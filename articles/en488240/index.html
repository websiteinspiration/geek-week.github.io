<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé§ üëû ü§æüèª An endless cycle that was not: the story of the Holy Grail bug üëß üöä üöù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once upon a time there was a game for GBA called Hello Kitty Collection: Miracle Fashion Maker. It was a cute game based on the famous Sanrio Hello Ki...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>An endless cycle that was not: the story of the Holy Grail bug</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488240/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once upon a time there was a game for GBA called Hello Kitty Collection: Miracle Fashion Maker. It was a cute game based on the famous Sanrio Hello Kitty franchise and developed by Imagineer. But under the guise of a seemingly innocent name was an insidious problem. For some reason, this simple game did not run on any GBA emulator. But this alone would not be enough to call the problem a bug of the Holy Grail. Like all the bugs of the Holy Grail, this bug itself was completely confusing. The explanation was simple: at some point in the sequence of starting the game, it fell into a cycle from which it never </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exited</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , waiting for a certain value to be read from a memory that </font><em><font style="vertical-align: inherit;">it does not exist</font></em><font style="vertical-align: inherit;"> . Although there are similar bugs in many games, for example, in the intro popular</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Legend of Zelda: The Minish Cap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , they rely on special behavior caused by reading invalid memory addresses. </font><font style="vertical-align: inherit;">But this cycle seemed to violate such behavior. </font><font style="vertical-align: inherit;">Nevertheless, the game worked on real equipment. </font><font style="vertical-align: inherit;">Moreover, the exact same bug occurred when loading a save into the Sonic Pinball Party after a cold reboot. </font><font style="vertical-align: inherit;">Could the expectation of these invalid memory addresses be somehow erroneous? </font><font style="vertical-align: inherit;">But if so, how?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/c85/547/1b0c8554787a8e54e1ac5c21c78d639c.png"></div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this is illegal, right?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wait a minute - if you are trying to access invalid memory, then the game just needs to crash, right? An unresolved operation, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segfault,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or some other error </font><font style="vertical-align: inherit;">should occur </font><font style="vertical-align: inherit;">. Right? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well it is more like Yes. But not really. At least not on the GBA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the architecture of the ARM processors that were used in GBA, this erroneous state is called data abort and occurs only when you try to access memory for which the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memory manager has</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> not assigned read permission </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . When data abort occurs, the processor completes what it was doing and goes to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the exception vector</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assigned to data abort exceptions. Then the operating system can choose one of the solutions: kill the current process, assign a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">page fault</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memory </font><font style="vertical-align: inherit;">, let the process cope with the situation, as some emulators JIT do it with ‚Äúfastmem‚Äù, or perform some other actions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How does the GBA handle data abort? The exception vector entry for data abort is located in the boot ROM of the GBA console (or, as it is also called, in the BIOS). If the GBA encounters data abort, then it tries to go to the DACS </font><sup><font style="vertical-align: inherit;">2</font></sup><font style="vertical-align: inherit;"> handler</font></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if it exists, otherwise blocking occurs. </font><font style="vertical-align: inherit;">No commercial game has DACS handlers. </font><font style="vertical-align: inherit;">So why is this game not freezing? </font><font style="vertical-align: inherit;">Everything is very simple - GBA never generates data abort. </font><font style="vertical-align: inherit;">It does not have a memory manager (MMU) (or even a memory protection unit, as in DS), so it just continues to work and reads out invalid memory.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The memory bus enters the scene.</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/dd9/55f/f75dd955f33d3a974b417f401fe054a6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is invalid memory in general? How does she look? This is the main snag. This is a difficult situation: what the code reads depends heavily on what the CPU recently did, or, more precisely, what the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memory bus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> did recently </font><font style="vertical-align: inherit;">. In short, when accessing an invalid memory, the CPU reads what was the last on the memory bus. To understand what follows from this, you need to learn a little about the memory bus and how it works.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A memory bus is part of an electronic circuit that connects the CPU to all the platform's memory components. On the GBA, several devices are connected to the memory bus: working RAM, video memory, and the cartridge bus. When the CPU tries to access the memory, it tells the memory bus which address it needs access to, and then the component corresponding to that address is activated. Then the component places the value at this address on the bus, which may take several </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cycles </font><font style="vertical-align: inherit;">, and then the CPU can finally read the value from the bus. In the case of the GBA, if no equipment is associated with the address, then no value is written to the bus, and the CPU reads any value placed </font><em><font style="vertical-align: inherit;">last</font></em><font style="vertical-align: inherit;"> on the bus</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The situation can vary in different ways, for example, if the read was 16-bit, and the CPU tries to perform 32-bit read, but in general it will always be a value from the bus. </font><font style="vertical-align: inherit;">Developers call this feature "open bus." </font><font style="vertical-align: inherit;">Earlier, I wrote how it affects </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">other games</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, it seems that everything doesn‚Äôt look so bad ... Right?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So you can just cache the last memory access? And then bring it back again? In the general case, this approach will work, but there are certain difficulties. First, you need to make sure that all memory access operations are in the correct order. This is more complicated than it sounds, because the CPU accesses the memory with each instruction to get the next instruction in the pipeline. And in fact, in the general case *, the memory stuck in the bus is the last instruction that was received. This simplifies the process, because you need to get only this last, pre-selected value. But since the last pre-selected value depends only on where we are currently executing from memory, it should always be the same. Even if the received address changes while it is invalid,you will always get the same memory.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uh ... Stop. </font><font style="vertical-align: inherit;">But this cycle exists, and it cannot be exited if this value is preselected. </font><font style="vertical-align: inherit;">So what is going on? </font><font style="vertical-align: inherit;">If he constantly receives the following instruction, then what happens between these operations? </font><font style="vertical-align: inherit;">I tried to run such endless loops on test ROMs to check if, for example, the value could go bad. </font><font style="vertical-align: inherit;">This can definitely happen if the value has not been updated recently, but the value is updated in each instruction, so it does not have time to get corrupted. </font><font style="vertical-align: inherit;">My tests never left the loop. </font><font style="vertical-align: inherit;">I did something different than in these games, although I recreated the cycle exactly. </font><font style="vertical-align: inherit;">What did I do wrong?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pok√©mon Emerald and ACE, occurring only on iron</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fast forward in time, in January 2020. The bug report at the Sonic Pinball Party at that time was about three and a half years old. In other emulators, he was known for many years. I have run out of working theories. At the end of this month, a user with the nickname </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merrp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">joined the Discord community of the mGBA emulator and said that Pok√©mon Emerald has a new arbitrary code execution glitch (ACE) that works only on hardware. Moreover, this glitch will most likely be used by speedrunners, who may want to practice the emulator. Obviously, this bug has become an attractive target for fixing the error, although it would be better if I found out about it before version 0.8.0. I began to research the glitch and confirmed the observation of merrp that it only works on hardware. In all the emulators I tried, the game hung with a black screen. But merrp informed me that it hangs on reading from invalid memory in a loop, and I realized that most likely I could not fix the error in the near future. This is again </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the same</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bug.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This time, learning about looping functions gave me an edge. Thanks to the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pokeemerald</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> decompilation </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">project,</font></a><font style="vertical-align: inherit;"> I could easily make targeted changes to the function to try to figure out how she managed to get out of the loop. A simplified version of this loop looks something like this:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint16_t</span> type = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> i = <span class="hljs-number">0</span>; table[type][i] != <span class="hljs-number">0xFFFF</span>; ++i) {
	<span class="hljs-keyword">uint16_t</span> value = table[type][i] &amp; <span class="hljs-number">0xFE00</span>;
	<span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0x7E00</span>) {
		<span class="hljs-keyword">break</span>;<font></font>
	}<font></font>
	<span class="hljs-comment">/* ... */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The loop performs a fairly simple task. There is a two-dimensional table of values. On each row of this column table, the </font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop first tries to determine if the value is a certain sentinel value. If so, the loop ends. Otherwise, it applies a mask to the value and checks if it is larger than the value being checked. Otherwise, it goes down the cycle. In a particular case of a glitch, the value </font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">goes beyond the boundaries of the table, which leads to the appearance of an invalid pointer. This means that when you try to access</font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To this element of this nonexistent column, we will always access invalid memory. Although the table offset increases with each iteration of the loop before returning to actual memory, it may need hundreds of millions of repetitions. Therefore, it is obvious that he does not. So how does a program get out of a loop?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To investigate this, I changed the cycle and looked at what would happen if I just instantly broke out of the cycle. </font><font style="vertical-align: inherit;">Everything turned out to be quite simple: at this moment ACE worked on both the hardware and the emulator, and nothing hung. </font><font style="vertical-align: inherit;">So instead, I tried to set the screen color to the value that the program reads when it exits the loop and freezes so that the color does not change. </font><font style="vertical-align: inherit;">I recompiled the code and ran it on a real GBA. </font><font style="vertical-align: inherit;">After a few seconds of freezing on a black screen, it became a gorgeous blue hue.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eq/e_/md/eqe_md60cly8igmztq2_kd2yigc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VERY BLUE</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
But the emulator still hung on a black screen. </font><font style="vertical-align: inherit;">What value will he read if he read the previously received value? </font><font style="vertical-align: inherit;">Instead, it became a dark turquoise.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sh/hf/6j/shhf6jyqkem0ulhbpzjuhc9hmi4.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fu.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
That is, the program, before it managed to get out of the cycle, most certainly passed it at least once. </font><font style="vertical-align: inherit;">It also turned out that the time required to escape from the cycle on iron varies. </font><font style="vertical-align: inherit;">This usually took 2 to 30 seconds. </font><font style="vertical-align: inherit;">What is going on?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New working theory</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then I noticed the difference between my test ROM and the Pok√©mon Emerald when it hung. Pok√©mon played music. Sonic Pinball Party also played music. Hello Kitty didn't play music, but it gave me an idea. What happens if an interrupt occurs between prefetching and data loading? Does the program start prefetching the interrupt vector before accessing the invalid memory? I quickly created a layout for this situation in mGBA, turned on interrupts in the test ROM, and of course it got out of the loop. Then I tried the same test ROM on hardware and ... it didn‚Äôt get out of the loop. And so the theory came about. In the end, I realized something. I‚Äôm sure that you noticed an asterisk above, so yes, there can be one event between prefetching and accessing memory,but only if, between the prefetch and access to invalid memory, the memory bus sends a request not to the CPU, but to something else.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I said that the memory bus is controlled by the CPU. For the most part, this is true, but there is other important equipment that also has access to the memory bus bypassing the processor. This process is called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direct memory access</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . I talked about DMA in a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">previous article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so now I will not go into the principles of its work. If you re-read the article, you may notice that I said that the main CPU pauses while DMA is running. This means that while DMA is running, the value on the bus will now be the last access to the DMA memory. This is mainly important if the DMA goes beyond the actual memory to an invalid region; however, it duplicates the last good value.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It has long been known that if you load invalid memory into DMA, you will get the last DMA value, but I implemented it in mGBA for a long time and already forgot about it. When I saw this in the access code for invalid memory when studying the bug, something clicked in my head. What if the DMA value lingers on the bus for one instruction? If the first instruction after DMA finishes loading the invalid memory before it gets the next value, then in theory this should lead to reloading the DMA value. Moreover, playing music in GBA typically uses DMA to transmit audio output. For the correct implementation of this, a tact-accurate emulator is required, which can block the CPU in the middle of the instruction execution, between the start of the instruction and memory access, and the GBA console emulation in the mGBA emulator is not tact-accurate.And this is something to me.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recalls</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Fortunately, I managed to get around this problem. </font><font style="vertical-align: inherit;">The solution is imperfect, but I can now compare the expected CPU address for the instruction after DMA with the current CPU address on an invalid load and use a single address instead of the pre-selected value for this DMA value.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The long-awaited decision</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I turned on the DMA operations for H-blank in the test ROM and synchronized them with V-blank so that the timings were stable, ran it on hardware, and ... this time it worked! The test ROM constantly exited the loop after the same number of iterations when the DMA value was read from the bus. I was right! For the correct implementation of this in mGBA, several attempts were required, but now the program exits the cycle with the same results as on the hardware. I finally got a shade of blue on mGBA. Hello Kitty has booted. Saving at the Sonic Pinball Party has earned. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I did it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This was probably the longest time I spent on a single bug. For three years, I invested so much time in debugging it that I lost count, and I am sure that other developers also faced similar situations in their emulators. Without this insight, it could have taken me another year, or even more, but the black screen, on which nothing happened except for playing music, became that domino tile that led to the collapse of the whole problem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now that the solution is found, it can be implemented in other GBA emulators, putting an end to this bug. The bug will be fixed in mGBA 0.9.0, which, I hope, will be released this year, and has already been fixed in test builds. You can finally play Hello Kitty Collection: Miracle Fashion Maker. Unless, of course, you wish, it is not for me to judge you.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34c/74c/fce/34c74cfce5ebbb092c5a55c9293ec0cb.png" alt="image"></div><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you try to execute memory that does not have execute permissions, this is called prefetch abort.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DACS (short for Debugging and Communication System) is part of the GBA development kit.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These idle cycles while reading from the bus are sometimes called wait states.</font></font></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en488224/index.html">Former TJ editor-in-chief about letters from the FSB: there will be a story of "Durov 2.0", but Habr will become the headliner</a></li>
<li><a href="../en488228/index.html">TOP 10 places and ideas for a geek date on February 14</a></li>
<li><a href="../en488230/index.html">Introduction to SSD. Part 3. Form factor</a></li>
<li><a href="../en488232/index.html">approx. tech: QATOK # 2</a></li>
<li><a href="../en488234/index.html">Using QubesOS for Windows 7</a></li>
<li><a href="../en488242/index.html">VueJS + TS Project Integration with SonarQube</a></li>
<li><a href="../en488244/index.html">How to reduce overhead when handling exceptions in C ++</a></li>
<li><a href="../en488246/index.html">VoiceOver on iOS: each control behaves differently</a></li>
<li><a href="../en488250/index.html">To the question of Linux (L)</a></li>
<li><a href="../en488252/index.html">How to reduce the cost of developing new products using SLS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>