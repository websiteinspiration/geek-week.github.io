<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📲 🖨️ 🤷🏽 RustでNESのライフゲームを作成する 👱 🎐 🏢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この投稿はRustプログラムについてです...
 
 

$ cargo install conway-nes
 ... NESバイナリの出力...
 
 

$ conway-nes > life.nes
 ...コンウェイゲーム「ライフ」を走らせる！
 
 

$ fceux life.nes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>RustでNESのライフゲームを作成する</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504262/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/380/aa2/539380aa23d7b4b3ac68d1c6851f89a6.webp" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この投稿はRustプログラムについてです...</font></font><br>
<br>
<pre><code class="rust hljs">$ cargo install conway-nes</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... NESバイナリの出力...</font></font><br>
<br>
<pre><code class="rust hljs">$ conway-nes &gt; life.nes</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...コンウェイゲーム「ライフ」を走らせる！</font></font><br>
<br>
<pre><code class="rust hljs">$ fceux life.nes    # fceux is a NES emulator</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エミュレータでゲームを起動した後、コントローラの任意のボタンを押して、ランダム化された状態から再開します。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NESレンダリング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NESは2種類のグラフィックスを表示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/d4f/928/b71d4f9286228ac795104a675b2b7aeb.webp"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スプライトと背景</font></font></i><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スプライト</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、特定のピクセル座標に配置できる8x8ピクセルのタイルです。</font><font style="vertical-align: inherit;">これらは通常、ゲームのキャラクターやオブジェクトに使用されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/188/05d/229/18805d2295e8eb44f8b84a35d8af115c.webp"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スプライトの</font></font></i><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景</font></font></em><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">のみ</font></i><font style="vertical-align: inherit;">が、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nametable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれる8x8ピクセルのタイルの2Dグリッドです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">個々のタイルを置き換えることができ、背景全体にスムーズにスクロールする機能があります。</font><font style="vertical-align: inherit;">通常、ほとんどが静的な背景とユーザーインターフェイス要素に使用されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c46/6d4/4c8/c466d44c8b69fe8cadb20d13eabaae74.webp"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景のみ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Conwayゲーム "Life"の場合、背景のみをレンダリングし、nametable要素を置き換えて、セルの状態に従ってタイルのグリッドを更新します。</font><font style="vertical-align: inherit;">NESグラフィックハードウェアは、名前テーブルに頻繁で大きな変更を加えるために最適化されていません。</font><font style="vertical-align: inherit;">幸いなことに、ライフゲームのフレーム内のほとんどの変更は比較的小さなものです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f31/489/902/f31489902d4072ff7443a42ddddf7443.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d64/ecb/e79/d64ecbe7910bfef6bf197685459fc074.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各セルの生存確率が50％であるランダムな状態から始めると、最初の数フレームはフレーム間で大きな違いがあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a6/dad/341/8a6dad341160f92619b06d5614621ad9.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/171/725/ce5171725be416413c8e2c0de49428c2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NESプロセッサは、グラフィック機器のフレームレート（特に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逆スイープをブランキング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">間隔</font></a><font style="vertical-align: inherit;">）に比べて遅すぎて、各フレームの名前テーブル全体を更新できないため、フレーム間の差が大きい場合、更新を完了するためにいくつかのフレームが必要になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lifeの1つの世代をレンダリングするために、レンダラーは可変数のフレームを必要とします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、世代間の変化がそれほど重要でない場合は少なくなります。</font><font style="vertical-align: inherit;">フレームレートの変動がはっきりとわかるスローモーションの記録を次に示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dbf/759/f97/dbf759f97ee8f070b65fe80957c21769.webp"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NES背景グラフィックスの簡単な紹介</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
背景の名前テーブルはビデオメモリに保存されます。このメモリはグラフィックチップに接続されており、中央プロセッサはメモリに直接アクセスできません。名前テーブルの各要素は1バイトで、</font><font style="vertical-align: inherit;">タイルフォームを含む</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターンテーブルの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスとして扱われ</font><font style="vertical-align: inherit;">ます。 NES画面の解像度は256x240ピクセルまたは8x8ピクセルの32x30タイルであるため、32 x 30 = 960要素が名前テーブルに保存されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CPUは、メモリ内のディスプレイを持つレジスタのペア（具体的には0x2006および0x2007）を書き込むことにより、名前テーブルを更新します。 2つの順次書き込み操作用の1つのレジスタが、現在のビデオメモリアドレスを設定します（ビデオメモリアドレスは2バイトで構成されますが、レジスタの幅は1バイトのみです）。 2番目のレジスタは、現在のビデオメモリアドレスと現在のアドレスの増分にデータバイトを書き込むために使用されます。これにより、要素ごとに1エントリの名前付き順序要素のシーケンスを指定でき、さらに最初の2エントリでシーケンスの開始アドレスを指定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このレジスタペアへのアクセスは、フレームごとに1回、2273 CPUサイクル（約1.27 ms）の周期に等しい逆スイープ（VBLANK）のブランキング期間中にのみ可能です（NESは60 FPSを生成します）。</font><font style="vertical-align: inherit;">この間、グラフィック機器は表示を更新しません。</font><font style="vertical-align: inherit;">これはそれほど長い時間ではないので、VBLANK間隔以外の時間をもう少し費やすことで、すべてがよりスムーズに実行されるようにする価値があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更されたものを再描画するだけです</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のレンダリング戦略は次のとおりでした：VBLANK間隔の外側の時間の一部を使用して、連続する状態の各ペア間の差異を見つけ、</font><font style="vertical-align: inherit;">更新が必要な名前テーブルのすべての部分とそれらが何である必要があるかをリスト</font><font style="vertical-align: inherit;">する</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリングキュー</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成</font><font style="vertical-align: inherit;">します交換してください。次に、VBLANKの実行中に、変更を適用して描画キューを繰り返しバイパスします。変更が少なければ少ないほど、時間がかかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conway’s Lifeの各セルは生きているか死んでいるので、各セルの現在の状態を示すために1ビットだけを使用します。各名前テーブルタイルはセルを示します。つまり、960個のセルがあり、960/1 =セルの1つの世代を記述するために120バイトが必要です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08c/c1b/dca/08cc1bdca18e8e0737d8cd55253cdcfb.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f30/799/a0a/f30799a0afd3ae8d8449bff5f1f38983.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームの現在の世代を計算するには、前の世代を変更しないでおく必要があります。これは、メモリ内の任意の時点で現在および前の世代であることを意味します。現在の世代の各バイトと前の世代の各バイトのビット単位のXORは、変更されたバイトをすばやく検出する方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の第2世代は、前の世代の対応するバイトとのビット単位のXORの結果が0の場合（つまり、2つの世代間でこのバイトに変更がなかった場合）、バイトは黒でマークされています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78a/6b7/270/78a6b72706bd3614c0571b2a4e2f798b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在のビデオメモリアドレスはビデオメモリに記録されるたびに増加するため、8タイルの2つの連続するバンド間でビデオメモリアドレスを明示的に設定する必要はありません。</font><font style="vertical-align: inherit;">したがって、レンダリングキューは、</font><font style="vertical-align: inherit;">8タイルの</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一連の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">連続したバンドの</font><font style="vertical-align: inherit;">シーケンスです</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最適化のために、レンダリングキューはメモリの最初の256バイトに格納されます。これは、他のメモリ領域よりもこの領域に高速にアクセスするための特別なコマンドがあるためです。</font><font style="vertical-align: inherit;">レンダリングキューは、次のような可変長ブロックで構成されています。</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面上の位置</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：0から119の範囲の1バイトは、更新されているバイトを示します。</font><font style="vertical-align: inherit;">この値をビデオメモリアドレスに変換するには、8を掛けてから、ベースアドレスの名前テーブルを追加する必要があります。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：タイルデータのバイト数を示す1バイト。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイルデータ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">各バイトの値がLifeの現在の世代のセルの状態を示す</font><font style="vertical-align: inherit;">一連の</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Size</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイト。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レンダリングキューは負の画面位置で終了します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例のレンダーキューの最初のいくつかの要素は次のとおりです。</font></font><br>
<br>
<blockquote><code>  : 8<br>
: 1<br>
:<br>
0x00 (0b00000000)<br>
<br>
  : 10<br>
: 1<br>
:<br>
0x80 (0b10000000)<br>
<br>
  : 12<br>
: 1<br>
:<br>
0x1C (0b00011100)<br>
<br>
  : 14<br>
: 2<br>
:<br>
0x80 (0b10000000)<br>
0x00 (0b00000000)</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更新は一度にバイト単位で示されるため、一部のタイルの更新（実際には多くの更新）は冗長です（つまり、nametable要素はすでに持っている値に更新されます）。</font><font style="vertical-align: inherit;">バイト全体で操作する方が便利であり、これにより状態のコンパクトな記述が可能になりますが、このアプローチにはコストがかかります。</font><font style="vertical-align: inherit;">ディテールを増やして表示を更新することで生産性を大幅に向上させることができても驚くことではありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイミング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的な状況では、グラフィックハードウェアがディスプレイの更新でビジー状態の間、すべてのアプリケーションロジックがVBLANK間隔の外で実行される必要があります。</font><font style="vertical-align: inherit;">次に、レンダラーを呼び出す必要があります。</font><font style="vertical-align: inherit;">VBLANKが開始するのを待ってから、名前付き要素の更新を開始し、VBLANKが完了するまでレンダリングキュー全体を処理します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05e/385/2e3/05e3852e3247dd2a5a2bf09865949562.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、実際には、レンダリングキューの処理に数フレームかかることがよくあります。</font><font style="vertical-align: inherit;">VBLANKの完了が近づくと、レンダラーは次のVBLANKの開始までそのまま残り、終了したところから続行します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dba/d01/797/dbad017974005c56a1dc5f73831067b3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VBLANK間隔中に名前テーブルに加えられたすべての変更は、次に表示が更新されるときに表示されます。</font><font style="vertical-align: inherit;">そのため、低いフレームレートでは、垂直方向の消去アーティファクトが顕著になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、各フレームに記録された名前付き要素の視覚化です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/380/aa2/539380aa23d7b4b3ac68d1c6851f89a6.webp" alt="怠惰な"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上のアニメーションは、各フレームに記録されている名前付きの場所を示しています。</font><font style="vertical-align: inherit;">各名前テーブルは1バイトで</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、パターンテーブルの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスとして扱われ</font><em><font style="vertical-align: inherit;">ます</font></em><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">パターンテーブルは、256 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターン</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を含む4KBビデオメモリ領域です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">パターンは、16バイト= 8 x 8 = 64ピクセルのタイルの128ビットの説明であり、ビットの各ペアがピクセルの色を決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lifeゲームでは、すべてのセルが生きているか死んでいるので、解決策の1つは2つのパターンを使用することです。</font><font style="vertical-align: inherit;">パターン0は死んだ細胞、パターン1-生細胞を示します。</font><font style="vertical-align: inherit;">残りのパターンは使用されません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c5/790/248/4c579024821ff94efde319ea2f340697.png" alt="素朴なパターン"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nametable要素にゼロを書き込むと、対応する背景タイルはデッドセルになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/a23/d06/9dea23d06e0e9a3e4f7be9303abc1bd5.png" alt="デッド"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユニットを記録すると、生細胞が表示されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a7/746/133/9a77461335e99554839df7fbc2dbe02d.png" alt="生きている"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
描画キューでは、8タイルの各水平ストリップは1バイトで表され、各ビットはセルの状態をエンコードします。バイトをレンダリングするには、各ビットを繰り返しトラバースし、ビット値をグラフィック機器に送信します。</font></font><br>
<br>
<pre><code class="rust hljs"><span class="hljs-comment">// Note that this is pseudocode!</span>
<span class="hljs-comment">// I don't compile rust to run on the NES.</span>
<span class="hljs-comment">// I write assmebly in a rust DSL. See below.</span><font></font>
<font></font>
<span class="hljs-comment">// assume video memory address is already set correctly</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> byte_to_render = next_byte_from_draw_queue();
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">8</span> {<font></font>
<font></font>
    <span class="hljs-comment">// take the current bit</span>
    <span class="hljs-keyword">let</span> pattern_index = byte_to_render &amp; <span class="hljs-number">1</span>;<font></font>
<font></font>
    <span class="hljs-comment">// assume this increments the current video memory address</span><font></font>
    write_to_video_memory(pattern_index);<font></font>
<font></font>
    <span class="hljs-comment">// right shift so the next bit can be tested</span>
    byte_to_render = byte_to_render &gt;&gt; <span class="hljs-number">1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなシステムは機能しますが、改善することができます。 NES中央処理装置には、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドライブ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれる1つの汎用レジスターしかありません</font><font style="vertical-align: inherit;">。ビットごとのANDでは、現在のドライブ値がAND演算の結果に置き換えられます。右にシフトして次のビットを読み取るに</font><font style="vertical-align: inherit;">は、ドライブの元の値</font><font style="vertical-align: inherit;">を</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コピーし、</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANDを実行して1から現在のビットを取得し、結果をビデオメモリに書き込んで</font><font style="vertical-align: inherit;">から、右にシフトする前に作成したコピーからドライブの元の値を</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">復元する</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要があります。これはすべて、前のVBLANK間隔中に行う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の</font></font><code>pattern_index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、正確に1に等しい</font><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">注意してください。</font></font><code>byte_to_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">奇数。</font><font style="vertical-align: inherit;">パターンテーブルには256の要素が含まれているため、可能なすべてのバイトが有効な名前付き要素です。</font><font style="vertical-align: inherit;">私たちは、から現在のビットを読み込む必要を取り除くことができます</font></font><code>byte_to_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ように、我々はパターンテーブルを設定した場合</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すべての</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">奇数名前テーブルの要素が生細胞に対応し、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全ての</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">死細胞にさえもの。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パターンテーブルの形式は次のとおりです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66b/73b/eba/66b73beba74567f5e4c6e03379a28db0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各偶数の要素は死んでおり、各奇数は生きています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイトレンダリングコードは簡略化できます。</font></font><br>
<br>
<pre><code class="rust hljs"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> byte_to_render = next_byte_from_draw_queue();
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">8</span> {
    <span class="hljs-comment">// assume this increments the current video memory address</span><font></font>
    write_to_video_memory(byte_to_render);<font></font>
<font></font>
    <span class="hljs-comment">// right shift so the next bit can be tested</span>
    byte_to_render = byte_to_render &gt;&gt; <span class="hljs-number">1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは単純なアセンブラコードに変換されます。</font></font><br>
<br>
<pre><code class="cpp hljs">INX        ; increment X index <span class="hljs-keyword">register</span> - the pointer into draw <span class="hljs-built_in">queue</span>
LDA $<span class="hljs-number">00</span>,X  ; read next byte from draw <span class="hljs-built_in">queue</span> into accumulator<font></font>
<font></font>
; unrolled loop<font></font>
<font></font>
STA $<span class="hljs-number">2007</span>  ; store accumulator value at address <span class="hljs-number">0x2007</span>, which writes it to video memory<font></font>
LSR        ; right shift the accumulator<font></font>
STA $<span class="hljs-number">2007</span>  ; writing <span class="hljs-number">0x2007</span> increments the current video memory address so repeatedly<font></font>
LSR        ;   writing <span class="hljs-number">8</span> times will populate <span class="hljs-number">8</span> consecutive nametable entries<font></font>
STA $<span class="hljs-number">2007</span><font></font>
LSR<font></font>
STA $<span class="hljs-number">2007</span><font></font>
LSR<font></font>
STA $<span class="hljs-number">2007</span><font></font>
LSR<font></font>
STA $<span class="hljs-number">2007</span><font></font>
LSR<font></font>
STA $<span class="hljs-number">2007</span><font></font>
LSR<font></font>
STA $<span class="hljs-number">2007</span></code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さび？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1年ほど前、私はRust </font><font style="vertical-align: inherit;">で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NESエミュレーター</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作成し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">、NESが</font></a><font style="vertical-align: inherit;">それをテストするための簡単なプログラムを書きたかったのです。</font><font style="vertical-align: inherit;">MOS6502（NESプロセッサ）用のアセンブラプログラム</font><font style="vertical-align: inherit;">を作成するために、小さな</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mos6502_assembler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rustライブラリを作成しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">エミュレーターの一部として私が作成した</font><font style="vertical-align: inherit;">別の小さな</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rustライブラリーを</font><font style="vertical-align: inherit;">使用すると</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NES ROMファイルを、</font><font style="vertical-align: inherit;">すべてのNESエミュレーターが理解する標準のファイル形式</font><font style="vertical-align: inherit;">である</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INES</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形式で</font><em><font style="vertical-align: inherit;">読み書き</font></em><font style="vertical-align: inherit;">できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="rust hljs"><span class="hljs-comment">// Function to read the state of the controller into address 0x00FF</span>
b.label(<span class="hljs-string">"controller-to-255"</span>);
<span class="hljs-keyword">const</span> CONTROLLER_REG: Addr = Addr(<span class="hljs-number">0x4016</span>);<font></font>
<font></font>
<span class="hljs-comment">// toggle the controller strobe bit to copy its current value into shift register</span>
b.inst(Lda(Immediate), <span class="hljs-number">1</span>);<font></font>
b.inst(Sta(Absolute), CONTROLLER_REG); <span class="hljs-comment">// set controller strobe</span>
b.inst(Sta(ZeroPage), <span class="hljs-number">255</span>); <span class="hljs-comment">// store a 1 at 255 - used to check when all bits are read</span>
b.inst(Lsr(Accumulator), ()); <span class="hljs-comment">// clear accumulator</span>
b.inst(Sta(Absolute), CONTROLLER_REG); <span class="hljs-comment">// clear controller strobe</span><font></font>
<font></font>
<span class="hljs-comment">// shift each of the 8 bits of controller state from the shift register into address 255</span>
b.label(<span class="hljs-string">"controller-to-255-loop"</span>);<font></font>
b.inst(Lda(Absolute), CONTROLLER_REG); <span class="hljs-comment">// load single bit into LBS of acculumator</span>
b.inst(Lsr(Accumulator), ()); <span class="hljs-comment">// shift bit into carry flag</span>
b.inst(Rol(ZeroPage), <span class="hljs-number">255</span>); <span class="hljs-comment">// shift carry flag into 255, and MSB of 255 into carry flag</span><font></font>
<font></font>
<span class="hljs-comment">// if that set the carry flag, this was the 8th iteration</span>
b.inst(Bcc, LabelRelativeOffset(<span class="hljs-string">"controller-to-255-loop"</span>));<font></font>
<font></font>
b.inst(Rts, ()); <span class="hljs-comment">// return from subroutine</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エミュレータが命令をデコードしてエミュレートするには、エミュレータが各命令のオペコードと引数の回路を知っている必要があります。</font><font style="vertical-align: inherit;">アセンブラは、プロセッサプログラム6502に対応するバイナリコードを生成するために同じ情報を必要とします。命令の定義は、私のエミュレータのコア- </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rustライブラリ：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mos6502_model</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から直接取得されます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このライブラリを作成するとき、エミュレータとアセンブラの両方で使用できるように、各命令にもう少し作業が必要でしたが、これは、命令の情報が1か所にあることを意味します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予備処理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アセンブラーを汎用プログラミング言語に組み込むことにより、この基本言語（この場合はRust）を強力なプリプロセッサーとして使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコード例では、コントローラーレジスタアドレスが</font></font><code>0x4016</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数Rustに割り当てられてい</font></font><code>CONTROLLER_REG</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。名前に値を割り当てる機能は、ほとんどのアセンブラーの標準ですが、アセンブラーが汎用言語に組み込まれている場合、必要なのは、変数/定数に値を割り当てることだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを使用するもう1つの利点は、アセンブラループの代わりに基本言語ループを使用できることです。ループが小さい一定の回数繰り返された場合、そのコードを複数回繰り返すことによるループ展開は、アセンブラループを記述するよりも速くて簡単です。</font></font><br>
<br>
<pre><code class="ruby hljs">/<span class="hljs-regexp">/ zero-out first 8 bytes of memory
b.inst(Lda(Immediate), 0);
for i in 0..8 {
    b.inst(Sta(ZeroPage), i);
}</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6502プロセッサには3つのレジスタしかないため、ネストされたループを持つコードでは、通常、ループカウンターを格納するのに十分なレジスタがありません。</font><font style="vertical-align: inherit;">しかし、これは災害ではありません。サイクルカウンターをメモリに格納できますが、非常に不便であり、ランタイムに影響するため、この手法を使用して負荷を軽減します。</font><font style="vertical-align: inherit;">もちろん、コードのサイズを大きくすることでこれを支払う必要があります。</font><font style="vertical-align: inherit;">より現代的なアーキテクチャで作業した場合、それが局所性に悪影響を与え、キャッシュミスの数を増加させることに言及しますが、6502にはキャッシュがありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検証</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
埋め込みのもう1つの利点は、基本言語型システムを使用して「ゲスト」プログラムのプロパティを検証できることです。</font><font style="vertical-align: inherit;">ドライブ（アキュムレータ）の値をメモリに格納（記憶）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
する命令について考えてみ</font></font><code>STA</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">プロセッサ6502では、メモリアドレス引数を受け取る命令は、引数がアドレスにどのようにマッピングされるかを決定する「アドレッシングモード」によってパラメータ化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例では、行があります...</font></font><br>
<br>
<pre><code class="ruby hljs">const <span class="hljs-symbol">CONTROLLER_REG:</span> Addr = Addr(<span class="hljs-number">0x4016</span>);<font></font>
b.inst(Sta(Absolute), CONTROLLER_REG);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...絶対アドレス指定モード（absolute）と引数0x4016があります。</font><font style="vertical-align: inherit;">絶対アドレッシングモードは、メモリ内のオペコード命令の次の2バイトを読み取り、それらをアドレスとして扱います（6502ではアドレスは16ビットです）。</font><font style="vertical-align: inherit;">この行は、現在のドライブ値を0x4016に保存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の行...</font></font><br>
<br>
<pre><code class="ruby hljs">b.inst(Sta(ZeroPage), <span class="hljs-number">255</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...「ゼロページ」アドレッシングモード（ゼロページ）と引数255（16進数で0xFF）があります。ゼロページアドレッシングモード</font><font style="vertical-align: inherit;">は、命令オペコードの後の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイトを</font><font style="vertical-align: inherit;">読み取り</font><font style="vertical-align: inherit;">、それをメモリの最初の256バイトのインデックス（つまり、6502用語の「ゼロページ」）として扱います。この行は、現在のドライブ値をアドレス0x00FFに保存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「即時」をアドレス指定する3番目のモードは、命令のオペコードの後の1バイトを読み取り、それをアドレスとしてではなく、リテラル値として扱います。</font></font><br>
<br>
<pre><code class="ruby hljs">b.inst(Lda(Immediate), <span class="hljs-number">42</span>); <span class="hljs-regexp">//</span> Load the accumulator with the value <span class="hljs-number">42</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、命令</font><font style="vertical-align: inherit;">がメモリから</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読み取る</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合にのみ重要</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">現在のドライブ値をリテラル値として保存することは意味がないため、STAでイミディエイトアドレッシングモードを使用することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
無効な命令のコンパイルを許可しないチェックを作成する代わりに、有効なアドレッシングモードを型システムにエンコードしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このように書こうとすると......</font></font><br>
<br>
<pre><code class="ruby hljs">b.inst(Sta(Immediate), <span class="hljs-number">42</span>); <span class="hljs-regexp">//</span> Store the accumulator with the value <span class="hljs-number">42</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...それからこれはタイプ不一致エラーになります：</font></font><br>
<br>
<blockquote><code>error[E0277]: the trait bound<br>
 `mos6502_model::addressing_mode::Immediate: mos6502_model::instruction::sta::AddressingMode`<br>
 is not satisfied<br>
 --&gt; conway/src/main.rs:609:5<br>
 |<br>
609 | b.inst(Sta(Immediate), 42); // Store the accumulator with the value 42<br>
 | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `mos6502_model::instruction::sta::AddressingMode`<br>
 | is not implemented for<br>
 | `mos6502_model::addressing_mode::Immediate`<br>
 |<br>
 = note: required by `mos6502_model::instruction::sta::Inst`<br>
</code></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム「ライフ」</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
960セルの状態は120バイトの配列に格納され、単純な乱数ジェネレーター（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32ビットXorshift</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を使用してランダムな値で初期化されます</font><font style="vertical-align: inherit;">。そのシードは、起動後のフレーム数です。</font><font style="vertical-align: inherit;">マシンの第2世代を計算すると、2番目の120バイトの配列が新しいセル状態で埋められます。</font><font style="vertical-align: inherit;">3番目の世代はセルの最初の状態を上書きし、4番目-2番目の状態を上書きします。</font><font style="vertical-align: inherit;">いつでも、前の2世代のセルが1組のアレイに存在します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一度に8つのセルを更新</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ステータスバイトは8つのセルの状態を記述するため、一度に8つのセルの新しい状態、つまり一度に1つのステータスバイトを計算すると便利です。現在のバイトの各ビットについて、このビットは現在のセルに隣接する生きているセルの数を表します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8つのネイバーすべてのカウントは同時に行われます。このため、各バイトについて、メモリから9バイトのみを読み取る必要があります（8つの隣接バイトと現在のバイト自体）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eae/342/0aa/eae3420aa960c3b2d7b2805b345d2cc1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生存セルの隣接セルの数を増やす方法は、隣接セルが配置されている隣接バイトによって異なります。</font><font style="vertical-align: inherit;">たとえば、バイトが現在のバイトより上にある場合、各ビットは現在のバイトの対応するビットの隣であり、左に1ビット、右に1ビットです（対角の隣も隣と見なされます）。</font><font style="vertical-align: inherit;">現在のバイトの左下にあるバイトでは、左端のビットのみを考慮する必要があります。</font><font style="vertical-align: inherit;">このビットで表されるセルは、現在のバイトの右端のビットにのみ隣接しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e4/44f/b0a/4e444fb0adafdd0d877cbf06f9077974.png" alt="3x3-2"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8つのセルのそれぞれのすべての生きている隣人がカウントされた後、生きている隣人の数に応じて、次世代の対応するセルの状態が選択されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事前計算されたネイバー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8セルのストリップの次の状態を計算するには、4x30バイトグリッド内の8つの隣接バイトを考慮する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/630/ac0/23c/630ac023c9f70629b3eb896a7df2ab7f.png" alt="暗くなった"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のインデックスを持つセルの隣接セルのインデックスを計算することは簡単なタスクですが、120バイトのそれぞれの8つの隣接セルを計算することは、特に一部の側のグリッドのエッジに沿ったバイトにはないため、NESが各フレームで実行する必要のある重要な作業です。隣人。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グリッドの最初の数行のインデックスは次のとおりです。</font></font><br>
<br>
<blockquote><code> 0 | 1 | 2 | 3<br>
 4 | 5 | 6 | 7<br>
 8 | 9 | 10 | 11<br>
 ...<br>
</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rustで生成されたROMコードは、各バイトのネイバーのインデックスを、上、下、左、左上、左下、右、右上、右下の順序で事前計算します。</font></font><br>
<br>
<blockquote><code>X,4,X,X,X,1,X,5 | X,5,0,X,4,2,X,6 | X,6,1,X,5,3,X,7 | X,7,2,X,6,X,X,X<br>
0,4,X,X,X,5,1,9 | 1,9,4,0,8,6,2,10 | 2,10,5,1,9,7,3,11 | 3,11,6,2,10,X,X,X<br>
...<br>
</code></blockquote><br><font style="vertical-align: inherit;"></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この表</font><font style="vertical-align: inherit;">
の記号</font><font style="vertical-align: inherit;">は、バイトがグリッドの端にあるため、存在しない近隣を示します。</font><font style="vertical-align: inherit;">事前計算されたネイバーのテーブル</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">代わりに</font><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用します</font></font><code>120</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">状態には、0から119の範囲のインデックスを持つ120バイトがあります。状態の最後のバイトの後、オフセット120に値0を格納します。したがって、そのようなネイバーを持たないバイトの隣の隣接バイトを読み取るとき、代わりに0が読み取られます。グリッドの可視領域は、常に死んでいるセルの境界線によって囲まれます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NESに関連するすべてのRustライブラリと実行可能ファイルは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このリポジトリにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悪い決断</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が最初にLifeゲームを実装してシンプルな</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グライダー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成で起動したとき</font><font style="vertical-align: inherit;">、それは通常は機能しましたが、フレーム間の差がゼロになるとすべてが崩壊しました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74a/eb9/b85/74aeb9b85c9f679915615ec6bbc3c904.webp"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レンダリングキューに入力するとき、フレーム間に違いがない条件は考慮しませんでした。</font><font style="vertical-align: inherit;">その結果、レンダラーがループに陥り、ビデオメモリが更新されます。</font><font style="vertical-align: inherit;">VBLANK間隔外で現在のビデオメモリアドレスを更新することによって引き起こされる視覚的なアーティファクト。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アニメーションの中央付近に、画面が揺れるフレームがあります（プログラムが完全にzabagatの前に）。</font><font style="vertical-align: inherit;">これは、進行中のレンダリングレンダラーがVBLANKの終わりをわずかに超えて、上記のように現在のビデオメモリアドレスを更新したためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回の投稿で、これらの不具合をより詳細に説明し、ゼルダの伝説の最初の部分でスクロールの実装にどのように使用されたかを示しました：</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ゼルダの伝説の画面間の遷移は、NESの文書化されていない機能を使用しています</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">」</font></a></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja504252/index.html">将来の小売プロセスの触媒としてのパンデミック</a></li>
<li><a href="../ja504254/index.html">ムーアの法則を超えて</a></li>
<li><a href="../ja504256/index.html">クラウドベース</a></li>
<li><a href="../ja504258/index.html">未来が来ている：中国のロボットがロシアに来る</a></li>
<li><a href="../ja504260/index.html">大規模モバイルアプリケーション向けのスケーラブルなアーキテクチャ</a></li>
<li><a href="../ja504264/index.html">Huawei Review Comment：Wi-Fi 6の投稿にコメントして賞品を獲得</a></li>
<li><a href="../ja504266/index.html">清潔さはデータセンターのエネルギー効率の鍵、またはディーゼル発電機の手入れがSLAにどのように影響するか</a></li>
<li><a href="../ja504268/index.html">Grafanaでkubernetesクラスターを監視するためのDevOpsProdigy KubeGrafプラグインの新バージョンのリリース</a></li>
<li><a href="../ja504270/index.html">Svelteはウィジェットの実装に適していますか？</a></li>
<li><a href="../ja504276/index.html">トップ10開発者向け書籍</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>