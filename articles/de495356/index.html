<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹️ 🏸 👩🏼‍🤝‍👨🏻 Implementierung des RAFT-Konsensalgorithmus für verteilten KV-Speicher in Java 👍🏻 🌐 🤱🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo wieder. Vor einigen Tagen begann die Ausbildung in einer neuen Gruppe zum Kurs „Software Architect“ . Heute möchten wir einen Artikel teilen, de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Implementierung des RAFT-Konsensalgorithmus für verteilten KV-Speicher in Java</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/495356/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo wieder. Vor einigen Tagen begann die Ausbildung in einer neuen Gruppe zum Kurs </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Software Architect“</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Heute möchten wir einen Artikel teilen, der von einem der Kursteilnehmer, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anton Pleshakov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Entwicklungsleiter bei Program Logistics und Mitbegründer bei Clusterra), verfasst wurde.</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/pb/5h/qq/pb5hqqeunfv8gkvyvspmegwuj4w.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Derzeit sind verteilte Microservice-Systeme nicht nur in der Unternehmenswelt zum Industriestandard geworden. Die Vorteile der Verwendung verteilter Systeme wurden mehr als einmal beschrieben und diskutiert. Die Vorteile von Microservices sind seit langem allen bekannt: Technologien für die Aufgabe, Kompositionsfähigkeit, Skalierbarkeit, Entwicklungsskalierung, TTM-Reduzierung usw. Es ist offensichtlich, dass die Entwicklung verteilter Anwendungen mehr Optionen bietet, um rechtzeitig auf wachsende Geschäftsanforderungen zu reagieren und alles zu digitalisieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist auch wichtig anzumerken, dass derzeit ein sehr wichtiger Faktor für die Wahl einer Entwicklungsstrategie zugunsten von Microservices die Verfügbarkeit aller Arten von vorgefertigten Infrastrukturlösungen ist, die die Lösung von Problemen übernehmen, die mit den zusätzlichen Kosten für den Betrieb eines verteilten Systems verbunden sind. Wir sprechen über Container-Orchestrierungssysteme, Service-Mash, Mittel zur verteilten Ablaufverfolgung, Überwachung, Protokollierung usw. Es kann mit Sicherheit festgestellt werden, dass die meisten Faktoren, die zuvor als Minuspunkte des heutigen Microservice-Ansatzes genannt wurden, nicht mehr so ​​viel Einfluss haben wie vor ein paar Jahren.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf modernen Realitäten suchen die meisten Entwickler nach der ersten Möglichkeit, von einer monolithischen Struktur zu einer Microservice-Struktur zu wechseln. Einer der ersten Schritte, die unternommen werden können, ohne auf eine vollständige Umgestaltung und ernsthafte Zerlegung zurückzugreifen, ist die Erzielung eines horizontalen Skalierbarkeitssystems. Das heißt, Sie verwandeln Ihre monolithische Anwendung in einen Cluster, der möglicherweise sogar aus denselben Monolithen besteht, aber es Ihnen ermöglicht, deren Anzahl dynamisch zu variieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Versuch, eine horizontale Skalierbarkeit zu erreichen, stellt sich die Frage der Datensynchronisation innerhalb eines Clusters sehr schnell und sehr akut. Glücklicherweise unterstützen alle modernen DBMS die Datenreplikation zwischen Knoten auf die eine oder andere Weise. Der Entwickler muss nur das DBMS für die Aufgabe auswählen und entscheiden, welche Eigenschaften des Systems (gemäß dem CAP-Theorem) er benötigt, CP oder AP, und das Problem ist behoben. In dem Fall, in dem CP erforderlich ist und die Anforderungen an die Konsistenz hoch sind, besteht eine der Methoden zur Lösung des Problems der Datensynchronisation darin, einen Cluster zu verwenden, der den RAFT-Konsensalgorithmus unterstützt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser ziemlich neue Algorithmus (wurde 2012 entwickelt) bietet eine hohe Konsistenzgarantie und ist sehr beliebt. Ich beschloss herauszufinden, wie es funktioniert, und schrieb meine Implementierung eines konsistenten Schlüsselwert-Repositorys in Java (Spring Boot).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ist es sinnvoll, einen verteilten Algorithmus selbst zu implementieren? Es ist klar, dass Sie eine vorgefertigte Implementierung eines verteilten Algorithmus durchführen können, und mit der höchsten Wahrscheinlichkeit ist diese Implementierung besser als ein selbst hergestelltes „Fahrrad“. Beispielsweise können Sie ein DBMS verwenden, das die erforderliche Konsistenzstufe beibehält. Oder Sie können </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zookeeper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bereitstellen </font><font style="vertical-align: inherit;">. Oder Sie finden einen Rahmen, der zu Ihrer Sprache passt. Für Java gibt es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atomix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das die Probleme der Synchronisierung verteilter Daten perfekt löst.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber auf der anderen Seite. Wenn Sie eine schlüsselfertige Lösung wählen, führt die Verwendung einer externen Anwendung normalerweise zu einem zusätzlichen Fehlerpunkt für Ihr System. Und Frameworks können redundant oder schwierig zu bedienen und zu erlernen sein oder für Ihre Programmiersprache überhaupt nicht vorhanden sein. Darüber hinaus ist die unabhängige Implementierung des Konsensalgorithmus eine äußerst interessante technische Aufgabe, die Ihren Horizont erweitert und Ihnen ein Verständnis dafür vermittelt, wie Sie die Probleme lösen können, die auftreten, wenn Dienste in einem Cluster mit der optimaleren Methode interagieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Spezifikation des Algorithmus eine Reihe von Maßnahmen zur Aufrechterhaltung der Datenintegrität enthält, können Sie das erworbene Wissen und sogar den Algorithmus in seiner Gesamtheit verwenden. Jeder Teil des Algorithmus kann im wirklichen Leben nützlich sein. Angenommen, Sie haben eine Reihe von Workern zum parallelen Parsen von Dateien. Arbeiter sind gleichwertig, aber Sie möchten einen der Arbeiter als Koordinator bestimmen, und wenn der koordinierende Arbeiter fällt, weisen Sie einen anderen freien Arbeiter als Koordinator zu. Die erste Hälfte des RAFT-Algorithmus, in der beschrieben wird, wie ein Leader unter äquivalenten Knoten ausgewählt wird, hilft Ihnen dabei. Wenn Sie beispielsweise nur zwei Knoten in Bezug auf Master-Slave haben, können Sie die in der RAFT-Spezifikation beschriebenen Replikationsregeln sehr gut verwenden, um den Datenaustausch in Ihrem einfacheren Fall zu organisieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel ist im Wesentlichen eine praktische Anleitung zur Implementierung von RAFT. </font><font style="vertical-align: inherit;">Der Algorithmus selbst und die theoretischen Aspekte seiner Arbeit werden nicht verstanden. </font><font style="vertical-align: inherit;">Sie können hier in diesem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ausgezeichneten Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine kurze Beschreibung lesen </font><font style="vertical-align: inherit;">oder die vollständige Spezifikation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> studieren </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dort finden Sie eine sehr übersichtliche Visualisierung des Algorithmus.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allgemeine Lösungsbeschreibung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Teil des Codes, der in direktem Zusammenhang mit der Implementierung des Algorithmus steht, wird im Artikel analysiert. </font><font style="vertical-align: inherit;">Am Ende des Artikels befindet sich ein Link zum Repository, in dem Sie den gesamten Code sehen können.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufgabe war wie folgt. </font><font style="vertical-align: inherit;">Entwickeln Sie ein verteiltes System, mit dem Sie Daten in einer Schlüsselwertdatenbank speichern können. </font><font style="vertical-align: inherit;">Die Daten jedes Knotens müssen konsistent sein, dh wenn die Daten in die Datenbank eines Knotens gelangt sind und die meisten Knoten bestätigt haben, dass sie auch diese Daten empfangen haben, befinden sich diese Daten früher oder später in der Datenbank jedes Knotens. </font><font style="vertical-align: inherit;">Wenn ein Teil des Clusters getrennt und wieder verbunden wird, müssen die Knoten außerhalb des Clusters den Hauptcluster einholen und synchronisieren. </font><font style="vertical-align: inherit;">Jeder Knoten bietet eine REST-API zum Schreiben und Lesen von Datenbankdaten. </font><font style="vertical-align: inherit;">Das System besteht aus zwei Modulen für zwei Knotentypen: Client und Server. </font><font style="vertical-align: inherit;">Im Folgenden werden die Funktionen der Implementierung des Servers selbst betrachtet. </font><font style="vertical-align: inherit;">Der Client-Code befindet sich im Repository. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Serverknoten kann in drei Zuständen betrieben werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhänger (Anhänger). </font><font style="vertical-align: inherit;">Akzeptiert Leseanforderungen vom Client. </font><font style="vertical-align: inherit;">Nimmt dem Anführer einen Herzschlag ab</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kandidat (Kandidat). </font><font style="vertical-align: inherit;">Akzeptiert Leseanforderungen vom Client. </font><font style="vertical-align: inherit;">Sendet Abstimmungsanfragen an andere Knoten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Führer </font><font style="vertical-align: inherit;">Akzeptiert Lese- und Schreibanforderungen. </font><font style="vertical-align: inherit;">Sendet Heartbeat-Anforderungen an andere Knoten. </font><font style="vertical-align: inherit;">Sendet Daten zum Anhängen von Anforderungen an andere Knoten.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Periode der „Führung“ eines der Knoten wird als Runde (Term) bezeichnet. </font><font style="vertical-align: inherit;">Ein neuer Kandidat eröffnet eine neue Runde.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenspeicher</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Knoten bietet Zugriff auf das Repository des Operationsprotokolls, in dem Operationen zum Ändern von Daten nacheinander aufgezeichnet werden.</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/operations/OperationsLog.java<br>
</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OperationsLog</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(Operation operation)</span></span>;
   <span class="hljs-function">Operation <span class="hljs-title">get</span><span class="hljs-params">(Integer index)</span></span>;
   <span class="hljs-function">List&lt;Operation&gt; <span class="hljs-title">all</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
   <span class="hljs-function">Long <span class="hljs-title">getTerm</span><span class="hljs-params">(Integer index)</span></span>;
   <span class="hljs-function">Integer <span class="hljs-title">getLastIndex</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">Long <span class="hljs-title">getLastTerm</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeAllFromIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newOperationIndex)</span></span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede Operation enthält neben Daten und Typ (Einfügen, Ändern, Löschen) die Nummer der Runde, in der sie erstellt wurde. Zusätzlich hat jede Operation einen Index, der sequentiell ansteigt. Es ist wichtig, dass alle Vorgänge in derselben Reihenfolge in die Protokolle der Follower eingefügt werden, in der sie in das Protokoll des Anführers eingefügt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Knoten hat Zugriff auf eine Datenbank, in der Daten direkt gespeichert werden.</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/storage/Storage.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Storage</span> </span>{
   <span class="hljs-function">List&lt;Entry&gt; <span class="hljs-title">all</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(Long key)</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Long key, String val)</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Long key, String val)</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Long key)</span></span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der aktuellen Implementierung werden eingebettete In-Memory-Lösungen sowohl für das Protokoll als auch für die Datenbank verwendet (normale Wettbewerbsliste und Karte). Bei Bedarf können Sie einfach die entsprechende Schnittstelle implementieren, um andere Speichertypen zu unterstützen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anwendung von Operationen aus dem Protokoll auf die Datenbank wird von einer verteilten Zustandsmaschine ausgeführt. Eine Zustandsmaschine ist ein solcher Mechanismus, der dafür verantwortlich ist, den Status eines Clusters zu ändern und die Verwendung falscher Änderungen einzuschränken (Operationen außerhalb der Reihenfolge oder ein getrennter Knoten, der sich selbst als führend betrachtet). Damit die Änderungen als gültig angesehen und auf die Datenbank angewendet werden können, müssen sie eine Reihe von Prüfungen bestehen und bestimmte Kriterien erfüllen, genau das bietet die Zustandsmaschine.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für einen Leiter wird eine Operation auf die Datenbank angewendet, wenn die meisten Knoten die Tatsache bestätigt haben, dass die Operation auch in ihr Protokoll repliziert wird. </font><font style="vertical-align: inherit;">Für einen Follower wird die Operation auf die Datenbank angewendet, wenn vom Leiter ein Signal empfangen wird, dass er in seine Datenbank gelangt ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Timer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Knoten bietet Datenaustausch mit anderen Knoten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es werden zwei Arten von Abfragen unterstützt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstimmung bei der Durchführung einer Abstimmungsrunde</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhängen, auch bekannt als Heartbeat (falls ohne Daten), um Protokolldaten an Follower zu replizieren und den Beginn einer neuen Abstimmungsrunde zu verhindern.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tatsache, dass ein Ereignis einsetzt, wird vom Timer bestimmt. </font><font style="vertical-align: inherit;">Auf dem Knoten werden zwei Arten von Timern gestartet:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstimmung. </font><font style="vertical-align: inherit;">Eine Abstimmungsrunde starten. </font><font style="vertical-align: inherit;">Jeder Knoten hat ein eigenes Intervall, nach dem er versucht, eine neue Abstimmung zu starten. </font><font style="vertical-align: inherit;">Der Countdown beginnt von neuem, wenn der Anführer einen Herzschlag erhält.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Herzschlag. </font><font style="vertical-align: inherit;">Senden einer Anfrage an Follower durch den Anhängeführer. </font><font style="vertical-align: inherit;">Wenn der Knoten keinen Herzschlag empfängt und der Abstimmungszeitgeber abgelaufen ist, wird er ein Kandidat und leitet Wahlen ein, erhöht die Anzahl der Abstimmungsrunden und sendet Abstimmungsanfragen an andere Knoten. </font><font style="vertical-align: inherit;">Wenn der Knoten die Mehrheit der Stimmen sammelt, wird er zum Anführer und sendet einen Herzschlag aus.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der aktuelle Status des Knotens</font></font></h3> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Knoten speichert Daten über den aktuellen Status.</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/context/Context.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Context</span> </span>{
   <span class="hljs-function">Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//    </span>
   <span class="hljs-function">State <span class="hljs-title">getState</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//: , ,  </span>
   <span class="hljs-function">Integer <span class="hljs-title">getVotedFor</span><span class="hljs-params">()</span></span>; 
               <span class="hljs-comment">//          </span>
   <span class="hljs-function">Long <span class="hljs-title">getCurrentTerm</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//  </span>
   <span class="hljs-function">Integer <span class="hljs-title">getCommitIndex</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//    </span>
   <span class="hljs-function">List&lt;Peer&gt; <span class="hljs-title">getPeers</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//      </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Führungsknoten speichert auch Metadaten für die Knoten, auf die er Daten repliziert.</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/node/peers/Peer.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Peer</span> </span>{
   <span class="hljs-function">Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//  </span>
   <span class="hljs-function">Integer <span class="hljs-title">getNextIndex</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//  ,    </span>
   <span class="hljs-function">Integer <span class="hljs-title">getMatchIndex</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//   </span>
   <span class="hljs-function">Boolean <span class="hljs-title">getVoteGranted</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//     </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Knotenmetadaten werden vom Leiter aktualisiert, wenn Antworten von Followern empfangen werden. </font><font style="vertical-align: inherit;">Sie werden verwendet, um vom Leiter zu bestimmen, welche nächste Indexoperation der Follower akzeptieren möchte und welche Operationen bereits zum Protokoll des Followers hinzugefügt wurden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wählen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">ElectionService-</font></a><font style="vertical-align: inherit;"> Klasse ist für die Abstimmung verantwortlich</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ElectionService</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processElection</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">AnswerVoteDTO <span class="hljs-title">vote</span><span class="hljs-params">(RequestVoteDTO requestVoteDTO)</span></span>;<font></font>
} </code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Senden eines Antrags auf Abstimmung </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Knoten ein Follower ist und für den für die Wartezeit festgelegten Zeitraum keinen Herzschlag erhält, erhöht er seine aktuelle Runde, erklärt sich selbst zum Kandidaten und beginnt, Abstimmungsanfragen an andere Knoten zu senden. </font><font style="vertical-align: inherit;">Wenn es ihm gelingt, ein Quorum zu erreichen und die meisten Knoten seine Stimme abgeben, wird er der neue Führer. </font><font style="vertical-align: inherit;">In RAFT-Begriffen ist das Quorum mehr als die Hälfte aller Knoten (51%). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns die </font></font><code>processElection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassenmethode </font><font style="vertical-align: inherit;">analysieren </font></font><code>ElectionServiceImpl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die vom Abstimmungs-Timer aufgerufen wird, wenn die Abstimmung abläuft, und den Knoten eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anforderung zur Abstimmung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sendet </font><font style="vertical-align: inherit;">.</font></font><br>
 <br>
<pre><code class="java hljs"><span class="hljs-comment">//1</span><font></font>
context.setState(CANDIDATE); <font></font>
Long term = context.incCurrentTerm(); <font></font>
context.setVotedFor(context.getId()); <font></font>
<font></font>
List&lt;Integer&gt; peersIds = context.getPeers().stream().map(Peer::getId).collect(Collectors.toList());<font></font>
<span class="hljs-keyword">long</span> voteGrantedCount = <span class="hljs-number">1L</span>;
<span class="hljs-keyword">long</span> voteRevokedCount = <span class="hljs-number">0L</span>;<font></font>
<font></font>
<span class="hljs-comment">//2</span>
<span class="hljs-keyword">while</span> (checkCurrentElectionStatus(term)) {<font></font>
   List&lt;AnswerVoteDTO&gt; answers = getVoteFromAllPeers(term, peersIds);<font></font>
   peersIds = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
   <span class="hljs-keyword">for</span> (AnswerVoteDTO answer : answers) {
       <span class="hljs-comment">//3</span>
       <span class="hljs-keyword">if</span> (answer.getStatusCode().equals(OK)) {
           <span class="hljs-comment">//4</span>
           <span class="hljs-keyword">if</span> (answer.getTerm()&gt;context.getCurrentTerm()) {<font></font>
               context.setTermGreaterThenCurrent(answer.getTerm());<font></font>
               <span class="hljs-keyword">return</span>;<font></font>
           }<font></font>
           <span class="hljs-keyword">if</span> (answer.isVoteGranted()) {
               <span class="hljs-comment">//5 </span>
               context.getPeer(answer.getId()).setVoteGranted(<span class="hljs-keyword">true</span>);<font></font>
               voteGrantedCount++;<font></font>
           } <span class="hljs-keyword">else</span>
               <span class="hljs-comment">//6 </span><font></font>
               voteRevokedCount++;<font></font>
       } <span class="hljs-keyword">else</span> {<font></font>
          peersIds.add(answer.getId());<font></font>
       }<font></font>
   }<font></font>
  <span class="hljs-comment">//7</span>
  <span class="hljs-keyword">if</span> (voteGrantedCount &gt;= context.getQuorum()) {<font></font>
       winElection(term);<font></font>
       <span class="hljs-keyword">return</span>;<font></font>
   } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (voteRevokedCount &gt;= context.getQuorum()) {<font></font>
       loseElection(term);<font></font>
       <span class="hljs-keyword">return</span>;<font></font>
   } </code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie den Status "Kandidat" ein. </font><font style="vertical-align: inherit;">Erhöhen Sie die runde Zahl und stimmen Sie für uns ab.</font></font></li>
<li>  ,       (    ).  -  ,        ,           heartbeat                 .</li>
<li> -  ,    .    ,      ,     -. </li>
<li>       ,                            .     ,      heartbeat     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Knoten hat für uns gestimmt! </font><font style="vertical-align: inherit;">Wir erhöhen die Anzahl der Knoten, die Stimmen für uns abgeben, und korrigieren, dass dieser Knoten für uns gestimmt hat.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht für uns gewählt, glauben wir auch.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Quorum gesammelt wird und der Knoten die Wahl gewonnen hat, legen wir den Status „Leader“ fest. </font><font style="vertical-align: inherit;">Ansonsten werden wir Anhänger und warten.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sollte auch beachtet werden, dass, wenn ein Knoten zum Leader wird, der nächste Index für jeden Knoten in der Liste der vom Leader gespeicherten Knoten festgelegt wird. Dies entspricht dem letzten Index im Leader-Protokoll plus 1. Ausgehend von diesem Index versucht der Leader, die Follower-Protokolle zu aktualisieren. </font><font style="vertical-align: inherit;">Tatsächlich entspricht dieser vom Leader gespeicherte Index möglicherweise nicht dem tatsächlichen Index des Protokolls des Followers, und der tatsächliche Wert wird nur beim Datenaustausch mit dem Follower ermittelt und angepasst. </font><font style="vertical-align: inherit;">Es ist jedoch ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgangspunkt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erforderlich </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">winElection</span><span class="hljs-params">(Long term)</span> </span>{<font></font>
       context.setState(LEADER);<font></font>
       context.getPeers().forEach(peer -&gt;<font></font>
               peer.setNextIndex(operationsLog.getLastIndex()+<span class="hljs-number">1</span>)<font></font>
<font></font>
       );<font></font>
   }</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bearbeitung von Abstimmungsanfragen </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Abstimmung erhält jeder Knoten vom Kandidaten eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfrage der</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> folgenden </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Form</font></a><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestVoteDTO</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long term; <span class="hljs-comment">//     </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer candidateId; <span class="hljs-comment">//  </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer lastLogIndex; <span class="hljs-comment">//     </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long lastLogTerm; <span class="hljs-comment">//       </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns nun das </font></font><code>vote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassenverfahren </font><font style="vertical-align: inherit;">an </font></font><code>ElectionServiceImpl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es verarbeitet die Abstimmungsanfrage des Kandidaten und gibt eine Entscheidung bezüglich seiner Kandidatur für die Rolle des Leiters zurück.</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/pleshakoff/raft/blob/eba5ea1984e2623702f4c299cf1b0af7a6ba0d14/server/src/main/java/com/raft/server/election/ElectionServiceImpl.java#L178 <br>
</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> AnswerVoteDTO <span class="hljs-title">vote</span><span class="hljs-params">(RequestVoteDTO dto)</span> </span>{<font></font>
   <font></font>
       <span class="hljs-keyword">boolean</span> termCheck;
       <span class="hljs-comment">//1</span>
       <span class="hljs-keyword">if</span> (dto.getTerm() &lt; context.getCurrentTerm())
           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerVoteDTO(context.getId(),context.getCurrentTerm(),<span class="hljs-keyword">false</span>);
       <span class="hljs-keyword">else</span> <span class="hljs-comment">//2</span>
       <span class="hljs-keyword">if</span> (dto.getTerm().equals(context.getCurrentTerm())) {<font></font>
           termCheck = (context.getVotedFor() == <span class="hljs-keyword">null</span>||<font></font>
                          context.getVotedFor().equals(dto.getCandidateId()));<font></font>
       }<font></font>
       <span class="hljs-keyword">else</span>
       {   <span class="hljs-comment">//3</span>
           termCheck = <span class="hljs-keyword">true</span>;<font></font>
             context.setTermGreaterThenCurrent(dto.getTerm());<font></font>
       }<font></font>
<font></font>
       <span class="hljs-comment">//4  </span>
       <span class="hljs-keyword">boolean</span> logCheck = !((operationsLog.getLastTerm() &gt; dto.getLastLogTerm()) ||<font></font>
               ((operationsLog.getLastTerm().equals(dto.getLastLogTerm())) &amp;&amp;<font></font>
                       (operationsLog.getLastIndex() &gt; dto.getLastLogIndex())));<font></font>
<font></font>
<font></font>
       <span class="hljs-keyword">boolean</span> voteGranted = termCheck&amp;&amp;logCheck;<font></font>
<font></font>
       <span class="hljs-comment">//5</span>
       <span class="hljs-keyword">if</span> (voteGranted) {<font></font>
           context.setVotedFor(dto.getCandidateId());<font></font>
       }<font></font>
       <span class="hljs-comment">//6   </span>
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerVoteDTO(context.getId(),context.getCurrentTerm(),voteGranted);<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach Erhalt einer Anfrage von einem Kandidaten führt der Knoten zwei Überprüfungen durch: Überprüft die Runde des Kandidaten und die Länge seines Protokolls. </font><font style="vertical-align: inherit;">Wenn die Runde des Kandidaten höher ist und sein Protokoll länger oder gleich ist, gibt der Knoten seinem Knoten eine Stimme für den Kandidaten</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die aktuelle Runde des Knotens größer ist als die Runde des Kandidaten, lehnen wir ab, da dies eine Anfrage eines verzögerten Knotens ist, der anscheinend einige Zeit außerhalb des Clusters lag und das Wahlverfahren gestartet hat, weil er den aktuellen Führer nicht gesehen hat. </font></font></li>
<li>   ,   , ,           ,        ,     ,       ;       .              —    .</li>
<li>     ,     </li>
<li> .                   ,            ,  ,        ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit einem positiven Ergebnis korrigieren wir die Tatsache, dass der Knoten an den Wahlen teilgenommen hat, und geben eine Stimme für den Kandidaten ab.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Senden Sie das Ergebnis an den Kandidaten zurück</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sicherlich hätten die Bedingungen etwas kürzer und eleganter geschrieben werden können, aber ich habe eine so „naivere“ Option gelassen, um mich nicht zu verwirren und niemanden zu verwirren. </font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reproduzieren </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Timer-Leader sendet Heartbeat-Follower an alle Knoten, um deren Abstimmungs-Timer zurückzusetzen. Da der Leiter in seinen Metadatenindizes die letzten Operationen aller Follower speichert, kann er bewerten, ob das Senden der Operation an Knoten erforderlich ist. Wenn das Operationsprotokoll des Anführers länger wird als das Protokoll eines Nachfolgers, sendet er ihm zusammen mit dem Herzschlag nacheinander die fehlenden Operationen. Nennen Sie es Append-Anfrage. Wenn die meisten Knoten den Empfang neuer Operationen bestätigen, wendet der Leiter diese Operationen auf seine Datenbank an und erhöht den Index der zuletzt angewendeten Operation. Dieser Index wird zusammen mit einer Heartbeat-Anfrage auch an Follower gesendet. Und wenn der Leader-Index höher als der Follower-Index ist, wendet der Follower auch Operationen auf seine Datenbank an, um die Indizes auszugleichen. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Art von Append-Anfrage sendet der Leader an den Follower</font></font></a><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestAppendDTO</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long term; <span class="hljs-comment">//   </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer leaderId; <span class="hljs-comment">//   </span><font></font>
<font></font>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer prevLogIndex;<span class="hljs-comment">//   </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long prevLogTerm;<span class="hljs-comment">//   </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer leaderCommit;<span class="hljs-comment">//      </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Operation operation; <span class="hljs-comment">//</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt Implementierungen, bei denen Vorgänge in Stapeln von mehreren pro Anforderung übertragen werden. </font><font style="vertical-align: inherit;">In der aktuellen Implementierung kann nur eine Operation pro </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anforderung übertragen werden. Die Klasse antwortet auf das Senden und Verarbeiten der Heartbeat-Append-Anforderung:</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/pleshakoff/raft/blob/eba5ea1984e2623702f4c299cf1b0af7a6ba0d14/server/src/main/java/com/raft/server/replication/ReplicationService.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReplicationService</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendRequest</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">AnswerAppendDTO <span class="hljs-title">append</span><span class="hljs-params">(RequestAppendDTO requestAppendDTO)</span></span>;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Senden Sie eine Datenänderungsanforderung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich ein Fragment einer </font></font><code>sendAppendForOnePeer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassenmethode vor </font></font><code>ReplicationServiceImpl</code><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Methode ist dafür verantwortlich, eine Anforderung an den Follower zu generieren und diese zu senden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> CompletableFuture&lt;AnswerAppendDTO&gt; <span class="hljs-title">sendAppendForOnePeer</span><span class="hljs-params">(Integer id)</span> </span>{
   <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; {
       <span class="hljs-keyword">try</span> {
           <span class="hljs-comment">//1</span><font></font>
           Peer peer = context.getPeer(id);<font></font>
<font></font>
           Operation operation;<font></font>
           Integer prevIndex;<font></font>
           <span class="hljs-comment">//2    </span>
           <span class="hljs-keyword">if</span> (peer.getNextIndex() &lt;= operationsLog.getLastIndex()) {<font></font>
               operation = operationsLog.get(peer.getNextIndex());<font></font>
               prevIndex = peer.getNextIndex() - <span class="hljs-number">1</span>;<font></font>
           } <span class="hljs-keyword">else</span> 
           <span class="hljs-comment">//3  </span><font></font>
           {<font></font>
               operation = <span class="hljs-keyword">null</span>;<font></font>
               prevIndex = operationsLog.getLastIndex();<font></font>
           }<font></font>
<font></font>
<font></font>
           RequestAppendDTO requestAppendDTO = <span class="hljs-keyword">new</span> RequestAppendDTO(<font></font>
                   context.getCurrentTerm(), <span class="hljs-comment">//   </span>
                   context.getId(), <span class="hljs-comment">//  </span>
                   prevIndex,<span class="hljs-comment">//      </span>
                   operationsLog.getTerm(prevIndex),<span class="hljs-comment">//  </span><font></font>
                   context.getCommitIndex(),<font></font>
                               <span class="hljs-comment">//      </span>
                   Operation <span class="hljs-comment">//</span><font></font>
           );<font></font>
<font></font>
...<font></font>
<span class="hljs-comment">/*   http     */</span>
}</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Follower-Metadaten</font></font></li>
<li>   ,   .             (      ),          ,      ,  ,   .    ,       ,    ,   ,     </li>
<li>   ,    ,       ;        ,     ,       ,  </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie als Nächstes die </font></font><code>appendRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassenmethode </font></font><code>ReplicationServiceImpl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die für das Senden der Append-Anforderung und die Verarbeitung des Ergebnisses an alle Follower verantwortlich ist.</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/pleshakoff/raft/blob/eba5ea1984e2623702f4c299cf1b0af7a6ba0d14/server/src/main/java/com/raft/server/replication/ReplicationServiceImpl.java#L109</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendRequest</span><span class="hljs-params">()</span> </span>{<font></font>
       List&lt;Integer&gt; peersIds = context.getPeers().stream().map(Peer::getId).collect(Collectors.toList());<font></font>
<font></font>
       <span class="hljs-comment">//1 </span>
       <span class="hljs-keyword">while</span> (peersIds.size() &gt; <span class="hljs-number">0</span>) {
           <span class="hljs-comment">//2 </span><font></font>
           List&lt;AnswerAppendDTO&gt; answers = sendAppendToAllPeers(peersIds);<font></font>
           peersIds = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
           <span class="hljs-keyword">for</span> (AnswerAppendDTO answer : answers) {
               <span class="hljs-comment">//3</span>
               <span class="hljs-keyword">if</span> (answer.getStatusCode().equals(OK)) {
                   <span class="hljs-comment">//4</span>
                   <span class="hljs-keyword">if</span> (answer.getTerm() &gt; context.getCurrentTerm()) {<font></font>
                        context.setTermGreaterThenCurrent(answer.getTerm());<font></font>
                       <span class="hljs-keyword">return</span>;<font></font>
                   }<font></font>
                   Peer peer = context.getPeer(answer.getId());<font></font>
                   <span class="hljs-comment">//5     </span>
                   <span class="hljs-keyword">if</span> (answer.getSuccess()) {                      <font></font>
                       peer.setNextIndex(answer.getMatchIndex() + <span class="hljs-number">1</span>);<font></font>
                       peer.setMatchIndex(answer.getMatchIndex());<font></font>
                       <span class="hljs-keyword">if</span> (peer.getNextIndex() &lt;= operationsLog.getLastIndex())<font></font>
                           peersIds.add(answer.getId());<font></font>
                   <span class="hljs-comment">//6      </span>
                   } <span class="hljs-keyword">else</span> {<font></font>
                       peer.decNextIndex();<font></font>
                       peersIds.add(answer.getId());<font></font>
                   }<font></font>
               }<font></font>
           }<font></font>
           <span class="hljs-comment">//7</span><font></font>
           tryToCommit();<font></font>
       }<font></font>
}<font></font>
</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir wiederholen die Anfrage, bis wir von allen Followern eine Antwort erhalten, dass die Replikation erfolgreich war. </font><font style="vertical-align: inherit;">Da pro Anforderung eine Operation gesendet wird, kann es mehrere Iterationen dauern, um die Protokolle der Follower zu synchronisieren</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Senden Sie Anfragen an alle Follower und erhalten Sie eine Liste mit Antworten </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir berücksichtigen nur Antworten von verfügbaren Followern</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich herausstellt, dass die Runde eines der Anhänger mehr ist als die Runde des Anführers, stoppen wir alles und verwandeln uns in einen Anhänger </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Follower geantwortet hat, dass alles erfolgreich war, aktualisieren wir die Follower-Metadaten: Wir speichern den letzten Index des Follower-Protokolls und den Index der nächsten vom Follower erwarteten Operation. </font></font></li>
<li>  ,    ,  ,           ,           .  ,                  ,      .     ,         .    ,          .</li>
<li>        ,      .     . </li>
</ol><br>
<h3>     </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun wollen wir sehen, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie genau der Follower die Append-Anfrage vom Leader verarbeitet. </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klasse - </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Methode</font></font><code>append</code><font style="vertical-align: inherit;"></font><code>ReplicationServiceImpl</code><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> AnswerAppendDTO <span class="hljs-title">append</span><span class="hljs-params">(RequestAppendDTO dto)</span> </span>{<font></font>
     <font></font>
       <span class="hljs-comment">//1     </span>
       <span class="hljs-keyword">if</span> (dto.getTerm() &lt; context.getCurrentTerm()) {
           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(),context.getCurrentTerm(),<span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<font></font>
       } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dto.getTerm() &gt; context.getCurrentTerm()) {
           <span class="hljs-comment">//2 </span><font></font>
           context.setCurrentTerm(dto.getTerm());<font></font>
           context.setVotedFor(<span class="hljs-keyword">null</span>);<font></font>
       }<font></font>
       <span class="hljs-comment">//3  </span>
       applicationEventPublisher.publishEvent(<span class="hljs-keyword">new</span> ResetElectionTimerEvent(<span class="hljs-keyword">this</span>));<font></font>
<font></font>
       <span class="hljs-keyword">if</span> (!context.getState().equals(FOLLOWER)) {<font></font>
           context.setState(FOLLOWER);<font></font>
       }<font></font>
        <font></font>
       <span class="hljs-comment">//4  </span>
       <span class="hljs-keyword">if</span> ((dto.getPrevLogIndex() &gt; operationsLog.getLastIndex()) ||                                                                                        !dto.getPrevLogTerm().equals(operationsLog.getTerm(dto.getPrevLogIndex()))) {
                      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(), context.getCurrentTerm(), <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<font></font>
       }<font></font>
<font></font>
<font></font>
       Operation newOperation = dto.getOperation();<font></font>
       <span class="hljs-keyword">if</span> (newOperation != <span class="hljs-keyword">null</span>) {
           <span class="hljs-keyword">int</span> newOperationIndex = dto.getPrevLogIndex() + <span class="hljs-number">1</span>;<font></font>
           <font></font>
         <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
               <span class="hljs-comment">//5</span>
               <span class="hljs-keyword">if</span> ((newOperationIndex &lt;= operationsLog.getLastIndex()) &amp;&amp;<font></font>
                      (!newOperation.getTerm().equals(operationsLog.getTerm(newOperationIndex)))){<font></font>
                   operationsLog.removeAllFromIndex(newOperationIndex);<font></font>
               }<font></font>
               <span class="hljs-comment">//6</span>
               <span class="hljs-keyword">if</span> (newOperationIndex &lt;= operationsLog.getLastIndex())<font></font>
               {<font></font>
                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(), context.getCurrentTerm(), <span class="hljs-keyword">true</span>,      operationsLog.getLastIndex());<font></font>
               }<font></font>
               <span class="hljs-comment">//7</span><font></font>
               operationsLog.append(newOperation);<font></font>
           }<font></font>
        }<font></font>
        <span class="hljs-comment">//8 </span>
        <span class="hljs-keyword">if</span> (dto.getLeaderCommit() &gt; context.getCommitIndex()) {<font></font>
           context.setCommitIndex(Math.min(dto.getLeaderCommit(), operationsLog.getLastIndex()));<font></font>
       }<font></font>
<font></font>
                 <font></font>
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(), context.getCurrentTerm(), <span class="hljs-keyword">true</span>, operationsLog.getLastIndex());<font></font>
   }</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Runde des Anführers geringer ist als die Runde des Nachfolgers, senden wir unserem Anführer eine Runde und ein Zeichen, dass seine Anfrage abgelehnt wurde. </font><font style="vertical-align: inherit;">Sobald der Anführer eine Runde erhält, die größer ist als seine Antwort, wird er zu einem Anhänger</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Runde des Anführers größer ist als die Runde des Nachfolgers, setzen Sie diese Runde auf den Nachfolger.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Anfrage vom Vorsitzenden eingegangen ist, setzen wir den Abstimmungszeitgeber zurück, unabhängig davon, ob Daten vorhanden sind oder nicht, und wenn wir kein Anhänger sind, werden wir es </font></font></li>
<li>   ,   ,            ,  ,   ,    ,   .        ,    ,      </li>
<li>              ,   .            .   ,     , - ,   ,      ,      ,      .             ,    .</li>
<li>  ,   .  ,    </li>
<li>  ,     </li>
<li>        ,   ,       ,    . </li>
</ol><br>
<h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es bleibt nur herauszufinden, wie der Leiter Operationen aus dem Protokoll auf die Datenbank anwendet. Beim Senden von Vorgängen an Follower und Verarbeiten von Antworten von diesen aktualisiert der Leiter die Metadaten der Knoten. Sobald die Anzahl der Knoten, deren Index der letzten Operation im Protokoll größer ist als der Index der letzten Operation, die vom Leader auf die Datenbank angewendet wurde, dem Quorum entspricht, können wir angeben, dass die meisten Knoten die Operation empfangen haben, und sie auf die Leader-Datenbank anwenden. Mit anderen Worten, wenn ein Anführer eine Operation an Follower gesendet hat und die meisten von ihnen sie in sein Protokoll eingefügt und dem Anführer geantwortet haben, können wir diese Operation auf die Datenbank des Anführers anwenden und den Index der zuletzt angewendeten Operation erhöhen. Dieser Index mit der nächsten Append-Heartbeat-Anforderung fliegt zum Follower und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wendet die Operation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit demselben Index aus seinem Protokoll auf seine Datenbank an.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns die </font></font><code>tryToCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassenmethode </font><font style="vertical-align: inherit;">analysieren</font></font><code>ReplicationServiceImpl</code><br>
<br>
<pre><code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryToCommit</span><span class="hljs-params">()</span> </span>{
       <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
           <span class="hljs-comment">//1</span>
           <span class="hljs-keyword">int</span> N = context.getCommitIndex() + <span class="hljs-number">1</span>;
           <span class="hljs-comment">//2</span><font></font>
           Supplier&lt;Long&gt; count = () -&gt;<font></font>
               context.getPeers().stream().map(Peer::getMatchIndex).<font></font>
                       filter(matchIndex -&gt; matchIndex &gt;= N).count() + <span class="hljs-number">1</span>;<font></font>
<font></font>
           <span class="hljs-comment">//3 </span>
           <span class="hljs-keyword">if</span> (operationsLog.getLastIndex() &gt;= N &amp;&amp;<font></font>
                   operationsLog.getTerm(N).equals(context.getCurrentTerm())&amp;&amp;<font></font>
                      count.get()&gt;=context.getQuorum()<font></font>
           )<font></font>
           {<font></font>
               context.setCommitIndex(N);<font></font>
           } <span class="hljs-keyword">else</span>
               <span class="hljs-keyword">return</span>;<font></font>
       }<font></font>
   }</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erhalten den folgenden Index der Operation, die auf die Datenbank angewendet wird</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir zählen, wie viele Follower eine Operation mit einem solchen Index in ihren Protokollen haben, und vergessen nicht, einen Leader hinzuzufügen </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Anzahl solcher Follower beschlussfähig ist und sich die Operation mit einem solchen Index im Protokoll des Leiters befindet und die Runde dieser Operation der aktuellen entspricht, wendet der Leiter die Operation auf die Datenbank an und erhöht den Index der zuletzt angewendeten Operation. </font><font style="vertical-align: inherit;">Operationen aus der vorherigen Runde können nicht angewendet werden, da ein anderer Anführer für sie verantwortlich war und ein Konflikt entstehen könnte. </font><font style="vertical-align: inherit;">Jeder Anführer wendet nur Operationen seiner aktuellen Runde an.</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder verteilte Algorithmus, dessen Vertreter RAFT ist, ist eine leistungsstarke integrierte Lösung, die das Erreichen des Ergebnisses unter Einhaltung aller in der Spezifikation beschriebenen Regeln garantiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt viele verteilte Algorithmen und sie sind unterschiedlich. Es gibt ZAB, das in Zookeeper implementiert ist und beispielsweise zum Synchronisieren von Daten in Kafka verwendet wird. Es gibt Algorithmen mit weniger strengen Anforderungen an die Konsistenz, beispielsweise die Masse der Implementierungen des Gossip-Protokolls, die in AP-Systemen verwendet werden. Es gibt Algorithmen, die den Prinzipien von RAFT folgen und gleichzeitig das Klatschprotokoll für den Austausch von Protokollen verwenden, z. B. MOKKA, das auch Verschlüsselung verwendet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich glaube, dass der Versuch, einen dieser Algorithmen herauszufinden, für jeden Entwickler äußerst nützlich ist, und wie oben erwähnt, können Lösungen sowohl umfassend als auch in separaten Teilen interessant sein. </font><font style="vertical-align: inherit;">Und natürlich müssen Sie auf jeden Fall in diese Richtung schauen, wenn sich die Aktivitäten auf die Entwicklung verteilter Systeme und die Datensynchronisation beziehen, auch wenn sie industrielle Standardlösungen verwenden.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spezifikation</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurzbeschreibung</font></font></a></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir hoffen, dass das Material für Sie nützlich war. </font><font style="vertical-align: inherit;">Und wenn Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Kurs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> belegen möchten </font><font style="vertical-align: inherit;">, können Sie dies jetzt tun.</font></font></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495342/index.html">Abrechnung von Bankkarten im Handel - Erstellen eines offenen Datensatzes und einer Infografik in Google Data Studio</a></li>
<li><a href="../de495344/index.html">Vereinheitlichen Sie es: Wie Lamoda seine Go-Services konsistent macht</a></li>
<li><a href="../de495346/index.html">Vom Fehler zum Alarm mit Aktionen</a></li>
<li><a href="../de495350/index.html">Home-Webserver oder Ihr eigener Hosting-Anbieter</a></li>
<li><a href="../de495354/index.html">Wie kann man Produkte kontinuierlich in 20 Sprachen veröffentlichen und nicht sterben?</a></li>
<li><a href="../de495360/index.html">Wie wir die Portierung von Produkten von C # nach C ++ automatisiert haben</a></li>
<li><a href="../de495362/index.html">Selbstisolieren und programmieren: Wie man zu Hause nicht verrückt wird und Zeit sinnvoll verbringt</a></li>
<li><a href="../de495364/index.html">API Style Guide, oder lassen Sie Benutzer nicht nachdenken</a></li>
<li><a href="../de495366/index.html">16 Arten von Programmierern oder Entwicklern sind nicht dieselben Roboter</a></li>
<li><a href="../de495368/index.html">Wir registrieren uns selbst für selbstlaufende Selbsthunde unter Bedingungen der Selbstisolation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>