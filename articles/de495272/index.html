<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🔬 💫 🕯️ SNES-Emulatoren nur wenige Pixel von der absoluten Perfektion entfernt 👩🏾‍🔧 🐢 👘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir sind so nah dran, einen Emulator zu entwickeln, der alle Funktionen von echter Hardware und SNES-Software perfekt nachbilden kann. 
 
 In den letz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SNES-Emulatoren nur wenige Pixel von der absoluten Perfektion entfernt</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495272/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/f3b/e14/44bf3be14304180044d2e7deb216f07d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind so nah dran, einen Emulator zu entwickeln, der alle Funktionen von echter Hardware und SNES-Software perfekt nachbilden kann. </font></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den letzten 15 Jahren habe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ich </font><font style="vertical-align: inherit;">als Codierer für den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bsnes-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Emulator </font><font style="vertical-align: inherit;">versucht, die Super Nintendo-Emulation zu perfektionieren, aber jetzt stehen wir vor dem letzten Problem: dem genauen Timing der Taktzyklen der SNES-Videoprozessoren. </font><font style="vertical-align: inherit;">Um diese letzte Stufe der Emulationsgenauigkeit zu erreichen, ist die Hilfe der gesamten Community erforderlich, und ich hoffe auf Ihre Unterstützung. </font><font style="vertical-align: inherit;">Aber zuerst werde ich Ihnen sagen, was wir bereits erreicht haben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktuellen Zustand</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heute ist die Situation mit der SNES-Emulation sehr gut. Abgesehen von den ungewöhnlichen Peripheriegeräten, die der Emulation widerstehen (z. B. einem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Golfschläger mit Lichtsensor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , einem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fahrradsimulator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und einem DFÜ-Modem, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Japan </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">für Pferderennen in</font></a><font style="vertical-align: inherit;"> Japan verwendet werden), sind alle offiziell lizenzierten SNES-Spiele vollständig spielbar. und kein Spiel hat offensichtliche Probleme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die SNES-Emulation wurde so präzise, ​​dass ich den Emulator sogar in zwei Versionen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aufteilen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> musste </font><font style="vertical-align: inherit;">: </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">higan</font></a><font style="vertical-align: inherit;"> , das absolute Genauigkeit und Konsistenz mit der Hardwaredokumentation </font><font style="vertical-align: inherit;">anstrebt </font><font style="vertical-align: inherit;">, und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bsnes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das Geschwindigkeit, breite Funktionen und Benutzerfreundlichkeit anstrebt.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jüngster Zeit wurden auf dem Gebiet der SNES-Emulation viele interessante Erfolge erzielt, darunter:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Low-Level-Emulation aller SNES-Coprozessoren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterstützung für HD-Modus 7</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausbau der Bremse</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breitbild-Unterstützung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSU1 für CD-Audio und FMV</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorläufige Ausführung zur Reduzierung von Verzögerungen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamische Datenratensteuerung für perfekte Audio- und Videosynchronisation</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
… und vieles mehr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also ist es fertig? Haben alle gut gearbeitet, tschüss, und danke für den Fisch? Nicht ganz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heute haben wir bei fast allen SNES-Komponenten eine Genauigkeit auf Schlagniveau erreicht. Die einzigen Ausnahmen waren die PPU (Bildverarbeitungseinheit, Bildverarbeitungsmodule), die zum Erzeugen von auf den Bildschirm übertragenen Videobildern verwendet wurden. Wir </font><font style="vertical-align: inherit;">wissen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meistens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wie PPUs funktionieren, aber für einige Funktionen müssen wir Vermutungen anstellen, was zu einer unvollständigen Genauigkeit führt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen sind die verbleibenden Probleme ziemlich gering. Wenn Sie nicht nach der absolut perfekten Idealität der Emulation aus Liebe zur Kunst streben, kann ich Sie nicht von der Notwendigkeit überzeugen, die PPU-Emulation weiter zu verbessern. Wie in jedem Bereich ist die Rendite umso geringer, je näher wir dem Ideal sind.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber ich kann sagen, warum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mir das</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wichtig </font><i><font style="vertical-align: inherit;">ist</font></i><font style="vertical-align: inherit;"> : Dies ist die Arbeit meines ganzen Lebens, und ich möchte nicht, dass ich sage, dass ich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kurz vor dem Abschluss </font><font style="vertical-align: inherit;">bin </font><font style="vertical-align: inherit;">, ohne den letzten Schritt zu </font><font style="vertical-align: inherit;">tun </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich altern und ich bin nicht ewig. </font><font style="vertical-align: inherit;">Ich möchte, dass das letzte Puzzleteil gelöst wird, damit ich nach meiner Pensionierung sicher bin, dass das SNES-Erbe dank der Emulation zuverlässig und vollständig erhalten bleibt. </font><font style="vertical-align: inherit;">Ich möchte sagen, dass das Problem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gelöst ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie immer noch fasziniert sind, lesen Sie weiter, um sich mit dem Hintergrund eines Problems und den von mir angebotenen Lösungen vertraut zu machen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modellierung der SNES-Architektur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit der Auflistung der Komponenten, aus denen SNES besteht:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3c/f4f/e25/c3cf4fe250fbbed2b897e46ef58628bd.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super NES Systemdiagramm. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Pfeile geben die Richtungen an, in denen verschiedene SNES-Prozessoren Daten miteinander austauschen können, und die gepunkteten Linien geben die Verbindungen zu den Speicherchips an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Wichtigste für uns ist jetzt, dass die Ausgabe von Video und Ton direkt von PPU und DSP übertragen wird. </font><font style="vertical-align: inherit;">Dies bedeutet, dass sie als "Black Boxes" fungieren und wir nicht sehen können, was in ihnen geschieht. </font><font style="vertical-align: inherit;">Später wird es uns wichtig.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtigkeit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich vor, wir emulieren den CPU-Befehl "multiplizieren", der zwei Register (Variablen) verwendet, diese multipliziert, das Ergebnis und mehrere Flags empfängt, die den Status des Ergebnisses anzeigen (z. B. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überlauf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können ein Programm schreiben, das jeden möglichen Wert von 0 bis 255 als Faktor und Multiplikator multipliziert. Dann können wir die numerischen und Flag-Multiplikationsergebnisse ableiten. Somit erhalten wir zwei Tabellen mit 65 536 Elementen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch die Analyse dieser Tabellen können wir genau bestimmen, wie und wo die Ergebnisse von CPU-Berechnungen auf bestimmte Weise festgelegt werden. Dann können wir die Emulatoren so ändern, dass wir beim Ausführen des gleichen Tests genau die gleichen Tabellen zur gleichen Zeit erhalten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir nun an, die CPU kann 16-Bit x 16-Bit-Multiplikation durchführen. Wenn jeder mögliche Wert getestet wird, werden 4 Milliarden Ergebnisse generiert, die in angemessener Zeit kaum zu testen sind. Wenn die CPU Multiplikationen von 32 Bit x 32 Bit hat, ist es in der Praxis nicht möglich, alle Kombinationen von Eingabewerten vor dem thermischen Tod des Universums zu testen (zumindest auf dem aktuellen Stand der Technik). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In solchen Fällen handeln wir bei den Tests selektiver und versuchen festzustellen, wann sich die Flags genau ändern können, wann die Ergebnisse überlaufen können und so weiter. Andernfalls müssten wir Tests durchführen, die niemals enden würden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Multiplikation ist eine eher triviale Operation, aber das gleiche Prinzip kann auf den gesamten Prozess des Reverse Engineering ausgedehnt werden, einschließlich komplexerer Operationen, beispielsweise der Datenübertragung über DMA (direkter Speicherzugriff) während der horizontalen Rückgabe des Strahls. </font><font style="vertical-align: inherit;">Wir erstellen Tests, die versuchen festzustellen, was in Grenzfällen passiert, und prüfen dann, ob sich unsere Emulation identisch mit dem Verhalten von echtem SNES verhält.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Signalgeneratoren und Beats</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SNES verfügt über zwei Signalgeneratoren (Oszillatoren): einen Quarzoszillator, der mit einer Frequenz von ungefähr 21 MHz arbeitet (er steuert die CPU- und PPU-Module), und einen Keramikresonator, der mit einer Frequenz von ungefähr 24 MHz arbeitet und SMP und DSP steuert. </font><font style="vertical-align: inherit;">In Cartridge-Coprozessoren wird manchmal ein 21-MHz-Quarzoszillator verwendet, und manchmal arbeiten eigene Signalgeneratoren mit anderen Frequenzen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97d/ecb/bc1/97decbbc1161fcf170f063d2fd42795d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Wiederherstellen dieser Super Famicom-Platine im Code ist schwieriger als es sich anhört.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Die Uhr ist das Grundelement des Timings eines jeden Systems, und SNES ist dafür ausgelegt, verschiedene Aufgaben mit bestimmten Frequenzen und Zeitintervallen auszuführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich einen 100-Hertz-Takt vorstellen, ist dies ein Gerät mit einem Binärausgang, der 100 Mal pro Sekunde auf einen hohen logischen Zustand des Signals (z. B. +5 V) und dann auf einen niedrigen Zustand des Signals (0 V oder Masse) umschaltet. Das heißt, jede Sekunde schwankt die Spannung am Ausgang 200-mal: 100-mal erhöht und 100-mal die Vorderseite des Taktsignals abgesenkt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Taktzyklus wird normalerweise als ein vollständiger Übergang betrachtet, dh ein 100-Hz-Zyklus erzeugt 100 Taktzyklen pro Sekunde. </font><font style="vertical-align: inherit;">Einige Systeme erfordern eine Unterscheidung zwischen ansteigenden und abfallenden Flanken, und für sie unterteilen wir den Zyklus in Halbzyklen, um jede Phase (hoch oder niedrig) des Taktsignals anzuzeigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die wichtigste Aufgabe eines genauen Emulators besteht darin, Aufgaben genauso und in genau derselben Zeit wie bei realen Geräten zu erledigen. </font><font style="vertical-align: inherit;">Es ist jedoch nicht sehr wichtig, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgaben ausgeführt werden. </font><font style="vertical-align: inherit;">Das einzige, was wichtig ist, ist, dass der Emulator, der dieselben Eingangssignale empfängt, dieselben Ausgangssignale zur gleichen Zeit wie auf realer Hardware erzeugt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Timings</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal brauchen Operationen Zeit. Nehmen wir zum Beispiel die Multiplikation in der SNES-CPU. Anstatt anzuhalten und auf den Abschluss der Multiplikation zu warten, berechnet die SNES-CPU das Ergebnis der Multiplikation bitweise im Hintergrund für acht Taktzyklen der CPU-Opcodes. Auf diese Weise kann der Code möglicherweise andere Aufgaben ausführen, während er auf den Abschluss der Multiplikation wartet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Höchstwahrscheinlich wartet jede kommerzielle Software auf diese acht Zyklen. Wenn Sie versuchen, das Ergebnis zu lesen, bevor es fertig ist, erhalten wir ein teilweise abgeschlossenes Ergebnis. Bevor jedoch SNES-Emulatoren </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sofort</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> korrekte Ergebnisse lieferten </font><font style="vertical-align: inherit;">, ohne auf diese zusätzlichen Taktzyklen zu warten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Konsolenfans begannen, selbst geschriebene Software in Emulatoren zu erstellen und zu testen, verursachte diese Diskrepanz bestimmte Probleme. Ein Teil der Software, zum Beispiel viele der ersten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super Mario World</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ROM-Hacks </font><font style="vertical-align: inherit;">, funktionierte nur in diesen alten Emulatoren korrekt, nicht jedoch auf echter SNES-Hardware. Dies geschah, weil sie unter Berücksichtigung des Zeitpunkts (aus Sicht der realen Ausrüstung unzuverlässig) der Multiplikationsergebnisse entwickelt wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Verbesserung der Emulatoren wurde die Kompatibilität alter Software beeinträchtigt, und daher mussten wir den neuen Emulatoren Kompatibilitätsoptionen hinzufügen, um diese Programme nicht zu verlieren. Ja, egal wie surreal es klingt, aber heute müssen Emulatoren andere Emulatoren emulieren!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Bequemlichkeit dieser Multiplikationsverzögerung in der CPU liegt in der Tatsache, dass sie sehr vorhersehbar ist: Acht Taktzyklen von Berechnungen beginnen unmittelbar nach der Anforderung der Multiplikationsoperation. </font><font style="vertical-align: inherit;">Durch Schreiben von Code, der die Ergebnisse nach jedem Zyklus liest, konnten wir überprüfen, ob die SNES-CPU </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Booth-Algorithmus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur Multiplikation verwendet </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uhrensynchronisation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andere Operationen sind nicht einfach zu modellieren, da sie im Hintergrund asynchron ausgeführt werden. Ein solcher Fall ist das DRAM-Update des zentralen SNES-Prozessors. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während des Renderns jeder Rasterzeile unterbricht die gesamte SNES-CPU zu einem bestimmten Zeitpunkt ihren Betrieb für einen kurzen Zeitraum, während der Inhalt des RAM-Chips aktualisiert wird. Dies ist erforderlich, da zur Reduzierung der Kosten in SNES dynamischer (statt statischer) RAM als Hauptspeicher der CPU verwendet wurde. Um den Inhalt des dynamischen RAM zu speichern, muss dieser regelmäßig aktualisiert werden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d61/cb1/ab9/d61cb1ab914186314069b09f88218fcf.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es reicht nicht aus, einen wirklich perfekten Emulator zu erstellen, um die Spielbarkeit aller dreieinhalbtausend SNES-Spiele zu gewährleisten. Es ist auch notwendig, eine Simulation jeder Funktion des Systems mit perfekter Taktgenauigkeit zu erreichen.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Der Schlüsselfaktor bei der Analyse der genauen Zeitpunkte dieser Operationen war die Möglichkeit, horizontale und vertikale PPU-Zähler zu verwenden. Diese Zähler führen Inkremente durch und werden nach jeder umgekehrten horizontalen und vertikalen Strahlbewegung zurückgesetzt. Ihre Genauigkeit beträgt jedoch nur ein Viertel der Frequenz des SNES-CPU-Signalgenerators. Mit anderen Worten, der horizontale Zähler erhöht sich alle vier Taktzyklen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch mehrmaliges Lesen der Werte der Zähler konnte ich feststellen, auf welches Viertel des Taktzyklus der Zähler ausgerichtet ist. Durch die Kombination dieses Wissens mit speziell erstellten Funktionen, die einen Schritt in Richtung der vom Benutzer angegebenen genauen Anzahl von Taktzyklen machen können, konnte ich die SNES-CPU perfekt auf jede genaue Position des von mir benötigten Taktzyklus abstimmen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dank eines iterativen Durchlaufs vieler Taktzyklen konnte ich feststellen, wann bestimmte Operationen genau ausgeführt werden (z. B. Aktualisieren des DRAM, Übertragen von HDMA, Abrufen von Interrupts usw.). Danach konnte ich all dies in der Emulation genau nachbilden. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SMP-Chip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die SNES-Konsole verfügt auch über eigene Timer, und für diesen Prozessor wurde auch ein erfolgreiches Reverse Engineering durchgeführt. </font><font style="vertical-align: inherit;">Ich kann einen ganzen Artikel nur dem SMP TEST-Register widmen, mit dem Programmierer den SMP-Frequenzteiler und seinen Timer steuern können, ganz zu schweigen von anderen schrecklichen Dingen. </font><font style="vertical-align: inherit;">Es wird ausreichen zu sagen, dass es kein einfacher und schneller Prozess war, aber am Ende haben wir gewonnen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sammeln Coprozessoren</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ce/8ec/80c/1ce8ec80c157a980c0222eb7462679e9.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der SuperFX-Chip ist nur einer von vielen Cartridge-Coprozessoren, die der SNES-Emulator verarbeiten kann.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Es gibt eine ganze Reihe von SNES-Coprozessoren, die in verschiedenen Spielekassetten verwendet werden und die wir auch zähmen mussten. Von einzelnen Allzweck-CPUs wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SuperFX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA-1 über</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> digitale Signalprozessoren wie DSP-1 und Cx4 bis hin zu Dekompressionsbeschleunigern wie S-DD1 und SPC7110 oder Sharp- und Epson-Echtzeituhren und vielem mehr ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass der SNES-Emulator mit SuperFX-Befehlen und Pixel-Caches umgehen muss. mit dem SA-1-Speicherbus-Konfliktlösungsschema (wodurch die SNES- und SA-1-CPUs gleichzeitig denselben ROM- und RAM-Chip verwenden können); mit integrierter Firmware DSP-1 und Cx4; mit prädiktionsbasierten arithmetischen Encodern S-DD1 und SPC7110; sowie mit ungeraden Grenzfällen von BCD (binär codierte Dezimalzahl) in Echtzeitgeneratoren. Langsam aber sicher haben wir mit allen oben beschriebenen Techniken zur Bestimmung der Korrektheit und des Timings gelernt, wie man all diese Chips nahezu perfekt emuliert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Entfernen der Chipabdeckungen und der Firmware von den in verschiedenen Spielen verwendeten digitalen Signalprozessoren war mit viel Aufwand und Tausenden von Dollar verbunden. In einem Fall ist die NEC uPD772x-Emulation zulässig</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie den Code von Higan, um die Stimme des verstorbenen Stephen Hawking zu retten! </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem anderen Fall mussten wir eine ganze Reihe von Anweisungen für die Hitachi HG51B-Architektur zurückentwickeln, da noch nie jemand die Dokumentation für diese Architektur veröffentlicht hatte. </font><font style="vertical-align: inherit;">In einem anderen Fall stellte sich heraus, dass ein Spiel ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hayazashi Nidan Morita Shougi 2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) eine leistungsstarke 32-Bit-ARM6-CPU mit einer Frequenz von 21 MHz hat, was das japanische Shogi-Spiel beschleunigt! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Speichern aller SNES-Coprozessoren erwies sich als langfristiger Prozess voller Schwierigkeiten und Überraschungen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digitale Signalverarbeitung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Sony S-DSP-Chip (Digital Signal Processor), der nicht mit dem DSP-1-Kassetten-Coprozessor verwechselt werden darf, erzeugte einen einzigartigen SNES-Sound. In diesem Chip wurden acht Audiokanäle mit 4-Bit-ADPCM-Codierung angeschlossen, wodurch die Erzeugung eines 16-Bit-Stereosignals sichergestellt wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Äußerlich und aus dem oben dargestellten Systemdiagramm scheint der DSP zunächst eine „Black Box“ zu sein: Wir passen die Tonkanäle und Mischerparameter an, wonach der Chip den an die Lautsprecher übertragenen Ton erzeugt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine wichtige Funktion ermöglichte es dem Entwickler unter dem Spitznamen blargg, ein vollständiges Reverse Engineering dieses Chips durchzuführen: Es war ein Echopuffer. </font><font style="vertical-align: inherit;">Der SNES-DSP verfügt über eine Funktion, die die Ausgabe vorheriger Samples mischt, um einen Echoeffekt zu erzeugen. </font><font style="vertical-align: inherit;">Dies geschieht ganz am Ende des Klangerzeugungsprozesses (abgesehen von dem letzten Schallblockierungsflag, mit dem die gesamte Tonausgabe ausgeschaltet werden kann). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Schreiben von Code mit dem richtigen Timing der Maßnahmen und Verfolgen des resultierenden Echos konnten wir die genaue Reihenfolge der vom DSP zu erzeugenden Operationen bestimmen von jedem Sample und perfekte Klang- und Schlaggenauigkeit.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPU speichern</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All dies führte uns zum letzten Teil des SNES-Architekturschemas: PPU-1- und PPU-2-Chips. </font><font style="vertical-align: inherit;">Dank John McMaster haben wir Scans der Chips S-PPU1 (Revision 1) und S-PPU2 (Revision 3) mit einer zwanzigfachen Zunahme.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/678/641/68e/67864168e9f383375b8e081ffff1606f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwanzigfacher Scan des Kristalls des ersten PPU-SNES ...</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fad/524/a23/fad524a235729831ae880c3edf1bb4b8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... und die zweite PPU.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Beide Crystal-Scans lassen uns wissen, dass es sich bei den Chips offensichtlich nicht um Allzweck-CPUs handelt, und es handelt sich auch nicht um spezialisierte Architekturen, die Betriebscodes aus dem internen ROM des Firmware-Programms ausführen. Hierbei handelt es sich um separate logische Schaltkreise mit fest codierter Logik, die eingehende Signale von verschiedenen Registern und Speichern empfangen und jeweils ein Rastersignal für den Monitor erzeugen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PPUs bleiben das letzte Hindernis für die Emulation von SNES, da PPUs im Gegensatz zu allen oben beschriebenen Komponenten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tatsächlich</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Black Box sind. Wir können sie für jeden Status konfigurieren, aber die SNES-CPU kann nicht direkt überwachen, was sie generieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir unser vorheriges Beispiel mit Multiplikation als Analogie verwenden, stellen Sie sich vor, Sie hätten das Ergebnis 3 * 7 angefordert, aber anstelle der binären Antwort erhalten Sie ein unscharfes analoges Bild der Zahlen „21“ auf dem Bildschirm. Jeder, der Ihre Software ausführt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann </font><font style="vertical-align: inherit;">21 sehen, aber Sie können kein Testprogramm schreiben, um automatisch zu überprüfen, ob er die richtige Antwort sieht. Die manuelle Überprüfung solcher Ergebnisse durch eine Person kann nicht auf mehr als mehrere tausend Tests skaliert werden, und Millionen sind erforderlich, um das PPU-Verhalten zu maximieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich weiß, was Sie gedacht haben: "Aber ist es einfacher, eine Aufnahmekarte zu verwenden, eine Bildverarbeitung durchzuführen, sie ungefähr mit dem Bild auf dem digitalen Bildschirm des Emulators zu vergleichen und darauf basierende Tests durchzuführen?"</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na ja, das ist möglich! </font><font style="vertical-align: inherit;">Besonders wenn der Test darin besteht, zwei große Zahlen zu überprüfen, die den gesamten Bildschirm einnehmen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber was ist, wenn das Testen viele Nuancen hat und wir versuchen, den Farbunterschied eines Halbtons von einem Pixel zu erkennen? </font><font style="vertical-align: inherit;">Was ist, wenn wir eine Million Tests in der richtigen Reihenfolge ausführen möchten und nicht immer wissen, was wir generieren werden, aber dennoch das Ergebnis mit der Ausgabe unserer Emulation vergleichen möchten? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nichts geht über Komfort und Genauigkeit bei digitalen Daten - ein genauer Bitstrom, der nur übereinstimmen kann oder nicht. </font><font style="vertical-align: inherit;">Die analoge Natur eines CRT-Signals kann uns dies nicht liefern.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum ist es wichtig?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Ausnahme eines Spiels ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) basiert die gesamte offiziell lizenzierte SNES-Software (sollte es gewesen sein) auf Rasterzeichenfolgen. Diese Spiele versuchen nicht, den Status des PPU-Renderings in der Mitte der aktuell gerenderten Rasterzeile zu ändern (ein solcher Trick wird von Programmierern als "Rastereffekt" bezeichnet). Dies bedeutet, dass die Ausführungszeiten der meisten Spiele nicht besonders genau sein müssen. Wenn Sie Zeit für die nächste vollständige Rasterzeile haben, ist alles in Ordnung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist jedoch wichtig für ein einziges Spiel.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/c75/08c/349c7508c9724e946a687c60881e77fc.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a4/7ee/5b2/3a47ee5b2b9ceacabcf2c4f1c34a1fe3.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77e/149/23c/77e14923ce342dc49287fa908aea5b93.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Bilderserie zeigt einen komplexen Emulationseffekt, der in der Nachricht „Good Luck“ von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol verwendet wird</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In den obigen Bildern sehen Sie den Frame-für-Frame-Text „Good Luck“ von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das Spiel implementiert es, indem es die Position des vertikalen Bildlaufs der Hintergrundebene 3 (BG3) ändert. Die Dashboard-Anzeige auf der linken Seite (wo Sie sehen können, dass der Spieler 39 Raketen hat) befindet sich jedoch ebenfalls auf derselben Hintergrundebene.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Spiel schafft es, diese Trennung durchzuführen, indem die Position der BG3-Schriftrolle in jeder Rasterzeile geändert wird, nachdem das linke Dashboard gerendert wurde, aber bevor der Text „Good Luck“ gerendert wird. Dies ist möglich, da BG3 außerhalb des Dashboards und des Texts transparent ist und zwischen diesen beiden Punkten unabhängig vom Wert des vertikalen Bildlaufregisters nichts zu zeichnen ist. Dieses Verhalten zeigt uns , </font><font style="vertical-align: inherit;">dass Scrollen Register </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in jedem Stadium des Rendering verändert.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/880/658/047/8806580479dcbbaf6671fc971c12ba8b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser kleine Schatten unter dem Flugzeug bereitete dem präzisionsbesessenen Emulatorentwickler einige Kopfschmerzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Bild oben zeigt den berüchtigten Schatten eines Flugzeugs. Dieser Effekt wird durch Ändern des Bildschirmhelligkeitsregisters mit kurzen Wellen über fünf Rasterlinien gerendert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während des Spiels können Sie sehen, dass dieser Schatten ziemlich chaotisch ist. Im obigen Bild sieht es ein bisschen wie der Buchstabe "c" aus, aber seine Form in jeder Rasterlinie ändert sich in Länge und Startpunkt mit jedem Frame. Die Entwickler von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol haben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nur grob umrissen, wo der Schatten erscheinen soll, und dieses Problem direkt gelöst. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den meisten Fällen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktioniert dies.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die korrekte Emulation eines solchen Verhaltens erfordert ein perfektes Timing, was im Emulator </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">äußerst</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schwierig zu </font><font style="vertical-align: inherit;">erreichen ist </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c5/b7f/fa2/1c5b7ffa2601b6480209321b60a131a1.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pausenbildschirm </font><font style="vertical-align: inherit;">werden Rastereffekte verwendet, die in keinem anderen SNES-Spiel absichtlich verwendet wurden.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lassen Sie uns nun über den Pausenbildschirm sprechen. Es schaltet BG3 ein, während links ein gelb-schwarzer Rand gezeichnet wird, und schaltet es während desselben Randes rechts wieder aus, um graue Linien auf dem Bildschirm zu zeichnen. Er wechselt auch abwechselnd durch den Rahmen die Rasterlinien, in denen diese grauen Linien angezeigt werden, um den Effekt eines Overlay-Jitters zu erzeugen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie das oben gezeigte emulierte Bild vergrößern, werden Sie feststellen, dass während des Rasterlinienpaars in der linken Ecke dieser grauen Linien mehrere Pixel fehlen. Es ist passiert, weil meine PPU-Emulation in Taktzyklen zu 100% unvollständig ist. In diesem Fall wird BG3 etwas später aktiviert, als es sollte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich kann die Timings sehr einfach ändern, damit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bild korrekt wiedergegeben wird. Eine solche Änderung wirkt sich jedoch wahrscheinlich nachteilig auf </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiele aus, die die PPU-Anzeigeregister in der Mitte der Rasterzeile ändern. Obwohl </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das einzige Spiel ist, das dies absichtlich tut, gibt es mindestens ein Dutzend Spiele, in denen dies zufällig geschieht (möglicherweise wird es früher oder später von IRQ ausgelöst). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal führt dies zu kurzen spürbaren Schäden am Bild, die bei der Entwicklung nicht berücksichtigt werden (z. B. bei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollgasrennen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">während des Übergangs zwischen dem Laden und dem Spiel). Manchmal wird eine Aufzeichnung durchgeführt, während der Bildschirm gerendert wird, der im Rest transparent ist und daher keine visuellen Anomalien verursacht (z. B. bei der Anzeige des HP-Status in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dai Kaijuu Monogatari II</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Aber selbst solche „unsichtbaren“ </font><i><font style="vertical-align: inherit;">Randfälle</font></i><font style="vertical-align: inherit;"> können Probleme beim weniger genauen Rendern von </font><i><font style="vertical-align: inherit;">Rasterlinien</font></i><font style="vertical-align: inherit;"> verursachen die in den produktivsten Emulatoren verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst wenn Sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ignorieren </font><font style="vertical-align: inherit;">, können Sie mit all diesen zufälligen (aber gültigen) Rastereffekten in der SNES-Software keinen PPU-Renderer funktional entwerfen, der die gesamte Rasterlinie mit perfekter Taktgenauigkeit generiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Fall von bsnes über die Jahre des Versuchs und Irrtums haben wir eine Liste solcher Spiele mit „Rastereffekten“ erstellt. </font><font style="vertical-align: inherit;">Wir haben auch individuelle Rendering-Positionen erstellt, die ein viel schnelleres Rendern basierend auf Rasterlinien ermöglichen, um alle diese Spiele korrekt anzuzeigen (außer </font><font style="vertical-align: inherit;">natürlich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Aber im Wesentlichen ist dies eine Reihe von Hacks, die für uns unangenehm sind und für bestimmte Spiele entwickelt wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe auch einen uhrbasierten PPU-Renderer, der nicht alle diese Hacks benötigt, aber von Zeit zu Zeit kleine (ein bis vier Pixel) Unterschiede beim Rendern dieses Geräts erzeugt, wie im obigen Screenshot von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interne Latch-Register</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Grund für all diese kleinen Fehler liegt in der zeitlichen Abstimmung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, SNES rendert seinen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berühmten Modus 7</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bei dem es sich um eine affine Texturtransformation mit Parameteränderungen in jeder Rasterzeile handelt. </font><font style="vertical-align: inherit;">Um ein Bildschirmpixel zu bestimmen, müssen Sie ähnliche Berechnungen durchführen:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">px = a * clip (hoffset - hcenter) + b * clip (voffset - vcenter) +</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b * y + (hcenter &lt;&lt; 8)</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
py = c * clip (hoffset - hcenter) + d * clip (voffset - vcenter) +</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
d * y + (vcenter &lt;&lt; 8)</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Real SNES kann nicht alle sechs Multiplikationen für jedes Pixel, das im Frame gerendert wird, schnell genug ausführen. </font><font style="vertical-align: inherit;">Aber keiner dieser Werte ändert sich für jedes Pixel (oder sollte sich zumindest nicht ändern), sodass wir px und py nur einmal am Anfang jeder Rasterzeile berechnen müssen. </font><font style="vertical-align: inherit;">Das heißt, PPU speichert statische Ergebnisse in Latches zwischen, die im Wesentlichen Kopien von PPU-Registern sind. </font><font style="vertical-align: inherit;">In Zukunft können sie transformiert werden oder unverändert bleiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann werden die x, y-Koordinaten durch Modus 7 wie folgt transformiert:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ox = (px + a * x) &gt;&gt; 8</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
oy = (py + c * x) &gt;&gt; 8</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl x für jedes Pixel variiert, wissen wir, dass das Inkrement jedes Mal um eins ausgeführt wird. Dank der Speicherung interner Laufwerke können wir ox und oy einfach für jedes Pixel konstante Werte a und c hinzufügen, anstatt zwei Multiplikationen für jedes Pixel durchzuführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann stellt sich vor uns die Frage: In welcher bestimmten Position des Taktzyklus liest die PPU die Werte von a und c aus den externen PPU-Registern, auf die die CPU Zugriff hat? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir sie zu früh nehmen, kann dies einige Spiele brechen. Wenn wir es zu spät nehmen, kann es andere Spiele brechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am einfachsten ist es, auf Fehlerberichte zu warten und diese Positionen anzupassen, um Probleme in den einzelnen Spielen zu beheben. In diesem Fall werden wir jedoch niemals die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genauen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Positionen finden, </font><font style="vertical-align: inherit;">sondern </font><font style="vertical-align: inherit;">nur deren Annäherungen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jedes Mal, wenn wir eine dieser Variablen ändern, ist es für uns unrealistisch, alle dreieinhalbtausend Spiele aus der SNES-Bibliothek erneut zu testen, um festzustellen, welche Verschlechterung unsere Änderungen bewirken könnten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus der Pfanne ins Feuer</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/741/b84/c0a741b84071dd0252021ae422277c1a.jpg"></div> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Künstlerische Interpretation des Prozesses zur Beseitigung von Emulationsfehlern.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Eine ähnliche Art der Testmethode: "Wir machen nur das Spiel, an dem wir interessiert sind, um jeden Preis" führte zu dem Phänomen, das ich Emulation "vom Feuer, aber ins Feuer" nenne. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu Beginn der Entwicklung der SNES-Emulation, wenn Probleme im Spiel auftraten, wurde </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jede</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Korrektur in diesem Spiel, die es ermöglichte, akzeptiert und dem Emulator hinzugefügt. Dieser Fix hat notwendigerweise ein anderes Spiel kaputt gemacht. Und dann haben sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiel </font><font style="vertical-align: inherit;">korrigiert </font><font style="vertical-align: inherit;">, woraufhin das dritte kaputt ging. Das dritte Spiel erneut zu reparieren, brach das erste. Dies dauerte viele Jahre.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Fehler dabei war, dass die Entwickler versuchten, jeweils nur eine Variable zu berücksichtigen. Angenommen, wir haben ein Spiel, und damit es funktioniert, müssen Ereignisse zwischen Takt 20 und 120 auftreten. Wir kennen den genauen Takt nicht, wählen Sie also einfach 70 genau in der Mitte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Später erhalten wir einen Fehlerbericht in einem anderen Spiel und stellen fest, dass </font><font style="vertical-align: inherit;">der Messwert </font><font style="vertical-align: inherit;">für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiel zwischen 10 und 60 liegen sollte. Jetzt ändern wir ihn auf 40, was für beide Spiele funktioniert. Klingt logisch! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber dann erscheint das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dritte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiel, in dem das Ereignis zwischen Takt 80 und 160 funktionieren sollte! Jetzt können wir nicht alle drei Spiele gleichzeitig mit demselben Wert zum Laufen bringen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies zwang Emulatorentwickler, Hacks für bestimmte Spiele zu erstellen. </font><font style="vertical-align: inherit;">Codierer möchten keinen Emulator veröffentlichen, in dem Sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mario</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zelda</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metroid</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht ausführen können </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher wird für den allgemeinen Fall der Taktzyklus 40 verwendet, aber beim Laden von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metroid</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erzwingen wir den Zeitwert auf 100. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie ist dies möglich, warum benötigen zwei Spiele unterschiedliche Werte? </font><font style="vertical-align: inherit;">Dies geschieht, weil hier nicht nur eine Variable beteiligt ist. </font><font style="vertical-align: inherit;">Das Timing, das Sie zuvor zum Auslösen eines anderen Ereignisses verwendet haben, kann sich auf den Timing-Wert auswirken, der für das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nächste</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ereignis </font><font style="vertical-align: inherit;">erforderlich ist </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich dies in Form eines einfachen algebraischen Ausdrucks vor:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2x + y = 120</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können es lösen, indem Sie x = 10, y = 100 nehmen. Oder x = 20, y = 80. Oder x = 30, y = 60. Wenn wir nur an den Wert von x denken, mit dem Sie gleichzeitig eine Reihe von Spielen ausführen können, übersehen wir die Tatsache, dass das Problem möglicherweise im falschen y liegt! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten Versionen von Emulatoren zur Erhöhung der Kompatibilität haben den Wert von x je nach laufendem Spiel einfach neu definiert. Solche einzelnen Spiel-Hacks blieben bestehen, auch wenn später der richtige Einzelwert von x entdeckt wurde. Das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problem </font><font style="vertical-align: inherit;">würde also niemals gelöst werden!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei SNES sind jedoch nicht eine oder zwei Variablen gleichzeitig beteiligt. Allein die SNES-Konsolen-PPU verfügt über 52 externe Register, was ungefähr 130 Parametern entspricht. Beim Rendern einer einzelnen Rasterzeile sind alle 130 dieser Parameter und eine unbekannte Anzahl interner Register und Latches beteiligt. Dies sind zu viele Informationen, als dass jemand außerhalb den Status der PPU zu einem bestimmten Zeitpunkt vollständig erfassen könnte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Aspekt der Emulation ist für Uneingeweihte nicht offensichtlich, aber sehr fair: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genauigkeit ist</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht gleich </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompatibilität</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir können einen Emulator mit einer Genauigkeit von 99 Prozent erstellen, der 10% der Spiele ausführen kann. </font><font style="vertical-align: inherit;">Und Sie können einen 80% genauen Emulator schreiben, der 98% der Spiele ausführt. </font><font style="vertical-align: inherit;">Manchmal bricht eine korrekte Implementierung kurzfristig beliebte Spiele. </font><font style="vertical-align: inherit;">Dies ist ein notwendiges Opfer, wenn Sie versuchen, sowohl 100% Genauigkeit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als auch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100% Kompatibilität zu erreichen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem lösen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dank deduktiver Überlegungen und Ergebnissen in der realen Welt haben wir die aktuelle Stufe der PPU-Emulation erreicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wissen, dass zwei PPUs Zugriff auf zwei VRAM-Chips haben. </font><font style="vertical-align: inherit;">Wir wissen, dass sie von jedem Chip eine bekannte Anzahl von Datenbytes pro Rasterzeile lesen können. </font><font style="vertical-align: inherit;">Wir kennen die groben Details der Funktionsweise der einzelnen SNES-Videomodi. </font><font style="vertical-align: inherit;">Auf dieser Grundlage können wir ein verallgemeinertes Muster für das Erscheinungsbild der Architektur skizzieren. </font><font style="vertical-align: inherit;">Hier ist zum Beispiel ein kurzes Beispiel, wie die ersten drei SNES-Videomodi funktionieren können:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if (io.bgMode == 0) {</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg4.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg4.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}}</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
if (io.bgMode == 1) {</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchCharacter (1);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchCharacter (1);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}}</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
if (io.bgMode == 2) {</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchNameTable ();</font></font><font></font>
<font></font>
bg3.fetchOffset(0);<font></font>
<font></font>
bg3.fetchOffset(8);<font></font>
<font></font>
bg2.fetchCharacter(0);<font></font>
<font></font>
bg2.fetchCharacter(1);<font></font>
<font></font>
bg1.fetchCharacter(0);<font></font>
<font></font>
bg1.fetchCharacter(1);<font></font>
<font></font>
}</pre></blockquote><br>
<h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die PPU zeigt einem Drittbeobachter nur einen kleinen Teil ihres Zustands: horizontale / vertikale Austastflags, horizontale und vertikale Pixelanzahl und Kachelüberlagerungsflags im Intervall für Sprites. Das ist nicht so sehr, aber ich wiederhole - jedes winzige Element des Staates, das dem Beobachter zugänglich ist, hilft uns. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der VRAM (Video-RAM, Videospeicher) des PPU-Chips während des Renderns ist auch zum Lesen für SNES-CPUs geschlossen. Wie sich herausstellte, sind OAM (Sprite-Speicher) und CGRAM (Palettenspeicher) geöffnet. Der Trick ist, dass zu diesem Zeitpunkt die PPU den Adressbus steuert. Daher kann ich beim Lesen von OAM und CGRAM während des Bildschirm-Renderings beobachten, was die PPU zu einem so kritischen Zeitpunkt von diesen beiden Speicherblöcken erhält.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies sind nicht alle Teile des Puzzles, aber sie reichen mir aus, um die praktisch richtigen Muster für das Erhalten von Sprites implementieren zu können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mithilfe von Zugriffsmustern für offenes OAM und CGRAM, PPU-Flags, allgemeinen Beobachtungen (d. H. Vermutungen) aus Fehlerberichten für verschiedene Spiele und deduktiven Überlegungen konnten wir uhrbasierte PPU-Renderer erstellen </font><font style="vertical-align: inherit;">, mit denen alle veröffentlichten Spiele </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nahezu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perfekt </font><font style="vertical-align: inherit;">gestartet werden können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Situation ist jedoch immer noch prekär: Wenn jemand anfängt, Homebrew-Spiele mit genauem Timing von Ticks und Rastereffekten zu erstellen, können alle unsere modernen Emulatoren damit nicht umgehen. Einschließlich auf FPGA basierender Software- und Hardware-Implementierungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich muss klar sagen: heute </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alles</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie kennen nur die interne Reihenfolge der Operationen und das Fangverhalten in den PPU-Chips der SNES-Konsole. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Niemand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> weiß, wie man sie perfekt emuliert. </font><font style="vertical-align: inherit;">Zumindest für jetzt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mögliche Lösungen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was sollen wir damit machen? </font><font style="vertical-align: inherit;">Wie kann man die genaue Reihenfolge der Operationen in einer PPU bestimmen, wenn es sich aus Sicht der SNES-CPU um eine "Black Box" handelt? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich sehe vier mögliche Optionen: Logikanalysatoren, digitale Videoausgabe im Testmodus, Riser und Entfernen von Abdeckungen von Chips.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logikanalysatoren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich die oben gezeigten Scans von PPU-Kristallen ansehen, werden Sie schwarze Bereiche an den Rändern des Chips bemerken. Dies sind die Plattformen, die mit den Kontakten der Chips verbunden sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Pins speichern den Zustand der PPU-Chips während jedes Taktzyklus. Hier finden Sie die aktuelle Adresse, an die die Chips auf den Videospeicherchip zugreifen, die Werte der von einer PPU zur zweiten übertragenen Daten und vieles mehr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Informationen sind für Code, der auf der SNES-CPU ausgeführt wird, nicht verfügbar, liefern jedoch wertvolle Beobachtungen zur internen Reihenfolge der PPU-Operationen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c8/157/c0d/2c8157c0df8caaebd7e24f620bf2c60f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Anschließen von Super NES-Konsolen-PPUs an einen ähnlichen Logikanalysator kann der Schlüssel zur Black Box sein. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das entscheidende Problem von Logikanalysatoren besteht darin, dass sie nicht sehr bequem zu verwalten sind: Wenn Sie versuchen, Live-Daten von einem funktionierenden System abzutasten, erhalten wir einen Strom von Ergebnissen, der ziemlich schwer zu entschlüsseln ist. </font><font style="vertical-align: inherit;">Wenn Sie versuchen, die analoge RGB-Ausgabe des Systems zu analysieren, tritt dasselbe Problem auf: Um diese Daten zu erfassen, müssen Sie jeden der Tests manuell durchführen. </font><font style="vertical-align: inherit;">Ein solches System ist nicht sehr gut für die Erstellung reproduzierbarer automatisierter Regressionstests.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digitaler Videoausgang im Testmodus</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kürzlich wurde durch einen Scan von Kristallschnitten mit 20-facher Vergrößerung ein geheimer Testmodus in den PPU-Chips der SNES-Konsole entdeckt. Wenn Sie eine kleine Hardwaremodifikation vornehmen, gibt </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die PPU ein digitales 15-Bit-RGB-Signal aus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist fast was wir brauchen! Dieser Modus weist jedoch Probleme auf, da der berühmte Modus 7 nicht das richtige Bild anzeigen kann. Es scheint, dass diese Funktion nicht vollständig abgeschlossen wurde.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Methode zu implementieren, sind weiterhin manuelle Änderungen an SNES-Konsolen und ein geeigneter Mechanismus zum Erfassen und Analysieren der Ausgabe im Testmodus erforderlich. </font><font style="vertical-align: inherit;">Im Gegensatz zu einer Lösung mit der Erfassung eines analogen RGB-Signals kann ein solches digitales Signal jedoch automatisch getestet werden, wodurch wir schnell einen großen Teil der Arbeit am PPU-Reverse Engineering erledigen können.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Riser</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die PPUs statisch sind, können wir die PPU-Chips von einer funktionierenden SNES-Konsole entfernen und sie zusammen mit zwei VRAM-Chips an eine Prototyping-Karte oder eine maßgeschneiderte Leiterplatte anschließen. </font><font style="vertical-align: inherit;">Danach können Sie einen Mikrocontroller zwischen der PPU und der USB-Schnittstelle platzieren und die Schnittstelle an den PC anschließen, sodass der Encoder alle externen Videospeicherregister und PPUs programmieren kann. </font><font style="vertical-align: inherit;">Darüber hinaus kann der Codierer die PPU-Taktzyklen manuell steuern und die resultierenden Signale in jedem Taktzyklus auf den E / A-Anschlüssen, Registern und im PPU-Speicher lesen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indem Sie den Software-Emulator so modifizieren, dass er die gleichen internen Werte der E / A-Anschlüsse generiert, können Sie echte Hardware auch in Echtzeit direkt mit der Emulation vergleichen. </font><font style="vertical-align: inherit;">Dies wird jedoch sehr harte Arbeit sein, da wir die internen PPU-Operationen noch nicht sehen können.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernen der Abdeckung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die extremste Lösung besteht darin, den Kristall weiter zu untersuchen, indem die Chipabdeckung entfernt wird. </font><font style="vertical-align: inherit;">Wir haben bereits Kristall-Scans mit einer 20-fachen Vergrößerung, aber ihre Auflösung reicht nicht aus, um einzelne Logikschaltungen zu analysieren und neu zu erstellen, wie dies im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visual 6502-Projekt durchgeführt wurde</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn wir die Kristall-Scans beider PPUs mit einer 100-fachen Vergrößerung erhalten können, können wir mit der harten Arbeit beginnen, PPU-Schaltungen zu kompilieren und sie in Verbindungstabellen oder VHDL-Code zu konvertieren. </font><font style="vertical-align: inherit;">Dann können sie direkt im FPGA verwendet sowie auf C ++ oder eine andere Programmiersprache portiert werden, die zum Erstellen von Softwareemulatoren geeignet ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Spezialist, der dies zuvor getan hatte, gab mir eine grobe Schätzung: Es würde ungefähr 600 Stunden dauern, um beide PPUs abzubilden. </font><font style="vertical-align: inherit;">Diese Aufgabe ist viel höher als das Niveau „Lasst uns Geld sammeln, indem wir Spenden sammeln und jemanden bezahlen“ und fällt idealerweise in die Kategorie „Hoffen wir, dass jemand, der sehr talentiert ist und über einzigartige Fähigkeiten verfügt, uns freiwillig helfen möchte“. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das bedeutet natürlich nicht, dass ich nicht gerne jemanden für seine Hilfe finanziell belohnen würde, ich kann für die notwendigen Details und die Arbeit bezahlen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitte um Hilfe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammenfassend: Ich bin in meinem SNES-Emulatorprojekt so weit wie möglich gegangen und brauche Hilfe, um diese letzte Aufgabe zu erledigen. </font><font style="vertical-align: inherit;">Wenn Sie bis zum Ende gelesen haben, möchten Sie vielleicht helfen! </font><font style="vertical-align: inherit;">Jede Unterstützung, einschließlich der Teilnahme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am bsnes-Projekt auf GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder jeglicher Forschungsdokumentation zum internen Betrieb von PPU-Chips, ist für uns von unschätzbarem Wert! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielen Dank fürs Lesen und für Ihre Unterstützung! </font><font style="vertical-align: inherit;">Es ist mir seit fünfzehn Jahren eine Ehre, Mitglied der SNES-Emulationsgemeinschaft zu sein.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495256/index.html">Informationen zu Ports und Verschlüsselung in Mailservern</a></li>
<li><a href="../de495258/index.html">Wie Zoom im Zeitalter des Coronavirus zum wichtigsten Unternehmen wurde</a></li>
<li><a href="../de495262/index.html">PostgreSQL-Versions-Upgrade-Praxis. Andrey Salnikov</a></li>
<li><a href="../de495266/index.html">E-Learning der Renaissance. Warum 2020 alle Vorteile des Fernunterrichts aufzeigen wird</a></li>
<li><a href="../de495268/index.html">UI / UX-Fall: Parkautomatisierung am Flughafen</a></li>
<li><a href="../de495274/index.html">So beheben Sie Routenlecks</a></li>
<li><a href="../de495276/index.html">Und zeigen Sie, oder wie wir das Operational Sustainability Audit am Uptime Institute bestanden haben</a></li>
<li><a href="../de495278/index.html">Datenbanken, Karten, Checklisten oder Warum ein Business Knowledge Manager</a></li>
<li><a href="../de495280/index.html">Max Patrol SIEM. Übersicht über das Informationssicherheits-Ereignisverwaltungssystem</a></li>
<li><a href="../de495282/index.html">XML-Validierung mit XSD, JAXB und Spring Framework</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>