<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüî¨ üí´ üïØÔ∏è SNES-Emulatoren nur wenige Pixel von der absoluten Perfektion entfernt üë©üèæ‚Äçüîß üê¢ üëò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir sind so nah dran, einen Emulator zu entwickeln, der alle Funktionen von echter Hardware und SNES-Software perfekt nachbilden kann. 
 
 In den letz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SNES-Emulatoren nur wenige Pixel von der absoluten Perfektion entfernt</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495272/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/f3b/e14/44bf3be14304180044d2e7deb216f07d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind so nah dran, einen Emulator zu entwickeln, der alle Funktionen von echter Hardware und SNES-Software perfekt nachbilden kann. </font></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den letzten 15 Jahren habe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ich </font><font style="vertical-align: inherit;">als Codierer f√ºr den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bsnes-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Emulator </font><font style="vertical-align: inherit;">versucht, die Super Nintendo-Emulation zu perfektionieren, aber jetzt stehen wir vor dem letzten Problem: dem genauen Timing der Taktzyklen der SNES-Videoprozessoren. </font><font style="vertical-align: inherit;">Um diese letzte Stufe der Emulationsgenauigkeit zu erreichen, ist die Hilfe der gesamten Community erforderlich, und ich hoffe auf Ihre Unterst√ºtzung. </font><font style="vertical-align: inherit;">Aber zuerst werde ich Ihnen sagen, was wir bereits erreicht haben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktuellen Zustand</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heute ist die Situation mit der SNES-Emulation sehr gut. Abgesehen von den ungew√∂hnlichen Peripherieger√§ten, die der Emulation widerstehen (z. B. einem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Golfschl√§ger mit Lichtsensor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , einem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fahrradsimulator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und einem DF√ú-Modem, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Japan </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">f√ºr Pferderennen in</font></a><font style="vertical-align: inherit;"> Japan verwendet werden), sind alle offiziell lizenzierten SNES-Spiele vollst√§ndig spielbar. und kein Spiel hat offensichtliche Probleme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die SNES-Emulation wurde so pr√§zise, ‚Äã‚Äãdass ich den Emulator sogar in zwei Versionen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aufteilen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> musste </font><font style="vertical-align: inherit;">: </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">higan</font></a><font style="vertical-align: inherit;"> , das absolute Genauigkeit und Konsistenz mit der Hardwaredokumentation </font><font style="vertical-align: inherit;">anstrebt </font><font style="vertical-align: inherit;">, und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bsnes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das Geschwindigkeit, breite Funktionen und Benutzerfreundlichkeit anstrebt.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In j√ºngster Zeit wurden auf dem Gebiet der SNES-Emulation viele interessante Erfolge erzielt, darunter:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Low-Level-Emulation aller SNES-Coprozessoren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterst√ºtzung f√ºr HD-Modus 7</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausbau der Bremse</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breitbild-Unterst√ºtzung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSU1 f√ºr CD-Audio und FMV</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorl√§ufige Ausf√ºhrung zur Reduzierung von Verz√∂gerungen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamische Datenratensteuerung f√ºr perfekte Audio- und Videosynchronisation</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¶ und vieles mehr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also ist es fertig? Haben alle gut gearbeitet, tsch√ºss, und danke f√ºr den Fisch? Nicht ganz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heute haben wir bei fast allen SNES-Komponenten eine Genauigkeit auf Schlagniveau erreicht. Die einzigen Ausnahmen waren die PPU (Bildverarbeitungseinheit, Bildverarbeitungsmodule), die zum Erzeugen von auf den Bildschirm √ºbertragenen Videobildern verwendet wurden. Wir </font><font style="vertical-align: inherit;">wissen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meistens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wie PPUs funktionieren, aber f√ºr einige Funktionen m√ºssen wir Vermutungen anstellen, was zu einer unvollst√§ndigen Genauigkeit f√ºhrt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen sind die verbleibenden Probleme ziemlich gering. Wenn Sie nicht nach der absolut perfekten Idealit√§t der Emulation aus Liebe zur Kunst streben, kann ich Sie nicht von der Notwendigkeit √ºberzeugen, die PPU-Emulation weiter zu verbessern. Wie in jedem Bereich ist die Rendite umso geringer, je n√§her wir dem Ideal sind.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber ich kann sagen, warum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mir das</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wichtig </font><i><font style="vertical-align: inherit;">ist</font></i><font style="vertical-align: inherit;"> : Dies ist die Arbeit meines ganzen Lebens, und ich m√∂chte nicht, dass ich sage, dass ich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kurz vor dem Abschluss </font><font style="vertical-align: inherit;">bin </font><font style="vertical-align: inherit;">, ohne den letzten Schritt zu </font><font style="vertical-align: inherit;">tun </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich altern und ich bin nicht ewig. </font><font style="vertical-align: inherit;">Ich m√∂chte, dass das letzte Puzzleteil gel√∂st wird, damit ich nach meiner Pensionierung sicher bin, dass das SNES-Erbe dank der Emulation zuverl√§ssig und vollst√§ndig erhalten bleibt. </font><font style="vertical-align: inherit;">Ich m√∂chte sagen, dass das Problem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gel√∂st ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie immer noch fasziniert sind, lesen Sie weiter, um sich mit dem Hintergrund eines Problems und den von mir angebotenen L√∂sungen vertraut zu machen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modellierung der SNES-Architektur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit der Auflistung der Komponenten, aus denen SNES besteht:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3c/f4f/e25/c3cf4fe250fbbed2b897e46ef58628bd.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super NES Systemdiagramm. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Pfeile geben die Richtungen an, in denen verschiedene SNES-Prozessoren Daten miteinander austauschen k√∂nnen, und die gepunkteten Linien geben die Verbindungen zu den Speicherchips an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Wichtigste f√ºr uns ist jetzt, dass die Ausgabe von Video und Ton direkt von PPU und DSP √ºbertragen wird. </font><font style="vertical-align: inherit;">Dies bedeutet, dass sie als "Black Boxes" fungieren und wir nicht sehen k√∂nnen, was in ihnen geschieht. </font><font style="vertical-align: inherit;">Sp√§ter wird es uns wichtig.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtigkeit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich vor, wir emulieren den CPU-Befehl "multiplizieren", der zwei Register (Variablen) verwendet, diese multipliziert, das Ergebnis und mehrere Flags empf√§ngt, die den Status des Ergebnisses anzeigen (z. B. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberlauf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen ein Programm schreiben, das jeden m√∂glichen Wert von 0 bis 255 als Faktor und Multiplikator multipliziert. Dann k√∂nnen wir die numerischen und Flag-Multiplikationsergebnisse ableiten. Somit erhalten wir zwei Tabellen mit 65 536 Elementen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch die Analyse dieser Tabellen k√∂nnen wir genau bestimmen, wie und wo die Ergebnisse von CPU-Berechnungen auf bestimmte Weise festgelegt werden. Dann k√∂nnen wir die Emulatoren so √§ndern, dass wir beim Ausf√ºhren des gleichen Tests genau die gleichen Tabellen zur gleichen Zeit erhalten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir nun an, die CPU kann 16-Bit x 16-Bit-Multiplikation durchf√ºhren. Wenn jeder m√∂gliche Wert getestet wird, werden 4 Milliarden Ergebnisse generiert, die in angemessener Zeit kaum zu testen sind. Wenn die CPU Multiplikationen von 32 Bit x 32 Bit hat, ist es in der Praxis nicht m√∂glich, alle Kombinationen von Eingabewerten vor dem thermischen Tod des Universums zu testen (zumindest auf dem aktuellen Stand der Technik). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In solchen F√§llen handeln wir bei den Tests selektiver und versuchen festzustellen, wann sich die Flags genau √§ndern k√∂nnen, wann die Ergebnisse √ºberlaufen k√∂nnen und so weiter. Andernfalls m√ºssten wir Tests durchf√ºhren, die niemals enden w√ºrden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Multiplikation ist eine eher triviale Operation, aber das gleiche Prinzip kann auf den gesamten Prozess des Reverse Engineering ausgedehnt werden, einschlie√ülich komplexerer Operationen, beispielsweise der Daten√ºbertragung √ºber DMA (direkter Speicherzugriff) w√§hrend der horizontalen R√ºckgabe des Strahls. </font><font style="vertical-align: inherit;">Wir erstellen Tests, die versuchen festzustellen, was in Grenzf√§llen passiert, und pr√ºfen dann, ob sich unsere Emulation identisch mit dem Verhalten von echtem SNES verh√§lt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Signalgeneratoren und Beats</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SNES verf√ºgt √ºber zwei Signalgeneratoren (Oszillatoren): einen Quarzoszillator, der mit einer Frequenz von ungef√§hr 21 MHz arbeitet (er steuert die CPU- und PPU-Module), und einen Keramikresonator, der mit einer Frequenz von ungef√§hr 24 MHz arbeitet und SMP und DSP steuert. </font><font style="vertical-align: inherit;">In Cartridge-Coprozessoren wird manchmal ein 21-MHz-Quarzoszillator verwendet, und manchmal arbeiten eigene Signalgeneratoren mit anderen Frequenzen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97d/ecb/bc1/97decbbc1161fcf170f063d2fd42795d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Wiederherstellen dieser Super Famicom-Platine im Code ist schwieriger als es sich anh√∂rt.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Die Uhr ist das Grundelement des Timings eines jeden Systems, und SNES ist daf√ºr ausgelegt, verschiedene Aufgaben mit bestimmten Frequenzen und Zeitintervallen auszuf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich einen 100-Hertz-Takt vorstellen, ist dies ein Ger√§t mit einem Bin√§rausgang, der 100 Mal pro Sekunde auf einen hohen logischen Zustand des Signals (z. B. +5 V) und dann auf einen niedrigen Zustand des Signals (0 V oder Masse) umschaltet. Das hei√üt, jede Sekunde schwankt die Spannung am Ausgang 200-mal: 100-mal erh√∂ht und 100-mal die Vorderseite des Taktsignals abgesenkt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Taktzyklus wird normalerweise als ein vollst√§ndiger √úbergang betrachtet, dh ein 100-Hz-Zyklus erzeugt 100 Taktzyklen pro Sekunde. </font><font style="vertical-align: inherit;">Einige Systeme erfordern eine Unterscheidung zwischen ansteigenden und abfallenden Flanken, und f√ºr sie unterteilen wir den Zyklus in Halbzyklen, um jede Phase (hoch oder niedrig) des Taktsignals anzuzeigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die wichtigste Aufgabe eines genauen Emulators besteht darin, Aufgaben genauso und in genau derselben Zeit wie bei realen Ger√§ten zu erledigen. </font><font style="vertical-align: inherit;">Es ist jedoch nicht sehr wichtig, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgaben ausgef√ºhrt werden. </font><font style="vertical-align: inherit;">Das einzige, was wichtig ist, ist, dass der Emulator, der dieselben Eingangssignale empf√§ngt, dieselben Ausgangssignale zur gleichen Zeit wie auf realer Hardware erzeugt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Timings</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal brauchen Operationen Zeit. Nehmen wir zum Beispiel die Multiplikation in der SNES-CPU. Anstatt anzuhalten und auf den Abschluss der Multiplikation zu warten, berechnet die SNES-CPU das Ergebnis der Multiplikation bitweise im Hintergrund f√ºr acht Taktzyklen der CPU-Opcodes. Auf diese Weise kann der Code m√∂glicherweise andere Aufgaben ausf√ºhren, w√§hrend er auf den Abschluss der Multiplikation wartet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√∂chstwahrscheinlich wartet jede kommerzielle Software auf diese acht Zyklen. Wenn Sie versuchen, das Ergebnis zu lesen, bevor es fertig ist, erhalten wir ein teilweise abgeschlossenes Ergebnis. Bevor jedoch SNES-Emulatoren </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sofort</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> korrekte Ergebnisse lieferten </font><font style="vertical-align: inherit;">, ohne auf diese zus√§tzlichen Taktzyklen zu warten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Konsolenfans begannen, selbst geschriebene Software in Emulatoren zu erstellen und zu testen, verursachte diese Diskrepanz bestimmte Probleme. Ein Teil der Software, zum Beispiel viele der ersten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super Mario World</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ROM-Hacks </font><font style="vertical-align: inherit;">, funktionierte nur in diesen alten Emulatoren korrekt, nicht jedoch auf echter SNES-Hardware. Dies geschah, weil sie unter Ber√ºcksichtigung des Zeitpunkts (aus Sicht der realen Ausr√ºstung unzuverl√§ssig) der Multiplikationsergebnisse entwickelt wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Verbesserung der Emulatoren wurde die Kompatibilit√§t alter Software beeintr√§chtigt, und daher mussten wir den neuen Emulatoren Kompatibilit√§tsoptionen hinzuf√ºgen, um diese Programme nicht zu verlieren. Ja, egal wie surreal es klingt, aber heute m√ºssen Emulatoren andere Emulatoren emulieren!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Bequemlichkeit dieser Multiplikationsverz√∂gerung in der CPU liegt in der Tatsache, dass sie sehr vorhersehbar ist: Acht Taktzyklen von Berechnungen beginnen unmittelbar nach der Anforderung der Multiplikationsoperation. </font><font style="vertical-align: inherit;">Durch Schreiben von Code, der die Ergebnisse nach jedem Zyklus liest, konnten wir √ºberpr√ºfen, ob die SNES-CPU </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Booth-Algorithmus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur Multiplikation verwendet </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uhrensynchronisation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andere Operationen sind nicht einfach zu modellieren, da sie im Hintergrund asynchron ausgef√ºhrt werden. Ein solcher Fall ist das DRAM-Update des zentralen SNES-Prozessors. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend des Renderns jeder Rasterzeile unterbricht die gesamte SNES-CPU zu einem bestimmten Zeitpunkt ihren Betrieb f√ºr einen kurzen Zeitraum, w√§hrend der Inhalt des RAM-Chips aktualisiert wird. Dies ist erforderlich, da zur Reduzierung der Kosten in SNES dynamischer (statt statischer) RAM als Hauptspeicher der CPU verwendet wurde. Um den Inhalt des dynamischen RAM zu speichern, muss dieser regelm√§√üig aktualisiert werden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d61/cb1/ab9/d61cb1ab914186314069b09f88218fcf.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es reicht nicht aus, einen wirklich perfekten Emulator zu erstellen, um die Spielbarkeit aller dreieinhalbtausend SNES-Spiele zu gew√§hrleisten. Es ist auch notwendig, eine Simulation jeder Funktion des Systems mit perfekter Taktgenauigkeit zu erreichen.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Der Schl√ºsselfaktor bei der Analyse der genauen Zeitpunkte dieser Operationen war die M√∂glichkeit, horizontale und vertikale PPU-Z√§hler zu verwenden. Diese Z√§hler f√ºhren Inkremente durch und werden nach jeder umgekehrten horizontalen und vertikalen Strahlbewegung zur√ºckgesetzt. Ihre Genauigkeit betr√§gt jedoch nur ein Viertel der Frequenz des SNES-CPU-Signalgenerators. Mit anderen Worten, der horizontale Z√§hler erh√∂ht sich alle vier Taktzyklen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch mehrmaliges Lesen der Werte der Z√§hler konnte ich feststellen, auf welches Viertel des Taktzyklus der Z√§hler ausgerichtet ist. Durch die Kombination dieses Wissens mit speziell erstellten Funktionen, die einen Schritt in Richtung der vom Benutzer angegebenen genauen Anzahl von Taktzyklen machen k√∂nnen, konnte ich die SNES-CPU perfekt auf jede genaue Position des von mir ben√∂tigten Taktzyklus abstimmen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dank eines iterativen Durchlaufs vieler Taktzyklen konnte ich feststellen, wann bestimmte Operationen genau ausgef√ºhrt werden (z. B. Aktualisieren des DRAM, √úbertragen von HDMA, Abrufen von Interrupts usw.). Danach konnte ich all dies in der Emulation genau nachbilden. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SMP-Chip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die SNES-Konsole verf√ºgt auch √ºber eigene Timer, und f√ºr diesen Prozessor wurde auch ein erfolgreiches Reverse Engineering durchgef√ºhrt. </font><font style="vertical-align: inherit;">Ich kann einen ganzen Artikel nur dem SMP TEST-Register widmen, mit dem Programmierer den SMP-Frequenzteiler und seinen Timer steuern k√∂nnen, ganz zu schweigen von anderen schrecklichen Dingen. </font><font style="vertical-align: inherit;">Es wird ausreichen zu sagen, dass es kein einfacher und schneller Prozess war, aber am Ende haben wir gewonnen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sammeln Coprozessoren</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ce/8ec/80c/1ce8ec80c157a980c0222eb7462679e9.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der SuperFX-Chip ist nur einer von vielen Cartridge-Coprozessoren, die der SNES-Emulator verarbeiten kann.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Es gibt eine ganze Reihe von SNES-Coprozessoren, die in verschiedenen Spielekassetten verwendet werden und die wir auch z√§hmen mussten. Von einzelnen Allzweck-CPUs wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SuperFX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA-1 √ºber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> digitale Signalprozessoren wie DSP-1 und Cx4 bis hin zu Dekompressionsbeschleunigern wie S-DD1 und SPC7110 oder Sharp- und Epson-Echtzeituhren und vielem mehr ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass der SNES-Emulator mit SuperFX-Befehlen und Pixel-Caches umgehen muss. mit dem SA-1-Speicherbus-Konfliktl√∂sungsschema (wodurch die SNES- und SA-1-CPUs gleichzeitig denselben ROM- und RAM-Chip verwenden k√∂nnen); mit integrierter Firmware DSP-1 und Cx4; mit pr√§diktionsbasierten arithmetischen Encodern S-DD1 und SPC7110; sowie mit ungeraden Grenzf√§llen von BCD (bin√§r codierte Dezimalzahl) in Echtzeitgeneratoren. Langsam aber sicher haben wir mit allen oben beschriebenen Techniken zur Bestimmung der Korrektheit und des Timings gelernt, wie man all diese Chips nahezu perfekt emuliert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Entfernen der Chipabdeckungen und der Firmware von den in verschiedenen Spielen verwendeten digitalen Signalprozessoren war mit viel Aufwand und Tausenden von Dollar verbunden. In einem Fall ist die NEC uPD772x-Emulation zul√§ssig</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie den Code von Higan, um die Stimme des verstorbenen Stephen Hawking zu retten! </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem anderen Fall mussten wir eine ganze Reihe von Anweisungen f√ºr die Hitachi HG51B-Architektur zur√ºckentwickeln, da noch nie jemand die Dokumentation f√ºr diese Architektur ver√∂ffentlicht hatte. </font><font style="vertical-align: inherit;">In einem anderen Fall stellte sich heraus, dass ein Spiel ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hayazashi Nidan Morita Shougi 2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) eine leistungsstarke 32-Bit-ARM6-CPU mit einer Frequenz von 21 MHz hat, was das japanische Shogi-Spiel beschleunigt! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Speichern aller SNES-Coprozessoren erwies sich als langfristiger Prozess voller Schwierigkeiten und √úberraschungen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digitale Signalverarbeitung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Sony S-DSP-Chip (Digital Signal Processor), der nicht mit dem DSP-1-Kassetten-Coprozessor verwechselt werden darf, erzeugte einen einzigartigen SNES-Sound. In diesem Chip wurden acht Audiokan√§le mit 4-Bit-ADPCM-Codierung angeschlossen, wodurch die Erzeugung eines 16-Bit-Stereosignals sichergestellt wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ñu√üerlich und aus dem oben dargestellten Systemdiagramm scheint der DSP zun√§chst eine ‚ÄûBlack Box‚Äú zu sein: Wir passen die Tonkan√§le und Mischerparameter an, wonach der Chip den an die Lautsprecher √ºbertragenen Ton erzeugt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine wichtige Funktion erm√∂glichte es dem Entwickler unter dem Spitznamen blargg, ein vollst√§ndiges Reverse Engineering dieses Chips durchzuf√ºhren: Es war ein Echopuffer. </font><font style="vertical-align: inherit;">Der SNES-DSP verf√ºgt √ºber eine Funktion, die die Ausgabe vorheriger Samples mischt, um einen Echoeffekt zu erzeugen. </font><font style="vertical-align: inherit;">Dies geschieht ganz am Ende des Klangerzeugungsprozesses (abgesehen von dem letzten Schallblockierungsflag, mit dem die gesamte Tonausgabe ausgeschaltet werden kann). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Schreiben von Code mit dem richtigen Timing der Ma√ünahmen und Verfolgen des resultierenden Echos konnten wir die genaue Reihenfolge der vom DSP zu erzeugenden Operationen bestimmen von jedem Sample und perfekte Klang- und Schlaggenauigkeit.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPU speichern</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All dies f√ºhrte uns zum letzten Teil des SNES-Architekturschemas: PPU-1- und PPU-2-Chips. </font><font style="vertical-align: inherit;">Dank John McMaster haben wir Scans der Chips S-PPU1 (Revision 1) und S-PPU2 (Revision 3) mit einer zwanzigfachen Zunahme.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/678/641/68e/67864168e9f383375b8e081ffff1606f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwanzigfacher Scan des Kristalls des ersten PPU-SNES ...</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fad/524/a23/fad524a235729831ae880c3edf1bb4b8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... und die zweite PPU.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Beide Crystal-Scans lassen uns wissen, dass es sich bei den Chips offensichtlich nicht um Allzweck-CPUs handelt, und es handelt sich auch nicht um spezialisierte Architekturen, die Betriebscodes aus dem internen ROM des Firmware-Programms ausf√ºhren. Hierbei handelt es sich um separate logische Schaltkreise mit fest codierter Logik, die eingehende Signale von verschiedenen Registern und Speichern empfangen und jeweils ein Rastersignal f√ºr den Monitor erzeugen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PPUs bleiben das letzte Hindernis f√ºr die Emulation von SNES, da PPUs im Gegensatz zu allen oben beschriebenen Komponenten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tats√§chlich</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Black Box sind. Wir k√∂nnen sie f√ºr jeden Status konfigurieren, aber die SNES-CPU kann nicht direkt √ºberwachen, was sie generieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir unser vorheriges Beispiel mit Multiplikation als Analogie verwenden, stellen Sie sich vor, Sie h√§tten das Ergebnis 3 * 7 angefordert, aber anstelle der bin√§ren Antwort erhalten Sie ein unscharfes analoges Bild der Zahlen ‚Äû21‚Äú auf dem Bildschirm. Jeder, der Ihre Software ausf√ºhrt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann </font><font style="vertical-align: inherit;">21 sehen, aber Sie k√∂nnen kein Testprogramm schreiben, um automatisch zu √ºberpr√ºfen, ob er die richtige Antwort sieht. Die manuelle √úberpr√ºfung solcher Ergebnisse durch eine Person kann nicht auf mehr als mehrere tausend Tests skaliert werden, und Millionen sind erforderlich, um das PPU-Verhalten zu maximieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wei√ü, was Sie gedacht haben: "Aber ist es einfacher, eine Aufnahmekarte zu verwenden, eine Bildverarbeitung durchzuf√ºhren, sie ungef√§hr mit dem Bild auf dem digitalen Bildschirm des Emulators zu vergleichen und darauf basierende Tests durchzuf√ºhren?"</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na ja, das ist m√∂glich! </font><font style="vertical-align: inherit;">Besonders wenn der Test darin besteht, zwei gro√üe Zahlen zu √ºberpr√ºfen, die den gesamten Bildschirm einnehmen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber was ist, wenn das Testen viele Nuancen hat und wir versuchen, den Farbunterschied eines Halbtons von einem Pixel zu erkennen? </font><font style="vertical-align: inherit;">Was ist, wenn wir eine Million Tests in der richtigen Reihenfolge ausf√ºhren m√∂chten und nicht immer wissen, was wir generieren werden, aber dennoch das Ergebnis mit der Ausgabe unserer Emulation vergleichen m√∂chten? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nichts geht √ºber Komfort und Genauigkeit bei digitalen Daten - ein genauer Bitstrom, der nur √ºbereinstimmen kann oder nicht. </font><font style="vertical-align: inherit;">Die analoge Natur eines CRT-Signals kann uns dies nicht liefern.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum ist es wichtig?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Ausnahme eines Spiels ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) basiert die gesamte offiziell lizenzierte SNES-Software (sollte es gewesen sein) auf Rasterzeichenfolgen. Diese Spiele versuchen nicht, den Status des PPU-Renderings in der Mitte der aktuell gerenderten Rasterzeile zu √§ndern (ein solcher Trick wird von Programmierern als "Rastereffekt" bezeichnet). Dies bedeutet, dass die Ausf√ºhrungszeiten der meisten Spiele nicht besonders genau sein m√ºssen. Wenn Sie Zeit f√ºr die n√§chste vollst√§ndige Rasterzeile haben, ist alles in Ordnung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist jedoch wichtig f√ºr ein einziges Spiel.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/c75/08c/349c7508c9724e946a687c60881e77fc.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a4/7ee/5b2/3a47ee5b2b9ceacabcf2c4f1c34a1fe3.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77e/149/23c/77e14923ce342dc49287fa908aea5b93.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Bilderserie zeigt einen komplexen Emulationseffekt, der in der Nachricht ‚ÄûGood Luck‚Äú von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol verwendet wird</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In den obigen Bildern sehen Sie den Frame-f√ºr-Frame-Text ‚ÄûGood Luck‚Äú von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das Spiel implementiert es, indem es die Position des vertikalen Bildlaufs der Hintergrundebene 3 (BG3) √§ndert. Die Dashboard-Anzeige auf der linken Seite (wo Sie sehen k√∂nnen, dass der Spieler 39 Raketen hat) befindet sich jedoch ebenfalls auf derselben Hintergrundebene.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Spiel schafft es, diese Trennung durchzuf√ºhren, indem die Position der BG3-Schriftrolle in jeder Rasterzeile ge√§ndert wird, nachdem das linke Dashboard gerendert wurde, aber bevor der Text ‚ÄûGood Luck‚Äú gerendert wird. Dies ist m√∂glich, da BG3 au√üerhalb des Dashboards und des Texts transparent ist und zwischen diesen beiden Punkten unabh√§ngig vom Wert des vertikalen Bildlaufregisters nichts zu zeichnen ist. Dieses Verhalten zeigt uns , </font><font style="vertical-align: inherit;">dass Scrollen Register </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in jedem Stadium des Rendering ver√§ndert.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/880/658/047/8806580479dcbbaf6671fc971c12ba8b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser kleine Schatten unter dem Flugzeug bereitete dem pr√§zisionsbesessenen Emulatorentwickler einige Kopfschmerzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Bild oben zeigt den ber√ºchtigten Schatten eines Flugzeugs. Dieser Effekt wird durch √Ñndern des Bildschirmhelligkeitsregisters mit kurzen Wellen √ºber f√ºnf Rasterlinien gerendert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend des Spiels k√∂nnen Sie sehen, dass dieser Schatten ziemlich chaotisch ist. Im obigen Bild sieht es ein bisschen wie der Buchstabe "c" aus, aber seine Form in jeder Rasterlinie √§ndert sich in L√§nge und Startpunkt mit jedem Frame. Die Entwickler von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol haben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nur grob umrissen, wo der Schatten erscheinen soll, und dieses Problem direkt gel√∂st. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den meisten F√§llen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktioniert dies.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die korrekte Emulation eines solchen Verhaltens erfordert ein perfektes Timing, was im Emulator </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√§u√üerst</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schwierig zu </font><font style="vertical-align: inherit;">erreichen ist </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c5/b7f/fa2/1c5b7ffa2601b6480209321b60a131a1.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pausenbildschirm </font><font style="vertical-align: inherit;">werden Rastereffekte verwendet, die in keinem anderen SNES-Spiel absichtlich verwendet wurden.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lassen Sie uns nun √ºber den Pausenbildschirm sprechen. Es schaltet BG3 ein, w√§hrend links ein gelb-schwarzer Rand gezeichnet wird, und schaltet es w√§hrend desselben Randes rechts wieder aus, um graue Linien auf dem Bildschirm zu zeichnen. Er wechselt auch abwechselnd durch den Rahmen die Rasterlinien, in denen diese grauen Linien angezeigt werden, um den Effekt eines Overlay-Jitters zu erzeugen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie das oben gezeigte emulierte Bild vergr√∂√üern, werden Sie feststellen, dass w√§hrend des Rasterlinienpaars in der linken Ecke dieser grauen Linien mehrere Pixel fehlen. Es ist passiert, weil meine PPU-Emulation in Taktzyklen zu 100% unvollst√§ndig ist. In diesem Fall wird BG3 etwas sp√§ter aktiviert, als es sollte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich kann die Timings sehr einfach √§ndern, damit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bild korrekt wiedergegeben wird. Eine solche √Ñnderung wirkt sich jedoch wahrscheinlich nachteilig auf </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiele aus, die die PPU-Anzeigeregister in der Mitte der Rasterzeile √§ndern. Obwohl </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das einzige Spiel ist, das dies absichtlich tut, gibt es mindestens ein Dutzend Spiele, in denen dies zuf√§llig geschieht (m√∂glicherweise wird es fr√ºher oder sp√§ter von IRQ ausgel√∂st). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal f√ºhrt dies zu kurzen sp√ºrbaren Sch√§den am Bild, die bei der Entwicklung nicht ber√ºcksichtigt werden (z. B. bei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollgasrennen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w√§hrend des √úbergangs zwischen dem Laden und dem Spiel). Manchmal wird eine Aufzeichnung durchgef√ºhrt, w√§hrend der Bildschirm gerendert wird, der im Rest transparent ist und daher keine visuellen Anomalien verursacht (z. B. bei der Anzeige des HP-Status in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dai Kaijuu Monogatari II</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Aber selbst solche ‚Äûunsichtbaren‚Äú </font><i><font style="vertical-align: inherit;">Randf√§lle</font></i><font style="vertical-align: inherit;"> k√∂nnen Probleme beim weniger genauen Rendern von </font><i><font style="vertical-align: inherit;">Rasterlinien</font></i><font style="vertical-align: inherit;"> verursachen die in den produktivsten Emulatoren verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst wenn Sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ignorieren </font><font style="vertical-align: inherit;">, k√∂nnen Sie mit all diesen zuf√§lligen (aber g√ºltigen) Rastereffekten in der SNES-Software keinen PPU-Renderer funktional entwerfen, der die gesamte Rasterlinie mit perfekter Taktgenauigkeit generiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Fall von bsnes √ºber die Jahre des Versuchs und Irrtums haben wir eine Liste solcher Spiele mit ‚ÄûRastereffekten‚Äú erstellt. </font><font style="vertical-align: inherit;">Wir haben auch individuelle Rendering-Positionen erstellt, die ein viel schnelleres Rendern basierend auf Rasterlinien erm√∂glichen, um alle diese Spiele korrekt anzuzeigen (au√üer </font><font style="vertical-align: inherit;">nat√ºrlich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Aber im Wesentlichen ist dies eine Reihe von Hacks, die f√ºr uns unangenehm sind und f√ºr bestimmte Spiele entwickelt wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe auch einen uhrbasierten PPU-Renderer, der nicht alle diese Hacks ben√∂tigt, aber von Zeit zu Zeit kleine (ein bis vier Pixel) Unterschiede beim Rendern dieses Ger√§ts erzeugt, wie im obigen Screenshot von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interne Latch-Register</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Grund f√ºr all diese kleinen Fehler liegt in der zeitlichen Abstimmung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, SNES rendert seinen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ber√ºhmten Modus 7</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bei dem es sich um eine affine Texturtransformation mit Parameter√§nderungen in jeder Rasterzeile handelt. </font><font style="vertical-align: inherit;">Um ein Bildschirmpixel zu bestimmen, m√ºssen Sie √§hnliche Berechnungen durchf√ºhren:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">px = a * clip (hoffset - hcenter) + b * clip (voffset - vcenter) +</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b * y + (hcenter &lt;&lt; 8)</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
py = c * clip (hoffset - hcenter) + d * clip (voffset - vcenter) +</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
d * y + (vcenter &lt;&lt; 8)</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Real SNES kann nicht alle sechs Multiplikationen f√ºr jedes Pixel, das im Frame gerendert wird, schnell genug ausf√ºhren. </font><font style="vertical-align: inherit;">Aber keiner dieser Werte √§ndert sich f√ºr jedes Pixel (oder sollte sich zumindest nicht √§ndern), sodass wir px und py nur einmal am Anfang jeder Rasterzeile berechnen m√ºssen. </font><font style="vertical-align: inherit;">Das hei√üt, PPU speichert statische Ergebnisse in Latches zwischen, die im Wesentlichen Kopien von PPU-Registern sind. </font><font style="vertical-align: inherit;">In Zukunft k√∂nnen sie transformiert werden oder unver√§ndert bleiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann werden die x, y-Koordinaten durch Modus 7 wie folgt transformiert:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ox = (px + a * x) &gt;&gt; 8</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
oy = (py + c * x) &gt;&gt; 8</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl x f√ºr jedes Pixel variiert, wissen wir, dass das Inkrement jedes Mal um eins ausgef√ºhrt wird. Dank der Speicherung interner Laufwerke k√∂nnen wir ox und oy einfach f√ºr jedes Pixel konstante Werte a und c hinzuf√ºgen, anstatt zwei Multiplikationen f√ºr jedes Pixel durchzuf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann stellt sich vor uns die Frage: In welcher bestimmten Position des Taktzyklus liest die PPU die Werte von a und c aus den externen PPU-Registern, auf die die CPU Zugriff hat? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir sie zu fr√ºh nehmen, kann dies einige Spiele brechen. Wenn wir es zu sp√§t nehmen, kann es andere Spiele brechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am einfachsten ist es, auf Fehlerberichte zu warten und diese Positionen anzupassen, um Probleme in den einzelnen Spielen zu beheben. In diesem Fall werden wir jedoch niemals die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genauen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Positionen finden, </font><font style="vertical-align: inherit;">sondern </font><font style="vertical-align: inherit;">nur deren Ann√§herungen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jedes Mal, wenn wir eine dieser Variablen √§ndern, ist es f√ºr uns unrealistisch, alle dreieinhalbtausend Spiele aus der SNES-Bibliothek erneut zu testen, um festzustellen, welche Verschlechterung unsere √Ñnderungen bewirken k√∂nnten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus der Pfanne ins Feuer</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/741/b84/c0a741b84071dd0252021ae422277c1a.jpg"></div> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K√ºnstlerische Interpretation des Prozesses zur Beseitigung von Emulationsfehlern.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Eine √§hnliche Art der Testmethode: "Wir machen nur das Spiel, an dem wir interessiert sind, um jeden Preis" f√ºhrte zu dem Ph√§nomen, das ich Emulation "vom Feuer, aber ins Feuer" nenne. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu Beginn der Entwicklung der SNES-Emulation, wenn Probleme im Spiel auftraten, wurde </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jede</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Korrektur in diesem Spiel, die es erm√∂glichte, akzeptiert und dem Emulator hinzugef√ºgt. Dieser Fix hat notwendigerweise ein anderes Spiel kaputt gemacht. Und dann haben sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiel </font><font style="vertical-align: inherit;">korrigiert </font><font style="vertical-align: inherit;">, woraufhin das dritte kaputt ging. Das dritte Spiel erneut zu reparieren, brach das erste. Dies dauerte viele Jahre.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Fehler dabei war, dass die Entwickler versuchten, jeweils nur eine Variable zu ber√ºcksichtigen. Angenommen, wir haben ein Spiel, und damit es funktioniert, m√ºssen Ereignisse zwischen Takt 20 und 120 auftreten. Wir kennen den genauen Takt nicht, w√§hlen Sie also einfach 70 genau in der Mitte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sp√§ter erhalten wir einen Fehlerbericht in einem anderen Spiel und stellen fest, dass </font><font style="vertical-align: inherit;">der Messwert </font><font style="vertical-align: inherit;">f√ºr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiel zwischen 10 und 60 liegen sollte. Jetzt √§ndern wir ihn auf 40, was f√ºr beide Spiele funktioniert. Klingt logisch! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber dann erscheint das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dritte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiel, in dem das Ereignis zwischen Takt 80 und 160 funktionieren sollte! Jetzt k√∂nnen wir nicht alle drei Spiele gleichzeitig mit demselben Wert zum Laufen bringen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies zwang Emulatorentwickler, Hacks f√ºr bestimmte Spiele zu erstellen. </font><font style="vertical-align: inherit;">Codierer m√∂chten keinen Emulator ver√∂ffentlichen, in dem Sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mario</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zelda</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metroid</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht ausf√ºhren k√∂nnen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher wird f√ºr den allgemeinen Fall der Taktzyklus 40 verwendet, aber beim Laden von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metroid</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erzwingen wir den Zeitwert auf 100. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie ist dies m√∂glich, warum ben√∂tigen zwei Spiele unterschiedliche Werte? </font><font style="vertical-align: inherit;">Dies geschieht, weil hier nicht nur eine Variable beteiligt ist. </font><font style="vertical-align: inherit;">Das Timing, das Sie zuvor zum Ausl√∂sen eines anderen Ereignisses verwendet haben, kann sich auf den Timing-Wert auswirken, der f√ºr das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√§chste</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ereignis </font><font style="vertical-align: inherit;">erforderlich ist </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich dies in Form eines einfachen algebraischen Ausdrucks vor:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2x + y = 120</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen es l√∂sen, indem Sie x = 10, y = 100 nehmen. Oder x = 20, y = 80. Oder x = 30, y = 60. Wenn wir nur an den Wert von x denken, mit dem Sie gleichzeitig eine Reihe von Spielen ausf√ºhren k√∂nnen, √ºbersehen wir die Tatsache, dass das Problem m√∂glicherweise im falschen y liegt! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten Versionen von Emulatoren zur Erh√∂hung der Kompatibilit√§t haben den Wert von x je nach laufendem Spiel einfach neu definiert. Solche einzelnen Spiel-Hacks blieben bestehen, auch wenn sp√§ter der richtige Einzelwert von x entdeckt wurde. Das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problem </font><font style="vertical-align: inherit;">w√ºrde also niemals gel√∂st werden!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei SNES sind jedoch nicht eine oder zwei Variablen gleichzeitig beteiligt. Allein die SNES-Konsolen-PPU verf√ºgt √ºber 52 externe Register, was ungef√§hr 130 Parametern entspricht. Beim Rendern einer einzelnen Rasterzeile sind alle 130 dieser Parameter und eine unbekannte Anzahl interner Register und Latches beteiligt. Dies sind zu viele Informationen, als dass jemand au√üerhalb den Status der PPU zu einem bestimmten Zeitpunkt vollst√§ndig erfassen k√∂nnte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Aspekt der Emulation ist f√ºr Uneingeweihte nicht offensichtlich, aber sehr fair: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genauigkeit ist</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht gleich </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompatibilit√§t</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir k√∂nnen einen Emulator mit einer Genauigkeit von 99 Prozent erstellen, der 10% der Spiele ausf√ºhren kann. </font><font style="vertical-align: inherit;">Und Sie k√∂nnen einen 80% genauen Emulator schreiben, der 98% der Spiele ausf√ºhrt. </font><font style="vertical-align: inherit;">Manchmal bricht eine korrekte Implementierung kurzfristig beliebte Spiele. </font><font style="vertical-align: inherit;">Dies ist ein notwendiges Opfer, wenn Sie versuchen, sowohl 100% Genauigkeit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als auch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100% Kompatibilit√§t zu erreichen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem l√∂sen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dank deduktiver √úberlegungen und Ergebnissen in der realen Welt haben wir die aktuelle Stufe der PPU-Emulation erreicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wissen, dass zwei PPUs Zugriff auf zwei VRAM-Chips haben. </font><font style="vertical-align: inherit;">Wir wissen, dass sie von jedem Chip eine bekannte Anzahl von Datenbytes pro Rasterzeile lesen k√∂nnen. </font><font style="vertical-align: inherit;">Wir kennen die groben Details der Funktionsweise der einzelnen SNES-Videomodi. </font><font style="vertical-align: inherit;">Auf dieser Grundlage k√∂nnen wir ein verallgemeinertes Muster f√ºr das Erscheinungsbild der Architektur skizzieren. </font><font style="vertical-align: inherit;">Hier ist zum Beispiel ein kurzes Beispiel, wie die ersten drei SNES-Videomodi funktionieren k√∂nnen:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if (io.bgMode == 0) {</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg4.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg4.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}}</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
if (io.bgMode == 1) {</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchCharacter (1);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchCharacter (1);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}}</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
if (io.bgMode == 2) {</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchNameTable ();</font></font><font></font>
<font></font>
bg3.fetchOffset(0);<font></font>
<font></font>
bg3.fetchOffset(8);<font></font>
<font></font>
bg2.fetchCharacter(0);<font></font>
<font></font>
bg2.fetchCharacter(1);<font></font>
<font></font>
bg1.fetchCharacter(0);<font></font>
<font></font>
bg1.fetchCharacter(1);<font></font>
<font></font>
}</pre></blockquote><br>
<h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die PPU zeigt einem Drittbeobachter nur einen kleinen Teil ihres Zustands: horizontale / vertikale Austastflags, horizontale und vertikale Pixelanzahl und Kachel√ºberlagerungsflags im Intervall f√ºr Sprites. Das ist nicht so sehr, aber ich wiederhole - jedes winzige Element des Staates, das dem Beobachter zug√§nglich ist, hilft uns. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der VRAM (Video-RAM, Videospeicher) des PPU-Chips w√§hrend des Renderns ist auch zum Lesen f√ºr SNES-CPUs geschlossen. Wie sich herausstellte, sind OAM (Sprite-Speicher) und CGRAM (Palettenspeicher) ge√∂ffnet. Der Trick ist, dass zu diesem Zeitpunkt die PPU den Adressbus steuert. Daher kann ich beim Lesen von OAM und CGRAM w√§hrend des Bildschirm-Renderings beobachten, was die PPU zu einem so kritischen Zeitpunkt von diesen beiden Speicherbl√∂cken erh√§lt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies sind nicht alle Teile des Puzzles, aber sie reichen mir aus, um die praktisch richtigen Muster f√ºr das Erhalten von Sprites implementieren zu k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mithilfe von Zugriffsmustern f√ºr offenes OAM und CGRAM, PPU-Flags, allgemeinen Beobachtungen (d. H. Vermutungen) aus Fehlerberichten f√ºr verschiedene Spiele und deduktiven √úberlegungen konnten wir uhrbasierte PPU-Renderer erstellen </font><font style="vertical-align: inherit;">, mit denen alle ver√∂ffentlichten Spiele </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nahezu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perfekt </font><font style="vertical-align: inherit;">gestartet werden k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Situation ist jedoch immer noch prek√§r: Wenn jemand anf√§ngt, Homebrew-Spiele mit genauem Timing von Ticks und Rastereffekten zu erstellen, k√∂nnen alle unsere modernen Emulatoren damit nicht umgehen. Einschlie√ülich auf FPGA basierender Software- und Hardware-Implementierungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich muss klar sagen: heute </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alles</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie kennen nur die interne Reihenfolge der Operationen und das Fangverhalten in den PPU-Chips der SNES-Konsole. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Niemand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wei√ü, wie man sie perfekt emuliert. </font><font style="vertical-align: inherit;">Zumindest f√ºr jetzt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√∂gliche L√∂sungen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was sollen wir damit machen? </font><font style="vertical-align: inherit;">Wie kann man die genaue Reihenfolge der Operationen in einer PPU bestimmen, wenn es sich aus Sicht der SNES-CPU um eine "Black Box" handelt? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich sehe vier m√∂gliche Optionen: Logikanalysatoren, digitale Videoausgabe im Testmodus, Riser und Entfernen von Abdeckungen von Chips.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logikanalysatoren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich die oben gezeigten Scans von PPU-Kristallen ansehen, werden Sie schwarze Bereiche an den R√§ndern des Chips bemerken. Dies sind die Plattformen, die mit den Kontakten der Chips verbunden sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Pins speichern den Zustand der PPU-Chips w√§hrend jedes Taktzyklus. Hier finden Sie die aktuelle Adresse, an die die Chips auf den Videospeicherchip zugreifen, die Werte der von einer PPU zur zweiten √ºbertragenen Daten und vieles mehr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Informationen sind f√ºr Code, der auf der SNES-CPU ausgef√ºhrt wird, nicht verf√ºgbar, liefern jedoch wertvolle Beobachtungen zur internen Reihenfolge der PPU-Operationen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c8/157/c0d/2c8157c0df8caaebd7e24f620bf2c60f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Anschlie√üen von Super NES-Konsolen-PPUs an einen √§hnlichen Logikanalysator kann der Schl√ºssel zur Black Box sein. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das entscheidende Problem von Logikanalysatoren besteht darin, dass sie nicht sehr bequem zu verwalten sind: Wenn Sie versuchen, Live-Daten von einem funktionierenden System abzutasten, erhalten wir einen Strom von Ergebnissen, der ziemlich schwer zu entschl√ºsseln ist. </font><font style="vertical-align: inherit;">Wenn Sie versuchen, die analoge RGB-Ausgabe des Systems zu analysieren, tritt dasselbe Problem auf: Um diese Daten zu erfassen, m√ºssen Sie jeden der Tests manuell durchf√ºhren. </font><font style="vertical-align: inherit;">Ein solches System ist nicht sehr gut f√ºr die Erstellung reproduzierbarer automatisierter Regressionstests.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digitaler Videoausgang im Testmodus</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
K√ºrzlich wurde durch einen Scan von Kristallschnitten mit 20-facher Vergr√∂√üerung ein geheimer Testmodus in den PPU-Chips der SNES-Konsole entdeckt. Wenn Sie eine kleine Hardwaremodifikation vornehmen, gibt </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die PPU ein digitales 15-Bit-RGB-Signal aus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist fast was wir brauchen! Dieser Modus weist jedoch Probleme auf, da der ber√ºhmte Modus 7 nicht das richtige Bild anzeigen kann. Es scheint, dass diese Funktion nicht vollst√§ndig abgeschlossen wurde.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Methode zu implementieren, sind weiterhin manuelle √Ñnderungen an SNES-Konsolen und ein geeigneter Mechanismus zum Erfassen und Analysieren der Ausgabe im Testmodus erforderlich. </font><font style="vertical-align: inherit;">Im Gegensatz zu einer L√∂sung mit der Erfassung eines analogen RGB-Signals kann ein solches digitales Signal jedoch automatisch getestet werden, wodurch wir schnell einen gro√üen Teil der Arbeit am PPU-Reverse Engineering erledigen k√∂nnen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Riser</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die PPUs statisch sind, k√∂nnen wir die PPU-Chips von einer funktionierenden SNES-Konsole entfernen und sie zusammen mit zwei VRAM-Chips an eine Prototyping-Karte oder eine ma√ügeschneiderte Leiterplatte anschlie√üen. </font><font style="vertical-align: inherit;">Danach k√∂nnen Sie einen Mikrocontroller zwischen der PPU und der USB-Schnittstelle platzieren und die Schnittstelle an den PC anschlie√üen, sodass der Encoder alle externen Videospeicherregister und PPUs programmieren kann. </font><font style="vertical-align: inherit;">Dar√ºber hinaus kann der Codierer die PPU-Taktzyklen manuell steuern und die resultierenden Signale in jedem Taktzyklus auf den E / A-Anschl√ºssen, Registern und im PPU-Speicher lesen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indem Sie den Software-Emulator so modifizieren, dass er die gleichen internen Werte der E / A-Anschl√ºsse generiert, k√∂nnen Sie echte Hardware auch in Echtzeit direkt mit der Emulation vergleichen. </font><font style="vertical-align: inherit;">Dies wird jedoch sehr harte Arbeit sein, da wir die internen PPU-Operationen noch nicht sehen k√∂nnen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernen der Abdeckung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die extremste L√∂sung besteht darin, den Kristall weiter zu untersuchen, indem die Chipabdeckung entfernt wird. </font><font style="vertical-align: inherit;">Wir haben bereits Kristall-Scans mit einer 20-fachen Vergr√∂√üerung, aber ihre Aufl√∂sung reicht nicht aus, um einzelne Logikschaltungen zu analysieren und neu zu erstellen, wie dies im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visual 6502-Projekt durchgef√ºhrt wurde</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn wir die Kristall-Scans beider PPUs mit einer 100-fachen Vergr√∂√üerung erhalten k√∂nnen, k√∂nnen wir mit der harten Arbeit beginnen, PPU-Schaltungen zu kompilieren und sie in Verbindungstabellen oder VHDL-Code zu konvertieren. </font><font style="vertical-align: inherit;">Dann k√∂nnen sie direkt im FPGA verwendet sowie auf C ++ oder eine andere Programmiersprache portiert werden, die zum Erstellen von Softwareemulatoren geeignet ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Spezialist, der dies zuvor getan hatte, gab mir eine grobe Sch√§tzung: Es w√ºrde ungef√§hr 600 Stunden dauern, um beide PPUs abzubilden. </font><font style="vertical-align: inherit;">Diese Aufgabe ist viel h√∂her als das Niveau ‚ÄûLasst uns Geld sammeln, indem wir Spenden sammeln und jemanden bezahlen‚Äú und f√§llt idealerweise in die Kategorie ‚ÄûHoffen wir, dass jemand, der sehr talentiert ist und √ºber einzigartige F√§higkeiten verf√ºgt, uns freiwillig helfen m√∂chte‚Äú. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das bedeutet nat√ºrlich nicht, dass ich nicht gerne jemanden f√ºr seine Hilfe finanziell belohnen w√ºrde, ich kann f√ºr die notwendigen Details und die Arbeit bezahlen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitte um Hilfe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammenfassend: Ich bin in meinem SNES-Emulatorprojekt so weit wie m√∂glich gegangen und brauche Hilfe, um diese letzte Aufgabe zu erledigen. </font><font style="vertical-align: inherit;">Wenn Sie bis zum Ende gelesen haben, m√∂chten Sie vielleicht helfen! </font><font style="vertical-align: inherit;">Jede Unterst√ºtzung, einschlie√ülich der Teilnahme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am bsnes-Projekt auf GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder jeglicher Forschungsdokumentation zum internen Betrieb von PPU-Chips, ist f√ºr uns von unsch√§tzbarem Wert! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielen Dank f√ºrs Lesen und f√ºr Ihre Unterst√ºtzung! </font><font style="vertical-align: inherit;">Es ist mir seit f√ºnfzehn Jahren eine Ehre, Mitglied der SNES-Emulationsgemeinschaft zu sein.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495256/index.html">Informationen zu Ports und Verschl√ºsselung in Mailservern</a></li>
<li><a href="../de495258/index.html">Wie Zoom im Zeitalter des Coronavirus zum wichtigsten Unternehmen wurde</a></li>
<li><a href="../de495262/index.html">PostgreSQL-Versions-Upgrade-Praxis. Andrey Salnikov</a></li>
<li><a href="../de495266/index.html">E-Learning der Renaissance. Warum 2020 alle Vorteile des Fernunterrichts aufzeigen wird</a></li>
<li><a href="../de495268/index.html">UI / UX-Fall: Parkautomatisierung am Flughafen</a></li>
<li><a href="../de495274/index.html">So beheben Sie Routenlecks</a></li>
<li><a href="../de495276/index.html">Und zeigen Sie, oder wie wir das Operational Sustainability Audit am Uptime Institute bestanden haben</a></li>
<li><a href="../de495278/index.html">Datenbanken, Karten, Checklisten oder Warum ein Business Knowledge Manager</a></li>
<li><a href="../de495280/index.html">Max Patrol SIEM. √úbersicht √ºber das Informationssicherheits-Ereignisverwaltungssystem</a></li>
<li><a href="../de495282/index.html">XML-Validierung mit XSD, JAXB und Spring Framework</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>