<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏽 👩‍🎨 🍵 4人用のアーケードマシンをゼロから開発および作成 👩🏿‍⚖️ 😥 📫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="2019年11月、私は仕事を辞め、長い間学びたかった新しいスキルを学ぶために数ヶ月を費やすことにしました。当時、私はWeb開発者として働いていました。その前は、ソフトウェア開発を勉強していました。そしてそれ以前にも、子供の頃、私は常に電子機器やプログラムを試していました。そのため、ソフトウェアの作成...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>4人用のアーケードマシンをゼロから開発および作成</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498822/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a6/10f/ede/6a610fede3bc45535fdcd0b8b3d6a9d7.jpg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2019年11月、私は仕事を辞め、長い間学びたかった新しいスキルを学ぶために数ヶ月を費やすことにしました。当時、私はWeb開発者として働いていました。その前は、ソフトウェア開発を勉強していました。そしてそれ以前にも、子供の頃、私は常に電子機器やプログラムを試していました。そのため、ソフトウェアの作成には自信が持てました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、</font><font style="vertical-align: inherit;">私は毎日</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「鉄」</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるこの魔法のもの</font><font style="vertical-align: inherit;">を使用していましたが、それが実際にどのように機能するのかわかりません。ソフトウェア開発者（特にWeb開発者）は、ハードウェアを理解する必要はありません。すべてのWeb開発コードは非常に高レベルであるため、ソフトウェアの問題がハードウェアに関連していることはほとんどありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、私は「鉄」に取り組み、高校で与えられたものを除いて、電気工学に関する一般的な知識を持っていませんでした。そして、私はこの状況を変えたかったのです。私はばかげた目標を設定しましたが、そのとき、私の知識のセットからは非常に遠く感じられました。そして...実験を始めたところです。やる気がなくなる前にどこまで行けるかチェックするつもりでした。目標は達成できなかったのですが、なんとか成功しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが私の結果です：</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/npsSCkFGR0g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の信じられないほどの目標は、4人用のアーケードゲームコンソールを最初から作成することでした。マイクロコントローラを頭脳として使用し、LEDストリップをディスプレイとして使用します。テーブルの端にあるプレーヤーごとに1つのジョイスティックと4つのボタンを使用して、プレーヤーはメモリチップからシステムに動的に読み込まれるゲームを制御します。これのおかげで、デバイスのゲームプレイは古き良きコンソールに似ています。今だけ、バグを取り除くためにカートリッジを吹き飛ばす必要はありません。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
驚いたことに...私は本当にプロジェクトを完了することができました。</font><font style="vertical-align: inherit;">実験、失敗、ドキュメントの読み取り、絶望、再試行のサイクルには、約3か月かかりました。</font><font style="vertical-align: inherit;">私がこれに費やした時間を知るためには、労働時間数を修正する必要があります。</font><font style="vertical-align: inherit;">約800-900時間</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と仮定</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">（私が週に6/7日、1日8〜10時間働いたとすると、これはかなり真実に近いものです。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は実験のプロセスを最初から最後まで記録し、写真を撮り、ビデオを録画しました。</font><font style="vertical-align: inherit;">この投稿では、プロジェクトと自分自身の経験を文書化します。</font><font style="vertical-align: inherit;">同様に素晴らしいプロジェクトに取り組むことにした場合、あなたにとってそれがインスピレーションの源となることを願っています。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">働き始める</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の冒頭で述べたように、私がプロジェクトを開始したとき、オームの法則の誤って記憶された公式を除いて、私は電子工学の知識を持っていませんでした。したがって、まずは実際に電子機器がどのように機能するかを調べ、それからゲーム機を組み立てる必要がありました。マイクロコントローラーを使ってLEDをオンにする方法すら知りませんでした。だから、私の最初のステップは、実験用の簡単な電子機器とマイクロコントローラーを注文することです。まず、LEDに電源を投入してみます。私は、LEDをオンにしようとする最初の試みがその燃焼につながったとほぼ確信しています。しかし、これはカメラに記録されていなかったので、記録されていなかったとしましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65d/3f9/4b4/65d3f94b409f452f2b89b61cebe87851.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロコントローラー、抵抗器、トランジスター、LEDを使った実験。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは最初の主要なマイルストーンでした。</font><font style="vertical-align: inherit;">これで、マイクロコントローラーで実行するコードを作成する方法がわかりました。</font><font style="vertical-align: inherit;">また、トランジスタを単純な電気スイッチとして使用してLEDをオンにする方法も学びました。</font><font style="vertical-align: inherit;">すごい！</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EEPROMでの冒険</font></font></h1><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b93/544/2b3/b935442b3b1db1c8c8e390c134394a6d.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 1.シフトレジスタを使用して、わずか3つの出力ピンで16本の出力ラインを制御します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
プロジェクトの一部は、ゲームロジックをメモリチップ（EEPROM）に書き込む機能でした。それらは、プレーヤー付きのカートリッジがシステムに挿入されたときに読み取られるはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長い目で見れば、このプロジェクトでどのタイプのEEPROMを使用するべきかについて十分な情報が得られなかったことに私は傷つきました。私は情熱を持って、古いパラレルEEPROMチップ（W27C512）を購入しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらに読み書きするには、16本のラインすべてに高または低信号を設定する機能が必要でした。マイクロコントローラーのすべての出力接点を占有したくない場合は、シフトレジスタの使用方法を学ぶのが理にかなっています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e51/17c/73e/e5117c73e685322a816450c33a198278.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 2.並列EEPROMチップへのデータの読み取り/書き込みに失敗した場合に使用される回路。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
2、3の連絡先で、16回線すべてを個別に制御できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、この知識をEEPROMに適用しましょう！はい...しかしいいえ。</font><font style="vertical-align: inherit;">EEPROMにデータを</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安定して</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">書き込む</font><font style="vertical-align: inherit;">ことができませんでした</font><font style="vertical-align: inherit;">。このタイプのチップでは、バイトを削除または書き込むために12〜14 Vが必要です。トランジスタをスイッチとして使用し、電圧を上げるようにしてみました。そして、私が理解しているように、それは機能しなければなりません。しかし、それはうまくいきませんでした。正確には何が問題なのか、まだわかりません。図では図2は、EEPROMからバイトを読み書きするために使用した回路を示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c8/55b/2cc/7c855b2cccc52a790973701590912927.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 3.シリアルEEPROMチップへのバイトの読み取り/書き込みに成功した回路</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最後に、このトピックに関する詳細を調査したところ、今日のパラレルEEPROMはあまり使用されないことがわかりました。通常、開発者はシリアルEEPROM I2Cを好むため、チュートリアルを見つけるのははるかに簡単です。 （たとえば、この</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">素晴らしいSparkfunチュートリアル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図では </font><font style="vertical-align: inherit;">図3に、シリアルEEPROMへのデータの読み取りと書き込みの方法を示します。これは、はるかにシンプルで、はるかに信頼性が高くなります。</font><font style="vertical-align: inherit;">このことから、部品の注文やプロジェクトの開発を早急に行うことにあまり満足するべきではないことがわかりました。</font><font style="vertical-align: inherit;">並列EEPROMに約1〜2週間を費やし、最終的にはまったく使用しませんでした。</font><font style="vertical-align: inherit;">ただし、その過程で、電子機器や仕様の読み取り（それ自体はスキル）で多くのことを学びました。</font><font style="vertical-align: inherit;">努力は完全に無駄ではありませんでした。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とにかく、どうやってそれを行うのですか？</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、メモリチップを読み書きできます。</font><font style="vertical-align: inherit;">次のステップは何ですか？</font><font style="vertical-align: inherit;">この段階では、例としていくつかの図面を使用して、コンソール計画をより詳細に説明するのが合理的です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbd/be2/3c5/fbdbe23c5506e650261938ce053e01a5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体的な計画。これは、4人用のコントローラを備えたゲームコンソールになります。各プレーヤーには1つのジョイスティックといくつかのボタンがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
赤い円はゲームカートリッジのプラグを示します。このコネクタには、コンソールがシリアルEEPROMを読み取ってゲームをメモリにロードするために使用する4つの金属ピンがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
緑は、LEDストリップの画面を作成する方法を示しています。画面のピクセルは、他のスポットと混ざり合うスポットではなく、正方形の明るい色のパッチにしたかったのです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
望ましい効果を達成するために、このようなスキームを使用して光源を互いに分離しました。同時に、画面の上部に当たる光を散乱させます。 （グリルの下の白い縞はLEDストリップを示します）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
42x42のLEDディスプレイを作ることにしました。すなわち、合計で１７６４個のＬＥＤが得られる。このおかげで、テーブルのサイズは4人でちょうどいいので、私は42を選びました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非常に多くのLEDを起動することは、それ自体が困難な作業です。最大輝度では、RGB LEDは60 mAの電流を消費します。 （最大の明るさで白になります）。 LEDの総数を掛けると、5 Vで最大消費電流105.84 Aが得られます。この電流に近づくために、電源</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">SE-600–5 MEAN WELL</font></a><font style="vertical-align: inherit;">を購入しました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最大100 Aの電流を供給できます。これは、理論的に可能な105 Aを下回ります。ただし、ゲームで最大の明るさの完全に白い画面を表示することは求めていません。</font><font style="vertical-align: inherit;">さらに、プログラムで明るさを制限できます。</font><font style="vertical-align: inherit;">また、誤ってこの100 Aの制限を超えないようにヒューズを追加します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/a49/769/332a49769fc921086ed5072e01879586.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">4. 3x3 LEDディスプレイ用のボール紙プロトタイプ。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
後でこの画面の組み立てに戻ります。</font><font style="vertical-align: inherit;">最初にプロトタイピングを行う必要があります。</font><font style="vertical-align: inherit;">小さなLEDスクリーンが機能するかどうか見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この3x3プロトタイプは、ピクセルを分離するいくつかの段ボールと、光を散乱させるプリンター用の普通紙で構成されています。</font><font style="vertical-align: inherit;">うまくいきました！</font><font style="vertical-align: inherit;">コンセプトの作業能力の素晴らしい確認を受けました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイクロコントローラーを使用してLEDを制御するために、FastLEDライブラリを使用しました。ただし、LEDが1つのデータバスによって制御されている場合、ゲームに十分な速度で1764個のLEDを更新することは不可能であることが判明しました。 800 kHzの周波数を想定すると、毎秒約17フレームのフレームレートを達成できます。私たちが目指していることとまったく同じではありません。個人的には、最低60FPSで遊ぶのが好きです。幸い、これは可能です。複数のデータバスを使用するのに十分です。 42x42ディスプレイは、便利に7つの等しい部分に分割できます。これらの各パーツは、独自のデータバスで個別に制御できます。これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Teensy 4マイクロコントローラーのFastLEDライブラリーの並列出力機能を使用する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことで可能になり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。 7つのデータバスを使用することで、最大約120FPSのリフレッシュレートを実現できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこれを計画しませんでしたが、たまたまプロジェクトの最初に、この特定のマイクロコントローラーを選びました。</font><font style="vertical-align: inherit;">ゲームの円滑な運用のためには、このMKが提供する高速な処理時間が必要になるように思えました。</font><font style="vertical-align: inherit;">図のプロトタイプ。</font><font style="vertical-align: inherit;">4はすでにパラレル出力機能によって制御されています。</font><font style="vertical-align: inherit;">ただし、このプロトタイプでは、データバスが2つしか使用されていません。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EEPROMでコードをどのように実行しますか？</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、この段階で、EEPROMの読み取りと書き込みを行うことができます。また、LEDディスプレイの概念の実用的な証拠もあります。次は何ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残された深刻な技術タスクは2つだけです。すべてのプレーヤーの入力方法（ボタンとジョイスティック）の構成です。また、EEPROMからゲームロジックを実行し、これらの命令の結果をディスプレイに表示する方法を理解する必要もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注文したボタンとジョイスティックはまだ到着していません。そのため、まずEEPROMからゲームロジックの実行に取り組みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EEPROMから命令（コード）を実行するには多くの方法があります。ただし、最初に特定の要件を設定する必要があります</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。1）コードは簡単に記述できる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2）コードは小さくなければなりません（ファイルサイズ）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3）コードは、私の作業量を減らすために、FastLEDなどの既製のライブラリーと対話できる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4）ロード時間を短縮するために、コードはできるだけ早くRAMにロードできる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5）ゲームをテストするために、通常のPCでコードをエミュレートする機能が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6）私たちのソリューションは高性能でなければなりません（少なくとも60FPSを提供します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7）ソリューションでは、追加の機器を大量に購入する必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8）ソリューションはTeensy 4.0 MKで動作するはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9）ソリューションは簡単に実装できる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EEPROMからコードを実行する方法は4つあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -通常のコンパイル済みArduinoコードをEEPROMに書き込みます。次に、外部のArduinoプログラマーに、コンパイルされたコードをEEPROMから読み取らせ、新しいゲームが読み込まれるたびにその場でArduinoを再プログラムします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -アセンブラコードをRAMにロードし、そこから実行します。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">-ArduinoBASIC</font></a><font style="vertical-align: inherit;">や</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Bitlash</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 などの既製のコードインタープリターを使用します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
 -独自のコードインタープリターを作成します。</font><font style="vertical-align: inherit;">
以下は、このプロジェクトの4つのソリューションの長所と短所の簡単な比較です。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75d/9e6/f9c/75d9e6f9c00e8c1067278d2317de5ae3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（1）外部プログラマとのソリューションのファイルサイズはひどいです。ゲームロジックと共に、このプロジェクトで使用するすべてのコードライブラリは、EEPROMに保存する必要があります。ゲームの状態を表示するには、各EEPROMにFastLEDライブラリの独自のコピーが必要です。これはまったく素晴らしいことではありません。この問題はおそらく、ベースコードを外部プログラマに追加して、Arduinoをプログラミングする前に、EEPROM内のコードと組み合わせることで回避できます。インターネット上でチュートリアルを見つけるのは簡単ではないので、これはリスクの高い作業です。それに時間をかけすぎると思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（2）RAMからアセンブラを実行することは素晴らしいオプションです。だから私はそれを検討することにしました。コードの記述の複雑さは、Cなどの高水準言語を使用することで軽減でき、Cは正しいアセンブラコードにコンパイルされます。しかし、Arduino上の他のライブラリーと簡単にやり取りできるかどうかは明確ではなかったので、それをやめることにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（3）既製のインタープリターを使用することもかなり良い解決策です。ただし、私が知る限り、これらのインタプリタはすべて文字列に基づいて実行されます。これらの長い行は、EEPROMに書き込む必要があります。これはそれほど大きな問題ではありませんが、ファイルサイズを最小限に抑える最善の方法ではありません。さらに、これらのインタープリターがArduinoライブラリーと対話できるかどうかは不明でした。したがって、既成の通訳を使用することは良い考えではないと判断しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（4）最後に、ソリューション4：独自のコードインタープリターを作成します。インタプリタの実装方法は私に完全に依存しているため、すべての要件を満たしています。彼</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インタプリタ自体の高速化を実現すれば高速化すること。</font><font style="vertical-align: inherit;">はい、ファイルサイズは小さくなり、コードは簡単に記述できます...これを自分で提供する場合。</font><font style="vertical-align: inherit;">つまり、すべてを完全に制御できます。</font><font style="vertical-align: inherit;">そして、私が努力すれば、すべてが完璧になります。</font><font style="vertical-align: inherit;">このようなソリューションの唯一の重大な欠点は、開発時間が長いことです。</font><font style="vertical-align: inherit;">私がこのプロジェクトに800〜900時間費やしたことを覚えているかもしれません。</font><font style="vertical-align: inherit;">つまり、独自のコードインタープリターを作成するために、ソリューション4を選択することを決定したことは明らかです。</font><font style="vertical-align: inherit;">時間は私にとって問題ではありませんでした。</font><font style="vertical-align: inherit;">この機会に、プログラミング言語がどのように作成されるかを学びました。</font><font style="vertical-align: inherit;">なぜこれらの言語でアーキテクチャの決定が行われたのかを調べます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArcadableScriptの誕生</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インタプリタの一般的な原則は非常に単純です。</font><font style="vertical-align: inherit;">内部構造の詳細については説明しません。これは、執筆の時点で、インタプリタをより効率的にし、コードを記述しやすいように完全に書き直すことを計画していたためです。</font><font style="vertical-align: inherit;">ただし、基本は変わりません。</font><font style="vertical-align: inherit;">インタープリターは、ゲームの各メジャーに対して単純なコードループを実行します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d38/795/8cf/d387958cf2e11b21d122f66d7f530918.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなスキームの大きな欠点は、ゲームの入力と状態がフレームごとに1回だけチェックされることです。</font><font style="vertical-align: inherit;">迅速な対応を必要としないゲームの場合、これは正常です。</font><font style="vertical-align: inherit;">ただし、他のゲームでは、プレーヤーはフレーム間で反応できません。</font><font style="vertical-align: inherit;">インタプリタの次のバージョンでこの問題を解決します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/843/ee2/fe1/843ee2fe188d8a16ea99f0e9e427b9ef.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 5</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
図の図では、図5は、近い将来にインタープリターをアップグレードして、ゲームの状態とフレームに2つの別個のサイクルを作成することを計画した方法を示しています。これにより、毎秒数百回のゲームの状態と表示を更新できます-毎秒60回のみ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、Teensy 4.0では、ハードウェアマルチスレッドコードを実行することはできません。したがって、これらの2つのサイクルを並行して実行することはできません。しかし、私は何かを思い付くと確信しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e56/8c7/878/e568c78787bb1b00b2aee6c406071050.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bd/b45/225/9bdb45225d410ef24bcc8e5fa3b325c3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しばらくして、独自に開発したバイトコード言語を使用して、2つの簡単なプログラムを作成することができました。ファイルサイズを最小化するために、生の数値を入力として使用します。つまり、私はこれら2つのプログラムの作成を完了し、通訳が理解できる数字のリストを文字通り書き留めました。このバイトコードがどの程度読みやすいかを理解するために、サンプルプログラムで使用されている、画面上でドットを移動する実際の命令を示します。</font></font><br>
<br>
<blockquote><code><pre>// TODO: Write/read all untyped... data to/from ROM
  int untypedGamestate[] = {
    0, // Previous time, to keep track of game time/framerate.
    0, // Player position x.
    0, // Player position y.
    0, // Player R color value.
    0, // Player G color value.
    255, // Player B color value.
  };
  int untypedValues[][3] = {
    // ID, Type, Value
    {0, 0, 0}, // Move up button value 
    {1, 0, 1}, // Move right button value
    {2, 0, 2},  // Move down button value
    {3, 0, 3},  // Move left button value
    {4, 3, 1},  // True/1
    {5, 3, 0},  // False/0
    {6, 4, 0},  // Current millis since game start
    {7, 2, 0},  // Gamestate previous time
    {8, 2, 1},  // Gamestate player x
    {9, 2, 2},  // Gamestate player y
    {10, 2, 3}, // Gamestate player r color
    {11, 2, 4}, // Gamestate player g color
    {12, 2, 5}, // Gamestate player b color
    {13, 3, 1}, // Move player up after button press boundary check
    {14, 1, 0}, // System config screen width
    {15, 1, 1}, // System config screen height
    {16, 3, 3}, // Move player down after button press boundary check
    {17, 3, 5}, // Move player left after button press boundary check
    {18, 3, 7}, // Move player right after button press boundary check
  }
  int untypedCalculations[][5] = {
    // ID, ending, valueLeftID, calculationRightID, calculationOperator
    {0, 0, 9, 1, 1}, // Current player y position - 1
    {1, 1, 4, 0, 0}, // True/1
    {2, 1, 0, 0, 0}, // Up button
    {3, 1, 2, 0, 0}, // Down button
    {4, 1, 5, 0, 0}, // False/0
    {5, 1, 9, 0, 0}, // Current player y position
    {6, 0, 15, 1, 1} // screenheight - 1
    {7, 0, 9, 1, 0}, // Current player y position + 1
    {8, 1, 3, 0, 0}, // Left button
    {9, 1, 1, 0, 0}, // Right button
    {10, 1, 8, 0, 0}, // Current player x position
    {11, 0, 8, 1, 0}, // Current player x position + 1
    {12, 0, 8, 1, 1}, // Current player x position - 1
    {13, 0, 14, 1, 1} // screenwidth - 1
  }
  int untypedInstructions[][10] = {
    // ID, rootInstruction, conditionCalculationLeftID, conditionCalculationRightID, conditionOperator, conditionSuccesValueLeftID,
    // conditionSuccessCalculationRightID, hasFailedCondition, conditionFailedValueLeftID, conditionFailedCalculationRightID
    {0, 1, 2, 1, 0, 13, 0, 0, 0, 0}, // move player up when up button is pressed.
    {1, 0, 5, 4, 1, 9, 0, 0, 0, 0}, // move the player up when the boundary is not reached.
    {2, 1, 3, 1, 0, 16, 0, 0, 0, 0}, // move player down when down button is pressed. 
    {3, 0, 5, 6, 1, 9, 7, 0, 0, 0} // move the player down when the boundary is not reached.
    {4, 1, 8, 1, 0, 17, 0, 0, 0, 0}, // move player left when left button is pressed.
    {5, 0, 10, 4, 1, 8, 12, 0, 0, 0}, // move the player left when the boundary is not reached.
    {6, 1, 9, 1, 0, 18, 0, 0, 0, 0}, // move player right when right button is pressed.
    {7, 0, 10, 13, 1, 8, 11, 0, 0, 0}, // move the player right when the boundary is not reached.
  };</pre></code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間をかけてコードを注意深く検討すると、このインタープリターの初期バージョンがどのように機能したかを理解できます。 「値」、「計算」、「命令」を使用する一般的な原則は、現在のバージョンでも保持されています。しかし、多くのことが変更されました。 gamestate値の固定リストはもうありません。今では、それらは通常の値リストの一部にすぎません。さらに、「条件」を指示から分離しました。これにより、コード内の命令を再利用できるため、ファイルサイズが小さくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インタプリタの詳細には触れません。再設計されたバージョンでは、これらすべてがすぐに変更されるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、EEPROMの読み取り/書き込み方法がわかった段階になり、通常の数の配列に基づいて命令を実行できます。</font><font style="vertical-align: inherit;">次の論理的なステップは、コードから命令のハードコードされたリストを削除し、EEPROMに書き込むことです。</font><font style="vertical-align: inherit;">これからは、EEPROMに格納された命令を読み取って実行できるようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99f/787/c14/99f787c142065459798925f8a58105c7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、最終的な結果を作成するために開始する必要がある概念の作業能力のすべての証拠があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、私たちが作成したプロトタイプの個々の部分には、依然として多くの作業が必要です。</font><font style="vertical-align: inherit;">しかし、私の意見では、最も困難なタスクはすでに解決されています。</font><font style="vertical-align: inherit;">私がしなければならなかったすべては私が既に持っていたものを開発することでした。</font><font style="vertical-align: inherit;">すべてが簡単です！</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LEDディスプレイアセンブリ</font></font></h1><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/661/fa9/f9d661fa96cd940cd19d0dd4c0f49930.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスプレイを組み立てるにはかなりの労力が必要でした。大変な仕事。まず、42本の別々のストリップにワイヤーをはんだ付けする必要がありました。各ストリップには、片側に3本、反対側に2本のワイヤーが必要です。つまり、約200本のワイヤのみです。このプロジェクトの前は、はんだ付けの練習はあまりしていなかったので、はんだ付けを行うほど品質が向上することがはっきりとわかります。もちろん、結局、結果が気に入らなかったので、最初のLEDストリップの多くをやり直す必要がありました。これらはすべて学習プロセスの一部です！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ec/9b3/604/2ec9b36040aadbe6007c8d3e7bf20d34.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップ：すべてのLEDストリップを大きな木製パネルに取り付けます。振り返ってみると、熱伝導率を向上させるためには、金属板を使用する価値があったと思います。1時間の操作で、ディスプレイが暖かくなったからです（40-50°C）。しかし、これはまだそれほど頻繁には発生しないので、大きな問題ではありません。ただし、プロジェクトを繰り返すことにした場合は、この点を修正します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/7b3/ebd/0ba7b3ebdd11e0349049d5bbf6c04761.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、より大きな直径のワイヤーをLEDストリップストリップのプラスとマイナスの導体に取り付けます。大口径のワイヤーが100 Aの最大電流に確実に耐えることを確認する必要があります。さらに保護するために、ディスプレイの各部分に15 Aのヒューズを追加しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、ディスプレイを制御する最初の試みを行う準備ができています。多くの失敗とソフトウェアのパラメーターとワイヤーによる操作の後、私はようやくディスプレイに歪みと干渉なしに単一の色を表示することに成功しました。それには長い時間がかかり、結果はまだ完璧とはほど遠いものでした。それについての</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">質問をelectronics.stackexchange.comに投稿する</font></a><font style="vertical-align: inherit;">まで、長い間、信号の歪み</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関する問題がありました。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このサイトの素晴らしい人たちが問題の診断を手伝ってくれました。</font><font style="vertical-align: inherit;">私はまだそれが何であるかを完全に理解していませんでしたが、MKアースからデータ入力近くのアース端子にデータバスに沿って直接マイナスのリード線を接続することにより、それを解決することができました。</font><font style="vertical-align: inherit;">それ以来、ディスプレイの歪みに問題はありませんでした。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78d/f76/e76/78df76e76fa5ca0494056dc1b7546e8c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の図からわかるように、2層の材料がLEDストリップに重ねられています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコーティングの材料として、強い、透明であるが散乱する光が必要です。</font><font style="vertical-align: inherit;">しかし、ガラスは高価で壊れやすいので使いたくありませんでした。</font><font style="vertical-align: inherit;">したがって、私は標準の透明なポリスチレンを取ることにしました。</font><font style="vertical-align: inherit;">彼が光を散乱させるように、私はそれを透けないほど細かいサンドペーパーで処理しました。</font><font style="vertical-align: inherit;">すべてが非常に簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリップの上に直接配置されるグリッドを作成するのにより多くの時間が費やされました。グリルを注文するのに必要なパラメータを注文するだけだと思っていましたが、約500ユーロの価格で呼ばれました。私の意見では、彼女はそれに値するものではありませんでした。そのため、自分で回収する必要がありました。これには、薄く（厚さが2 mm以下）、耐久性のある、不透明な白いプラスチックストリップが必要です。かなり多くの要件。したがって、適切な素材の選択には多くの時間がかかりました。結局のところ、ブラインド（ラメラ）からの縞模様が理想的です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4d/069/ecc/c4d069ecc77f2597d1e5093b225333c2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、幅広のストライプを均一にカットするために小さなホルダーを作りました。この場合、かなり小さいプラスチック片が得られた。次に、各ストリップの真ん中の適切な場所に切り込みを入れる必要がありました。これは、プラスチック片を接続して格子を組み立てるために必要です。これは、3番目の写真で行うことです。これを行う前に、のこぎりの幅が、カットするストリップの幅と同じかわずかに大きいことを確認する必要があります。さもなければ、格子を組み立てることができません。私の場合、金属の弓のこは理想的な厚さであることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4番目の写真では、すべてのストリップをグリッドに組み立てた結果が表示されています。</font><font style="vertical-align: inherit;">それは非常に迷惑で単調な仕事でしたが、グリルは非常に耐久性があることがわかりました。</font><font style="vertical-align: inherit;">一般に、すべてのセルが同じサイズであるように見えます。</font><font style="vertical-align: inherit;">セルのサイズに大きな違いはありません。さもないと、表示がおかしくなり、すべてがかなり良い結果になります。</font><font style="vertical-align: inherit;">私はこのグリルに満足しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/c98/a63/3e5c98a63af67f3ba0102a455a939724.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、いくつかのタスクを実行する木枠で格子を囲みました。</font><font style="vertical-align: inherit;">最初に、彼女はグリルの上にポリスチレンのシートを持っています。</font><font style="vertical-align: inherit;">グリルが動かないようにします。</font><font style="vertical-align: inherit;">さらに、木製フレームがすべてのワイヤーを押して、ワイヤーをよりしっかりと保持し、誤って外れないようにします（これは、ディスプレイを移動したときに数回発生しました）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/817/19a/c01/81719ac01006db1add78e0f394d1fffb.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この写真は、ワイヤーラックの上に置かれた紙やすりで磨いたポリスチレンシートを示しています。</font><font style="vertical-align: inherit;">グリルがほとんど見えなくなったことに注意してください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3eb/a69/4e8/3eba694e869e4fc489af81f01c6de832.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスプレイコントロールの正しい実装を試すために長い時間を費やした後、最終的にそれを機能させることができました。大きな問題は、信号の完全性の維持でした。しかし、上で述べたように。 electronics.stackexchangeのコミュニティがこれを助けてくれました！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスプレイは予想以上に明るいです。これを予測して、電源用に100 Aのユニットを注文する必要がありました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0a/092/371/a0a09237152f40f6ce6cb24aaa8d3e89.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何度か言ったように、FastLEDライブラリを使用してLEDを制御します。</font><font style="vertical-align: inherit;">しかし、私はまたの修正版を使用することを言及しなかった</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことにより、FastLED-GFXライブラリを</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユルゲンSkrocki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（のポートで自身</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adafruit-GFX-ライブラリ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">ディスプレイ上の図の簡単なレンダリングのために</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このライブラリの変更はわずかですが、インタプリタがライブラリと便利な方法で通信できるようにするために必要でした。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脳と...</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロジェクトを完了するために解決する必要がある最後の技術的なタスクの1つは、コンソールの頭脳の完成です。それらを1つの便利でコンパクトなセットに変える必要があります。しかし、最初に、プレイヤーのすべての入力信号を処理する方法を理解する必要があります。各プレーヤーには4つのボタンと1つのジョイスティックがあることを思い出させてください。これは、合計16個のデジタル入力信号と8個のアナログ信号です。 MKはそのような入力のための十分な連絡先を決して持っていません。さらに、EEPROMを読み取るために2つのデータバスピンがすでに使用されており、ディスプレイを制御するために7つのパラレルデータバスピンが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するには、デジタル入力に1組のシフトレジスタを使用します。そして、すべてのアナログ入力に対して、アナログマルチプレクサを使用します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be4/362/3d4/be43623d4bc69b23ee153bf4e0fc191b.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EEOPROMの読み取り/書き込み、プレイヤー入力の処理、および表示制御を同時に行うためのスキーム。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
そして、混乱が始まります。この写真で何が起こっているのかを左から右に説明しましょう。左側のブレッドボードの上部には、ディスプレイの制御に使用される7つのデータバスがあります。以下は、EEPROMを挿入できる領域と、それを読み取る領域です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中央のブレッドボードの上部には、アナログマルチプレクサがあります。このマルチプレクサは最大16個のアナログ入力信号を受信でき、マルチプレクサの入力信号に応じて、アナログ信号の1つをMKに接続します。したがって、16個のアナログ入力を処理するために必要なのは、1つのアナログ入力ピンと1組のデジタル入力ピンだけです。この写真では、マルチプレクサにアナログ入力が接続されていないようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチプレクサの下にはMK Teensyがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右側のブレッドボードでは、デジタル入力信号を処理します。この写真では、16のデジタル信号が単純にグラウンドに接続されています。ボタンが届くのをまだ待っていたので、16のデジタル信号すべてをこの方法でテストしました。シフトレジスタのおかげで、すべてのデジタル信号を制御するのに必要なピンは4つだけでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システム全体が巨大で信頼性の低いカオスです。</font><font style="vertical-align: inherit;">1回の不注意な呼気から外れないように、コンパクトにする必要があります。</font><font style="vertical-align: inherit;">したがって、私はいくつかのプロトタイピングボードを注文し、再びはんだ付けを始めました！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/351/a13/ea7/351a13ea70ae3f30f125304080770dcc.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e86/af8/04c/e86af804cc17b0925735084d862a2204.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、それは難しい作業であることが判明しました！</font><font style="vertical-align: inherit;">しかし、これは正確にはんだ付けする方法を学ぶ絶好の機会でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この回路を思いつくために、ブレッドボード上のワイヤーのカオスを例として使用しました。</font><font style="vertical-align: inherit;">次に、互いに通信する必要があるコンポーネントができるだけ近くなるように、よりスマートな回路を考え出そうとしました。</font><font style="vertical-align: inherit;">だから私はあまりにも多くのワイヤーを引っ張る必要性を取り除こうとしました。</font><font style="vertical-align: inherit;">これで、いくつかのモデリングツールを使用して回路を設計できると思います。</font><font style="vertical-align: inherit;">しかし、それでもかなりうまくいきました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2層回路を設計することにしました。下のプロトタイプボードでは、すべての入力が処理されます。 4つの入力接続のそれぞれに、8本の入力ラインがあります（1-アース、1-正、4-デジタル入力、2-アナログ入力）。 MKは、シフトレジスタの隣の4つの接続とマルチプレクサの隣の4つの接続を使用して、下位層と通信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
電源は上部層にあり、右側にはディスプレイ用の7つの出力データバスがあり、下部にはEEPROMを読み取るための接点があります。そして最後に、もちろん中央にはマイクロコントローラがあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e36/b63/416/e36b63416aa9c6b7cfad5c3c3f3918e7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインコントロールボードとプレーヤーの入力の間に、メインボードから入力ボードへの5本のアース線すべてを使用する必要がないため、中間ボードを配置して、両側で必要なワイヤーの数を12から8に減らしました。</font><font style="vertical-align: inherit;">すべてのボタンとジョイスティックには、1つの接地で十分です。</font><font style="vertical-align: inherit;">したがって、このような中間ボードは4つあります。</font><font style="vertical-align: inherit;">集めた次の各ボードの品質の向上に気付くのが好きです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d4/6b0/5ab/6d46b05abd9ced550837adb796becb9e.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注文したボタンを受け取ったことがないので、別の販売者に別のセットを注文し、数日後にそれを受け取りました。</font><font style="vertical-align: inherit;">これでようやくすべてのボタンのテストを開始できました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd3/083/a72/fd3083a7252ec45ff226ccaf9c3ee18a.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、コンソールでプレイできる最初のゲームも作成しました。はい、今ではコンソールと呼んでいます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスプレイでの作業の過程で、同時に通訳も改善したので、成功しました。特に、コードを書くときに開発プロセス自体を改善することができました。このプロセスは外部的にはそれほど興味深いものではないので、特に文書化しないことにしました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6f/fed/54f/a6ffed54fd1a461d601e1424ccf9de2d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンソールで実行できるコードを作成するためのシンプルな開発環境を作成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この環境はブラウザーで動作し、上記で見た数の無秩序なリストをいじることなく、コンソールのコードを書くことができます。</font><font style="vertical-align: inherit;">さらに、同じWebアプリケーションで実行されるコンソールエミュレーターを作成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PCでのデバッグはMKでのデバッグよりもはるかに簡単であるため、Webアプリケーションでコンソールのゲームをエミュレートする機能により、多くの時間を節約できました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エミュレーターは完璧ではありません。</font><font style="vertical-align: inherit;">エミュレーションと実際のバージョンのコンソールでの再生を区別するいくつかのバグがあります。</font><font style="vertical-align: inherit;">今後、新しいバージョンのインタープリターを作成するときに、それらを排除するよう努めます。</font><font style="vertical-align: inherit;">2つのバージョンのインタープリター（1つはC ++で記述され、もう1つはTSで記述）をサポートする必要性は少し面倒ですが、それだけの価値はありました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてを一緒に入れて</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべて準備ができています。</font><font style="vertical-align: inherit;">EEPROMから取得したゲームロジックに基づいて画像を表示し、ボタンやジョイスティックからのプレーヤー入力を処理できます。</font><font style="vertical-align: inherit;">次に、これらすべてを1つの耐久性のあるデバイスに組み合わせる必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df9/c7a/ebc/df9c7aebc3b77c16e5332a91ea52c04a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、ボタンとジョイスティックを固定するアルミニウムプレートに穴を開けます。</font><font style="vertical-align: inherit;">次に、これらのプレートを、都合よく凹んだ木製ケースの溝に挿入することができました。</font><font style="vertical-align: inherit;">これのおかげで、プレイヤーは誤って金属を引っかくことができなくなります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff9/911/305/ff991130552aade0b73c9241f014f781.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/61b/d54/98961bd54b0b66591cc5de96b952d17f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスプレイ周辺のすべてのものを収集し、信頼性の高い折りたたみ脚を追加します（保管を容易にするため）。</font><font style="vertical-align: inherit;">黒塗りの金属板はとても綺麗に見えます。</font><font style="vertical-align: inherit;">プロジェクトは本当に完成に向かっている感じです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/171/5e8/1ee/1715e81ee0aad78e45735d8354761956.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、もちろん、プロジェクトがほぼ完了したと私は信じていました。</font><font style="vertical-align: inherit;">約1か月間のコンソールの外観は次のとおりです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはすべてを収集し、ボタンが機能しないことを理解しています。</font><font style="vertical-align: inherit;">再度分解し、ボタンの問題を修正します。</font><font style="vertical-align: inherit;">すべてが機能しているようです。</font><font style="vertical-align: inherit;">ジョイスティックが機能しないことを理解しています。</font><font style="vertical-align: inherit;">再度分解します。</font><font style="vertical-align: inherit;">遅かれ早かれ、すべてのボタンとジョイスティックが機能し始めます。</font><font style="vertical-align: inherit;">ただし、LEDは機能しなくなります。</font><font style="vertical-align: inherit;">それらを修正するには、コンソール全体を分解し、最初から再組み立てする必要があります。</font><font style="vertical-align: inherit;">これは約1か月続き、最終的にすべてが機能しました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果</font></font></h1><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/N37waS4YijA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/797/f90/9fd/797f909fdad045379aa381c6d005422f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべて準備完了です！プロジェクトの作業を開始してから3〜4か月が経過しました。したがって、インタープリターの改善、ツリーのペイント、新しいゲームの開発を続ける私のモチベーションがすでに枯渇しているのは当然です。この記事を書いている時点で、私が最後にプロジェクトに参加していた1か月がすでに過ぎています。このドキュメンタリーの投稿を私と読者の皆さんのために書く力がついに強まりました。私が書いたすべてのことを正しい心の誰かが実際に読んでくれるとは思いませんが、プロジェクトの段階的な発展の写真を見て楽しんでいただければ幸いです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これをすべて読んだら、プロジェクトのGithubリポジトリに興味があるかもしれません。もちろん、私のコードはすべてオープンソースです！</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/Arcadable</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
さらなるプロジェクト開発計画：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -最初に、最後のビデオに示されているように、4人でPongをプレイするには、より美しいカートリッジを作成する必要があります。</font><font style="vertical-align: inherit;">それは接触面として使用されるアルミ箔の曲がった部分を備えた段ボールです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 ・また、コンソールの塗装を良くしたいです。</font><font style="vertical-align: inherit;">最初は、絵を描くのが好きな非常に経験豊富な友達と一緒に絵を描くことを計画していました。</font><font style="vertical-align: inherit;">しかし、今はパンデミックのため、これは不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -最後に、数回言ったように、インタープリターをより効率的な方法で書き直します。</font><font style="vertical-align: inherit;">ゲームを簡単にするために、開発環境も改善します。</font><font style="vertical-align: inherit;">Webアプリの設計は現在、生産性を妨げています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fb/339/925/2fb3399255938735b58a888c18aaaba8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">垂直方向のビデオを記録するための補償。</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja498808/index.html">KubernetesのYAMLサポートを備えたVim</a></li>
<li><a href="../ja498810/index.html">元の（いいえ）コントローラーでレトロコンソールを実行したとき</a></li>
<li><a href="../ja498814/index.html">あなたは社会保障に関する理論的な質問に失敗し、彼らはあなたに終止符を打った。これは正常です？//私たちは運命にある＃3</a></li>
<li><a href="../ja498816/index.html">まず第一に真実、またはデータベースシステムに基づいてシステムを設計する必要がある理由</a></li>
<li><a href="../ja498820/index.html">.NETとCに関するさらにトリッキーな質問＃</a></li>
<li><a href="../ja498826/index.html">SILとSalesforce</a></li>
<li><a href="../ja498828/index.html">食塩とタンパク質がインプラントの生存率をどのように高めるか</a></li>
<li><a href="../ja498830/index.html">ハッシュ+キャッシュ：ストリーム処理の最適化</a></li>
<li><a href="../ja498832/index.html">マイクロコントローラーをプログラミングするためのQt Creator 4.12およびQBS 1.16の可能性の概要</a></li>
<li><a href="../ja498834/index.html">今週の33のオンラインmitap。1つ選択するか、すべての時間をお持ちですか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>