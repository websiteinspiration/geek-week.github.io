<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏼 🎋 👩🏽‍🎓 Blitz Engine＆Battle Prime：ECSとネットワークコード 🥄 😔 👟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="バトルプライムは私たちのスタジオの最初のプロジェクトです。多くのチームメンバーがゲームの開発にかなりの経験を持っているという事実にもかかわらず、私たちはそれに取り組んでいる間、自然にさまざまな困難に直面しました。それらは、エンジンで作業するプロセスとゲーム自体を開発するプロセスの両方で発生しました。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Blitz Engine＆Battle Prime：ECSとネットワークコード</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469709/"><img src="https://habrastorage.org/webt/xi/ez/ao/xiezaordrjuxu_maz07nn1wdtqe.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バトルプライム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は私たちのスタジオの最初のプロジェクトです。多くのチームメンバーがゲームの開発にかなりの経験を持っているという事実にもかかわらず、私たちはそれに取り組んでいる間、自然にさまざまな困難に直面しました。それらは、エンジンで作業するプロセスとゲーム自体を開発するプロセスの両方で発生しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gamedev業界では、さまざまな形で、ストーリー、ベストプラクティス、アーキテクチャの決定を喜んで共有する多数の開発者がいます。この経験は、記事、プレゼンテーション、レポートの形式でパブリックスペースに配置され、アイデアとインスピレーションの優れた情報源です。たとえば、Overwatch開発チームからのレポートは、エンジンの作業に非常に役立ちました。ゲーム自体と同じように、彼らは非常に才能があり、興味のあるすべての人に見てもらうことをお勧めします。 GDCボールト以降で利用可能</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YouTube</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、私たちも共通の原因に貢献したい理由の1つです。そして、この記事は、Blitzエンジンの開発と再生の技術的詳細に最初に取り組んだものの1つ、Battle Primeです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事は2つのパートに分かれます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS：Blitzエンジン内のEntity-Component-Systemパターンの実装。</font><font style="vertical-align: inherit;">このセクションは、記事のコード例を理解するために重要であり、それ自体が別の興味深いトピックです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットコードとゲームプレイ：クライアントサーバーアーキテクチャ、クライアント予測、レプリケーションなど、高レベルのネットワークパーツとゲーム内での使用に関するすべて。</font><font style="vertical-align: inherit;">シューティングゲームで最も重要なことの1つはシューティングです。そのため、より多くの時間が与えられます。</font></font></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メガバイトのGIFが大量にカットされています！</font></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各セクション内では、機能とその使用についてのストーリーに加えて、制限、作業上の不便さ、または将来の改善についての単なる考えなど、それ自体が持つ欠点について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、コード例といくつかの統計を提供するように努めます。</font><font style="vertical-align: inherit;">第一に、それは単に興味深いものであり、第二に、これまたはその機能とプロジェクトを使用する規模に関する小さなコンテキストを提供します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンジン内では、「世界」という用語を使用して、オブジェクトの階層を含むシーンを表します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワールドは、Entity-Component-Systemテンプレート（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipediaの説明</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">に従って機能します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンティティ-シーン内のオブジェクト。</font><font style="vertical-align: inherit;">これは、一連のコンポーネントのリポジトリです。</font><font style="vertical-align: inherit;">オブジェクトはネストして、ワールド内で階層を形成できます。</font></font></li>
<li>Component —    ,    - ,    . , `TransformComponent`     ,  `DynamicBodyComponent` —    .         ,         . ,  Battle Prime  `AliveComponent`  `DeadComponent`,       ;</li>
<li>System —    ,      .      ,  -  ( ,    ) ,  ,  .           . ,    `LodSystem`,    LOD (level of detail)            .  ,   `LodComponent`       .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチにより、同じオブジェクト内で異なるメカニズムを簡単に組み合わせることができます。</font><font style="vertical-align: inherit;">エンティティが一部の力学の作業に十分なデータを受け取るとすぐに、この力学を担当するシステムがこのオブジェクトの処理を開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、新しい機能を追加すると、新しいコンポーネント（またはコンポーネントのセット）と、この機能を実装する新しいシステム（またはシステムのセット）に削減されます。</font><font style="vertical-align: inherit;">ほとんどの場合、このパターンで作業すると便利です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反射</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントとシステムの説明に進む前に、リフレクションメカニズムについて少し説明します。リフレクションメカニズムは、コード例でよく使用されるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リフレクションを使用すると、アプリケーションの実行中にタイプに関する情報を受け取って使用できます。</font><font style="vertical-align: inherit;">特に、次の機能を使用できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定の基準に従ってタイプのリストを取得します（たとえば、クラスの相続人や特別なタグを持つ）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスフィールドのリストを取得し、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス内のメソッドのリストを取得し、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列挙値のリストを取得し、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを呼び出すか、フィールドの値を変更します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定の関数に使用できるフィールドまたはメソッドのメタデータを取得します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンジン内の多くのモジュールは、独自の目的でリフレクションを使用します。</font><font style="vertical-align: inherit;">いくつかの例：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクリプト言語の統合では、リフレクションを使用してC ++コードで宣言された型を処理します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エディターはリフレクションを使用して、オブジェクトに追加できるコンポーネントのリストを取得し、それらのフィールドを表示および編集します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワークモジュールは、コンポーネント内のフィールドメタデータを使用して、いくつかの機能を実行します。これらは、サーバーからクライアントにフィールドを複製するためのパラメーター、複製中のデータ量子化などを示します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リフレクションを使用して、さまざまな構成が対応するタイプのオブジェクトにデシリアライズされます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは独自の実装を使用しており、そのインターフェースは他の既存のソリューション（たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/rttrorg/rttr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">と大差ありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">CapturePointComponent（ゲームモードのキャプチャポイントを説明する）の例を使用して、型にリフレクションを追加すると、次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//    </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CapturePointComponent</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> Component<font></font>
{<font></font>
    <span class="hljs-comment">//           </span><font></font>
    BZ_VIRTUAL_REFLECTION(Component);<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">float</span> points_to_own = <span class="hljs-number">10.0f</span>;<font></font>
    String visible_name;<font></font>
<font></font>
    <span class="hljs-comment">// …  </span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//   .cpp </span><font></font>
BZ_VIRTUAL_REFLECTION_IMPL(CapturePointComponent)<font></font>
{<font></font>
    <span class="hljs-comment">//      </span><font></font>
    ReflectionRegistrar::begin_class&lt;CapturePointComponent&gt;()<font></font>
    [M&lt;Serializable&gt;(), M&lt;Scriptable&gt;(), M&lt;DisplayName&gt;(<span class="hljs-string">"Capture point"</span>)]<font></font>
<font></font>
        <span class="hljs-comment">//     </span>
        .field(<span class="hljs-string">"points_to_own"</span>, &amp;CapturePointComponent::points_to_own)<font></font>
        [M&lt;Serializable&gt;(), M&lt;DisplayName&gt;(<span class="hljs-string">"Points to own"</span>)]<font></font>
<font></font>
        .field(<span class="hljs-string">"visible_name"</span>, &amp;CapturePointComponent::visible_name)<font></font>
        [M&lt;Serializable&gt;(), M&lt;DisplayName&gt;(<span class="hljs-string">"Name"</span>)]<font></font>
        <font></font>
        <span class="hljs-comment">// …    </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
式を使用して宣言された型、フィールド、およびメソッドのメタデータに特別な注意を払いたい </font></font><br>
<br>
<pre><code class="cpp hljs">M&lt;T&gt;()</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、 `T`はメタデータのタイプです（コマンド内では単に「meta」という用語を使用しますが、将来的に使用します）。</font><font style="vertical-align: inherit;">それらは、独自の目的で異なるモジュールによって使用されます。</font><font style="vertical-align: inherit;">たとえば、エディターは「DisplayName」を使用してエディター内のタイプ名とフィールドを表示し、ネットワークモジュールはすべてのコンポーネントのリストを受信し、その中で「Replicable」とマークされたフィールドを検索します-それらはサーバーからクライアントに送信されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントの説明とオブジェクトへの追加</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各コンポーネントは `Component`基本クラスの継承であり、（必要に応じて）使用するフィールドをリフレクションで記述できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、 `AvatarHitComponent`がゲーム内で宣言および記述される方法です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/** Component that indicates avatar hit event. */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AvatarHitComponent</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> Component<font></font>
{<font></font>
    BZ_VIRTUAL_REFLECTION(Component);<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    PlayerId source_id = NetConstants::INVALID_PLAYER_ID;<font></font>
    PlayerId target_id = NetConstants::INVALID_PLAYER_ID;<font></font>
    HitboxType hitbox_type = HitboxType::UNKNOWN;<font></font>
};<font></font>
<font></font>
BZ_VIRTUAL_REFLECTION_IMPL(AvatarHitComponent)<font></font>
{<font></font>
    ReflectionRegistrar::begin_class&lt;AvatarHitComponent&gt;()<font></font>
        .ctor_by_pointer()<font></font>
        .copy_ctor_by_pointer()<font></font>
        .field(<span class="hljs-string">"source_id"</span>, &amp;AvatarHitComponent::source_id)[M&lt;Replicable&gt;()]<font></font>
        .field(<span class="hljs-string">"target_id"</span>, &amp;AvatarHitComponent::target_id)[M&lt;Replicable&gt;()]<font></font>
        .field(<span class="hljs-string">"hitbox_type"</span>, &amp;AvatarHitComponent::hitbox_type)[M&lt;Replicable&gt;()];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコンポーネントは、プレーヤーが別のプレーヤーを打った結果として作成されたオブジェクトをマークします。</font><font style="vertical-align: inherit;">攻撃しているプレーヤーの識別子とそのゴール、ヒットが発生したヒットボックスのタイプなど、このイベントに関する情報が含まれています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単に言うと、このオブジェクトはサーバーシステム内で同様の方法で作成されます。</font></font><br>
<br>
<pre><code class="cpp hljs">Entity hit_entity = world-&gt;create_entity();<font></font>
<font></font>
<span class="hljs-keyword">auto</span>* <span class="hljs-keyword">const</span> avatar_hit_component = hit_entity.add&lt;AvatarHitComponent&gt;();<font></font>
avatar_hit_component-&gt;source_id = source_player_id;<font></font>
avatar_hit_component-&gt;target_id = target_player_id;<font></font>
avatar_hit_component-&gt;hitbox_type = hitbox_type;<font></font>
<font></font>
<span class="hljs-comment">//     </span>
<span class="hljs-comment">//     </span>
<span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、 `AvatarHitComponent`を含むオブジェクトがさまざまなシステムで使用されます。プレーヤーを打つ音の再生、統計の収集、プレーヤーの実績の追跡などです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムとその作業の説明</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムは、 `System`から継承したタイプのオブジェクトで、特定のタスクを実装するメソッドが含まれています。</font><font style="vertical-align: inherit;">原則として、1つの方法で十分です。</font><font style="vertical-align: inherit;">同じフレーム内の異なる時点で実行する必要がある場合は、いくつかの方法が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィールドを記述するコンポーネントと同様に、各システムは世界が実行する必要があるメソッドを記述します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、爆発の原因であるExplosiveSystemは、次のように宣言および記述されています。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// System responsible for handling explosive components:</span>
<span class="hljs-comment">//   - tracking when they need to be exploded: by timer, trigger zone etc.</span>
<span class="hljs-comment">//   - destroying them on explosion and creating separate explosion entity</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExplosiveSystem</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> System<font></font>
{<font></font>
    BZ_VIRTUAL_REFLECTION(System);<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    ExplosiveSystem(World* world);<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">float</span> dt)</span></span>;<font></font>
<font></font>
    <span class="hljs-comment">//    ,    </span>
    <span class="hljs-comment">// ...</span><font></font>
};<font></font>
<font></font>
BZ_VIRTUAL_REFLECTION_IMPL(ExplosiveSystem)<font></font>
{<font></font>
    ReflectionRegistrar::begin_class&lt;ExplosiveSystem&gt;()[M&lt;SystemTags&gt;(<span class="hljs-string">"battle"</span>)]<font></font>
        .ctor_by_pointer&lt;World*&gt;()<font></font>
        .method(<span class="hljs-string">"ExplosiveSystem::update"</span>, &amp;ExplosiveSystem::update)[M&lt;SystemTask&gt;(<font></font>
            TaskGroups::GAMEPLAY_END,<font></font>
            ReadAccess::<span class="hljs-built_in">set</span>&lt;<font></font>
                TimeSingleComponent,<font></font>
                WeaponDescriptorComponent,<font></font>
                BallisticComponent,<font></font>
                ProjectileComponent,<font></font>
                GrenadeComponent&gt;(),<font></font>
            WriteAccess::<span class="hljs-built_in">set</span>&lt;ExplosiveComponent&gt;(),<font></font>
            InitAccess::<span class="hljs-built_in">set</span>&lt;ExplosiveStatsComponent,<font></font>
                            LocalExplosionComponent,<font></font>
                            ServerExplosionComponent,<font></font>
                            EntityWasteComponent,<font></font>
                            ReplicationComponent,<font></font>
                            AbilityIdComponent,<font></font>
                            WeaponBaseStatsComponent,<font></font>
                            HitDamageStatsComponent,<font></font>
                            ClusterGrenadeStatsComponent&gt;(),<font></font>
            UpdateType::FIXED,<font></font>
            Vector&lt;TaskOrder&gt;{ TaskOrder::before(FastName{ <span class="hljs-string">"ballistic_update"</span> }) })];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のデータは、システムの説明の中に示されています。</font></font><br>
<br>
<ul>
<li>,    .     ,     ,      .   ,  `battle`  ,      .     `server`  `client` (       )  `render` (      GUI);</li>
<li>,        ,     —  ,   ;</li>
<li>Update type —       normal update’, fixed update’  ;</li>
<li>    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムのグループ、依存関係、および更新タイプの詳細については、以下で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
宣言されたメソッドは、このシステムの機能を維持するために適切なタイミングで世界中から呼び出されます。メソッドの内容はシステムに依存しますが、原則として、このシステムの基準を満たすすべてのオブジェクトとその後の更新を通過します。たとえば、ゲーム内の `ExplosiveSystem`の更新は次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ExplosiveSystem::update</span><span class="hljs-params">(<span class="hljs-keyword">float</span> dt)</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>* time_single_component = world-&gt;get&lt;TimeSingleComponent&gt;();<font></font>
<font></font>
    <span class="hljs-comment">// Init new explosives</span>
    <span class="hljs-keyword">for</span> (Component* component : new_explosives_group-&gt;components)<font></font>
    {<font></font>
        <span class="hljs-keyword">auto</span>* explosive_component = <span class="hljs-keyword">static_cast</span>&lt;ExplosiveComponent*&gt;(component);<font></font>
        init_explosive(explosive_component, time_single_component);<font></font>
    }<font></font>
    new_explosives_group-&gt;components.clear();<font></font>
<font></font>
    <span class="hljs-comment">// Update all explosives</span>
    <span class="hljs-keyword">for</span> (ExplosiveComponent* explosive_component : explosives_group)<font></font>
    {<font></font>
        update_explosive(explosive_component, time_single_component, dt);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例のグループ（ `new_explosives_group`および` explosives_group`）は、システム実装を簡略化する補助コンテナーです。</font><font style="vertical-align: inherit;">new_explosives_groupは、このシステムに必要で処理されたことのない新しいオブジェクトを含むコンテナであり、explosives_groupは、フレームごとに処理する必要があるすべてのオブジェクトを含むコンテナです。</font><font style="vertical-align: inherit;">これらの容器への充填は世界が直接行っています。</font><font style="vertical-align: inherit;">システムによる受信は、コンストラクターで行われます。</font></font><br>
<br>
<pre><code class="cpp hljs">ExplosiveSystem::ExplosiveSystem(World* world)<font></font>
    : System(world)<font></font>
{<font></font>
    <span class="hljs-comment">// `explosives_group`        `ExplosiveComponent`</span><font></font>
    explosives_group = world-&gt;acquire_component_group&lt;ExplosiveComponent&gt;();<font></font>
    <font></font>
    <span class="hljs-comment">// `new_explosives_group`       </span>
    <span class="hljs-comment">//  `ExplosiveComponent` -      </span><font></font>
    new_explosives_group = explosive_group-&gt;acquire_component_group_on_add();<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">世界のアップデート</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
`World`タイプのオブジェクトである世界である各フレームは、多くのシステムで必要なメソッドを呼び出します。呼び出されるシステムは、そのタイプによって異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのフレームが必ず更新されるシステムの一部（エンジン内で「通常の更新」という用語が使用されます）-このタイプには、フレームとサウンドのレンダリングに影響するすべてのシステム（骨格アニメーション、パーティクル、UIなど）が含まれます。もう1つの部分は、事前に決められた固定の頻度で実行されます（「固定更新」という用語を使用し、1秒あたりの固定更新の数-FFPS）-ほとんどのゲームプレイロジックと、クライアントとサーバー間で同期する必要があるすべてを処理します-たとえば、プレーヤーの入力の一部、キャラクターの動き、射撃、物理シミュレーションの一部。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/j7/uo/wo/j7uowoyprp2hgp3lqgdy9rsotpm.png" height="1024" width="768"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
修正された更新の実行頻度はバランスを取る必要があります。値が小さすぎると、ゲームプレイが応答しなくなり（たとえば、プレーヤーの入力が処理される頻度が少なくなり、遅延が長くなるなど）、高すぎると、アプリケーションが実行されているデバイスのパフォーマンス要件が高くなります。</font><font style="vertical-align: inherit;">また、頻度が高いほど、サーバー容量のコストが高くなります（同じマシンで同時に実行できる戦闘が少なくなります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下のgifでは、世界は1秒あたり5回の固定更新の頻度で機能しています。</font><font style="vertical-align: inherit;">Wボタンを押してから移動を開始するまでの遅延と、ボタンを離してからキャラクターの移動を停止するまでの遅延を確認できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0dd/cbe/d6a/0ddcbed6a0354d56cc93efe6c2901b17.gif" alt="画像" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のgifでは、世界は1秒あたり30回の固定更新の頻度で動作し、応答性が大幅に向上しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe9/330/c42/fe9330c427acbd0bf5c807edcd9463ff.gif" alt="画像" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現時点では、バトルプライムの修正アップデートでは、世界は1秒あたり31回実行されます。</font><font style="vertical-align: inherit;">この「醜い」値は特別に選択されたものであり、1秒あたりの更新数が、たとえば、ラウンド数または画面のリフレッシュレートの倍数である場合、他の状況では存在しないバグを引き起こす可能性があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システム実行順序</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ECSでの作業を複雑にするものの1つは、システムを実行するタスクです。</font><font style="vertical-align: inherit;">コンテキストについては、執筆の時点では、プレイヤー間のバトル中のバトルプライムクライアントには251システムがあり、その数は増え続けています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
間違ったタイミングで誤って実行されたシステムは、微妙なバグや一部のメカニズムの動作の遅延につながる可能性があります（たとえば、損傷システムがフレームの最初に機能し、発射体飛行システムが最後に機能する場合、損傷が発生します） 1フレームの遅延あり）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムの実行順序は、次のようにさまざまな方法で設定できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注文の明示的な表示;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムの数値「優先度」の表示と、その後の優先度によるソート。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システム間の依存関係のグラフを自動的に作成し、実行順に正しい場所にインストールします。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、3番目のオプションを使用しています。</font><font style="vertical-align: inherit;">各システムは、読み取り、書き込みに使用するコンポーネント、および作成するコンポーネントを示します。</font><font style="vertical-align: inherit;">次に、システムは必要な順序でシステム間で自動的に配置されます。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムAのコンポーネント読み取りは、システムがコンポーネントAに書き込んだ後に行われます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントBに書き込みまたは読み取りを行うシステムは、コンポーネントBを作成するシステムの後に配置されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方のシステムがコンポーネントCに書き込む場合、順序は任意です（ただし、必要に応じて手動で指定できます）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理論的には、このようなソリューションは実行順序の制御を最小限に抑え、必要なのはシステムのコンポーネントマスクを設定することだけです。実際には、プロジェクトの成長に伴い、システム間のサイクルがますます多くなります。システム1がコンポーネントAに書き込み、コンポーネントBを読み取り、システム2がコンポーネントAを読み取り、コンポーネントBに書き込む場合、これはサイクルであり、手動で解決する必要があります。多くの場合、1つのサイクルには3つ以上のシステムがあります。それらの解決には、時間とそれらの間の関係の明確な指示が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ブリッツエンジンにはシステムの「グループ」があります。グループ内では、システムは自動的に望ましい順序で並べられ（サイクルは依然として手動で解決されます）、グループの順序は明示的に設定されます。このソリューションは、完全に手動のオーダーと完全に自動化されたオーダーのクロスであり、グループのサイズはその有効性に深刻な影響を与えます。グループが大きくなりすぎるとすぐに、プログラマーは再びループ内の問題に遭遇することがよくあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バトルプライムには現在10個のグループがあります。これでもまだ十分ではありません。それらの間に厳密な論理シーケンスを構築し、それぞれの内部にグラフを自動作成することで、その数を増やす予定です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムが書き込みまたは読み取りのためにどのコンポーネントを使用するかを示すことにより、将来的にはシステムを自動的に「ブロック」にグループ化して、互いに並行して実行できるようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、システムのリストと各グループ内のシステム間の依存関係を表示する補助ユーティリティです（グループ内の完全なグラフは威圧的に見えます）。</font><font style="vertical-align: inherit;">オレンジ色は、システム間の明示的に定義された依存関係を示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/592/2a4/fae/5922a4fae880eb7c80252628a827d2a0.gif" alt="画像" height="1024" width="768"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムとその構成間の通信</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムがそれ自体で実行するタスクは、ある程度、他のシステムの結果に依存する可能性があります。たとえば、2つのオブジェクトの衝突を処理するシステムは、これらの衝突を記録する物理のシミュレーションに依存します。そして、損傷システムは、弾丸システムの結果に依存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システム間で通信する最も簡単で最も明白な方法は、コンポーネントを使用することです。 1つのシステムはその作業の結果をコンポーネントに追加し、2番目のシステムはこれらの結果をコンポーネントから読み取り、それらに基づいて問題を解決します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントベースのアプローチは、場合によっては不便です。</font></font><br>
<br>
<ul>
<li>,         - ? ,     ( , ,    ) —   ,    ;</li>
<li>,     -  ? ,     ,        ,   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの問題を解決するために、私たちはオーバーウォッチの開発チームから借りてきたアプローチ-シングルコンポーネントを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単一コンポーネントは、単一のコピーで世界に存在し、世界から直接取得されるコンポーネントです。</font><font style="vertical-align: inherit;">システムはそれを使用して、他のシステムで使用される作業の結果を合計したり、作業を構成したりできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、プロジェクト（エンジンモジュール+ゲーム）には、世界のグローバルデータの保存から個々のシステムの構成まで、さまざまな目的で使用される約120の単一コンポーネントがあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「クリーン」なアプローチ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も純粋な形では、システムとコンポーネントへのそのようなアプローチは、コンポーネント内でのみデータの可用性とシステム内でのみロジックの存在を必要とします。</font><font style="vertical-align: inherit;">私の意見では、実際にはこの制限を厳密に遵守することはほとんど意味がありません（ただし、このテーマに関する議論はまだ定期的に行われています）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「厳密でない」アプローチを支持する次の議論を強調することができます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードの一部を共有し、異なるシステムから同期的に実行するか、コンポーネントのいくつかのプロパティを設定するときに実行する必要があります。</font><font style="vertical-align: inherit;">同様のロジックについては別途説明します。</font><font style="vertical-align: inherit;">エンジンの一部として、Utilsという用語を使用します。</font><font style="vertical-align: inherit;">たとえば、ゲーム内の「DamageUtils」には、ダメージの適用に関連するロジックが含まれています。これは、さまざまなシステムから適用できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムのプライベートデータをこのシステム自体以外の場所に保持することは意味がありません。それ以外の人がそれを必要とすることはなく、それを別の場所に移動することは特に役に立ちません。</font><font style="vertical-align: inherit;">このルールには例外があり、これはクライアント予測の機能に関連付けられています。これについては、以下のセクションで説明します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントが少量のロジックを持つことは有用です-ほとんどの場合、これらはコンポーネントの操作を簡単にするスマートなゲッターとセッターです。</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットコード</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バトルプライムは、権威主義的なサーバーとクライアントの予測を備えたアーキテクチャを使用しています。</font><font style="vertical-align: inherit;">これにより、pingやパケット損失が高い場合でも、プレーヤーはアクションから即座にフィードバックを受け取り、プロジェクト全体を受け取ることができます。</font><font style="vertical-align: inherit;">サーバーは、戦闘中のすべてのシミュレーション結果を指示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームプロジェクト内のすべてのコードは、3つの部分に分かれています。</font></font><br>
<br>
<ul>
<li> —   ,     .       UI,   ;</li>
<li> —   ,     . , ,        ;</li>
<li> —  ,     ,   .  ,  ,   ,   ( , )   ,     .   ,        —       GUI  (     ).</li>
</ul><br>
<h2>  ()</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントでのレプリケーションと予測の詳細に進む前に、エンジン内の入力を操作する方法について説明する必要があります。これの詳細は、以下のセクションで重要になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレーヤーからのすべての入力は、低レベルと高レベルの2つのタイプに分けられます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低レベルの入力-これらは、キーストローク、画面へのタッチなどの入力デバイスからのイベントです。</font><font style="vertical-align: inherit;">このような入力がゲームプレイシステムで処理されることはほとんどありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高レベルの入力-ショット、武器の変更、キャラクターの動きなど、ゲームのコンテキストでユーザーが行ったアクションです。</font><font style="vertical-align: inherit;">このような高レベルのアクションでは、「アクション」という用語を使用します。</font><font style="vertical-align: inherit;">また、動きの方向や選択した武器のインデックスなど、追加のデータをアクションに関連付けることができます。</font><font style="vertical-align: inherit;">システムの大部分はアクションで動作します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高レベル入力は、低レベル入力からのバインダーに基づいて、またはプログラムで生成されます。たとえば、発砲アクションはマウスボタンのクリックに関連付けることができます。または、自動発射を担当するシステムによって生成できます。プレーヤーが敵を狙った直後に、ユーザーが対応する設定を有効にしている場合、このシステムはアクションショットを生成します。また、対応するボタンを押したり、画面上のジョイスティックを動かしたりするなど、UIシステムからアクションを送信することもできます。自分自身を起動するシステムは、このアクションがどのように作成されたかには関係ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
論理的に関連するアクションはグループ化されます（ `ActionSet`タイプのオブジェクト）。現在のコンテキストでグループが必要ない場合は、グループを切断できます。たとえば、Battle Primeには、いくつかのグループがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャラクターの動きを制御するアクション、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動兵器を発射するためのアクション、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">半自動武器を発射するためのアクション。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後の2つのグループのうち、一度にアクティブになるのは、選択した武器のタイプによって異なります。これらは、FIREアクションの生成方法が異なります。ボタンが押されている間（自動武器の場合）またはボタンが押されたときに1回だけ（半自動武器の場合） ）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、アクションのグループは、いずれかのシステム内のゲーム内で作成および構成されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> Map&lt;FastName, ActionSet&gt; action_sets = {<font></font>
{<font></font>
  <span class="hljs-comment">//    </span><font></font>
  ControlModes::CHARACTER_MOVEMENT,<font></font>
  ActionSet<font></font>
  {<font></font>
    {<font></font>
      DigitalBinding{ ActionNames::JUMP, { { InputCode::KB_SPACE, DigitalState::just_pressed() } }, nullopt },<font></font>
      DigitalBinding{ ActionNames::MOVE, { { InputCode::KB_W, DigitalState::pressed() } }, ActionValue{ AnalogState{<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>} } },
      <span class="hljs-comment">//    ...</span><font></font>
    },<font></font>
    {<font></font>
      AnalogBinding{ ActionNames::LOOK, InputCode::MOUSE_RELATIVE_POSITION, AnalogStateType::ABSOLUTE, AnalogStateBasis::LOGICAL, {} }<font></font>
      <span class="hljs-comment">//    ...</span><font></font>
      }<font></font>
    }<font></font>
  },<font></font>
<font></font>
  {<font></font>
    <span class="hljs-comment">//      </span><font></font>
    ControlModes::AUTOMATIC_FIRE,<font></font>
    ActionSet<font></font>
    {<font></font>
      {<font></font>
        <span class="hljs-comment">// FIRE    ,     </span><font></font>
        DigitalBinding{ ActionNames::FIRE, { { InputCode::MOUSE_LBUTTON, DigitalState::pressed() } }, nullopt },<font></font>
    <font></font>
        <span class="hljs-comment">//       ...</span><font></font>
      }<font></font>
    }<font></font>
  },<font></font>
<font></font>
  {<font></font>
    <span class="hljs-comment">//      </span><font></font>
    ControlModes::SEMI_AUTOMATIC_FIRE, <font></font>
    ActionSet<font></font>
    {<font></font>
      {<font></font>
        <span class="hljs-comment">// FIRE         </span><font></font>
        DigitalBinding{ ActionNames::FIRE, { { InputCode::MOUSE_LBUTTON, DigitalState::just_pressed() } }, nullopt },<font></font>
<font></font>
        <span class="hljs-comment">//       ...</span><font></font>
      }<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">//   ...</span><font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バトルプライムは約40のアクションについて説明しています。</font><font style="vertical-align: inherit;">それらの一部は、デバッグまたはクリップの記録にのみ使用されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レプリケーション</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レプリケーションは、サーバーからクライアントにデータを転送するプロセスです。</font><font style="vertical-align: inherit;">すべてのデータは、世界のオブジェクトを介して送信されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼らの作成と削除、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトのコンポーネントの作成と削除、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントのプロパティを変更します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レプリケーションは、適切なコンポーネントを使用して構成されます。</font><font style="vertical-align: inherit;">たとえば、同様の方法で、ゲームはプレイヤーの武器の複製を設定します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span>* replication_component = weapon_entity.add&lt;ReplicationComponent&gt;();<font></font>
replication_component-&gt;enable_replication&lt;WeaponDescriptorComponent&gt;(Privacy::PUBLIC);<font></font>
replication_component-&gt;enable_replication&lt;WeaponBaseStatsComponent&gt;(Privacy::PUBLIC);<font></font>
replication_component-&gt;enable_replication&lt;WeaponComponent&gt;(Privacy::PRIVATE);<font></font>
replication_component-&gt;enable_replication&lt;BallisticsStatsComponent&gt;(Privacy::PRIVATE);<font></font>
<span class="hljs-comment">// ...   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントごとに、レプリケーション中に使用されるプライバシーが指定されます。プライベートコンポーネントは、この武器を所有するプレーヤーにのみサーバーから送信されます。パブリックコンポーネントは全員に送信されます。この例では、 `WeaponDescriptorComponent`と` WeaponBaseStatsComponent`はパブリックです-他のプレイヤーの正しい表示に必要なデータが含まれています。たとえば、アニメーションには、武器が置かれているスロットのインデックスとそのタイプが必要です。残りのコンポーネントは、この武器を所有するプレーヤーに非公開で送信されます-砲弾の弾道のパラメータ、総弾数に関する情報、使用可能な射撃モードなど。より特別なプライバシーモードがあります。たとえば、コンポーネントを同盟国または敵だけに送信できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明内の各コンポーネントは、このコンポーネント内で複製されるフィールドを指定する必要があります。</font><font style="vertical-align: inherit;">たとえば、 `WeaponComponent`内のすべてのフィールドは、` Replicable`としてマークされます。</font></font><br>
<br>
<pre><code class="cpp hljs">BZ_VIRTUAL_REFLECTION_IMPL(WeaponComponent)<font></font>
{<font></font>
    ReflectionRegistrar::begin_class&lt;WeaponComponent&gt;()<font></font>
        .ctor_by_pointer()<font></font>
        .copy_ctor_by_pointer()<font></font>
        .field(<span class="hljs-string">"owner"</span>, &amp;WeaponComponent::owner)[M&lt;Replicable&gt;()]<font></font>
        .field(<span class="hljs-string">"fire_mode"</span>, &amp;WeaponComponent::fire_mode)[M&lt;Replicable&gt;()]<font></font>
        .field(<span class="hljs-string">"loaded_ammo"</span>, &amp;WeaponComponent::loaded_ammo)[M&lt;Replicable&gt;()]<font></font>
        .field(<span class="hljs-string">"ammo"</span>, &amp;WeaponComponent::ammo)[M&lt;Replicable&gt;()]<font></font>
        .field(<span class="hljs-string">"shooting_cooldown_end_ms"</span>, &amp;WeaponComponent::shooting_cooldown_end_ms)[M&lt;Replicable&gt;()];<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメカニズムは非常に便利です。</font><font style="vertical-align: inherit;">たとえば、（特別なゲームモードで）殺された対戦相手からトークンを「排出」するサーバーシステム内では、そのようなトークンに「ReplicationComponent」を追加して設定するだけで十分です。</font><font style="vertical-align: inherit;">次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> Component* component : added_dead_avatars-&gt;components)<font></font>
{<font></font>
    Entity kill_token_entity = world-&gt;create_entity();<font></font>
    <font></font>
    <span class="hljs-comment">//          </span>
    <span class="hljs-comment">// ...</span><font></font>
   <font></font>
    <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">auto</span>* replication_component = kill_token_entity.add&lt;ReplicationComponent&gt;();<font></font>
    replication_component-&gt;enable_replication&lt;TransformComponent&gt;(Privacy::PUBLIC);<font></font>
    replication_component-&gt;enable_replication&lt;KillTokenComponent&gt;(Privacy::PUBLIC);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、発生時にトークンの物理シミュレーションがサーバーで行われ、トークンの最終的な変換が送信されてクライアントに適用されます。補間システムはクライアントでも機能し、更新の頻度、サーバーへの接続の品質などを考慮して、このトークンの動きをスムーズにします。このゲームモードに関連付けられている他のシステムは、 `KillTokenComponent`を使用してオブジェクトにビジュアルパーツを追加し、それらの選択を監視します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在のアプローチで、注意を払いたい、将来的に削除したい唯一の不便な点は、各コンポーネントフィールドにプライバシーを設定できないことです。コンポーネントをいくつかに分割することで同様の問題を簡単に解決できるため、これはそれほど重要ではありません。たとえば、ゲームには、対応するプライバシーを持つ `ShooterPublicComponent`と` ShooterPrivateComponent`が含まれています。同じメカニズム（撮影）に関連付けられているという事実にもかかわらず、トラフィックを節約するために2つのコンポーネントが必要です-一部のフィールドは、これらのコンポーネントを所有していないクライアントでは単に必要ありません。ただし、これはプログラマーに作業を追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、クライアントに複製されたオブジェクトは、さまざまなフレームの状態を持つことができます。</font><font style="vertical-align: inherit;">したがって、レプリケーショングループを作成してオブジェクトをグループ化する機能が追加されました。</font><font style="vertical-align: inherit;">同じグループ内のオブジェクトのすべてのコンポーネントには、常にクライアントの同じフレームの状態があります。これは、予測が正しく機能するために必要です（詳細は以下を参照）。</font><font style="vertical-align: inherit;">たとえば、武器とそれを所有するキャラクターは同じグループに属しています。</font><font style="vertical-align: inherit;">オブジェクトが異なるグループにある場合、世界でのオブジェクトの状態は異なるフレームである可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レプリケーションシステムは、特に送信データを圧縮し（コンポーネント内の各フィールドにオプションで圧縮のマークを付けることができます）、2つのフレーム間の値の違いのみを送信することにより、トラフィック量を最小限に抑えようとします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顧客の予測</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアント予測（クライアント側予測という用語は英語で使用されます）を使用すると、プレーヤーはゲームでのほとんどのアクションについて即座にフィードバックを受け取ることができます。</font><font style="vertical-align: inherit;">同時に、最後の単語は常にサーバーの後ろにあるため、シミュレーションでエラーが発生した場合（誤解という用語は英語で使用されます。将来的には単に「誤解」と呼ぶことにします）、クライアントはそれを修正する必要があります。</font><font style="vertical-align: inherit;">予測エラーとその修正方法の詳細については、以下で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントの予測は、次のルールに従って機能します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントは自分自身をNフレームだけシミュレートします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントによって生成されたすべての入力は、（プレーヤーによって実行されるアクションの形式で）サーバーに送信されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nはサーバーへの接続の品質に依存します。</font><font style="vertical-align: inherit;">この値が小さいほど、クライアントの世界の画像はより「最新」になります（つまり、ローカルプレーヤーと他のプレーヤーの間の時間差が小さくなります）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、サーバーとクライアントの両方がクライアント入力に基づいてシミュレーションを実行します。</font><font style="vertical-align: inherit;">次に、サーバーはこのシミュレーションの結果をクライアントに送信します。</font><font style="vertical-align: inherit;">結果がサーバーの結果と一致しないとクライアントが判断した場合、クライアントはエラーを修正しようとします-自身を最後の既知のサーバー状態にロールバックし、再びNフレーム先をシミュレートします。</font><font style="vertical-align: inherit;">その後、すべてが同様のスキームに従って続行されます。クライアントは、サーバーに対して将来的に自分自身をシミュレートし続け、サーバーはそれにシミュレーションの結果を送信します。</font><font style="vertical-align: inherit;">したがって、クライアントの予測に影響するすべてのコードは、クライアントとサーバー間で共有する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、トラフィックを節約するために、入力全体が事前定義されたスキームに基づいて事前圧縮されます。次に、サーバーに送信され、すぐにクライアントで解凍されます。クライアントとサーバー間の入力に関連付けられた値の違いを排除するには、クライアントでのパッケージ化とその後のアンパックが必要です。スキームを作成するとき、このアクションの値の範囲と、それをパックする必要があるビット数が示されます。同様に、Battle Primeのパッケージスキームのアナウンスは、クライアントとサーバー間の一般的なシステムの内部のように見えます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span>* input_packing_sc = world-&gt;get_for_write&lt;InputPackingSingleComponent&gt;();<font></font>
input_packing_sc-&gt;packing_schema = {<font></font>
    { ActionNames::MOVE, AnalogStatePrecision{ <span class="hljs-number">8</span>, { <span class="hljs-number">-1.f</span>, <span class="hljs-number">1.f</span> }, <span class="hljs-literal">false</span> } },<font></font>
    { ActionNames::LOOK, AnalogStatePrecision{ <span class="hljs-number">16</span>, { -PI, PI }, <span class="hljs-literal">false</span> } },<font></font>
    { ActionNames::JUMP, nullopt },<font></font>
    <span class="hljs-comment">// ..    action'</span><font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアント予測のパフォーマンスが機能するための重要な条件は、この入力が関連するフレームシミュレーションの時間までに、入力がサーバーに到達する時間を持つ必要があることです。入力がサーバー上の目的のフレームに到達できなかった場合（これは、たとえば、鋭いpingジャンプ中に発生する可能性があります）、サーバーは前のフレームからのこのクライアントの入力を使用しようとします。これは、状況によってはクライアントの予測ミスを取り除くのに役立つバックアップメカニズムです。たとえば、クライアントが単に一方向で実行され、その入力が比較的長い間変化しない場合、最後のフレームの入力を使用すると成功します。サーバーがそれを「推測」し、クライアントとサーバーの間に矛盾はありません。同様のスキームがオーバーウォッチで使用されています（GDCの講義で言及されました：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.youtube.com/watch?v=W3aieHjyNvw</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、Battle Primeクライアントは次のオブジェクトのステータスを予測しています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレーヤーのアバター（世界での位置とそれに影響を与える可能性のあるすべてのもの、スキルの状態など）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのプレイヤーの武器（店内のラウンド数、ショット間のクールダウンなど）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアント予測の使用は、クライアント上の「PredictionComponent」を目的のオブジェクトに追加および構成することになります。</font><font style="vertical-align: inherit;">たとえば、いずれかのシステムでのプレーヤーのアバターの予測は、同様の方法でオンになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// `new_local_avatars`       ,</span>
<span class="hljs-comment">//     </span>
<span class="hljs-keyword">for</span> (Entity avatar : new_local_avatars)<font></font>
{<font></font>
    <span class="hljs-keyword">auto</span>* avatar_prediction_component = avatar.add&lt;PredictionComponent&gt;();<font></font>
    avatar_prediction_component-&gt;enable_prediction&lt;TransformComponent&gt;();<font></font>
    avatar_prediction_component-&gt;enable_prediction&lt;CharacterControllerComponent&gt;();<font></font>
    avatar_prediction_component-&gt;enable_prediction&lt;ShooterPrivateComponent&gt;();<font></font>
    avatar_prediction_component-&gt;enable_prediction&lt;ShooterPublicComponent&gt;();<font></font>
    <span class="hljs-comment">// ...     </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは、上記のコンポーネント内のフィールドがサーバーコンポーネントの同じフィールドと常に比較されることを意味します。単一のフレーム内の値の不一致に気づいた場合、クライアントで調整が行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不一致の基準は、データのタイプによって異なります。ほとんどの場合、これは `operator ==`への呼び出しにすぎません。例外はフロートに基づくデータです。それらの最大許容エラーは現在固定されており、0.005に等しくなります。将来的には、コンポーネントの各フィールドの精度を個別に設定する機能を追加したいという要望があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レプリケーションとクライアント予測のワークフローは、シミュレーションに必要なすべてのデータがコンポーネントに含まれているという事実に基づいています。上記のECSのセクションで、システムがデータの一部を保持することを許可することを書きました。これは場合によっては便利です。これは、シミュレーションに影響を与えるデータには適用されません。クライアントとサーバーのスナップショットシステムはコンポーネントでのみ機能するため、常にコンポーネント内にある必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネント内のフィールド値を予測することに加えて、コンポーネントの作成と削除を予測することが可能です。たとえば、アビリティを使用した結果、 `SpeedModifierComponent`がキャラクターにスーパーインポーズされた場合（動きの速度を変更したり、プレーヤーを加速したりした場合）、同じフレームのサーバーとクライアントの両方でキャラクターに追加する必要があります。それ以外の場合は、クライアント上でのキャラクターの位置の誤った予測につながります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトの作成と削除の予測は現在サポートされていません。これは状況によっては便利な場合がありますが、ネットワークモジュールも複雑になります。おそらく私たちは将来これに戻るでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、RTTで約1.5秒間キャラクターコントロールが行われるgifです。</font><font style="vertical-align: inherit;">ご覧のように、移動、射撃、リロード、手榴弾投げなどの大きな遅延にもかかわらず、キャラクターは即座に制御されます-サーバーからの情報を待たずにすべてが起こります。</font><font style="vertical-align: inherit;">また、ポイント（三角形で制限されたゾーン）のキャプチャが遅延で始まることに気付く場合もあります。このメカニズムはサーバーでのみ機能し、クライアントでは予測されません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6b/224/09f/a6b22409f317a314819b0163f14f2b6e.gif" alt="画像" height="1024" width="768"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予測ミスと再シミュレーション</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予測ミス-サーバーとクライアントのシミュレーション結果の不一致。再シミュレーションは、クライアントによるこの不一致を修正するプロセスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予測ミスが発生する最初の理由は、クライアントが調整する時間のない急激なpingジャンプです。そのような状況では、プレーヤーからの入力にサーバーに到達する時間がなく、サーバーは上記のバックアップメカニズムを使用して、最後の入力をしばらくの間複製し、しばらくすると使用を停止します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の理由は、完全にサーバー制御され、クライアントによってローカルで予測されないオブジェクトとキャラクターの相互作用です。たとえば、別のプレーヤーとの衝突は、実際には2つの異なる期間に住んでいるため、予測の誤りを引き起こします（ローカルキャラクターは将来、別のプレーヤーと比較して、サーバーからの位置で補間されます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目の最も不愉快な理由は、コードのバグです。たとえば、システムは複製されていないデータを誤って使用してシミュレーションを制御したり、システムが間違った順序で動作したり、サーバーとクライアントで異なる順序で動作したりすることがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのバグを見つけるには、かなりの時間がかかることがあります。検索を簡略化するために、いくつかの補助ツールを作成しました。アプリケーションの実行中に、次のように表示されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複製されたコンポーネント</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予測ミスの数</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのフレームで起こりましたか、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分岐したコンポーネントのサーバーとクライアントのデータ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このフレームに対してサーバーとクライアントに適用された入力。</font></font></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/9d/ym/7x/9dym7xq_wej-rqkes4zumdvkrxa.png" height="1024" width="768"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/4t/4i/ar/4t4iarkyqjkmgdlbabbfordysgi.png" height="1024" width="768"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gp/zt/cy/gpztcyp0k9yobauozchbixe4suy.png" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、それらを使用しても、再シミュレーションの原因の検索にはまだかなりの時間がかかります。</font><font style="vertical-align: inherit;">バグの可能性を減らし、バグの検索を簡素化するために、ツールキットと検証を開発する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再シミュレーションの操作をサポートするために、システムは特定のクラス「ResimulatableSystem」から継承する必要があります。</font><font style="vertical-align: inherit;">予測ミスが発生した状況では、世界はすべてのオブジェクトを最後の既知のサーバー状態に「ロールバック」し、このエラーを修正するために必要な数のシミュレーションを先に行います。これには再シミュレーション可能なシステムのみが参加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、クライアントの再シミュレーションはプレーヤーに気付かれるべきではありません。</font><font style="vertical-align: inherit;">それらが発生すると、すべてのコンポーネントフィールドが新しい値にスムーズに補間され、起こり得る「けいれん」が視覚的に滑らかになります。</font><font style="vertical-align: inherit;">ただし、その数をできるだけ少なくすることが重要です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">撮影</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレイヤーへのダメージはサーバーによって完全に決定されます-不正行為の可能性を減らすために顧客がそのような重要なメカニズムで信頼されることはできません。ただし、動きと同様に、クライアントでの撮影は可能な限り遅滞なく反応する必要があります。プレーヤーは、エフェクトとサウンドの形で瞬時にフィードバックを受け取る必要があります-銃口フラッシュ、発射体の飛行の軌跡、および周囲や他のプレーヤーに当たる発射体の影響。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、射撃に関連するキャラクターの全体的な状態は、店内にあるラウンドの数、発砲中の分散、ショット間の遅延、最後のショットの時間など、クライアントによって予測されます。また、クライアントには、サーバーと同じシェルの動きを担当する同じシステムがあります。これにより、サーバーでのシミュレーションの結果を待たずに、クライアントでショットをシミュレートできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェル自体の弾道は予測されません-シェルは非常に高速で飛行し、通常、数フレームで動きを終えるため、シミュレーション結果を得る前に、シェルはすでに世界のある時点に到達し、効果を失う時間があります。これはサーバーからの発射物です（または、予測ミスのためにクライアントが誤って発射物を発射した場合の結果の欠如）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゆっくりと飛ぶ砲弾の作業スキームは少し異なります。</font><font style="vertical-align: inherit;">プレイヤーが手榴弾を投げたが、予測ミスの結果、手榴弾が投げられなかったことが判明した場合、クライアントでは手榴弾が破壊されます。</font><font style="vertical-align: inherit;">同様に、クライアントが手榴弾の破壊を誤って予測した場合（すでにサーバー上で爆発しましたが、まだクライアント上ではありません）、クライアント手榴弾も破壊されます。</font><font style="vertical-align: inherit;">クライアントエラーの結果としてサーバーの爆発が別の場所で発生し、クライアントで別の場所で発生した状況を回避するために、クライアントに表示される爆発に関するすべての情報はサーバーから取得されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的には、私は将来的にゆっくり飛ぶ貝殻を完全に予測したいと思います-人生の時間だけでなく、それらの位置も。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラグ補償</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラグ補正は、サーバーとクライアント間の遅延が撮影の精度に与える影響を平準化するための手法です。</font><font style="vertical-align: inherit;">このセクションでは、射撃は常に「ヒットスキャン」兵器から行われると想定します。つまり、</font><font style="vertical-align: inherit;">武器によって発射された発射物は無限の速度で移動します。</font><font style="vertical-align: inherit;">しかし、ここで説明されていることはすべて、他の種類の武器でも重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の点で、撮影時の遅れを補正する必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレーヤーの制御下にあるキャラクターは、サーバーに対して将来的に存在します（特定のフレーム数前の状態を予測します）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したがって、残りのプレイヤーは比較的過去にいます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起動すると、対応するアクションがクライアントからサーバーに送信され、クライアントで適用されたのと同じフレームに適用されます（可能な場合）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレイヤーが頭に向かって走っている敵を狙っていると想定し、ショットボタンを押すと、次の画像が得られます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアント上：フレームN1の射手がフレームN0（N0 &lt;N1）にある敵の頭に発砲します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバー上：フレームN1の射手は、同じくフレームN1にある敵の頭に発砲します（サーバー上では、全員が同時に）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この結果、高い確率で、ショット中にミスが発生します。</font><font style="vertical-align: inherit;">クライアントは、サーバーの世界の画像と一致しない世界の画像に基づいてターゲットを設定するため、敵に侵入するために、ヒットスキャン武器を使用する場合でも、彼の前を狙う必要があり、前に撮影する必要がある距離は、サーバ。</font><font style="vertical-align: inherit;">控えめに言っても、これは射手にとって最良の体験ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を取り除くために、ラグ補償が使用されます。</font><font style="vertical-align: inherit;">彼女の作品のスキームは以下の通りです：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーは、世界のスナップショットの限られたサイズの履歴を保持しています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発砲されると、敵（または一部の敵）は、サーバー上の世界がクライアント自体が見た世界と一致するように「ロールバック」します。クライアントは「現在」（ショットの瞬間）にあり、敵は過去にいます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒット検出メカニズムが機能し、ヒットが記録されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">世界は元の状態に戻っています。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアント上の世界の画像も補間システムの操作に依存するため、サーバー上の世界を最も正確なクライアントの状態に「ロールバック」するために、クライアントは追加のデータを提供します-クライアントの現在のフレームと他のすべてのプレーヤーを見るフレームとの差（現時点では、これらはフレームごとに2バイトです）、およびフレームの先頭を基準としたショット入力の生成時間。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラグ補正は、エンジン内の別のモジュールのレベルに存在し、特定のプロジェクトに関連付けられていません。</font><font style="vertical-align: inherit;">ゲームプレイメカニズムの開発者の観点から見ると、その使用法は次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">`LagCompensationComponent`がプレーヤーに追加され、履歴に保存されるヒットボックスのリストが入力されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">射撃（または、近接攻撃など、補償を必要とする他のメカニズム）のときに、 `LagCompensation :: invoke`が呼び出され、特定のプレーヤー、世界の観点から、「補償された」で実行されるファンクターが渡されます。</font><font style="vertical-align: inherit;">必要なヒット検出をすべて備えている必要があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
弾道発射体を移動するときにBatle Primeからの遅延補償を使用する例をコード化します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// `targets_data`    ,</span>
<span class="hljs-comment">//   “”    ,</span>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> compensated_action = [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">const</span> Vector&lt;LagCompensation::LagCompensationData&gt;&amp; targets_data) {<font></font>
  process_projectile(projectile, elapsed_time);<font></font>
};<font></font>
<font></font>
LagCompensation::invoke(<font></font>
  observer, <span class="hljs-comment">// ,      </span>
  projectile_component-&gt;input_time_ms, <span class="hljs-comment">// ,     </span>
  compensated_entities, <span class="hljs-comment">// ,   </span>
  compensated_action <span class="hljs-comment">// ,      </span><font></font>
);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラグ補正は、射手が経験しているターゲットの経験よりも射撃の経験を優先させる方式であることにも注意したいと思います。</font><font style="vertical-align: inherit;">ターゲットの視点から見ると、敵は既に障害物（ゲームフォーラムで頻繁に苦情）の後ろにいるときに敵に侵入する可能性があります。</font><font style="vertical-align: inherit;">これを行うために、ラグ補償には、目標を「汲み出す」ことができるフレームの数に制限があります。</font><font style="vertical-align: inherit;">現時点では、バトルプライムでは、RTTが約400ミリ秒の射手が快適に敵を攻撃できます。</font><font style="vertical-align: inherit;">RTTが高い場合は、先に撃つ必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
補償なしの射撃の例-敵を着実に攻撃するには、前方に射撃する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/510/94b/f4951094b844f899b7bafc0fd2783534.gif" alt="画像" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、補償付き-快適に敵を直接狙うことができます：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/2fe/126/ffe2fe12616364feb0251847e02b3807.gif" alt="画像" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビルドエージェントは、さまざまなメカニズムの動作をチェックする自動テストも定期的に実行します。その中には、ラグ補正を有効にした発砲精度の自動テストもあります。下のテストは下のgifに示されています。キャラクターは単に、過去を走っている敵の頭を撃ち、ヒットした数を数えます。デバッグのために、ショット時にサーバー上にあった敵のヒットボックス（白）と、補正された世界（青）内でヒット検出に使用されたヒットボックスがさらに表示されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f99/8cf/e30/f998cfe305878180085bb44352b36a85.gif" alt="画像" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
射撃の精度に影響を与える追加の要因は、キャラクターのヒットボックスの位置です。</font><font style="vertical-align: inherit;">Hitboxはスケルトンアニメーションに依存しており、そのフェーズは現在どのような方法でも同期されていないため、クライアントとサーバーでHitboxが異なる状況が発生する可能性があります。</font><font style="vertical-align: inherit;">この結果はアニメーション自体に依存します。アニメーション内の動きの範囲が大きいほど、サーバーとクライアント間のヒットボックスの位置の潜在的な差が大きくなります。</font><font style="vertical-align: inherit;">実際には、そのような違いはプレーヤーにはわずかに気づき、下半身に影響を与えます。これは、上半身（頭、胴体、腕）に比べてそれほど重要ではありません。</font><font style="vertical-align: inherit;">それにもかかわらず、将来的には、サーバーとクライアントの間でアニメーションを同期する問題についてさらに詳しく説明したいと思います。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、Battle Primeが構築されている基盤について説明しようとしました。これは、Blitz Engine内のECSパターンの実装であり、レプリケーション、クライアント予測、および関連するメカニズムを担当するネットワークモジュールです。</font><font style="vertical-align: inherit;">いくつかの欠点（私たちは修正に取り組んでいます）にも関わらず、この機能の使用は今やシンプルで便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バトルプライムの全体像を示すために、多くのトピックに触れなければなりませんでした。</font><font style="vertical-align: inherit;">それらの多くは、将来、個別の記事に専念する可能性があり、それらについてはさらに詳しく説明します！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームはすでにトルコとフィリピンでテストされています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
著者：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロレグリアン</font></font></a> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前の記事は次のリンクにあります。</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/en/post/461623</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/en/post/465343</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja469691/index.html">10月にApache IgniteとGridGainについて聞く場所</a></li>
<li><a href="../ja469693/index.html">何百万もの中国人を30分で養う方法</a></li>
<li><a href="../ja469697/index.html">伝統的に製造されたビジネスプロセスにおける新技術の誕生</a></li>
<li><a href="../ja469703/index.html">通常のアバロニア</a></li>
<li><a href="../ja469707/index.html">Scalaと連動するようにVSCodeを構成する</a></li>
<li><a href="../ja469717/index.html">光を輝かせて</a></li>
<li><a href="../ja469721/index.html">Dell OptiPlex 7070 Ultra：モニターをモノブロック化するモジュラーコンピューター</a></li>
<li><a href="../ja469723/index.html">Yandex.CloudとPythonのサーバーレス関数でAliceのステートフルスキルを作成する</a></li>
<li><a href="../ja469725/index.html">ヒッチハイカーのための太陽系ガイド</a></li>
<li><a href="../ja469731/index.html">IRO.Mvc.MvcExceptionHandlerを使用したASP.NET例外の処理</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>