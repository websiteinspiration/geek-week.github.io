<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🌾 👨🏿‍🔧 🕴🏽 以RoughJS为例模仿徒手画 🚣🏼 ⬇️ 🎎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RoughJS是一个小的（< 9KB）JavaScript图形库，允许您以粗略的手写样式进行绘制。它使您可以使用<canvas>和进行绘制SVG。在这篇文章中，我想回答有关RoughJS的最流行的问题：它是如何工作的？
 
 
 一点历史
 我对手写的图形，图表和草图的图像着迷，我像一个真正的书呆子...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>以RoughJS为例模仿徒手画</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500018/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RoughJS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个小的（&lt; </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">9KB</font></a><font style="vertical-align: inherit;">）JavaScript图形库，允许您以</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">粗略的手写</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">样式</font><font style="vertical-align: inherit;">进行绘制</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它使您可以使用</font></font><code>&lt;canvas&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">进行绘制</font></font><code>SVG</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这篇文章中，我想回答有关RoughJS的最流行的问题：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它是如何工作的？</font></font></strong><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/06b/dcb/dee/06bdcbdee1eec1748f07434abb002f34.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一点历史</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我对手写的图形，图表和草图的图像着迷，我像一个真正的书呆子一样问自己：我可以在代码的帮助下创建这样的图形，在不影响软件实现的前提下，尽可能精确地手工模拟图形吗？我决定专注于图元（直线，多边形，椭圆和曲线）以创建整个2D图形库。基于此，您可以创建用于绘制图形和图表的库和图形。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在简短地研究了这个问题之后，我发现了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Joe Wood</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">及其同事</font><font style="vertical-align: inherit;">的一篇</font><font style="vertical-align: inherit;">名为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sketchy rendering</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的文章，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">用于信息可视化</font></a><font style="vertical-align: inherit;">。其中描述的技术成为该库的基础，尤其是在绘制线条和椭圆形时。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2017年，我编写了该库的第一个版本，该版本仅适用于Canvas。</font><font style="vertical-align: inherit;">解决了这个问题，我对此失去了兴趣。</font><font style="vertical-align: inherit;">一年后，我在SVG上工作了很多，并决定使RoughJS适应SVG。</font><font style="vertical-align: inherit;">我还更改了API的结构以使其更简单，并着重于简单的矢量图形基元。</font><font style="vertical-align: inherit;">我在Hacker News上谈论了2.0版，突然间它获得了极大的欢迎。</font><font style="vertical-align: inherit;">在2018年，这是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShowHN第二受欢迎的职位</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从那时起，其他人基于RoughJS创建了更多令人惊奇的东西，例如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excalidraw</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why do Cats and Dogs ...</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">roughViz图形库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在让我们谈谈算法...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参差不齐</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
模仿手写图形的基本基础是机会。</font><font style="vertical-align: inherit;">当我们手工绘制时，任何两个形状都会有所不同。</font><font style="vertical-align: inherit;">没有人能够完美地精确绘制，因此RoughJS中的每个空间点都针对随机位移进行了调整。</font><font style="vertical-align: inherit;">随机性的大小由数值参数给出</font></font><code>roughness</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35d/b72/e5e/35db72e5e11caf5a6cb19e194b0a5972.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
想象一下</font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">围绕它的</font><font style="vertical-align: inherit;">一个点</font><font style="vertical-align: inherit;">和一个圆。</font><font style="vertical-align: inherit;">现在替换</font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为该圆内的</font><font style="vertical-align: inherit;">一个</font><font style="vertical-align: inherit;">随机点。</font><font style="vertical-align: inherit;">这个随机性圈的面积由值控制</font></font><code>roughness</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线数</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手写线条从来没有笔直，常常表现出在曲率</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弯</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（形容</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">我们基于粗糙度随机化线的两个端点。</font><font style="vertical-align: inherit;">然后，我们再选择两个随机点，这些随机点距离该段的末端大约50％和75％。</font><font style="vertical-align: inherit;">通过连接曲线的这些点，我们可以获得</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弯曲</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的效果</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/f29/8fe/633f298feb4231e8c9d652cb2811b4ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手工绘图时，人们有时会沿直线前后移动铅笔。</font><font style="vertical-align: inherit;">这对于使线条更亮或者仅校正线条的直线度是必要的。</font><font style="vertical-align: inherit;">看起来像这样：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/377/2fd/665/3772fd6659c97c0dea4144645d63fdf7.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了增加草图效果，RoughJS绘制了两条线。</font><font style="vertical-align: inherit;">将来，我计划使这方面更具可定制性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看一下这个画布表面。</font><font style="vertical-align: inherit;">粗糙度参数更改线条的外观：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vw/vy/fp/vwvyfpdytbbalxolkj9eufdctri.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在画布上的原始文章中，您可以自己绘画。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手工绘制时，长线通常变得不那么笔直，而更加弯曲。</font><font style="vertical-align: inherit;">也就是说，产生效果的偏移量的随机性</font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是线长和值的函数</font></font><code>randomness</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，缩放此功能不适用于非常长的行。</font><font style="vertical-align: inherit;">例如，在下图中，使用相同的随机种子绘制同心正方形，即 </font><font style="vertical-align: inherit;">实际上，它们是一个随机数，但是具有不同的比例。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6f/943/aaf/c6f943aaf7f5fd94336286e902a7ed5b.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能会注意到，外部正方形的边缘看起来比内部正方形的边缘更加不均匀。</font><font style="vertical-align: inherit;">因此，我还根据线路长度添加了一个阻尼系数。</font><font style="vertical-align: inherit;">衰减系数用作各种长度的阶跃函数。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0f/f30/162/f0ff30162ccf5f76efab1543ed36b79a.jpg"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">椭圆（和圆圈）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
取一张纸并连续不断地尽可能快地画几个圆圈。</font><font style="vertical-align: inherit;">这是我得到的：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/268/911/691/2689116919287022e800ab72c7e3877f.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，循环的起点和终点并不总是匹配。</font><font style="vertical-align: inherit;">RoughJS试图模仿这一点，同时使外观更加完整（该技术改编自</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">giCenter文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该算法找到由</font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">椭圆</font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的大小确定</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">椭圆点</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后，将每个点的值随机化</font></font><code>roughness</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后通过这些点绘制一条曲线。</font><font style="vertical-align: inherit;">为了获得</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">断开的端点</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的效果，</font><font style="vertical-align: inherit;">从第二个到最后一个的点与第一个点不重合。</font><font style="vertical-align: inherit;">取而代之的是，曲线连接了第二和第三点。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/a4f/238/4d8a4f238460b44b847da72c22cbf3d1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还绘制了第二个椭圆，以便使循环更闭合并具有附加的草图效果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在原始文章中，您可以在交互式画布表面上绘制椭圆。</font><font style="vertical-align: inherit;">改变粗糙度并观察形状如何变化：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/kq/5g/9o/kq5g9ouwifltwn-qfp2tednoaqq.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在画线的情况下，如果将某些形状缩放到不同大小，则某些假象会变得更加突出。</font><font style="vertical-align: inherit;">在椭圆形中，此效果更为明显，因为该比例是二次方。</font><font style="vertical-align: inherit;">在下图中，所有圆都具有相同的形状，但外面的圆看起来更不均匀。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/bc1/682/d1cbc168206970ade73e1b7a77639d7d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该算法会根据形状的大小自动进行调整，从而增加圆（</font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）中</font><font style="vertical-align: inherit;">的点数</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以下是使用自动调整生成的同一组圆。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa4/6f0/612/aa46f0612d82b8944e70fb888db8ac39.jpg"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">填写</font></font></h2><br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虚线</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
通常用于填充手绘形状</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在徒手画草图的情况下，线条并不总是保留在形状的轮廓之内。</font><font style="vertical-align: inherit;">它们也是随机的。</font><font style="vertical-align: inherit;">密度，角度，线宽均可调节。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/d62/0dc/1e4d620dc5d4e0c7167c7f64595537c6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上面显示的正方形容易填充，但是在其他形状的情况下，可能会发生各种问题。</font><font style="vertical-align: inherit;">例如，凹面多边形（角度可能超过180°）通常会导致以下问题：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20b/9cd/46f/20b9cd46fba00903739307fba87386f0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，上面的图像是从RoughJS早期版本之一的错误报告中获取的。从那时起，我通过适应</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串扫描方法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的版本更新了笔划填充算法</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串扫描算法</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可用于填充任何多边形。其原理是使用水平线（栅格线）扫描多边形。栅格线从多边形的顶部开始向下。对于每条栅格线，我们确定线与多边形相交的点。我们从左到右建立这些交点。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/6df/028/8d96df0287ebd8320120e61813fc30f6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从点到点，我们从填充模式切换到非填充模式；</font><font style="vertical-align: inherit;">当栅格线上的每个交点相遇时，就会在状态之间进行切换。</font><font style="vertical-align: inherit;">在这里，还需要考虑更多，特别是边界情况和扫描优化方法。</font><font style="vertical-align: inherit;">您可以在此处阅读有关此内容的更多信息：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">栅格化多边形</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，或使用伪代码部署扰流器。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串扫描算法的执行细节</font></font></b>
                        <div class="spoiler_text">     ()      .<br>
<br>
 —     (Edge Table, ET),   ,    <code>Y<sub>min</sub></code>.      <code>Y<sub>min</sub></code>,        <code>X<sub>min</sub></code>.<br>
<br>
 —     (Active Edge Table, AET),       ,     .<br>
<br>
        :<br>
<br>
<pre><code class="javascript hljs">interface EdgeTableEntry {
  <span class="hljs-attr">ymin</span>: number;<font></font>
  ymax: number;<font></font>
  x: number; <span class="hljs-comment">// Initialized to Xmin</span>
  iSlope: number; <span class="hljs-comment">// Inverse of the slope of the line: 1/m</span><font></font>
}<font></font>
<font></font>
interface ActiveEdgeTableEntry {<font></font>
  <span class="hljs-attr">scanlineY</span>: number; <span class="hljs-comment">// The y value of the scanline</span><font></font>
  edge: EdgeTableEntry;<font></font>
}</code></pre><br>
   ,    :<br>
<br>
<strong>1.</strong>  <em>y</em>   <em>y</em>  ET.      .<br>
<br>
<strong>2.</strong>  AET   .<br>
<br>
<strong>3.</strong>   ,   AET,  ET  :<br>
<br>
<strong>(a)</strong>    ET <em>y</em>  AET ,   <em>y<sub>min</sub> ≤ y</em>.<br>
<br>
<strong>(b)</strong>   AET ,   <em>y = y<sub>max</sub></em>,    AET  <em>x</em>.<br>
<br>
<strong>()</strong>      <em>y</em>,    <em>x</em>  AET.<br>
<br>
<strong>(d)</strong>   <em>y</em>   ,   , ..    .<br>
<br>
<strong>(e)</strong>    ,   AET,  <em>x</em>   <em>y</em> (<code>edge.x = edge.x + edge.iSlope</code>)</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在下面的图像中（在互动的原始文章中），每个正方形表示一个像素。</font><font style="vertical-align: inherit;">您可以移动顶点以更改多边形，并观察传统上将填充哪些像素。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/2p/o7/wg/2po7wg8kdj0ixdeogj9_b2hax78.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
填充笔划时，根据笔划线的给定密度以增量执行栅格线的增加，并使用上述算法绘制每条线。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，此算法适用于水平栅格线。</font><font style="vertical-align: inherit;">为了实现不同的笔触角度，算法首先将形状本身旋转所需的笔触角度。</font><font style="vertical-align: inherit;">然后计算旋转图形的光栅线。</font><font style="vertical-align: inherit;">此外，计算出的线沿相反方向旋转回到笔触角度。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9b/1ad/324/e9b1ad3244af05b53b02203659e7f6f7.jpg"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不只是填写笔画</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RoughJS还支持其他填充样式，但它们均源自相同的填充算法。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交叉阴影</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线包括以一定角度绘制虚线</font></font><code>angle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后</font><font style="vertical-align: inherit;">以一定角度绘制</font><font style="vertical-align: inherit;">其他线条</font></font><code>angle + 90°</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之字形</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">试图将一条虚线与上一条虚线连接起来。</font><font style="vertical-align: inherit;">要获得</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">点</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图案，请沿虚线绘制小圆圈。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/06b/dcb/dee/06bdcbdee1eec1748f07434abb002f34.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲线</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RoughJS中的所有内容均已标准化为曲线-线，多边形，椭圆等。</font><font style="vertical-align: inherit;">因此，此想法的自然发展是创建草图曲线。</font><font style="vertical-align: inherit;">在RoughJS中，我们将一组点传递给一条曲线，然后使用曲线</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">近似</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将它们转换为三次贝塞尔</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">曲线</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个贝塞尔曲线都有两个端点和两个控制点。</font><font style="vertical-align: inherit;">通过将它们随机化</font></font><code>roughness</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您可以类似地创建“手写”曲线。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba3/0bd/82c/ba30bd82c30edfc43f6845670f97f4b0.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲线填充</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，需要逆过程来填充曲线。与其将所有内容归一化为曲线，不如将其归一化为多边形。获取多边形后，可以使用线扫描算法填充曲线形状。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三次贝塞尔曲线</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">方程式</font></a><font style="vertical-align: inherit;">以所需的频率对曲线上的点进行采样</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a85/bcc/2d5/a85bcc2d5b946e8e88df52f2080b5303.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们使用取决于笔画密度的采样频率，那么我们将获得足够的点来填充图形。但这并不是特别有效。如果曲线的一部分很锐利，那么我们需要更多点。如果曲线的一部分几乎是笔直的，则需要更少的点。一种解决方案是确定</font><font style="vertical-align: inherit;">曲线</font><font style="vertical-align: inherit;">的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲率/平滑度</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果曲线非常弯曲，则将曲线分为两条较小的曲线。如果平滑，则我们将其简单地视为一条直线。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
曲线的光滑度使用中所描述的方法来计算</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此信息</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。将平滑度值与公差值进行比较，然后决定是否拆分曲线。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是公差水平为0.7的同一条曲线：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/995/55d/9be/99555d9be7e6cc2223db46f6cbd98da8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅基于公差，该算法即可提供足够的点来表示曲线。</font><font style="vertical-align: inherit;">但是，它不允许您有效地摆脱可选点。</font><font style="vertical-align: inherit;">这将有助于第二个参数名为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distance</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了减少这种方法的点数，使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了Ramer-Douglas-Pecker算法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下示出了具有距离值的生成的点，等于</font></font><code>0.15</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>0.75</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>1.5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>3.0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c9/e93/6e1/4c9e936e15771d9d02d1768a2e14b70b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据</font><font style="vertical-align: inherit;">形状</font><font style="vertical-align: inherit;">的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">粗糙度</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可以设置适当的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">距离</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">收到多边形的所有顶点后，我们可以精美地填充弯曲的形状：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45b/eb7/161/45beb716138e9836c8e841f63d15f28a.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SVG电路</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SVG轮廓</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一种非常强大的工具，可用于创建各种令人惊叹的图像，但是正因为如此，很难使用它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RoughJS仅通过三个操作即可解析路径并将其标准化：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Move</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Line</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cubic Curve</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 （</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">path-data-parser</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。归一化后，可以使用上述绘制线和曲线的方法来绘制图形。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">路径上</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">点</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">软件包</font><font style="vertical-align: inherit;">将</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">路径</font></a><font style="vertical-align: inherit;">的标准化和曲线点的采样相结合，以计算相应的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">路径</font></a><font style="vertical-align: inherit;">点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是路径的示例点计算</font></font><code>M240,100c50,0,0,125,50,100s0,-125,50,-150s175,50,50,100s-175,50,-300,0s0,-125,50,-100s0,125,50,150s0,-100,50,-100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/585/374/dd6/585374dd67d5210ff7628540a6b5edaa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我喜欢显示的另一个SVG示例是美国的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">轮廓</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff7/68b/675/ff768b675300dc4604b87dc2e81478c7.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">试试RoughJS</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
查阅</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Github上</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的网站</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按照</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Twitter </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">@RoughLib</font></a><font style="vertical-align: inherit;">获取项目</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">信息</font></a><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN500008/index.html">满足升频器</a></li>
<li><a href="../zh-CN500010/index.html">氢气污染的历史</a></li>
<li><a href="../zh-CN500012/index.html">实体框架核心</a></li>
<li><a href="../zh-CN500014/index.html">完全响应式设计不只是媒体查询</a></li>
<li><a href="../zh-CN500016/index.html">Redd集中的FPGA的实际工作。掌握用于Avalon-ST总线的DMA以及在Avalon-MM总线之间进行切换</a></li>
<li><a href="../zh-CN500020/index.html">Google Earth Engine-独特的大地理数据分析平台</a></li>
<li><a href="../zh-CN500022/index.html">为什么要参加社区生活，它如何帮助职业发展？</a></li>
<li><a href="../zh-CN500026/index.html">这个行业的废话*简直令人难以置信</a></li>
<li><a href="../zh-CN500028/index.html">数据管理平台：从外围到云</a></li>
<li><a href="../zh-CN500030/index.html">在危机中谁是好人：在大流行期间股价上涨的IT公司的例子</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>