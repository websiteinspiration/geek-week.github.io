<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧥 🎰 ⚛️ 最適化コンパイラのしくみ 🍗 🖐🏼 👩‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最適化コンパイラーは、最新のソフトウェアの基礎です。これにより、プログラマーは理解できる言語でコードを記述し、それを機器で効率的に実行できるコードに変換できます。コンパイラーを最適化するタスクは、作成した入力プログラムが何をするかを理解し、同じことを行う出力プログラムを作成することです。
 
 この...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>最適化コンパイラのしくみ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/477062/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uc/uq/bo/ucuqbo4tluzynnptop1pdmdvjhc.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最適化コンパイラーは、最新のソフトウェアの基礎です。これにより、プログラマーは理解できる言語でコードを記述し、それを機器で効率的に実行できるコードに変換できます。コンパイラーを最適化するタスクは、作成した入力プログラムが何をするかを理解し、同じことを行う出力プログラムを作成することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、コンパイラーの最適化におけるいくつかの基本的な推論手法について説明します。コンパイラーが簡単に機能するプログラムを設計する方法。プログラムでどのような削減を行うことができ、それらを使用して削減および加速する方法。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムオプティマイザーはどこでも実行できます。大規模なコンパイルプロセスの一部として（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scala Optimizer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。コンパイラーの後かつ実行前に起動される別個のプログラムとして（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proguard</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）;または、実行中にプログラムを最適化するランタイム環境の一部として（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVM JITコンパイラー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。オプティマイザの動作の制限は状況によって異なりますが、1つのタスクがあります。入力プログラムを取得して出力プログラムに変換することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、ドラフトプログラムの最適化の例をいくつか見て、オプティマイザが通常行うことと、手動で行う方法を理解します。</font><font style="vertical-align: inherit;">次に、プログラムを提示するいくつかの方法を検討し、最後に、プログラムを分析し、プログラムをより小さく、より速くできるアルゴリズムと手法を分析します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドラフトプログラム</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての例はJavaで提供されます。この言語は非常に一般的で、比較的単純なアセンブラである</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javaバイトコードに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイルされ</font><font style="vertical-align: inherit;">ます。そのため、優れた基盤を作成します。そのおかげで、実際の実行可能な例を使用してコンパイル最適化手法を探ることができます。以下で説明するすべての手法は、他のほとんどすべてのプログラミング言語に適用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、ドラフトプログラムについて検討します。さまざまなロジックが含まれ、プロセス内の標準結果を登録し、計算結果を返します。プログラム自体は意味がありませんが、既存の動作を維持しながら最適化できるものの例として使用されます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, total = <span class="hljs-number">0</span>, multiplied = <span class="hljs-number">0</span>;<font></font>
  Logger logger = <span class="hljs-keyword">new</span> PrintLogger();
  <span class="hljs-keyword">while</span>(count &lt; n){<font></font>
    count += <span class="hljs-number">1</span>;<font></font>
    multiplied *= count;<font></font>
    <span class="hljs-keyword">if</span> (multiplied &lt; <span class="hljs-number">100</span>) logger.log(count);<font></font>
    total += ackermann(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<font></font>
    total += ackermann(multiplied, n);<font></font>
    <span class="hljs-keyword">int</span> d1 = ackermann(n, <span class="hljs-number">1</span>);<font></font>
    total += d1 * multiplied;<font></font>
    <span class="hljs-keyword">int</span> d2 = ackermann(n, count);
    <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) total += d2;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> total;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// https://en.wikipedia.org/wiki/Ackermann_function</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ackermann</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ackermann(m - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ackermann(m - <span class="hljs-number">1</span>, ackermann(m, n - <span class="hljs-number">1</span>));<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Logger</span></span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> Logger <span class="hljs-title">log</span><span class="hljs-params">(Object a)</span></span>;<font></font>
}<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Logger</span></span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> PrintLogger <span class="hljs-title">log</span><span class="hljs-params">(Object a)</span></span>{  System.out.println(a); <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; }<font></font>
}<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Logger</span></span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> ErrLogger <span class="hljs-title">log</span><span class="hljs-params">(Object a)</span></span>{ System.err.println(a); <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今のところ、このプログラムは私たちが持っているすべてのものであり、コードの他の部分がそれを呼び出すものではないと仮定します。</font><font style="vertical-align: inherit;">単純ににデータを入力して</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行し、結果を返します。</font><font style="vertical-align: inherit;">では、このプログラムを最適化しましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化の例</font></font></h2><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型キャストとインライン化</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数の</font></font><code>logger</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">不正確</font><font style="vertical-align: inherit;">であることに気づいたかもしれません。</font><font style="vertical-align: inherit;">ラベル</font></font><code>Logger</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">かかわらず</font><font style="vertical-align: inherit;">、コードに基づいて、これは特定のサブクラスであると結論付けることができます- </font></font><code>PrintLogger</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="java hljs">-  Logger logger = <span class="hljs-keyword">new</span> PrintLogger();<font></font>
+  PrintLogger logger = <span class="hljs-keyword">new</span> PrintLogger();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで何</font></font><code>logger</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">である</font><font style="vertical-align: inherit;">か</font><font style="vertical-align: inherit;">が</font></font><code>PrintLogger</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">わかりました。また、呼び出し</font></font><code>logger.log</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は単一の実装を持つことができることが</font><font style="vertical-align: inherit;">わかりました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">インライン化できます：</font></font><br>
<br>
<pre><code class="java hljs">-    <span class="hljs-keyword">if</span> (multiplied &lt; <span class="hljs-number">100</span>) logger.logcount();<font></font>
+    <span class="hljs-keyword">if</span> (multiplied &lt; <span class="hljs-number">100</span>) System.out.println(count);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、</font></font><code>ErrLogger</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用されていない</font><font style="vertical-align: inherit;">不要なクラス</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">削除</font><font style="vertical-align: inherit;">されるだけでなく、さまざまなメソッドが削除</font><font style="vertical-align: inherit;">されるため、プログラムが削減</font><font style="vertical-align: inherit;">され</font></font><code>public Logger</code> <code>log</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これは、呼び出しの1か所にインライン化するためです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凝固定数</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムの実行中に、</font></font><code>count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらは</font></font><code>total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変化しますが、変化し</font></font><code>multiplied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません。それは、から始まり、</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からまで毎回乗算され</font></font><code>multiplied = multiplied * count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、等しくなり</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">したがって、プログラム全体で次のように置き換えることができます</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{<font></font>
-  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, total = <span class="hljs-number">0</span>, multiplied = <span class="hljs-number">0</span>;<font></font>
+  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, total = <span class="hljs-number">0</span>;<font></font>
   PrintLogger logger = <span class="hljs-keyword">new</span> PrintLogger();
   <span class="hljs-keyword">while</span>(count &lt; n){<font></font>
     count += <span class="hljs-number">1</span>;<font></font>
-     multiplied *= count;<font></font>
-    <span class="hljs-keyword">if</span> (multiplied &lt; <span class="hljs-number">100</span>) System.out.println(count);<font></font>
+    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt; <span class="hljs-number">100</span>) logger.log(count);<font></font>
     total += ackermann(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<font></font>
-    total += ackermann(multiplied, n);<font></font>
+    total += ackermann(<span class="hljs-number">0</span>, n);
     <span class="hljs-keyword">int</span> d1 = ackermann(n, <span class="hljs-number">1</span>);<font></font>
-     total += d1 * multiplied;<font></font>
     <span class="hljs-keyword">int</span> d2 = ackermann(n, count);
     <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) total += d2;<font></font>
   }<font></font>
   <span class="hljs-keyword">return</span> total;<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、</font></font><code>d1 * multiplied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常に等しいことが</font><font style="vertical-align: inherit;">わかります。つまり</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>total += d1 * multiplied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何も実行せず、削除できるということです。</font></font><br>
<br>
<pre><code class="java hljs">-    total += d1 * multiplied
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドコードの除去</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
折りたたん</font></font><code>multiplied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font><code>total += d1 * multiplied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何もしないこと</font><font style="vertical-align: inherit;">を認識し</font><font style="vertical-align: inherit;">たら、定義を削除できます</font></font><code>int d1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs">-     <span class="hljs-keyword">int</span> d1 = ackermann(n, <span class="hljs-number">1</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはプログラムの一部ではなくなり</font></font><code>ackermann</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、純粋な機能であるため、削除してもプログラムの結果には影響しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、インライン化後</font></font><code>logger.log</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>logger</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用されなくなり、削除できます。</font></font><br>
<br>
<pre><code class="java hljs">-   PrintLogger logger = <span class="hljs-keyword">new</span> PrintLogger();
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブランチの削除</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、サイクルの最初の条件付き遷移はに依存し</font></font><code>0 &lt; 100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これは常に当てはまるので、単純に条件を削除できます。</font></font><br>
<br>
<pre><code class="java hljs">- <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt; <span class="hljs-number">100</span>) System.out.println(count);<font></font>
+ System.out.println(count);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
常に真である条件付き遷移は、条件の本体にインライン化できます。また、常に正しくない遷移の場合は、本体とともに条件を削除できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分計算</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、残りの3つの呼び出しを分析します</font></font><code>ackermann</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs">   total += ackermann(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<font></font>
    total += ackermann(<span class="hljs-number">0</span>, n);
    <span class="hljs-keyword">int</span> d2 = ackermann(n, count);
</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の引数には2つの定数引数があります。</font><font style="vertical-align: inherit;">関数は純粋であり、予備計算で</font></font><code>ackermann(2, 2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は等しいはずです</font></font><code>7.</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の呼び出しには、1つの定数引数</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と1つの不明</font><font style="vertical-align: inherit;">引数が</font><font style="vertical-align: inherit;">あり</font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">あなたはそれを定義に渡すことができます</font></font><code>ackermann</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そしてそれ</font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が等しい</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とき、関数は常に戻る</font><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">がわかり</font><font style="vertical-align: inherit;">ます</font></font><code>n + 1.</code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三控訴では、両方の引数は不明である：</font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">とりあえず、そのままにしておきましょう。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
へのアピールが</font></font><code>ackermann</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のように定義され</font><font style="vertical-align: inherit;">ていると仮定し</font><font style="vertical-align: inherit;">ます：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ackermann</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ackermann(m - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ackermann(m - <span class="hljs-number">1</span>, ackermann(m, n - <span class="hljs-number">1</span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のように簡略化できます。</font></font><br>
<br>
<pre><code class="java hljs">-    total += ackermann(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<font></font>
+    total += <span class="hljs-number">7</span>
-    total += ackermann(<span class="hljs-number">0</span>, n);<font></font>
+    total += n + <span class="hljs-number">1</span>
     <span class="hljs-keyword">int</span> d2 = ackermann(n, count);
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅いスケジューリング</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定義は</font></font><code>d2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件付きブランチでのみ使用され</font></font><code>if (count % 2 == 0)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">計算</font></font><code>ackermann</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はクリーンな</font><font style="vertical-align: inherit;">ので、</font><font style="vertical-align: inherit;">この呼び出しを条件分岐に転送して、使用されるまで処理されないようにすることができます。</font></font><br>
<br>
<pre><code class="java hljs">-    <span class="hljs-keyword">int</span> d2 = ackermann(n, count);<font></font>
-    <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) total += d2;<font></font>
+    <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {<font></font>
+      <span class="hljs-keyword">int</span> d2 = ackermann(n, count);<font></font>
+      total += d2;<font></font>
+    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、への呼び出しの半分が回避され</font></font><code>ackermann(n, count)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、プログラムの実行が加速されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較すると、関数は</font></font><code>System.out.println</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">純粋で</font><font style="vertical-align: inherit;">はあり</font><font style="vertical-align: inherit;">ません。つまり、プログラムのセマンティクスを変更しない限り、条件付き遷移の内部または外部に</font><font style="vertical-align: inherit;">関数を</font><font style="vertical-align: inherit;">転送することはできません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化された結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての最適化を収集したら、次のソースコードを取得します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, total = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(count &lt; n){<font></font>
    count += <span class="hljs-number">1</span>;<font></font>
    System.out.println(count);<font></font>
    total += <span class="hljs-number">7</span>;<font></font>
    total += n + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {<font></font>
      total += d2;<font></font>
      <span class="hljs-keyword">int</span> d2 = ackermann(n, count);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> total;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ackermann</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ackermann(m - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ackermann(m - <span class="hljs-number">1</span>, ackermann(m, n - <span class="hljs-number">1</span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手動で最適化しましたが、これらはすべて自動的に行うことができます。</font><font style="vertical-align: inherit;">以下は、JVMプログラム用に作成したプロトタイプオプティマイザーの逆コンパイル結果です。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var0)</span> </span>{
  <span class="hljs-keyword">new</span> Demo.PrintLogger();
  <span class="hljs-keyword">int</span> var1 = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> var3;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var2 = <span class="hljs-number">0</span>; var2 &lt; var0; var2 = var3) {<font></font>
    System.out.println(var3 = <span class="hljs-number">1</span> + var2);
    <span class="hljs-keyword">int</span> var10000 = var3 % <span class="hljs-number">2</span>;
    <span class="hljs-keyword">int</span> var7 = var1 + <span class="hljs-number">7</span> + var0 + <span class="hljs-number">1</span>;<font></font>
    var1 = var10000 == <span class="hljs-number">0</span> ? var7 + ackermann(var0, var3) : var7;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> var1;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ackermann__I__TI1__I</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var0)</span> </span>{
  <span class="hljs-keyword">if</span> (var0 == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ackermann(var0 - <span class="hljs-number">1</span>, var0 == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : ackermann__I__TI1__I(var0 - <span class="hljs-number">1</span>););<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ackermann</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var0, <span class="hljs-keyword">int</span> var1)</span> </span>{
  <span class="hljs-keyword">if</span> (var0 == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> var1 + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> var1 == <span class="hljs-number">0</span> ? ackermann__I__TI1__I(var0 - <span class="hljs-number">1</span>) : ackermann(var0 - <span class="hljs-number">1</span>, ackermann(var0, var1 - <span class="hljs-number">1</span>));<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Demo</span>.<span class="hljs-title">Logger</span> </span>{}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Logger</span> </span>{}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
逆コンパイルされたコードは、手動で最適化されたバージョンとは少し異なります。</font><font style="vertical-align: inherit;">コンパイラーが最適化できなかったもの（たとえば、未使用の呼び出し</font></font><code>new PrintLogger</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）が、少し異なる方法で実行されました（たとえば、分離された</font></font><code>ackermann</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>ackermann__I__TI1__I</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">しかし、残りの部分では、自動オプティマイザは、埋め込まれているロジックを使用して、私と同じことを行いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題が発生します：どのように？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中間ビュー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
独自のオプティマイザを作成しようとする場合、最初に発生する質問はおそらく最も重要です。「プログラム」とは何ですか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確かに、ソースコードとしてプログラムを作成および変更することに慣れています。</font><font style="vertical-align: inherit;">あなたは間違いなくコンパイルされたバイナリの形でそれらを実行しました、おそらくバイナリをデバッグしました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文ツリー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3アドレスコード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A-Normal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継続渡しスタイル、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一の静的割り当て</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の形式でプログラムに遭遇した可能性があり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムのさまざまな表現の全体の動物園があります。</font><font style="vertical-align: inherit;">ここでは、オプティマイザ内の「プログラム」を表す最も重要な方法について説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース</font></font></h2><br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ackermann</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ackermann(m - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ackermann(m - <span class="hljs-number">1</span>, ackermann(m, n - <span class="hljs-number">1</span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイルされていないソースコードもプログラムの表現です。</font><font style="vertical-align: inherit;">比較的コンパクトで人間が読める形式ですが、次の2つの欠点があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコードには、名前とフォーマットの詳細がすべて含まれています。これは、プログラマにとっては重要ですが、コンピュータにとっては役に立ちません。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正しいものよりも、ソースコードの形式のエラーの多いプログラムの方が多く、最適化中に、プログラムが正しい入力ソースコードから正しい出力ソースコードに変換されていることを確認する必要があります。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの要因により、オプティマイザがプログラムをソースコードの形式で処理することが困難になります。</font><font style="vertical-align: inherit;">はい、</font><font style="vertical-align: inherit;">そのようなプログラム</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換</font><i><font style="vertical-align: inherit;">でき</font></i><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正規表現を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用してパターン</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">を</font></a><font style="vertical-align: inherit;">識別および置換できます。</font><font style="vertical-align: inherit;">ただし、2つの要因のうち最初の要因により、無関係な詳細が豊富にあるパターンを確実に特定することが困難になります。</font><font style="vertical-align: inherit;">そして、2番目の要因は、混乱して誤った結果のプログラムを取得する可能性を大幅に高めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの制限は、たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codemod</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用し</font><font style="vertical-align: inherit;">てコードベースをリファクタリングおよび変換</font><font style="vertical-align: inherit;">できる場合など、人間の監視下で実行されるプログラムコンバーターでは許容されます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、ソースコードを自動オプティマイザの主要モデルとして使用することはできません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象構文木</font></font></h2><br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ackermann</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ackermann(m - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ackermann(m - <span class="hljs-number">1</span>, ackermann(m, n - <span class="hljs-number">1</span>));<font></font>
}<font></font>
<font></font>
IfElse(<font></font>
    cond = BinOp(Ident(<span class="hljs-string">"m"</span>), <span class="hljs-string">"="</span>, Literal(<span class="hljs-number">0</span>)),<font></font>
    then = Return(BinOp(Ident(<span class="hljs-string">"n"</span>), <span class="hljs-string">"+"</span>, Literal(<span class="hljs-number">1</span>)),
    <span class="hljs-keyword">else</span> = IfElse(<font></font>
        cond = BinOp(Ident(<span class="hljs-string">"n"</span>), <span class="hljs-string">"="</span>, Literal(<span class="hljs-number">0</span>)),<font></font>
        then = Return(Call(<span class="hljs-string">"ackermann"</span>, BinOp(Ident(<span class="hljs-string">"m"</span>), <span class="hljs-string">"-"</span>, Literal(<span class="hljs-number">1</span>)), Literal(<span class="hljs-number">1</span>)),
        <span class="hljs-keyword">else</span> = Return(<font></font>
            Call(<font></font>
                <span class="hljs-string">"ackermann"</span>,<font></font>
                BinOp(Ident(<span class="hljs-string">"m"</span>), <span class="hljs-string">"-"</span>, Literal(<span class="hljs-number">1</span>)),<font></font>
                Call(<span class="hljs-string">"ackermann"</span>, Ident(<span class="hljs-string">"m"</span>), BinOp(Ident(<span class="hljs-string">"n"</span>), <span class="hljs-string">"-"</span>, Literal(<span class="hljs-number">1</span>)))<font></font>
            )<font></font>
        )<font></font>
    )<font></font>
)<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/e01/019/324/e0101932411807ddb7abb9c120033f58.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
抽象構文木（AST）は、もう1つの一般的な中間形式です。これらは、ソースコードと比較して、抽象化ラダーの次のステップにあります。通常、ASTはすべてのソースコードのフォーマット、インデント、コメントを破棄しますが、より抽象的な表現で破棄されたローカル変数の名前は保持します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースコードと同様に、ASTはプログラムの実際のセマンティクスに影響を与えない不要な情報をエンコードする可能性があります。たとえば、次の2つのコードフラグメントは、意味的に同一です。ローカル変数の名前のみが異なりますが、ASTは異なります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ackermannA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">int</span> p = n;
  <span class="hljs-keyword">int</span> q = m;
  <span class="hljs-keyword">if</span> (q == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> p + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ackermannA(q - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ackermannA(q - <span class="hljs-number">1</span>, ackermannA(q, p - <span class="hljs-number">1</span>));<font></font>
}<font></font>
Block(<font></font>
    Assign(<span class="hljs-string">"p"</span>, Ident(<span class="hljs-string">"n"</span>)),<font></font>
    Assign(<span class="hljs-string">"q"</span>, Ident(<span class="hljs-string">"m"</span>)),<font></font>
    IfElse(<font></font>
        cond = BinOp(Ident(<span class="hljs-string">"q"</span>), <span class="hljs-string">"=="</span>, Literal(<span class="hljs-number">0</span>)),<font></font>
        then = Return(BinOp(Ident(<span class="hljs-string">"p"</span>), <span class="hljs-string">"+"</span>, Literal(<span class="hljs-number">1</span>)),
        <span class="hljs-keyword">else</span> = IfElse(<font></font>
            cond = BinOp(Ident(<span class="hljs-string">"p"</span>), <span class="hljs-string">"=="</span>, Literal(<span class="hljs-number">0</span>)),<font></font>
            then = Return(Call(<span class="hljs-string">"ackermann"</span>, BinOp(Ident(<span class="hljs-string">"q"</span>), <span class="hljs-string">"-"</span>, Literal(<span class="hljs-number">1</span>)), Literal(<span class="hljs-number">1</span>)),
            <span class="hljs-keyword">else</span> = Return(<font></font>
                Call(<font></font>
                    <span class="hljs-string">"ackermann"</span>,<font></font>
                    BinOp(Ident(<span class="hljs-string">"q"</span>), <span class="hljs-string">"-"</span>, Literal(<span class="hljs-number">1</span>)),<font></font>
                    Call(<span class="hljs-string">"ackermann"</span>, Ident(<span class="hljs-string">"q"</span>), BinOp(Ident(<span class="hljs-string">"p"</span>), <span class="hljs-string">"-"</span>, Literal(<span class="hljs-number">1</span>)))<font></font>
                )<font></font>
            )<font></font>
        )<font></font>
    )<font></font>
)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ackermannB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">int</span> r = n;
  <span class="hljs-keyword">int</span> s = m;
  <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ackermannB(s - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ackermannB(s - <span class="hljs-number">1</span>, ackermannB(s, r - <span class="hljs-number">1</span>));<font></font>
}<font></font>
Block(<font></font>
    Assign(<span class="hljs-string">"r"</span>, Ident(<span class="hljs-string">"n"</span>)),<font></font>
    Assign(<span class="hljs-string">"s"</span>, Ident(<span class="hljs-string">"m"</span>)),<font></font>
    IfElse(<font></font>
        cond = BinOp(Ident(<span class="hljs-string">"s"</span>), <span class="hljs-string">"=="</span>, Literal(<span class="hljs-number">0</span>)),<font></font>
        then = Return(BinOp(Ident(<span class="hljs-string">"r"</span>), <span class="hljs-string">"+"</span>, Literal(<span class="hljs-number">1</span>)),
        <span class="hljs-keyword">else</span> = IfElse(<font></font>
            cond = BinOp(Ident(<span class="hljs-string">"r"</span>), <span class="hljs-string">"=="</span>, Literal(<span class="hljs-number">0</span>)),<font></font>
            then = Return(Call(<span class="hljs-string">"ackermann"</span>, BinOp(Ident(<span class="hljs-string">"s"</span>), <span class="hljs-string">"-"</span>, Literal(<span class="hljs-number">1</span>)), Literal(<span class="hljs-number">1</span>)),
            <span class="hljs-keyword">else</span> = Return(<font></font>
                Call(<font></font>
                    <span class="hljs-string">"ackermann"</span>,<font></font>
                    BinOp(Ident(<span class="hljs-string">"s"</span>), <span class="hljs-string">"-"</span>, Literal(<span class="hljs-number">1</span>)),<font></font>
                    Call(<span class="hljs-string">"ackermann"</span>, Ident(<span class="hljs-string">"s"</span>), BinOp(Ident(<span class="hljs-string">"r"</span>), <span class="hljs-string">"-"</span>, Literal(<span class="hljs-number">1</span>)))<font></font>
                )<font></font>
            )<font></font>
        )<font></font>
    )<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要な点は、ASTにはツリー構造がありますが、意味的にはツリーのように動作しないノードが含まれていることです。値</font></font><code>Ident("r")</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とは</font></font><code>Ident("s")</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、サブツリーの内容ではなく、上流のノード</font></font><code>Assign("r", ...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">によって決定されます</font></font><code>Assign("s", ...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">実際、</font></font><code>Ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>Assign</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">間に</font><font style="vertical-align: inherit;">追加のセマンティック接続があり、これはASTツリー構造のエッジと同じくらい重要です。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a17/62a/9a0/a1762a9a0a21d0b0e4fac6afb4f23335.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのリンクは、関数の再帰的な定義が存在する場合のサイクルを含む一般化されたグラフ構造を形成します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイトコード</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaをメイン言語として選択したので、コンパイルされたプログラムはJavaバイトコードとして.classファイルに保存されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの機能を思い出してください</font></font><code>ackermann</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ackermann</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ackermann(m - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ackermann(m - <span class="hljs-number">1</span>, ackermann(m, n - <span class="hljs-number">1</span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはこのバイトコードにコンパイルされます：</font></font><br>
<br>
<pre><code class="java hljs">  <span class="hljs-number">0</span>: iload_0
   <span class="hljs-number">1</span>: ifne          <span class="hljs-number">8</span>
   <span class="hljs-number">4</span>: iload_1
   <span class="hljs-number">5</span>: iconst_1
   <span class="hljs-number">6</span>: iadd
   <span class="hljs-number">7</span>: ireturn
   <span class="hljs-number">8</span>: iload_1
   <span class="hljs-number">9</span>: ifne          <span class="hljs-number">20</span>
  <span class="hljs-number">12</span>: iload_0
  <span class="hljs-number">13</span>: iconst_1
  <span class="hljs-number">14</span>: isub
  <span class="hljs-number">15</span>: iconst_1
  <span class="hljs-number">16</span>: invokestatic ackermann:(II)I
  <span class="hljs-number">19</span>: ireturn
  <span class="hljs-number">20</span>: iload_0
  <span class="hljs-number">21</span>: iconst_1
  <span class="hljs-number">22</span>: isub
  <span class="hljs-number">23</span>: iload_0
  <span class="hljs-number">24</span>: iload_1
  <span class="hljs-number">25</span>: iconst_1
  <span class="hljs-number">26</span>: isub
  <span class="hljs-number">27</span>: invokestatic ackermann:(II)I
  <span class="hljs-number">30</span>: invokestatic ackermann:(II)I
  <span class="hljs-number">33</span>: ireturn</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaバイトコードを実行するJava仮想マシン（JVM）は、スタックとレジスタを組み合わせたマシンです。値が操作されるオペランドスタック（STACK）と、これらの値を格納できるローカル変数の配列（LOCALS）があります。関数は、ローカル変数の最初のNスロットのNパラメーターから始まります。関数が実行されると、関数はデータをスタックに移動して操作し、それらを変数</font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に戻し、オペランドスタックから呼び出し元を呼び出して値を返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のバイトコードに注釈を付けて、スタックとローカル変数テーブルの間を移動する値を表すと、次のようになります。</font></font><br>
<br>
<pre><code class="java hljs"> BYTECODE                                LOCALS          STACK<font></font>
                                          |a0|a1|         |<font></font>
   <span class="hljs-number">0</span>: iload_0                             |a0|a1|         |a0|
   <span class="hljs-number">1</span>: ifne          <span class="hljs-number">8</span>                     |a0|a1|         |
   <span class="hljs-number">4</span>: iload_1                             |a0|a1|         |a1|
   <span class="hljs-number">5</span>: iconst_1                            |a0|a1|         |a1| <span class="hljs-number">1</span>|
   <span class="hljs-number">6</span>: iadd                                |a0|a1|         |v1|
   <span class="hljs-number">7</span>: ireturn                             |a0|a1|         |
   <span class="hljs-number">8</span>: iload_1                             |a0|a1|         |a1|
   <span class="hljs-number">9</span>: ifne          <span class="hljs-number">20</span>                    |a0|a1|         |
  <span class="hljs-number">12</span>: iload_0                             |a0|a1|         |a0|
  <span class="hljs-number">13</span>: iconst_1                            |a0|a1|         |a0| <span class="hljs-number">1</span>|
  <span class="hljs-number">14</span>: isub                                |a0|a1|         |v2|
  <span class="hljs-number">15</span>: iconst_1                            |a0|a1|         |v2| <span class="hljs-number">1</span>|
  <span class="hljs-number">16</span>: invokestatic ackermann:(II)I        |a0|a1|         |v3|
  <span class="hljs-number">19</span>: ireturn                             |a0|a1|         |
  <span class="hljs-number">20</span>: iload_0                             |a0|a1|         |a0|
  <span class="hljs-number">21</span>: iconst_1                            |a0|a1|         |a0| <span class="hljs-number">1</span>|
  <span class="hljs-number">22</span>: isub                                |a0|a1|         |v4|
  <span class="hljs-number">23</span>: iload_0                             |a0|a1|         |v4|a0|
  <span class="hljs-number">24</span>: iload_1                             |a0|a1|         |v4|a0|a1|
  <span class="hljs-number">25</span>: iconst_1                            |a0|a1|         |v4|a0|a1| <span class="hljs-number">1</span>|
  <span class="hljs-number">26</span>: isub                                |a0|a1|         |v4|a0|v5|
  <span class="hljs-number">27</span>: invokestatic ackermann:(II)I        |a0|a1|         |v4|v6|
  <span class="hljs-number">30</span>: invokestatic ackermann:(II)I        |a0|a1|         |v7|
  <span class="hljs-number">33</span>: ireturn                             |a0|a1|         |</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、の助けを借りて</font><font style="vertical-align: inherit;">、関数の最初のLOCALSテーブルに格納されている関数の引数</font></font><code>a0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font><code>a1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示しました。</font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数はスルーロード表し</font></font><code>iconst_1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、およびから</font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font></font><code>v7</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、中間値を計算しました。ここでは3つの命令です</font></font><code>ireturn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">戻っては</font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>v7</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この関数は他のローカル変数を定義しないため、LOCALS配列は入力引数のみを格納します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記では、関数に2つのオプションがありました- </font></font><code>ackermannA</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>ackermannB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。だから彼らはバイトコードを見る：</font></font><br>
<br>
<pre><code class="java hljs"> BYTECODE                                LOCALS          STACK<font></font>
                                          |a0|a1|         |<font></font>
   <span class="hljs-number">0</span>: iload_1                             |a0|a1|         |a1|
   <span class="hljs-number">1</span>: istore_2                            |a0|a1|a1|      |
   <span class="hljs-number">2</span>: iload_0                             |a0|a1|a1|      |a0|
   <span class="hljs-number">3</span>: istore_3                            |a0|a1|a1|a0|   |
   <span class="hljs-number">4</span>: iload_3                             |a0|a1|a1|a0|   |a0|
   <span class="hljs-number">5</span>: ifne          <span class="hljs-number">12</span>                    |a0|a1|a1|a0|   |
   <span class="hljs-number">8</span>: iload_2                             |a0|a1|a1|a0|   |a1|
   <span class="hljs-number">9</span>: iconst_1                            |a0|a1|a1|a0|   |a1| <span class="hljs-number">1</span>|
  <span class="hljs-number">10</span>: iadd                                |a0|a1|a1|a0|   |v1|
  <span class="hljs-number">11</span>: ireturn                             |a0|a1|a1|a0|   |
  <span class="hljs-number">12</span>: iload_2                             |a0|a1|a1|a0|   |a1|
  <span class="hljs-number">13</span>: ifne          <span class="hljs-number">24</span>                    |a0|a1|a1|a0|   |
  <span class="hljs-number">16</span>: iload_3                             |a0|a1|a1|a0|   |a0|
  <span class="hljs-number">17</span>: iconst_1                            |a0|a1|a1|a0|   |a0| <span class="hljs-number">1</span>|
  <span class="hljs-number">18</span>: isub                                |a0|a1|a1|a0|   |v2|
  <span class="hljs-number">19</span>: iconst_1                            |a0|a1|a1|a0|   |v2| <span class="hljs-number">1</span>|
  <span class="hljs-number">20</span>: invokestatic ackermannA:(II)I       |a0|a1|a1|a0|   |v3|
  <span class="hljs-number">23</span>: ireturn                             |a0|a1|a1|a0|   |
  <span class="hljs-number">24</span>: iload_3                             |a0|a1|a1|a0|   |a0|
  <span class="hljs-number">25</span>: iconst_1                            |a0|a1|a1|a0|   |a0| <span class="hljs-number">1</span>|
  <span class="hljs-number">26</span>: isub                                |a0|a1|a1|a0|   |v4|
  <span class="hljs-number">27</span>: iload_3                             |a0|a1|a1|a0|   |v4|a0|
  <span class="hljs-number">28</span>: iload_2                             |a0|a1|a1|a0|   |v4|a0|a1|
  <span class="hljs-number">29</span>: iconst_1                            |a0|a1|a1|a0|   |v4|a0|a1| <span class="hljs-number">1</span>|
  <span class="hljs-number">30</span>: isub                                |a0|a1|a1|a0|   |v4|a0|v5|
  <span class="hljs-number">31</span>: invokestatic ackermannA:(II)I       |a0|a1|a1|a0|   |v4|v6|
  <span class="hljs-number">34</span>: invokestatic ackermannA:(II)I       |a0|a1|a1|a0|   |v7|
  <span class="hljs-number">37</span>: ireturn                             |a0|a1|a1|a0|   |</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースコードは2つの引数を取り、それらをローカル変数に入れるため、バイトコードには、LOCALインデックス0および1から引数値をロードし、インデックス2および3の下に保存するための対応する指示があります。ただし、バイトコードはローカル変数の名前には関係ありません。 LOCALS配列のインデックスと同様に、それらによって排他的に。したがって、</font></font><code>ackermannA</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font><code>ackermannB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は同じバイトコードになります。これらは意味的に同等であるため、これは論理的です！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、</font><font style="vertical-align: inherit;">元のバイトコードと同じバイトコードにコンパイルされるわけ</font></font><code>ackermannA</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font><code>ackermannB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はありません。</font></font><code>ackermann</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイトコードはローカル変数の名前から抽象化されていますが、これらの変数のロードと保存から完全に抽象化されているわけではありません。値がLOCALSとSTACKに沿ってどのように移動するかは、プログラムの実際の動作には影響しませんが、それでも重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロード/保存からの抽象化の欠如に加えて、バイトコードには別の欠点があります：ほとんどの線形アセンブラーのように、それはコンパクトさの点で非常に最適化されており、最適化に関してそれを変更することは非常に難しい場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より明確にするために、元の関数のバイトコードを見てみましょう</font></font><code>ackermann</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="java hljs"> BYTECODE                                LOCALS          STACK<font></font>
                                          |a0|a1|         |<font></font>
   <span class="hljs-number">0</span>: iload_0                             |a0|a1|         |a0|
   <span class="hljs-number">1</span>: ifne          <span class="hljs-number">8</span>                     |a0|a1|         |
   <span class="hljs-number">4</span>: iload_1                             |a0|a1|         |a1|
   <span class="hljs-number">5</span>: iconst_1                            |a0|a1|         |a1| <span class="hljs-number">1</span>|
   <span class="hljs-number">6</span>: iadd                                |a0|a1|         |v1|
   <span class="hljs-number">7</span>: ireturn                             |a0|a1|         |
   <span class="hljs-number">8</span>: iload_1                             |a0|a1|         |a1|
   <span class="hljs-number">9</span>: ifne          <span class="hljs-number">20</span>                    |a0|a1|         |
  <span class="hljs-number">12</span>: iload_0                             |a0|a1|         |a0|
  <span class="hljs-number">13</span>: iconst_1                            |a0|a1|         |a0| <span class="hljs-number">1</span>|
  <span class="hljs-number">14</span>: isub                                |a0|a1|         |v2|
  <span class="hljs-number">15</span>: iconst_1                            |a0|a1|         |v2| <span class="hljs-number">1</span>|
  <span class="hljs-number">16</span>: invokestatic ackermann:(II)I        |a0|a1|         |v3|
  <span class="hljs-number">19</span>: ireturn                             |a0|a1|         |
  <span class="hljs-number">20</span>: iload_0                             |a0|a1|         |a0|
  <span class="hljs-number">21</span>: iconst_1                            |a0|a1|         |a0| <span class="hljs-number">1</span>|
  <span class="hljs-number">22</span>: isub                                |a0|a1|         |v4|
  <span class="hljs-number">23</span>: iload_0                             |a0|a1|         |v4|a0|
  <span class="hljs-number">24</span>: iload_1                             |a0|a1|         |v4|a0|a1|
  <span class="hljs-number">25</span>: iconst_1                            |a0|a1|         |v4|a0|a1| <span class="hljs-number">1</span>|
  <span class="hljs-number">26</span>: isub                                |a0|a1|         |v4|a0|v5|
  <span class="hljs-number">27</span>: invokestatic ackermann:(II)I        |a0|a1|         |v4|v6|
  <span class="hljs-number">30</span>: invokestatic ackermann:(II)I        |a0|a1|         |v7|
  <span class="hljs-number">33</span>: ireturn                             |a0|a1|         |</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大まかな変更を加えましょう。関数呼び出しで</font></font><code>30: invokestatic ackermann:(II)I</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の引数を使用しないようにします。そして、この呼び出しは</font></font><code>30: invokestatic ackermann2:(I)I</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、引数を1つだけ取る</font><font style="vertical-align: inherit;">同等の呼び出し</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">置き換えることができ</font><font style="vertical-align: inherit;">ます。これは一般的な最適化であり、「デッドコードを破棄」して、最初の引数の計算に使用されるコードを破棄できます</font></font><code>30: invokestatic ackermann:(II)I</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、命令を置き換えるだけでなく、命令</font></font><code>30</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のリストを見て、最初の引数（</font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>STACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）が</font><font style="vertical-align: inherit;">計算される場所を理解し、</font><font style="vertical-align: inherit;">それを削除する必要もあります。私たちは、命令から復帰</font></font><code>30</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font></font><code>22</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から、と</font></font><code>22</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font></font><code>21</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>20</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。最終バージョン：</font></font><br>
<br>
<pre><code class="java hljs"> BYTECODE                                LOCALS          STACK<font></font>
                                          |a0|a1|         |<font></font>
   <span class="hljs-number">0</span>: iload_0                             |a0|a1|         |a0|
   <span class="hljs-number">1</span>: ifne          <span class="hljs-number">8</span>                     |a0|a1|         |
   <span class="hljs-number">4</span>: iload_1                             |a0|a1|         |a1|
   <span class="hljs-number">5</span>: iconst_1                            |a0|a1|         |a1| <span class="hljs-number">1</span>|
   <span class="hljs-number">6</span>: iadd                                |a0|a1|         |v1|
   <span class="hljs-number">7</span>: ireturn                             |a0|a1|         |
   <span class="hljs-number">8</span>: iload_1                             |a0|a1|         |a1|
   <span class="hljs-number">9</span>: ifne          <span class="hljs-number">20</span>                    |a0|a1|         |
  <span class="hljs-number">12</span>: iload_0                             |a0|a1|         |a0|
  <span class="hljs-number">13</span>: iconst_1                            |a0|a1|         |a0| <span class="hljs-number">1</span>|
  <span class="hljs-number">14</span>: isub                                |a0|a1|         |v2|
  <span class="hljs-number">15</span>: iconst_1                            |a0|a1|         |v2| <span class="hljs-number">1</span>|
  <span class="hljs-number">16</span>: invokestatic ackermann:(II)I        |a0|a1|         |v3|
  <span class="hljs-number">19</span>: ireturn                             |a0|a1|         |<font></font>
- <span class="hljs-number">20</span>: iload_0                             |a0|a1|         |<font></font>
- <span class="hljs-number">21</span>: iconst_1                            |a0|a1|         |<font></font>
- <span class="hljs-number">22</span>: isub                                |a0|a1|         |
  <span class="hljs-number">23</span>: iload_0                             |a0|a1|         |a0|
  <span class="hljs-number">24</span>: iload_1                             |a0|a1|         |a0|a1|
  <span class="hljs-number">25</span>: iconst_1                            |a0|a1|         |a0|a1| <span class="hljs-number">1</span>|
  <span class="hljs-number">26</span>: isub                                |a0|a1|         |a0|v5|
  <span class="hljs-number">27</span>: invokestatic ackermann:(II)I        |a0|a1|         |v6|<font></font>
- <span class="hljs-number">30</span>: invokestatic ackermann:(II)I        |a0|a1|         |v7|<font></font>
+ <span class="hljs-number">30</span>: invokestatic ackermann2:(I)I        |a0|a1|         |v7|
  <span class="hljs-number">33</span>: ireturn                             |a0|a1|         |</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純な関数で、このような単純な変更を行うことができます</font></font><code>ackermann</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。しかし、実際のプロジェクトで使用される大規模な関数では、相互に関連する多数の変更を行うことははるかに困難になります。一般に、プログラムの小さな意味上の変更には、バイトコード全体で多数の変更が必要になる場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我々はそれがされたかを見て：あなたは、私たちは変更がLOCALSとSTACKの値を分析し、上記なさことに気づいたかもしれ</font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令に転送</font></font><code>30</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令から</font></font><code>22</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、と</font></font><code>22</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にデータを取り</font></font><code>a0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指示から来ている</font></font><code>21</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>20</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これらの値は、グラフの原則に従って、LOCALSとSTACKの間で転送されます。値を計算する命令から、さらに使用する場所までです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カップルのように</font></font><code>Ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>Assign</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちのASTでは、LOCALSとSTACKの間で渡される値は、値の計算のポイントとそれらの使用のポイントの間のグラフを形成します。</font><font style="vertical-align: inherit;">それでは、なぜグラフを直接操作しないのでしょうか。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データフローグラフ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データフローグラフは、バイトコードの後の次のレベルの抽象化です。</font></font><code>Ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>Assign</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">構文ツリーを展開する場合</font><font style="vertical-align: inherit;">、またはバイトコードがLOCALSとSTACKの間で値を移動する方法を追跡する場合は、グラフを作成できます。関数の場合、</font></font><code>ackermann</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは次のよう</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">なります</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5ad/217/5f7/5ad2175f73cf13fa7e47fb521a9aab1a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。ASTまたはJavaスタックバイトコードバイトコードとは異なり、データフローグラフは「ローカル変数」の概念を使用しません。代わりに、グラフには各値とそれが使用される場所の間の直接接続が含まれます。バイトコードを分析する場合、値がどのように移動するかを理解するために、LOCALSとSTACKを抽象的に解釈する必要があることがよくあります。 AST分析には、ツリーの追跡とリンクを含むシンボルテーブルの操作が含まれます</font></font><code>Assign</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>Ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;多くの場合、データフローグラフの分析は、遷移を直接追跡することです。つまり、プログラムを提示するという手間をかけずに、「値を移動する」という純粋なアイデアです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフは線形バイトコードよりも操作が簡単</font><font style="vertical-align: inherit;">です。引数の1つを</font></font><code>ackermann</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出し</font></font><code>ackermann2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て破棄</font><font style="vertical-align: inherit;">することで</font><font style="vertical-align: inherit;">ノードを呼び出しに置き換える</font><font style="vertical-align: inherit;">と、グラフのノード（緑でマーク）が変更され、ノードのある通過リンク（赤でマーク）とともに入力リンクの1つが削除され</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b70/c2d/90d/b70c2d90d886bd7c90cdfbb3cb03b42d.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます</font><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">ご覧のとおり、プログラムの小さな変化（置換</font></font><code>ackermann(int n, int m)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用</font></font><code>ackermann2(int m)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データのグラフで比較的局在変化に変わる）が流れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、グラフの操作は、線形バイトコードやASTを使用するよりもはるかに簡単です。グラフの分析や変更は簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このグラフの説明には多くの詳細はありません。グラフの実際の物理的表現に加えて、状態とフロー制御をモデル化する方法は他にもたくさんあります。これらの方法は、記事の範囲を超えて作業するのがより困難です。</font><font style="vertical-align: inherit;">また、グラフの変換に関する多くの詳細、たとえば、リンクの追加と削除、順方向と逆方向の遷移、水平方向と垂直方向の遷移（幅と深さ）などについても省略しました。アルゴリズムを研究した場合、これはすべておなじみのはずです。 。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、線形バイトコードからグラフへの変換アルゴリズム、次にグラフからバイトコードへの変換アルゴリズムを省略しました。</font><font style="vertical-align: inherit;">これはそれ自体興味深い作業ですが、独立した研究のためにお任せします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムのアイデアを得たら、それを分析する必要があります。動作を変更せずにプログラムを変換できるいくつかの事実を見つけます。</font><font style="vertical-align: inherit;">上記の最適化の多くは、プログラムの分析に基づいています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数の折りたたみ：式の結果は既知の定数値ですか？</font><font style="vertical-align: inherit;">式の計算は純粋ですか？</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型キャストとインライン化：メソッド呼び出しタイプは、呼び出されたメソッドの単一の実装を持つタイプですか？</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブランチの削除：ブール条件式は定数ですか？</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドコードの削除：コンパイル結果は「ライブ」ですか？</font><font style="vertical-align: inherit;">つまり、プログラムの結果に何らかの影響がありますか？</font><font style="vertical-align: inherit;">計算はきれいですか？</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅いスケジュール：計算はクリーンです。つまり、別の時間に転送できますか？</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムについて知っている事実が多く、具体的であるほど、セマンティクスを変更せずにプログラムを変換して最適化することができます。</font><font style="vertical-align: inherit;">この記事では、型キャスト、定数、活力、アクセシビリティについて説明します。また、純度分析は独自のタスクです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプ、定数、純正度、活力-これらは、オプティマイザがプログラムについて知りたい最も一般的な事実の一部です。</font><font style="vertical-align: inherit;">オプティマイザでの分析は、コンパイラによるフロントエンドの型チェックでの型変換と非常に似ています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゴースト構造（推論格子）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、還元可能な型と定数がどのように機能するかを決めましょう。</font><font style="vertical-align: inherit;">本質的に、「タイプ」は意味に関する私たちのある種の知識を反映しています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですよ</font></font><code>Integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ね？</font></font><code>String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font><code>Array[Float]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font><code>PrintLogger</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font><br>
</li>
<li> <code>CharSequence</code>?      <code>String</code>,     -  <code>StringBuilder</code>?<br>
</li>
<li>  <code>Any</code>,     ,    ?<br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラム内の潜在的な値の型は、そのような構造として表すことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/258/4b1/b4d/2584b1b4d5769ebd78d1dcd84e4f686a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定数値のキャストは、キャストと非常に似ています。ある意味で、定数文字列値</font></font><code>"hello"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、サブタイプ</font></font><code>String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と同じように</font></font><code>String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブタイプ</font></font><code>CharSequence</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。ラインが1つしかないため</font></font><code>"hello"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、シングルタイプ（Singleton Type）-シングルトンと呼ぶことができます。シングルトーンで構造を拡張します</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/416/872/547/416872547323d84b9b682852ea1f4dcc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。値に割り当てられたタイプの構造が高くなるほど、その値についての知識が少なくなります。下に行くほど、学ぶことが多くなります。値が2つの型のいずれかに属していることがわかっている場合（たとえば、</font></font><code>String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または）</font></font><code>StringBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">その値は</font><font style="vertical-align: inherit;">最も近い上位の型に属していると控えめに仮定できます。</font></font><code>CharSequence</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">値が</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、または</font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、またはに</font><font style="vertical-align: inherit;">等しいことがわかっている場合</font><font style="vertical-align: inherit;">、それ</font><font style="vertical-align: inherit;">は等しいと</font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論付けることができ</font></font><code>Integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/76a/79c/cc2/76a79ccc288b609397bdc4013a33f7b5.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、偶数と奇数を分離するなど、さらに細かい構造を作成できます。構造が細かい</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/479/112/0ef/4791120ef75231854b348596b49ab700.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほど、分析の精度は高くなりますが、時間がかかります。</font><font style="vertical-align: inherit;">どのくらい詳細に分析するかはあなた次第です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャスト数</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムの簡略版を見てみましょう</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, multiplied = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(count &lt; n){
    <span class="hljs-keyword">if</span> (multiplied &lt; <span class="hljs-number">100</span>) logger.log(count);<font></font>
    count += <span class="hljs-number">1</span>;<font></font>
    multiplied *= count;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> ...;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
へのさまざまな呼び出しを削除し</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">と</font></font><code>ackermann</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のみを使用</font><font style="vertical-align: inherit;">しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、データがグラフの外観をどのように流れるかです：</font><font style="vertical-align: inherit;">
私たちは、それがされていることがわかり</font><font style="vertical-align: inherit;">等しい初期化</font><font style="vertical-align: inherit;">します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして、制御フローは、にシフトしている</font><font style="vertical-align: inherit;">私たちは、条件が満たされているかどうかを確認する場合は、</font><font style="vertical-align: inherit;">yesの場合、その後に移動します。</font><font style="vertical-align: inherit;">そして</font><font style="vertical-align: inherit;">、それ以外に行く</font><font style="vertical-align: inherit;">、その刻み</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">とに結果を保存し</font><font style="vertical-align: inherit;">に制御を戻す、</font><font style="vertical-align: inherit;">チェックを繰り返します。</font><font style="vertical-align: inherit;">このサイクル</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">が戻る</font><font style="vertical-align: inherit;">まで機能</font><font style="vertical-align: inherit;">します</font><font style="vertical-align: inherit;">。その後</font><font style="vertical-align: inherit;">、プログラムに</font><font style="vertical-align: inherit;">移動し</font><font style="vertical-align: inherit;">て終了します。</font><font style="vertical-align: inherit;">
それを分析するには？</font></font><code>count</code><font style="vertical-align: inherit;"></font><code>multiplied</code><font style="vertical-align: inherit;"></font><code>logger</code><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/383/aa5/a19/383aa5a19df21ddbbe6f13555fb4ea1d.png"><br>
<br><font style="vertical-align: inherit;"></font><code>count</code><font style="vertical-align: inherit;"></font><code>0</code><font style="vertical-align: inherit;"></font><code>block0</code><font style="vertical-align: inherit;"></font><code>block1</code><font style="vertical-align: inherit;"></font><code>count &lt; n</code><font style="vertical-align: inherit;"></font><code>block3</code><font style="vertical-align: inherit;"></font><code>return</code><font style="vertical-align: inherit;"></font><code>block2</code><font style="vertical-align: inherit;"></font><code>count</code><font style="vertical-align: inherit;"></font><code>1</code><font style="vertical-align: inherit;"></font><code>count</code><font style="vertical-align: inherit;"></font><code>block1</code><font style="vertical-align: inherit;"></font><code>&lt;</code><font style="vertical-align: inherit;"></font><code>false</code><font style="vertical-align: inherit;"></font><code>block3</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から始め</font></font><code>block0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">私達はことを知っています</font></font><code>count = 0.</code><br>
</li>
<li>  <code>block1</code>,   ,   <code>n</code> (  ,      <code>Integer</code>),     ,   <code>if</code>.   <code>block2</code>  <code>block3.</code></li>
<li> <code>block3</code>,   ,    <code>block1b</code>,      <code>block2</code>,   ,     <code>block1c</code>.  ,  <code>block2</code>  <code>count</code>,    1      <code>count.</code></li>
<li> ,  <code>count</code>    <code>0</code>  <code>1</code>:        <code>count</code>  <code>Integer.</code></li>
<li> :   <code>block1</code>   <code>n</code>  <code>count</code>  <code>Integer</code>.<br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再度移動し</font></font><code>block2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、に</font></font><code>count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更しました</font></font><code>Integer + 1 -&gt; Integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それ</font></font><code>count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">何であるか</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">すでにわかっている</font></font><code>Integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ので、分析を完了することができます。</font></font><br>
</li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャストを掛けた</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
に関連するブロックごとの他のデータフローグラフについて考えてみましょう</font></font><code>multiplied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から始め</font></font><code>block0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">私たちは知ってい</font></font><code>multiplied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た値が割り当てられています。</font></font><code>0.</code><br>
</li>
<li><font style="vertical-align: inherit;"></font><code>block1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前に削除できなかった条件付きジャンプがあるに</font><font style="vertical-align: inherit;">移動し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">行く</font></font><code>block2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>block3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（すべてがここでは簡単です）。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">（以前はとして定義した</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">（等しい</font><font style="vertical-align: inherit;">）で</font></font><code>block2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乗算した</font><font style="vertical-align: inherit;">ことが</font><font style="vertical-align: inherit;">わかります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">なので</font><font style="vertical-align: inherit;">、あなたはそれを</font><font style="vertical-align: inherit;">減らした</font><font style="vertical-align: inherit;">ままにすることができます</font></font><code>block2</code><font style="vertical-align: inherit;"></font><code>0</code><font style="vertical-align: inherit;"></font><code>count</code><font style="vertical-align: inherit;"></font><code>Integer</code><font style="vertical-align: inherit;"></font><code>0 * Integer -&gt; 0</code><font style="vertical-align: inherit;"></font><code>multiplied</code><font style="vertical-align: inherit;"></font><code>0.</code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは再び通過</font></font><code>block1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し</font></font><code>block2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><code>multiplied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まだに減少している</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、分析を停止できます。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
に</font></font><code>multiplied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">減少してから</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次のことがわかります。</font></font><br>
<br>
<ul>
<li><code>multiplied &lt; 100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> につながることができます </font></font><code>true.</code><br>
</li>
<li><code>if (multiplied &lt; 100) logger.log(count);</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に簡略化できます</font></font><code>logger.log(count)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"></font><code>multiplied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最終結果は常に等しいことがわかっているため、</font><font style="vertical-align: inherit;">で完了するすべての計算を削除でき</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの変更は赤でマークされ</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e9f/5f2/e95/e9f5f2e95c4dc3bfc64d54834c2a19ea.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ています。次のデータフローグラフがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fd4/625/fdb/fd4625fdb669e5d9e0c4d28a71e67f85.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイトコードにシリアル化してプログラムを取得します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(count &lt; n){<font></font>
    logger.log(count);<font></font>
    count += <span class="hljs-number">1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> ...;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムを適切なデータ構造の形式でモデル化したので、混乱しやすい非効率的なコードを単純化して小さな効率的なループに変えるために、単純なグラフ遷移が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
削減</font></font><code>multiplied -&gt; 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、部分計算などの他の最適化に適用できます。</font><font style="vertical-align: inherit;">一般に、ゴーストを使用すると、新しいゴーストを作成できます。一部の最適化は、新しいゴーストへの道を開きます。</font><font style="vertical-align: inherit;">プログラムオプティマイザーを設計する際の主な困難は、このキャストと最適化機能のカスケードを効果的に使用することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでは、データストリームのグラフでキャストがどのように機能するかを示しました。</font><font style="vertical-align: inherit;">見直しました：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムの各値の知識を表すために、ゴーストの構造をどのように定義できますか。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合成プログラムのデータフローグラフはどのようなものですか？</font></font><br>
</li>
<li>            .<br>
</li>
<li>       :        .<br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、最初に分析し</font></font><code>count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次に</font><font style="vertical-align: inherit;">分析することができました</font></font><code>multiplied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これはに</font></font><code>multiplied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存している</font><font style="vertical-align: inherit;">ため可能になりましたが、</font><font style="vertical-align: inherit;">依存して</font></font><code>count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">い</font></font><code>count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません</font></font><code>multiplied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。相互依存の場合、グラフを1回通過する間に変数を一緒に分析する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャストは反復的なプロセスであることに注意してください。キャストが変化しなくなるまで、ループを何度も繰り返します。一般に、ループ（または再帰）のないデータフローグラフは、常に1つのパスで分析できます。また、ループや再帰を伴うプログラムでは、分析を数回繰り返す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、サイクルは2回しか通過し</font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ませんでしたが、分析に必要な場合があります</font></font><code>O(  )</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反復。</font><font style="vertical-align: inherit;">したがって、より詳細な構造（偶数と奇数への分割など）を使用すると、分析の精度が向上するだけでなく、その期間も長くなるため、妥協点を探す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これから説明するように、同じアプローチを使用して任意の再帰関数のプロパティを減らすことができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の手続き間キャスト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記では、わかりやすくするために、他の関数またはメソッドへの呼び出しを無視して、関数の単一の本体内の値を引用しました。</font><font style="vertical-align: inherit;">しかし、ほとんどのプログラムには相互に呼び出す関数が多数含まれているため、実際のプログラムを操作する場合は、関数内の1つの式のプロパティだけでなく、関数自体のプロパティも引用し、呼び出しグラフで相互の相互作用をもたらす必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純な非再帰関数</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、他の機能の処理は簡単です。</font><font style="vertical-align: inherit;">このプログラムを見てください：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
    <span class="hljs-keyword">return</span> called(n, <span class="hljs-number">0</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">called</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{
    <span class="hljs-keyword">return</span> x * y;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これら2つの関数のデータフローグラフは次のよう</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/45a/a32/471/45aa32471c28271c2755e5494a590891.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
になります</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">戻り値は</font><font style="vertical-align: inherit;">次のとおり</font><font style="vertical-align: inherit;">です</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持参 </font></font><code>main(n)</code><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持参 </font></font><code>called(n, 0)</code><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは、持参</font></font><code>x * y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font></font><code>x = n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>y = 0</code></li>
<li><code>n * 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 同様に </font></font><code>0</code></li>
</ul></li>
<li><code>called(n, 0)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 同様に </font></font><code>0</code></li>
</ul></li>
<li><code>main(n)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 同様に </font></font><code>0</code><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャスト中に関数呼び出しに到達した場合、呼び出し元のキャストを続行する前に、まず呼び出し元をキャストします。</font><font style="vertical-align: inherit;">このゴーストスタックは任意の深さにすることができ、プログラムの実行時にコールスタックを反映します。</font><font style="vertical-align: inherit;">等しい</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
こと</font></font><code>called(n, 0)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">わかっているので</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これを使用してデータフローのグラフを単純化できます。これを</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3e8/484/17d/3e848417db361dae9f39425ddeed1a13.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードにシリアル化します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、関数は再帰的ではありません。AがBを呼び出し、Cを呼び出し、Dを呼び出し、DはそのキャストをC、B、D、Aに返します。ただし、関数AがBを呼び出し、BがAを呼び出し、またはAがAを再帰的に呼び出します。呼び出しは何も返さないので、それはすべてバラバラになります！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再帰的階乗関数</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
疑似Javaで記述された単純な再帰関数を考えます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Any <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> n * factorial(n - <span class="hljs-number">1</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼女はそれ</font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を受け取って作成します</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、戻り値の型は次のようにマークされ</font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。宣言が戻りデータと一致しません。</font><font style="vertical-align: inherit;">私たちは何</font></font><code>factorial</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（または</font></font><code>Integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちの構造の中で）</font><font style="vertical-align: inherit;">戻ってくるの</font><font style="vertical-align: inherit;">かを見</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、戻る前にボディを完全に分析すると、</font><font style="vertical-align: inherit;">分析が完了するまで</font></font><code>factorial</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再帰呼び出しが分析さ</font></font><code>factorial</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れます</font></font><code>factorial</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。つまり、無限再帰が発生します。</font><font style="vertical-align: inherit;">キャストエンジンは、これをどのように判断するのですか？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下に持ってきて</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは、幽霊の私達の構造に特別な意味を追加します</font></font><code>Bottom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/abe/520/44e/abe52044e569bfe201c2d0f6998761ec.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは意味「我々はそれがまだあるかわからないが、私たちは、後で戻ってくると、それを記入します。」</font></font><code>Bottom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データフローグラフに</font><font style="vertical-align: inherit;">適用可能</font></font><code>factorial</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/50b/347/73b/50b34773b36ec9470e3bdb03efaec5eb.png"><br>
<br>
<ul>
<li>  <code>block0</code>. <code>n</code>   <code>Integer</code>, <code>1</code>  <code>1</code>,   <code>n == 1</code>  ,      <code>true</code>  <code>false</code>.<br>
</li>
<li> <code>true</code>  : <code>return</code>  <code>1</code>.<br>
</li>
<li>  <code>false</code>  <code>n - 1</code>  <code>n </code>  <code>Integer</code>.<br>
</li>
<li><code>factorial</code> —   ,      <code>Bottom</code>.<br>
</li>
<li><code>*</code>  <code>n: Integer</code>  <code>factorial</code>: <code>Bottom</code>   <code>Bottom</code>.<br>
</li>
<li><code>return</code>  <code>Bottom</code>.</li>
<li>  <code>factorial</code>  <code>1</code>  <code>Bottom</code>,           <code>1</code>.<br>
</li>
<li> <code>1</code>      <code>factorial</code>,      <code>Bottom</code>.<br>
</li>
<li><code>Integer * 1</code>  <code>Integer</code>.<br>
</li>
<li><code>return</code>   <code>Integer</code>.</li>
<li><code>factorial</code>   <code>Integer</code>  <code>1</code>,        <code>Integer</code>.<br>
</li>
<li><i></i>    <code>factorial</code>,      <code>Integer</code>.  <code>*</code>  <code>n: Integer</code>  <code>factorial: Integer</code>,    <code>Integer</code>,     .<br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我々はリターンキャストすることができました</font></font><code>factorial</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、結果を</font></font><code>Integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それが戻り値の型を宣言することなく、再帰関数であっても、。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの例はすべて人為的なものですが、関数呼び出しがある場合のキャストメソッドを示しています。</font><font style="vertical-align: inherit;">再帰関数を使用すると、</font></font><code>Bottom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初にそれらに遭遇したとき</font><font style="vertical-align: inherit;">から呼び出しのスタブを作成し</font><font style="vertical-align: inherit;">、最初の分析パスの完了時に、スタブを最初のキャストに置き換え、この変更をデータフローグラフに渡すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、式は</font></font><code>*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3回分析されます。</font></font><br>
<br>
<ol>
<li><code>(n: Integer) * (factorial: Bottom)</code><br>
</li>
<li><code>(n: Integer) * (factorial: 1)</code><br>
</li>
<li><code>(n: Integer) * (factorial: Integer)</code><br>
</li>
</ol><br><font style="vertical-align: inherit;"></font><code>multiplied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ループから</font><font style="vertical-align: inherit;">
定数をキャストする場合と同様に</font><font style="vertical-align: inherit;">、キャストを完了するには、</font></font><code>O(  )</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パスの</font><font style="vertical-align: inherit;">前にキャストを完了する必要がある場合があり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">このアプローチは、他のスタイルの再帰関数を一般化し、清潔さなどの他のプロパティをもたらすことができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">活力とアクセシビリティをもたらす</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行可能性とアクセシビリティの分析は、「デッドコードの削除」のカテゴリに分類される最適化のペアです。</font><font style="vertical-align: inherit;">この分析では、コード、最終結果に影響を与える値（「ライブコード」）、およびプログラム制御フローによって到達できるコード（「利用可能なコード」）を探します。</font><font style="vertical-align: inherit;">他のすべてのコードは削除できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元の関数の別の簡略化されたバージョンを見てみましょう</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, total = <span class="hljs-number">0</span>, multiplied = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(count &lt; n){
    <span class="hljs-keyword">if</span> (multiplied &gt; <span class="hljs-number">100</span>) count += <span class="hljs-number">1</span>;<font></font>
    count += <span class="hljs-number">1</span>;<font></font>
    multiplied *= <span class="hljs-number">2</span>;<font></font>
    total += <span class="hljs-number">1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> count;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前のバージョンとは異なり、ここでは条件ジャンプをに変更し</font></font><code>if (multiplied &gt; 100)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て置き換え</font></font><code>multiplied *= count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました</font></font><code>multiplied *= 2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そのため、一般化を失うことなく、プログラムのグラフを簡略化しました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードの実行可能性を評価するための収益</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のプログラムで検出する必要がある2つの問題があります。</font></font><br>
<br>
<ul>
<li><code>multiplied &gt; 100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発生</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すること</font></font><code>count += 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はないため、実行される</font><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">はありません（「使用不可」）。</font></font><br>
</li>
<li><code>total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> いくつかの計算値を保存しますが、そのうちの1つは使用されません（「実行不可能」）。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的には、プログラムは次のようになります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(count &lt; n){<font></font>
    count += <span class="hljs-number">1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> count;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、アナライザーがそれを自動的に書き換える方法を見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、データフローグラフを見てください。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0f1/2a1/af5/0f12a1af57586674b9e1a7fb1ae13c86.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでに見たグラフよりもはるかにわかりにくいですが、それでも読みやすくなっています。ある</font><font style="vertical-align: inherit;">条件がtrueの場合</font><font style="vertical-align: inherit;">は</font></font><code>block0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、から</font><font style="vertical-align: inherit;">始めて</font><font style="vertical-align: inherit;">、に進み</font></font><code>block1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次に</font></font><code>block1b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、別の条件がtrueの場合は、に進ん</font></font><code>block1c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でください。ノード</font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cで</font><font style="vertical-align: inherit;">終了するまで</font></font><code>block3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">死んでいてアクセスできないコードを削除します</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我々は、検索のためのようなタイプと定数の同じキャストを適用することができ</font></font><code>multiplied -&gt; 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、グラフを変更します</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/92a/1dd/f90/92a1ddf903dcc52cc9966220c56db876.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
：ここでは何が起こったのです</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/906/1ef/09c/9061ef09c209275be5158a8b3184a5bc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我々は、条件付きに移行することを参照</font></font><code>block1b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>0 &gt; 100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）が起こることはありません</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この手段は、分岐という</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件からは</font></font><code>block1c</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">利用できない</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と（条件のように削除することができます</font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/587/21e/8e4/58721e8e43fb326379c796593f9bd2a7.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、私たちは「行き止まり」を参照</font></font><code>total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その計算の何かが、結果を返すか、評価し、任意の降順条件分岐で使用されていません。これは、サイトから以下のグラフアップから理解することができ</font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すべての収集、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：コンポーネントを、他の除去</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font><code>block1b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、と</font></font><code>+ 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に渡されます</font></font><code>total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これが起こったことです：</font><font style="vertical-align: inherit;">
バイトコードにシリアル化し、「完璧な」プログラムを取得します：</font></font><code>block0</code><font style="vertical-align: inherit;"></font><code>block2</code><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/55b/508/e16/55b508e164d0c4421aa525dcab56e122.png"><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(count &lt; n){<font></font>
    count += <span class="hljs-number">1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> count;<font></font>
}<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、最適化コンパイラー内にプログラムをキャストする方法を検討しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドラフトプログラムの手動による最適化を確認しました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの最適化は、オプティマイザを使用して自動的に実行できることがわかりました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化コンパイラーがメモリー内のプログラムを中間表現としてシミュレートできるさまざまな方法を検討しました。</font><font style="vertical-align: inherit;">その後、データフローのグラフ形式の表現が記事で使用されました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">削減手法を検討しました。1つの関数のフレームワーク内での「プロシージャ内」と複数の関数間での「プロシージャ間の」、おそらく再帰的なものです。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行可能性とアクセシビリティの分析を検討しました。プログラムの実装の結果に影響を与えないプログラムの部分の検索です。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中間表現を単純化するための簡約と分析の使用を検討しました。中間表現は、より単純でよりコンパクトなプログラムにシリアル化できます。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純なアルゴリズムを単純なデータ構造に適用することにより、手動プログラム最適化プロセスを自動化プロセスに変えることが可能であることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、コードを高速化するコンパイラの最適化のほんの一部です。</font><font style="vertical-align: inherit;">記事には多くは含まれていませんでした。</font><font style="vertical-align: inherit;">詳細を知りたい場合は、これから始めることができます。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keith D CooperとLinda Torczonによるエンジニアリングコンパイラー</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析の組み合わせ、Cliff Noel Click Jrによる最適化の組み合わせ</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Steven Muchnickによる高度なコンパイラの設計と実装</font></font></a><br>
</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja477050/index.html">ビデオ監視とクラウドのためのブラックフライデー2019。</a></li>
<li><a href="../ja477052/index.html">Reactor、WebFlux、Kotlinコルーチン、または簡単な例による非同期</a></li>
<li><a href="../ja477054/index.html">Webastoがモジュール式自動車用バッテリーシステムを発表</a></li>
<li><a href="../ja477058/index.html">Enterprise Agile Russia at Raiffeisenbank 26/11 + Broadcast</a></li>
<li><a href="../ja477060/index.html">DataArtは、サンクトペテルブルク州立大学マトメク校システムプログラミング学部長Andrei Terekhovによる公開講演を主催します。</a></li>
<li><a href="../ja477072/index.html">顧客開発、または失敗なく製品を発売する方法？</a></li>
<li><a href="../ja477074/index.html">アリアドネのスレッド：JSR-133に恋する方法。Yandexレポート</a></li>
<li><a href="../ja477078/index.html">WebStorm 2019.3：起動の高速化、Vue.jsのサポートの改善、その他の改善</a></li>
<li><a href="../ja477082/index.html">米国議会対ザッカーバーグ：規制当局がFacebookの安定した天秤座に反対している主張</a></li>
<li><a href="../ja477084/index.html">会社の頭脳。パート2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>