<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüîß üçù üöê Probleme und Funktionen der UEFI-Implementierung auf verschiedenen Plattformen üë©‚Äç‚öïÔ∏è ü§õüèø üì¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seit der Ver√∂ffentlichung der ersten EFI-Spezifikation im Jahr 2000 sind etwa neunzehn Jahre vergangen. Es dauerte zehn Jahre, bis die Benutzeroberfl√§...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Probleme und Funktionen der UEFI-Implementierung auf verschiedenen Plattformen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/gaz-is/blog/493822/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seit der Ver√∂ffentlichung der ersten EFI-Spezifikation im Jahr 2000 sind etwa neunzehn Jahre vergangen. Es dauerte zehn Jahre, bis die Benutzeroberfl√§che in den Benutzermarkt eingetreten war und dort Fu√ü gefasst hatte. Im Moment kann man selten einen modernen Computer ohne UEFI in der Firmware des Motherboards sehen. Der Schnittstellenstandard hat das "Fleisch" und mehrere tausend Seiten in der offiziellen Dokumentation erh√∂ht. F√ºr den durchschnittlichen Benutzer hat sich nichts ge√§ndert, au√üer gelegentlichen Kollisionen mit aktiviertem Secure Boot. Wenn sich die Arbeitsebene jedoch zur Entwicklung verschiebt, wird alles interessanter.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1f/ek/as/1fekaswnox-diqt-hgzmaiqnq4g.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Konzept der modularen Architektur von UEFI impliziert, dass diese Module nicht nur in der Standardkonfiguration verwendet werden k√∂nnen, sondern auch etwas Eigenes herunterladen k√∂nnen. Der Dateisystemtreiber (nicht beschr√§nkt auf das native eFi-sch√ºchterne FAT?), Peripherietreiber, Anwendungen, Bootloader - Sie k√∂nnen alles von Hand laden, es w√§re sch√∂n, ein bisschen Shell zu laden. Sie k√∂nnen einen Schritt "tiefer" gehen und sich den Inhalt der Firmware ansehen, um sich vor dem Tanzen mit SecureBoot und der Notwendigkeit zu sch√ºtzen, eine Schicht von Skripten zu schreiben (es gibt gen√ºgend Artikel auf den Seiten des Hubs).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf dieser Grundlage entstand die Idee, vor dem Laden des Betriebssystems Funktionsmodule zu erstellen, die verschiedene Sicherheitsfunktionen ausf√ºhren. Diese k√∂nnen sich weiter vereinen und zu einer Art integrierter vertrauensw√ºrdiger Startumgebung werden, die sich sowohl auf die Dienste der Start- als auch auf die Laufzeitschnittstelle auswirkt, sodass zwischen den Modulen in der Firmware und den Modulen auf der Festplatte Nichts konnte ohne Eingreifen auf niedriger Ebene und danach "gepusht" werden - nur mit Erlaubnis des Sicherheitsadministrators. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Umsetzung dieser Idee f√ºhrte uns in eine Vielzahl von Nuancen und Feinheiten von UEFI ein - angefangen bei vielen undokumentierten oder schlecht dokumentierten Funktionen, Fehlern bis hin zu dem undefinierten Verhalten, das von allen Entwicklern so geliebt wird. </font><font style="vertical-align: inherit;">Fangen wir in der richtigen Reihenfolge an.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plattformabh√§ngigkeit</font></font></h4><br>
<img src="https://habrastorage.org/webt/wn/pz/1f/wnpz1fwi6hrqqhoogamysefkdic.png" width="770"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste, was Sie bei der Integration in die Plattform herausfinden m√ºssen, ist, ob wir damit arbeiten k√∂nnen. Die Version der UEFI-Spezifikation ist wichtig und wird auf den meisten Ger√§ten im Bereich zwischen 2.1 und 2.7 angeboten. Der neuere hat den Forschungsstand noch nicht erreicht. Das √§ltere wird gefunden, und seine Leistung kann aufgrund des Fehlens der erforderlichen Protokolle oder schief geschriebenen Treiber f√ºr deren Implementierung eingeschr√§nkt sein. Beispielsweise reicht UnicodeCollation h√§ufig nicht aus. Wenn auf smbios zugegriffen wird, treten undokumentierte Fehler auf. Die Sprach√§nderungsfunktionen √ºber SetVariable () funktionieren nicht. Je nach Anbieter und Aktualit√§t kann alles passieren, da Sie Ihre Protokolle manchmal sogar auf relativ neuen Boards ablegen m√ºssen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst in unserer Praxis hatte ich das Gl√ºck, auf zwei Mini-Computer mit Intel Bay Trail D und 32-Bit-Firmware an Bord zu sto√üen. Der Fall ist selten, machte es jedoch einmal erforderlich, die Module dringend neu zu kompilieren. Eigentlich wie die Frage: Werden wir in Zukunft auf eine modernere Plattform mit der gleichen Kapazit√§t treffen? Und wenn wir uns treffen, wo dann?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der n√§chste Schritt besteht darin, zu bestimmen, wie integriert werden soll. Die Module sind in die Firmware integriert, die Firmware befindet sich im SPI-Chip auf der Platine und PCH mit Intel ME befindet sich in der N√§he. Und hier stellt sich die interessanteste Frage: Wie kommt man dorthin? Guter alter Programmierer mit einem "Krokodil" - das ist gut, es ist zuverl√§ssig. Auch wenn Sie nicht bis zum Ende durchhalten, k√∂nnen Sie immer auf die brennenden LEDs auf der Platine schauen, sie haben genug Strom vom Programmierer. Es funktioniert fast einwandfrei, mit Ausnahme einiger √§lterer HP-Modelle, bei denen mikruha SOIC-16 mit Firmware so zug√§nglich ist, dass es einfacher ist, den Adapter zu konstruieren und an ihre Beine zu l√∂ten, als den Clip zusammenzudr√ºcken. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/uu/ce/6b/uuce6bumbvwdovmxow0ntfoeynm.png" width="770"><br>
<img src="https://habrastorage.org/webt/qj/kf/k1/qjkfk14esp5_ol1vchn8fkaiwt4.png" width="770"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich wei√ü, dass es auf Habr√© Leute gibt, die dank ihnen separat zum Schreiben von Flashrom beigetragen haben.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Zuverl√§ssigkeit und Zuverl√§ssigkeit der Speicherauszugsentfernung durch den Programmierer ist diese Methode nicht geeignet, wenn Sie etwas in UEFI auf mehreren Computern installieren m√ºssen oder wenn sich die Zielplattform f√ºr die Installation nicht auf Ihrem Schreibtisch befindet. Zum Gl√ºck haben die Hersteller native Firmware-Dienstprogramme zur√ºckgelassen: FPT (Flash-Programmiertool) von Intel (CS) ME System Tools und AFU (AMI Firmware Update) f√ºr Aptio von American Megatrends. Diese Dienstprogramme werden sowohl von der EFI-Umgebung als auch von den Betriebssystemen Windows, Linux und DOS gestartet. Die Dienstprogramme sind etwas austauschbar. Mit beiden k√∂nnen Sie das Bild, wenn nicht das Ganze, bestimmte Regionen mit Sicherheit betrachten. Und manchmal lassen sie dich sogar zur√ºckschreiben. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/hk/vz/pp/hkvzppckxwb02epv3ieytikh5y0.png" width="770"><br>
<img src="https://habrastorage.org/webt/we/qx/3y/weqx3ysvpinegiv9gxh9biw7xdg.png" width="770"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Er schreibt und schreibt nicht</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier erscheint der erste ernsthafte Stolperstein auf dem Weg der Integration. Nicht auf allen Motherboards k√∂nnen Sie die gesamte Firmware lesen und den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zugriff</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf die ME-Region </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">verbieten</font></a><font style="vertical-align: inherit;"> (ME ist fast heilig, Intel l√§sst es nicht zu, dass es gut gelesen wird, aber </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf schlechte Weise wollen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir es nicht immer). Noch weniger - gie√üen Sie etwas sogar in die BIOS-Region, es sei denn, es handelt sich um eine signierte Kapsel. Die Erfolgswahrscheinlichkeit variiert stark je nach Hersteller und Frische des Chipsatzes. Bei einigen Motherboard-Modellen ist ein lustiges Bild zu sehen: Das, was nicht auf den alten Vendor-Boards aufgezeichnet wurde, fliegt zu neuen Zeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal hilft der </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">IFR-Parser dabei</font></a><font style="vertical-align: inherit;"> , den Schreibschutz zu bek√§mpfen</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was den Vorhang f√ºr versteckte Einstellungen und Variablen √∂ffnet. </font><font style="vertical-align: inherit;">Und manchmal hilft nur ein Hardcore-Jumper, der den Zugriff auf die Aufnahme erm√∂glicht oder ME "ausschaltet" (falls vorhanden).</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Komplexit√§t von Systemen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Acer-, Asus-, AsRock- und Gigabyte-Karten werden in den meisten F√§llen ohne unn√∂tige Schwierigkeiten geschrieben. </font><font style="vertical-align: inherit;">Intel-, HP- und Serverhardware zeichnen sich aus. </font><font style="vertical-align: inherit;">HP erlaubt nicht nur nicht, programmgesteuert in sich selbst zu schreiben, sondern schw√∂rt auch bei jedem Versuch, die Firmware zu √§ndern (in</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CodeRush</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zum Auffinden und Deaktivieren der Integrit√§tspr√ºfung. Intel hat mehr oder weniger bis zum 87. Chipsatz aufgenommen, dann wurde es taub f√ºr Anfragen, die Tore der BIOS-Region zu √∂ffnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Intel war das erste Mal lustig. Die Module wurden mit dem Dienstprogramm UEFITool in die Firmware importiert, und wir stie√üen auf einen interessanten Fehler: Wenn Sie am Ende des DXE-Volumes nach allen Freiforms ffs-Module einf√ºgen, hat das zusammengesetzte Image die Platine ‚Äûgemauert‚Äú. Die L√∂sung bestand darin, Module nach jedem nativen DXE-Treiber hinzuzuf√ºgen. Wir sind nicht sofort dazu gekommen, und auf den ersten Blick sah es so aus, als w√ºrde Intel die Integrit√§t der Firmware √ºberwachen, wie HP. Sp√§ter wurde klar, dass man auf ein automatisches Dienstprogramm zum Importieren von Modulen nicht verzichten konnte, und das Problem wurde nach dem Schreiben zunichte gemacht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Serverseitige Hardware ist gleichzeitig einfacher und komplexer. Einerseits gibt es immer zus√§tzliche M√∂glichkeiten, BIOSs auf Servern zu aktualisieren und zu √§ndern, andererseits ist das Anpassungsvolumen in denselben BIOSs √ºberw√§ltigend, da sie nicht an Servern sparen und recht umfangreiche Flash-Speicherchips installieren und diese h√§ufig auch sichern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Installation auf einem Server ist es immer sch√∂n, das BIOS √ºber IPMI remote aktualisieren zu k√∂nnen. Richtig, daf√ºr braucht man nat√ºrlich eine Lizenz, die nat√ºrlich bezahlt wird. Wenn es nicht zum richtigen Zeitpunkt erscheint, ist es durchaus m√∂glich, in eine lustige Situation zu geraten, √§hnlich der, die wir durch die Einf√ºhrung von Modulen in das Supermicro-Server-BIOS erhalten haben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach der Einf√ºhrung der Module friert die Last aufgrund der Blockierung durch eines der Sicherheitsmodule stark ein (sie ber√ºcksichtigten nicht die Unberechenbarkeit der Server-BIOSs, mit denen dies nicht geschieht!). Da das BIOS nicht √ºber IPMI zur√ºckgesetzt werden konnte, griff die Hand selbst nach dem Programmierer, aber es war ein Pech - der Standard-SOIC-8-Clip reichte f√ºr einen SOIC-16-Chip nicht aus! Okay, denn theoretisch kann die Serverplatine von den angeschlossenen Medien sichern und das SUPER.ROM-Image im Stammverzeichnis aufnehmen. Dieser Mechanismus startet jedoch nicht, da laut System alles in Ordnung ist, alles funktioniert und daher kein BIOS-Rollback erforderlich ist! Was tun?! .. Die Geschichte lief durch die Stadt auf der Suche nach dem richtigen Clip, einem Notl√∂ten von Dr√§hten, das von den Chinesen in einer f√ºr uns unverst√§ndlichen Reihenfolge verschmiert wurde, und schlie√ülich - einem Blinken.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lenovo kam noch interessanter heraus. Auf den vom Hersteller erhaltenen Schaltern wurde unter dem Deckmantel des Geh√§uses eine Steuerplatine mit zwei ‚ÄûMikruhs‚Äú f√ºr Firmware, einer SSD f√ºr Betriebssysteme und einem festen Akku gefunden. Das BIOS stellte sich als harte Nuss heraus. Ich wollte in keiner Weise ein modifiziertes Image essen, sondern nur dem Programmierer erliegen. Bei einem der Versuche, etwas aufzuschreiben, steckten sie ein Flash-Laufwerk mit Konsolen-Ubuntu in den Switch (das Terminal gab keine Grafiken aus) und starteten ziemlich sicher. Nachdem sie das Notwendige getan hatten, schalteten sie das System mit dem Befehl halt -p aus dem alten Speicher aus. Der Schalter war von Natur aus nicht f√ºr ein Herunterfahren geeignet, au√üer f√ºr den Mangel an Strom, war daf√ºr nicht bereit und wollte nicht mehr starten. Die Verbindung im Gesicht brannte einmal durch, die Ventilatoren raschelten leise und alle Anschl√ºsse gaben nichts heraus. Ein erneutes Blinken hat nicht geholfen,Die Batterie sa√ü wie angegossen - wir hatten Angst, die Halterung zu zerbrechen. Infolgedessen kroch eine d√ºnne dielektrische Platte unter der Kraft der Beharrlichkeit und der verbalen Inspiration unter den Kontakten, der fl√ºchtige Speicher wurde gel√∂scht, der Schalter wurde lebendig.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Untersuchung von Deponien aus zwei Chips zeigte viele interessante Dinge. Insbesondere eine gro√üe Anzahl von "ung√ºltigen" Eintr√§gen im NVRAM der Hauptfirmware und mehrere √§hnliche im Backup. Nun, und kein zuvor angetroffener Daten-Hash im Volume mit DXE-Treibern. Man konnte nur die genaue Ursache des Problems beim Starten des Schalters erraten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen wird der Softwareteil selten seiner unerwarteten Nuancen beraubt. Viele Motherboards, die vor dem 87. Chipsatz (von verschiedenen Herstellern) zu uns kamen, haben eine unangenehme Funktion, die bei der Eingabe des Befehls "dh -v" in der Shell-Konsole einen endlosen Strom von Fehlern erzeugt. Bei der manuellen Eingabe ist dies nicht kritisch, aber beim Sammeln von Daten in einer Datei endet dies in einem ungl√ºcklichen Hang. In beiden F√§llen m√ºssen Sie den Computer neu starten. Ich bin froh, dass gleichzeitig die Datendatei nicht zu immensen Gr√∂√üen anschwillt.</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/z-/rr/_k/z-rr_k9f6o7pmt_ezbza-ysrjzw.png" width="770"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Kraftway-BIOS mit ASRock H81M-DGS-Karte erwies sich als sehr eigensinnig. Es reagiert also auf Strg Alt Del Del, indem es h√§ngt, von dem nur Reset es ausgeben kann. Beim √úberspringen des Startskripts &lt;startup.nsh&gt; in Shell'e gab es Probleme - ein Sekundenbruchteil anstelle von f√ºnf Standard-Skripten. Vielleicht werden diese Probleme durch die Modifikation durch die propriet√§ren KSS-Module verursacht, vielleicht ist die Angelegenheit ME ungenau "abgeschraubt".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der Asus H97-PLUS-Karte verf√ºgt die Firmware √ºber die folgende Funktion: BootOrder l√§uft mit der Zeit √ºber. Der Grund liegt h√∂chstwahrscheinlich in den Fehlern im Code. Vielleicht wollte der Hersteller zwar alle Boot-Ger√§te, die jemals angeschlossen waren, im Board behalten, rechnete aber nicht damit, dass an einem Tag mehr als ein Dutzend vorhanden sein k√∂nnten. Wenn BootOrder √ºberl√§uft, bleibt das System w√§hrend des Startvorgangs h√§ngen. Um es zu reinigen, m√ºssen Sie alle Startger√§te ausschalten und das System einschalten. Die Firmware l√∂scht sich von selbst und das System startet direkt in der BIOS-Setup-Shell. Die Leistung bleibt bis zum n√§chsten √úberlauf erhalten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Erfahrung mit Boards verschiedener Anbieter zusammenfassen, kommen Sie zu dem Schluss, dass es fast unm√∂glich ist herauszufinden, mit welchen √úberraschungen auf EFI-Ebene Sie auf dem n√§chsten Board umgehen werden, selbst wenn es bereits ein bekanntes Modell hat. </font><font style="vertical-align: inherit;">Dies ist eine Art Lotterie, da manchmal Schwierigkeiten beim Sammeln von Informationen √ºber das System auftreten k√∂nnen. </font><font style="vertical-align: inherit;">Vielleicht hat dies einen unausl√∂schlichen Forschungsidealismus und das Vertrauen in den Hersteller, denn wie sonst k√∂nnten einige der frischesten Motherboards mit ME v11 und v12 h√§ngen, wenn FPT oder MEInfo √§lterer Versionen darauf ausgef√ºhrt werden?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probleme bei der Arbeit mit Hardwareprotokollen</font></font></h4><br>
<img src="https://habrastorage.org/webt/j2/yo/ze/j2yozeg6zdyfa--juz_ycvvobbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Probleme treten auf, wenn wir mit USB-Ger√§ten arbeiten - Laufwerken und Token. Dies geschieht h√§ufig, weil der BIOS-Code f√ºr die Arbeit mit Peripherieger√§ten ein gef√§hrlicher Cocktail aus Treibern und Anwendungen von Independent Hardware Vendor (IHV) f√ºr ein bestimmtes Peripherieger√§t ist, Code vom Chipsatzhersteller (in unserem Fall von Intel), Code vom BIOS-Hersteller und Code vom Hersteller des Motherboards. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden ‚Äûinteressanten‚Äú Situationen sind </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aufgetreten </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">Token ‚Äûnicht erkannt‚Äú. Gleichzeitig leuchtet eine LED darauf. H√∂chstwahrscheinlich durchl√§uft der Host-Controller den anf√§nglichen R√ºcksetzvorgang des USB-Ger√§ts nicht, dh die Stromversorgung wird bereitgestellt, aber das Zur√ºcksetzen durch √Ñndern der D + - und D- -Leitungen funktioniert nicht ordnungsgem√§√ü, und ohne ihn sind weitere Manipulationen mit dem Token bedeutungslos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Computer friert vor dem Laden der Shell ein (erneut mit angeschlossenem Token). In diesem Fall startet der PC ohne Token normal. Live sieht es so aus: Der Computer scheint direkt nach dem Start abzust√ºrzen, w√§hrend der Token im Anschluss herausragt. Sie nehmen es heraus - das Laden geht pl√∂tzlich weiter. Verbinden - wieder h√§ngen. Das offensichtliche Problem liegt in der UEFI, und man kann nur √ºber die Gr√ºnde spekulieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Situation, in der es nicht m√∂glich ist, die USB_IO-Schnittstelle zu √∂ffnen. M√∂glicherweise ist es nur mit der Schnittstelle f√ºr die Arbeit mit Smartcards verbunden - USB CCID. Einige AMI-Treiber haben USB_IO bereits mit dem Parameter EFI_OPEN_PROTOCOL_BY_DRIVER ge√∂ffnet. Der Treiber hat ein Protokoll mit einer GUID:</font></font><br>
<br>
<pre><code class="plaintext hljs">#define EFI_AMI_USB_CCID_PROTOCOL_GUID	 { 0x5FDEE00D, 0xDA40, 0x405A, { 0xB9, 0x2E, 0xCF, 0x4A, 0x80, 0xEA, 0x8F, 0x76} }<font></font>
 // Workaround.      EFI_OPEN_PROTOCOL_BY_DRIVER,  ,     EFI_OPEN_PROTOCOL_GET_PROTOCOL.<font></font>
 //<font></font>
 // Open USB I/O Protocol<font></font>
 //<font></font>
 Status = gBS-&gt;OpenProtocol (<font></font>
 ControllerHandle,<font></font>
 &amp;gEfiUsbIoProtocolGuid,<font></font>
 (VOID **) &amp;UsbIo,<font></font>
 This-&gt;DriverBindingHandle,<font></font>
 ControllerHandle,<font></font>
 EFI_OPEN_PROTOCOL_BY_DRIVER<font></font>
 );<font></font>
<font></font>
 if (EFI_ACCESS_DENIED == Status)<font></font>
 {		// AMI BIOS workaround (BindingStop will not be invoked)<font></font>
	 Status = gBS-&gt;OpenProtocol(<font></font>
		 ControllerHandle,<font></font>
		 &amp;gEfiUsbIoProtocolGuid,<font></font>
		 (VOID **)&amp;UsbIo,<font></font>
		 This-&gt;DriverBindingHandle,<font></font>
		 ControllerHandle,<font></font>
		 EFI_OPEN_PROTOCOL_GET_PROTOCOL<font></font>
	 );<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BindingStop () wird jedoch nicht aufgerufen, d.h. Das Ger√§teextraktionsereignis wird nicht √ºberwacht, und der Treiber versucht, ein ung√ºltiges Handle zu verwenden. Dies wurde mit dem HP Compaq Elite 8300 SFF PC und einigen anderen beobachtet. Dies ist entweder eine Art Herstellerschutz vor unerw√ºnschten Treibern oder ein regelm√§√üiger Entwicklungsfehler. Vielleicht unternimmt AMI st√§ndig etwas in Richtung USB CCID, aber der st√∂rende Treiber kann nicht entladen werden, da er sich zusammen mit USB HID, USB MassStorage, im selben AMI UHCI-Modul befindet. Mit UninstallInterface () sieht es √§hnlich aus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oder eine andere interessante Funktion. In einem der UEFI-BIOS, in dem das Token nicht erkannt wurde, durfte USB_IO die Ger√§tedeskriptoren lesen, EFI_INVALID_PARAMETER kehrte jedoch zum n√§chsten UsbBulkTransfer () zur√ºck. Dar√ºber hinaus geschah dies nur mit einigen Arten von Token, mit absolut den gleichen Parametern, andere funktionierten perfekt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen ist das Protokoll UsbBulkTransfer () interessanterweise im EFI_USB_IO_PROTOCOL-Protokoll implementiert. </font><font style="vertical-align: inherit;">Es ist f√ºr eine garantierte Paketzustellung f√ºr eine unbegrenzte Zeit oder f√ºr die im Parameter Timeout angegebene Zeit vorgesehen. </font><font style="vertical-align: inherit;">Es wurde jedoch ein Experiment mit einem MassStorage-Ger√§t durchgef√ºhrt: Beim Kopieren einer gro√üen Datei auf ein USB-Flash-Laufwerk wurde diese entfernt. </font><font style="vertical-align: inherit;">PC h√§ngt fest. </font><font style="vertical-align: inherit;">Beim Anschlie√üen des USB-Flash-Laufwerks sackte der PC zusammen und schrieb die Datei weiter, als w√§re nichts passiert. </font><font style="vertical-align: inherit;">Die gleiche Situation war mit Token, aber mit seinen eigenen Besonderheiten. </font><font style="vertical-align: inherit;">Dies ist ein Architekturproblem. In EFI gibt es au√üer einem Timer keine Interrupts, und die Ger√§te arbeiten gem√§√ü einer Umfrage. </font><font style="vertical-align: inherit;">Das hei√üt, das System st√ºrzte irgendwo in der USB-Abfrage ab, erreichte jedoch nicht die Zeit√ºberschreitungsausgabe. Als das Ger√§t erneut angezeigt wurde, wurde es einfach fortgesetzt und der Vorgang abgeschlossen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virtualisierung</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sollten auch √ºber virtuelle Umgebungen sagen. Derzeit gibt es zwei Hauptplattformen auf dem Markt, die die Emulation der EFI-Umgebung unterst√ºtzen: VMware und VirtualBox. Beide haben ihre Vor- und Nachteile bei der Interaktion mit ihnen wie bei ‚Äûechten‚Äú Systemen. Die VMware-Umgebung bietet ausreichend Arbeit mit NVRAM-Variablen, stolpert jedoch bei der visuellen Anzeige von Nachrichten w√§hrend der Initialisierung von DXE-Modulen: Im besten Fall werden native Nachrichten bevorzugt, um bootf√§hige Medien zu finden und das zu hinterlassen, was wir ben√∂tigen. VirtualBox hingegen rendert alles, was erforderlich ist, perfekt, m√∂chte sich aber nicht an lange Variablen erinnern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer kleiner Stein im VMware-Garten - der integrierte FAT32-Treiber unterst√ºtzt das Erstellen und Bearbeiten von Dateien nur in 8.3-Notation. </font><font style="vertical-align: inherit;">Es ist nicht klar, warum dies getan wurde, aber dies ist eine Einschr√§nkung, die eindeutig Aufmerksamkeit erfordert. </font><font style="vertical-align: inherit;">Es ist wahrscheinlich, dass eine √§hnliche Implementierung des Treibers auf realen Plattformen beobachtet werden kann, aber bisher sind wir nicht auf diese gesto√üen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der anderen Seite gibt es in virtuellen Maschinen keine T√§nze mit Firmware-Dienstprogrammen, Programmierern, Jumpern und unbequemen Chips. </font><font style="vertical-align: inherit;">Eine separate ROM-Datei, UEFITool und eine Zeile in der Konfigurationsdatei. </font><font style="vertical-align: inherit;">Fast eine Idylle.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlussendlich</font></font></h4><br>
<img src="https://habrastorage.org/webt/cb/qg/va/cbqgvany9ens-l7ippxwgzox9co.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Ausschnitt aus der Anfrage von CHIPSEC. </font><font style="vertical-align: inherit;">Wo lehren sie solche Sakramente? </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erw√§hnt, ist die Entwicklung und Implementierung in der UEFI-Shell ein faszinierender und kreativer Prozess. </font><font style="vertical-align: inherit;">Selbst auf einem ber√ºhmten Feld kann man immer auf etwas Neues sto√üen. </font><font style="vertical-align: inherit;">Einerseits ist es ermutigend, dass sich der Standard weiterentwickelt, andererseits ist es traurig, dass konkrete Implementierungen durch die Produzenten zu ‚Äûkreativ‚Äú sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptprobleme waren und sind:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abweichung von Anbietern von der UEFI-Spezifikation bei der Entwicklung der Firmware.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehler im Code w√§hrend der Implementierung.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NDV im Code, Popup w√§hrend der Integration.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und nicht zuletzt das Fehlen vieler Dinge in der offiziellen (gelesenen, offenen) Dokumentation, wie zum Beispiel Beschreibungen des Protokolls f√ºr die Kommunikation mit ME √ºber PCI-Ger√§te wie MEI, HECI. </font><font style="vertical-align: inherit;">Sie finden eine Beschreibung der Register, jedoch nicht der Befehle. </font><font style="vertical-align: inherit;">Finden Sie eine GUID, aber nicht ihren Zweck. </font><font style="vertical-align: inherit;">Dies f√ºhrt erneut zu einer langen Analyse, bei der Daten und Statistiken auf Plattformen gesammelt und der Disassembler verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sollte angemerkt werden, dass sich die Situation langsam aber sicher korrigiert, und ich m√∂chte glauben, dass der Moment nicht weit entfernt ist, in dem die Entwicklung des Standards zu einem ziemlich vorhersehbaren und sehr angenehmen Prozess wird. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vladimir Onipchuk, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leiter der Gruppe der Hardware- und Softwareschutzprodukte von </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gazinformservice LLC</font></font></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493810/index.html">F√ºnf Jahre intensive Entwicklung des Marktes f√ºr Dokumentenerkennung</a></li>
<li><a href="../de493814/index.html">Wie wir Interviews in Barcelona f√ºhren</a></li>
<li><a href="../de493816/index.html">Git Guide Teilenummer 1: Alles, was Sie √ºber das .git-Verzeichnis wissen m√ºssen</a></li>
<li><a href="../de493818/index.html">Git Guide Teil Nummer 2: Die goldene Regel und andere Grundlagen der Rebase</a></li>
<li><a href="../de493820/index.html">Kubernetes Load Balancing und Skalierung langlebiger Verbindungen</a></li>
<li><a href="../de493826/index.html">Teilen und erobern: Verbesserung der Elektrolyse von Wasser</a></li>
<li><a href="../de493828/index.html">Wie die Benutzeroberfl√§che Geschichten in Videospielen erz√§hlt</a></li>
<li><a href="../de493830/index.html">Welche Fragen stellt der Junior iOS-Entwickler bei den ersten Interviews?</a></li>
<li><a href="../de493832/index.html">Coronavirus COVID-19-Verteilungs-Dashboard (React + Chart.js + BootstrapTable)</a></li>
<li><a href="../de493840/index.html">Bewertungen: Asana, Jira, Bitrix-24, Trello, YouGile. Was magst du und was macht w√ºtend?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>