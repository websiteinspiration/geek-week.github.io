<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐫 🎙️ 👩🏾‍🤝‍👨🏿 Pourquoi est-il temps d'arrêter d'utiliser JavaScript IIFE 👼🏽 👩🏿‍✈️ 🥒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La fonction Expression de fonction immédiatement invoquée (IIFE) en JavaScript est une construction qui vous permet d'appeler une fonction immédiateme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pourquoi est-il temps d'arrêter d'utiliser JavaScript IIFE</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/494868/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction Expression de fonction immédiatement invoquée (IIFE) en JavaScript est une construction qui vous permet d'appeler une fonction immédiatement après sa définition. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2s/uu/zb/2suuzb9kcp1yfpkiqt_upvzdyx0.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous comprendrons pourquoi il vaut la peine d'abandonner l'utilisation de l'IIFF, malgré ses mérites antérieurs.</font></font><a name="habracut"></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons déclarer des variables à l'intérieur de blocs autonomes</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depuis que la norme ES6 a vu le jour, nous pouvons déclarer des variables et des constantes à l'intérieur d'un bloc avec let et const. </font><font style="vertical-align: inherit;">Parallèlement à cette norme, il est également devenu possible d'allouer des variables et des constantes en blocs autonomes, inaccessibles de l'extérieur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple:</font></font><br>
<br>
<pre><code class="javascript hljs">{
 <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors x ne sera pas accessible de l'extérieur. </font><font style="vertical-align: inherit;">C'est clairement mieux que:</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
 <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<font></font>
})();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que ES6 est pris en charge par presque tous les navigateurs modernes, nous devons cesser d'utiliser IIFE pour séparer les variables du monde extérieur. </font><font style="vertical-align: inherit;">Une autre façon d'isoler les variables consiste à utiliser des modules qui n'ont désormais plus aucun problème à les supporter. </font><font style="vertical-align: inherit;">Jusqu'à ce que nous les exportions, ils ne seront pas disponibles pour d'autres modules.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons nous débarrasser de presque toutes les fermetures</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fermeture est un mécanisme par lequel une fonction se souvient de ses variables externes et peut y accéder. Si à l'intérieur de la fonction, nous en créons une autre et la renvoyons, alors la fonction retournée pourra accéder aux variables externes qui sont internes à la fonction externe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, ici, nous pouvons obtenir des effets secondaires:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> id = <span class="hljs-function">(<span class="hljs-params">(</span>) =&gt;</span> {
 <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
 <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
   ++count;<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-string">`id_<span class="hljs-subst">${count}</span>`</span>;<font></font>
 };<font></font>
})();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encore une fois, cela n'a plus de sens de clôturer tout ce jardin, car nous avons des blocs et des modules autonomes pour l'isolement des données. Nous pouvons simplement mettre tout cela dans notre propre module, alors nous n'aurons pas à nous soucier de l'accès aux données. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les fermetures provoquent des effets secondaires, ce qui n'est pas très bon, car les meilleures pratiques et le bon sens nous demandent de les éviter autant que possible. Ils rendent difficile le test de fonctions qui ne sont pas propres dans ce cas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, vous ne devez pas produire de fonctions imbriquées lorsque cela peut être évité: avec elles, le code devient plus déroutant que sans elles. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La meilleure alternative est de les remplacer par des modules:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> id = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
 ++<span class="hljs-keyword">this</span>.count;
 <span class="hljs-keyword">return</span> <span class="hljs-string">`id_<span class="hljs-subst">${count}</span>`</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le code ci-dessus, nous avons la même déclaration pour la variable count et exportons la fonction id () afin qu'elle soit disponible pour les autres modules. </font><font style="vertical-align: inherit;">Nous masquons donc count et ouvrons id (), comme nous le voulions, uniquement sans utiliser IIFE. </font><font style="vertical-align: inherit;">En conséquence, nous obtenons moins d'imbrication et nous nous débarrassons de la nécessité de définir une autre fonction et de l'exécuter.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons créer des alias pour les variables différemment.</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pourrions écrire ceci:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">window</span>.$ = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
 <span class="hljs-comment">// ...</span>
};(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>) </span>{
 <span class="hljs-comment">// ...</span>
})(jQuery);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais maintenant, il n'est plus nécessaire d'utiliser IIFE pour créer des alias. </font><font style="vertical-align: inherit;">En utilisant des modules, nous pouvons simplement importer une variable sous un nom différent, créant ainsi un alias pour elle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et puis il suffit d'écrire:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { $ <span class="hljs-keyword">as</span> jQuery } <span class="hljs-keyword">from</span> <span class="hljs-string">"jquery"</span>;
<span class="hljs-keyword">const</span> $ = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, vous ne devez pas ajouter de nouvelles propriétés à l'objet window, car cela pollue la portée globale.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons facilement obtenir un objet global.</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec l'avènement de globalThis, nous n'avons plus à nous soucier du nom de l'objet global dans divers environnements car il devient la norme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pourrions utiliser IIFE pour capturer un objet global:</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">global</span>) </span>{
 <span class="hljs-comment">// ...</span>
})(<span class="hljs-keyword">this</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais maintenant, ce n'est pas nécessaire. </font><font style="vertical-align: inherit;">Oui, et avant il était possible de s'en passer, simplement en écrivant la ligne suivante:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> globalObj = self || <span class="hljs-built_in">window</span> || global;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour être plus précis, vous pouvez écrire ceci:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> getGlobal = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
 <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> self !== <span class="hljs-string">'undefined'</span>) { <span class="hljs-keyword">return</span> self; }
 <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">'undefined'</span>) { <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>; }
 <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> global !== <span class="hljs-string">'undefined'</span>) { <span class="hljs-keyword">return</span> global; }
 <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'unable to locate global object'</span>);<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et puis, vous ne pouvez pas ajouter un appel de fonction et une imbrication supplémentaires qui apparaissent lors de l'utilisation de IIFE.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons faciliter la minification</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec les modules JavaScript, nous n'avons plus besoin de séparer le reste du code de l'IIFE afin de réduire correctement nos fichiers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webpack, Browserify, Parcel, Rollup et ainsi de suite peuvent fonctionner correctement avec les modules, nous devons donc les utiliser pour créer un code plus propre.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est temps d'arrêter d'utiliser IIFE dans notre code. </font><font style="vertical-align: inherit;">Cela ajoute des fonctionnalités supplémentaires et une imbrication redondante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, c'est maintenant un anachronisme: l'IFEF était utilisé avant même l'avènement et l'utilisation répandue des modules en JavaScript. </font><font style="vertical-align: inherit;">En 2020, nous devons utiliser des modules et des blocs autonomes pour séparer le code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour empêcher l'accès externe aux variables à l'intérieur du module, nous pouvons utiliser des étendues de bloc.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/iq/fi/b4/iqfib45pgphfrxv--zfemt0qnmw.jpeg"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr494858/index.html">À distance pour les affaires. Nous montrons, racontons, connectons</a></li>
<li><a href="../fr494860/index.html">Comment est la production de bâtons pour tester le coronavirus</a></li>
<li><a href="../fr494862/index.html">Nous optimisons la mémoire du service Rails (cas réel)</a></li>
<li><a href="../fr494864/index.html">Bureau à domicile vantant un poste</a></li>
<li><a href="../fr494866/index.html">Les réseaux 8 bits sur Elbrus, est-ce logique?</a></li>
<li><a href="../fr494874/index.html">La mise en œuvre d'algorithmes inertiels sur l'exemple de la modélisation logique des circuits numériques</a></li>
<li><a href="../fr494878/index.html">Comment choisir une école de langue étrangère ou un tuteur</a></li>
<li><a href="../fr494880/index.html">Nouveau modèle logiciel pour le code de chaîne Hyperledger Fabric</a></li>
<li><a href="../fr494882/index.html">Que faire pour ne pas chercher de nouveaux yeux après la quarantaine</a></li>
<li><a href="../fr494884/index.html">Digital Dictation 2020 se tiendra en ligne du 28 mars au 11 avril</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>