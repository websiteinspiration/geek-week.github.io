<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕🏼 🤳🏼 🥕 デジタル不死-同期インターネット 🔍 🎒 🤚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前の記事（https://habr.com/en/post/489068/）で始まったトピックを続けることを提案します。実際、彼女が20XX年に技術的特異性とデジタル不死性が現れるときにすべてがうまくいく（または人のタイプに大きく依存する）タイプの夢に夢中になっている場合、この記事とその後の記事では...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>デジタル不死-同期インターネット</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491632/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前の記事（https://habr.com/en/post/489068/）で始まったトピックを続けることを提案します。実際、彼女が20XX年に技術的特異性とデジタル不死性が現れるときにすべてがうまくいく（または人のタイプに大きく依存する）タイプの夢に夢中になっている場合、この記事とその後の記事では、幸せな未来を確実にするために可能な限りのことを行います（特異点）が速くなりました。つまり、第5世代プロセッサーの計算パラダイムを作成しました（これについては数行ありました）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「著作権」を使用して、作成されたコンピューティングパラダイムを「Rutel」と名付けます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それを理解してみましょう。根本的に新しい何かが本当に必要なのでしょうか、それともフォンノイマンの老人を「シャーマナイズ」して十分なのでしょうか。</font><font style="vertical-align: inherit;">日本人はまさに火をつけていました。彼らが新しいアーキテクチャと並列プロセッサを作ろうとしている間に、従来の直列プロセッサの生産技術は向上しました。</font><font style="vertical-align: inherit;">それらは大幅に改善されており、通常のシリアルでの並列プロセッサに期待されるすべてのパラメーターが達成されています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このようなシナリオ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><b><font style="vertical-align: inherit;">繰り返される可能性</font></b><font style="vertical-align: inherit;">は、現在多くの理由で低くなっています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">既存のアーキテクチャのバックログはすでに使い果たされています（Lebedevや他の人たちによる作業）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランジスタのサイズはすでに分子に匹敵しています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">熱放散は、実際には技術基準の低下に伴って低下することはありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセッサー周波数を上げてもパフォーマンスは向上しません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンピュータテクノロジーの開発者は、コンピュータシステムのコアの数の平凡な増加を除いて、アイデアを持っていません。</font><font style="vertical-align: inherit;">このアプローチは、「並列計算」の概念に基づいていないシステムでは生産的ではないと思います。</font><font style="vertical-align: inherit;">また、人（プログラマー）の論理的（順次）な考え方も、並列処理ではうまくいきません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定された問題を踏まえて、</font><font style="vertical-align: inherit;">有望なコンピューティングシステムに対して現在提唱されている</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要件を</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義しましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並列処理</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分布</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複雑さの問題を解決します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォールトトレランス。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デバイスの作成は、必要に応じて行われます。現代のコンピューター技術は、大量の科学およびエンジニアリングコンピューティングのニーズに応えて作成されました。現在、コンピューター技術の主な用途は、さまざまな仮想モデルの「計算」、「活性化」であり、それらの一部は実際の物理世界のオブジェクトの簡略化されたモデルであり、その他は一般に完全に仮想であり、同時にさまざまなインターフェースを通じて外界と相互作用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人の個性をそのようなシステムに移すことも現代のニーズです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォンノイマンの計算パラダイムは本質的に高度で非常に強力ですが、それでも計算機です。現代のコンピューティングテクノロジーの基礎は、人の論理的思考の「模倣」（注：論理的思考のみであり、脳全体の構造ではない）ですが、周囲の世界をシミュレートすることを意図していません。人の論理的思考は高レベルの精神プロセスであり、基本的に一貫しています。フレーズについて考えてみましょう：プログラミング言語。コンピュータシステムとの対話の基礎であるプログラミング言語は、人体の一部と論理的に接続されており、その機能の多くを継承しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、2つのフレーズを同時に発声してみてください。はい、同時に2人で完全に聞くこと（特に同様の声で）は機能しません。</font></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主なタスク</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
として、</font><font style="vertical-align: inherit;">仮想世界のオブジェクトを維持または「活性化」するタスクを実行する必要があります。</font><font style="vertical-align: inherit;">（さまざまなセンサーとマニピュレーターを介した）接続と結合された現実世界のオブジェクトのモデルと、類似体のないモデルの両方を含む仮想世界。</font><font style="vertical-align: inherit;">限界において、「新しい計算パラダイム」は、差し迫った問題を解決するための別のツールとしてではなく、私たちの物理的な世界の追加の次元のセットとして考えられるべきです。</font><font style="vertical-align: inherit;">個人（全体）はまったく同じ問題を解決する生物学的システムであることを指摘したいので、個人の人格を移すには、同じかそれ以上の機能を持つシステムが必要になります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どこから始めますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然、仮想空間の特性の仮定から始める必要があります。</font><font style="vertical-align: inherit;">今日のコンピューティング技術は、1次元空間（無限アドレス空間）で表されます。</font><font style="vertical-align: inherit;">しかし、これは3次元（+時間）の世界をモデル化するのに十分ではありません。3次元の世界では、ソリューションに「クランチ」を必要とする問題が常に生じます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現代のコンピューティングパラダイムに固有の問題の例を挙げます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ内でのオブジェクトの位置を指定した後は、再作成しないとオブジェクトのサイズを変更できません。</font><font style="vertical-align: inherit;">間接アドレス指定を使用し、デフラグとメモリ割り当てに関する問題を解決する必要があります。</font><font style="vertical-align: inherit;">スタックオーバーフローとさまざまなバッファの問題。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データプレゼンテーションシステムにデータがないという概念はありません。物理メモリ内のゴミは正当なデータであり、エラーの原因になります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別のコンピューティングシステム（オブジェクト）の概念はありません。メモリの「テープ」は1つと、それを変更するオートマトンは1つだけです。</font><font style="vertical-align: inherit;">このアプローチでは、同じプロセッサ内でもタスクの相互作用に関する問題が発生します（タスクは順次実行されます）。複数のコンピューターシステムが相互作用する必要がある場合、「処理能力」は壮大な比率に達します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの例は、大きな問題のほとんどが、最も単純な「ブリック」要素の計算パラダイムの核心にあることを理解するためだけのものです。</font><font style="vertical-align: inherit;">これらの「レンガ」は、ある時点で単一の構造を形成することを望まず、「建物」全体が崩壊します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮定</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（それらは補充され、いくつかの基本的なものに削減されます）：</font></font><br>
<br>
<ol>
<li>     «»,          «»   .</li>
<li>   «»  .    «»    (  )   «»      «»    «».  ,                  «»  .</li>
<li>      .</li>
<li>      ,          «» « »  «»,   .</li>
</ol><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単に言うと、仮想空間は、互いに接触している多次元の泡の泡です。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これらの仮定により、現実の（物理的な）または仮想の世界からシステム（相互作用するオブジェクトのセット）を作成できます。例：「アドレス」ディメンションを使用した「メモリ」オブジェクトを介したアドレスへのアクセス。このようなアドレス空間はいくつでも存在できます。アドレス指定されたオブジェクトには、さまざまなアドレス空間に対応する追加の次元があります。物理オブジェクトの形のオブジェクト「メモリ」は存在しない可能性があります（純粋に仮想モデル）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大事なポイント</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：仮説は、オブジェクトの場所、プレゼンス、ストレージデバイスの場所を示していません。アドレススペースの概念もそうではありません（単一の概念ではありません）。言えることは、潜在的な空間の存在（「泡」）だけであり、「接触」の存在によってのみ、泡自体の存在を確信することができます。 「バブル」の中で「番号」を付けることができるのは接触点だけです。連絡先がない場合、これらは完全に独立しており、理論的には互いに他のシステムに影響を与えることはありませんが、同時にすべてが元の「バブル」にあり、将来相互作用し始める可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーソナリティ転送のタスクでは、デジタル脳は、ニューロンをエミュレートするオブジェクトまたは生物の脳とのコミュニケーションのオブジェクトを含む1000億のバブルを含む1つの一般的なバブルのように見えます。</font><font style="vertical-align: inherit;">視覚的には、接触点への糸（樹状突起の軸索）の伸張（3次元空間での「泡」の投影の変形）を想像することもできます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成されたパラダイムでの通信システムの実装</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font></b> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この記事で説明するすべてのアイデアとアルゴリズムは、私の独立した完全に独立した知的活動の結果です。</font><font style="vertical-align: inherit;">著者として、私は、あらゆる種類のプロジェクトのあらゆる個人や組織に対して、私の作者であることを義務的に示し、自由に使用、変更、補足することを許可します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現代のパラダイムでは、空間を1次元のリングとして実現するのは非常に簡単です。アドレス、「書き込み」-「読み取り」の信号、および信号「読み取り」-「書き込み」。多次元の「バブル」を抱えるパラダイムの場合、「みんなで（みんなで）」（限りなく）のコミュニケーションシステムを構築する必要がありますが、もちろん不可能です。ほとんどのオブジェクトは中間ノードを介して接続されます。 「通信範囲」の分布には「通常のタイプ」があり、ノード間の距離が小さいほど、そのような接続の数が多くなります（論理的および常識的に、相互作用するオブジェクトを互いにできるだけ近くにマークする必要があります）。中間ノードを持つ通信システムの基礎は、複数のソース間で通信チャネルを多重化（分割）するためのアルゴリズムです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、物理通信チャネルの多重化アルゴリズムの動作原理を簡単に説明することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
送信されたデータは、ビーズの「散乱」として表現できます（各ビーズは固有であり、シーケンスを変更することはできません）。これは、ビーズの直径と等しい直径のチューブを通して送信する必要があります。</font><font style="vertical-align: inherit;">ビーズの供給源が1つあれば「通信管」へのアクセスに問題はなく、独占所有です。</font><font style="vertical-align: inherit;">ビーズソースが多数ある場合、それらは「チューブ」の入口で衝突する可能性があり、ビーズの出口でさえ、別々のビンに分離する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提案されたアルゴリズム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（バスなど）は次のようになります。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまなソースからのビーズを弾性糸でひもで締め、固定します（ソースごとに別々の糸）</font></font></li>
<li>  ,     ,          (   ).        ,    .</li>
<li>     ,        .</li>
<li>       (  )</li>
<li>       (        )</li>
<li>        :   ,         (        ).</li>
<li> ,           (,    ),    ,        . </li>
<li>          ,       ( ).</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビーズをチューブに入れる必要があったときに、ビーズがまだ入って来るチューブを通過しておらず、ホッパーが空だった場合は、選別アルゴリズムの一意性を確保するために、代わりに特別な「空の」ビーズを配置する必要があります。受け取り側では、空のビーズはホッパーに置かれず、単に廃棄されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次は、電気通信専門家を対象としたテキストになります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
電気通信パラダイムのすべての側面をカバーしたいという欲求のため、テキストはやや乱雑で肥大化していることが判明しました。慎重な読書が必要なもの、不正確な用語や論理的なエラーがあるかもしれません（訂正に感謝します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文字がわかりづらいので、説明を絵で補足したいのですが、きれいに描くことができません。</font><font style="vertical-align: inherit;">そんな重荷を背負いたいのなら、ありがたいです。</font><font style="vertical-align: inherit;">それに応じて、私は各図に著者のメモしか提供できません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に恐れない人のために</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ伝送ネットワークの現状。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新のデータ伝送ネットワークは、比較的低い接続強度（チャネルまたは個々のメッセージの数）向けに設計されており、同時に、時間の安定性、配信速度、仮想チャネルの作成時間、バックアップデータ転送パスを使用するのにかかる時間、および物理チャネル帯域幅の最大使用率に、弱い同時要件が課されます。このような原則に基づいて構築されたデータネットワークは、新しいコンピューティングパラダイムによって提起された要件と非常に矛盾しています。予想されるトラフィックの増加と速度要件の規模を理解するには、プロセッサースタックを介して送信されるデータとメモリ内の関連データ（ポインターはほとんどの場合スタックを通過する）の量と速度を使用して、一般的なスーパーコンピューターのコンピューティングコアの数を掛けます。これらの要件は、データネットワークの要件のより低いバーになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分散コンピューティングシステムは、相互接続された（共同計算に参加している）多数のコンピューティングモジュール（ブロック）であり、一般的なケースでは、多数の短期接続を生成します。</font><font style="vertical-align: inherit;">接続には、低い安定した待ち時間と保証された配信を組み合わせた、より高い伝送速度が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分散型（分散型）コンピュータシステムの観点からデータ伝送ネットワークに要求される要件は、システム全体のパフォーマンスは最終的にはその実装に依存します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に短い仮想チャネルの作成時間。</font><font style="vertical-align: inherit;">仮想チャネルの作成時間は、トランスミッター（ルーター）のローカルバッファーを埋める時間と同等でなければなりません。</font></font></li>
<li>                    .</li>
<li>                      .  ,                 ,     .</li>
<li>           .</li>
<li>  ,              .        ()    .</li>
<li>            (90%  ). </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的には、通信システムでは、システムの各コンポーネントを直接接続する必要がありますが、実際にはこれは不可能であり、中間ノードを介してデータを送信する必要があります。そのようなネットワークの各ノードには、（仮想チャネルへの）共有通信回線を使用して同じノードのいくつかに接続されたスイッチがあります。このような通信システムの基礎は、物理チャネルを多数の仮想チャネルに多重化（分割）し、さまざまな物理チャネルの仮想チャネル間でデータを転送するためのアルゴリズムです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
物理チャネルのこのような分離（多重化）の現在使用されている（メイン）アルゴリズム（同期階層およびパケットデータ伝送システム）は、提唱されている要件を批判的に満たしていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同期階層（SDH）の方法で作成されたチャネルは、伝送速度の安定性、衝突の欠如、およびこれらのパラメーターに対するチャネル使用率の影響の点で優れたパフォーマンスを発揮します。同時に、伝送遅延は多くのことが望まれるままになり（サイズが十分に大きいコンテナーで動作します）、作成されたチャネルのパラメーターに柔軟性がありません。コンピュータネットワークを最適に動作させるには、遅延時間（データ転送時間）が必要です。これは、物理的な距離（ケーブル長）と、要求されたデータ転送速度に比例する2つのパラメータで決定する必要があります。スイッチは、一定のスイッチング時間で同時に多数の仮想チャネル（同時に数百万まで）をサポートできる必要があります。さらに、チャネル（SHD）は、作成されたチャネルの速度に十分な柔軟性がありません。また、仮想チャネルの作成にかかる時間は、一般的に悲しい絵です（伝送遅延時間に相当する時間が必要です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パケットスイッチングを使用してもまったく意味がありません（標準形式で使用する場合）。単一の要件がまったく満たされていません（十分に大きなコンピューティングシステムの場合）。チャネル作成時間はトランスミッタ側でのみ部分的に実行され、多数の可能なルートをリアルタイムで処理することはできません。すべての接続オプションのテーブルを作成することはできません（サイズと管理コストが大きすぎる）。パケットデータ送信の遅延保証は原則として不可能です。データ転送速度の調整とアクセスの保証は、予約帯域幅を介してのみ可能です。これは、多数の仮想チャネルでは不可能です。データ損失（衝突）は、基本的にパケット転送で発生します（スイッチのバッファーの実際の値の場合）。最大物理チャネル容量に近づくと、パケットデータ伝送のすべての問題が大幅に悪化します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：分散コンピューティングシステムを最適に動作させるには、データ転送システムを構築する新しいパラダイムが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ伝送システムの基本は、レシーバーとトランスミッターの間にエンドツーエンドの仮想チャネルを構築するために、1つの物理チャネルを必要な数の仮想同期チャネルと最大同期チャネルに分割する方法（アルゴリズム）です。状況の予備分析の結果によると、最も最適なのはSDHアルゴリズムです。 SDHに固有の欠点を克服するには、このシステムを「再設計」する必要があります。 SDHアルゴリズムは、PDHで具体化されたアイデアの延長であり、PDHは固定電話システムから発展したものです。分散コンピューティングシステムの場合、125μsの持続時間を持つフレームの存在、および同じパフォーマンスの多くのチャネルへの分割（およびエンドツーエンド同期の階層も）は、まったく意味のない制限です（テレフォニーにとって、これがすべて基本の基礎でした）。コンピューティングシステムの場合、データ転送システムの最下位レベルの「TK」は次のようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースストリームを、各チャネルに指定されたビットレートで、指定された数の仮想データチャネルに分割します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
着信チャネルから発信チャネルへのペイロードの転送を確実にするために、1文字のサイズのデータ​​バッファを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一定または可変のサイズのフレームが存在することに対する明示的な要件はなく、仮想チャネルのリスト（物理チャネルが分割される）が一定である期間を決定する手段としても、フレームを導入しないことをお勧めします。フレームの概念を導入する場合、追加のチャネルの作成には、フレームのサイズによって決定される時間が必要になります。追加のアクションが実行されない場合、新しいチャネルの作成の遅延は、平均でフレーム時間の半分にトランジットスイッチの数を掛けたものになり、新しい仮想チャネルの作成（および古い仮想チャネルの削除）の時間が大幅に増加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
速度の合計のルール（仮想チャネルの速度とチャネルの管理コストの合計がプライマリチャネルの速度を超えないようにする必要があります）に従って、単一の物理チャネルを任意の伝送速度で任意の数の個別の仮想チャネルに分割する方法は？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、同期の要件、つまり個々の送信されたデータの断片間の等しい時間は、作成されるチャネルに送られるため、バッファーの最小サイズが保証されます。最小バッファーサイズの要件は、スイッチ内のスイッチクリスタルの外部にバッファーを構成できないことに起因します。 100G（400G）以上のストリームをバッファリングしてみてください。そのようなフローが10または100ある場合、最小限の不均一性でも妥当なサイズのメモリをオーバーフローし、一般的なRAMのスループットはそのような1つのストリームの速度よりも低くなります。 1つの仮想チャネル（または同じ伝送速度の複数のチャネル）を作成する場合、問題はありません（SDH）が、データ転送速度が異なる2つ以上のチャネルを作成すると、競合が発生する可能性があります。同時に、さまざまな仮想チャネルに属するデータを送信する必要があります。データ伝送システムの要件を満たすために、SDH多重化アルゴリズムを変更します。</font></font><br>
<br>
<h3>   </h3><br>
<ol>
<li>              .</li>
<li>    — .       ,           (    ),     .      :  ,      (). <br>
<br>
            .                        (   ).           (,  ,    ,     ).      (  )  ,      ,      ,      .         .         .    100     ,          .         (   )     (),             .          (     ),             . </li>
<li>   (   )      «»,       .      ,           .      .           ,    .</li>
<li>   «»  (   )           .        (   )          .</li>
<li>            .            .</li>
<li>        ,      (   )          (   ).</li>
<li>      .   (  )       «».      ,     (      ), ,    FIFO   .       ,     ,          ( ).              «» (    ),     FIFO       . <br>
<br>
 ,      (      ),    .    «»    -    .         ,    « ».    « »,    «»              FIFO   .           ,      (  ).     ,   ,       —    ,          ,      (   ). (         )</li>
<li>        32 (24)     64 /,      E1(T1). ,    PHD        .</li>
<li>       .         ( 100)    ( ).     106    .      120 .          2.5  (    )   (  ).. (                .)</li>
<li>  (   )  ,    ( )    «»  « »,       (   ).                 .       «»  « »,      .</li>
<li>        ,     « »               (          ),        « ».         « »,               .            .</li>
<li>      (    )        (         ).          .   « »         ,                () .     « »      ,       .   ,           (  ).        ,      ()   .       ,     ,         .   ,     ,            .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
物理チャネルを介して送信した後、物理チャネル間の仮想チャネルの再配置のためだけでなく、「データなし」の文字を追加または削除する必要がある可能性があるため、ストリーム全体を分解する必要があります（バッファへの文字の書き込みまたは読み取り時にのみ可能です）。データの部分的な「編集」または置換はあまり意味がありません。中間スイッチでは理解されないストリーム全体を作成する機能を追加できます-トンネル（中間スイッチのコンポーネントは理解されません）。仮想「トンネル」の作成は、代替サービスシンボルを使用してサマリーストリームを作成し（アルゴリズムは同じで、各トンネルレベルに独自のサービスシンボルのセットが必要）、結果のサマリーストリームを通常の仮想チャネルとして送信する場合に可能です。受信側では、そのようなチャネルをコンポーネントに分解するために追加の手順が必要です（分析の数は「トンネル」のレベルと同じです）。 「トンネル」を作成すると、仮想チャネルの数が減少するため、中間スイッチに必要なバッファが少なくなるため（および仮想チャネルの速度に比例するスイッチング遅延が少なくなるため）、メリットがあります。バッファの数は、スイッチを同時に通過する仮想チャネルの数を制限します。すべての物理チャネル（受信または送信用）は、任意のバッファーを使用できます（バッファーは共通リソースです）。これにより、それらの使用係数が増加します。物理的には、バッファはいくつかの文字を格納するための小さなFIFO（最大10、新しい仮想チャネルを作成する時間とデータ転送時間の最大の不均一性によって決定されます）であり、このスイッチでチャネル全体を収集または分解するモジュールの数に等しい読み取りおよび書き込みインターフェイスの数と同じです（すべての物理および仮想チャネル）、クロックサイクルあたりの呼び出しが1つだけである保証があります。バッファのクロック同期の周期は、文字の送受信の頻度と一致します。 1つのブロードバンドチャネルと多数の小さいチャネルがある場合は、大きな文字を高速チャネルに割り当て、複数のデータを一度にバッファーに書き込むことができます（または別のオプション）。説明されているアーキテクチャは非常によくカスケードされています。多くの構成オプションがあり、最適な妥協点を模索する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルチップ内に通信ネットワークを構築する場合、トランスミッターモジュールは2つのレジスター（トランスミッター側とレシーバー側に1つずつ）になり、アルゴリズム自体は変更されません。作成されたチャネルの速度と構成が一定であれば、スイッチハードウェアのサイズを大幅に最適化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体として、データ伝送ネットワークは、スイッチとポート間の通信ケーブルで構成されています。ネットワークの目的は、可能な限り最高の品質で顧客データを提供することです。クライアントは、通常のスイッチと同様のデバイスを介してネットワークに接続します。その際立った機能は、コンピューティングシステム自体のハードウェアとその大きなサイズによってデータバッファーにアクセスできることです。作成された仮想チャネルの受信データがコンピューターシステムに接続されたスイッチのバッファーに（受信用に）書き込まれるとすぐに、メカニズム（通常のコンピューターシステムの中断と同様）がオンになり、呼び出されたサービスを判別するのに十分な情報が表示されるのを待って、対応するソフトウェアが接続され、このバッファーを維持します。現代の「ネットワークカード」との違いは、多数の並列チャネル（データネットワークへの並列アクセス）を作成できることです。これにより、ネットワークから（ネットワークへ）のパケットの内部キューが、多数のコンピューティングコア（スレッド）へ（から）削除されます。 「データハンドラー」の起動の自動化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チャネルの作成は、管理（ルート検索、速度割り当て、アクセス許可など）と仮想チャネルの直接作成（データ転送が必要な場合）の2つの段階に分けることができます。最初の段階は比較的まれに実行され（ネットワークは比較的静的です）、これはアプリケーションの起動段階で事前に行うことができます。 2番目のステージは、できるだけ早く実行する必要があります。データネットワークのパフォーマンスと分散コンピューティングシステム全体のパフォーマンスを決定するのはこのステージです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想チャネルを直接作成および削除する（必要なデータはすべて最初の段階で準備されます）には、可能な限り高速で行う必要があります。チャネルの作成とデータの送信は同時に発生する必要があると言う方が正しいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムは次のようになります。最初の時点では、仮想チャネルはまだ存在せず（データの最初の部分はデータソースに関連付けられたバッファーに書き込まれます）、マルチプレクサーはそのための物理チャネル帯域幅の一部を割り当てていません。サービスチャネルしかなく、どちらを使用するかを決定する必要があります物理チャネルから新しい仮想チャネルが作成されます。仮想チャネルを作成するために十分な量のデータがバッファに表示される場合（方向と必要な速度、それらは選択肢のリストから選択されます）、目的の物理チャネルで仮想チャネルを作成するリクエストを含むデータパケットを形成し、（サービスチャネルを使用して）送信する必要があります。作成された仮想チャネルのリクエストとパラメータを含むパッケージ送信機の全チャネルの合成デバイスを通過し、選択した物理チャネルの受信機の全チャネルを解析すると、受信機と送信機の仮想チャネルのテーブルの構成が変わります。パラメータ付きのパッケージには、「チャネルの追加」サービスシンボルが含まれている必要があります。その後、コントローラは、新しい仮想チャネルが追加されたストリーム全体の送信を開始します。新しい仮想チャネルを追加する瞬間に、バッファからのデータサンプリングが始まり、作成された仮想チャネルの文字が選択されたルータのサイドに送信されます。ローカルの物理チャネルの空き帯域幅のみに基づいて、リモートスイッチに通知せずに新しいチャネルが作成されます。作成されたチャネルのパフォーマンスは、サービスチャネル（物理チャネルの空き部分）の初期パフォーマンスより常に低くなります。リソースの一部をサービスチャネルから分離することにより、新しいチャネルが作成されます。新しい仮想チャネルを作成する要求でパケットを処理（物理チャネルから受信）する場合、「チャネルの追加」シンボルを受信するまでの残り時間内に新しいチャネルのデータの保存を開始するために、利用可能な（空き）バッファのどれを決定する必要があります。リクエストをメモリに保存して後で処理することは不可能です。「チャネルの作成」シンボルを受け取った直後に（または既知の遅延で）全体のストリームの構成が変わり、作成された仮想チャネルのシンボルを含む全体のストリームが受信され始めます。これにより、全体のストリームのデコードプロセスが破棄されます（受信側のチャネルのリストの場合）。変更されません）。割り当てられたバッファからデータの送信を開始する必要がある送信物理チャネルの数を計算する時間最小にする必要があります（バッファーのサイズによって決定されます）。つまり、速度とルートのデータは、新しい仮想チャネルを作成する要求と共にパケットヘッダーに既に含まれている必要があります（外部メモリのテーブルにアクセスする時間は基本的にありません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要求のあるパケットの形成は、切り替えの方向と作成されたチャネルの速度に関するすべての必要なデータを受信した後でのみ可能です。スイッチの仮想チャネルバッファーのサイズは小さい必要があります。つまり、このデータ（次のスイッチの速度とポート番号）は送信データの最初にある必要がありますが、現在のバッファーのサイズにより、新しい合計チャネルが形成されるまで、後続のすべてのデータを保存できます。オーバーフローなし。リクエスト付きのパケットが形成された後、次のスイッチにつながる物理チャネルの番号に関するデータを含むシンボルを削除する必要があります（ルートがスイッチポートのシーケンスを指定して指定されている場合）。仮想チャネルを閉じるために、サービスチャネルを使用してパケットを転送する必要はありません。削除されたチャネルの送信データに「チャネル削除」サービスシンボルを挿入するだけで十分です。マルチプレックスチャネル合成モジュールによって「チャネルの削除」シンボルを受信すると、対応する仮想チャネルが削除され、生成された更新されたサマリーチャネルにリモート仮想チャネルが含まれなくなります。自動削除（クリーニング）、物理チャネルのパフォーマンスの「リーク」の防止のために、仮想チャネルのハードウェアバッファーに統合し、送信された文字（任意）の数のカウンターを統合し、特定の値（タイムアウト）に達すると、「クローズチャネル」シンボルを自動的に送信する必要があります。仮想チャネルの寿命を延ばすために、データに追加された「リセットカウンタ」記号を入力できます。ローカルスイッチは、チャネルの有効期間の延長を無視する場合があります。これは、物理チャネルの帯域幅の不足に対する答えになります。仮想チャネルの作成中に、空き帯域幅が不足している物理チャネルに切り替える必要がある場合、サービスチャネルの速度では新しい仮想チャネルを作成するのに十分ではないか、空きバッファがないなどの理由がない場合、要求パケットを破棄する必要があります。より正確には、失敗した仮想チャネルのすべての文字を受け取り、送信側に必要なすべてのメッセージを生成するスタブモジュールにリダイレクトされます（これらのメッセージはサービスチャネルを使用して送信されます）。実装が複雑なため、バッファリングのオプションは考慮していません。このアプローチは、長さが短いチャネルに最適です。それらの場合、配信タイムアウトは最小限であり、仮想チャネルの作成を繰り返しても、全体的なパフォーマンスに大きな影響はありません。チャネルが正常に作成された場合、起こり得ることは、機器の干渉によるデータの歪みのみです。既存のネットワーク（イーサネット）とは対照的に、パケットを送信するだけでなく、すでに最低レベルのサービスで、それが宛先まで完全に構築されていることを確認することも必要です。 「どこにも」データを送信することは一般的に誰も満足するものではなく、応答メッセージを待機してデータの配信を確認することは、必要な時間が不明であるため非常に「不愉快」です。特に大きなリソースを必要としない操作である、サービスチャネルを使用したチャネルの作成に関する通知の送信。別のオプションを実装することもできます-送信されたデータの送信元と受信者を組み合わせたリングをすぐに作成します（パケット全体がすぐに円で実行されるか、受信側のスイッチによって応答パケットが形成されます）。各中間スイッチでこのような通知（チャネルの作成に失敗した場合）を生成して、送信機がチャネルを作成できないことをできるだけ早く知ることができます。必要な速度で仮想チャネルを作成することが不可能であるときに本当にデータを再送信したくない場合は、これは非常に長い配信時間（衛星経由で地球の反対側へ）のルートに最適であり、部分配信アルゴリズムを使用してみることができます。各中間スイッチでこのような通知（チャネルの作成に失敗した場合）を生成して、送信機がチャネルを作成できないことをできるだけ早く知ることができます。必要な速度で仮想チャネルを作成することが不可能であるときに本当にデータを再送信したくない場合は、これは非常に長い配信時間（衛星経由で地球の反対側へ）のルートに最適であり、部分配信アルゴリズムを使用してみることができます。各中間スイッチでこのような通知（チャネルの作成に失敗した場合）を生成して、送信機がチャネルを作成できないことをできるだけ早く知ることができます。必要な速度で仮想チャネルを作成することが不可能であるときに本当にデータを再送信したくない場合は、これは非常に長い配信時間（衛星経由で地球の反対側へ）のルートに最適であり、部分配信アルゴリズムを使用してみることができます。次に、部分配信アルゴリズムを使用してみます。次に、部分配信アルゴリズムを使用してみます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要な速度でチャネルを作成できない場合は、速度の遅いチャネルが作成され（この速度でチャネルが作成されます）、スイッチバッファオーバーフロー時にバッファがクリアされ、バッファオーバーフローを示す記号と破棄された文字数がその中に配置されます。そのような文字を受け入れると、受信者はそのような減速のリストを作成し、それを送信機に送信します。トランスミッターは、プライマリチャネルの速度を下げ、スキップされたデータを計算し（スキップされたデータは、減速のリストとバッファーのサイズから簡単に判断できます）、最適な方法で送信します（代替ルートです）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
既存のパケット交換ネットワークでのルーティングは、パケットヘッダーのアドレス、ルートテーブル、および中間ルーターのその他のルールに基づいています。このアプローチは、ルート定義の数が比較的少なく、単一パケットの受信データをバッファリングする可能性がある場合に適しています。パケットの送信先のポート番号を決定するのに比較的長い時間がかかります。仮想チャネルの寿命が短い高速システムの場合、スイッチングテーブルのメモリへの十分なアクセス速度はありません（そして、テーブル自体のサイズは各物理チャネルごとにメガバイト単位になります-仮想チャネルの可能な最大数に等しいRAMを割り当てる必要があります）。直接法を使用してルートを説明する方が有利です物理チャネルの列挙、それを介して仮想チャネルを構築する必要があります。アドレス情報のサイズは大きくなりすぎず、中間スイッチの数は比較的少なく、8ビットが各スイッチ（物理ポートまたはトンネル番号）に割り当てられている場合、IP6アドレスのアナログを使用すると、16スイッチのルートを構築できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提案された方法の場合、テーブルは各バッファー（つまり、既存の仮想チャネルではない可能性がある既存の仮想チャネル）ごとに1バイトに変換されます。さらに、アドレスはチャネルの作成時にのみ送信されること（受信機に移動するにつれて徐々に消去される）を考慮する必要があり、仮想トンネルを使用するとルーティングコストが大幅に削減されます。物理チャネルのチェーンを構築するには、従来の検索エンジンのアナログまたは最新のネットワークからのDNSを使用して、宛先パラメーター（パラメーターのセット：IPアドレスも通常のパラメーターです）を設定すると、代替ルートを持つチェーンのセットを取得できます。相対アドレス指定により、不正アクセスに対する保護が強化され、ルートを完全に制御できます。ネットワークが機能するには、高レベルのコンポーネントの必須の存在（操作）は必要ありません。ルートは事前に設定できます（例として、常設通信システムのネットワークの場合、プリント基板上の配線-接続は変更されません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チャネルの作成が高速であり、ネットワークのサイズが大きくなる可能性があるため、直接トラフィック制御、帯域幅の割り当て（計画）などは不可能です。チャネルの負荷を分散するには、さまざまなルートの計画、仮想チャネルの使用に関する累積統計を考慮した伝送速度の割り当てなど、間接的な方法を使用する必要があります。物理チャネルが過負荷の場合、既存の仮想チャネルからのデータは破棄されず、新しいチャネルを作成するだけでは不可能です。トラフィックの性質（主に短く頻繁なメッセージ）、バックアップルートの可用性、および仮想チャネルを作成（削除）するための非常に高速な手順を考慮に入れれば、チャネルの作成を拒否してもパフォーマンスの壊滅的な低下にはつながりません。計算速度はわずかに低下します（チャネルの再作成は、接続エラーに関するメッセージまたは所定の時間の満了時に発生します）。負の統計が蓄積されると（つまり、個々のイベントに対する反応ではなく統計）、スイッチ管理ソフトウェアは接続エラーの頻度を監視し、このデータを考慮してチャネルパラメータをスケジュールします。高い確率で、輻輳自体は数百ナノ秒の時間で停止し、ルーターソフトウェアは戦略的な計画の問題に対処する必要があります。このような計画には、すでに作成されたルートを編集する機能が含まれます（データはマルチプレクサに保存されます）。そうでない場合、ルートソフトウェアを確実に再構築することはできません（ソフトウェアがまだルートの再作成を要求する場合）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
送信データのソース（レシーバー）との通信プログラム（コンピューティングプロセスのスレッド）は、スイッチと同じスキームに従って構築されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンピューティングシステムは、通信ネットワークによって統合された多数の異なる実行モジュールです。通信ネットワークは、メモリへのアクセスからキーボードの接続まで、すべてのローカルバスとインターフェイスを置き換えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコンピューティングシステムのアーキテクチャは、コンピューティングパラダイム全体を根本的に変えます（この問題については、オペレーティングシステムとソフトウェアの構造を説明する記事で後で取り上げます）。</font><font style="vertical-align: inherit;">コンピューティングアーキテクチャにおけるネットワーク機器の役割は大きく変化しています。</font><font style="vertical-align: inherit;">以前は、ネットワークが個別のコンピューターとそれらで実行されているアプリケーションを接続する方法であった場合、個別のコンピューターの概念は本質的になくなり、アプリケーションはさまざまなネットワークハードウェアリソースに「分散」できます。</font><font style="vertical-align: inherit;">管理の問題（コンピュータシステムのアクセスパラメータによるリソース管理）は、個々の実行モジュールを接続するネットワーク管理の面に完全に行き渡ります（中央プロセッサはもうありません）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">送信エラーへの対応</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も低いレベルのエラー制御は、1つ以上のエラーが発生したときに回復できる可能性がある送信文字のエンコードと見なすことができます（数はデータ送信チャネルに依存します）。それにもかかわらず、コーディングにもかかわらず、誤ったシンボル（またはシンボルのグループ）が表示される場合は、送信機と受信機の仮想チャネルのリストの同期が最も不快な影響を及ぼします。したがって、テーブルを変更する（チャネルを作成または削除する）要求は、回復の可能性が最大になります。それでも要求が失われた場合、要求の速度よりも遅い速度を持つすべての仮想チャネルのデータが歪められます。さらに、応答には2つのオプションがあり、すべての仮想チャネルを完全に破壊するか、データが歪んだ仮想チャネルのみを破壊します（失われたチャネルよりも転送レートが低い）。歪みを受けたデータに記号「エラー」を追加します（この記号は受信機によって処理されます）。非同期が検出された場合、テーブルのIDをできるだけ早く復元する必要があり、チャネルの回復時間はケーブルの長さ（2つのスイッチを接続する）によって決定する必要があります。トランスミッターからレシーバーへのテーブルの完全な送信が最も簡単なオプションですが、各テーブル編集リクエストに循環リクエスト番号を追加することをお勧めします。リクエスト番号によって、非同期化の瞬間を特定し（番号は順番に移動しない）、失われた変更を再送信するリクエストを生成します。チャネルの回復時間は、ケーブルの長さ（2つのスイッチを接続する）によって決定する必要があります。トランスミッターからレシーバーへのテーブルの完全な送信が最も簡単なオプションですが、各テーブル編集リクエストに循環リクエスト番号を追加することをお勧めします。リクエスト番号によって、非同期化の瞬間を特定し（番号は順番に移動しない）、失われた変更を再送信するリクエストを生成します。チャネルの回復時間は、ケーブルの長さ（2つのスイッチを接続する）によって決定する必要があります。トランスミッターからレシーバーへのテーブルの完全な送信が最も簡単なオプションですが、各テーブル編集リクエストに循環リクエスト番号を追加することをお勧めします。リクエスト番号によって、非同期化の瞬間を特定し（番号は順番に移動しない）、失われた変更を再送信するリクエストを生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提案された通信パラダイムは、次世代のコンピューティングシステムを構築するためだけでなく、既存のネットワークを改善するためにも使用できます。作成された仮想通信チャネルの同期と高品質のサービスは、伝送、音声、ビデオ（フェージングなし）のすべての問題を最適に解決します。特に、リアルタイムシステムや高信頼性システムでは、多くの代替ルートを作成する機能、チャネルの作成時間の厳密な制御、およびデータ配信が非常に役立ちます。パケット交換は、新しいパラダイムによって透過的にエミュレートできます。パケット送信は、一時的なチャネルの作成、データ転送、およびクローズにすぎません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パケット交換による新しいネットワークのリバースエミュレーションはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通信システムの記事をお楽しみいただけたでしょうか。読み込み中にエラーが見つかりドッキングが発生しなかった場合は、その旨をお知らせください。このテキストが、大規模な組織によって買収される新しいプロジェクトや新興企業の基礎になることを願っています。そのようなシステムをOpenCores.orgなどのコミュニティでHDLモデルとして実装したいという要望があれば、私はとても嬉しく思います（ソースを指すことを忘れないでください）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の記事では、計算パラダイムの他の側面（部分）について説明します。 「アバター」を設計する機械的な原理に関する記事が計画されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通信システムを構築するための記述されたアルゴリズムは、大きな全体の一部になることもあれば、国際標準にさえなることもあります（私は本当に望んでいます）。</font><font style="vertical-align: inherit;">ご不明な点がございましたら、具体的な物理的な実装について、「パーティーの一般的な方針に準拠しているかどうか」について回答、アドバイス、確認する準備ができています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja491620/index.html">サイプレスがオートメーションの初心者にとって優れている理由は何ですか？</a></li>
<li><a href="../ja491622/index.html">Pythonで金融危機を予測する</a></li>
<li><a href="../ja491624/index.html">Unity Universal Render Pipelineでアウトライン効果を作成する</a></li>
<li><a href="../ja491628/index.html">良いゲームデザインの例としてのSpelunky</a></li>
<li><a href="../ja491630/index.html">Firefoxブラウザ拡張アプリ（WebExtensions）</a></li>
<li><a href="../ja491634/index.html">Xbox 360の保護とハッキング（パート1）</a></li>
<li><a href="../ja491636/index.html">GRASPテンプレート：情報エキスパート</a></li>
<li><a href="../ja491638/index.html">クラウド1C。すべてが雲一つない</a></li>
<li><a href="../ja491640/index.html">ビッグデータは約束を守りますか？</a></li>
<li><a href="../ja491642/index.html">Alconostで動画を作成する方法とクライアントがこれに参加する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>