<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍃 🤫 ☂️ AndroidアーキテクチャのZen分離コンポーネント 🎭 🤜 📖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="数年前、BadooはAndroid開発にMVIアプローチを使用し始めました。これは、複雑なコードベースを簡素化し、誤った状態の問題を回避するように設計されています。単純なシナリオでは簡単ですが、システムが複雑になるほど、正しい形式で維持することが難しくなり、バグを見逃しやすくなります。  
 
 B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>AndroidアーキテクチャのZen分離コンポーネント</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/463781/"><img src="https://habrastorage.org/webt/0f/iz/h0/0fizh0eukxdsz6kb0zxcjiw5878.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数年前、BadooはAndroid開発にMVIアプローチを使用し始めました。これは、複雑なコードベースを簡素化し、誤った状態の問題を回避するように設計されています。単純なシナリオでは簡単ですが、システムが複雑になるほど、正しい形式で維持することが難しくなり、バグを見逃しやすくなります。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Badooでは、すべてのアプリケーションが非同期です。UIを介してユーザーが利用できる広範な機能のためだけでなく、サーバーが一方向のデータを送信する可能性があるためです。チャットモジュールの古いアプローチを使用して、再現するのが困難ないくつかの奇妙なバグに遭遇しました。これらのバグを取り除くためにかなりの時間を費やす必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同僚のZsolt Kocsi（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）ロンドンオフィスから、MVIを使用して、再利用が容易な独立したコンポーネントを構築する方法、得られる利点、およびこのアプローチを使用したときに遭遇する欠点について話されました。</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Badoo Androidアーキテクチャに関する一連の記事の3番目の記事です。</font><font style="vertical-align: inherit;">最初の2つへのリンク：</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotlinに基づく最新のMVIアーキテクチャ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotlinによるリアクティブコンポーネントシステムの構築</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
</li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続が不十分なコンポーネントに留まらないでください。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
弱い接続は、強いよりも優れていると考えられています。</font><font style="vertical-align: inherit;">特定の実装ではなく、インターフェースのみに依存している場合は、コンポーネントを置き換えるのが簡単になり、ほとんどのコードを書き直すことなく他の実装に切り替えるのが簡単になり、単体テストを含めて簡単になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは通常ここで終わり、接続性に関して可能な限りのことを行ったと言います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、このアプローチは最適ではありません。</font><font style="vertical-align: inherit;">他の3つのクラスB、C、およびDの機能を使用する必要があるクラスAがあるとします。インターフェイスを介してそれらを参照する場合でも、クラスAはこれらの各クラスで難しくなります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼はそれらを使用しなくても、すべてのインターフェースのすべてのメソッド、それらの名前、戻り型を知っています。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aをテストするときは、さらにモック（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モックオブジェクト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を構成する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B、C、Dがない、またはしたくない他のコンテキストでAを繰り返し使用することはより困難です。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、クラスAに必要なインターフェースの最小セットを決定する必要があるのは、まさにクラスAです（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOLID</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からのインターフェース分離の原則</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">ただし、実際には、便宜上、異なるアプローチが取られた状況に対処する必要がありました。いくつかの機能を実装する既存のクラスを取り、そのすべてのパブリックメソッドをインターフェイスに抽出し、次に、言及されたクラスが必要な場所でこのインターフェイスを使用しました。</font><font style="vertical-align: inherit;">つまり、このコンポーネントが必要とするものではなく、別のコンポーネントが提供できるものに基づいて、インターフェースが使用されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチでは、状況は時間とともに悪化します。</font><font style="vertical-align: inherit;">新しい機能を追加するたびに、クラスは、彼らが知る必要のある新しいインターフェースのWebにリンクされます。</font><font style="vertical-align: inherit;">クラスのサイズが大きくなり、テストがますます困難になっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、異なるコンテキストでそれらを使用する必要がある場合、インターフェースを介してさえ、それらが接続されているすべてのこのもつれがなければ、それらを移動することは事実上不可能です。</font><font style="vertical-align: inherit;">あなたはアナロジーを描くことができます：バナナを使いたい、それは木にぶら下がっているサルの手の中にあるので、結果として、バナナの荷の中にあなたはジャングルの全体を手に入れます。</font><font style="vertical-align: inherit;">つまり、転送プロセスには長い時間がかかり、すぐにコードを再利用することがなぜ難しいのか、すぐに考え始めます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブラックボックスコンポーネント</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントを簡単に再利用できるようにする場合は、このために次の2つのことを知る必要はありません。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それが使用される他の場所について;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部実装に関連しない他のコンポーネントについて。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その理由は明らかです。外の世界を知らなければ、それにはつながりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントに本当に必要なもの：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自の入力（入力）および出力（出力）データを定義します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このデータの出所や出所を考えないでください。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用するためにコンポーネントの内部構造を知る必要がないように、それは自己完結型でなければなりません。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントはブラックボックス、または集積回路と考えることができます。</font><font style="vertical-align: inherit;">彼女は入力と出力の連絡先を持っています。</font><font style="vertical-align: inherit;">あなたはそれらをはんだ付けします-そして、マイクロ回路はそれが何も知らないシステムの一部になります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ol/fy/04/olfy04qy7hmdfupiqifwqfx9jwa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでは、双方向のデータストリームについて話していると想定されていました。クラスAが何かを必要とする場合、インターフェイスBを介してメソッドを抽出し、関数から返された値の形式で結果を受け取ります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yb/1s/4k/yb1s4ksgh4k3adpupkm9bkiiem0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、AはBについて知っているので、これは避けたいと考えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、このようなスキームは、低レベルの実装機能では理にかなっています。</font><font style="vertical-align: inherit;">しかし、自己完結型のブラックボックスのように機能する再利用可能なコンポーネントが必要な場合は、外部インターフェイス、メソッド名、または戻り値について何も認識していないことを確認する必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一方向性に移行</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、インターフェース名とメソッドがなければ、何も呼び出すことができません！あとは、単方向のデータストリームを使用するだけです</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3p/zy/_m/3pzy_micni9yxdstnff6m3ilfxw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。この場合、</font><font style="vertical-align: inherit;">入力を取得して出力を生成するだけです</font><font style="vertical-align: inherit;">。最初はこれは制限のように見えるかもしれませんが、そのようなソリューションには多くの利点があります。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">最初の記事</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
から、</font><font style="vertical-align: inherit;">機能（Feature）は独自の入力データ（Wish）と独自の出力データ（State）を定義することがわかっています。したがって、願いがどこから来たのか、あるいは国家がどこへ行ったのかは彼らにとって重要ではありません。</font><font style="vertical-align: inherit;">
それが必要です！機能は、入力を提供できる場所ならどこでも使用でき、出力を使用すると、好きなように実行できます。また、機能は他のコンポーネントと直接通信しないため、自己完結型の無関係なモジュールです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/webt/aw/wn/c0/awwnc0nkjkhiedmyxd00ovtdhrw.png"><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ビューを取得して、それも自己完結型モジュールになるように設計します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、ビューは、内部タスクのみを処理できるように、できるだけシンプルにする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのようなタスクですか？</font><font style="vertical-align: inherit;">それらの2つがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewModelのレンダリング（入力）;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーアクション（出力）に応じてViewEventsをトリガーします。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ViewModelを使用する理由 </font><font style="vertical-align: inherit;">フィーチャーの状態を直接描画しませんか？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（非）画面に機能を表示することは、実装の詳細ではありません。</font><font style="vertical-align: inherit;">データが複数のソースからのものである場合、ビューはそれ自体をレンダリングできるはずです。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビューに状態の複雑さを反映する必要はありません。</font><font style="vertical-align: inherit;">ViewModelには、シンプルにするために必要な、すぐに表示できる情報のみを含める必要があります。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、Viewは次のことに興味を持ってはなりません。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのすべてのViewModelはどこから来るのでしょうか。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewEventがトリガーされるとどうなるか。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジネスロジック</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析追跡;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジャーナリング</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その他のタスク。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらはすべて外部タスクであり、ビューをそれらに関連付けることはできません。</font><font style="vertical-align: inherit;">停止して、ビューのシンプルさを要約しましょう。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FooView</span> : <span class="hljs-type">Consumer</span>&lt;<span class="hljs-type">ViewModel</span>&gt;, <span class="hljs-type">ObservableSource</span>&lt;<span class="hljs-type">Event</span>&gt; </span>{<font></font>
  <font></font>
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span></span>(
        <span class="hljs-keyword">val</span> title: String,
        <span class="hljs-keyword">val</span> bgColor: <span class="hljs-built_in">Int</span><font></font>
    )<font></font>
  <font></font>
    <span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Event</span> </span>{
        <span class="hljs-keyword">object</span> ButtonClicked : Event()
        <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextFocusChanged</span></span>(<span class="hljs-keyword">val</span> hasFocus: <span class="hljs-built_in">Boolean</span>) : Event()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Androidの実装は次のようにする必要があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDでAndroidビューを見つけます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewModelの値を設定して、コンシューマインターフェイスのAcceptメソッドを実装します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のイベントを生成するためにUIと対話するようにリスナー（ClickListeners）を設定します。</font></font><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooViewImpl</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
    context: Context,<font></font>
    attrs: AttributeSet? = <span class="hljs-literal">null</span>,<font></font>
    defStyle: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> events: PublishRelay&lt;Event&gt; = PublishRelay.create&lt;Event&gt;()<font></font>
) : LinearLayout(context, attrs, defStyle),<font></font>
    FooView,<font></font>
    <span class="hljs-comment">// delegate implementing ObservableSource to our Relay</span>
    ObservableSource&lt;Event&gt; <span class="hljs-keyword">by</span> events {<font></font>
     <font></font>
    <span class="hljs-comment">// 1. find the views</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> title: TextView <span class="hljs-keyword">by</span> lazy { findViewById&lt;TextView&gt;(R.id.title)}
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> panel: ViewGroup <span class="hljs-keyword">by</span> lazy { findViewById&lt;ViewGroup&gt;(R.id.panel)}
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> button: Button <span class="hljs-keyword">by</span> lazy { findViewById&lt;Button&gt;(R.id.button)}
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> editText: EditText <span class="hljs-keyword">by</span> lazy { findViewById&lt;EditText&gt;(R.id.editText)}<font></font>
     <font></font>
    <span class="hljs-comment">// 2. set listeners to trigger Events</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFinishInflate</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.onFinishInflate()<font></font>
        button.setOnClickListener { events.accept(Event.ButtonClicked) }<font></font>
        editText.setOnFocusChangeListener { _, hasFocus -&gt; events.accept(Event.TextFocusChanged(hasFocus)) }<font></font>
    }<font></font>
     <font></font>
    <span class="hljs-comment">// 3. render the ViewModel</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">accept</span><span class="hljs-params">(vm: <span class="hljs-type">ViewModel</span>)</span></span> {<font></font>
        title.text = vm.title<font></font>
        panel.setBackgroundColor(ContextCompat.getColor(context, vm.bgColor))<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能とビューに限定されない場合、このアプローチで他のコンポーネントは次のようになります。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GenericBlackBoxComponent</span> : <span class="hljs-type">Consumer</span>&lt;<span class="hljs-type">Input</span>&gt;, <span class="hljs-type">ObservableSource</span>&lt;<span class="hljs-type">Output</span>&gt; </span>{
    <span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span></span>
    <span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Output</span></span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、パターンですべてが明確になりました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pt/pi/pb/ptpipbdlny1tekgwhhgnwu3pg2q.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">団結、団結、団結！</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、異なるコンポーネントがあり、それぞれに独自の入力と出力がある場合はどうなりますか？</font><font style="vertical-align: inherit;">それらを接続します！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸いなことに、これはBinderの助けを借りて簡単に行うことができます。これは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からわかるように、正しいスコープの作成にも役立ちます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// will automatically dispose of the created rx subscriptions when the lifecycle ends:</span>
<span class="hljs-keyword">val</span> binder = Binder(lifecycle)
<span class="hljs-comment">// connect some observable sources to some consumers with element transformation:</span><font></font>
binder.bind(outputA to inputB using transformer1)<font></font>
binder.bind(outputB to inputA using transformer2)<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の利点：変更なしで拡張が容易</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一時的にのみ接続されるブラックボックスの形で無関係なコンポーネントを使用すると、既存のコンポーネントを変更せずに新しい機能を追加できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な例を見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qz/py/4j/qzpy4jxjtbnceillcf05-jay_ym.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、機能（F）とビュー（V）が単純に相互に接続されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対応するバインディングは次のようになります。</font></font><br>
<br>
<pre><code class="kotlin hljs">bind(feature to view using stateToViewModelTransformer)<font></font>
bind(view to feature using uiEventToWishTransformer)</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシステムにいくつかのUIイベントの追跡を追加するとします。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> AnalyticsTracker : Consumer&lt;AnalyticsTracker.Event&gt; {
    <span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Event</span> </span>{
        <span class="hljs-keyword">object</span> ProfileImageClicked: Event()
        <span class="hljs-keyword">object</span> EditButtonClicked : Event()<font></font>
    }<font></font>
  <font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">accept</span><span class="hljs-params">(event: <span class="hljs-type">AnalyticsTracker</span>.<span class="hljs-type">Event</span>)</span></span> {
        <span class="hljs-comment">// TODO Implement actual tracking</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
良いニュースは、ビューの既存の出力チャネルを再利用するだけでこれを実行できることです</font></font><br>
<br>
<img src="https://habrastorage.org/webt/en/sz/ld/enszldmuacqrd0e7wmumdm_duoi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。コードでは、次のようになります。</font></font><br>
<br>
<pre><code class="kotlin hljs">bind(feature to view using stateToViewModelTransformer)<font></font>
bind(view to feature using uiEventToWishTransformer)<font></font>
<span class="hljs-comment">// +1 line, nothing else changed:</span><font></font>
bind(view to analyticsTracker using uiEventToAnalyticsEventTransformer)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい機能は、追加のバインディングを1行追加するだけで追加できます。</font><font style="vertical-align: inherit;">これで、コードビューの1行を変更できるだけでなく、出力が新しい問題の解決に使用されていることさえわかりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、今では追加の心配や不必要に複雑なコンポーネントを避けるのが簡単になりました。</font><font style="vertical-align: inherit;">それらは単純なままです。</font><font style="vertical-align: inherit;">コンポーネントを既存のコンポーネントに接続するだけで、システムに機能を追加できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の利点：再利用が簡単</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィーチャーとビューの例を使用すると、バインディングを持つ1行だけで、出力データの新しい入力ソースまたはコンシューマーを追加できることがはっきりとわかります。これにより、アプリケーションのさまざまな部分でのコンポーネントの再利用が大幅に容易になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、このアプローチはクラスに限定されません。このインターフェースの使用方法により、任意のサイズの自己完結型の無効コンポーネントを記述することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の入力データと出力データに制限することで、すべてが内部でどのように機能するかを知る必要がなくなり、コンポーネントの内部をシステムの他の部分と誤ってリンクすることを簡単に回避できます。バインドしなくても、コンポーネントを繰り返し簡単に使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のいずれかの記事でこれに戻り、この手法を使用して上位レベルのコンポーネントを接続する例を検討します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の質問：バインディングをどこに置くか？</font></font></h2><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象化のレベルを選択します。</font><font style="vertical-align: inherit;">アーキテクチャに応じて、これはアクティビティ、フラグメント、または一部のViewControllerになります。</font><font style="vertical-align: inherit;">UIがない部分でも、ある程度の抽象化が行われていることを願っています。</font><font style="vertical-align: inherit;">たとえば、DIコンテキストツリーのスコープの一部。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UIのこの部分と同じレベルで、バインディングの個別のクラスを作成します。</font><font style="vertical-align: inherit;">FooActivity、FooFragment、またはFooViewControllerの場合は、その横にFooBindingsを配置できます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アクティビティやフラグメントなどで使用するのと同じコンポーネントインスタンスにFooBindingsを埋め込んでください。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バインディングのスコープを形成するには、アクティビティまたはフラグメントのライフサイクルを使用します。</font><font style="vertical-align: inherit;">このループがAndroidに関連付けられていない場合は、DIスコープを作成または破棄するときなどに、トリガーを手動で作成できます。</font><font style="vertical-align: inherit;">スコープの他の例については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明してい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
</li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の質問：テスト</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントは他のコンポーネントについて何も認識していないため、通常は代わりにスタブは必要ありません。</font><font style="vertical-align: inherit;">テストは、入力データに対するコンポーネントの正しい応答を検証し、期待される結果を生成するために簡略化されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィーチャーの場合、これは次のことを意味します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定の入力が期待される状態（出力）を生成するかどうかをテストする機能。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてビューの場合：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のViewModel（入力）がUIの予想される状態につながるかどうかをテストできます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UIとの相互作用のシミュレーションが、予想されるViewEvent（出力）で初期化されるかどうかをテストできます。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、コンポーネント間の相互作用は魔法のように消えません。</font><font style="vertical-align: inherit;">これらのタスクをコンポーネント自体から抽出しました。</font><font style="vertical-align: inherit;">彼らはまだテストする必要があります。</font><font style="vertical-align: inherit;">しかしここで？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、バインダーはコンポーネントを接続する責任があります：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// this is wherever you put your bindings, depending on your architecture</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BindingEnvironment</span></span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> component1: Component1,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> component2: Component2<font></font>
) {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createBindings</span><span class="hljs-params">(lifecycle: <span class="hljs-type">Lifecycle</span>)</span></span> {
        <span class="hljs-keyword">val</span> binder = Binder(lifecycle)<font></font>
        binder.bind(component1 to component2 using Transformer())<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストでは、次のことを確認する必要があります</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。1.トランスフォーマー（マッパー）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部の接続にはマッパーがあり、要素が正しく変換されることを確認する必要があります。</font><font style="vertical-align: inherit;">通常、マッパーも非常に単純であるため、ほとんどの場合、非常に単純な単体テストで十分です。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testCase1</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> transformer = Transformer()
    <span class="hljs-keyword">val</span> testInput = TODO()
    <span class="hljs-keyword">val</span> actualOutput = transformer.invoke(testInput)
    <span class="hljs-keyword">val</span> expectedOutput = TODO()<font></font>
    assertEquals(expectedOutput, actualOutput)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.コミュニケーション。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接続が正しく構成されていることを確認する必要があります。</font><font style="vertical-align: inherit;">何らかの理由でそれらの間の接続が確立されていない場合、個々のコンポーネントとマッパーの作業のポイントは何ですか？</font><font style="vertical-align: inherit;">これはすべて、スタブ、初期化ソースを使用してバインディング環境をセットアップし、期待される結果がクライアント側で受信されるかどうかを確認することによってテストできます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BindingEnvironmentTest</span> </span>{
    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> component1: ObservableSource&lt;Component1.Output&gt;
    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> component2: Consumer&lt;Component2.Input&gt;
    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> bindings: BindingEnvironment<font></font>
  <font></font>
    <span class="hljs-meta">@Before</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">val</span> component1 = PublishRelay.create()
        <span class="hljs-keyword">val</span> component2 = mock()
        <span class="hljs-keyword">val</span> bindings = BindingEnvironment(component1, component2)<font></font>
    }<font></font>
  <font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testBindings</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">val</span> simulatedOutputOnLeftSide = TODO()
        <span class="hljs-keyword">val</span> expectedInputOnRightSide = TODO()<font></font>
        component1.accept(simulatedOutputOnLeftSide)<font></font>
        verify(component2).accept(expectedInputOnRightSide)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、テストの場合、他のアプローチと同じ量のコードを記述する必要がありますが、タスクが明確に分離されているため、自己完結型のコンポーネントにより、個々のパーツのテストが容易になります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">思考の糧</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブラックボックスのグラフの形でのシステムの説明は一般的な理解には役立ちますが、これはシステムのサイズが比較的小さい場合にのみ機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5〜8本の結合線が許容されます。しかし、接続数が増えると、何が起こっているのかを理解するのがかなり難しくなります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x6/88/du/x688duddke2ejaf65ywgz60u4ic.png"><br>
<br>
<img src="https://habrastorage.org/webt/93/lm/wl/93lmwld0ldslgadh1kre2n2uvou.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接続数が増えると（表示されたコードフラグメントよりもさらに多く）、状況はさらに複雑になるという事実に直面しました。その理由は、行の数だけではなく、ある種類のバインディングをグループ化してさまざまな方法で抽出できることだけでなく、すべてを表示することがますます難しくなるためでもありました。そして、これは常に悪い兆候です。数十の異なるコンポーネントが同じレベルに配置されている場合、考えられるすべての相互作用を想像することは不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その理由は、コンポーネントの使用です-ブラックボックスまたは他の何か？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、記述しているスコープが最初は複雑である場合、システムをより小さな部分に分割するまで、前述の問題からあなたを救う方法はありません。バインディングの巨大なリストがなくても複雑になりますが、それほど明白ではありません。さらに、難易度が明示され、隠されていない場合は、はるかに優れています。さまざまなメソッド呼び出しでクラス内に隠されているリンクについて知らないよりも、個別のコンポーネントがいくつあるかを思い出させる単一行の結合の増加するリストを確認することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネント自体は単純であるため（ブラックボックスであり、追加のプロセスはコンポーネントに流れ込みません）、コンポーネントを分離しやすくなり、これは正しい方向への一歩です。</font><font style="vertical-align: inherit;">難易度を1か所に移動しました-バインディングのリスト。一般的な状況を評価し、この混乱から抜け出す方法について考えることができるように一目で確認できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策の検索には多くの時間がかかりましたが、それはまだ進行中です。</font><font style="vertical-align: inherit;">この問題への対処方法については、以下の記事で説明する予定です。</font><font style="vertical-align: inherit;">連絡を取り合う！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja463769/index.html">Mitap Netologii「データサイエンスのキャリア：初心者から中級者まで」</a></li>
<li><a href="../ja463771/index.html">[ピーター]セバスチャンダシュナーとJUG.ruとの出会い-エンタープライズテストの作成をより楽しくする</a></li>
<li><a href="../ja463773/index.html">情報からの子供の保護の仕組み-そしてそれが最初にどこから来たのかについての魅惑的な物語（18+）</a></li>
<li><a href="../ja463775/index.html">誰がSAML 2.0認証プロトコルを使用するか</a></li>
<li><a href="../ja463777/index.html">Powershellホストの可用性の監視</a></li>
<li><a href="../ja463785/index.html">端末エミュレーターの概要</a></li>
<li><a href="../ja463787/index.html">HPの大きな古い驚き</a></li>
<li><a href="../ja463789/index.html">Swiftにおけるジェネリックの力。パート2</a></li>
<li><a href="../ja463791/index.html">アイアングリップ：ジオメトリと表面テクスチャに応じた鳥の着陸の運動学</a></li>
<li><a href="../ja463795/index.html">英語の意味の濃淡：動詞の使い方アドバイス、推奨、提案</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>