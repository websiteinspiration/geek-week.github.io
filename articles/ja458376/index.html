<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍⚕️ 🏒 ㊙️ 別のプログラミング言語ではありません。パート1：ドメインロジック ♓️ 🚵🏾 💂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近、多数の新しいプログラミング言語が市場に登場しました：Go、Swift、Rust、Dart、Julia、Kotlin、Hack、Bosque-これは聞いたものの1つにすぎません。
 これらの言語がプログラミングの世界にもたらすものの価値を過大評価することは困難ですが、Y Combinator が...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>別のプログラミング言語ではありません。パート1：ドメインロジック</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lsfusion/blog/458376/"><img src="https://habrastorage.org/webt/0h/1q/o8/0h1qo8v-kpvk8vbrbtlzwvm4gai.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近、多数の新しいプログラミング言語が市場に登場しました：Go、Swift、Rust、Dart、Julia、Kotlin、Hack、Bosque-これは聞いたものの1つにすぎません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの言語がプログラミングの世界にもたらすものの価値を過大評価することは困難ですが、</font><font style="vertical-align: inherit;">Y Combinator </font><font style="vertical-align: inherit;">が昨年</font><font style="vertical-align: inherit;">、開発ツールについて話す際に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指摘したように</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレームワークは良くなり、言語は少し賢くなりましたが、基本的には同じです。</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事では、上に挙げたものを含め、既存のすべての言語で使用されているアプローチとは根本的に異なるアプローチに基づいて構築された言語について説明します。概して、この言語は汎用言語と見なすことができますが、その機能の一部とその上に構築されたプラットフォームの現在の実装は、それでも、おそらくそのアプリケーションを少し狭い領域、つまり情報システムの開発に制限します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はすぐに予約します。それはアイデア、プロトタイプ、またはMVPについてではなく、開発環境（デバッガー付き）から複数バージョンの言語の自動サポート（それらの間の自動マージバグ修正を含む）まで、必要なすべてのインフラストラクチャ言語を備えた本格的な本番対応言語に関するものです。 、リリースノートなど）。さらに、この言語を使用して、ERPレベルの複雑な数十のプロジェクトがすでに実装されており、数百人の同時ユーザー、テラバイトデータベース、「昨日の期限」、限られた予算、ITの経験のない開発者がいます。そして、これらすべてを同時に。もちろん、現在は2000年ではなく、これらすべてのプロジェクトは既存のシステム（存在していなかった）の上に実装されたことに注意してください。つまり、最初はビジネスを停止することなく、「そのまま」徐々に実行する必要があり、その後、また徐々に「あるべき姿」を作ります。一般的に、これは最初の電気自動車をカリフォルニアの裕福な流行に敏感な人ではなく、オムスクのどこかで低価格のタクシーサービスに販売する方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この言語で構築されたプラットフォームは、LGPL v3ライセンスの下でリリースされます。</font><font style="vertical-align: inherit;">正直に言って、冒頭でこれを書きたくなかったのは、これが最も重要な利点とはほど遠いためですが、主要な潜在市場の1つであるERPプラットフォームで働いている人々と話すと、1つの機能に気づきました。すでに市場に出ているものと同じことをしても、無料で、それはすでに非常にクールです。</font><font style="vertical-align: inherit;">ここに残してください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理論のビット</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、この言語と他の現代言語で使用されている基本的なアプローチの違いを強調する理論から始めましょう。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小さな免責事項、ある程度のさらなる考慮事項は、地球上のフクロウを引っ張る試みですが、プログラミングの基本的な理論では、原則として、実際にはそうではなく、率直に言ってみましょう。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラミングによって解決される最初の主要なタスクの1つは、関数の値を計算するタスクです。計算理論の観点から、この問題を解決するための2つの根本的に異なるアプローチがあります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のそのようなアプローチは、さまざまなマシンです（最も有名なのはチューリングマシンです）。現在の状態（メモリ）とマシン（プロセッサ）で構成されるモデルで、各ステップでこの現在の状態を何らかの方法で変更します。このアプローチはフォンノイマンアーキテクチャとも呼ばれ、すべての最新のコンピューターと既存の言語の99％の基礎となっているのは彼です。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のアプローチは演算子の使用に基づいており、いわゆる</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">部分的に再帰的な関数</font></a><font style="vertical-align: inherit;">によって使用され</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（さらにChRF）。さらに、このアプローチの最も重要な違いは、演算子自体の使用（たとえば、演算子は最初のアプローチを使用した構造プログラミングにもあります）ではなく、関数のすべての値を反復する可能性（引数を最小化する演算子を参照）および状態が存在しない場合です。計算プロセス。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チューリングマシンと同様に、部分的に再帰的な関数はチューリング完全です。つまり、可能な計算を指定するために使用できます。ここでは、チューリングマシンとCRFの両方が最小限のベースにすぎないことをすぐに明確にします。次に、それらをアプローチと同じように説明します。それぞれ機能します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプローチとしてのCRFには、3つの主な利点があります。</font></font><br>
<br>
<ul>
<li>   .         ,      .      , ,       .<br>
</li>
<li>   ,         ,         ,     .  ,      ,       ,        ,    .<br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理解しやすいです。</font><font style="vertical-align: inherit;">つまり、大まかに言えば、他の2つのインジケーターのコンテキストで1つのインジケーターの合計を計算する関数の説明は、最初のアプローチで説明した場合よりもはるかに理解しやすくなります。</font><font style="vertical-align: inherit;">ただし、アルゴリズム的に複雑な問題では状況は正反対ですが、5％であれば、大部分の領域でアルゴリズム的に複雑な問題が適切であることは注目に値します。</font><font style="vertical-align: inherit;">一般的に、少し要約すると、CRFは数学であり、チューリングマシンはコンピュータサイエンスです。</font><font style="vertical-align: inherit;">したがって、数学はほとんど幼稚園で研究されており、コンピュータサイエンスは任意であり、高校からです。</font><font style="vertical-align: inherit;">もちろんまあまあの比較ですが、それでもこの問題については何らかのメトリックが得られます。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チューリングマシンには少なくとも2つの利点があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズム的に複雑な問題における最高の適用性についてはすでに述べた</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最近のコンピュータはすべて、このアプローチに基づいて構築されています。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、この比較では、データ計算タスクについてのみ話しているため、データの変更の問題では、チューリングマシンはうまくいっていません。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場所を読んだ後、注意深い読者は、「CRFアプローチが非常に優れているのに、なぜ一般的な現代言語で使用されていないのですか？」したがって、実際には、これはそうではなく、既存の情報システムの大部分で使用されている言語で使用されています。ご想像のとおり、この言語はSQLです。ここで、もちろん、同じ注意深い読者は、SQLがリレーショナル代数の言語であること（つまり、関数ではなくテーブルを操作すること）に反対し、それは正しいでしょう。正式に。実際、DBMSのテーブルは通常第3正規形であること、つまりキー列があることを思い出すことができます。つまり、このテーブルの残りの列はすべて、キー列の関数と見なすことができます。明白ではありませんが、率直に言って。その後なぜSQLがリレーショナル代数言語から本格的なプログラミング言語に成長していないのか（つまり、関数の操作）は大きな問題です。私の意見では、これには多くの理由がありますが、最も重要なのは、「ロシア人（実際には誰でも）が空腹で作業することはできませんが、十分に給餌された胃で作業することを望んでいない」ということです。それは本当にタイタニックであり、小企業にとって、そして大企業にとって、あまりにも多くのリスクを伴います-第一に、すべてがうまく、第二に、この仕事をお金で強制することは不可能です-品質は量より重要です。実際、人々が問題を解決しようとすると何が起こるかを示す最も明白なイラスト最も重要なのは、「ロシア人（実際には誰でも）が空腹で作業することはできないが、完全な胃を望んでいないこと」です。これは、練習で示されているように、これに必要な作業は非常に強力であり、リスクが多すぎるという意味です中小企業にとっても、大企業にとっても、第一にすべてが順調であり、第二に、この仕事にお金をかけることは不可能です。ここでは、量よりも質の方が重要です。実際、人々が問題を解決しようとすると何が起こるかを示す最も明白なイラスト最も重要なのは、「ロシア人（実際には誰でも）が空腹で作業することはできないが、完全な胃を望んでいないこと」です。これは、練習で示されているように、これに必要な作業は非常に強力であり、リスクが多すぎることを意味します。中小企業にとっても、大企業にとっても、第一にすべてが順調であり、第二に、この仕事にお金をかけることは不可能です。ここでは、量よりも質の方が重要です。実際、人々が問題を解決しようとすると何が起こるかを示す最も明白なイラストお金でこれを強制することは不可能です—量よりも質が重要です。実際、人々が問題を解決しようとすると何が起こるかを示す最も明白なイラストお金でこれを強制することは不可能です—量よりも質が重要です。実際、人々が問題を解決しようとすると何が起こるかを示す最も明白なイラスト</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">品質</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">なく量</font></a><font style="vertical-align: inherit;">はOracleであり、インクリメンタルの最も基本的なアプリケーション（更新された実体化された表現）を実装することさえできたため、このメカニズムに</font><font style="vertical-align: inherit;">は数ページのサイズ</font><font style="vertical-align: inherit;">の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制限</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がいくつかあります（公平に言えば、Microsoftはさらに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悪いです</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。ただし、これは別の話であり、おそらく別の記事があるでしょう。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、SQLが悪いということではありません。番号。抽象化のレベルでは、その機能は完全に実行され、現在のプラットフォームの実装では、完全にではなく（他のすべてのプラットフォームよりもはるかに）使用されています。もう1つは、SQLはその誕生直後に実際に開発が中止され、実際にSQLになることができなかった、つまり、これから説明する言語になったことです。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、十分な理論があります。今こそ言語に直接行く時です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、私たちは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会い</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fc/3c/fl/fc3cfl_xss6ocbakmm6jz7p37ng.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
具体的には、この記事は3つのうちの最初の部分（2つの記事でも、まだ資料が多すぎるため）であり、論理モデルについてのみ説明します。つまり、システムの機能に直接関連し、プロセスとは何の関係もありません。開発と実装（パフォーマンスの最適化）。さらに、論理モデルの2つの部分のうちの1つ、つまり対象領域の論理についてのみ説明します。このロジックは、システムが格納する情報と、この情報を使用して何ができるかを決定します（ビジネスアプリケーションを開発する場合、ビジネスロジックとも呼ばれます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフィカルに、lsFusionのドメインロジックのすべての概念は、次の図で表すことができます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/6a/na/tm/6anatmmbhaojzaqbyfeygcbsx4i.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この写真の矢印は、それぞれの概念が使用する方向を示しているため、概念は一種のスタックを形成しているので、このスタックの順に説明します。 </font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目次</font></font></b><div class="spoiler_text"><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  (DATA)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> (JOIN), ,  (+,-,/,*),  (AND, OR),  (+, CONCAT),  (&gt;,&lt;,=),  (CASE, IF),   (IS)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> (GROUP)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> /  (PARTITION … ORDER)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> (RECURSION)</a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> (FOR),   (WHILE)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> (EXEC),  ({…}),  (CASE, IF),  (BREAK),  (RETURN)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  (CHANGE)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  (NEW)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  (DELETE)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  (NEWSESSION, NESTEDSESSION)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  (APPLY),   (CANCEL)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">    (PREV, CHANGED, SET, DROPPED)</a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a></li>
</ul></div></div><br>
<a name="property"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロパティは、1つ以上のオブジェクトをパラメーターとして取り、結果としていくつかのオブジェクトを返す抽象化です。このプロパティには後遺症はなく、実際には純粋な関数ですが、後者とは異なり、値を計算するだけでなく保存することもできます。実際、「プロパティ」自体の名前は他の現代のプログラミング言語から借用されたもので、ほぼ同じ目的で使用されていますが、カプセル化に対応しているため、1つのパラメーターを持つ関数でのみサポートされます。さて、この「プロパティ」という言葉は「純粋な関数」よりも短いという事実に加えて、不必要な関連付けがないため、この言葉を使用することに賛成です。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロパティは、事前定義された演算子のセットを使用して再帰的に設定されます。</font><font style="vertical-align: inherit;">これらのオペレーターはたくさんあるので、主要なオペレーターのみを検討します（これらのオペレーターは平均的な静的プロジェクトの95％をカバーします）。</font></font><br>
<br>
<a name="data"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プライマリプロパティ（DATA）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プライマリプロパティは、データベースに値が格納されているプロパティであり、対応するアクションの結果として変更できます（少し後で）。</font><font style="vertical-align: inherit;">デフォルトでは、パラメータセットのそのような各プロパティの値は、特別なNULL値と同じです。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>quantity&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">INTEGER</font>&nbsp;(Item);<br>
isDayOff&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">BOOLEAN</font>&nbsp;(Country,&nbsp;<font color="#a626a4">DATE</font>);<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プライマリプロパティ演算子を使用する場合、作成したプロパティが入力として受け入れるクラス（クラス自体についても少し後で）と、このプロパティが返すことができる値のクラスを指定する必要があります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、この演算子は、フィールドとコレクションを現代の言語で一般化します。</font><font style="vertical-align: inherit;">そう：</font></font><br>
 <br>
<pre><code class="java">class X { 	<font></font>
    Y y; 	<font></font>
    Map&lt;Y, Z&gt; f; 	<font></font>
    Map&lt;Y, Map&lt;M, Z&gt;&gt; m; 	<font></font>
    List&lt;Y&gt; n;<font></font>
    LinkedHashSet&lt;Y&gt; l; //   <font></font>
    static Set&lt;Y&gt; s;<font></font>
}<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
に相当：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>y&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;Y&nbsp;(X);<br>
f&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;Z&nbsp;(X,&nbsp;Y);<br>
m&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;Z&nbsp;(X,&nbsp;Y,&nbsp;M);<br>
n&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;Y&nbsp;(X,<font color="#a626a4">INTEGER</font>);<br>
l&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">INTEGER</font>&nbsp;(X,Y);<br>
s&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">BOOLEAN</font>&nbsp;(Y);<br>
</code></td>
</tr>
</tbody></table></div><a name="rest"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成（JOIN）、定数、算術（+、-、/、*）、論理（AND、OR）、文字列（+、CONCAT）、比較（&gt;、&lt;、=）、選択肢（CASE、IF）、クラスに属する（IS）</font></font></h3><div class="scrollable-table"><table>
<tbody><tr>
<td><code>f(a)&nbsp;=&nbsp;<font color="#a626a4">IF</font>&nbsp;g(h(a))&nbsp;&gt;&nbsp;<font color="#986801">5</font>&nbsp;<font color="#a626a4">AND</font>&nbsp;a&nbsp;<font color="#a626a4">IS</font>&nbsp;X&nbsp;<font color="#a626a4">THEN</font>&nbsp;‘AB’&nbsp;+&nbsp;‘CD’&nbsp;<font color="#a626a4">ELSE</font>&nbsp;x(<font color="#986801">5</font>);<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここではすべてが多かれ少なかれ標準であるため、これらの演算子を詳細に停止することはあまり意味がありません。</font><font style="vertical-align: inherit;">おそらく注目に値する唯一のもの：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">論理演算子と選択演算子では、条件として、論理型の値を持つプロパティだけでなく、一般的なプロパティを使用できます。</font><font style="vertical-align: inherit;">したがって、この場合の条件は、プロパティ値の確実性（つまり、NULLとの差）です。</font><font style="vertical-align: inherit;">実際には、lsFusion自体の論理型は実際には定数です。つまり、その値のセットは正確に1つの要素で構成されています-真の値（偽の役割はNULLです）、屋根のある3状態はありません。</font></font><br>
</li>
<li>          NULL: (+), (-), CONCAT  .    :<br>
<ul>
<li>  : NULL     0,    – , 0   NULL (  5 (+) NULL = 5, 5 (-) 5 = NULL,  5 + NULL = NULL  5 — 5 = 0).<br>
</li>
<li>  : NULL         (  CONCAT ‘ ‘, ‘John’,’Smith’ = ‘John Smith’,  CONCAT ‘ ‘, ‘John’, NULL = ‘John’,  ‘John’ + ‘ ‘ + NULL = NULL).<br>
</li>
</ul></li>
<li>    (IF)  (   )  : f(a) IF g(a),   f(a)  g(a)  NULL,  NULL –   . <br>
</li>
</ul><br>
<a name="group"></a><h3> (GROUP)</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グループ化は、最も一般的に使用されるセット演算子です。</font><font style="vertical-align: inherit;">この演算子はプロパティを受け取り、そのすべての値について、他のプロパティの値のコンテキストでいくつかの集計関数（たとえば、合計）を計算します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構文に関して、この演算子には2つの形式があります。</font></font><br>
 <br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能的： </font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>sum(Invoice&nbsp;i)&nbsp;=&nbsp;<font color="#a626a4">GROUP</font>&nbsp;<font color="#a626a4">SUM</font>&nbsp;sum(InvoiceDetail&nbsp;id)&nbsp;<font color="#a626a4">IF</font>&nbsp;invoice(id)&nbsp;=&nbsp;i;<br>
currentBalance(Sku&nbsp;sk)&nbsp;=&nbsp;<font color="#a626a4">GROUP</font>&nbsp;<font color="#a626a4">SUM</font>&nbsp;currentBalance(sk,&nbsp;Stock&nbsp;st);</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この形式では、字句コンテキストを閉じることができます。つまり、演算子の内部では、外部コンテキストのパラメーターを使用できます（上記の例では、パラメーターiおよびsk）。</font><font style="vertical-align: inherit;">関数形の特徴は、式で使用できることです。つまり、次のようなものを書くことができます。</font></font><div class="scrollable-table"><table>
<tbody><tr>
<td><code>x()&nbsp;=&nbsp;(<font color="#a626a4">GROUP</font>&nbsp;<font color="#a626a4">SUM</font>&nbsp;f(a))&nbsp;+&nbsp;<font color="#986801">5</font>;</code></td>
</tr>
</tbody></table></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLスタイル：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>sum&nbsp;=&nbsp;<font color="#a626a4">GROUP</font>&nbsp;<font color="#a626a4">SUM</font>&nbsp;sum(InvoiceDetail&nbsp;id)&nbsp;<font color="#a626a4">BY</font>&nbsp;invoice(id);<br>
currentBalance&nbsp;=&nbsp;<font color="#a626a4">GROUP</font>&nbsp;<font color="#a626a4">SUM</font>&nbsp;currentBalance(Sku&nbsp;sk,&nbsp;Stock&nbsp;st)&nbsp;<font color="#a626a4">BY</font>&nbsp;sk;</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数とは異なり、この形式の演算子は、プロパティを宣言するときにのみ使用できます（たとえば、プライマリプロパティを作成する演算子など）。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードの簡潔さの観点から、グループ化がパラメーター（例：残りの部分）の場合は最初の形式を使用し、2番目はプロパティ（例：請求書）の場合を使用するのが理にかなっています。</font><font style="vertical-align: inherit;">概して、これはまだ好みの問題ですが、より親しみやすいものです（関数型プログラミングでより多くの作業をした人にとって、最初のフォームはSQLで作業している人にとってはより馴染みがあります-2番目）。</font><font style="vertical-align: inherit;">ちなみに、必要に応じて、これらの形式を組み合わせて使用​​できます（つまり、上位パラメーターにアクセスしてBYオプションを使用できる場合）。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#808080"><i>//&nbsp;BY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;s</i></font><br>
sum(<font color="#a626a4">DATE</font>&nbsp;from,&nbsp;Stock&nbsp;s,&nbsp;<font color="#a626a4">DATE</font>&nbsp;to)&nbsp;=&nbsp;<font color="#a626a4">GROUP</font>&nbsp;sum(Invoice&nbsp;i)&nbsp;<font color="#a626a4">IF</font>&nbsp;date(i)&nbsp;&gt;=&nbsp;from&nbsp;<font color="#a626a4">AND</font>&nbsp;date(i)&nbsp;&lt;=to&nbsp;<font color="#a626a4">BY</font>&nbsp;stock(i);&nbsp;<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、正直に言うと、このようなマッピングは暗に暗示されているため、これを行うことはお勧めしません。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
集計関数として、金額に加えて、以下もサポートされています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大/最小</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定された順序での文字列連結</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定された順序の最後の値。 </font></font><br>
</li>
</ul><br>
<a name="partition"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パーティショニング/整理（PARTITION ... ORDER）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のグループ化演算子は、システム内のすべてのオブジェクト（またはオブジェクトのセット）をグループに分割し、その後、各グループの特定の値を計算します。</font><font style="vertical-align: inherit;">ただし、場合によっては、値をグループ自体ではなく、直接グループ化されたオブジェクトのセットに対して計算する必要があります（ただし、このセットが属するグループのコンテキストで計算する必要があります）。</font><font style="vertical-align: inherit;">この種の計算を実行するために、言語には特別な分割/順序付け演算子が存在します。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>place(Team&nbsp;t)&nbsp;=&nbsp;<font color="#a626a4">PARTITION</font>&nbsp;<font color="#a626a4">SUM</font>&nbsp;<font color="#986801">1</font>&nbsp;<font color="#a626a4">ORDER</font>&nbsp;<font color="#a626a4">DESC</font>&nbsp;points(t)&nbsp;<font color="#a626a4">BY</font>&nbsp;conference(t);<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的に言って、分割は順序付けなしで実行でき、分割せずに順序付けできますが、それでも、ほとんどの場合、これらの操作は一緒に実行されるため、1つの演算子に結合されます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQLでのこの演算子（およびそれが実装される手段）に類似するのは、ウィンドウ関数（OVER PARTITION BY ... ORDER BY）です。</font></font><br>
<br>
<a name="recursion"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再帰（RECURSION）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再帰は、セットを処理するためのおそらく最も複雑な演算子です。</font><font style="vertical-align: inherit;">特にグラフを操作するには、事前に不明な反復回数で計算を実装する必要があります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再帰演算子の場合、初期プロパティとステッププロパティを指定する必要があります。</font><font style="vertical-align: inherit;">したがって、この演算子を計算するためのアルゴリズムは次のとおりです（以下、ドキュメントからほぼ逐語的に引用）。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初に、中間プロパティ（結果）は、次のように追加の最初のパラメーター（操作番号）で再帰的に構築されます。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果（0、o1、o2、...、oN）= initial（o1、...、oN）、ここで、initialは初期プロパティです</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果（i + 1、o1、o2、...、oN）=ステップ（o1、...、oN、$ o1、$ o2、...、$ oN）IF結果（i、$ o1、$ o2 、...、$ oN）、stepはステップのプロパティです。</font></font><br>
</li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、取得されたプロパティのすべての値について、操作番号を除くすべてのパラメーターのコンテキストで合計が計算されます（つまり、o1、o2、...、oN）。</font><font style="vertical-align: inherit;">理論的には、合計の代わりに任意の集計関数を使用できますが、現在の実装では合計のみがサポートされています。</font></font><br>
</li>
</ul> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も明白な定義ではありませんが、率直に言って、この演算子の本質は例からおそらく理解しやすいでしょう：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#808080"><i>//&nbsp;&nbsp;&nbsp;integer&nbsp;&nbsp;from&nbsp;&nbsp;to&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System)</i></font><br>
iterate(i,&nbsp;from,&nbsp;to)&nbsp;=&nbsp;<font color="#a626a4">RECURSION</font>&nbsp;i=from&nbsp;<font color="#a626a4">STEP</font>&nbsp;i=$i+<font color="#986801">1</font>&nbsp;<font color="#a626a4">AND</font>&nbsp;i&lt;=to <font color="#a626a4">CYCLES</font>&nbsp;<font color="#a626a4">IMPOSSIBLE</font>;<br>
&nbsp;<br>
<font color="#808080"><i>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;(&nbsp;,&nbsp;&nbsp;,&nbsp;&nbsp;)</i></font><br>
edge&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">BOOLEAN</font>&nbsp;(Node,&nbsp;Node);<br>
pathes&nbsp;<font color="#50a14f">'-&nbsp;'</font>&nbsp;(a,&nbsp;b)&nbsp;=&nbsp;<font color="#a626a4">RECURSION</font>&nbsp;<font color="#986801">1</font>&nbsp;<font color="#a626a4">IF</font>&nbsp;b=a&nbsp;<font color="#a626a4">STEP</font>&nbsp;<font color="#986801">1</font>&nbsp;<font color="#a626a4">IF</font>&nbsp;edge(b,&nbsp;$b);<br>
&nbsp;<br>
<font color="#808080"><i>//&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child&nbsp;&nbsp;parent,&nbsp;&nbsp;null,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child')</i></font><br>
parent&nbsp;&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;Group&nbsp;(Group);<br>
level&nbsp;<font color="#50a14f">''</font>&nbsp;(Group&nbsp;child,&nbsp;Group&nbsp;parent)&nbsp;=&nbsp;<font color="#a626a4">RECURSION</font>&nbsp;<font color="#986801">1</font>&nbsp;<font color="#a626a4">AND</font>&nbsp;child&nbsp;<font color="#a626a4">IS</font>&nbsp;Group&nbsp;<font color="#a626a4">AND</font>&nbsp;parent&nbsp;=&nbsp;child&nbsp;<font color="#a626a4">STEP</font>&nbsp;<font color="#986801">1</font>&nbsp;<font color="#a626a4">IF</font>&nbsp;parent&nbsp;=&nbsp;parent($parent);<br>
&nbsp;<br>
<font color="#808080"><i>//&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to,&nbsp;(&nbsp;&nbsp;&nbsp;NULL)</i></font><br>
fib(i,&nbsp;to)&nbsp;=&nbsp;<font color="#a626a4">RECURSION</font>&nbsp;<font color="#986801">1</font>&nbsp;<font color="#a626a4">IF</font>&nbsp;(i=<font color="#986801">0</font>&nbsp;<font color="#a626a4">OR</font>&nbsp;i=<font color="#986801">1</font>)&nbsp;<font color="#a626a4">STEP</font>&nbsp;<font color="#986801">1</font>&nbsp;<font color="#a626a4">IF</font>&nbsp;(i=$i+<font color="#986801">1</font>&nbsp;<font color="#a626a4">OR</font>&nbsp;i=$i+<font color="#986801">2</font>)&nbsp;<font color="#a626a4">AND</font>&nbsp;i&lt;to <font color="#a626a4">CYCLES</font>&nbsp;<font color="#a626a4">IMPOSSIBLE</font>;<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、グループ化と合成を使用して分割/順序付けを実装できる場合、この演算子のタスクは他の演算子を使用して原理的に解決できないことに注意してください。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、この演算子の定義はChRFのプリミティブ再帰演算子の定義と非常に似ていますが、ChRFのプリミティブ再帰は、反復回数が事前にわかっている場合にのみ適用でき、lsFusionでは逆も同様です。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再帰CTEはSQLの再帰演算子に類似していますが、非常に多くの制限があるため、プラットフォームが実行時にそれらを使用することはほとんどありません。</font><font style="vertical-align: inherit;">特に、Postgresでは、ステップにGROUP BYを使用することは不可能です。つまり、頂点のグラフを実行すると、マークを使用できません。これは、反復回数が指数関数的に増加することを意味します。</font><font style="vertical-align: inherit;">したがって、実際には、プラットフォームは原則として内部にWHILEを含むテーブル関数を使用します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、プロパティ作成演算子の説明は終わりです。</font><font style="vertical-align: inherit;">これらはすべての演算子ではありませんが、残りはあまり一般的に使用されていないか、他のレベルの言語抽象化に属しており、そこで考慮されます。</font></font><br>
<br>
<a name="action"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行動</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクションは、いくつかのオブジェクトをパラメーターとして取り、それらを何らかの方法で使用して、システムの状態を変更する抽象化です（このアクションが実行されるものと他の外部システムの状態の両方）。ここではもちろん、おそらく「手順」という用語を使用できますが、1つ目はすでにかなり古くなっており、2つ目は「アクション」よりも単語自体が扱いにくく理解しにくいものです。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、プロパティとアクションは、lsFusionでの陰と陽のプログラミングの一種です。プロパティはHRFアプローチを使用し、アクションはチューリングマシンアプローチを使用します。プロパティはデータベースサーバーで処理され、アクションはアプリケーションサーバーで処理されます（プラットフォームがこれらのプロセスをサーバー間で移動する場合、実際には多くの魔法があります。したがって、これらの抽象化がデフォルトで処理される場所の詳細です）。プロパティはデータの保存と計算を担当し、アクションは変更を担当します。等。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロパティとアクションへの分割は他の言語では暗黙的であることは注目に値します。</font><font style="vertical-align: inherit;">したがって、算術/論理演算子、変数、フィールド、および一般に式で使用できるすべてのものは、プロパティのロジックに起因し、その他はすべてアクションのロジックに起因する可能性があります。</font><font style="vertical-align: inherit;">しかし、他の言語では、この比率が3 x 97であれば適切である場合、平均的なプロジェクトのlsFusionでは少なくとも60 x 40 </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
です。プロパティなどのアクションは、事前定義された演算子のセットを使用して再帰的に設定されます。</font><font style="vertical-align: inherit;">これらの演算子も非常に多く（実際、プロパティを作成するための演算子よりも数倍大きい）、したがって、主要な演算子のみを考慮します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行順序を担当する演算子から始めましょう。</font></font><br>
<br>
<a name="for"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ループ（FOR）、再帰ループ（WHILE）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ名前にもかかわらず、lsFusionのループは、他のプログラミング言語の同じ概念とは大きく異なり、指定されたプロパティの値がNULLでないすべてのオブジェクトのセットに対して上記の反復操作に基づいて構築されます（このプロパティをループ条件と呼びます）。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">FOR</font>&nbsp;selected(Team&nbsp;team)&nbsp;<font color="#a626a4">DO</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#50a14f">'Team&nbsp;'</font>&nbsp;+&nbsp;name(team)&nbsp;+&nbsp;<font color="#50a14f">'&nbsp;was&nbsp;selected'</font>;<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトでは、反復は非決定的な順序ですが、必要に応じて、この順序を明示的に指定できます。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>showAllDetails(Invoice&nbsp;i)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">FOR</font>&nbsp;invoice(InvoiceDetail&nbsp;id)&nbsp;=&nbsp;i&nbsp;<font color="#a626a4">ORDER</font>&nbsp;index(id)&nbsp;<font color="#a626a4">DO</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#50a14f">'Sku&nbsp;:&nbsp;'</font>&nbsp;+&nbsp;nameSku(id)&nbsp;+&nbsp;<font color="#50a14f">',&nbsp;'</font>&nbsp;+&nbsp;quantity(id);<br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ループを作成するとき、その条件は新しいパラメーターを導入する必要があることに注意してください。そうしないと、プラットフォームがエラーをスローし、分岐演算子（IF）の使用を提案します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再帰ループ（WHILE）は、次の点で通常のループとは異なります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ループ条件に少なくとも1つの非NULL値が存在するまで実行を継続します（この意味で、これはプロパティの再帰演算子に非常に似ています）</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいパラメータを入力する必要はありません </font></font><br>
</li>
</ul><br>
<a name="restaction"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出し（EXEC）、シーケンス（{...}）、分岐（CASE、IF）、割り込み（BREAK）、終了（RETURN）</font></font></h3><div class="scrollable-table"><table>
<tbody><tr>
<td><code>f(a)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">FOR</font>&nbsp;t=x(b,a)&nbsp;<font color="#a626a4">DO</font>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do(b);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">IF</font>&nbsp;t&gt;5&nbsp;<font color="#a626a4">THEN</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">BREAK</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#50a14f">'Succeeded'</font>;<br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの演算子は多かれ少なかれ標準的であり、他のプログラミング言語の類似の演算子と大差ありません。</font><font style="vertical-align: inherit;">構文にわずかなニュアンスがあることは明らかですが、他の演算子の違いと比較して、それらを詳細に詳しく説明することは意味がありません。</font></font><br>
<br>
<a name="change"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティ変更（CHANGE）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この演算子を使用すると、プライマリプロパティの値を変更できます。</font><font style="vertical-align: inherit;">同時に、彼はオブジェクトの1つの値のセットだけでなく、指定されたプロパティの値がNULLでないすべてのオブジェクトのセットに対してもこれを行うことができます。</font><font style="vertical-align: inherit;">例えば：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#808080"><i>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i></font><br>
setDiscount(Customer&nbsp;c)&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;discount(c,&nbsp;Item&nbsp;i)&nbsp;&lt;-&nbsp;<font color="#986801">15</font>&nbsp;<font color="#a626a4">WHERE</font>&nbsp;selected(i);<br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記のアクションは以下と同等であることに注意してください。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>setDiscount(Customer&nbsp;c)&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">FOR</font>&nbsp;selected(Item i)&nbsp;<font color="#a626a4">DO</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;discount(c,&nbsp;i)&nbsp;&lt;-&nbsp;<font color="#986801">15</font>;<br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして実際、プラットフォームは、ループ本体に再帰的な依存関係がないことがわかった場合（つまり、読み取り可能なプロパティが変更可能なプロパティに依存している場合（この場合、たとえば、選択された値と割引がプライマリプロパティであると仮定した場合）、プラットフォーム自体は自動的に2番目のオプションを最初のオプションに変換し、1つの要求を実行します。</font><font style="vertical-align: inherit;">ただし、このような最適化は別のトピックであり、次の記事で詳しく説明します。</font></font><br>
 <br>
<a name="new"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトの追加（新規）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この演算子は、指定されたクラスのオブジェクトを追加します（クラスについてはすぐにわかりますが、特別なことは何もありません。</font><font style="vertical-align: inherit;">プロパティ変更演算子と同様に、特定の条件に対して一度に1つではなく多くのオブジェクトを追加できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクト追加演算子の構文は、プロパティ変更演算子の構文に似ています。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>newSku&nbsp;()&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">LOCAL</font>&nbsp;addedSkus&nbsp;=&nbsp;Sku&nbsp;(<font color="#a626a4">INTEGER</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">NEW</font>&nbsp;Sku&nbsp;<font color="#a626a4">WHERE</font>&nbsp;iterate(i,&nbsp;<font color="#986801">1</font>,&nbsp;<font color="#986801">3</font>)&nbsp;<font color="#a626a4">TO</font>&nbsp;addedSkus(i);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">FOR</font>&nbsp;Sku&nbsp;s&nbsp;=&nbsp;addedSkus(i)&nbsp;<font color="#a626a4">DO</font>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id(s)&nbsp;&lt;-&nbsp;<font color="#986801">425</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name(s)&nbsp;&lt;-&nbsp;<font color="#50a14f">'New&nbsp;Sku&nbsp;:&nbsp;'</font>&nbsp;+&nbsp;i;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただし、明らかにこの構文は通常使用されません。オブジェクトを追加するための特別な構文糖があります-ループ演算子（FOR）のNEWオプションは、追加されたオブジェクトの新しいパラメーターをすぐに導入します（これは非常に便利です）。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">FOR</font>&nbsp;iterate(i,&nbsp;<font color="#986801">1</font>,&nbsp;<font color="#986801">3</font>)&nbsp;<font color="#a626a4">NEW</font>&nbsp;s=Sku&nbsp;<font color="#a626a4">DO</font>&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;id(s)&nbsp;&lt;-&nbsp;i;<br>
&nbsp;&nbsp;&nbsp;&nbsp;name(s)&nbsp;&lt;-&nbsp;<font color="#50a14f">'New&nbsp;Sku&nbsp;:&nbsp;'</font>&nbsp;+&nbsp;i;<br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトを1つだけ追加する必要がある場合は、FORを省略できます。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">NEW</font>&nbsp;s=Sku&nbsp;<font color="#a626a4">DO</font>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;id(s)&nbsp;&lt;-&nbsp;<font color="#986801">425</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;name(s)&nbsp;&lt;-&nbsp;<font color="#50a14f">'New&nbsp;Sku'</font>;<br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物理的な観点からオブジェクトを追加することは、一意の識別子を生成することに他なりません。複数のオブジェクトがある場合、プラットフォームは、一度にすべてのオブジェクトに対する1つの要求でこれらの識別子を生成できます。 </font></font><br>
<br>
<a name="delete"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトの削除（DELETE）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、すべてが非常に単純で、多くの点で2つの上位演算子に似ています。削除演算子は、指定された条件で1つまたは複数のオブジェクトを削除します。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">DELETE</font>&nbsp;Sku&nbsp;s&nbsp;<font color="#a626a4">WHERE</font>&nbsp;name(s)&nbsp;=&nbsp;<font color="#50a14f">'MySku'</font>;<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティの変更に関しては、ループ条件を削除条件に転送する「魔法」が削除演算子に対して機能します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の演算子に移る前に、アクションのロジックで使用される別の重要な概念について説明する必要があります。</font></font><br>
<br>
<a name="session"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッションを変更</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述したように、実行の結果としてのアクションは、それが実行されるシステムの状態を変更する可能性があります。整合性の観点とシステムの人間工学の観点の両方から、これらの変更を直接データベースに記録することは常に望ましいとは限りません。したがって、プラットフォームには、これらの変更をいわゆる変更セッションでローカルに蓄積する機能があります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セッションの変更は、オブジェクトクラスの変更だけでなく、プライマリプロパティの変更にもなります。前者は上記のプロパティ変更演算子を使用して実装され、後者はオブジェクトの追加/削除演算子を使用して実装されます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクションが実行されるたびに、実行コンテキストに応じて、現在のセッションが決定されます。たとえば、アクションがフォームの何らかのイベントのハンドラーとして呼び出された場合（最も一般的なケース）、このフォームのセッションがそのフォームの現在のセッションになります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクションが実行中にプロパティを参照する場合、その値は、このアクションの現在のセッションで行われた変更を考慮して計算されます。例えば：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">LOCAL</font>&nbsp;f&nbsp;=&nbsp;<font color="#a626a4">INTEGER</font>&nbsp;(<font color="#a626a4">INTEGER</font>,&nbsp;<font color="#a626a4">INTEGER</font>);<br>
<br>
f(<font color="#986801">1</font>,<font color="#986801">3</font>)&nbsp;&lt;-&nbsp;<font color="#986801">6</font>;<br>
f(<font color="#986801">2</font>,<font color="#986801">2</font>)&nbsp;&lt;-&nbsp;<font color="#986801">4</font>;<br>
f(f(<font color="#986801">1</font>,<font color="#986801">3</font>),<font color="#986801">4</font>)&nbsp;&lt;-&nbsp;<font color="#986801">5</font>;<br>
f(a,a)&nbsp;&lt;-&nbsp;<font color="#a626a4">NULL</font>;&nbsp;<font color="#808080"><i>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1-&nbsp;&nbsp;2-&nbsp;&nbsp;(&nbsp;&nbsp;2,2)</i></font><br>
<br>
<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#a626a4">GROUP</font>&nbsp;<font color="#a626a4">CONCAT</font>&nbsp;a&nbsp;+&nbsp;<font color="#50a14f">','</font>&nbsp;+&nbsp;b&nbsp;+&nbsp;<font color="#50a14f">'-&gt;'</font>&nbsp;+&nbsp;f(a,&nbsp;b),<font color="#50a14f">'&nbsp;;&nbsp;'</font>;&nbsp;<font color="#808080"><i>//&nbsp;&nbsp;1,3-&gt;6&nbsp;;&nbsp;6,4-&gt;5</i></font><br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッションでは、アプリケーション（APPLY）とキャンセル（CANCEL）の2つの基本操作がサポートされています。</font><font style="vertical-align: inherit;">ここでは、セッションとトランザクションを混同しないことが重要です。これらは、厳密に言えば、垂直な概念です。</font><font style="vertical-align: inherit;">そのため、セッションは長期間存在し、一時テーブルまたはアプリケーションサーバーに変更を蓄積し、共通のデータベースにセッションの変更を適用する場合にのみトランザクションを開始できます。</font><font style="vertical-align: inherit;">整合性の維持方法は別のトピックですが、簡単に言うと、トランザクションの開始直後に、既存のすべての変更の値クラスに変更の可能性があるかどうかがそれぞれチェックされ、誤った変更が削除されます。</font><font style="vertical-align: inherit;">セッションをキャンセルすると、セッションに蓄積されたすべての変更がクリアされます。</font></font><br>
<br>
<a name="newsession"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッションの作成（NEWSESSION、NESTEDSESSION）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタックの最上位の操作でセッションが自動的に作成されます（たとえば、ナビゲーターからのアクションの呼び出し、http要求によるアクションなど）。ただし、1つのアクションを実行するプロセスでは、多くの場合、現在のセッション以外の新しいセッションで別のアクションを実行する必要があります。通常、そのような必要性は、アクションの実行のコンテキストが不明であり、現在のセッションに変更を「ブラインド」で適用することにより、誤って「エイリアン」の変更（つまり、適用する必要のなかった変更）を適用する可能性があります。この機能を実装するために、プラットフォームには特別なNEWSESSION演算子があり、ラップすると、アクションが新しいセッションで実行されます（この場合、このアクションの最後に、セッションは自動的に閉じます）。例えば：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>run()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;f(<font color="#986801">1</font>)&nbsp;&lt;-&nbsp;<font color="#986801">2</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">APPLY</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;f(<font color="#986801">1</font>)&nbsp;&lt;-&nbsp;<font color="#986801">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">NEWSESSION</font>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;f(<font color="#986801">1</font>);&nbsp;<font color="#808080"><i>//&nbsp;&nbsp;2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i></font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f(<font color="#986801">2</font>)&nbsp;&lt;-&nbsp;<font color="#986801">5</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">APPLY</font>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;f(<font color="#986801">1</font>);&nbsp;<font color="#808080"><i>//&nbsp;&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;</i></font><br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">確かに、新しいセッションを使用する場合、必要な場合でも、現在のセッションと作成されたセッションの間でデータを転送する方法についての疑問が生じます。</font><font style="vertical-align: inherit;">したがって、パラメーターがスタックに沿って自動的に渡される場合：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>run(Store&nbsp;s)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">NEWSESSION</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#50a14f">'I&nbsp;see&nbsp;that&nbsp;param,&nbsp;its&nbsp;name&nbsp;is:&nbsp;'</font>&nbsp;+&nbsp;name(s);<br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティへの変更は、デフォルトではどこにも送信されません（上記の例を参照）。</font><font style="vertical-align: inherit;">この問題を解決するために、プラットフォームには特別なNESTEDオプションがあり、セッションの作成時に設定されたプロパティへの変更をコピーでき、逆に、セッションを閉じるときに、これらのプロパティへの変更を現在のセッションにコピーして戻すことができます。</font><font style="vertical-align: inherit;">このオプションは、セッション作成ステートメントで直接サポートされているか、プロパティに対してグローバルにサポートされています（この場合、このプロパティは、各セッション作成ステートメントでこのプロパティがNESTEDとして明示的に指定されているかのように機能します）。</font><font style="vertical-align: inherit;">例えば：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>g&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">LOCAL</font>&nbsp;<font color="#a626a4">NESTED</font>&nbsp;<font color="#a626a4">INTEGER</font>&nbsp;();<br>
run()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;f(<font color="#986801">1</font>)&nbsp;&lt;-&nbsp;<font color="#986801">1</font>;&nbsp;g()&nbsp;&lt;-&nbsp;<font color="#986801">5</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">NEWSESSION</font>&nbsp;<font color="#a626a4">NESTED</font>&nbsp;(f)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;f(<font color="#986801">1</font>)&nbsp;+&nbsp;<font color="#50a14f">'&nbsp;'</font>&nbsp;+&nbsp;g();&nbsp;<font color="#808080"><i>//&nbsp;&nbsp;1&nbsp;5</i></font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f(<font color="#986801">1</font>)&nbsp;&lt;-&nbsp;<font color="#986801">5</font>;&nbsp;g()&nbsp;&lt;-&nbsp;<font color="#986801">7</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;f(<font color="#986801">1</font>)&nbsp;+&nbsp;<font color="#50a14f">'&nbsp;'</font>&nbsp;+&nbsp;g();&nbsp;<font color="#808080"><i>//&nbsp;&nbsp;5&nbsp;7</i></font><br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラットフォームは、いわゆるネストされたセッションの作成もサポートしています。</font><font style="vertical-align: inherit;">ネストされたセッションの場合：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のセッションのすべての変更は、作成されたセッションに自動的にコピーされます。つまり、大まかに言えば、ネストされたセッション&lt;-現在のセッション</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされたセッションの変更をキャンセルすると、クリアされませんが、作成時の状態に戻ります。ネストされたセッション&lt;-現在のセッション</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされたセッションで変更を適用すると、そのすべての変更が現在のセッションにコピーされます。現在のセッション&lt;-ネストされたセッション。</font></font><br>
</li>
</ul> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネストされたセッションのメカニズムは、大量の情報（おそらく複数のステージで構成される）の入力を整理する必要がある場合に非常に便利ですが、最後にすべての変更を同時に適用するか、何も適用しない必要があります。</font><font style="vertical-align: inherit;">したがって、たとえば、ある種の大きなドキュメントを入力する必要がある場合、そのドキュメントの入力中に、製品がない場合はその製品を入力できなければなりませんが、次のようにする必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーはこの製品の入力をキャンセルして、ドキュメントの入力を続行できます</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーがドキュメント全体のエントリをキャンセルした場合、この製品のエントリもキャンセルする必要があります </font></font><br>
</li>
</ul><br>
<a name="apply"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更の適用（APPLY）、変更のキャンセル（CANCEL）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変更の適用とキャンセルは、実際にセッションが作成された操作です。</font><font style="vertical-align: inherit;">セッションの説明では、それらはすでに言及されており、そのセマンティクスは名前から派生しています。</font><font style="vertical-align: inherit;">注目に値する1つのこと：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更を適用して元に戻すと、ローカルのプライマリプロパティに対するすべての変更が削除されます。</font><font style="vertical-align: inherit;">この動作は望ましくない場合があるため、セッションの作成に関しては、これらのステートメントに対してNESTEDオプション（同様の動作）がサポートされています。</font></font><br>
</li>
<li>       ,       .                  ,     -   ,   ,     ,   .  ,        (update conflict),  ,      ,            .  ,         :<br>
</li>
</ul> <br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#808080"><i>//&nbsp;--------------------------&nbsp;Object&nbsp;locks&nbsp;----------------------------&nbsp;//</i></font><br>
&nbsp;<br>
locked&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;User&nbsp;(Object);<br>
lockResult&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">LOCAL</font>&nbsp;<font color="#a626a4">NESTED</font>&nbsp;<font color="#a626a4">BOOLEAN</font>&nbsp;();<br>
&nbsp;<br>
lock(Object&nbsp;object)&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">NEWSESSION</font>&nbsp;{&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lockResult()&nbsp;&lt;&nbsp;-&nbsp;<font color="#a626a4">NULL</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">APPLY</font>&nbsp;<font color="#a626a4">SERIALIZABLE</font>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">IF</font>&nbsp;locked(object)&nbsp;<font color="#a626a4">THEN</font>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">CANCEL</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<font color="#a626a4">ELSE</font>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;locked(object)&nbsp;&lt;-&nbsp;currentUser();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lockResult()&nbsp;&lt;-&nbsp;<font color="#a626a4">TRUE</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}<br>
&nbsp;<br>
unlock(Object&nbsp;object)&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">NEWSESSION</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">APPLY</font>&nbsp;locked(object)&nbsp;&lt;-&nbsp;<font color="#a626a4">NULL</font>;<br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS：上記のプロパティとアクションは認証システムモジュールで既に宣言されているため、必要に応じて、それらを使用することができます（推奨されます）（ここでは例としてのみ示しています）。</font><font style="vertical-align: inherit;">一般的に言えば、プラットフォーム自体が競合するアクセス状況の大部分を自動的に完全に解決するため（たとえば、1つのドキュメントを同時に編集するなど）、lsFusionでの悲観的なブロッキングは原則として推奨されません。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の演算子のセットは、アクションではなくプロパティを作成するための演算子ですが、性質上、計算ではなく変更のロジックに近いため、ここでは説明します（プロパティではありません）。</font></font><br>
<br>
<a name="changed"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更演算子（PREV、CHANGED、SET、DROPPED）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セッションでは、変更を操作するための一連の演算子がサポートされています。セッションの前の値の取得（PREV）、セッションのプロパティ値の変更（CHANGED）の有無、NULLから非NULL値（SET）への変更などの判別などです。</font><font style="vertical-align: inherit;">一般的に、これらの演算子は主にイベントのロジックで使用されます（少し後で）が、必要に応じて、どこからでも呼び出されるアクション内で使用できます。次に例を示します。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>f&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">INTEGER</font>&nbsp;(<font color="#a626a4">INTEGER</font>);<br>
run()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;f(<font color="#986801">1</font>)&nbsp;&lt;-&nbsp;<font color="#986801">2</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">APPLY</font>;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;f(<font color="#986801">1</font>)&nbsp;&lt;-&nbsp;<font color="#986801">5</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;f(<font color="#986801">2</font>)&nbsp;&lt;-&nbsp;<font color="#986801">3</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#a626a4">GROUP</font>&nbsp;<font color="#a626a4">SUM</font>&nbsp;<font color="#986801">1</font>&nbsp;<font color="#a626a4">IF</font>&nbsp;<font color="#a626a4">CHANGED</font>(f(a));&nbsp;<font color="#808080"><i>//&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;2</i></font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#50a14f">'.&nbsp;:&nbsp;'</font>&nbsp;+&nbsp;f(<font color="#986801">1</font>)&nbsp;+&nbsp;<font color="#50a14f">',&nbsp;.&nbsp;:&nbsp;'</font>&nbsp;+&nbsp;<font color="#a626a4">PREV</font>(f(<font color="#986801">1</font>));&nbsp;<font color="#808080"><i>//&nbsp;&nbsp;.&nbsp;:&nbsp;5,&nbsp;.&nbsp;:&nbsp;2</i></font><br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これでアクションオペレータが作成されます。</font><font style="vertical-align: inherit;">プロパティと同様に、それらが終了したからではないので、残りはほとんど使用されないか、他のレベルの言語抽象化の概念に密接に関連しており、そこで考慮されます。</font></font><br>
<br>
<a name="event"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベント</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクションは「何をすべきか」という質問に答えますが、「これをいつ行うべきか」という質問には答えないでください。</font><font style="vertical-align: inherit;">特定のアクションを実行する必要がある瞬間を判断するために、プラットフォームにイベントが存在します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すぐに予約します。サブジェクトエリアのイベントについて説明します。それらに加えて、プレゼンテーションロジックにはフォームイベントもあります。</font><font style="vertical-align: inherit;">これらは2つのまったく関係のないメカニズムであり、プレゼンテーションロジックに関する記事でフォームのイベントについて詳しく説明します。</font><font style="vertical-align: inherit;">ただし、今後、タイプを指定しないイベントは、対象領域のイベントと見なされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドメインイベントには次の2つのタイプがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期-データ変更の直後に発生します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期-サーバーが指定されたすべての処理を完了したり、特定の期間が経過したりした後の任意の時点で発生します。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、変更の範囲の観点から、イベントは次のように分類できます。 </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローカル-変更のセッションごとにローカルで発生します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバル-データベース全体でグローバルに発生します。</font></font><br>
</li>
</ul> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、イベントは、同期ローカル、同期グローバル、非同期ローカル、および非同期グローバルにすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同期イベントの利点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要に応じて、たとえば、これらの変更が必要な条件を満たさない場合、プロセスの変更をキャンセルすることができます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更の記録が終了した後、ユーザーは更新されたデータを使用して作業することが保証されるため、完全性が保証されます。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期イベントの利点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーをすぐに解放して、「バックグラウンドで」処理を実行できます。</font><font style="vertical-align: inherit;">これにより、システムの人間工学が向上しますが、データの更新がユーザーの今後の作業にとって重要でない場合にのみ可能です（たとえば、グローバルイベントの場合、次の5〜10分以内に、サーバーが次の処理サイクルを完了する時間まで）。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">処理は、さまざまなユーザーによって行われた変更（グローバルイベントの場合）を含む多数の変更に対してグループ化されているため、実行回数が少なくなり、システム全体のパフォーマンスが向上します。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
地元のイベントのメリット：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーは、イベント処理の結果を、共通のデータベースに保存した直後ではなく、すぐに確認できます。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グローバルイベントのメリット：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更が共通のデータベースに保存された後にのみ処理が実行される（つまり、頻度が大幅に低下する）ことと、トランザクションの操作に関連する多数のDBMS機能の使用により、パフォーマンスと整合性が向上します。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、プラットフォームでは同期グローバルおよび非同期ローカルイベントのみがサポートされています（最も一般的に使用されているように、他のタイプのイベントのサポートも将来計画されています）。したがって、今後はグローバルイベントとローカルイベントについて簡単に説明します。 </font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">ON</font>&nbsp;{&nbsp;<font color="#808080"><i>//&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;APPLY</i></font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#50a14f">'Something&nbsp;changed'</font>;<br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただし、上記のように、変更が適用されると（！）変更が適用されると（このセッションで何が変更されたかに関係なく）メッセージ「Something changed」が発行されるため、実際には実行しない方がよいでしょう。</font><font style="vertical-align: inherit;">原則として、イベントでは特定の何かが変更されたことを確認する必要があります。ここで、変更を処理するオペレーターが救済します（変更、設定、削除など）。</font><font style="vertical-align: inherit;">さらに、実際には、ほとんどのイベントは単純な因果関係に帰着します。何かが変わったとき、何かをする必要があります。</font><font style="vertical-align: inherit;">このシナリオを実装するために、プラットフォームには特別なタイプのイベント（単純なイベント）があります。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#808080"><i>//&nbsp;&nbsp;email,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i></font><br>
<font color="#a626a4">WHEN</font>&nbsp;<font color="#a626a4">SET</font>(balance(Sku&nbsp;s,&nbsp;Stock&nbsp;st)&nbsp;&lt; <font color="#986801">0</font>)&nbsp;<font color="#a626a4">DO</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">EMAIL</font>&nbsp;<font color="#a626a4">SUBJECT</font>&nbsp;<font color="#50a14f">'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'</font>&nbsp;+&nbsp;name(s)&nbsp;+&nbsp;<font color="#50a14f">'&nbsp;&nbsp;&nbsp;'</font>&nbsp;+&nbsp;name(st);<br>
<br>
<font color="#a626a4">WHEN</font>&nbsp;<font color="#a626a4">LOCAL</font>&nbsp;<font color="#a626a4">CHANGED</font>(customer(Order&nbsp;o))&nbsp;<font color="#a626a4">AND</font>&nbsp;name(customer(o))&nbsp;==&nbsp;<font color="#50a14f">'Best&nbsp;customer'</font>&nbsp;<font color="#a626a4">DO</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;discount(OrderDetail&nbsp;d)&nbsp;&lt;- <font color="#986801">50</font>&nbsp;<font color="#a626a4">WHERE</font>&nbsp;order(d)&nbsp;=&nbsp;o;<br>
</code></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、単純なイベントは構文糖にすぎません。</font><font style="vertical-align: inherit;">したがって、最初のイベントは次と同等です。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">ON</font>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">FOR</font>&nbsp;<font color="#a626a4">SET</font>(balance(Sku&nbsp;s,&nbsp;Stock&nbsp;st)&nbsp;&lt; <font color="#986801">0</font>)&nbsp;<font color="#a626a4">DO</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">EMAIL</font>&nbsp;<font color="#a626a4">SUBJECT</font>&nbsp;<font color="#50a14f">'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'</font>&nbsp;+&nbsp;name(s)&nbsp;+&nbsp;<font color="#50a14f">'&nbsp;&nbsp;&nbsp;'</font>&nbsp;+&nbsp;name(st);<br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただし、単純なイベントを使用するため、脚を自分で撃つことははるかに困難であり、開発者がそれらを読み書きする方が簡単です。デフォルトでは、単純なイベントを使用し、通常のイベントを使用して、本当に難しいケースの実行を最適化することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トリガーは、SQLの単純なイベント（またはその拡張）に類似しています。ただし、トリガーは1つのテーブルに制限されており、完全に書き込みに対して機能し、各テーブルに対して個別に実行され（つまり、1つのクエリで実行することはできません）、他にも多くのことがあり、プラットフォームでは単純なイベントを実装するために使用されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のオペレーターの動作は、ドメイン内のイベントの処理内で変化することに注意することが重要です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更の破棄-変更の適用をキャンセルし、セッションをクリアしません（このオペレーターは同期イベント内でのみ使用できます）</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更を処理する演算子-データベース内の現在の値ではなく、前のイベントの処理が完了した時点の値を返します。</font><font style="vertical-align: inherit;">ただし、グローバルイベントの場合、これらの値は一致します。さらに、特別なオプションを使用して、これらの演算子を標準モードに「戻し」、データベースの現在の値を返すことができます。</font></font><br>
</li>
</ul><br>
<a name="constraint"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制限事項</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラットフォームの制限により、プライマリプロパティを持つ値と持たない値が決まります。</font><font style="vertical-align: inherit;">一般に、制約は、常にNULLである必要があるプロパティとして定義されます。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#808080"><i>//&nbsp;&nbsp;&nbsp;&nbsp;0</i></font><br>
<font color="#a626a4">CONSTRAINT</font>&nbsp;balance(Sku&nbsp;s,&nbsp;Stock&nbsp;st)&nbsp;&lt; <font color="#986801">0</font>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#50a14f">'&nbsp;&nbsp;&nbsp;&nbsp;'</font>;<br>
<br>
<font color="#808080"><i>//&nbsp;""&nbsp;&nbsp;</i></font><br>
<font color="#a626a4">CONSTRAINT</font>&nbsp;<font color="#a626a4">DROPCHANGED</font>(barcode(Sku&nbsp;s))&nbsp;<font color="#a626a4">AND</font>&nbsp;name(currentUser())&nbsp;!=&nbsp;<font color="#50a14f">'admin'</font>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#50a14f">'&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'</font>;<br>
<br>
<font color="#808080"><i>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;</i></font><br>
<font color="#a626a4">CONSTRAINT</font>&nbsp;sku(OrderDetail&nbsp;d)&nbsp;<font color="#a626a4">AND</font>&nbsp;<font color="#a626a4">NOT</font>&nbsp;in(sku(d),&nbsp;customer(order(d)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#50a14f">'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'</font>;<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際、制約は、制約されているプロパティの非NULL（SET）値への変更である単純なイベントですが、処理では、その非NULL値をすべて表示し、加えられた変更を破棄します。</font><font style="vertical-align: inherit;">つまり、制限は構文上の砂糖に過ぎませんが、単純なイベントと同様に、制限は読み書きが簡単なので、可能であれば使用することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントと同様に、制限には特別な亜種があります-単純な制限（最も一般的な制限の場合の構文糖）ですが、慣例が示すように、特定のプロパティを設定する必要があることを制限することに加えて（ここではすべてが多少明白です）、単純な制限が使用されますめったにないので、詳しくは説明しません。</font></font><br>
<br>
<a name="class"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、ここでクラスに行きます。</font><font style="vertical-align: inherit;">通常、それらから始めるのが慣例ですが、厳密に言えば、論理的には、クラスは制限のタイプの1つにすぎません。</font><font style="vertical-align: inherit;">例えば：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>f&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;A&nbsp;(<font color="#a626a4">INTEGER</font>);<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり、fに非NULL値がある場合、この値はクラスAでなければなりません。つまり、上の例は同等です。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>f&nbsp;=&nbsp;Object&nbsp;(<font color="#a626a4">INTEGER</font>);<br>
<font color="#a626a4">CONSTRAINT</font>&nbsp;f(i)&nbsp;<font color="#a626a4">AND</font>&nbsp;<font color="#a626a4">NOT</font>&nbsp;f(i)&nbsp;<font color="#a626a4">IS</font>&nbsp;A&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#50a14f">'&nbsp;'</font>;&nbsp;<font color="#808080"><i>//&nbsp;f(i)&nbsp;=&gt;&nbsp;f(i)&nbsp;IS&nbsp;A</i></font><br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同時に、論理的にクラスがスタックの最上位にある場合、物理的に-すべてが正反対です。</font><font style="vertical-align: inherit;">クラスはそれぞれ構文糖質ではありません（つまり、上記の例のように制限を介さずに「ネイティブに」実装されます）。それぞれの作業は非常に最適化されています。つまり、一般的な原則は次のとおりです。クラスを使用して問題を解決できる場合、クラスを使用して解決することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、lsFusionのクラスの概念は、OOPのクラスの概念とそれほど変わりません。</font><font style="vertical-align: inherit;">確かに、OOPとは異なり、lsFusionにはカプセル化がありません。</font><font style="vertical-align: inherit;">とにかく、さようなら。</font><font style="vertical-align: inherit;">しかし、lsFusionでのカプセル化が表示されたとしても、それは次のような構文糖の形式にすぎません。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">CLASS</font>&nbsp;A&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">LONG</font>&nbsp;(<font color="#a626a4">INTEGER</font>);&nbsp;<font color="#808080"><i>//&nbsp;&nbsp;f&nbsp;=&nbsp;DATA&nbsp;LONG&nbsp;(A,&nbsp;INTEGER)</i></font><br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOPと同様に、lsFusionは複数を含むクラス継承をサポートします。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">CLASS</font>&nbsp;Animal;<br>
<font color="#a626a4">CLASS</font>&nbsp;Transport;<br>
<font color="#a626a4">CLASS</font>&nbsp;Car&nbsp;:&nbsp;Transport;<br>
<font color="#a626a4">CLASS</font>&nbsp;Horse&nbsp;:&nbsp;Transport,&nbsp;Animal;<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継承自体はあまり有用ではありません。その主な目的は、メカニズムでポリモーフィズムを使用することです。</font></font><br>
<br>
<a name="poly"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポリモーフィズム</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lsFusionの現在のバージョンでは、ポリモーフィズムは明示的です。</font><font style="vertical-align: inherit;">それを実装するには、抽象プロパティまたはアクションが最初に、おそらく抽象クラスのいくつかに対して宣言されます。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>speed&nbsp;=&nbsp;<font color="#a626a4">ABSTRACT</font>&nbsp;<font color="#a626a4">LONG</font>&nbsp;(Transport);<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、特定のクラスが表示されたときに、宣言された抽象プロパティの実装を設定することが可能/必要です。次に例を示します。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">CLASS</font>&nbsp;Breed;<br>
speed&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">LONG</font>&nbsp;(Breed)<br>
breed&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;Breed&nbsp;(Animal);<br>
<br>
speed(Horse&nbsp;h)&nbsp;+=&nbsp;speed(breed(h));&nbsp;<font color="#808080"><i>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i></font><br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポリモーフィズムは、いくつかのパラメーターでもサポートされています（いわゆる多重ポリモーフィズム）。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">CLASS</font>&nbsp;Thing;<br>
<font color="#a626a4">CLASS</font>&nbsp;Ship&nbsp;:&nbsp;Thing;<br>
<font color="#a626a4">CLASS</font>&nbsp;Asteroid&nbsp;:&nbsp;Thing;<br>
<br>
collide&nbsp;<font color="#a626a4">ABSTRACT</font>&nbsp;(Thing,&nbsp;Thing);<br>
collide(Ship&nbsp;s1,&nbsp;Ship&nbsp;s2)&nbsp;+{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#50a14f">'Ship&nbsp;:&nbsp;'</font>&nbsp;+&nbsp;name(s1)&nbsp;+&nbsp;<font color="#50a14f">',&nbsp;Ship&nbsp;:&nbsp;'</font>&nbsp;+&nbsp;name(s2);<br>
}<br>
collide(Ship&nbsp;s1,&nbsp;Asteroid&nbsp;a2)&nbsp;+{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#50a14f">'Ship&nbsp;:&nbsp;'</font>&nbsp;+&nbsp;name(s1)&nbsp;+&nbsp;<font color="#50a14f">',&nbsp;Asteroid&nbsp;:&nbsp;'</font>&nbsp;+&nbsp;name(a2);<br>
}<br>
collide(Asteroid&nbsp;a1,&nbsp;Ship&nbsp;s2)&nbsp;+{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#50a14f">'Asteroid&nbsp;:&nbsp;'</font>&nbsp;+&nbsp;name(a1)&nbsp;+&nbsp;<font color="#50a14f">',&nbsp;Ship&nbsp;:&nbsp;'</font>&nbsp;+&nbsp;name(s2);<br>
}<br>
collide(Asteroid&nbsp;a1,&nbsp;Asteroid&nbsp;a2)&nbsp;+{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">MESSAGE</font>&nbsp;<font color="#50a14f">'Asteroid&nbsp;:&nbsp;'</font>&nbsp;+&nbsp;name(a1)&nbsp;+&nbsp;<font color="#50a14f">',&nbsp;Asteroid&nbsp;:&nbsp;'</font>&nbsp;+&nbsp;name(a2);<br>
}<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">厳密に言えば、ポリモーフィズムは物理モデル（開発プロセス）を指し、論理モデルを指しません。</font><font style="vertical-align: inherit;">したがって、解析直後のサーバーは、ABSTRACTステートメントを選択ステートメントに変換します。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>speed(Transport&nbsp;t)&nbsp;=&nbsp;<font color="#a626a4">CASE</font>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">WHEN</font>&nbsp;t&nbsp;<font color="#a626a4">IS</font>&nbsp;Horse&nbsp;<font color="#a626a4">THEN</font>&nbsp;speed(breed(t))<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080"><i>//&nbsp;&nbsp;</i></font><br>
<font color="#a626a4">END</font><br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、ポリモーフィズムなしですでに述べたように、継承はほとんど意味がないため、少し先に進みました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来的には、明示的なポリモーフィズムに加えて、言語が暗黙的なポリモーフィズムもサポートすることが計画されています。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>speed(Horse&nbsp;h)&nbsp;=&nbsp;speed(breed(h));<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">馬のプロパティを同時に作成し、クラスに適した同じ名前のすべての抽象プロパティに実装を追加します（ほとんどの最新の言語で行われているように）。</font><font style="vertical-align: inherit;">さらに、このため、プラットフォームには必要なインフラストラクチャがすべて揃っていますが、さまざまな理由から、この機能をプラットフォームの最初のパブリックバージョンに含めないことにしました。</font></font><br>
<br>
<a name="built"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インラインクラス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記では、カスタムクラス、つまり開発者が作成するクラスについてのみ説明しました。</font><font style="vertical-align: inherit;">同時に、プラットフォームは、いわゆる組み込み（プリミティブ）クラス（数値、文字列、日付など）もサポートします。</font><font style="vertical-align: inherit;">他の言語と比較して特別なことは何もありませんが、現在の実装では相互に、またはユーザークラスと混在させることはできないことを考慮に入れる必要があります。</font><font style="vertical-align: inherit;">つまり、特定の数値またはオブジェクトに対してプロパティが同時にNULL以外の値を返すことはできません。つまり、これを行うことはできません。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>f&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">LONG</font>&nbsp;(<font color="#a626a4">LONG</font>);<br>
g&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">LONG</font>&nbsp;(A);<br>
h(a)&nbsp;=&nbsp;<font color="#a626a4">OVERRIDE</font>&nbsp;f(a),&nbsp;g(a);&nbsp;<font color="#808080"><i>//&nbsp;&nbsp;&nbsp;</i></font><br>
</code></td>
</tr>
</tbody></table></div><a name="static"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的オブジェクト</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的（または組み込み）オブジェクト-サーバーの起動時に作成され、削除できないオブジェクト。</font><font style="vertical-align: inherit;">さらに、静的オブジェクトは、言語で定数として直接アクセスできます。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">CLASS</font>&nbsp;Direction&nbsp;<font color="#50a14f">''</font> {<br>
&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;<font color="#50a14f">''</font>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;right&nbsp;<font color="#50a14f">''</font>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;forward&nbsp;<font color="#50a14f">''</font><br>
}<br>
<br>
result(dir)&nbsp;=&nbsp;<font color="#a626a4">CASE</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">WHEN</font>&nbsp;dir&nbsp;=&nbsp;Direction.left&nbsp;<font color="#a626a4">THEN</font>&nbsp;<font color="#50a14f">'&nbsp;'</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">WHEN</font>&nbsp;dir&nbsp;=&nbsp;Direction.right&nbsp;<font color="#a626a4">THEN</font>&nbsp;<font color="#50a14f">'&nbsp;'</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">WHEN</font>&nbsp;dir&nbsp;=&nbsp;Direction.forward&nbsp;<font color="#a626a4">THEN</font>&nbsp;<font color="#50a14f">'&nbsp;'</font><br>
<font color="#a626a4">END</font><br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それ以外の場合、静的オブジェクトは、ユーザーが作成した他のオブジェクトと同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現代のプログラミング言語における静的オブジェクトの類似物はそれぞれ列挙型であり、通常、静的オブジェクトはまったく同じ目的で使用されます。</font></font><br>
<br>
<a name="aggr"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集計</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスメカニズム（lsFusionと他の言語の両方）には、少なくとも3つの制限があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスに属することは計算できません（オブジェクトのクラスを追加および変更するときに明示的に設定するだけです）。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスは1つのオブジェクトに対してのみ定義されます（オブジェクトのセットに対しては定義されません）。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じクラスを複数回継承することはできません。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの制限を回避するために、プラットフォームにはいわゆる集計のメカニズムがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
集約とは、いくつかの集約されたプロパティの各NULL以外の値に対応する一意の（集約された）オブジェクトの作成を指します。</font><font style="vertical-align: inherit;">そのようなオブジェクトの場合、このオブジェクトを集約プロパティの各パラメーターにマッピングするプロパティと、逆に、集約プロパティのパラメーターをこのオブジェクトにマッピングするプロパティがあると想定されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例えば：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#808080"><i>//&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;B</i></font><br>
b(A&nbsp;a)&nbsp;=&nbsp;<font color="#a626a4">AGGR</font>&nbsp;B&nbsp;<font color="#a626a4">WHERE</font>&nbsp;a&nbsp;<font color="#a626a4">IS</font>&nbsp;A;&nbsp;<br>
<font color="#808080"><i>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;A,&nbsp;&nbsp;&nbsp;b(a(b))&nbsp;=&nbsp;b</i></font><br>
<br>
createC&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">BOOLEAN</font>&nbsp;(A,&nbsp;B)<br>
<font color="#808080"><i>//&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;createC&nbsp;&nbsp;&nbsp;&nbsp;C</i></font><br>
<font color="#808080"><i>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i></font><br>
c&nbsp;=&nbsp;<font color="#a626a4">AGGR</font>&nbsp;C&nbsp;<font color="#a626a4">WHERE</font>&nbsp;createC(A&nbsp;a,&nbsp;B&nbsp;b);&nbsp;<br>
<font color="#808080"><i>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;</i></font><br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、より命を救う例を挙げて、継承とポリモーフィズム（実際には大多数のケースで行われます）とともに集計を使用する方法を示します。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">CLASS</font>&nbsp;Shipment&nbsp;<font color="#50a14f">''</font>;<br>
date&nbsp;=&nbsp;<font color="#a626a4">ABSTRACT</font>&nbsp;<font color="#a626a4">DATE</font>&nbsp;(Shipment);<br>
<font color="#a626a4">CLASS</font>&nbsp;Invoice&nbsp;<font color="#50a14f">''</font>;<br>
createShipment&nbsp;<font color="#50a14f">'&nbsp;'</font>&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">BOOLEAN</font>&nbsp;(Invoice);<br>
date&nbsp;<font color="#50a14f">'&nbsp;'</font>&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">DATE</font>&nbsp;(Invoice);<br>
<font color="#a626a4">CLASS</font>&nbsp;ShipmentInvoice&nbsp;<font color="#50a14f">'&nbsp;&nbsp;'</font>&nbsp;:&nbsp;Shipment;<br>
<font color="#808080"><i>//&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i></font><br>
shipment(Invoice&nbsp;invoice)&nbsp;=&nbsp;<font color="#a626a4">AGGR</font>&nbsp;ShipmentInvoce&nbsp;<font color="#a626a4">WHERE</font>&nbsp;createShipment(invoice);<br>
date(ShipmentInvoice&nbsp;si)&nbsp;+=&nbsp;sum(date(invoice(si)),<font color="#986801">1</font>);&nbsp;<font color="#808080"><i>//&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;+&nbsp;1</i></font><br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般に、これら3つのメカニズム（集約、継承、およびポリモーフィズム）、およびイベントと拡張（物理モデルの記事の後半の拡張について）により、理想的ではないにしても、それに非常に近いモジュール性を実現できます。たとえば、現在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ERP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は約1100のモジュールで構成されています。したがって、それらから、モジュールの任意のサブセットを選択し、このサブセットから、顧客が必要とするものがあるソリューションを組み立てることができます。そのため、一部のお客様には、食品以外の小売り（約50モジュール）しかないもの、生産と卸売のみしているもの、ほとんどすべてが1,100に加えて独自の300を持っているものもあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドメインのロジックで終わります。これだけですべてではありませんが、1つの記事では多すぎるかもしれません。</font><font style="vertical-align: inherit;">ただし、すぐに言語の機能を説明する記事が少なくとも2つ追加されます。1つはプレゼンテーションロジックに関する記事、2つ目は物理モデルに関する記事です。また、残念ながらまたは幸いにも、「すべてが多かれ少なかれここでは標準的」というフレーズで管理することは困難です。彼らが言うように、あなたの画面から遠くに行かないでください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、lsFusionと汎用言語を対比する場合、導入部にはある程度のずる賢い点があります。はい、クラス、集約、制限、イベント、およびその他の言語の抽象化は、概して、実際には特定のサブジェクト領域に属しておらず、システムプログラミング（開発など）を含め、何らかの形で存在しています条件付きOSまたはDBMS）。ただし、lsFusion仕様全体（ACIDがなくても）をサポートする仮想マシンを実装することは、最新のSQLサーバーほど重くないため、非常に困難です。その結果、DSL lsFusionラベルを取り除くことが成功する可能性は低く、これは、ほとんどのシステムプログラマー（汎用言語の主な消費者）の好意に頼る必要がほとんどないことを意味します。厳密に言えば、SQLのほとんどは好きではありません。内部には多くの魔法があり、lsFusionではこの魔法はさらに多くなります。もちろん、私たちはこの効果を最大化しようとします-無料ライセンス、githubのソースコード（プラットフォーム自体とそのインフラストラクチャ全体の両方）、既存のエコシステム（IDE、レポート、VCS、自動アセンブリ）の最大限の使用、スラックおよび電報チャネルコミュニケーション、パブリックリポジトリ（linuxとmaven、ソースも含む）での存在、そして原則として、開発者とのやり取りにおける一般的な開放性ですが、平均的なシステムプログラマーがSQLやABAPよりもlsFusionを好まない場合は現実的です1Cはすでに成功しています。この影響を最大限に軽減しようとします-無料ライセンス、githubソース（プラットフォーム自体とそのインフラストラクチャ全体の両方）、既存のエコシステム（IDE、レポート、VCS、自動アセンブリ）の最大使用、スラックおよびテレグラム通信チャネル、可用性パブリックリポジトリ（linuxとmaven、再びソース付き）、および原則として、開発者とのやり取りにおける一般的なオープン性ですが、平均的なシステムプログラマーがlsFusionをSQL、ABAP、1Cよりも嫌いであれば、現実的です-これすでに成功しています。この影響を最大限に軽減しようとします-無料ライセンス、githubソース（プラットフォーム自体とそのインフラストラクチャ全体の両方）、既存のエコシステム（IDE、レポート、VCS、自動アセンブリ）の最大使用、スラックおよびテレグラム通信チャネル、可用性パブリックリポジトリ（linuxとmaven、再びソース付き）、および原則として、開発者とのやり取りにおける一般的なオープン性ですが、平均的なシステムプログラマーがlsFusionをSQL、ABAP、1Cよりも嫌いであれば、現実的です-これすでに成功しています。まあ、原則として、開発者とのやり取りにおける一般的な開放性ですが、平均的なシステムプログラマーがlsFusionをSQL、ABAP、および1Cよりも単純に嫌うのであれば、現実的です。これはすでに成功しています。まあ、原則として、開発者とのやり取りにおける一般的なオープン性ですが、平均的なシステムプログラマーがlsFusionをSQL、ABAP、および1Cよりも単純に嫌うなら、私たちは現実的です-これはすでに成功しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その一方で、近い将来、lsFusionの主な市場はシステムではなくアプリケーションプログラミング（前述のIPの開発）になることは明らかであり、ERPプラットフォーム、手続き型拡張機能を備えたSQLサーバー、ORMフレームワークの5つの主要なプレーヤーが存在します。 、RADフレームワーク、そして単なるスプレッドシートです。</font><font style="vertical-align: inherit;">1番目、4番目、5番目のタイプのプラットフォームにはキットにユーザーインターフェイスがあり、2番目と3番目では、サードパーティのテクノロジーが使用されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの5種類のプラットフォームにはそれぞれ独自のニッチがあり、主に次の場所にあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手続き型の拡張機能を備えたSQLサーバー（比較的複雑なロジックと大量のデータを含むビジネスアプリケーション）は通常、小売店と銀行です。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ERPプラットフォーム-複雑なロジックを備えたその他のビジネスアプリケーション-卸売、製造、財務など</font></font><br>
</li>
<li>ORM- – - (, ),         .<br>
</li>
<li>RAD –   -   ,  ,  ,   IT-.<br>
</li>
<li>  –   ,   RAD, , -       ,   ,             Excel (,   ,    ,      –   ).<br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の純粋に主観的な意見では、グローバルな観点から見ると、lsFusionはすべての非機能要件でlsFusionが超えるERP、RAD、およびSQLプラットフォームを完全に置き換えることができます（それらの多くでは、桁違いです）。確かに、SQLに関しては、置換についてではなく、アドインについて、つまり、たとえば、FortranとCがアセンブラを置き換えたのと同じようにあります（アセンブラで記述できますが、理由は明確ではありません）。 ORMフレームワークを使用すると、極端な柔軟性とスケーラビリティ、および非常に単純なタスクと非構造化データの操作でエントリしきい値のあるスプレッドシートで競争することは明らかに困難になります。それにもかかわらず、彼らは彼らから市場の一部を取り戻すことができる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、中期的には、主に中小企業（人的資源とIT予算は限られていますが、使用されるソリューションの柔軟性と人間工学に大きなニーズがあります）と非標準のタスク（既製のソリューションがほとんどなく、それに応じてカスタマイズされる）に焦点が当てられますこれらのソリューション自体を超えています）。</font><font style="vertical-align: inherit;">つまり、1Cが現在ロシアで占めているニッチを占めるが、それは地球規模でのみ行うことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これはすべて野心的に聞こえますが、このテクノロジーをすべて機能させるためにすでに完了している（そしてほぼ12年かかりました）後、このタスクはもはやそれほど不可能に思えなくなりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UPD：記事の2番目の部分は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja458362/index.html">単一行の乗算表</a></li>
<li><a href="../ja458364/index.html">フィッシュネットケース-Microsoft Azureがフィッシング攻撃をどのように支援するか</a></li>
<li><a href="../ja458370/index.html">どのように迅速な結果がイヴァンを助けましたか</a></li>
<li><a href="../ja458372/index.html">TestMace-APIを操作するための強力なIDE</a></li>
<li><a href="../ja458374/index.html">IBM Watsonサービスの例としてのTJBOT</a></li>
<li><a href="../ja458378/index.html">サイトのレイアウトにAvocodeを使用します。初心者向けのレビュー。ボーナス-30日間の試用期間を登録する</a></li>
<li><a href="../ja458382/index.html">なぜこれを教えるのですか？</a></li>
<li><a href="../ja458384/index.html">HP 3D Structured Light Scanner Pro S3レビューとテスト</a></li>
<li><a href="../ja458388/index.html">深い（学習+ランダム）フォレストと記事の解析</a></li>
<li><a href="../ja458390/index.html">Ceph-「膝の上」から「本番」までパート2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>