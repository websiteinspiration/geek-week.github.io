<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏼 🍒 🦆 关于提高JavaScript代码可靠性的7条建议 ☺️ 🎩 💤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这篇文章的作者（我们今天将要翻译的译本）决定与读者分享有关JavaScript的七个建议。正如作者希望的那样，这些建议将有助于编写更可靠的程序。
 
 
 
 1.使用工厂功能
 如果没有人知道，则工厂函数是返回对象的普通函数（而不是类或构造函数）。这个简单的概念使我们能够利用JavaScript的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>关于提高JavaScript代码可靠性的7条建议</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/487682/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这篇文章的作者（我们今天将要翻译的译本）决定与读者分享有关JavaScript的七个建议。</font><font style="vertical-align: inherit;">正如作者希望的那样，这些建议将有助于编写更可靠的程序。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/8z/rd/8y/8zrd8y9kug0o6kfhfjfyizbt-va.jpeg"></a><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.使用工厂功能</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果没有人知道，则工厂函数是返回对象的普通函数（而不是类或构造函数）。</font><font style="vertical-align: inherit;">这个简单的概念使我们能够利用JavaScript的强大功能来创建强大而可靠的应用程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要的是要知道不使用关键字就可以调用工厂函数</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果使用此关键字给她打电话，她将停止应有的举止。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍为什么要使用工厂功能？</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
工厂函数可用于简化实例化对象，而不必绑定到类或关键字</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
工厂功能的本质是将它们视为最普通的功能。这意味着它们可用于构造对象，其他功能甚至承诺。即，可以将这些功能进行组合和组合以创建更强大的工厂功能，而这些功能又可以与其他功能或对象组合以创建甚至更高级的工厂功能。工厂功能为程序员提供了无限的可能性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
鉴于以上所述，并将工厂功能的使用与推荐的代码编写方法相结合，这些功能可以成为功能强大且便捷的工具。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是工厂函数的简单示例：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFrog</span>(<span class="hljs-params">name</span>) </span>{
&nbsp;&nbsp;<span class="hljs-keyword">const</span> children = []<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">return</span> {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;addChild(frog) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children.push(frog)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;},<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> mikeTheFrog = createFrog(<span class="hljs-string">'mike'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您使用工厂功能一段时间，您可能会了解，与构造函数形式的竞争对手相比，工厂功能可以提高代码重用级别。</font><font style="vertical-align: inherit;">结果，程序员必须编写更少的代码。</font><font style="vertical-align: inherit;">工厂函数便于重构，因为它们能够返回任意对象，并简化了代码库的工作。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.编写构造函数时，将方法添加到其原型中</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您刚开始学习JavaScript，那么使用原型对象在您看来可能会有些新鲜。</font><font style="vertical-align: inherit;">因此，从一开始就与我同在。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请记住，此技术不适用于课程。</font><font style="vertical-align: inherit;">类无需程序员费力地将类的方法独立保存在其原型中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个示例构造函数：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Frog</span>(<span class="hljs-params">name, gender</span>) </span>{
&nbsp;&nbsp;<span class="hljs-keyword">this</span>.name = name
&nbsp;&nbsp;<span class="hljs-keyword">this</span>.gender = gender<font></font>
}<font></font>
<font></font>
Frog.prototype.leap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">feet</span>) </span>{
&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Leaping <span class="hljs-subst">${feet}</span>ft into the air`</span>)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么使用构造</font></font><code>Frog.prototype.leap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是仅</font></font><code>leap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向构造函数创建的对象</font><font style="vertical-align: inherit;">编写方法</font><font style="vertical-align: inherit;">？</font><font style="vertical-align: inherit;">例如，像这样：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Frog</span>(<span class="hljs-params">name, gender</span>) </span>{
&nbsp;&nbsp;<span class="hljs-keyword">this</span>.name = name
&nbsp;&nbsp;<span class="hljs-keyword">this</span>.gender = gender<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">this</span>.leap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">feet</span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Leaping <span class="hljs-subst">${feet}</span>ft into the air`</span>)<font></font>
&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实是，如果将方法直接附加到构造函数属性</font></font><code>prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则意味着该实例将由构造函数创建的对象的所有实例共享。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
换句话说，如果您依赖前面的示例，</font></font><code>this.leap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就会发现在创建对象的多个实例时</font></font><code>Frog</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，每个</font><font style="vertical-align: inherit;">实例</font><font style="vertical-align: inherit;">都有自己的method </font></font><code>leap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。也就是说-将创建此方法的多个副本。在这种情况下，这表明系统资源的使用是不合理的，因为在所有这些对象中，都将存在相同方法的副本，该副本在各处的行为都相同。不必在对象的每个实例中创建此类方法的副本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，这将导致程序性能下降。</font><font style="vertical-align: inherit;">但这并不难避免。</font><font style="vertical-align: inherit;">应当注意，属性</font></font><code>this.name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>this.gender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该以这种形式声明，因为它们必须属于特定的对象。</font><font style="vertical-align: inherit;">如果我们用真实的青蛙作一个类比，那么它的虚拟表示是使用构造函数描述的</font></font><code>Frog</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么事实证明青蛙可以有自己的名字，青蛙具有不同的性别。</font><font style="vertical-align: inherit;">结果，为了在每个对象中存储有关青蛙的唯一信息，有必要声明对象的属性，以便可以在对象实例级别正确使用它们。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在流行的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请求</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包中使用此技术的示例</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.将.type属性添加到要区分的对象。</font></font></font></h2><br><font style="vertical-align: inherit;"></font><code>.type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如今，通过非官方协议经常将其添加到对象中的</font><font style="vertical-align: inherit;">
一种属性</font><font style="vertical-align: inherit;">已被广泛使用。</font><font style="vertical-align: inherit;">如果您正在编写React应用程序，那么您可能一直都遇到此属性。</font><font style="vertical-align: inherit;">特别是-如果您使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用这种方法可以很好地展示自己的开发过程，因为它除其他功能外，还可以让您创建自记录代码：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSpecies</span>(<span class="hljs-params">type, name, gender</span>) </span>{
&nbsp;&nbsp;<span class="hljs-keyword">if</span> (type === <span class="hljs-string">'frog'</span>) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> createFrog(name, gender)<font></font>
&nbsp;&nbsp;} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'human'</span>) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> createHuman(name, gender)<font></font>
&nbsp;&nbsp;} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">undefined</span>) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Cannot create a species with an unknown type'</span>)<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> myNewFrog = createSpecies(<span class="hljs-string">'frog'</span>, <span class="hljs-string">'sally'</span>, <span class="hljs-string">'female'</span>)</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.使用TypeScript</font></font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已在JavaScript社区中得到广泛应用，原因是该语言为程序员提供了一种安全地处理类型的强大工具，并且还允许您甚至在错误出现在正在运行的代码中之前对其进行识别。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用TypeScript，即使在启动代码之前，也可以在编译代码的阶段发现潜在的错误。如果代码中有错误，则在编译时将显示编译通知。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，在任何情况下使用TypeScript的类型安全性和错误的早期检测都远未完整。</font><font style="vertical-align: inherit;">TypeScript的一大优点是，它可以让您在新的JavaScript功能出现在主流浏览器之前就加以利用。</font><font style="vertical-align: inherit;">事实是，TypeScript代码已编译为现代浏览器（而不是最新浏览器）支持的JavaScript代码。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.编写测试</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您正在从事一个项目并且对这项工作很认真，那么您实际上需要编写测试。这将使代码更具可预测性，并减少出错的可能性。进行更改时，这将使您对代码的质量有更高的信心。换句话说，如果您希望代码经受住时间的考验，那么没有比编写测试更好的方法来为此测试准备代码了。您在项目中进行的测试越多，将其部署到生产环境中时对代码的信心就越大。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果仅需要选择一项最重要的正面测试功能，那将是什么？</font><font style="vertical-align: inherit;">我相信这是事实，即测试有助于发现错误，然后再进入工作程序。</font><font style="vertical-align: inherit;">什么样的程序员不希望有这样的机会？</font><font style="vertical-align: inherit;">我当然不会拒绝这样的事情。</font><font style="vertical-align: inherit;">这就是为什么我要为我的项目编写单元测试。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您只是要开始为项目创建测试-请注意，今天有许多用于组织代码测试的工具和框架。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一些好东西。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.编写尽可能简单的函数。</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
众所周知，没有问题的JavaScript允许您创建可立即解决许多任务的庞大函数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您不熟悉编程，那么这对您来说似乎很积极。我要说说自己，在过去，当我编写满足我需要的大量代码时，我感觉很棒。这对我来说很重要。当我看到自己的代码可以毫无问题地工作时，我会感到更加自信，更不用说我能够编写大量功能良好的代码，从而增强了我的自信心。那时我真是天真！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您想编写易于维护的代码，简单且不太容易出错的代码，那么最好的选择就是使函数尽可能的简单和小巧。</font><font style="vertical-align: inherit;">功能越简单，就越容易与系统的其他部分隔离地对其进行测试。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于那些想要在工作中使用函数式编程原理的人来说，这一点尤其重要。</font><font style="vertical-align: inherit;">在这方面，我们可以回想一下对功能的一个众所周知的要求：一个功能只能解决一个问题，而它需要很好地解决这个问题。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.永远记住使用JSON.parse和JSON.stringify时错误处理的重要性</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在JavaScript编程中，将JSON数据传递给方法时</font></font><code>JSON.parse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，有必要考虑以下事实：该方法期望接收正确执行的JSON代码作为第一个参数。如果此方法收到错误的JSON材料，则将引发错误。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里的危险是，传递</font></font><code>JSON.parse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不正确的JSON代码会导致应用程序停止。在工作中，我最近遇到一种情况，由于其中一个外部软件包不适合</font></font><code>JSON.parse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该块</font><font style="vertical-align: inherit;">，因此我们的一个Web项目引发了错误</font></font><code>try/catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这导致页面失败，直到修复了外部程序包代码，我们才能摆脱该问题。这一切都是由于以下事实而发生的：在代码运行期间，出现了未处理的错误：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">SyntaxError</span>: Unexpected token } <span class="hljs-keyword">in</span> <span class="hljs-built_in">JSON</span> at position <span class="hljs-number">107</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在处理从外部来源传入应用程序的JSON数据时，人们不能希望它会被正确格式化。</font><font style="vertical-align: inherit;">您总是需要为它们可能遇见会导致错误的事实做好准备。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们希望此处提供的建议可以提高JavaScript代码的可靠性，对您有用。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亲爱的读者们！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于想要编写更好，更可靠的JavaScript代码的人，您有什么建议？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN487670/index.html">距离创建功能最强大的粒子加速器仅一步之遥</a></li>
<li><a href="../zh-CN487674/index.html">上周第401周（2020年2月3日至9日）来自前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN487676/index.html">新的ZX Spectrum游戏竞赛-您的游戏6</a></li>
<li><a href="../zh-CN487678/index.html">国际会议PGConf.Russia 2020的边注。要点和幻灯片</a></li>
<li><a href="../zh-CN487680/index.html">全面分析ShAD-2019考试</a></li>
<li><a href="../zh-CN487684/index.html">在Vue.js上开发更快的应用程序</a></li>
<li><a href="../zh-CN487688/index.html">用Python开发类型为2019-nCoV的交互式冠状病毒分布图</a></li>
<li><a href="../zh-CN487690/index.html">PHP摘要173号（2020年1月27日至2月10日）</a></li>
<li><a href="../zh-CN487694/index.html">虚拟私有云如何托管Yandex.Cloud，以及我们的用户如何帮助我们实现有用的功能</a></li>
<li><a href="../zh-CN487696/index.html">2月10日至16日在莫斯科举行的数字活动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>