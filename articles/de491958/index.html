<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üà≥ ‚òëÔ∏è ‚õ¥Ô∏è Handbuch zur Komprimierung von Skelettanimationen üíï üë¶ ‚ÜñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel bietet einen kurzen √úberblick √ºber die Implementierung eines einfachen Animationskomprimierungsschemas und einiger verwandter Konzepte....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Handbuch zur Komprimierung von Skelettanimationen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491958/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/o1/6v/gp/o16vgpz4u-9_ntko92qweoxqzx0.png" height="50%" width="50%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel bietet einen kurzen √úberblick √ºber die Implementierung eines einfachen Animationskomprimierungsschemas und einiger verwandter Konzepte. </font><font style="vertical-align: inherit;">Ich bin kein Experte in dieser Angelegenheit, aber es gibt nur sehr wenige Informationen zu diesem Thema und es ist ziemlich fragmentiert. </font><font style="vertical-align: inherit;">Wenn Sie ausf√ºhrlichere Artikel zu diesem Thema lesen m√∂chten, empfehle ich Ihnen, auf die folgenden Links zuzugreifen:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://nfrechette.github.io/2016/10/21/anim_compression_toc/</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://technology.riotgames.com/news/compressing-skeletal-animation-data</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bitsquid.blogspot.com/2009/11/bitsquid-low-level-animation-system.html</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bitsquid.blogspot.com/2011/10/low-level-animation-part-2.html</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir beginnen, lohnt es sich, eine kurze Einf√ºhrung in die Skelettanimation und einige ihrer Grundkonzepte zu geben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundlagen der Animation und Komprimierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skelettanimation ist ein ziemlich einfaches Thema, wenn Sie das Enth√§uten vergessen. Wir haben ein Konzept eines Skeletts, das Transformationen der Knochen eines Charakters enth√§lt. Diese Knochentransformationen werden in einem hierarchischen Format gespeichert. Tats√§chlich werden sie als Delta zwischen ihrer globalen Position und der Position des Elternteils gespeichert. Die Terminologie hier ist verwirrend, da in der Spiel-Engine lokal oft als Modell- / Charakterraum bezeichnet wird und global der Weltraum ist. In der Animationsterminologie wird lokal als der Raum des Elternteils des Knochens bezeichnet, und global ist entweder der Raum des Charakters oder der Weltraum, je nachdem, ob sich der Wurzelknochen bewegt. Aber machen wir uns dar√ºber keine Sorgen. Wichtig ist, dass Knochentransformationen relativ zu ihren Eltern lokal gespeichert werden. Dies hat viele Vorteile, insbesondere beim Mischen (Mischen):Wenn die Vermischung der beiden Positionen global w√§re, w√ºrden sie in der Position linear interpoliert, was zu einer Zunahme und Abnahme der Knochen und einer Verformung des Charakters f√ºhren w√ºrde.</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Deltas verwenden, wird das Mischen von einem Unterschied zum anderen durchgef√ºhrt. Wenn also die Delta-Transformation f√ºr einen Knochen zwischen zwei Posen gleich ist, bleibt die L√§nge des Knochens konstant. Ich denke, dass es am einfachsten (aber nicht ganz genau) ist, dies so zu verstehen: Die Verwendung von Deltas f√ºhrt zu einer ‚Äûsph√§rischen‚Äú Bewegung der Knochenpositionen w√§hrend des Mischens, und das Mischen globaler Transformationen f√ºhrt zu einer linearen Bewegung der Knochenpositionen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Skelettanimation ist nur eine geordnete Liste von Keyframes mit einer (normalerweise) konstanten Framerate. Der Schl√ºsselrahmen ist die Skeletthaltung. Wenn wir eine Pose zwischen Keyframes erhalten m√∂chten, probieren wir beide Keyframes aus und mischen zwischen ihnen, wobei der Bruchteil der Zeit zwischen ihnen als Gewicht der Mischung verwendet wird. Das Bild unten zeigt eine Animation mit 30 Bildern pro Sekunde. Die Animation hat insgesamt 5 Frames und wir m√ºssen die Pose 0,52 s nach dem Start bekommen. Daher m√ºssen wir die Pose in Bild 1 und die Pose in Bild 2 abtasten und dann mit einem Mischgewicht von ca. 57% zwischen ihnen mischen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/733/f11/c43/733f11c43022b935901e6f20f8a70fab.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel f√ºr eine Animation mit 5 Bildern und eine Anforderung f√ºr eine Pose zu einem Zwischenbildzeitpunkt</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn Sie die obigen Informationen haben und der Ansicht sind, dass der Speicher f√ºr uns kein Problem darstellt, ist das sequentielle Speichern der Pose der ideale Weg, um die Animation zu speichern, wie unten gezeigt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d28/7c5/f3c/d287c5f3cbfd9a8144d20432c3a258dc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfache Speicherung von Animationsdaten</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ist das perfekt? Das Abtasten eines beliebigen Keyframes erfolgt √ºber eine einfache Memcpy-Operation. Das Abtasten einer Zwischenpose erfordert zwei Memcpy-Operationen und eine Mischoperation. Aus Sicht des Caches kopieren wir mit memcpy zwei Datenbl√∂cke der Reihe nach, dh nach dem Kopieren des ersten Frames hat einer der Caches bereits einen zweiten Frame. Sie k√∂nnen sagen: Warten Sie, wenn wir mischen, m√ºssen wir alle Knochen mischen. Was ist, wenn die meisten von ihnen nicht zwischen Frames wechseln? W√§re es nicht besser, Knochen als Datens√§tze zu speichern und nur ge√§nderte Transformationen zu mischen? Wenn dies implementiert ist, k√∂nnen beim Lesen einzelner Datens√§tze m√∂glicherweise etwas mehr Cache-Fehler auftreten, und dann m√ºssen Sie nachverfolgen, welche Konvertierungen Sie mischen m√ºssen, und so weiter ... Das Mischen scheint eine Menge Arbeit zu seinIm Wesentlichen ist es jedoch die Anwendung eines Befehls auf zwei Speicherbl√∂cke, die sich bereits im Cache befinden. Dar√ºber hinaus ist der Mischcode relativ einfach, oft nur ein Satz von SIMD-Befehlen ohne Verzweigung, und ein moderner Prozessor verarbeitet sie in wenigen Augenblicken.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem bei diesem Ansatz besteht darin, dass extrem viel Speicher ben√∂tigt wird, insbesondere bei Spielen, bei denen die folgenden Bedingungen f√ºr 95% der Daten zutreffen.</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Knochen haben eine konstante L√§nge</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Charaktere in den meisten Spielen dehnen die Knochen nicht, daher sind innerhalb derselben Animation die Aufzeichnungen der Transformationen konstant.</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalerweise skalieren wir die Knochen nicht.</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skalierung wird in Spielanimationen selten verwendet. </font><font style="vertical-align: inherit;">Es wird ziemlich aktiv in Filmen und VFX verwendet, aber sehr wenig in Spielen. </font><font style="vertical-align: inherit;">Selbst wenn verwendet, wird normalerweise die gleiche Skala verwendet.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tats√§chlich habe ich in den meisten Animationen, die ich zur Laufzeit erstellt habe, diese Tatsache ausgenutzt und die gesamte Knochentransformation in 8 Float-Variablen beibehalten: 4 zum Drehen des Quaternions, 3 zum Bewegen und 1 zum Skalieren. </font><font style="vertical-align: inherit;">Dies reduziert die Gr√∂√üe der Pose zur Laufzeit erheblich und erh√∂ht die Produktivit√§t beim Mischen und Kopieren.</font></font></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor diesem Hintergrund k√∂nnen Sie anhand des Originaldatenformats feststellen, wie ineffizient der Speicherplatz ist. </font><font style="vertical-align: inherit;">Wir duplizieren die Verschiebungs- und Skalenwerte jedes Knochens, auch wenn sie sich nicht √§ndern. </font><font style="vertical-align: inherit;">Und die Situation ger√§t schnell au√üer Kontrolle. </font><font style="vertical-align: inherit;">Normalerweise erstellen Animatoren Animationen mit einer Frequenz von 30 fps, und in Spielen auf AAA-Ebene hat ein Charakter normalerweise etwa 100 Knochen. </font><font style="vertical-align: inherit;">Basierend auf dieser Informationsmenge und einem Format von 8 Float ben√∂tigen wir ungef√§hr 3 KB pro Pose und 94 KB pro Sekunde Animation. </font><font style="vertical-align: inherit;">Werte h√§ufen sich schnell und auf einigen Plattformen kann der gesamte Speicher leicht verstopfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sprechen wir also √ºber die Komprimierung. </font><font style="vertical-align: inherit;">Beim Versuch, Daten zu komprimieren, m√ºssen verschiedene Aspekte ber√ºcksichtigt werden:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompressionsrate</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie viel haben wir geschafft, die Menge des belegten Speichers zu reduzieren</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualit√§t</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie viele Informationen haben wir aus den Quelldaten verloren?</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompressionsrate</font></font></strong><ul>
<li>     </li>
</ul></li>
<li><strong> </strong><ul>
<li>           .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich mache mir haupts√§chlich Sorgen um Qualit√§t und Geschwindigkeit und weniger um das Ged√§chtnis. Au√üerdem arbeite ich mit Spielanimationen und kann die Tatsache ausnutzen, dass wir zur Reduzierung der Speicherbelastung keine Verschiebung und Skalierung in den Daten verwenden m√ºssen. Aufgrund dessen k√∂nnen wir eine Qualit√§tsminderung vermeiden, die durch eine Verringerung der Anzahl von Frames und anderen L√∂sungen mit Verlusten verursacht wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist auch √§u√üerst wichtig zu beachten, dass Sie den Effekt der Animationskomprimierung auf die Leistung nicht untersch√§tzen sollten: In einem meiner vorherigen Projekte verringerte sich die Abtastrate um etwa 35%, und es gab auch einige Qualit√§tsprobleme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir mit der Komprimierung von Animationsdaten beginnen, m√ºssen zwei wichtige Bereiche ber√ºcksichtigt werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie schnell k√∂nnen wir einzelne Informationselemente in einem Schl√ºsselrahmen (Quaternionen, Float usw.) komprimieren?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie k√∂nnen wir die Reihenfolge der Schl√ºsselbilder komprimieren, um redundante Informationen zu entfernen?</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datendiskretisierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fast der gesamte Abschnitt kann auf ein Prinzip reduziert werden: Daten diskretisieren. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Diskretisierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine schwierige Art zu sagen, dass wir einen Wert aus einem kontinuierlichen Intervall in einen diskreten Satz von Werten konvertieren m√∂chten.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diskretisierungs-Float</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn es darum geht, Gleitkommawerte abzutasten, bem√ºhen wir uns, diesen Gleitkommawert als Ganzzahl mit weniger Bits darzustellen. Der Trick besteht darin, dass eine Ganzzahl m√∂glicherweise nicht tats√§chlich eine Quellennummer darstellt, sondern einen Wert in einem diskreten Intervall, der einem kontinuierlichen Intervall zugeordnet ist. Normalerweise wird ein sehr einfacher Ansatz verwendet. Um einen Wert abzutasten, ben√∂tigen wir zun√§chst ein Intervall f√ºr den urspr√ºnglichen Wert. Nachdem wir dieses Intervall erhalten haben, normalisieren wir den Anfangswert f√ºr dieses Intervall. Dann wird dieser normalisierte Wert mit dem maximal m√∂glichen Wert f√ºr die gew√ºnschte gegebene Ausgangsgr√∂√üe in Bit multipliziert. Das hei√üt, f√ºr 16 Bits multiplizieren wir den Wert mit 65535. Dann wird der resultierende Wert auf die n√§chste ganze Zahl gerundet und gespeichert. Dies ist im Bild deutlich zu sehen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e73/827/f7be73827067126fd51c0bf6f2396b10.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel f√ºr das Abtasten eines 32-Bit-Floats in eine vorzeichenlose 16-Bit-Ganzzahl</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Um den urspr√ºnglichen Wert wieder zu erhalten, f√ºhren wir die Operationen einfach in umgekehrter Reihenfolge aus. Es ist wichtig anzumerken, dass wir irgendwo das Anfangsintervall des Wertes aufzeichnen m√ºssen; Andernfalls k√∂nnen wir den abgetasteten Wert nicht dekodieren. Die Anzahl der Bits im abgetasteten Wert bestimmt die Schrittgr√∂√üe im normalisierten Intervall und damit die Schrittgr√∂√üe im urspr√ºnglichen Intervall: Der decodierte Wert ist ein Vielfaches dieser Schrittgr√∂√üe, wodurch wir den maximalen Fehler, der aufgrund des Abtastprozesses auftritt, leicht berechnen k√∂nnen, sodass wir die Anzahl der Bits bestimmen k√∂nnen f√ºr unsere Bewerbung erforderlich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde keine Beispiele f√ºr den Quellcode geben, da es eine ziemlich bequeme und einfache Bibliothek f√ºr die Durchf√ºhrung grundlegender Stichprobenoperationen gibt, die eine gute Quelle zu diesem Thema darstellt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/r-lyeh-archived/quant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (w√ºrde ich sagen dass Sie nicht die Quaternion-Diskretisierungsfunktion verwenden sollten, aber dazu sp√§ter mehr).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quaternion-Komprimierung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Quaternion-Komprimierung ist ein gut untersuchtes Thema, daher werde ich nicht wiederholen, was andere Leute besser erkl√§rt haben. </font><font style="vertical-align: inherit;">Hier ist ein Link zu einem Snapshot-Komprimierungsbeitrag, der die beste Beschreibung zu diesem Thema enth√§lt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://gafferongames.com/post/snapshot_compression/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe jedoch etwas zu diesem Thema zu sagen. </font><font style="vertical-align: inherit;">Die Bitsquid-Posts, die sich mit Quaternionskomprimierung befassen, schlagen vor, die Quaternion auf 32 Bit zu komprimieren, wobei ungef√§hr 10 Datenbits f√ºr jede Quaternionskomponente verwendet werden. </font><font style="vertical-align: inherit;">Dies ist genau das, was Quant tut, da es auf Bitsquid-Posts basiert. </font><font style="vertical-align: inherit;">Meiner Meinung nach ist eine solche Kompression zu gro√ü und hat in meinen Tests starkes Sch√ºtteln verursacht. </font><font style="vertical-align: inherit;">Vielleicht haben die Autoren weniger tiefe Hierarchien des Charakters verwendet, aber wenn Sie mehr als 15 Quaternionen aus meinen Animationsbeispielen multiplizieren, stellt sich der kombinierte Fehler als ziemlich schwerwiegend heraus. </font><font style="vertical-align: inherit;">Meiner Meinung nach </font><font style="vertical-align: inherit;">betr√§gt </font><font style="vertical-align: inherit;">das </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">absolute</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Minimum an Genauigkeit 48 Bit pro Quaternion.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Downsizing aufgrund von Sampling</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir uns mit den verschiedenen Komprimierungsmethoden und der Anordnung der Datens√§tze befassen, wollen wir uns ansehen, welche Art der Komprimierung wir erhalten, wenn wir einfach die Diskretisierung in der urspr√ºnglichen Schaltung anwenden. Wir werden das gleiche Beispiel wie zuvor verwenden (ein Skelett von 100 Knochen). Wenn Sie also 48 Bit (3 x 16 Bit) pro Quaternion verwenden, 48 Bit (3 √ó 16) zum Verschieben und 16 Bit zum Skalieren, dann insgesamt zur Konvertierung Wir brauchen 14 Bytes anstelle von 32 Bytes. Dies sind 43,75% der Originalgr√∂√üe. Das hei√üt, f√ºr 1 Sekunde Animation mit einer Frequenz von 30 fps haben wir das Volumen von ca. 94 KB auf ca. 41 KB reduziert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist √ºberhaupt nicht schlecht, die Diskretisierung ist relativ kosteng√ºnstig, sodass die Auspackzeit nicht zu stark beeintr√§chtigt wird. </font><font style="vertical-align: inherit;">Wir haben einen guten Ausgangspunkt f√ºr den Start gefunden, und in einigen F√§llen reicht dies sogar aus, um Animationen innerhalb des Ressourcenbudgets zu implementieren und eine hervorragende Qualit√§t und Leistung sicherzustellen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komprimierung aufzeichnen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier wird alles sehr kompliziert, insbesondere wenn Entwickler anfangen, Techniken wie das Reduzieren des Schl√ºsselrahmens, die Kurvenanpassung usw. auszuprobieren. </font><font style="vertical-align: inherit;">Auch in dieser Phase beginnen wir wirklich, die Qualit√§t der Animationen zu verringern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei fast allen derartigen Entscheidungen wird davon ausgegangen, dass die Eigenschaften jedes Knochens (Rotation, Verschiebung und Skalierung) als separate Aufzeichnung gespeichert werden. </font><font style="vertical-align: inherit;">Daher k√∂nnen wir die Schaltung umdrehen, wie ich es zuvor gezeigt habe:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f64/752/16a/f6475216adb6ac795e1737de30aef6af.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern von Knochendaten als Datens√§tze</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Hier speichern wir einfach alle Datens√§tze nacheinander, k√∂nnen aber auch alle Datens√§tze von Rotationen, Verschiebungen und Skalen gruppieren. Die Grundidee ist, dass wir vom Speichern von Daten aus jeder Pose zum Speichern von Datens√§tzen √ºbergehen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir dies getan haben, k√∂nnen wir andere M√∂glichkeiten verwenden, um den belegten Speicher weiter zu reduzieren. Der erste besteht darin, Frames zu l√∂schen. Hinweis: Dies erfordert kein Datensatzformat und diese Methode kann im vorherigen Schema angewendet werden. Diese Methode funktioniert, f√ºhrt jedoch zum Verlust kleiner Bewegungen in der Animation, da wir die meisten Daten verwerfen. Diese Technik wurde auf der PS3 aktiv eingesetzt, und manchmal mussten wir uns auf wahnsinnig niedrige Abtastfrequenzen b√ºcken, zum Beispiel bis zu 7 Bilder pro Sekunde (normalerweise f√ºr nicht sehr wichtige Animationen). Ich habe immer noch schlechte Erinnerungen daran, als Animationsprogrammierer sehe ich deutlich die verlorenen Details und die Ausdruckskraft, aber wenn Sie aus der Sicht des Systemprogrammierers schauen, k√∂nnen wir sagen, dass die Animation "fast" dieselbe ist, weil die Bewegung im Allgemeinen bestehen bleibt, aber gleichzeitig wir Sparen Sie viel Speicher.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen wir diesen Ansatz weg (meiner Meinung nach ist er zu destruktiv) und betrachten andere m√∂gliche Optionen. Ein anderer beliebter Ansatz besteht darin, eine Kurve f√ºr jeden Datensatz zu erstellen und eine Reduzierung der Keyframes auf der Kurve durchzuf√ºhren, d. H. Entfernen doppelter Keyframes. Aus Sicht der Spielanimationen werden bei diesem Ansatz die Bewegungs- und Skalenaufzeichnungen perfekt komprimiert und manchmal auf einen Keyframe reduziert. Diese L√∂sung ist zerst√∂rungsfrei, erfordert jedoch das Entpacken, da wir jedes Mal, wenn wir die Transformation erhalten m√ºssen, die Kurve berechnen m√ºssen, da wir nicht mehr nur zu den Daten im Speicher gehen k√∂nnen. Die Situation kann ein wenig verbessert werden, wenn Sie </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animationen nur in eine Richtung berechnen.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und speichern Sie den Status des Samplers jeder Animation f√ºr jeden Knochen (d. h. woher die Berechnung der Kurve stammt), aber Sie m√ºssen daf√ºr mit einer Erh√∂hung des Speichers und einer signifikanten Erh√∂hung der Codekomplexit√§t bezahlen. In modernen Animationssystemen spielen wir Animationen oft nicht von Anfang bis Ende ab. Oft machen sie zu bestimmten Zeitvers√§tzen √úberg√§nge zu neuen Animationen, beispielsweise durch synchronisiertes Mischen oder Phasenanpassung. Oft probieren wir einzelne, aber nicht aufeinanderfolgende Posen aus, um Dinge wie das Mischen von Zielen / Betrachten eines Objekts zu implementieren, und oft werden Animationen in umgekehrter Reihenfolge abgespielt. Daher empfehle ich nicht, eine solche L√∂sung zu verwenden, da sich der Aufwand aufgrund der Komplexit√§t und potenzieller Fehler einfach nicht lohnt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt auch das Konzept, nicht nur identische Schl√ºssel in Kurven zu l√∂schen, sondern auch einen Schwellenwert anzugeben, bei dem √§hnliche Schl√ºssel gel√∂scht werden. Dies f√ºhrt dazu, dass die Animation st√§rker verblasst, √§hnlich wie beim L√∂schen von Frames, da das Endergebnis hinsichtlich der Daten dasselbe ist. Es werden h√§ufig Animationskomprimierungsschemata verwendet, bei denen f√ºr jeden Datensatz Komprimierungsparameter festgelegt werden und Animatoren st√§ndig mit diesen Werten gequ√§lt werden, um gleichzeitig die Qualit√§t zu erhalten und die Gr√∂√üe zu reduzieren. Dies ist ein schmerzhafter und stressiger Arbeitsablauf, der jedoch erforderlich ist, wenn Sie mit dem begrenzten Speicher √§lterer Konsolengenerationen arbeiten. Gl√ºcklicherweise haben wir heute ein gro√ües Speicherbudget und brauchen keine so schrecklichen Dinge.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All diese Aspekte werden in den Beitr√§gen von Riot / BitSquid und Nicholas offenbart (siehe Links am Anfang meines Artikels). Ich werde nicht im Detail dar√ºber sprechen. Stattdessen werde ich dar√ºber sprechen, was ich √ºber das Komprimieren der Datens√§tze beschlossen habe ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich ... habe beschlossen, die Datens√§tze nicht zu komprimieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor Sie mit dem Winken beginnen, lassen Sie mich erkl√§ren ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ich die Daten in den Datens√§tzen speichere, speichere ich die Rotationsdaten f√ºr alle Frames. Wenn es um Bewegung und Skalierung geht, verfolge ich, ob Bewegung und Skalierung w√§hrend der Komprimierung statisch sind, und wenn ja, speichere ich nur einen Wert pro Datensatz. Das hei√üt, wenn sich der Datensatz entlang X bewegt, aber nicht entlang Y und Z, speichere ich alle Werte f√ºr das Verschieben des Datensatzes entlang X, aber nur einen Wert f√ºr das Verschieben des Datensatzes entlang Y und Z.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Situation tritt bei den meisten Knochen in etwa 95% unserer Animationen auf, sodass wir am Ende den belegten Speicher erheblich reduzieren k√∂nnen, ohne an Qualit√§t zu verlieren. Dies erfordert Arbeit unter dem Gesichtspunkt der Inhaltserstellung (DCC): Wir m√∂chten nicht, dass die Knochen im Workflow f√ºr die Animationserstellung leichte Bewegungen und Zooms aufweisen, aber ein solcher Vorteil ist die zus√§tzlichen Kosten wert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Animationsbeispiel gibt es nur zwei Datens√§tze mit Verschiebung und keine Datens√§tze mit Skalierung. Dann verringert sich das Datenvolumen f√ºr 1 Sekunde der Animation von 41 KB auf 18,6 KB (dh bis zu 20% des Volumens der Originaldaten). Die Situation wird noch besser, wenn die Dauer der Animation zunimmt, wir Ressourcen nur f√ºr das Aufzeichnen von Kurven und dynamischen Bewegungen verwenden und die Kosten f√ºr statische Aufzeichnungen konstant bleiben, was bei langen Animationen mehr spart. Und wir m√ºssen keinen Qualit√§tsverlust durch Stichproben feststellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Anbetracht all dieser Informationen sieht mein endg√ºltiges Datenschema folgenderma√üen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f5/347/eb0/9f5347eb09718967ebacbe89d443e992.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel f√ºr ein komprimiertes Animationsdatenschema (3 Bilder pro Datensatz)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Au√üerdem speichere ich den Versatz im Datenblock, um die Daten jedes Knochens zu starten. </font><font style="vertical-align: inherit;">Dies ist notwendig, da wir manchmal Daten f√ºr nur einen Knochen abtasten m√ºssen, ohne die gesamte Pose zu lesen. </font><font style="vertical-align: inherit;">Dies bietet uns eine schnelle M√∂glichkeit, direkt auf Datensatzdaten zuzugreifen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zus√§tzlich zu den in einem Speicherblock gespeicherten Animationsdaten habe ich auch Komprimierungsoptionen f√ºr jeden Datensatz:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d7/b3d/7a3/4d7b3d7a3f1362c0429d72591268dbce.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel f√ºr Komprimierungsparameter f√ºr Datens√§tze aus meiner Kruger-Engine</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Diese Parameter speichern alle Daten, die ich zum Dekodieren der abgetasteten Werte jedes Datensatzes ben√∂tige. </font><font style="vertical-align: inherit;">Sie √ºberwachen auch die Statik von Datens√§tzen, sodass ich wei√ü, wie ich mit komprimierten Daten umgehen soll, wenn ich beim Sampling auf einen statischen Datensatz sto√üe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen auch feststellen, dass die Diskretisierung f√ºr jeden Datensatz individuell ist: W√§hrend der Komprimierung verfolge ich die Minimal- und Maximalwerte jedes Merkmals (z. B. entlang des X) jedes Datensatzes, um sicherzustellen, dass die Daten innerhalb des minimalen / maximalen Intervalls diskretisiert werden und die maximale Genauigkeit erhalten bleibt. </font><font style="vertical-align: inherit;">Ich denke nicht, dass es im Allgemeinen m√∂glich ist, globale Abtastintervalle zu erstellen, ohne Ihre Daten zu zerst√∂ren (wenn die Werte au√üerhalb des Intervalls liegen) und ohne signifikante Fehler zu machen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie dem auch sei, hier ist eine kurze Zusammenfassung meiner dummen Versuche, die Animationskomprimierung zu implementieren: Am Ende verwende ich fast die Komprimierung.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491942/index.html">Wie wir item2vec verwenden, um √§hnliche Produkte zu empfehlen</a></li>
<li><a href="../de491944/index.html">So kombinieren Sie zwei Plattformen zu einer und beleidigen Benutzer nicht. Yandex.Kew Entwicklererfahrung</a></li>
<li><a href="../de491946/index.html">Gesetze der Programmierung</a></li>
<li><a href="../de491948/index.html">Design-Token k√∂nnen mehr: Sie k√∂nnen eine einzige Informationsquelle √ºber UI-Komponenten erstellen</a></li>
<li><a href="../de491956/index.html">Rust 1.42.0 Release: Slice-Vorlagen und bequemere Panikmeldungen</a></li>
<li><a href="../de491960/index.html">√Ñra, in der es schwer ist, sich zu verlaufen</a></li>
<li><a href="../de491962/index.html">VPN-Killer. Richtiger Fernzugriff auf Kampfserver</a></li>
<li><a href="../de491964/index.html">Remotecodeausf√ºhrung in SMB v3: CVE-2020-0796</a></li>
<li><a href="../de491974/index.html">Coronavirus: Warum m√ºssen Sie jetzt handeln?</a></li>
<li><a href="../de491976/index.html">Wir drehen die UNIT-Wirtschaft f√ºr einen Online-Shop oder eine Produktion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>