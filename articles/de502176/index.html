<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👩🏾 🗓️ 🤴🏼 Los: JSON-Deserialisierung mit falscher Eingabe oder Umgehen von API-Entwicklerfehlern 👨🏼‍🔧 🧝🏽 🍧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kürzlich habe ich auf Go einen http-Client für einen Dienst entwickelt, der eine REST-API mit json als Codierungsformat bereitstellt. Eine Standardauf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Los: JSON-Deserialisierung mit falscher Eingabe oder Umgehen von API-Entwicklerfehlern</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502176/"><img src="https://habrastorage.org/webt/pf/hz/xm/pfhzxmp9antvvecnexqujg6pkzk.jpeg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kürzlich habe ich auf Go einen http-Client für einen Dienst entwickelt, der eine REST-API mit json als Codierungsformat bereitstellt. </font><font style="vertical-align: inherit;">Eine Standardaufgabe, aber im Laufe der Arbeit musste ich mich einem nicht standardmäßigen Problem stellen. </font><font style="vertical-align: inherit;">Ich sage dir, worum es geht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie wissen, hat das JSON-Format Datentypen. </font><font style="vertical-align: inherit;">Vier Grundelemente: Zeichenfolge, Zahl, Boolescher Wert, Null; </font><font style="vertical-align: inherit;">und zwei Strukturtypen: ein Objekt und ein Array. </font><font style="vertical-align: inherit;">In diesem Fall interessieren uns primitive Typen. </font><font style="vertical-align: inherit;">Hier ist ein Beispiel für einen JSON-Code mit vier Feldern unterschiedlichen Typs:</font></font><br>
<br>
<pre><code class="json hljs">{
	<span class="hljs-attr">"name"</span>:<span class="hljs-string">"qwerty"</span>,
	<span class="hljs-attr">"price"</span>:<span class="hljs-number">258.25</span>,
	<span class="hljs-attr">"active"</span>:<span class="hljs-literal">true</span>,
	<span class="hljs-attr">"description"</span>:<span class="hljs-literal">null</span>,<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie das Beispiel zeigt, wird der Zeichenfolgenwert in Anführungszeichen gesetzt. Numerisch - hat keine Anführungszeichen. Ein boolescher Typ kann nur einen von zwei Werten haben: true oder false (ohne Anführungszeichen). Und der Null-Typ ist dementsprechend null (auch ohne Anführungszeichen).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt das Problem selbst. Irgendwann stellte ich bei einer detaillierten Untersuchung des von einem Drittanbieter-Service erhaltenen JSON-Codes fest, dass eines der Felder (nennen wir es Preis) regelmäßig einen Zeichenfolgenwert (die Zahl in Anführungszeichen) zusätzlich zum numerischen Wert enthält. Das heißt, dieselbe Abfrage mit unterschiedlichen Parametern kann eine Zahl als Zahl oder dieselbe Zahl als Zeichenfolge zurückgeben. Ich kann mir nicht vorstellen, wie der Code, der solche Ergebnisse zurückgibt, am anderen Ende organisiert ist, aber anscheinend liegt dies daran, dass der Dienst selbst ein Aggregator ist und Daten aus verschiedenen Quellen abruft und die Entwickler die Serverantwort json nicht auf ein einziges Format gebracht haben. Trotzdem ist es notwendig, mit dem zu arbeiten, was ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber dann war ich noch mehr überrascht. </font><font style="vertical-align: inherit;">Das logische Feld (nennen wir es aktiv) gab zusätzlich zu true und false die Zeichenfolgenwerte "true", "false" und sogar die numerischen Werte 1 und 0 (true bzw. false) zurück.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All diese Verwirrung über Datentypen wäre nicht kritisch, wenn ich json say in schwach typisiertem PHP verarbeiten würde, aber Go hat eine starke Typisierung und erfordert eine klare Angabe des Typs des desialisierten Feldes. </font><font style="vertical-align: inherit;">Infolgedessen musste ein Mechanismus implementiert werden, mit dem alle Werte des aktiven Felds während des Deserialisierungsprozesses in einen logischen Typ und jeder Wert des Preisfelds in einen numerischen konvertiert werden können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit dem Preisfeld. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben folgenden JSON-Code:</font></font><br>
<br>
<pre><code class="json hljs">[<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">2.58</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">7.15</span>}<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, json enthält ein Array von Objekten mit zwei Feldern eines numerischen Typs. </font><font style="vertical-align: inherit;">Der Standard-Deserialisierungscode für diesen json on Go sieht folgendermaßen aus:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id    <span class="hljs-keyword">int</span>     <span class="hljs-string">`json:"id"`</span>
	Price <span class="hljs-keyword">float64</span> <span class="hljs-string">`json:"price"`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	jsonString := <span class="hljs-string">`[{"id":1,"price":2.58},
					{"id":4,"price":7.15}]`</span><font></font>
<font></font>
	targets := []Target{}<font></font>
<font></font>
	err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(jsonString), &amp;targets)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
		fmt.Println(err)<font></font>
		<span class="hljs-keyword">return</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> targets {<font></font>
		fmt.Println(t.Id, <span class="hljs-string">"-"</span>, t.Price)<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Code deserialisieren wir das ID-Feld in int und das Preisfeld in float64. </font><font style="vertical-align: inherit;">Nehmen wir nun an, unser JSON-Code sieht folgendermaßen aus:</font></font><br>
<br>
<pre><code class="json hljs">[<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">2.58</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-string">"2.58"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">7.15</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">4</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-string">"7.15"</span>}<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, das Preisfeld enthält Werte sowohl eines numerischen Typs als auch einer Zeichenfolge. </font><font style="vertical-align: inherit;">In diesem Fall können nur die numerischen Werte des Preisfelds in den Typ float64 dekodiert werden, während Zeichenfolgenwerte einen Fehler bezüglich der Inkompatibilität von Typen verursachen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass weder float64 noch ein anderer primitiver Typ zum Deserialisieren dieses Felds geeignet ist, und wir benötigen unseren eigenen benutzerdefinierten Typ mit eigener Deserialisierungslogik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deklarieren Sie als solchen Typ eine CustomFloat64-Struktur mit einem einzelnen Float64-Feld vom Typ float64.</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> CustomFloat64 <span class="hljs-keyword">struct</span>{<font></font>
	Float64 <span class="hljs-keyword">float64</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Geben Sie diesen Typ sofort für das Feld Preis in der Zielstruktur an:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id    <span class="hljs-keyword">int</span>           <span class="hljs-string">`json:"id"`</span>
	Price CustomFloat64 <span class="hljs-string">`json:"price"`</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen Sie Ihre eigene Logik zum Dekodieren eines Felds vom Typ CustomFloat64 beschreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Paket "encoding / json" verfügt über zwei spezielle Methoden: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MarshalJSON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnmarshalJSON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mit denen die Codierungs- und Decodierungslogik eines bestimmten Benutzerdatentyps angepasst werden kann. Es reicht aus, diese Methoden zu überschreiben und Ihre eigene Implementierung zu beschreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überschreiben Sie die UnmarshalJSON-Methode für einen beliebigen Typ CustomFloat64. In diesem Fall muss die Signatur der Methode genau befolgt werden, da sie sonst einfach nicht funktioniert und vor allem keinen Fehler verursacht.</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf *CustomFloat64)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Eingabe nimmt diese Methode eine Schicht von Bytes (Daten), die den Wert eines bestimmten Feldes des decodierten JSON enthält. Wenn wir diese Folge von Bytes in eine Zeichenfolge konvertieren, sehen wir den Wert des Feldes genau in der Form, in der es in json geschrieben ist. Das heißt, wenn es sich um einen Zeichenfolgentyp handelt, wird genau eine Zeichenfolge mit doppelten Anführungszeichen („258“) angezeigt. Wenn es sich um einen numerischen Typ handelt, wird eine Zeichenfolge ohne Anführungszeichen (258) angezeigt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um einen numerischen Wert von einem Zeichenfolgenwert zu unterscheiden, müssen Sie prüfen, ob das erste Zeichen ein Anführungszeichen ist. Da das doppelte Anführungszeichen in der UNICODE-Tabelle ein Byte belegt, müssen wir nur das erste Byte des Daten-Slice überprüfen, indem wir es mit der Zeichennummer in UNICODE vergleichen. Dies ist Nummer 34. Beachten Sie, dass ein Zeichen im Allgemeinen nicht einem Byte entspricht, da es mehr als ein Byte benötigen kann. Ein Charakter in Go entspricht Rune (Rune). In unserem Fall ist diese Bedingung ausreichend:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == <span class="hljs-number">34</span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Bedingung erfüllt ist, hat der Wert einen Zeichenfolgentyp, und wir müssen die Zeichenfolge zwischen den Anführungszeichen abrufen, dh das Slice-Byte zwischen dem ersten und dem letzten Byte. </font><font style="vertical-align: inherit;">Dieses Slice enthält einen numerischen Wert, der in den primitiven Typ float64 dekodiert werden kann. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir die Methode json.Unmarshal darauf anwenden können, während das Ergebnis in der CustomFloat64-Struktur im Feld Float64 gespeichert wird.</font></font><br>
<br>
<pre><code class="go hljs">err := json.Unmarshal(data[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(data)<span class="hljs-number">-1</span>], &amp;cf.Float64)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Daten-Slice nicht mit einem Anführungszeichen beginnt, enthält es bereits einen numerischen Datentyp, und wir können die Methode json.Unmarshal direkt auf das gesamte Daten-Slice anwenden.</font></font><br>
<br>
<pre><code class="go hljs">err := json.Unmarshal(data, &amp;cf.Float64)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der vollständige Code für die UnmarshalJSON-Methode:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf *CustomFloat64)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == <span class="hljs-number">34</span> {<font></font>
		err := json.Unmarshal(data[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(data)<span class="hljs-number">-1</span>], &amp;cf.Float64)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		err := json.Unmarshal(data, &amp;cf.Float64)<font></font>
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen werden unter Verwendung der json.Unmarshal-Methode für unseren json-Code alle Werte des Preisfelds für uns transparent in einen primitiven Typ float64 konvertiert und das Ergebnis in das Float64-Feld der CustomFloat64-Struktur geschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen wir möglicherweise die Zielstruktur wieder in json konvertieren. Wenn wir jedoch die json.Marshal-Methode direkt auf den CustomFloat64-Typ anwenden, serialisieren wir diese Struktur als Objekt. Wir müssen das Preisfeld in einen numerischen Wert kodieren. Um die Codierungslogik des benutzerdefinierten Typs CustomFloat64 anzupassen, implementieren wir die MarshalJSON-Methode dafür, wobei wir die Signatur der Methode genau beachten:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf CustomFloat64)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cf.Float64)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei dieser Methode müssen Sie lediglich die json.Marshal-Methode erneut verwenden, sie jedoch bereits nicht auf die CustomFloat64-Struktur, sondern auf das Float64-Feld anwenden. </font><font style="vertical-align: inherit;">Von der Methode geben wir das empfangene Byte Slice und den Fehler zurück. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der vollständige Code, der die Ergebnisse der Serialisierung und Deserialisierung anzeigt (die Fehlerprüfung wird der Kürze halber weggelassen, die Nummer des Bytes mit dem doppelten Anführungszeichen ist konstant):</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"encoding/json"</span>
	<span class="hljs-string">"errors"</span>
	<span class="hljs-string">"fmt"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">type</span> CustomFloat64 <span class="hljs-keyword">struct</span> {<font></font>
	Float64 <span class="hljs-keyword">float64</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> QUOTES_BYTE = <span class="hljs-number">34</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf *CustomFloat64)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == QUOTES_BYTE {<font></font>
		err := json.Unmarshal(data[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(data)<span class="hljs-number">-1</span>], &amp;cf.Float64)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		err := json.Unmarshal(data, &amp;cf.Float64)<font></font>
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf CustomFloat64)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cf.Float64)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id    <span class="hljs-keyword">int</span>           <span class="hljs-string">`json:"id"`</span>
	Price CustomFloat64 <span class="hljs-string">`json:"price"`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	jsonString := <span class="hljs-string">`[{"id":1,"price":2.58},
					{"id":2,"price":"2.58"},
					{"id":3,"price":7.15},
					{"id":4,"price":"7.15"}]`</span><font></font>
<font></font>
	targets := []Target{}<font></font>
<font></font>
	_ := json.Unmarshal([]<span class="hljs-keyword">byte</span>(jsonString), &amp;targets)<font></font>
<font></font>
	<span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> targets {<font></font>
		fmt.Println(t.Id, <span class="hljs-string">"-"</span>, t.Price.Float64)<font></font>
	}<font></font>
<font></font>
	jsonStringNew, _ := json.Marshal(targets)<font></font>
	fmt.Println(<span class="hljs-keyword">string</span>(jsonStringNew))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ergebnis der Codeausführung:</font></font><br>
<br>
<pre><code class="bash hljs">1 - 2.58<font></font>
2 - 2.58<font></font>
3 - 7.15<font></font>
4 - 7.15<font></font>
[{<span class="hljs-string">"id"</span>:1,<span class="hljs-string">"price"</span>:2.58},{<span class="hljs-string">"id"</span>:2,<span class="hljs-string">"price"</span>:2.58},{<span class="hljs-string">"id"</span>:3,<span class="hljs-string">"price"</span>:7.15},{<span class="hljs-string">"id"</span>:4,<span class="hljs-string">"price"</span>:7.15}]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fahren wir mit dem zweiten Teil fort und implementieren denselben Code für die JSON-Deserialisierung mit inkonsistenten Werten des logischen Felds. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben folgenden JSON-Code:</font></font><br>
<br>
<pre><code class="json hljs">[<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-literal">true</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"true"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"1"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">4</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-number">1</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">5</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-literal">false</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">6</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"false"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">7</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"0"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">8</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-number">0</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">9</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">""</span>}<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall impliziert das aktive Feld einen logischen Typ und das Vorhandensein von nur einem von zwei Werten: wahr und falsch. </font><font style="vertical-align: inherit;">Nicht-boolesche Werte müssen während der Deserialisierung in boolesche Werte konvertiert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im aktuellen Beispiel geben wir die folgenden Übereinstimmungen zu. </font><font style="vertical-align: inherit;">Wahre Werte entsprechen: wahr (logisch), wahr (Zeichenfolge), 1 (Zeichenfolge), 1 (numerisch). </font><font style="vertical-align: inherit;">Der falsche Wert entspricht: false (logisch), false (Zeichenfolge), 0 (Zeichenfolge), 0 (numerisch), "" (leere Zeichenfolge). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst deklarieren wir die Zielstruktur für die Deserialisierung. </font><font style="vertical-align: inherit;">Als Typ des Felds Aktiv geben wir sofort den benutzerdefinierten Typ CustomBool an:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id     <span class="hljs-keyword">int</span>        <span class="hljs-string">`json:"id"`</span>
	Active CustomBool <span class="hljs-string">`json:"active"`</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CustomBool ist eine Struktur mit einem einzelnen Bool-Feld vom Typ Bool:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> CustomBool <span class="hljs-keyword">struct</span> {<font></font>
	Bool <span class="hljs-keyword">bool</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir implementieren die UnmarshalJSON-Methode für diese Struktur. </font><font style="vertical-align: inherit;">Ich gebe Ihnen sofort den Code:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CustomBool)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">switch</span> <span class="hljs-keyword">string</span>(data) {
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"true"`</span>, <span class="hljs-string">`true`</span>, <span class="hljs-string">`"1"`</span>, <span class="hljs-string">`1`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">true</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"false"`</span>, <span class="hljs-string">`false`</span>, <span class="hljs-string">`"0"`</span>, <span class="hljs-string">`0`</span>, <span class="hljs-string">`""`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">false</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomBool: parsing \""</span> + <span class="hljs-keyword">string</span>(data) + <span class="hljs-string">"\": unknown value"</span>)<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da das aktive Feld in unserem Fall eine begrenzte Anzahl von Werten hat, können wir das switch-case-Konstrukt verwenden, um zu entscheiden, wie der Wert des Bool-Felds der CustomBool-Struktur sein soll. Zur Überprüfung benötigen Sie nur zwei Fallblöcke. Im ersten Block überprüfen wir den Wert auf true, im zweiten auf false.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie mögliche Werte schreiben, sollten Sie auf die Rolle des Kieses achten (dies ist ein solches Anführungszeichen auf dem Schlüssel mit dem Buchstaben E im englischen Layout). Mit diesem Zeichen können Sie doppelte Anführungszeichen in einer Zeichenfolge umgehen. Aus Gründen der Übersichtlichkeit habe ich die Werte mit Anführungszeichen und ohne Anführungszeichen mit diesem Symbol versehen. Somit entspricht "false" der Zeichenfolge false (ohne Anführungszeichen, geben Sie bool in json ein), und "false" entspricht der Zeichenfolge "false" (mit Anführungszeichen, geben Sie string in json ein). Das Gleiche gilt für die Werte "1" und "1". Die erste ist die Zahl 1 (in json ohne Anführungszeichen geschrieben), die zweite ist die Zeichenfolge "1" (in json mit Anführungszeichen). Dieser Eintrag `` "` ist eine leere Zeichenfolge, d. H. Im JSON-Format sieht er folgendermaßen aus: "". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der entsprechende Wert (true oder false) wird direkt in das Bool-Feld der CustomBool-Struktur geschrieben:</font></font><br>
<br>
<pre><code class="go hljs">cb.Bool = <span class="hljs-literal">true</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Standardblock geben wir einen Fehler zurück, der besagt, dass das Feld einen unbekannten Wert hat:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomBool: parsing \""</span> + <span class="hljs-keyword">string</span>(data) + <span class="hljs-string">"\": unknown value"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können wir die json.Unmarshal-Methode auf unseren json-Code anwenden, und die Werte des aktiven Felds werden in einen primitiven Bool-Typ konvertiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir implementieren die MarshalJSON-Methode für die CustomBool-Struktur:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb CustomBool)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cb.Bool)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier gibt es nichts Neues. </font><font style="vertical-align: inherit;">Die Methode serialisiert das Bool-Feld der CustomBool-Struktur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der vollständige Code, der die Ergebnisse der Serialisierung und Deserialisierung anzeigt (Fehlerprüfung der Kürze halber weggelassen):</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"encoding/json"</span>
	<span class="hljs-string">"errors"</span>
	<span class="hljs-string">"fmt"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">type</span> CustomBool <span class="hljs-keyword">struct</span> {<font></font>
	Bool <span class="hljs-keyword">bool</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CustomBool)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">switch</span> <span class="hljs-keyword">string</span>(data) {
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"true"`</span>, <span class="hljs-string">`true`</span>, <span class="hljs-string">`"1"`</span>, <span class="hljs-string">`1`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">true</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"false"`</span>, <span class="hljs-string">`false`</span>, <span class="hljs-string">`"0"`</span>, <span class="hljs-string">`0`</span>, <span class="hljs-string">`""`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">false</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomBool: parsing \""</span> + <span class="hljs-keyword">string</span>(data) + <span class="hljs-string">"\": unknown value"</span>)<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb CustomBool)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cb.Bool)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id     <span class="hljs-keyword">int</span>        <span class="hljs-string">`json:"id"`</span>
	Active CustomBool <span class="hljs-string">`json:"active"`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	jsonString := <span class="hljs-string">`[{"id":1,"active":true},
					{"id":2,"active":"true"},
					{"id":3,"active":"1"},
					{"id":4,"active":1},
					{"id":5,"active":false},
					{"id":6,"active":"false"},
					{"id":7,"active":"0"},
					{"id":8,"active":0},
					{"id":9,"active":""}]`</span><font></font>
<font></font>
	targets := []Target{}<font></font>
<font></font>
	_ = json.Unmarshal([]<span class="hljs-keyword">byte</span>(jsonString), &amp;targets)<font></font>
<font></font>
	<span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> targets {<font></font>
		fmt.Println(t.Id, <span class="hljs-string">"-"</span>, t.Active.Bool)<font></font>
	}<font></font>
<font></font>
	jsonStringNew, _ := json.Marshal(targets)<font></font>
	fmt.Println(<span class="hljs-keyword">string</span>(jsonStringNew))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ergebnis der Codeausführung:</font></font><br>
<br>
<pre><code class="bash hljs">1 - <span class="hljs-literal">true</span>
2 - <span class="hljs-literal">true</span>
3 - <span class="hljs-literal">true</span>
4 - <span class="hljs-literal">true</span>
5 - <span class="hljs-literal">false</span>
6 - <span class="hljs-literal">false</span>
7 - <span class="hljs-literal">false</span>
8 - <span class="hljs-literal">false</span>
9 - <span class="hljs-literal">false</span>
[{<span class="hljs-string">"id"</span>:1,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:2,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:3,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:4,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:5,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:6,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:7,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:8,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:9,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>}]</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens. </font><font style="vertical-align: inherit;">Durch Überschreiben der Methoden MarshalJSON und UnmarshalJSON für beliebige Datentypen können Sie die Serialisierung und Deserialisierung eines bestimmten JSON-Codefelds anpassen. </font><font style="vertical-align: inherit;">Zusätzlich zu den angegebenen Anwendungsfällen werden diese Funktionen verwendet, um mit nullbaren Feldern zu arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens. </font><font style="vertical-align: inherit;">Das json-Textcodierungsformat ist ein weit verbreitetes Werkzeug für den Informationsaustausch. Einer seiner Vorteile gegenüber anderen Formaten ist die Verfügbarkeit von Datentypen. </font><font style="vertical-align: inherit;">Die Einhaltung dieser Typen muss streng überwacht werden.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502154/index.html">Effektiv Autotests schreiben - Subkutane Tests</a></li>
<li><a href="../de502156/index.html">Rambler gegen NGINX Fall: Kriminelle Risiken der Digitalisierung Roundtable 16. Mai</a></li>
<li><a href="../de502158/index.html">So organisieren Sie Tests, um Produktfreigaben zu beschleunigen und zu stabilisieren. Teil 2</a></li>
<li><a href="../de502160/index.html">Die Entwicklung von benutzerdefinierten mobilen Apps ist kostengünstig: Realität oder Illusion</a></li>
<li><a href="../de502166/index.html">Ghosts Windows 3.1</a></li>
<li><a href="../de502178/index.html">OVirt in 2 Stunden. Teil 3. Erweiterte Einstellungen</a></li>
<li><a href="../de502180/index.html">Der Tag, an dem der Umfang verschwand. Sicherheitslösungen von Microsoft und Partnern</a></li>
<li><a href="../de502182/index.html">Nochmals zu MikroTik oder dem lang erwarteten SOCKS5</a></li>
<li><a href="../de502186/index.html">Webinar. Informationssicherheit: SOC in Quarantäne</a></li>
<li><a href="../de502200/index.html">Entropie: Wie Entscheidungsbäume Entscheidungen treffen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>