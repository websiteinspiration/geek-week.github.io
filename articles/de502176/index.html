<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë©üèæ üóìÔ∏è ü§¥üèº Los: JSON-Deserialisierung mit falscher Eingabe oder Umgehen von API-Entwicklerfehlern üë®üèº‚Äçüîß üßùüèΩ üçß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="K√ºrzlich habe ich auf Go einen http-Client f√ºr einen Dienst entwickelt, der eine REST-API mit json als Codierungsformat bereitstellt. Eine Standardauf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Los: JSON-Deserialisierung mit falscher Eingabe oder Umgehen von API-Entwicklerfehlern</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502176/"><img src="https://habrastorage.org/webt/pf/hz/xm/pfhzxmp9antvvecnexqujg6pkzk.jpeg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
K√ºrzlich habe ich auf Go einen http-Client f√ºr einen Dienst entwickelt, der eine REST-API mit json als Codierungsformat bereitstellt. </font><font style="vertical-align: inherit;">Eine Standardaufgabe, aber im Laufe der Arbeit musste ich mich einem nicht standardm√§√üigen Problem stellen. </font><font style="vertical-align: inherit;">Ich sage dir, worum es geht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie wissen, hat das JSON-Format Datentypen. </font><font style="vertical-align: inherit;">Vier Grundelemente: Zeichenfolge, Zahl, Boolescher Wert, Null; </font><font style="vertical-align: inherit;">und zwei Strukturtypen: ein Objekt und ein Array. </font><font style="vertical-align: inherit;">In diesem Fall interessieren uns primitive Typen. </font><font style="vertical-align: inherit;">Hier ist ein Beispiel f√ºr einen JSON-Code mit vier Feldern unterschiedlichen Typs:</font></font><br>
<br>
<pre><code class="json hljs">{
	<span class="hljs-attr">"name"</span>:<span class="hljs-string">"qwerty"</span>,
	<span class="hljs-attr">"price"</span>:<span class="hljs-number">258.25</span>,
	<span class="hljs-attr">"active"</span>:<span class="hljs-literal">true</span>,
	<span class="hljs-attr">"description"</span>:<span class="hljs-literal">null</span>,<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie das Beispiel zeigt, wird der Zeichenfolgenwert in Anf√ºhrungszeichen gesetzt. Numerisch - hat keine Anf√ºhrungszeichen. Ein boolescher Typ kann nur einen von zwei Werten haben: true oder false (ohne Anf√ºhrungszeichen). Und der Null-Typ ist dementsprechend null (auch ohne Anf√ºhrungszeichen).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt das Problem selbst. Irgendwann stellte ich bei einer detaillierten Untersuchung des von einem Drittanbieter-Service erhaltenen JSON-Codes fest, dass eines der Felder (nennen wir es Preis) regelm√§√üig einen Zeichenfolgenwert (die Zahl in Anf√ºhrungszeichen) zus√§tzlich zum numerischen Wert enth√§lt. Das hei√üt, dieselbe Abfrage mit unterschiedlichen Parametern kann eine Zahl als Zahl oder dieselbe Zahl als Zeichenfolge zur√ºckgeben. Ich kann mir nicht vorstellen, wie der Code, der solche Ergebnisse zur√ºckgibt, am anderen Ende organisiert ist, aber anscheinend liegt dies daran, dass der Dienst selbst ein Aggregator ist und Daten aus verschiedenen Quellen abruft und die Entwickler die Serverantwort json nicht auf ein einziges Format gebracht haben. Trotzdem ist es notwendig, mit dem zu arbeiten, was ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber dann war ich noch mehr √ºberrascht. </font><font style="vertical-align: inherit;">Das logische Feld (nennen wir es aktiv) gab zus√§tzlich zu true und false die Zeichenfolgenwerte "true", "false" und sogar die numerischen Werte 1 und 0 (true bzw. false) zur√ºck.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All diese Verwirrung √ºber Datentypen w√§re nicht kritisch, wenn ich json say in schwach typisiertem PHP verarbeiten w√ºrde, aber Go hat eine starke Typisierung und erfordert eine klare Angabe des Typs des desialisierten Feldes. </font><font style="vertical-align: inherit;">Infolgedessen musste ein Mechanismus implementiert werden, mit dem alle Werte des aktiven Felds w√§hrend des Deserialisierungsprozesses in einen logischen Typ und jeder Wert des Preisfelds in einen numerischen konvertiert werden k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit dem Preisfeld. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben folgenden JSON-Code:</font></font><br>
<br>
<pre><code class="json hljs">[<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">2.58</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">7.15</span>}<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt, json enth√§lt ein Array von Objekten mit zwei Feldern eines numerischen Typs. </font><font style="vertical-align: inherit;">Der Standard-Deserialisierungscode f√ºr diesen json on Go sieht folgenderma√üen aus:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id    <span class="hljs-keyword">int</span>     <span class="hljs-string">`json:"id"`</span>
	Price <span class="hljs-keyword">float64</span> <span class="hljs-string">`json:"price"`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	jsonString := <span class="hljs-string">`[{"id":1,"price":2.58},
					{"id":4,"price":7.15}]`</span><font></font>
<font></font>
	targets := []Target{}<font></font>
<font></font>
	err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(jsonString), &amp;targets)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
		fmt.Println(err)<font></font>
		<span class="hljs-keyword">return</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> targets {<font></font>
		fmt.Println(t.Id, <span class="hljs-string">"-"</span>, t.Price)<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Code deserialisieren wir das ID-Feld in int und das Preisfeld in float64. </font><font style="vertical-align: inherit;">Nehmen wir nun an, unser JSON-Code sieht folgenderma√üen aus:</font></font><br>
<br>
<pre><code class="json hljs">[<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">2.58</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-string">"2.58"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">7.15</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">4</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-string">"7.15"</span>}<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt, das Preisfeld enth√§lt Werte sowohl eines numerischen Typs als auch einer Zeichenfolge. </font><font style="vertical-align: inherit;">In diesem Fall k√∂nnen nur die numerischen Werte des Preisfelds in den Typ float64 dekodiert werden, w√§hrend Zeichenfolgenwerte einen Fehler bez√ºglich der Inkompatibilit√§t von Typen verursachen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass weder float64 noch ein anderer primitiver Typ zum Deserialisieren dieses Felds geeignet ist, und wir ben√∂tigen unseren eigenen benutzerdefinierten Typ mit eigener Deserialisierungslogik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deklarieren Sie als solchen Typ eine CustomFloat64-Struktur mit einem einzelnen Float64-Feld vom Typ float64.</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> CustomFloat64 <span class="hljs-keyword">struct</span>{<font></font>
	Float64 <span class="hljs-keyword">float64</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Geben Sie diesen Typ sofort f√ºr das Feld Preis in der Zielstruktur an:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id    <span class="hljs-keyword">int</span>           <span class="hljs-string">`json:"id"`</span>
	Price CustomFloat64 <span class="hljs-string">`json:"price"`</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt m√ºssen Sie Ihre eigene Logik zum Dekodieren eines Felds vom Typ CustomFloat64 beschreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Paket "encoding / json" verf√ºgt √ºber zwei spezielle Methoden: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MarshalJSON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnmarshalJSON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mit denen die Codierungs- und Decodierungslogik eines bestimmten Benutzerdatentyps angepasst werden kann. Es reicht aus, diese Methoden zu √ºberschreiben und Ihre eigene Implementierung zu beschreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úberschreiben Sie die UnmarshalJSON-Methode f√ºr einen beliebigen Typ CustomFloat64. In diesem Fall muss die Signatur der Methode genau befolgt werden, da sie sonst einfach nicht funktioniert und vor allem keinen Fehler verursacht.</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf *CustomFloat64)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Eingabe nimmt diese Methode eine Schicht von Bytes (Daten), die den Wert eines bestimmten Feldes des decodierten JSON enth√§lt. Wenn wir diese Folge von Bytes in eine Zeichenfolge konvertieren, sehen wir den Wert des Feldes genau in der Form, in der es in json geschrieben ist. Das hei√üt, wenn es sich um einen Zeichenfolgentyp handelt, wird genau eine Zeichenfolge mit doppelten Anf√ºhrungszeichen (‚Äû258‚Äú) angezeigt. Wenn es sich um einen numerischen Typ handelt, wird eine Zeichenfolge ohne Anf√ºhrungszeichen (258) angezeigt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um einen numerischen Wert von einem Zeichenfolgenwert zu unterscheiden, m√ºssen Sie pr√ºfen, ob das erste Zeichen ein Anf√ºhrungszeichen ist. Da das doppelte Anf√ºhrungszeichen in der UNICODE-Tabelle ein Byte belegt, m√ºssen wir nur das erste Byte des Daten-Slice √ºberpr√ºfen, indem wir es mit der Zeichennummer in UNICODE vergleichen. Dies ist Nummer 34. Beachten Sie, dass ein Zeichen im Allgemeinen nicht einem Byte entspricht, da es mehr als ein Byte ben√∂tigen kann. Ein Charakter in Go entspricht Rune (Rune). In unserem Fall ist diese Bedingung ausreichend:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == <span class="hljs-number">34</span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Bedingung erf√ºllt ist, hat der Wert einen Zeichenfolgentyp, und wir m√ºssen die Zeichenfolge zwischen den Anf√ºhrungszeichen abrufen, dh das Slice-Byte zwischen dem ersten und dem letzten Byte. </font><font style="vertical-align: inherit;">Dieses Slice enth√§lt einen numerischen Wert, der in den primitiven Typ float64 dekodiert werden kann. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir die Methode json.Unmarshal darauf anwenden k√∂nnen, w√§hrend das Ergebnis in der CustomFloat64-Struktur im Feld Float64 gespeichert wird.</font></font><br>
<br>
<pre><code class="go hljs">err := json.Unmarshal(data[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(data)<span class="hljs-number">-1</span>], &amp;cf.Float64)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Daten-Slice nicht mit einem Anf√ºhrungszeichen beginnt, enth√§lt es bereits einen numerischen Datentyp, und wir k√∂nnen die Methode json.Unmarshal direkt auf das gesamte Daten-Slice anwenden.</font></font><br>
<br>
<pre><code class="go hljs">err := json.Unmarshal(data, &amp;cf.Float64)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der vollst√§ndige Code f√ºr die UnmarshalJSON-Methode:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf *CustomFloat64)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == <span class="hljs-number">34</span> {<font></font>
		err := json.Unmarshal(data[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(data)<span class="hljs-number">-1</span>], &amp;cf.Float64)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		err := json.Unmarshal(data, &amp;cf.Float64)<font></font>
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen werden unter Verwendung der json.Unmarshal-Methode f√ºr unseren json-Code alle Werte des Preisfelds f√ºr uns transparent in einen primitiven Typ float64 konvertiert und das Ergebnis in das Float64-Feld der CustomFloat64-Struktur geschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt m√ºssen wir m√∂glicherweise die Zielstruktur wieder in json konvertieren. Wenn wir jedoch die json.Marshal-Methode direkt auf den CustomFloat64-Typ anwenden, serialisieren wir diese Struktur als Objekt. Wir m√ºssen das Preisfeld in einen numerischen Wert kodieren. Um die Codierungslogik des benutzerdefinierten Typs CustomFloat64 anzupassen, implementieren wir die MarshalJSON-Methode daf√ºr, wobei wir die Signatur der Methode genau beachten:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf CustomFloat64)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cf.Float64)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei dieser Methode m√ºssen Sie lediglich die json.Marshal-Methode erneut verwenden, sie jedoch bereits nicht auf die CustomFloat64-Struktur, sondern auf das Float64-Feld anwenden. </font><font style="vertical-align: inherit;">Von der Methode geben wir das empfangene Byte Slice und den Fehler zur√ºck. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der vollst√§ndige Code, der die Ergebnisse der Serialisierung und Deserialisierung anzeigt (die Fehlerpr√ºfung wird der K√ºrze halber weggelassen, die Nummer des Bytes mit dem doppelten Anf√ºhrungszeichen ist konstant):</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"encoding/json"</span>
	<span class="hljs-string">"errors"</span>
	<span class="hljs-string">"fmt"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">type</span> CustomFloat64 <span class="hljs-keyword">struct</span> {<font></font>
	Float64 <span class="hljs-keyword">float64</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> QUOTES_BYTE = <span class="hljs-number">34</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf *CustomFloat64)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == QUOTES_BYTE {<font></font>
		err := json.Unmarshal(data[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(data)<span class="hljs-number">-1</span>], &amp;cf.Float64)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		err := json.Unmarshal(data, &amp;cf.Float64)<font></font>
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf CustomFloat64)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cf.Float64)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id    <span class="hljs-keyword">int</span>           <span class="hljs-string">`json:"id"`</span>
	Price CustomFloat64 <span class="hljs-string">`json:"price"`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	jsonString := <span class="hljs-string">`[{"id":1,"price":2.58},
					{"id":2,"price":"2.58"},
					{"id":3,"price":7.15},
					{"id":4,"price":"7.15"}]`</span><font></font>
<font></font>
	targets := []Target{}<font></font>
<font></font>
	_ := json.Unmarshal([]<span class="hljs-keyword">byte</span>(jsonString), &amp;targets)<font></font>
<font></font>
	<span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> targets {<font></font>
		fmt.Println(t.Id, <span class="hljs-string">"-"</span>, t.Price.Float64)<font></font>
	}<font></font>
<font></font>
	jsonStringNew, _ := json.Marshal(targets)<font></font>
	fmt.Println(<span class="hljs-keyword">string</span>(jsonStringNew))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ergebnis der Codeausf√ºhrung:</font></font><br>
<br>
<pre><code class="bash hljs">1 - 2.58<font></font>
2 - 2.58<font></font>
3 - 7.15<font></font>
4 - 7.15<font></font>
[{<span class="hljs-string">"id"</span>:1,<span class="hljs-string">"price"</span>:2.58},{<span class="hljs-string">"id"</span>:2,<span class="hljs-string">"price"</span>:2.58},{<span class="hljs-string">"id"</span>:3,<span class="hljs-string">"price"</span>:7.15},{<span class="hljs-string">"id"</span>:4,<span class="hljs-string">"price"</span>:7.15}]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fahren wir mit dem zweiten Teil fort und implementieren denselben Code f√ºr die JSON-Deserialisierung mit inkonsistenten Werten des logischen Felds. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben folgenden JSON-Code:</font></font><br>
<br>
<pre><code class="json hljs">[<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-literal">true</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"true"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"1"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">4</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-number">1</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">5</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-literal">false</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">6</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"false"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">7</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"0"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">8</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-number">0</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">9</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">""</span>}<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall impliziert das aktive Feld einen logischen Typ und das Vorhandensein von nur einem von zwei Werten: wahr und falsch. </font><font style="vertical-align: inherit;">Nicht-boolesche Werte m√ºssen w√§hrend der Deserialisierung in boolesche Werte konvertiert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im aktuellen Beispiel geben wir die folgenden √úbereinstimmungen zu. </font><font style="vertical-align: inherit;">Wahre Werte entsprechen: wahr (logisch), wahr (Zeichenfolge), 1 (Zeichenfolge), 1 (numerisch). </font><font style="vertical-align: inherit;">Der falsche Wert entspricht: false (logisch), false (Zeichenfolge), 0 (Zeichenfolge), 0 (numerisch), "" (leere Zeichenfolge). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst deklarieren wir die Zielstruktur f√ºr die Deserialisierung. </font><font style="vertical-align: inherit;">Als Typ des Felds Aktiv geben wir sofort den benutzerdefinierten Typ CustomBool an:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id     <span class="hljs-keyword">int</span>        <span class="hljs-string">`json:"id"`</span>
	Active CustomBool <span class="hljs-string">`json:"active"`</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CustomBool ist eine Struktur mit einem einzelnen Bool-Feld vom Typ Bool:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> CustomBool <span class="hljs-keyword">struct</span> {<font></font>
	Bool <span class="hljs-keyword">bool</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir implementieren die UnmarshalJSON-Methode f√ºr diese Struktur. </font><font style="vertical-align: inherit;">Ich gebe Ihnen sofort den Code:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CustomBool)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">switch</span> <span class="hljs-keyword">string</span>(data) {
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"true"`</span>, <span class="hljs-string">`true`</span>, <span class="hljs-string">`"1"`</span>, <span class="hljs-string">`1`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">true</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"false"`</span>, <span class="hljs-string">`false`</span>, <span class="hljs-string">`"0"`</span>, <span class="hljs-string">`0`</span>, <span class="hljs-string">`""`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">false</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomBool: parsing \""</span> + <span class="hljs-keyword">string</span>(data) + <span class="hljs-string">"\": unknown value"</span>)<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da das aktive Feld in unserem Fall eine begrenzte Anzahl von Werten hat, k√∂nnen wir das switch-case-Konstrukt verwenden, um zu entscheiden, wie der Wert des Bool-Felds der CustomBool-Struktur sein soll. Zur √úberpr√ºfung ben√∂tigen Sie nur zwei Fallbl√∂cke. Im ersten Block √ºberpr√ºfen wir den Wert auf true, im zweiten auf false.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie m√∂gliche Werte schreiben, sollten Sie auf die Rolle des Kieses achten (dies ist ein solches Anf√ºhrungszeichen auf dem Schl√ºssel mit dem Buchstaben E im englischen Layout). Mit diesem Zeichen k√∂nnen Sie doppelte Anf√ºhrungszeichen in einer Zeichenfolge umgehen. Aus Gr√ºnden der √úbersichtlichkeit habe ich die Werte mit Anf√ºhrungszeichen und ohne Anf√ºhrungszeichen mit diesem Symbol versehen. Somit entspricht "false" der Zeichenfolge false (ohne Anf√ºhrungszeichen, geben Sie bool in json ein), und "false" entspricht der Zeichenfolge "false" (mit Anf√ºhrungszeichen, geben Sie string in json ein). Das Gleiche gilt f√ºr die Werte "1" und "1". Die erste ist die Zahl 1 (in json ohne Anf√ºhrungszeichen geschrieben), die zweite ist die Zeichenfolge "1" (in json mit Anf√ºhrungszeichen). Dieser Eintrag `` "` ist eine leere Zeichenfolge, d. H. Im JSON-Format sieht er folgenderma√üen aus: "". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der entsprechende Wert (true oder false) wird direkt in das Bool-Feld der CustomBool-Struktur geschrieben:</font></font><br>
<br>
<pre><code class="go hljs">cb.Bool = <span class="hljs-literal">true</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Standardblock geben wir einen Fehler zur√ºck, der besagt, dass das Feld einen unbekannten Wert hat:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomBool: parsing \""</span> + <span class="hljs-keyword">string</span>(data) + <span class="hljs-string">"\": unknown value"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt k√∂nnen wir die json.Unmarshal-Methode auf unseren json-Code anwenden, und die Werte des aktiven Felds werden in einen primitiven Bool-Typ konvertiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir implementieren die MarshalJSON-Methode f√ºr die CustomBool-Struktur:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb CustomBool)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cb.Bool)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier gibt es nichts Neues. </font><font style="vertical-align: inherit;">Die Methode serialisiert das Bool-Feld der CustomBool-Struktur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der vollst√§ndige Code, der die Ergebnisse der Serialisierung und Deserialisierung anzeigt (Fehlerpr√ºfung der K√ºrze halber weggelassen):</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"encoding/json"</span>
	<span class="hljs-string">"errors"</span>
	<span class="hljs-string">"fmt"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">type</span> CustomBool <span class="hljs-keyword">struct</span> {<font></font>
	Bool <span class="hljs-keyword">bool</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CustomBool)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">switch</span> <span class="hljs-keyword">string</span>(data) {
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"true"`</span>, <span class="hljs-string">`true`</span>, <span class="hljs-string">`"1"`</span>, <span class="hljs-string">`1`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">true</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"false"`</span>, <span class="hljs-string">`false`</span>, <span class="hljs-string">`"0"`</span>, <span class="hljs-string">`0`</span>, <span class="hljs-string">`""`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">false</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomBool: parsing \""</span> + <span class="hljs-keyword">string</span>(data) + <span class="hljs-string">"\": unknown value"</span>)<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb CustomBool)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cb.Bool)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id     <span class="hljs-keyword">int</span>        <span class="hljs-string">`json:"id"`</span>
	Active CustomBool <span class="hljs-string">`json:"active"`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	jsonString := <span class="hljs-string">`[{"id":1,"active":true},
					{"id":2,"active":"true"},
					{"id":3,"active":"1"},
					{"id":4,"active":1},
					{"id":5,"active":false},
					{"id":6,"active":"false"},
					{"id":7,"active":"0"},
					{"id":8,"active":0},
					{"id":9,"active":""}]`</span><font></font>
<font></font>
	targets := []Target{}<font></font>
<font></font>
	_ = json.Unmarshal([]<span class="hljs-keyword">byte</span>(jsonString), &amp;targets)<font></font>
<font></font>
	<span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> targets {<font></font>
		fmt.Println(t.Id, <span class="hljs-string">"-"</span>, t.Active.Bool)<font></font>
	}<font></font>
<font></font>
	jsonStringNew, _ := json.Marshal(targets)<font></font>
	fmt.Println(<span class="hljs-keyword">string</span>(jsonStringNew))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ergebnis der Codeausf√ºhrung:</font></font><br>
<br>
<pre><code class="bash hljs">1 - <span class="hljs-literal">true</span>
2 - <span class="hljs-literal">true</span>
3 - <span class="hljs-literal">true</span>
4 - <span class="hljs-literal">true</span>
5 - <span class="hljs-literal">false</span>
6 - <span class="hljs-literal">false</span>
7 - <span class="hljs-literal">false</span>
8 - <span class="hljs-literal">false</span>
9 - <span class="hljs-literal">false</span>
[{<span class="hljs-string">"id"</span>:1,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:2,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:3,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:4,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:5,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:6,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:7,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:8,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:9,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>}]</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens. </font><font style="vertical-align: inherit;">Durch √úberschreiben der Methoden MarshalJSON und UnmarshalJSON f√ºr beliebige Datentypen k√∂nnen Sie die Serialisierung und Deserialisierung eines bestimmten JSON-Codefelds anpassen. </font><font style="vertical-align: inherit;">Zus√§tzlich zu den angegebenen Anwendungsf√§llen werden diese Funktionen verwendet, um mit nullbaren Feldern zu arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens. </font><font style="vertical-align: inherit;">Das json-Textcodierungsformat ist ein weit verbreitetes Werkzeug f√ºr den Informationsaustausch. Einer seiner Vorteile gegen√ºber anderen Formaten ist die Verf√ºgbarkeit von Datentypen. </font><font style="vertical-align: inherit;">Die Einhaltung dieser Typen muss streng √ºberwacht werden.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502154/index.html">Effektiv Autotests schreiben - Subkutane Tests</a></li>
<li><a href="../de502156/index.html">Rambler gegen NGINX Fall: Kriminelle Risiken der Digitalisierung Roundtable 16. Mai</a></li>
<li><a href="../de502158/index.html">So organisieren Sie Tests, um Produktfreigaben zu beschleunigen und zu stabilisieren. Teil 2</a></li>
<li><a href="../de502160/index.html">Die Entwicklung von benutzerdefinierten mobilen Apps ist kosteng√ºnstig: Realit√§t oder Illusion</a></li>
<li><a href="../de502166/index.html">Ghosts Windows 3.1</a></li>
<li><a href="../de502178/index.html">OVirt in 2 Stunden. Teil 3. Erweiterte Einstellungen</a></li>
<li><a href="../de502180/index.html">Der Tag, an dem der Umfang verschwand. Sicherheitsl√∂sungen von Microsoft und Partnern</a></li>
<li><a href="../de502182/index.html">Nochmals zu MikroTik oder dem lang erwarteten SOCKS5</a></li>
<li><a href="../de502186/index.html">Webinar. Informationssicherheit: SOC in Quarant√§ne</a></li>
<li><a href="../de502200/index.html">Entropie: Wie Entscheidungsb√§ume Entscheidungen treffen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>