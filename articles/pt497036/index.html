<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😅 🖕🏻 🤦🏼 Quando parar o processo de reconhecimento de sequência de vídeo? 🕞 👊🏼 🤘🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Habr! Hoje, gostaríamos de falar sobre um problema muito interessante com o qual estamos lidando desde o início de nossa pesquisa sobre reconhecime...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Quando parar o processo de reconhecimento de sequência de vídeo?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/smartengines/blog/497036/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oi Habr! </font><font style="vertical-align: inherit;">Hoje, gostaríamos de falar sobre um problema muito interessante com o qual estamos lidando desde o início de nossa pesquisa sobre reconhecimento de documentos no fluxo de vídeo - o problema de encontrar o tempo de parada ideal.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ce/ya/vj/ceyavj_vrjjv1n9uolpknwvrvqa.png" width="75%"></div><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FIG. 1. Imagens de campos de texto de documentos de identificação em quadros de uma sequência de vídeo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como muitas pessoas sabem, o principal produto dos Smart Engines é um sistema de reconhecimento de documentos de identidade, o Smart IDReader, aplicável em servidores e desktops, e em dispositivos móveis. Em um grande número de casos, o reconhecimento de documentos em um telefone celular deve ocorrer offline, geralmente não podemos controlar as condições e a qualidade da filmagem, e o custo de erros de reconhecimento, especialmente no reconhecimento de documentos de identificação, é muito alto. Ao mesmo tempo, temos uma vantagem importante - podemos usar não uma imagem, mas uma sequência de quadros capturados (veja a Fig. 1), para aumentar a precisão do reconhecimento.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao usar várias imagens de campos de texto, duas questões importantes surgem. A primeira pergunta é como combinar observações? Vale a pena combinar os quadros de origem para obter uma imagem, uma "qualidade" mais alta ou escolher um quadro melhor (então onde está a garantia de que haverá um quadro no qual tudo esteja bem)? Ou, talvez, primeiro reconheça o campo em cada quadro e, em seguida, selecione o resultado mais "confiante" (por quais critérios?) Ou combine resultados de reconhecimento quadro a quadro, etc. Aderimos à última abordagem (reconhecimento quadro a quadro com combinação de resultados entre quadros), mas a abordagem ideal pode diferir, dependendo do mecanismo de reconhecimento usado e de outros parâmetros da tarefa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A segunda questão que surge independentemente da primeira é quando parar o processo de observação? </font><font style="vertical-align: inherit;">Em outras palavras, por qual critério você decide que o processo de captura pode ser interrompido e o resultado acumulado no momento atual é reconhecido como final? </font><font style="vertical-align: inherit;">Como comparar esses critérios entre si e existe um ótimo? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trata-se do problema de encontrar o momento de interromper o processo de observação que será discutido neste artigo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que queremos alcançar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O reconhecimento de uma sequência de texto em uma sequência de vídeo, na qual após a captura de outra observação, o resultado melhora de uma maneira ou de outra, pode ser considerado como um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo a qualquer momento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - um algoritmo com um resultado que melhora sequencialmente, cujo cálculo pode ser interrompido a qualquer momento. Uma ferramenta conveniente para visualizar a qualidade de tais algoritmos é o “ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perfil de desempenho esperado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” - gráficos da dependência da qualidade do resultado, medido de uma forma ou de outra, no tempo de cálculo.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8f/l6/5e/8fl65ee0_n1sexz30sa9ez1hqwi.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FIG. 2. Perfis de eficiência de reconhecimento de linha de texto em uma sequência de vídeo (quanto menor, melhor). A linha pontilhada preta é de qualidade quadro a quadro, a linha sólida preta é o resultado da combinação entre quadros. A linha laranja é o que queremos da regra de parada “boa”. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na Fig. A Figura 2 mostra os perfis de eficiência para o reconhecimento de uma sequência de texto - a dependência do erro médio (em termos da distância de Levenshtein à resposta correta) no número de quadros processados. Gráficos em preto foram obtidos usando o Tesseract v4.0.0 nos campos de texto do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conjunto de dados MIDV-500</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pode-se observar que o uso da combinação entre quadros de resultados de reconhecimento permite obter um valor de erro muito menor (o que, em geral, não é surpreendente).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que queremos de uma regra de parada "boa"? Como esperamos, razoavelmente, que quanto mais continuarmos o processo, melhor será o resultado médio, seria ótimo se a regra para parar em algumas sequências de vídeo consideradas "mais longas", se houvesse uma chance de minimizar o erro e, em algumas, ele parasse seria mais cedo se o resultado já estiver bom ou se não houver chance de melhorá-lo. Devido a isso, com a mesma qualidade média do resultado combinado, em média, menos quadros processados ​​podem ser alcançados e vice-versa, com o mesmo número médio de quadros, o resultado médio é melhor. Em outras palavras, é importante entender que a regra de parada não é apenas minimizar o tempo, mas também maximizar a qualidade, pelo mesmo tempo (médio).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos procurar a regra de parada da seguinte forma: depois de processar o próximo quadro e receber o resultado do reconhecimento combinado, consideramos alguma característica e cortamos seu limite - se, digamos, estiver abaixo do limite, paramos, caso contrário continuamos. Então, com uma regra de parada fixa, mas variando o limite, também obteremos um perfil de eficiência, com a exceção de que o eixo horizontal não conterá o número exato de quadros processados, mas a média (veja o gráfico laranja na Fig. 2). Quanto menor esse gráfico, mais eficaz podemos considerar a regra de parada. Podemos considerar o perfil inicial do “resultado combinado” como o perfil da efetividade da regra trivial de parada - na qual simplesmente cortamos o número de quadros processados ​​pelo limite.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que a teoria diz</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nas estatísticas matemáticas, os problemas de encontrar o tempo ideal de parada são bem conhecidos e há muito tempo são investigados. </font><font style="vertical-align: inherit;">Talvez as tarefas mais famosas desta classe sejam as </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de uma noiva exigente</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ela estava muito envolvida, por exemplo, Boris Abramovich Berezovsky), a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tarefa de vender uma casa</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e outras. </font><font style="vertical-align: inherit;">Sem aprofundar a teoria, vamos colocar brevemente o problema de reconhecimento nas sequências de vídeo como o problema ideal de parada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denotamos o erro do resultado combinado na </font></font><img src="https://habrastorage.org/getpro/habr/post_images/fd6/0b2/b5b/fd60b2b5be4b7e93a0d905dd970c314f.svg" alt="n"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">ésima etapa do processo como </font></font><img src="https://habrastorage.org/getpro/habr/post_images/a9c/6b0/871/a9c6b0871448de920874afcfd86bd19b.svg" alt="\ epsilon (R_n)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Assumimos que, se pararmos na </font></font><img src="https://habrastorage.org/getpro/habr/post_images/fd6/0b2/b5b/fd60b2b5be4b7e93a0d905dd970c314f.svg" alt="n"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">ésima etapa, sofreremos uma perda da seguinte forma :, </font></font><img src="https://habrastorage.org/getpro/habr/post_images/755/fbc/32f/755fbc32f1fbc9374f93a6e4eafe240f.svg" alt="L_n = \ epsilon (R_n) + c \ cdot n"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em que</font></font><img src="https://habrastorage.org/getpro/habr/post_images/226/161/418/226161418d10186d2b8602d4aa8b6c20.svg" alt="c"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- algum custo relativo predeterminado de cada observação. </font><font style="vertical-align: inherit;">A tarefa de encontrar o tempo de parada ideal pode ser formulada como uma busca por uma variável aleatória </font></font><img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- o tempo de parada, cuja distribuição depende das observações de entrada (em alguma literatura, o valor </font></font><img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é chamado de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">momento de Markov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) e em que a perda esperada é minimizada </font></font><img src="https://habrastorage.org/getpro/habr/post_images/711/2cc/2ac/7112cc2ac05a63cdb6ef47612d68661b.svg" alt="\ mathrm {E} (L_N)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problemas monótonos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sob certas condições, nesses problemas, a regra de parada ideal pode ser expressa explicitamente. Um exemplo é o chamado problema monótono. O critério para a monotonicidade do problema é o seguinte: se em alguma etapa a </font></font><img src="https://habrastorage.org/getpro/habr/post_images/fd6/0b2/b5b/fd60b2b5be4b7e93a0d905dd970c314f.svg" alt="n"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perda </font></font><img src="https://habrastorage.org/getpro/habr/post_images/ed9/92f/1d6/ed992f1d6f84c21bbc0f2e028c797dc2.svg" alt="L_n"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não exceder a perda esperada na próxima etapa, isso será realizado em todas as etapas subsequentes. Em outras palavras, pelo que aconteceu, o evento </font></font><img src="https://habrastorage.org/getpro/habr/post_images/2d1/042/ace/2d1042aceeb07d176e3f331765a17d2e.svg" alt="L_n \ le \ mathrm {E} (L_ {n + 1} | \ text {received} ~ n ~ \ text {frames})"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segue que o evento acontecerá </font></font><img src="https://habrastorage.org/getpro/habr/post_images/d4a/008/ca7/d4a008ca75d0cfacb4787e8f17b57917.svg" alt="L_ {n + 1} \ le \ mathrm {E} (L_ {n + 2} | \ text {received} ~ n + 1 ~ \ text {frames})"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para problemas monótonos, a chamada regra de parada míope é ideal: pare na primeira etapa em que a condição for atendida </font></font><img src="https://habrastorage.org/getpro/habr/post_images/2d1/042/ace/2d1042aceeb07d176e3f331765a17d2e.svg" alt="L_n \ le \ mathrm {E} (L_ {n + 1} | \ text {received} ~ n ~ \ text {frames})"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que nossa tarefa seja monótona. Depois de escrever a regra míope em termos de nossa função, </font></font><img src="https://habrastorage.org/getpro/habr/post_images/ed9/92f/1d6/ed992f1d6f84c21bbc0f2e028c797dc2.svg" alt="L_n"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">concluímos que precisamos parar quando a seguinte condição for atendida:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ec/b68/ef1/2ecb68ef1cb3a6a19003160c24abc32f.svg" alt="\ epsilon (R_n) - \ mathrm {E} (\ epsilon (R_ {n + 1}) | \ text {received} ~ n ~ \ text {frames}) \ le c."></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É claro que isso é ótimo, mas para implementar essa regra, precisamos avaliar em tempo de execução não apenas a “correção” do resultado atual, mas também a correção esperada do próximo, o que não é tão simples (sem mencionar o que exigimos imperiosamente da tarefa monotonia). </font><font style="vertical-align: inherit;">De alguma forma, podemos aplicar essa regra sem avaliar diretamente a “correção” do resultado? ... Você pode tentar avaliar o lado esquerdo da desigualdade de cima para baixo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a regra míope pode ser usada?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos supor que uma função </font></font><img src="https://habrastorage.org/getpro/habr/post_images/a9c/6b0/871/a9c6b0871448de920874afcfd86bd19b.svg" alt="\ epsilon (R_n)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seja a distância </font></font><img src="https://habrastorage.org/getpro/habr/post_images/2cb/58f/b16/2cb58fb16fe9ba5419dfbe05ea5c8f57.svg" alt="\ rho (R_n, R ^ *)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do resultado do reconhecimento combinado </font></font><img src="https://habrastorage.org/getpro/habr/post_images/d3e/d44/0c3/d3ed440c397aa0bef8702405bd68d9f8.svg" alt="R_n"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">até a "resposta correta" </font></font><img src="https://habrastorage.org/getpro/habr/post_images/03f/123/c0a/03f123c0a2a3f7711cda2fdfad4b7a98.svg" alt="R ^ *"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, como qualquer distância que se respeite, a desigualdade do triângulo se mantém. A distância de Levenshtein mencionada acima satisfaz a desigualdade do triângulo, bem como uma função simples na forma de “certo / errado” (se assumirmos que </font></font><img src="https://habrastorage.org/getpro/habr/post_images/2cb/58f/b16/2cb58fb16fe9ba5419dfbe05ea5c8f57.svg" alt="\ rho (R_n, R ^ *)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para a resposta correta é zero e para a resposta errada é constante). De acordo com a desigualdade do triângulo, o lado esquerdo do nosso critério de parada não excede </font></font><img src="https://habrastorage.org/getpro/habr/post_images/bb2/7fc/4e5/bb27fc4e52d0d0d373690a096a1bfc55.svg" alt="\ mathrm {E} (\ rho (R_n, R_ {n + 1}) | \ text {received} ~ n ~ \ text {frames})"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- a distância esperada do resultado combinado atual para o próximo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Também vamos exigir do nosso algoritmo que combine resultados de reconhecimento entre quadros, para que, em média, a distância entre resultados combinados adjacentes não aumente ao longo do tempo (ou seja, consideraremos a sequência de resultados combinados como um processo "convergente", embora não necessariamente para a resposta correta). Então, se a distância esperada do resultado atual para o próximo for menor que o limite c, duas coisas serão feitas ao mesmo tempo. Em primeiro lugar, o critério de parada míope é cumprido (já que sua parte esquerda é delimitada acima por essa mesma distância). E, em segundo lugar, a tarefa se torna monótona: na próxima etapa, a distância esperada para a próxima resposta não aumentará, o que significa que continuará sendo menor que o limite c, e o critério míope será preenchido novamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso significa que, se esperamos que as distâncias entre os resultados combinados adjacentes não aumentem, em média, precisamos parar pelo limite de limiar da distância esperada do resultado atual para o próximo, aproximando-se assim da regra ideal. Você precisa entender que essa regra não é mais ideal (já que a regra ideal "real" pode parar mais cedo), mas pelo menos não vamos parar antes do necessário.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem várias maneiras de avaliar a distância esperada do resultado combinado atual para o próximo. Por exemplo, se a distância de Levenshtein for usada como métrica sobre os resultados, mesmo a distância entre os dois últimos resultados do layout será uma boa aproximação. Outra abordagem possível é simular uma possível observação seguinte (por exemplo, com base nas já obtidas), realizar combinações "inativas" e calcular a distância média às previsões obtidas. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pk/ky/t7/pkkyt7kde0i-ia7aauhi-xbl1s0.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FIG. 3. Comparação de perfis de desempenho para várias regras de parada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na Fig. 3 mostra perfis de desempenho para várias regras de parada. </font></font><img src="https://habrastorage.org/getpro/habr/post_images/f56/2b2/fa8/f562b2fa8369f5f0c257866d2aa57e03.svg" alt="N_K"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- a mesma regra "mencionada acima" e "trivial" - com um limite de limiar do número de observações processadas. </font></font><img src="https://habrastorage.org/getpro/habr/post_images/f14/bec/845/f14bec8450b9f53b4a348df8b5524f9a.svg" alt="N_ {CX}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font><img src="https://habrastorage.org/getpro/habr/post_images/da5/d7f/754/da5d7f7548d7c0e962c9f960fdeb2136.svg" alt="N_ {CR}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- limites limiares do tamanho máximo do cluster dos mesmos resultados quadro a quadro ( </font></font><img src="https://habrastorage.org/getpro/habr/post_images/f14/bec/845/f14bec8450b9f53b4a348df8b5524f9a.svg" alt="N_ {CX}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e combinados ( </font></font><img src="https://habrastorage.org/getpro/habr/post_images/da5/d7f/754/da5d7f7548d7c0e962c9f960fdeb2136.svg" alt="N_ {CR}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- a regra descrita neste documento, com uma estimativa da distância esperada para o próximo resultado usando combinações de modelagem e "inatividade".</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez de uma conclusão</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O objetivo do artigo era mostrar que nos sistemas de reconhecimento de documentos em quadros de sequências de vídeo existem muitos problemas interessantes, não apenas diretamente da visão computacional, mas também de outras áreas interessantes. Embora tenhamos mostrado o problema de encontrar o tempo de parada ideal apenas na sua forma mais simples, a parte mais interessante começa quando, por exemplo, queremos levar em consideração não apenas o número de quadros no modelo, mas também o tempo de execução real. Esperamos que você esteja interessado e obrigado por sua atenção! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
- A </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
publicação foi preparada com base no artigo Sobre estratégias de parada ideais para reconhecimento de texto em um fluxo de vídeo, K. Bulatov, N. Razumnyi, VV Arlazarov, IJDAR 22, 303-314 (2019) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.1007 / s10032-019-00333-0</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se o leitor estiver interessado na teoria do tempo ideal de parada, em particular a prova da otimização da regra míope para problemas monótonos, recomendamos o curso publicado de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ótima parada e aplicações</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Thomas Ferguson, UCLA). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algumas fontes mais interessantes sobre esse assunto: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chow YS, Siegmund D. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grandes expectativas: A teoria da parada ideal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Houghton Mifflin, 1971, 139 p. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berezovsky B.A., Gnedin A.V. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Melhor Problema de Escolha</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Science, 1984, 200 pp. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ferguson TS, Hardwick TS </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regras de parada para revisão</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Journal of Applied Probability., V. 26, N. 2, 1989, p. 303-313. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ferguson TS</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estatística matemática: uma abordagem teórica da decisão</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Academic press, 1967, p. 396.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt497024/index.html">Por que hiperconvergência? Visão geral e testes do Cisco HyperFlex</a></li>
<li><a href="../pt497028/index.html">Bem-vindo ao MeetUp de sistema operacional de robô</a></li>
<li><a href="../pt497030/index.html">Experiência na implementação de fábricas de rede baseadas em EVPN VXLAN e Cisco ACI e uma pequena comparação</a></li>
<li><a href="../pt497032/index.html">Negócio de serviços e crise: histórias de sucesso. Como o pensamento fora da caixa funciona para você?</a></li>
<li><a href="../pt497034/index.html">O que é o novo nRF Connect SDK for Nordic? Evolução, revolução ou alternativa?</a></li>
<li><a href="../pt497040/index.html">Estratégia de crescimento liderada por produtos. Como o Miro cresce x3 anualmente</a></li>
<li><a href="../pt497046/index.html">Como trazer um site para o oeste no TOP10 sem saber nada sobre SEO</a></li>
<li><a href="../pt497050/index.html">TeamLead Conf 2020: principais relatórios</a></li>
<li><a href="../pt497052/index.html">Semana de segurança 16: xHelper - Trojan de sobrevivência do Android</a></li>
<li><a href="../pt497054/index.html">Produto e priorização: como avaliar os objetivos do projeto?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>