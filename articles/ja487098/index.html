<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌏 🙋 🐗 アリで描く：アリのコロニー最適化アルゴリズムを使用した手続き型画像 🤛🏻 🚣🏽 🚪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="なぜアリで描きたかったのですか
 ソフトウェア設計の複雑さを探る芸術作品を作りたかったのです。巨大なコードベースを提示するとき、その独立して発生する複雑さと、相互に関連しあう相互に関連する部分について考えます。その一般的な形は、いわば、多くの個性の行動から生じます。
 
 これをグラフィカルに表現す...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>アリで描く：アリのコロニー最適化アルゴリズムを使用した手続き型画像</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487098/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/d31/366/59ed31366bcf08b906a07e476152a66c.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜアリで描きたかったのですか</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソフトウェア設計の複雑さを探る芸術作品を作りたかったのです。巨大なコードベースを提示するとき、その独立して発生する複雑さと、相互に関連しあう相互に関連する部分について考えます。その一般的な形は、いわば、多くの個性の行動から生じます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これをグラフィカルに表現する方法を考えていたところ、私に反応を見つけた画像の1つがアリのコロニーの画像でした。アリは、出現しつつある（創発的な）複雑さの素晴らしい例です。単一の蟻は建築家ではありませんが、一緒に壮大で複雑な構造を構築します。</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/4f3/a72/5b14f3a72a15eefbeef534448a51647b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ホルミカリアのスキーム。出典：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィキメディアコモンズ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
私はアリのコロニーのシミュレーションに関する情報を探すことから始めました。明らかに、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これについての文献があり、それは美しい</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。しかし、トリックは、蟻塚が砂とその物理的な地球の物理学に一部依存して発生することです-蟻の作成は、蟻がそれを置いたときに粒子がどのように配置されるかに依存するためです。 2Dで何かを作成したかったので、砂の物理コードを書かずにシミュレーションに直接行こうとしました。つまり、蟻塚の物理シミュレーションを放棄する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このため、私は再び検索を開始し、それらは私を完全に</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なる</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスのアリシミュレーション</font><font style="vertical-align: inherit;">に導きました</font><font style="vertical-align: inherit;">：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蟻コロニー最適化（蟻コロニーアルゴリズム）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antコロニー最適化は、グラフの2点間の最短経路を見つける問題を解決するために使用されるエージェントアルゴリズムです。 「エージェント」とは、アルゴリズムが個別の手順（この場合は「アリ」）で構成されており、その突発的な動作によって問題が解決されることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは非常に簡単に動作します。各アリはその経路に「フェロモン」の痕跡を残します。アリは蟻塚を離れた後に1種類のフェロモンを残し、食べ物を見つけたときにもう1種類のフェロモンを残します。餌探しのアリは「食べ物」のフェロモンの痕跡を見つけようとしますが、蟻塚を探しているアリは「家」のフェロモンの痕跡を探します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自分が短い経路にいることに気付いたアリは、家から食べ物まで、またその逆に、より速く移動することができます。</font><font style="vertical-align: inherit;">これは、それらがフェロモンのより飽和した層を作成することを意味します。</font><font style="vertical-align: inherit;">アリが長く動くと、より豊かなトラックが好まれ、短いパスに沿って動きます。</font><font style="vertical-align: inherit;">個々のアリは非常に単純な規則に従って動作しますが、時間の経過とともにアリは2点間のより最適な経路を見つけます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シミュレーション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は処理3でantシミュレーターを作成しました。私は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gregory Brownによるこの驚くべき投稿から</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のコード</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">を</font></a><font style="vertical-align: inherit;">シミュレートすることにより、独自の実装を開始しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アリが動き始めた後、私はコードを拡張および変更し始め、より大きなピクセルグリッドでよりよく機能するようにしました。面白いシミュレーション（必ずしも</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">効果的で</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はない</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を取得したかったので</font><font style="vertical-align: inherit;">、コードでの作業が決まりました。各アリが数ピクセル先に見えるように、私はアリの非常に初歩的なビジョンを作成しました。アリが死んでから生まれるのを追加して、アリが空間全体にランダムに分散しないようにしました。最後に、私はアリを少し沈黙させました。検索が失敗した場合でも、アリは実際にフェロモンを残します。これは、アリの実際の動作に似ています。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、ブラウザーでp5.jsのシミュレーションポートを再生できます！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Githubで移植されたソースコードを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">確認することもでき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます。</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シミュレーションの何よりも、私はアリが生み出す美しく奇妙で複雑な形に魅了されました。</font><font style="vertical-align: inherit;">彼らは直線的に行進しませんが、ループ、ターン、ブランチを形成します。</font><font style="vertical-align: inherit;">さらに興味深いのは、アリの世界のさまざまな変数を変更することで、アリが作成したフィギュアの外観を制御できることです。</font><font style="vertical-align: inherit;">たとえば、フェロモンの蒸発率やアリの視界をピクセル単位で変更できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アリを芸術に変える</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シミュレーションが機能し始めたら、次のステップは、出力するデータを調査することでした。私の目標は、ある種の2次元イメージを作成することでした。つまり、アリが作成したフィギュアをキャプチャして描画する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、さまざまなタイプの出力を書きました。いくつかのタイプのラスター出力と1つのベクトルです。ラスター出力をキャプチャするために、アリが訪問したセルとその訪問の頻度を追跡しました。この結論のフィルターで遊んだ後、アリが訪れた場所の幽霊のような痕跡を得ることができます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b02/930/8ca/b029308ca64dee625eccbe87749bfc87.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラスター出力の例。</font><font style="vertical-align: inherit;">歩道は人気のあるアリのトラックに沿ってはるかに広く、アリはアリの丘の周りをランダムに歩き回っています。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラスター出力は興味深いものでしたが、個々のパスをより明確に確認したかったので、svgにエクスポートする可能性を検討しました。</font><font style="vertical-align: inherit;">ベクトル出力のために、私は各アリの履歴を保存し、彼らが食べ物や蟻塚に達したときに、この話をリストに書き留めました。</font><font style="vertical-align: inherit;">レンダリングでは、保存されたすべてのパスをサンプリングし、一連の曲線としてレンダリングしました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/069/397/a81/069397a81dcb254778ab2ce864bab992.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクトル出力の例。</font><font style="vertical-align: inherit;">ここでは、アリの個々のパスを見ることができます。</font><font style="vertical-align: inherit;">多くのアリがいる場所では、わずかに重なる線がより広い経路を形成します。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">点を結びます</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たくさんの点の間を移動するアリを描きたいと思っていたので、いくつかのシミュレーションを1つの画像にリンクするコードは最初のものの1つでした。しかし、それでは何を描くべきですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、文字通りのグラフを作成することにしました。単純な二分木から始めて、さらに複雑な視覚化に移ります。アリのコロニーを最適化すると、グラフ内のパスを見つける問題が解決されるため、これは自然なステップのように見えました。また、これはコードの複雑さを視覚化する興味深い方法になると思いました。UMLダイアグラムまたは依存関係グラフを取得し、アリを使用してレンダリングしてみませんか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はすでに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphviz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">精通していた</font><font style="vertical-align: inherit;">ので、このツールキットと</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">DOTグラフ記述言語</font></a><font style="vertical-align: inherit;">を使用することにしました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シミュレーションのノードとエッジを指定します。</font><font style="vertical-align: inherit;">Graphvizには、ピクセル座標の注釈を含むDOTファイルを出力するモードがあります。</font><font style="vertical-align: inherit;">私は非常に醜いDOTファイルパーサーを作成し、注釈付きのDOTファイルと一緒に使用して、蟻塚と食べ物の場所をシミュレートしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
二分木を使った実験は有望であり、非常に自然で有機的な外観をもたらしました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/971/59e/e53/97159ee533223d92707a989ba83c10c3.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純な二分木。</font><font style="vertical-align: inherit;">血管造影のようなものだと言われました。</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/278/845/f30/278845f30db3fab5dc9085c6261130b7.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もう少し複雑なツリーで、すでにかなり深いです。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、さまざまなコードベースを入力として使用して、より多くのグラフを作成し始めました。</font><font style="vertical-align: inherit;">私はいくつかの単純なPythonスクリプトを作成しました。1つはgitツリーをDOTファイルに変換し、もう1つはCインポートの依存関係をDOTファイルに変換しました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d41/699/426/d41699426c3cf2e31c97b2ee429dc34b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アリによって描かれたgitオブジェクトツリーのオブジェクトのグラフ。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/813/525/30d/81352530da26c9e3cdf334d6909c479e.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linuxカーネル内のファイル間の依存関係。ノードとエッジは、Graphvizグラフの正方形スタイルを使用して作成されました。実際、ランダムグラフほど興味深いものではありません。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これらのグラフはすべて興味深いものであり、間違いなく複雑ですが、実際には、それらが作成されたコードベースの一般的な形式について何も言わなかったことにがっかりしました。コードの視覚化を実験するほど、コードベースから興味深いグラフを作成すること自体が、別の困難な作業であることに気付きました。しかし、私は非常に大きなグラフの複雑さを気に入って、後で再びこれに戻りました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の次の実験は単純な形のゲームでした。線、円、正弦波、およびノー​​ドとエッジで簡単に説明できるその他の形状からグラフを作成しました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fab/5f3/287/fab5f32876434586bafc780db2d897d9.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セグメントの右側のセグメント上のポイントは、ポイント同士がより接近しています。</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d5/8e5/ef1/2d58e5ef1de0f74706ee2e47321b94d0.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なる正弦波周波数。</font><font style="vertical-align: inherit;">かなり良いオシロスコープがアリから出てくると思います。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純な三角形分割された空間が私にとって最も興味深いように思えました。</font><font style="vertical-align: inherit;">ランダムに、または図形を描くことによって、均等に分散された多数のポイントを生成し、Processingライブラリを使用してこれらのポイントをDelaunay三角形分割またはボロノイ図に変換しました。</font><font style="vertical-align: inherit;">次に、得られた肋骨を使用して蟻をシミュレートしました。各肋骨は1つの「蟻の丘」または「食べ物」を表しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/d31/366/59ed31366bcf08b906a07e476152a66c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アリボロノイ図によって描かれました。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これは複雑なアリの複雑さの美しい完全な空間の出現につながりました、そしてそれは私にずっと興味がある複雑さを説明しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、私は別の角度からその課題に取り組みました。ある友人がシミュレーションを見て、アリが壁に衝突したときに何が起こるか尋ねました-単純な障害物を回避できますか？私のコードは壁を境界線のケースとして処理する方法をすでに知っているので、内部の壁を追加し、迷路を解決する方法をアリに教えるために多くの時間を費やしました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e74/803/088/e74803088c3d09ddb1b2b77902004c72.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純な迷路を解こうとするアリの道。</font><font style="vertical-align: inherit;">蟻が行けないところに気づくと迷路の形がわかります。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アリが単純な迷路を解くことができれば、それらを組み合わせてより大きな作品を作成できるという考えがありました。</font><font style="vertical-align: inherit;">アリがそれらを解決できるようにシミュレーション変数を設定するのに多くの時間を費やしましたが、それでも迷路を安定して解決させることができませんでした。</font><font style="vertical-align: inherit;">結局、これはすべてアリの小道のカールになり、迷路自体の形状によって制限されていました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成した芸術作品</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、一歩下がってすべての実験の出力を検討することにしました。最も興味深い画像は、セミランダムポイントとエッジの大きなフィールドから取得されていることに気づき、ランダムポイントのDelaunay三角形分割間に線を引くようにシミュレーションを設定することで、これを私の最終決定とすることにしました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b3/09f/a33/3b309fa331b59c059e4b722d4e4c7c10.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シミュレーションの実行が完了しました。ファジースポットが得られる多くの重ねられたパスが含まれています。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最後の問題は、SVGベンドを完成した作業に変換する方法でした。実験から、美しい形のパスを強調するために、パスを何らかの方法でソートしたいことがわかりました。ただし、完成したシミュレーションの実行には1〜2時間かかりました。そのため、実験の実行ごとに変数を変更するのは不便でした。</font><font style="vertical-align: inherit;">シミュレーション出力をSVGに読み込み、必要な視覚効果を適用</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
する</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">処理図</font><font style="vertical-align: inherit;">を作成することにしました</font><font style="vertical-align: inherit;">。さらに、ポストプロセススクリプトをインタラクティブにして、線の太さや色を変えたり、しきい値を並べ替えたりできるようにしたかったのです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォアグラウンドとバックグラウンドにあるはずのパスを評価するために、いくつかの異なる方法を試しました。いくつかの異なる要因が計算されました：ラインの自己交差の数、そのスロープラインのラインによる交差の数、およびラインが前の2つのポイントによって予測されたスロープに従う可能性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要な外観になるまで、これらの推定値のさまざまな重みと値を使用した実験に後処理スクリプトを使用しました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ac/8a0/5e7/6ac8a05e7e250a030461dab605e0770f.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前線と背景線のしきい値設定。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この時点で、各変数を変更するときに画像を保存すると、非常に役立ちました。必要な画像に近づいたとき、いくつかの要因を一度に変更するよりも、いくつかの小さな変化を比較する方がはるかに簡単でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長いセットアップと小さな変更を加えた後、シミュレーションから次の画像を作成しました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/781/a92/940/781a92940d65d658abfd788b7e0a27db.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は私にとって最も興味深いと思われる領域にズームインし、それをトリミングして、空のスペースと塗りつぶされたスペースのバランスをとります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のステップは、このイメージを物理的なオブジェクトに変換する方法の選択でした。私はそれらを40×50 cmのポスターとしてデジタルで印刷していましたが、カラーペーパーに画面を印刷しようとしましたが（失敗しました）。デジタル印刷されたポスターは見栄えが良いですが、将来は画像を画像の一部としてコピーしたいと考えています。複雑なドローイングは瞑想的であり、手動でドローイングすることで興味深い効果を得ることができると思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロジェクトには予想以上に多くの時間が費やされ、最初に思ったよりも複雑になりました。</font><font style="vertical-align: inherit;">しかし、これはあらゆる種類の計算ジオメトリとアルゴリズムの問​​題を試すのに最適な方法です。</font><font style="vertical-align: inherit;">複雑さを解消するために数千行のコードを書いたのはかなり皮肉なことだと思いますが、見栄えがよく、それ自体が説明になっていることを嬉しく思います。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja487088/index.html">ArduinoでのGSMスケールのデバッグ</a></li>
<li><a href="../ja487090/index.html">新しいレベルのWindows最適化</a></li>
<li><a href="../ja487092/index.html">ERPシステム実装プロジェクトの一部としてのビジネスプロセスのモデリング</a></li>
<li><a href="../ja487094/index.html">Kafkaから受け取った再処理イベント</a></li>
<li><a href="../ja487096/index.html">切れ端。ドキュメンテーションでの作業プロセスを簡単にする方法</a></li>
<li><a href="../ja487100/index.html">最先端の不変のデータ構造</a></li>
<li><a href="../ja487106/index.html">PVS-StudioアナライザーのRunUOチェック</a></li>
<li><a href="../ja487108/index.html">モバイルゲーマープロフィール：MyTracker Research</a></li>
<li><a href="../ja487110/index.html">Slurm SRE。Booking.comとGoogle.comの専門家による完全な実験</a></li>
<li><a href="../ja487112/index.html">Edge of Madness：The Basic Circle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>