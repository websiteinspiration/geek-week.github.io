<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤷🏿 ⛸️ 🧑🏻‍🤝‍🧑🏻 例としてLoRaWANを使用したワイヤレスプロトコルの保護 👨🏾‍💻 🤘🏼 👨🏻‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル。
 
 もう一度、LoRaWANの例を使用して、IoTデバイスで使用されるワイヤレスネットワークのデータセキュリティの基本的な（必要最低限​​の）レベルがどのように提供されるかについてお話します。
 
 なぜLoRaWANなのか？第一に、独自のワイヤレスプロトコルを開発している場...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>例としてLoRaWANを使用したワイヤレスプロトコルの保護</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458394/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度、LoRaWANの例を使用して、IoTデバイスで使用されるワイヤレスネットワークのデータセキュリティの基本的な（必要最低限​​の）レベルがどのように提供されるかについてお話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜLoRaWANなのか？第一に、独自のワイヤレスプロトコルを開発している場合に参照として参照する必要がある、十分に説明され開発された標準であるためです。次に、非常にネイティブで典型的なIoTソリューションであるためです。もちろん、Wi-FiまたはLTEでセキュリティを分解することはできますが、ほとんどの開発者にとってこれは役に立たない分析になります。独自のWi-Fi実装を作成する必要はほとんどありません。第三に、開発者がすべてのバイトを保存するのは低電力のIoTデバイスであり、多くの場合、最も漏洩しやすいことが判明しています。ここでLoRaWANは、バイトを保存し、攻撃されないようにするための良いアイデアを提供します。最後に、最後に文字通りここ数日で、私たちのクライアントの何人かはLoRaWANでのデータ保護についてもっと多くを彼らに話すように頼んだので、そしてこの記事で私は1つの石で2羽の鳥を殺します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rt/-k/bb/rt-kbbrmazihfcgicxk0spcnexs.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーとデバイス間のLoRaWANでの</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
メッセージング写真のLoRaWANのメッセージングスキームはかなり単純に見えますが、この単純さは誤解を招くものです。</font><font style="vertical-align: inherit;">今、あなたはその理由を理解するでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはLoRaWAN 1.0.2を例として分析し、起こり得る脅威に対抗します。優れた開発者は常に、自分のシステムがどのように保護されているかではなく、どのように破壊されるかについて考える必要があります。</font><font style="vertical-align: inherit;">そうでなければ、誰かが彼のためにそれについて考えるでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、ワイヤレスネットワークの主な脅威は何ですか？それらから身を守る方法は？</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーデータの傍受</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純な脅威は、定期的なデータ傍受です。</font><font style="vertical-align: inherit;">電波は制御不能に伝播するため、絶対に誰でも希望の範囲と種類の変調に調整された受信機を持ち、送信するすべてを聞くことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを防ぐ最も簡単な方法は、データの暗号化です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LoRaWANでは、ユーザーデータはAES-128アルゴリズム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><b><font style="vertical-align: inherit;">使用して暗号化され</font></b><font style="vertical-align: inherit;">、キーの長さはそれぞれ128ビット（16バイト）です。</font><font style="vertical-align: inherit;">AESは信頼性の高いアルゴリズムですが、ハードウェア暗号化ブロックさえもない最小限の最新のマイクロコントローラーを使用しても、その使用による大きなオーバーヘッドは発生しません。周波数が48 MHzのCortex-M3では、1つの16バイトブロックが最初から約100μsで暗号化されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データの繰り返し</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合によっては、攻撃者は何を送信しているのかを正確に知る必要はありません。たとえば、あるものを送信する閉じたウィンドウのセンサーと開いているもののセンサーがある場合、それは別のものです。その内容の詳細に行くことなく1つを記録し、センサーを無音にして、システムがパケットの不足により何かが間違っていると疑わないようにすることができます。センサーから-以前に記録されたメッセージをブロードキャストします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LoRaWANでは、各パケットにカウンターが追加されます</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。パケットが前のパケット以下のカウンターでネットワークサーバーに到着した場合、このパケットは単に破棄されます。 1メートルあたり2バイトで、IoTシステムのメッセージ転送の一般的なペースで、それは非常に長い間続きます。たとえば、毎分温度を送信する国内の気象ステーションでさえ、1か月半後にのみオーバーフローします（LoRaWANでは、4バイトのカウンターを使用できます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、明らかな問題があります。オーバーフローの後、デバイスから番号0のパケットが送信されます。これは、明らかに他のどの番号よりも小さくなりますが、ネットワークサーバーはそれを正しく認識し、パケットのカウントを再開する必要があります。さらに、デバイスはリブートするだけでカウンターをリセットできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、次の2つの方法のいずれかで実現されます。</font></font><br>
<br>
<ul>
<li>           (  LoRaWAN    Join)</li>
<li>       0,     </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LoRaWANでは、デバイスのアクティブ化方法（OTAAまたはABP）に応じて、どちらの方式も使用されます（これらについては以下で説明します）。最初のオプションはOTAAに使用されますが、デバイスには新しい暗号化キーも与えられます。そのため、気象ステーションの下で1か月半を費やした攻撃者でさえ、以前に記録された単一のパケットを送信できないため、システムはそれを受け入れることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークに登録手順がないABPの場合、2番目のオプションが使用されます。ただし、カウンターオーバーフロー期間が推定デバイス寿命を著しく超えている場合は、無効にすることができます。各パケットの送信後に偶発的に再起動した場合、そのようなエンドデバイスはカウンタ値を不揮発性メモリに保存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、2番目のスキームは安全性は低くなりますが、実際にはそれは許容されます。攻撃者はパケットを記録するのではなく、具体的にはゼロを記録する必要があります。必要に応じて、その内容を他のすべてのパッケージと異なるものにすることができます。たとえば、データを送信するのではなく、デバイスのタイプと設定に関する情報を送信します。その後、その遮断と繰り返しは合理的なものを与えません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偽造品</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、質問がすぐに発生します-カウンターが偽造されている場合はどうなりますか？パケットの暗号化された部分に入れることができますが、ユーザーデータの実際の量は2バイト減少します。ユーザーデータだけでなく、最初に16バイトのブロックサイズに適応する必要がある暗号化を行うことができます。次に、ネットワークサーバーの負荷が増加します。これにより、パッケージのすべてのアクションで最初にそれを復号化する必要があります（スキームでは、ユーザーデータのみが暗号化されます。パケットが正式な署名によって無視された場合は、何も復号化する必要はありません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
攻撃者がパッケージ番号を知っているかどうかは私たちにとって重要ではないことは明らかです-ネットワーク再登録（OTAA）を備えたスキームでは、この知識は彼をまったく助けません、そしてABPでは彼は海のために非常に長い時間天気を待ちます、つまり番号N-1のパケットの次の到着。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、この数を変更させないことで十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、LoRaWANのパッケージ全体が暗号化署名-AES-CMACで署名されます。この署名は、この規格ではMIC、メッセージ整合性コードと呼ばれています。</font><font style="vertical-align: inherit;">すべてのヘッダーとデータを含む</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージ全体が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更されずにサーバーに到達した</font><font style="vertical-align: inherit;">ことを確認し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、次のパケットを受け入れたら、そのカウンター（送信者アドレスなど）をすばやく確認し、それが自分のもので正しい場合は、署名を確認し（追加のリソースを費やしている）、署名も正しい場合は、データを復号化して送信しますそれらをさらに。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不変データの追跡</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、攻撃者がデータを理解したり、少なくとも繰り返したりするのを防ぐだけでは不十分です。場合によっては、データが変化しないことを攻撃者が理解するだけで十分です。教科書の例は家庭用水道メーターです。所有者が自宅にいるかどうかを確認したいだけなら、正確に何リットルあるかは関係ありません</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この値が増加している</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か</font><i><font style="vertical-align: inherit;">どうか</font></i><font style="vertical-align: inherit;">を知ることが重要です</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、データの暗号化は可逆的な手順です（解読できます）。つまり、同じキーで暗号化された同じデータは常に同じに見えます。読み取り値が変化しない水道メーターからパケットを受信</font><font style="vertical-align: inherit;">すると</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、パケットを復号化</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">せずに、それらが変化しないことを理解できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これに対処するのは非常に簡単です。データまたはキーを変更する必要があります。データを変更するには、ソルトを追加することができます-ランダムな数バイト。これは、復号化後に単純に破棄されます。残念ながら、パケットの16バイトはすでにスパースであるため、一般的なケースでは、実際のゴミに2〜4バイトを費やしたくありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LoRaWANはよりトリッキーなスキームを使用しています</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。パケットカウンターがあることを覚えていますか？したがって、AESアルゴリズムを使用して暗号化されるのは、このカウンターに加えて、デバイスとパケットに関する情報（LoRaWANネットワーク上のデバイスの短いアドレス、データ転送方向、16バイトのセグメントカウンター）であり、XOR結果はユーザーデータパケットです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、ペイロードバイトが無駄にならず、負荷が変化したかどうかに関係なく、各メッセージは異なって見えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS別のオプションがありますが、もう少し簡単です。メッセージカウンターをキーの最後のNバイトとして使用します。この場合、キーは毎回新しくなりますが、サーバーはメッセージカウンターの値を知っているので（メッセージの暗号化されていない部分にあります）、それを復元できます。マイナス-パッケージが複数の16バイトブロックで構成されていて、それらに同じデータが含まれている場合、暗号化後も同じままです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">攻撃者は暗号化キーを学びました</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは非常に現実的な状況です。IoTは多数のデバイスを使用することを特徴としています。そのため、部外者へのアクセスを十分に信頼できる方法で制御できない場合があります（ネットワークオペレーターでもある場合、顧客は当然のことながら部外者です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、すべてのデバイスが同じ暗号化キーを持っている場合、それらのいずれかの所有者は他のデバイスのトラフィックをリッスンできます（一般的に、彼がファームウェアを変更する能力を持っている場合、そのような操作では、キーを明示的に知ることすらできません-させてください新しいファームウェアは古いファームウェアと同じ場所から取得し、他の人のデータを提供するだけです）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LoRaWANは、デバイスごとに個別の2つの主要な使用法を実装しています。</font></font><br>
<br>
<ul>
<li>Over The Air Activation, OTAA —&nbsp;     ,     </li>
<li>Activation By Personalization —&nbsp;      ,   </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合計で少なくとも2つのキーがあります。ユーザーデータを暗号化するAppSKeyと、メッセージに署名するNwkSKeyです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、OTAAスキームの方がより便利で信頼性があります。キーは何度でも変更でき、一意であることが保証されており、ネットワークサーバー以外の誰にも知られていません。 ABPでは、キーは決して変更されず、一意性はデバイスメーカーの良識に依存します（たとえば、これらのキーはマイクロコントローラーの一意のIDから生成されるため、2つのデバイスでの一致の可能性は無視できます）。デバイスを接続するときに、どこかに明示的に保存する必要があります。ネットワークにそれらをサーバーに登録します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、OTAAでキーを取得するための手順は別の話であり、不正確に実装すると、さらにいくつかのタイプの攻撃が生成される可能性があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成されたキーの傍受</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、ネットワークへの登録中に毎回新しいキーが生成される場合、デバイスとサーバー間でそれらを同期する必要があります。つまり、攻撃者がそれらを傍受して、すべての保護を破ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、LoRaWANデバイスには3つ目のキーであるAppKeyがあり、デバイス</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に緊密に接続されて、ある瞬間に使用されます：ネットワークに登録するとき。</font><font style="vertical-align: inherit;">その助けを借りて、デバイスとサーバーの間でセッション鍵の交換が署名されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的には、AppKeyはデバイスごとに一意である必要がありますが、多くの場合、同じAppKeyの使用が許可されます-一度だけ必要なので、これは有効であると認識できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デバイスを接続する前のAppKeyは、ネットワークサーバーの設定に入力されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、デバイスは登録要求（JoinRequest）を生成しますが、それを暗号化する（機密情報は含まない）のではなく、AppKeyキーで署名します。このパケットを受信し、送信者アドレス（これが私たちのデバイスであるかどうか）と署名を確認したネットワークサーバーは、ネットワーク設定を転送するJoinAcceptパケットで応答します。まあ、実際には登録を確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AppSKeyキーとNwkSKeyキーはどこから来るのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ランダムなAppNonce番号、キー番号（1または2）、ネットワークID、および応答でサーバーから送信された別のランダムなDevNonce番号の組み合わせのAppKeyキーを使用したAES-128暗号化の結果です。</font></font><br>
<br>
<pre><code class="plaintext hljs">NwkSKey = aes128_encrypt(AppKey, 0x01 | AppNonce | NetID | DevNonce)<font></font>
AppSKey = aes128_encrypt(AppKey, 0x02 | AppNonce | NetID | DevNonce)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
登録パケットを交換した後のデバイスとサーバーの両方がこれらすべてのパラメーターを知っているため、同じキーが生成されます。</font><font style="vertical-align: inherit;">したがって、無線でキーが送信されることは決してありませんが、同時にデバイスとサーバーは一意の暗号化キーとパケット署名を受信します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自身のデータストリームの傍受</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それだけではありません！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、通常、ネットワーク上での登録イベントはまれですが、攻撃者がそれを開始して傍受できたと想像してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、記録したJoinRequestパケットを送信するだけで、何も変更せずに、サーバーはJoinAcceptパケットで応答し、新しいキーを生成します。その後、攻撃されたデバイスは、サーバーとの通信を停止します。これは、JoinRequestを開始しておらず、キーを更新する理由がないためです。つまり、同じ攻撃が繰り返されますが、すでにネットワーク上の登録手順で行われています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
攻撃者はデータを偽造することはできません。これを行うには、キーを知っている必要があり、それらを取得するには、彼が知らないAppKeyを知っている必要があります。しかし、ネットワークからデバイスをノックアウトするために-彼はできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを回避するために、デバイスは登録時にランダムなDevNonceをサーバーに送信します（ご覧のとおり、上記のパッケージに含まれています）。</font><font style="vertical-align: inherit;">キーがそれに基づいて生成されるという事実に加えて、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LoRaWANサーバーはDevNonceアーカイブを格納する</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という別の目的を</font><b><font style="vertical-align: inherit;">果たします</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">デバイスがすでに使用されているDevNonceで繰り返し登録要求を受信した場合、サーバーはそれを単に無視します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、デバイスは登録ごとに新しいDevNonceを生成する必要があります（つまり、従来のパケットをリレーする回路—「応答を受信しなかったため、同じパケットを2回無線で吐き出しました」-ここでは機能せず、JoinRequestが毎回再作成されます）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テキストは多く、写真はほとんどありませんでしたが、これは無線のみに対する攻撃の完全な図ではありません（たとえば、デバイスで設定を暗号化する必要がある理由についての質問であり、デバイスごとに個別のキーをキーに残しました）ブラケットの外では、これはもはやラジオについてではありません）。たとえば、LoRaWAN 1.1では、保護スキームがさらに複雑になっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも、これは情報の保護に最低限の価値があると主張するあらゆる無線プロトコルの紳士用のセットであり、同時に低速ネットワークの低電力デバイスで動作するように設計されています。</font><font style="vertical-align: inherit;">さらに、これは安全なプロトコルを実装するだけでなく、低電力デバイス用に書かれたプロトコルを実装し、セキュリティを大幅に損なうことなく、可能な限り通信時間と計算能力の両方の消費を最小限に抑える非常に良い例です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、IoT用の独自のプロトコルを設計している場合、詳細に指定されたLoRaWANは、攻撃を行う基本的な方法の理解と組み合わせて、この保護を適切に構成する方法を学ぶ絶好の機会を提供します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja458378/index.html">サイトのレイアウトにAvocodeを使用します。初心者向けのレビュー。ボーナス-30日間の試用期間を登録する</a></li>
<li><a href="../ja458382/index.html">なぜこれを教えるのですか？</a></li>
<li><a href="../ja458384/index.html">HP 3D Structured Light Scanner Pro S3レビューとテスト</a></li>
<li><a href="../ja458388/index.html">深い（学習+ランダム）フォレストと記事の解析</a></li>
<li><a href="../ja458390/index.html">Ceph-「膝の上」から「本番」までパート2</a></li>
<li><a href="../ja458396/index.html">サーバー側レンダリングでVue.jsでの開発を便利にする方法</a></li>
<li><a href="../ja458398/index.html">遠隔作業の衛生またはテレパシーの利点</a></li>
<li><a href="../ja458404/index.html">モノリスからマイクロサービスへの移行：歴史と実践</a></li>
<li><a href="../ja458406/index.html">ユーティリティおよび非ユーティリティプログラムに関する30以上の質問</a></li>
<li><a href="../ja458408/index.html">セキュリティウィーク27：インスリンポンプの脆弱性</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>