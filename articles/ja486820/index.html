<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋🏻 🕦 🦗 70 Javascriptインタビューの質問 ⛑️ 🍸 💆🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは！
 
 この記事が初心者の開発者と経験豊富な開発者の両方に役立つことを願っています。
 
 他の人よりも難しいと思われた質問では、追加の文献への参照が提供されています。
 
 詳しいコメントはありがたいです。記事の編集時には、すべてのコメントが考慮されます。
 
 じゃ、行こう。
 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>70 Javascriptインタビューの質問</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486820/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事が初心者の開発者と経験豊富な開発者の両方に役立つことを願っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の人よりも難しいと思われた質問では、追加の文献への参照が提供されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
詳しいコメントはありがたいです。</font><font style="vertical-align: inherit;">記事の編集時には、すべてのコメントが考慮されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
じゃ、行こう。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70 Javascriptインタビューの質問</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
質問：</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. nullとundefinedの違いは何ですか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. &amp;&amp;演算子は何に使用されますか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.「||」演算子は何に使用されますか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.単項プラス（+演算子）を使用すると、文字列を数値に変換する最速の方法ですか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. DOMとは何ですか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.イベントの伝播とは何ですか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.イベントバブリングとは</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.イベントキャプチャとは何ですか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. event.preventDefault（）メソッドとevent.stopPropagation（）メソッドの違いは何ですか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. event.preventDefault（）メソッドの使用方法を学ぶには？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. obj.someprop.xでエラーが発生するのはなぜですか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12.イベントターゲットまたはターゲット要素（event.target）とは何ですか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">13.      (event.currentTarget)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">14.      "=="  "==="?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">15.        false?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">16.     "!!"?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">17.       ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">18.    (Hoisting)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">19.     (Scope)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">20.    (Closures)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">21.    JS  ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">22.  ,    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">23.     «use strict»?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">24.    this?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">25.    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">26.   IIFE?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">27.     Function.prototype.apply?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">28.     Function.prototype.call?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">29.      call  apply?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">30.     Function.prototype.bind?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">31.        JS         ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">32.      (Higher Order Functions)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">33.    JS     (First-class Objects)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">34.      Array.prototype.map?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">35.      Array.prototype.filter?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">36.      Array.prototype.reduce?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">37.    arguments?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">38.   ,   ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">39.      b     ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">40.   ECMAScript?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">41.     JS  ES6  ECMAScript2015?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">42.       «var», «let»  «const»?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">43.     (Arrow Functions)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">44.    (Classes)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">45.     (Template Literals)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">46.     (Object Destructuring)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">47.    (Modules)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">48.    Set?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">49.      (Callback Function)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">50.    (Promises)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">51.   async/await?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">52.     spread-  rest-?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">53.      (Default Parameters)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">54.     (Wrapper Objects)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">55.             (Implicit and Explicit Coercion)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">56.   NaN?  ,    NaN?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">57.  ,    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">58.  ,    ,          ( "%")?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">59.      ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">60.   AJAX?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">61.   JS  ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">62.      Object.freeze  Object.seal?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">63.      «in»   hasOwnProperty?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64. JSで非同期コードを操作するためのどのようなテクニックを知っていますか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65.通常の関数と関数式の違いは何ですか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">66. JSで関数を呼び出す方法は？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67.暗記またはメモ化とは何ですか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68.暗記の補助機能をどのように実装しますか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69. typeof nullがオブジェクトを返す理由 </font><font style="vertical-align: inherit;">値がnullかどうかを確認するにはどうすればよいですか？</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70.「新しい」キーワードは何に使用されますか？</font></font></a><br>
<br>
<a name="1"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. nullとundefinedの違いは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、共通点についてお話ししましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、これらは7つのJS "プリミティブ"（プリミティブタイプ）に属します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> primitiveTypes = [<span class="hljs-string">'string'</span>, <span class="hljs-string">'number'</span>, <span class="hljs-string">'null'</span>, <span class="hljs-string">'undefined'</span>, <span class="hljs-string">'boolean'</span>, <span class="hljs-string">'symbol'</span>, <span class="hljs-string">'bigint'</span>]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二に、それらは偽の値です。</font><font style="vertical-align: inherit;">ブール（）または演算子 "!!"を使用してブールに変換した結果 </font><font style="vertical-align: inherit;">は偽です：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、今違いについて。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
undefinedがデフォルト値です。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値が割り当てられていない変数、つまり </font><font style="vertical-align: inherit;">宣言されているが初期化されていない変数。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明示的に何も返さない関数。たとえば、console.log（1）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトの存在しないプロパティ。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの場合、JSエンジンは値を未定義に設定します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> _thisIsUndefined
<span class="hljs-keyword">const</span> doNothing = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}
<span class="hljs-keyword">const</span> someObj = {
    <span class="hljs-attr">a</span>: <span class="hljs-string">'ay'</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-string">'bee'</span>,
    <span class="hljs-attr">c</span>: <span class="hljs-string">'si'</span><font></font>
}<font></font>
<span class="hljs-built_in">console</span>.log(_thisIsUndefined) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(doNothing()) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(someObj[<span class="hljs-string">'d'</span>]) <span class="hljs-comment">// undefined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nullは「値のない値」です。</font><font style="vertical-align: inherit;">nullは、変数に明示的に割り当てられる値です。</font><font style="vertical-align: inherit;">以下の例では、fs.readFileメソッドがエラーなしで機能するときにnullを取得します。</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'path/to/file'</span>, (e, data) =&gt; {
    <span class="hljs-built_in">console</span>.log(e) <span class="hljs-comment">//    null</span>
<span class="hljs-keyword">if</span>(e) {
    <span class="hljs-built_in">console</span>.log(e)<font></font>
}<font></font>
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nullと未定義を比較する場合、「==」演算子を使用するとtrueになり、「===」演算子を使用するとfalseになります。</font><font style="vertical-align: inherit;">これが発生する理由については、以下を参照してください。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="2"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. &amp;&amp;演算子は何に使用されますか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&amp;&amp;演算子（論理and）は、すべての値がtrueの場合、最初のfalse値または最後のオペランドを検索して返します。</font><font style="vertical-align: inherit;">不要なコストを回避するために短絡を使用します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-number">1</span> &amp;&amp; []) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">' '</span> &amp;&amp; <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-number">5</span>) <span class="hljs-comment">// 5</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ifステートメントで：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> router: Router = Router()<font></font>
<font></font>
router.get(<span class="hljs-string">'/endpoint'</span>, (req: Request, <span class="hljs-attr">res</span>: Response) =&gt; {
    <span class="hljs-keyword">let</span> conMobile: PoolConnection
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//    </span>
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">if</span> (conMobile) {<font></font>
            conMobile.release()<font></font>
        }<font></font>
    }<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&amp;&amp;演算子についても同じことが言えます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> router: Router = Router()<font></font>
<font></font>
router.get(<span class="hljs-string">'/endpoint'</span>, (req: Request, <span class="hljs-attr">res</span>: Response) =&gt; {
    <span class="hljs-keyword">let</span> conMobile: PoolConnection
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//    </span>
    } <span class="hljs-keyword">catch</span> (e) {<font></font>
        conMobile &amp;&amp; conMobile.release()<font></font>
    }<font></font>
})<font></font>
</code></pre><br>
<a name="3"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.「||」演算子は何に使用されますか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演算子「||」</font><font style="vertical-align: inherit;">（boolean or）最初の真の値を見つけて返します。</font><font style="vertical-align: inherit;">また、短絡を使用します。</font><font style="vertical-align: inherit;">この演算子は、デフォルトパラメータがES6で標準化される前に、関数にデフォルトパラメータを割り当てるために使用されました。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> || <span class="hljs-number">1</span> || <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 1</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logName</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">let</span> n = name || Mark
    <span class="hljs-built_in">console</span>.log(n)<font></font>
}<font></font>
<font></font>
logName() <span class="hljs-comment">// Mark</span>
</code></pre><br>
<a name="4"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.単項プラス（+演算子）を使用すると、文字列を数値に変換する最速の方法ですか？</font></font></h4><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">
よると</font><font style="vertical-align: inherit;">、数値である値に対して演算を実行しないため、+演算子は文字列を数値に変換する最も速い方法です。</font></font><br>
<br>
<a name="5"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. DOMとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DOMまたはDocument Object Modelは、HTMLおよびXMLドキュメントを操作するためのアプリケーションプログラミングインターフェイス（API）です。</font><font style="vertical-align: inherit;">ブラウザが最初にHTMLドキュメントを読み取る（「解析する」）と、それは大きなオブジェクト、つまりドキュメントに基づく本当に大きなオブジェクト、つまりDOMを形成します。</font><font style="vertical-align: inherit;">DOMはツリー構造（ドキュメントツリー）です。</font><font style="vertical-align: inherit;">DOMは、DOM自体またはその個々の要素やノードの構造を操作および変更するために使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のHTMLがあるとします。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document Object Model<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このHTMLのDOMは次のよう</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ax/cg/id/axcgidsa8fghreeuyvbhfpga6yo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
になります。JSでは、DOMはDocumentオブジェクトで表されます。</font><font style="vertical-align: inherit;">Documentオブジェクトには、要素の操作、作成、変更、削除などのための多数のメソッドがあります。</font></font><br>
<br>
<a name="6"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.イベントの伝播とは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントがDOM要素内で発生すると、実際にはそれだけで発生するわけではありません。</font><font style="vertical-align: inherit;">イベントはWindowオブジェクトからそれを呼び出した要素（event.target）に「伝播」します。</font><font style="vertical-align: inherit;">この場合、イベントはターゲット要素のすべての祖先に順次浸透（影響）します。</font><font style="vertical-align: inherit;">イベントの伝播には3つの段階またはフェーズがあります。</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イマージョン（キャプチャ、インターセプト）フェーズ-イベントはWindowオブジェクトで発生し、そのすべての祖先を介してイベントターゲットに下降します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ターゲットフェーズは、イベントがターゲット要素に到達したときです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">昇順-イベントはevent.targetから発生し、すべての祖先を順番に通過してWindowオブジェクトに到達します。</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/a3/9x/67/a39x67wkxdmcyzj-it5m2jmfxgg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントの配布について詳しくは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="7"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.イベントポップアップとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DOM要素でイベントが発生すると、この要素だけでなく、</font><font style="vertical-align: inherit;">イベントは（水中の気泡のように）「ポップアップ」し、イベント（event.target）の原因となった要素からその親に渡され、さらに上昇して、要素の親の親まで、それがWindowオブジェクトに到達します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のマークアップがあるとします。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grandparent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてそのようなJS：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">el, event, callback, isCapture = false</span>) </span>{
    <span class="hljs-keyword">if</span> (!el || !event || !callback || <span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span><font></font>
<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> el === <span class="hljs-string">'string'</span>) {<font></font>
        el = <span class="hljs-built_in">document</span>.querySelector(el)<font></font>
    }<font></font>
    el.addEventListener(event, callback, isCapture)<font></font>
}<font></font>
<font></font>
addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'DOMContentLoaded'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.child'</span>)
    <span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.parent'</span>)
    <span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.grandparent'</span>)<font></font>
<font></font>
    addEvent(child, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(parent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(grandparent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'grandparent'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-string">'html'</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'html'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'document'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">window</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'window'</span>)<font></font>
    })<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
addEventListenerメソッドには、3番目のオプションパラメータ-useCaptureがあります。</font><font style="vertical-align: inherit;">値がfalse（デフォルト）の場合、イベントは上昇段階から始まります。</font><font style="vertical-align: inherit;">その値がtrueの場合、イベントはダイビングフェーズから始まります（イベントのターゲットに関連付けられたイベントの「リスナー」の場合、イベントはダイビングフェーズまたは上昇フェーズではなく、ターゲットフェーズにあります。ターゲットフェーズのイベントは、要素のすべてのリスナーによって順番にトリガーされますuseCaptureパラメータに関係なく登録された-約。</font><font style="vertical-align: inherit;">子要素をクリックすると、コンソールが表示されます：子、親、祖父母、html、ドキュメント、ウィンドウ。</font><font style="vertical-align: inherit;">イベントポップアップは次のとおりです。</font></font><br>
<br>
<a name="8"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.没入イベントとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントがDOM要素で発生すると、それだけで発生するわけではありません。</font><font style="vertical-align: inherit;">没入フェーズでは、イベントはすべての祖先を介してWindowオブジェクトからイベントターゲットに下降します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マークアップ：</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grandparent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JS：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">el, event, callback, isCapture = false</span>) </span>{
    <span class="hljs-keyword">if</span> (!el || !event || !callback || <span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span><font></font>
<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> el === <span class="hljs-string">'string'</span>) {<font></font>
        el = <span class="hljs-built_in">document</span>.querySelector(el);<font></font>
    }<font></font>
    el.addEventListener(event, callback, isCapture)<font></font>
}<font></font>
<font></font>
addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'DOMContentLoaded'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.child'</span>)
    <span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.parent'</span>)
    <span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.grandparent'</span>)<font></font>
<font></font>
    addEvent(child, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child'</span>);<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(parent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(grandparent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'grandparent'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-string">'html'</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'html'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'document'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">window</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'window'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
addEventListenerメソッドには、3番目のオプションパラメータ-useCaptureがあります。</font><font style="vertical-align: inherit;">値がfalse（デフォルト）の場合、イベントは上昇段階から始まります。</font><font style="vertical-align: inherit;">その値がtrueの場合、イベントはダイビング段階から始まります。</font><font style="vertical-align: inherit;">子要素をクリックすると、コンソールにウィンドウ、ドキュメント、html、祖父母、親、子が表示されます。</font><font style="vertical-align: inherit;">これがイベントの没頭です。</font></font><br>
<br>
<a name="9"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. event.preventDefault（）メソッドとevent.stopPropagation（）メソッドの違いは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
event.preventDefault（）メソッドは、要素のデフォルトの動作を無効にします。</font><font style="vertical-align: inherit;">このメソッドをform要素で使用すると、フォームが送信されなくなります。</font><font style="vertical-align: inherit;">コンテキストメニューで使用すると、コンテキストメニューが無効になります（この方法は、たとえば音楽/ビデオプレーヤーやテキストエディターを作成するときなど、キーボードを再定義するためにキーダウンでよく使用されます。</font><font style="vertical-align: inherit;">event.stopPropagation（）メソッドは、イベントの伝播（アセントまたはイマージョン）を無効にします。</font></font><br>
<br>
<a name="10"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. event.preventDefault（）メソッドの使用方法を学ぶには？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、event.preventDefaultメソッドの要素へのアプリケーションのインジケーターとして機能するブール値を返すevent.defaulPreventedプロパティを使用できます。</font></font><br>
<br>
<a name="11"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. obj.someprop.xでエラーが発生するのはなぜですか？</font></font></h4><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj = {}
<span class="hljs-built_in">console</span>.log(obj.someprop.x)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
答えは明らかです。未定義のsomepropプロパティのxプロパティにアクセスしようとしています。</font><font style="vertical-align: inherit;">obj .__ proto __.__ proto = nullなので、undefinedが返され、undefinedにはxプロパティがありません。</font></font><br>
<br>
<a name="12"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12.イベントターゲットまたはターゲット要素（event.target）とは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単に言うと、event.targetは、イベントが発生する要素、またはイベントを発生させる要素です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のマークアップがあります。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"clickFunc(event)"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center; margin: 15px;
border: 1px solid red; border-radius: 3px;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border: 1px solid royalblue; border-radius: 3px;"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border: 1px solid skyblue; border-radius: 3px;"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 10px"</span>&gt;</span><font></font>
                Button<font></font>
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、そのような単純なJS：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickFunc</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(event.target)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外側のdivに「リスナー」を追加しました。</font><font style="vertical-align: inherit;">ただし、ボタンをクリックすると、コンソールにこのボタンのレイアウトが表示されます。</font><font style="vertical-align: inherit;">これにより、イベントを発生させた要素はボタン自体であり、外部または内部のdivではないと結論付けることができます。</font></font><br>
<br>
<a name="13"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13.イベント（event.currentTarget）の現在の目的は何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Event.currentTargetは、イベントリスナーが関連付けられている要素です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様のマークアップ：</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"clickFunc(event)"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center;margin:15px;
border:1px solid red;border-radius:3px;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border:1px solid royalblue;border-radius:3px;"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin:25px;border:1px solid skyblue;border-radius:3px;"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin:10px"</span>&gt;</span><font></font>
                Button<font></font>
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして少し変更されたJS：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickFunc</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(event.currentTarget)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスナーを外側のdivに接続しました。</font><font style="vertical-align: inherit;">ボタンでも内部divの1つでも、どこをクリックしても、コンソールでは常に外部divのレイアウトが表示されます。</font><font style="vertical-align: inherit;">これにより、event.currentTargetはイベントリスナーがアタッチされている要素であると結論付けることができます。</font></font><br>
<br>
<a name="14"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14.演算子「==」と「===」の違いは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演算子==（抽象または非厳密な等価）と演算子===（厳密な等価）の違いは、最初の値が1つの型（Coersion）に変換またはキャストされた後、2番目の値が比較されることです-そのような変換なし。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
深く掘り下げましょう。</font><font style="vertical-align: inherit;">まず、変革についてお話ししましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変換は、値を別のタイプにキャストするプロセス、または比較された値を1つのタイプにキャストするプロセスです。</font><font style="vertical-align: inherit;">比較する場合、演算子「==」は、いわゆる暗黙的な比較を生成します。</font><font style="vertical-align: inherit;">演算子「==」は、2つの値を比較する前にいくつかの操作を実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
xとyを比較するとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムは次のとおりです。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xとyが同じタイプの場合、比較は「===」演算子を使用して実行されます。</font></font></li>
<li> x = null  y = undefined  true.</li>
<li> x = undefined  y = null  true.</li>
<li> x = ,  y = ,  x == toNumber(y) ( y   ).</li>
<li> x = ,  y = ,  toNumber(x) == y ( x   ).</li>
<li> x =  ,  toNumber(x) == y.</li>
<li> y =  ,  x == toNumber(y).</li>
<li> x = ,   ,  y = ,  x == toPrimitive(y) ( y   ).</li>
<li> x = ,  y = ,   ,  toPrimitive(x) == y.</li>
<li> false.</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：オブジェクトを「プリミティブ」にキャストするには、最初にtoPrimitiveメソッドがvalueOfメソッドを使用し、次にtoStringメソッドを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yd/xe/tn/ydxetnfghjtfuex_p-em8v4emck.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての例でtrueが返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の例は、アルゴリズムの最初の条件です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の例は4番目の条件です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目は2番目です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4番目は7番目です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第五-第八。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後は10番目です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t-/4k/ys/t-4kyszb4grfafbi7lazyyvq6dy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「===」演算子を使用する場合、最初の例を除くすべての例はfalseを返します。これらの例の値は異なるタイプであるためです。</font></font><br>
<br>
<a name="15"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15. 2つの類似したオブジェクトを比較した結果が誤っているのはなぜですか？</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> a = {
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><font></font>
}<font></font>
<span class="hljs-keyword">let</span> b = {
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><font></font>
}<font></font>
<span class="hljs-keyword">let</span> c = a<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(a === b) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(a === c) <span class="hljs-comment">// true ...</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSでは、オブジェクトとプリミティブは異なる方法で比較されます。</font><font style="vertical-align: inherit;">プリミティブは値で比較されます。</font><font style="vertical-align: inherit;">オブジェクト-変数が格納されているメモリ内の参照またはアドレス。</font><font style="vertical-align: inherit;">これが、最初のconsole.logがfalseを返し、2番目がtrueを返す理由です。</font><font style="vertical-align: inherit;">変数「a」と「c」は同じオブジェクトを指し、変数「a」と「b」は同じプロパティと値を持つ異なるオブジェクトを指します。</font></font><br>
<br>
<a name="16"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16.演算子「!!」は何に使用されますか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オペレーター "！！" </font><font style="vertical-align: inherit;">（二重否定）は、その値を論理値に導きます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-string">''</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-string">' '</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!!{}) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!![]) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!![].length) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="17"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17. 1行に複数の式を記述する方法は？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これには、演算子 "、"（コンマ）を使用できます。</font><font style="vertical-align: inherit;">この演算子は、左から右に「移動」して、最後の式またはオペランドの値を返します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span><font></font>
<font></font>
x = (x++, x = addFive(x), x *= <span class="hljs-number">2</span>, x -= <span class="hljs-number">5</span>, x += <span class="hljs-number">10</span>)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addFive</span>(<span class="hljs-params">num</span>) </span>{
    <span class="hljs-keyword">return</span> num + <span class="hljs-number">5</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
xの値をコンソールに出力すると、27になります。最初に、xの値を1つ増やします（x = 6）。</font><font style="vertical-align: inherit;">次に、パラメーター6を指定してaddFive（）関数を呼び出し、そこに5（x = 11）を追加します。</font><font style="vertical-align: inherit;">その後、xの値に2を掛けます（x = 22）。</font><font style="vertical-align: inherit;">次に5を減算します（x = 17）。</font><font style="vertical-align: inherit;">最後に、10を加算します（x = 27）。</font></font><br>
<br>
<a name="18"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18.巻き上げとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リフトは、グローバルスコープまたは関数スコープでの変数または関数の出現を表す用語です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ホイストとは何かを理解するには、実行コンテキストとは何かを理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行コンテキストは、コードが実行される環境です。実行コンテキストには、コンパイルと実行自体の2つのフェーズがあります。</font><font style="vertical-align: inherit;">
パフォーマンス。このフェーズでは、変数に値が割り当てられ、関数（またはオブジェクトのメソッド）が呼び出されるか実行されます。</font><font style="vertical-align: inherit;">
注意：「var」キーワードを使用して宣言された関数式と変数のみが発生します。通常の関数と矢印関数、およびキーワード「let」と「const」を使用して宣言された変数は発生しません。</font><font style="vertical-align: inherit;">
次のようなコードがあるとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コンパイル。このフェーズでは、値が未定義の「var」キーワードを使用して宣言された関数式と変数が、グローバル（または関数）スコープの最上部に上昇します（コードの先頭に移動した場合と同様です。これにより、関数の前に関数を呼び出すことができる理由がわかりますお知らせ-約</font></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(y)<font></font>
y = <span class="hljs-number">1</span>
<span class="hljs-built_in">console</span>.log(y)
<span class="hljs-built_in">console</span>.log(greet(<span class="hljs-string">'Mark'</span>))<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> y
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
未定義の1と「Hello Mark！」を取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイルフェーズは次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> y <span class="hljs-comment">//  undefined</span><font></font>
<font></font>
<span class="hljs-comment">//    </span><font></font>
<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-comment">/*
console.log(y)
y = 1
console.log(y)
console.log(greet('Mark'))
*/</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイルフェーズが完了した後、変数に値が割り当てられ、関数が呼び出されると、実行フェーズが開始されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
巻き上げの詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="19"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19.スコープとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スコープは、変数または関数にアクセスできる場所（または場所）です。</font><font style="vertical-align: inherit;">JSには、グローバル、機能、およびブロック（ES6）の3つのタイプのスコープがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グローバルスコープ-グローバル名前空間で宣言された変数と関数はグローバルスコープを持ち、コードのどこからでもアクセスできます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> g = <span class="hljs-string">'global'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">globalFunc</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFunc</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(g) <span class="hljs-comment">//     g,    </span><font></font>
    }<font></font>
    innerFunc()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数スコープ（関数のスコープ）-関数内で宣言された変数、関数、およびパラメーターは、この関数内でのみ使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFavouriteFunc</span>(<span class="hljs-params">a</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> b = <span class="hljs-string">'Hello '</span> + a<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> b<font></font>
}<font></font>
myFavouriteFunc(<span class="hljs-string">'World'</span>)<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span>
<span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">//  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロックスコープ-ブロック（{}）内の変数（キーワード "let"および "const"を使用して宣言）は、その内部でのみ使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testBlock</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">let</span> z = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> z<font></font>
}<font></font>
<font></font>
testBlock() <span class="hljs-comment">// Uncaught ReferenceError: z is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スコープは、変数が検索される一連のルールでもあります。</font><font style="vertical-align: inherit;">変数が現在のスコープに存在しない場合、その検索は現在のスコープの外部可視性でより高く実行されます。</font><font style="vertical-align: inherit;">外部スコープに変数がない場合、その検索はグローバルスコープまで続行されます。</font><font style="vertical-align: inherit;">変数がグローバルスコープで見つかった場合は検索が停止し、見つからなかった場合は例外がスローされます。</font><font style="vertical-align: inherit;">検索は、現在の可視領域に最も近い場所で実行され、変数で停止します。</font><font style="vertical-align: inherit;">これはスコープチェーンと呼ばれます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-comment">//    -&gt;    -&gt;   </span><font></font>
<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> variable1 = <span class="hljs-string">'Comrades'</span>
<span class="hljs-keyword">var</span> variable2 = <span class="hljs-string">'Sayonara'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">var</span> variable1 = <span class="hljs-string">'World'</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">//   </span>
        <span class="hljs-keyword">var</span> variable2 = <span class="hljs-string">'Hello'</span>
        <span class="hljs-built_in">console</span>.log(variable2 + <span class="hljs-string">' '</span> + variable1)<font></font>
    }<font></font>
    inner()<font></font>
}<font></font>
outer()<font></font>
<span class="hljs-comment">//    'Hello World',</span>
<span class="hljs-comment">//   variable2 = 'Hello'  variable1 = 'World'  </span>
<span class="hljs-comment">//     </span>
</code></pre><br>
<img src="https://habrastorage.org/webt/r6/07/q7/r607q7hehfjmuicf0_icntddk2s.png"><br>
<br>
<a name="20"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20.クロージャー（クロージャー）とは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはおそらくリストの中で最も難しい質問です。クロージャーを理解する方法を説明しようと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、クロージャーとは、作成時に、現在のスコープ、親関数のスコープ、親関数の親のスコープなどにある変数とパラメーターへの参照を記憶し、スコープのチェーンを使用してグローバルスコープに関数を作成する機能です。通常、スコープは関数の作成時に決定されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例は、閉鎖を説明するのに最適な方法です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">'abc'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-built_in">console</span>.log(globalVar)<font></font>
}<font></font>
<font></font>
a() <span class="hljs-comment">// 'abc'</span>
<span class="hljs-comment">//   </span>
<span class="hljs-comment">//    a -&gt;   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、関数を宣言すると、グローバルスコープがクロージャの一部になります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/10/ke/qa/10keqaosrww0rntbyei1gx9f_k0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「globalVar」変数は、関数ではどこでいつ呼び出されるかによって値が変化する可能性があるため、図では重要ではありません。ただし、上記の例では、globalVarの値は「abc」になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、例はより複雑になります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">'global'</span>
<span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">'outer'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outerFunc</span>(<span class="hljs-params">outerParam</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFunc</span>(<span class="hljs-params">innerParam</span>) </span>{
        <span class="hljs-built_in">console</span>.log(globalVar, outerParam, innerParam)<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> innerFunc<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> x = outerFunc(outerVar)<font></font>
outerVar = <span class="hljs-string">'outer-2'</span>
globalVar = <span class="hljs-string">'guess'</span>
x(<span class="hljs-string">'inner'</span>)
</code></pre><br>
<img src="https://habrastorage.org/webt/ms/dv/wx/msdvwxdxp5s3l4cquxnqgkdtyr0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果は「外部アウターを推測する」です。説明はこれです。outerFunc関数を呼び出して変数「x」をinnerFunc関数から返された値に設定すると、パラメーター「outerParam」は「outer」に等しくなります。変数「outerVar」を「outer-2」に割り当てたという事実にもかかわらず、これは、スコープチェーンで変数「outerVar」の値を見つけるために「管理」されたouterFunc関数を呼び出した後に発生しました。この値は「outer」でした。 innerFuncを参照する「x」を呼び出す場合、「x」を呼び出すときにこの値をパラメーターとして渡すため、「innerParam」の値は「inner」です。 globalVarの値は「guess」です。これは、「x」を呼び出す前にその値を割り当てたためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回路の誤解の例。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> arrFunc = []
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {<font></font>
    arrFunc.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> i<font></font>
    })<font></font>
}<font></font>
<span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">// 5</span><font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arrFunc.length; i++) {
    <span class="hljs-built_in">console</span>.log(arrFunc[i]()) <span class="hljs-comment">//  5</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは期待どおりに動作しません。</font><font style="vertical-align: inherit;">varキーワードを使用して変数を宣言すると、この変数がグローバルになります。</font><font style="vertical-align: inherit;">arrFunc配列に関数を追加すると、グローバル変数「i」の値は「5」になります。</font><font style="vertical-align: inherit;">したがって、この関数を呼び出すと、グローバル変数「i」の値が返されます。</font><font style="vertical-align: inherit;">クロージャーは、作成時の値ではなく、変数への参照を格納します。</font><font style="vertical-align: inherit;">この問題は、IIFEを使用するか、「let」キーワードを使用して変数を宣言することで解決できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
閉鎖について詳しくは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="21"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21. JSのどの値が偽ですか？</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> falsyValues = [<span class="hljs-string">''</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-literal">false</span>]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
falseは、ブール値への変換がfalseである値です。</font></font><br>
<br>
<a name="22"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22.値がfalseかどうかを確認するにはどうすればよいですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブール関数または演算子「!!」を使用します </font><font style="vertical-align: inherit;">（2倍）。</font></font><br>
<br>
<a name="23"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23. use strictディレクティブは何に使用されますか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「Use strict」は、すべてのコードまたは個々の関数のコードをストリクトモードで実行することを強制するES5ディレクティブです。</font><font style="vertical-align: inherit;">厳格モードでは、コードの記述にいくつかの制限が導入され、初期段階でのエラーが回避されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
strictモードの制限は次のとおりです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値を割り当てたり、宣言されていない変数にアクセスしたりすることはできません。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnY</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-string">'use strict'</span>
    y = <span class="hljs-number">123</span>
    <span class="hljs-keyword">return</span> y<font></font>
}<font></font>
returnY() <span class="hljs-comment">// Uncaught ReferenceError: y is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グローバル値を読み取り専用または書き込み専用の変数に割り当てることは禁止されています。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">NaN</span> = <span class="hljs-literal">NaN</span> <span class="hljs-comment">// Uncaught TypeError: Cannot assign to read only property 'NaN' of object '#&lt;Window&gt;'</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">Infinity</span> = <span class="hljs-string">'and beyond'</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトの「削除できない」プロパティは削除できません。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span>
<span class="hljs-keyword">const</span> obj = {}<font></font>
<font></font>
<span class="hljs-built_in">Object</span>.defineProperties(obj, <span class="hljs-string">'x'</span>, {
    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><font></font>
})<font></font>
<font></font>
<span class="hljs-keyword">delete</span> obj.x <span class="hljs-comment">// Uncaught TypeError: Property description must be an object: x</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータの複製は禁止されています：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someFunc</span>(<span class="hljs-params">a, b, b, c</span>) </span>{} <span class="hljs-comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eval関数を使用して関数を作成することはできません。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-built_in">eval</span>(<span class="hljs-string">'var x = 1'</span>)<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(x) <span class="hljs-comment">// Uncaught ReferenceError: x is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これのデフォルト値は未定義です：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMeThis</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
}<font></font>
<font></font>
showMeThis() <span class="hljs-comment">// undefined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
…など</font></font><br>
<br>
<a name="24"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24.これはどういう意味ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは通常、現在関数を実行または呼び出しているオブジェクトの値を参照します。</font><font style="vertical-align: inherit;">「今すぐ」とは、これの値が、使用する実行コンテキストによって異なることを意味します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> carDetails = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Ford Mustang'</span>,
    <span class="hljs-attr">yearBought</span>: <span class="hljs-number">2005</span>,<font></font>
    getName() {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name<font></font>
    }<font></font>
    <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(carDetails.getName()) <span class="hljs-comment">// Ford Mustang</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、getNameメソッドはthis.nameを返し、これはgetNameが実行されるオブジェクトであるcarDetailsを参照します。これは、その「所有者」です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
console.logの後に3行追加します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Ford Ranger'</span>
<span class="hljs-keyword">var</span> getCarName = carDetails.getName<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(getCarName()) <span class="hljs-comment">// Ford Ranger</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のconsole.logはFord Rangerを生成しますが、これは奇妙です。</font><font style="vertical-align: inherit;">この動作の理由は、getCarNameの「所有者」がウィンドウオブジェクトであるためです。</font><font style="vertical-align: inherit;">グローバルスコープでvarキーワードを使用して宣言された変数は、ウィンドウオブジェクトのプロパティに書き込まれます。</font><font style="vertical-align: inherit;">これはグローバルスコープでウィンドウオブジェクトを参照します（厳密なモードでない限り）。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(getCarName === <span class="hljs-built_in">window</span>.getCarName) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(getCarName === <span class="hljs-keyword">this</span>.getCarName) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、thisとwindowは同じオブジェクトを参照しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決する1つの方法は、callメソッドまたはapplyメソッドを使用することです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(getCarName.apply(carDetails)) <span class="hljs-comment">// Ford Mustang</span>
<span class="hljs-built_in">console</span>.log(getCarName.call(carDetails)) <span class="hljs-comment">// Ford Mustang</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数内でthisの値となるオブジェクトを最初の引数として呼び出して適用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IIFEでは、グローバルスコープで作成される関数、無名関数、およびオブジェクトのメソッドの内部関数の場合、このデフォルト値はウィンドウオブジェクトです。</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)<font></font>
})() <span class="hljs-comment">// window</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iHateThis</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)<font></font>
}<font></font>
iHateThis() <span class="hljs-comment">// window</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> myFavouriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
<font></font>
myFavouriteObj.guessThis() <span class="hljs-comment">// window</span>
myFavouriteObj.thisIsAnnoying(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// window</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Marko Poloを入手するには2つの方法があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、この値を変数に格納できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myFavoriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span> <span class="hljs-comment">//   this   self</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(self.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、矢印関数を使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myFavoriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-keyword">const</span> getName = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-comment">//   this   </span>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
矢印関数にはこの固有値はありません。</font><font style="vertical-align: inherit;">彼らはこれの意味を外部の字句環境からコピーします。</font></font><br>
<br>
<a name="25"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25.オブジェクトのプロトタイプとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単に言えば、プロトタイプはオブジェクトの計画（図またはプロジェクト）です。</font><font style="vertical-align: inherit;">このオブジェクトに存在するプロパティとメソッドのフォールバックとして使用されます。</font><font style="vertical-align: inherit;">また、オブジェクト間でプロパティと機能を交換する方法の1つでもあります。</font><font style="vertical-align: inherit;">これは、JSにおけるプロトタイプ継承の基本概念です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {}
<span class="hljs-built_in">console</span>.log(o.toString()) <span class="hljs-comment">// [object Object]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「o」オブジェクトにはtoStringプロパティがありませんが、このプロパティにアクセスしてもエラーは発生しません。</font><font style="vertical-align: inherit;">特定のプロパティがオブジェクトにない場合、その検索は、最初にオブジェクトのプロトタイプで実行され、次にオブジェクトのプロトタイプのプロトタイプで、プロパティが見つかるまで繰り返されます。</font><font style="vertical-align: inherit;">これはプロトタイプチェーンと呼ばれます。</font><font style="vertical-align: inherit;">プロトタイプチェーンの先頭はObject.prototypeです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o.toString === <span class="hljs-built_in">Object</span>.prototype.toString) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロトタイプと継承の詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="26"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26. IIFEとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IIFEまたは即時に呼び出される関数式は、作成または宣言の直後に呼び出されるか実行される関数です。</font><font style="vertical-align: inherit;">IIFEを作成するには、関数を括弧（グループ化演算子）で囲み、式に変換してから、別の括弧を使用して呼び出す必要があります。</font><font style="vertical-align: inherit;">これは次のようになります：（関数（）{}）（）。</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{ }( ))<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{ })( )<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">named</span>(<span class="hljs-params">params</span>) </span>{ })( )<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-params">( )</span> =&gt;</span> { })<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">global</span>) </span>{ })(<span class="hljs-built_in">window</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> utility = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{
    <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">// </span><font></font>
    }<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの例はすべて有効です。</font><font style="vertical-align: inherit;">最後から2番目の例は、パラメーターをIIFEに渡すことができることを示しています。</font><font style="vertical-align: inherit;">最後の例は、IIFEの結果を変数に格納できることを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IIFEの最適な用途は、初期化構成機能を実行し、グローバルスコープ内の他の変数との名前の競合（グローバル名前空間の汚染）を防ぐことです。</font><font style="vertical-align: inherit;">例を挙げます。</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードで使用できるいくつかのグローバル関数を提供するsomelibrary.jsライブラリへのリンクがありますが、このライブラリにはcreateGraphとdrawGraphの2つのメソッドがあり、エラーが含まれているため使用しません。</font><font style="vertical-align: inherit;">そして、これらの機能を独自に実装したいと考えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決する1つの方法は、スクリプトの構造を変更することです。</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ライブラリによって提供されるメソッドを再定義します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の方法は、関数の名前を変更することです。</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCreateGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myDrawGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目の方法は、IIFEを使用することです。</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script&gt;
    <span class="hljs-keyword">const</span> graphUtility = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGraph</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawGraph</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> {<font></font>
            createGraph,<font></font>
            drawGraph<font></font>
        }<font></font>
    })<font></font>
&lt;/script&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、createGraphメソッドとdrawGraphメソッドを含むオブジェクトを返すIIFE結果を含むユーティリティ変数を作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、IIFEで解決できる別の問題を示します。</font></font><br>
<br>
<pre><code class="javascript hljs">val li = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.list-group &gt; li'</span>)
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i - <span class="hljs-number">0</span>, len = li.length; i &lt; len; i++) {<font></font>
    li[i].addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(i)<font></font>
    })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5つの子要素liを含むリストグループクラスを持つul要素があるとします。</font><font style="vertical-align: inherit;">また、別の「li」をクリックすると、値「i」がコンソールに表示されます。</font><font style="vertical-align: inherit;">ただし、代わりに、コンソールには常に5が表示されます。障害はすべての障害です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IIFEは1つのソリューションです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.list-group &gt; li'</span>)
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = li.length; i &lt; len; i++) {<font></font>
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentIndex</span>) </span>{<font></font>
        li[currentIndex].addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
            <span class="hljs-built_in">console</span>.log(currentIndex)<font></font>
        })<font></font>
    })(i)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードが意図したとおりに機能する理由は、IIFEが反復ごとに新しいスコープを作成し、currentIndexに値「i」を書き込むためです。</font></font><br>
<br>
<a name="27"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">27. Function.prototype.applyメソッドは何に使用されますか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Applyは、特定のオブジェクトを呼び出された関数のthis値にバインドするために使用されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello World!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMessage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message<font></font>
}<font></font>
<font></font>
getMessage.apply(details) <span class="hljs-comment">// Hello World!</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドはFunction.prototype.callに似ています。</font><font style="vertical-align: inherit;">唯一の違いは、適用では引数が配列として渡されることです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeting</span>(<span class="hljs-params">greetingMessage</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${greetingMessage}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
}<font></font>
<font></font>
greeting.apply(person, [<span class="hljs-string">'Hello'</span>]) <span class="hljs-comment">// Hello Marko Polo</span>
</code></pre><br>
<a name="28"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28. function.prototype.callメソッドは何に使用されますか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Callは、特定のオブジェクトを、呼び出されているこの関数の値にバインドするために使用されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello World!'</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMessage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message;<font></font>
}<font></font>
<font></font>
getMessage.call(details); <span class="hljs-comment">// Hello World!</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドは、Function.prototype.applyに似ています。</font><font style="vertical-align: inherit;">違いは、呼び出しでは引数がコンマで区切られて渡されることです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeting</span>(<span class="hljs-params">greetingMessage</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${greetingMessage}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span>;<font></font>
}<font></font>
<font></font>
greeting.call(person, <span class="hljs-string">'Hello'</span>); <span class="hljs-comment">// Hello Marko Polo</span>
</code></pre><br>
<a name="29"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">29. callメソッドとapplyメソッドの違いは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
callとapplyの違いは、呼び出された関数で引数を渡す方法です。</font><font style="vertical-align: inherit;">適用では、引数は、呼び出し時に、コンマで区切られた配列として渡されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj1 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> obj2 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduceAdd</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) {<font></font>
        result += <span class="hljs-built_in">arguments</span>[i]<font></font>
    }<font></font>
    <span class="hljs-keyword">this</span>.result = result<font></font>
}<font></font>
<font></font>
reduceAdd.apply(obj1, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]) <span class="hljs-comment">// 15</span>
reduceAdd.call(obj2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 15</span>
</code></pre><br>
<a name="30"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30. function.prototype.bindメソッドは何に使用されますか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bindは、この値が最初のパラメーターとして指定されたオブジェクトである新しい関数を返します。</font><font style="vertical-align: inherit;">bindとは異なり、関数を呼び出して適用するとすぐに呼び出されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props)
        <span class="hljs-keyword">this</span>.state = {
            <span class="hljs-attr">value</span>: <span class="hljs-string">''</span><font></font>
        }<font></font>
        <span class="hljs-keyword">this</span>.handleChange = <span class="hljs-keyword">this</span>.handleChange.bind(<span class="hljs-keyword">this</span>)
        <span class="hljs-comment">//   handleChange   MyComponent</span><font></font>
    }<font></font>
<font></font>
    handleChange(e) {<font></font>
        <span class="hljs-comment">// </span><font></font>
    }<font></font>
<font></font>
    render() {<font></font>
        <span class="hljs-keyword">return</span> ( &lt; &gt;<font></font>
            &lt;<font></font>
            input type = {<font></font>
                <span class="hljs-keyword">this</span>.props.type<font></font>
            }<font></font>
            value = {<font></font>
                <span class="hljs-keyword">this</span>.state.value<font></font>
            }<font></font>
            onChange = {<font></font>
                <span class="hljs-keyword">this</span>.handleChange<font></font>
            }<font></font>
            /&gt; &lt;/ &gt;<font></font>
        )<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<a name="31"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">31.関数型プログラミングとは何ですか？JSのどの機能を使用すると、関数型プログラミング言語としてそれについて話すことができますか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型プログラミングは、宣言型プログラミングの概念またはアプリケーションの構築方法の例（パターン）であり、渡される引数を変更せずに値を計算する式を含む関数がどのように使用されるかを示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arrayオブジェクトには、map、filter、reduceメソッドが含まれています。これらは、その有用性と、配列を変更しないためこれらの関数を「クリーン」にするため、関数型プログラミングの世界で最も有名な関数です。</font><font style="vertical-align: inherit;">JSには、関数型プログラミング言語の特徴であるクロージャーと高階関数もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mapメソッドは、配列の各要素のコールバック結果を含む新しい配列を返します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> words = [<span class="hljs-string">'Functional'</span>, <span class="hljs-string">'Procedural'</span>, <span class="hljs-string">'Object-Oriented'</span>]<font></font>
<font></font>
<span class="hljs-keyword">const</span> wordsLength = words.map(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.length)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
filterメソッドは、コールバックで指定された条件を満たすすべての要素を含む新しい配列を作成します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> data = {<font></font>
    {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mark'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
    } {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mary'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">false</span><font></font>
    } {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mae'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> registeredUsers = data.filter(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.isRegistered)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
reduceメソッドは、配列の各要素に対して1回コールバックを実行します。ただし、voidを除き、初期値（または前のコールバックからの値）、現在の要素の値、現在のインデックス、反復配列の4つの引数を取ります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> strs = [<span class="hljs-string">'I'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'am'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'Iron'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'Man'</span>]<font></font>
<font></font>
<span class="hljs-keyword">const</span> result = strs.reduce(<span class="hljs-function">(<span class="hljs-params">acc, currentStr</span>) =&gt;</span> acc + str, <span class="hljs-string">''</span>)
</code></pre><br>
<a name="32"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32.高次関数とは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高階関数は、別の関数を返すか、別の関数を引数として受け入れる関数です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">higherOrderFunction</span>(<span class="hljs-params">param, callback</span>) </span>{
    <span class="hljs-keyword">return</span> callback(param)<font></font>
}<font></font>
</code></pre><br>
<a name="33"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">33. JSの関数がファーストクラスオブジェクトと呼ばれるのはなぜですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は、JSの他の値と同じように処理されるため、ファーストクラスオブジェクトと呼ばれます。</font><font style="vertical-align: inherit;">それらは、変数（オブジェクト（メソッド）のプロパティ、配列の要素、別の関数の引数、関数によって返される値）に割り当てることができます。</font><font style="vertical-align: inherit;">関数とJSの他の値の唯一の違いは、関数を実行または呼び出すことができることです。</font></font><br>
<br>
<a name="34"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">34. Array.prototype.mapメソッドはどのように実装しますか？</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">arr, mapCallback</span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> mapCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">let</span> result = []
        <span class="hljs-comment">//         </span>
        <span class="hljs-comment">//       </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) {<font></font>
            result.push(mapCallback(arr[i], i, arr))<font></font>
            <span class="hljs-comment">//   mapCallback  result</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mapメソッドは、配列の各要素に対して指定された関数を呼び出した結果を持つ新しい配列を作成します。</font></font><br>
<br>
<a name="35"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">35. Array.prototype.filterメソッドをどのように実装しますか？</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span>(<span class="hljs-params">arr, filterCallback</span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> filterCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">let</span> result = []
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) {
            <span class="hljs-comment">//      </span>
            <span class="hljs-keyword">if</span> (filterCallback(arr[i], i, arr)) {
                <span class="hljs-comment">//  ,  ,  result</span><font></font>
                result.push(arr[i])<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
filterメソッドは、渡される関数で指定されたテストに合格したすべての要素を含む新しい配列を作成します。</font></font><br>
<br>
<a name="36"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">36. Array.prototype.reduceメソッドをどのように実装しますか？</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">arr, reduceCallbak, initialValue</span>) </span>{
    <span class="hljs-comment">// ..</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> filterCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//        initialValue, </span>
        <span class="hljs-keyword">let</span> hasInitialValue = initialValue !== <span class="hljs-literal">undefined</span>
        <span class="hljs-keyword">let</span> value = hasInitialValue ? initialValue : arr[<span class="hljs-number">0</span>]
        <span class="hljs-comment">//      initialValue</span><font></font>
<font></font>
        <span class="hljs-comment">//    ,   1,       initialValue,   0,    </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = hasInitialValue ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>, len = arr.length; i &lt; len; i++) {
            <span class="hljs-comment">//         reduceCallback </span><font></font>
            value = reduceCallback(value, arr[i], i, arr)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> value<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
reduceメソッドは配列の各要素に（左から右に）reducer関数を適用し、1つの結果値を返します。</font></font><br>
<br>
<a name="37"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">37.引数オブジェクトとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引数は、関数に渡される引数のコレクションです。</font><font style="vertical-align: inherit;">これは配列のようなオブジェクトで、lengthプロパティがあり、引数[i]を使用して特定の値にアクセスできますが、forEach、reduce、filter、mapメソッドはありません。</font><font style="vertical-align: inherit;">関数パラメーターの数を見つけることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Array.prototype.sliceを使用して、引数を配列に変換できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：矢印関数では、argumentsオブジェクトは機能しません。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">one</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span><font></font>
}<font></font>
<span class="hljs-keyword">const</span> two = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span><font></font>
}<font></font>
<span class="hljs-keyword">const</span> three = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">three</span>(<span class="hljs-params">{
    return arguments
}</span>)
<span class="hljs-title">const</span> <span class="hljs-title">four</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title">arguments</span>

<span class="hljs-title">four</span>(<span class="hljs-params"></span>) // <span class="hljs-title">arguments</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">defined</span>
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4つの関数を呼び出すと、ReferenceErrorが発生します。引数は定義されていません。</font><font style="vertical-align: inherit;">この問題は、restステートメントを使用して解決できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> four = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> args
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、すべてのパラメーターが自動的に配列に入れられます。</font></font><br>
<br>
<a name="38"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">38.プロトタイプを持たないオブジェクトを作成するにはどうすればよいですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはObject.createを使用して実行できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o1 = {}
<span class="hljs-built_in">console</span>.log(o1.toString) <span class="hljs-comment">// [object Object]</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> o2 = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>) <span class="hljs-comment">//      Object-create  -</span>
<span class="hljs-comment">//    -,   null</span>
<span class="hljs-built_in">console</span>.log(o2.toString) <span class="hljs-comment">// o2.toString is not a function</span>
</code></pre><br>
<a name="39"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">39.提示されたコードで、関数が呼び出されると変数bがグローバルになるのはなぜですか？</font></font></h4><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a = b = <span class="hljs-number">0</span><font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、代入演算子（ "="）の結合規則が右手であるために発生します。</font><font style="vertical-align: inherit;">値を右から左に割り当てます。</font><font style="vertical-align: inherit;">したがって、コードは次の形式になります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a = (b = <span class="hljs-number">0</span>)<font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、値「0」が宣言されていない変数「b」に割り当てられます。</font><font style="vertical-align: inherit;">JSエンジンはそれをグローバルにします。</font><font style="vertical-align: inherit;">次に、b = 0によって返される値（0）がローカル変数「a」に割り当てられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は、最初にローカル変数を宣言し、次にそれらに値を割り当てることで解決できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a, b<font></font>
    a = b = <span class="hljs-number">0</span><font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br>
<a name="40"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">40. ECMAScriptとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ECMAScriptは仕様であり、標準のスクリプトプログラミング言語であり、JSの基礎であるため、ECMAScriptへの変更はJSに反映されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ECMA-262仕様の最新バージョンは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">確認でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="41"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">41. ES6またはECMAScript2015はJSにどのような新しい機能をもたらしましたか？</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">矢印関数</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンプレート文字列。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張されたオブジェクトリテラル</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破壊（オブジェクトの破壊）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">約束（約束）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発電機</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュール</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シンボル。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロキシ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セット。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトのオプション。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">休憩してオペレーターを広げます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロックスコープ（キーワード「let」および「const」）。</font></font></li>
</ul><br>
<a name="42"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">42.キーワード「var」、「let」、「const」の違いは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
varキーワードを使用して宣言された変数はグローバルです。</font><font style="vertical-align: inherit;">つまり、コードのどこからでもアクセスできます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">if</span>(showX){
        <span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(giveMeX(<span class="hljs-literal">false</span>))
<span class="hljs-built_in">console</span>.log(giveMeX(<span class="hljs-literal">true</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のconsole.logの結果は未定義、2番目のログは5になります。グローバルスコープに出現したため、変数「x」にアクセスできます。</font><font style="vertical-align: inherit;">上記の例のコードは、次のように解釈されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">var</span> x <span class="hljs-comment">//   undefined</span>
    <span class="hljs-keyword">if</span>(showX){<font></font>
        x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値が割り当てられていない宣言された変数はデフォルトでは未定義であるため、最初のconsole.logの結果は未定義です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーワード「let」および「const」を使用して宣言された変数には、ブロックスコープがあります。</font><font style="vertical-align: inherit;">つまり、これらはブロック（{}）内でのみ使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">if</span>(showX){
        <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeY</span>(<span class="hljs-params">showY</span>)</span>{
    <span class="hljs-keyword">if</span>(showY){
        <span class="hljs-keyword">let</span> y = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> y<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
falseパラメーターを指定してこれらの関数を呼び出すと、参照エラーエラーが発生します。これは、変数 "x"および "y"がブロック外からアクセスできず、それらの値が返されない（ポップアップしない）ためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「let」と「const」の違いは、最初のケースでは変数の値を変更できること、2番目のケースでは-いいえ（定数）であるということです。</font><font style="vertical-align: inherit;">同時に、constを使用して宣言されたオブジェクトのプロパティの値を変更できますが、プロパティ自体（変数）は変更できません。</font></font><br>
<br>
<a name="43"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">43.矢印関数（矢印関数）とは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アロー関数は、JSで関数を作成する比較的新しい方法です。</font><font style="vertical-align: inherit;">アロー関数は、関数式よりも高速で読みやすい構文を持っています。</font><font style="vertical-align: inherit;">アロー関数では、「関数」という単語は省略されています。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> getCurrentDate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> getCurrentDate = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数式では、returnキーワードを使用して値を返します。</font><font style="vertical-align: inherit;">アロー関数では、これを実行しません。アロー関数は、単一の式または値を返す場合、暗黙的に値を返すためです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span> <font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> greet = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>
<span class="hljs-keyword">const</span> greet2 = name = &gt; <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アロー関数にパラメーターを渡すこともできます。</font><font style="vertical-align: inherit;">1つのパラメーターを渡す場合は、括弧で囲む必要はありません。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> getArgs = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">arguments</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> getArgs2 = <span class="hljs-function">(<span class="hljs-params">...rest</span>) =&gt;</span> rest
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
矢印関数は引数オブジェクトにアクセスできません。</font><font style="vertical-align: inherit;">したがって、最初の関数を呼び出すとエラーになります。</font><font style="vertical-align: inherit;">関数に渡されるパラメーターを取得するには、rest演算子を使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> data = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span>
    <span class="hljs-attr">nums</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<font></font>
    computeResult(){<font></font>
        <span class="hljs-comment">// this    data</span>
        <span class="hljs-keyword">const</span> addAll = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-comment">//     this   </span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nums.reduce(<span class="hljs-function">(<span class="hljs-params">total, cur</span>) =&gt;</span> total + cur, <span class="hljs-number">0</span>)<font></font>
        }<font></font>
    <span class="hljs-keyword">this</span>.result = addAll()<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<a name="44"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">44.クラスとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスは、JSでコンストラクター関数を作成する比較的新しい方法です。</font><font style="vertical-align: inherit;">これはコンストラクタ関数の構文糖衣です。</font><font style="vertical-align: inherit;">クラスは同じプロトタイプとプロトタイプ継承に基づいています。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName, lastName, age, address</span>)</span>{
    <span class="hljs-keyword">this</span>.firstName = firstName
    <span class="hljs-keyword">this</span>.lastName = lastName
    <span class="hljs-keyword">this</span>.age = age
    <span class="hljs-keyword">this</span>.address = address<font></font>
}<font></font>
<font></font>
Person.self = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
}<font></font>
<font></font>
Person.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Person]'</span><font></font>
}<font></font>
<font></font>
Person.prototype.getFullName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.lastName<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>{
    <span class="hljs-keyword">constructor</span>(firstName, lastName, age, address){
        <span class="hljs-keyword">this</span>.firstName = firstName
        <span class="hljs-keyword">this</span>.lastName = lastName
        <span class="hljs-keyword">this</span>.age = age
        <span class="hljs-keyword">this</span>.address = address<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> self(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
    }<font></font>
<font></font>
    toString(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Person]'</span><font></font>
    }<font></font>
<font></font>
    getFullName(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.firstName}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.lastName}</span>`</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドのオーバーライドと別のクラスからの継承：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
Employee.prototype = <span class="hljs-built_in">Object</span>.create(Person.prototype)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">firstName, lastName, age, address, jobTitle, yearStarted</span>)</span>{<font></font>
    Person.call(<span class="hljs-keyword">this</span>, firstName, lastName, age, address)
    <span class="hljs-keyword">this</span>.jobTitle = jobTitle
    <span class="hljs-keyword">this</span>.yearStarted = yearStarted<font></font>
}<font></font>
<font></font>
Employee.prototype.describe = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-keyword">this</span>.getFullName()}</span> and I have a position of #{this.jobTitle} and I started at <span class="hljs-subst">${<span class="hljs-keyword">this</span>.yearStarted}</span>}`</span><font></font>
}<font></font>
<font></font>
Employee.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Employee]'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{ <span class="hljs-comment">//   Person</span>
    <span class="hljs-keyword">constructor</span>(firstName, lastName, age, address, jobTitle, yearStarted){
        <span class="hljs-keyword">super</span>(firstName, lastName, age, address)
        <span class="hljs-keyword">this</span>.jobTitle = jobTitle
        <span class="hljs-keyword">this</span>.yearStarted = yearStarted<font></font>
    }<font></font>
<font></font>
    describe(){<font></font>
       <span class="hljs-keyword">return</span> <span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-keyword">this</span>.getFullName()}</span> and I have a position of #{this.jobTitle} and I started at <span class="hljs-subst">${<span class="hljs-keyword">this</span>.yearStarted}</span>}`</span> <font></font>
    }<font></font>
<font></font>
    toString(){ <span class="hljs-comment">//   toString  Person</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Employee]'</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロトタイプの使用について学ぶ方法は？</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Something</span></span>{ }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AnotherSomething</span>(<span class="hljs-params"></span>)</span>{ }<font></font>
<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">as</span> = <span class="hljs-keyword">new</span> AnotherSomething()
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Something()<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> Something) <span class="hljs-comment">// function</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> AnotherSomething) <span class="hljs-comment">// function</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">as</span>.toString()) <span class="hljs-comment">// [object Object]</span>
<span class="hljs-built_in">console</span>.log(a.toString()) <span class="hljs-comment">// [object Object]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">as</span>.toString === <span class="hljs-built_in">Object</span>.prototype.toString)
<span class="hljs-built_in">console</span>.log(a.toString === <span class="hljs-built_in">Object</span>.prototype.toString)
<span class="hljs-comment">//     true</span>
<span class="hljs-comment">// Object.prototype     </span>
<span class="hljs-comment">// Something  AnotherSomething   Object.prototype</span>
</code></pre><br>
<a name="45"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">45.テンプレートリテラルとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テンプレートリテラルは、JSで文字列を作成する比較的新しい方法です。</font><font style="vertical-align: inherit;">テンプレートリテラルは、ダブルバッククォート（ ``）を使用して作成されます：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> greet = <span class="hljs-string">'Hi I\'m Mark'</span><font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">let</span> greet = <span class="hljs-string">`Hi I'm Mark`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テンプレートリテラルでは、一重引用符をエスケープする必要はありません。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> lastWords = <span class="hljs-string">'\n'</span>
    + <span class="hljs-string">' I \n'</span>
    + <span class="hljs-string">' am \n'</span>
    + <span class="hljs-string">'Iron Man \n'</span><font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">let</span> lastWords = <span class="hljs-string">`
    I
    am
    Iron Man
`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ES6では、行にフィードするためにエスケープシーケンス「\ n」を使用する必要はありません。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>!`</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ES6では、テキストを変数と組み合わせるために文字列連結を使用する必要はありません。式$ {expr}を使用して変数の値を取得できます。</font></font><br>
<br>
<a name="46"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">46.オブジェクトの破壊とは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解体は、オブジェクトまたは配列の値を取得（取得）する比較的新しい方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のようなオブジェクトがあるとします。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> employee = {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Marko'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Polo'</span>,
    <span class="hljs-attr">position</span>: <span class="hljs-string">'Software Developer'</span>,
    <span class="hljs-attr">yearHired</span>: <span class="hljs-number">2017</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は、オブジェクトのプロパティを作成するために、各プロパティに変数を作成しました。</font><font style="vertical-align: inherit;">それは非常に退屈で非常に迷惑でした：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> firstName = employee.firstName
<span class="hljs-keyword">var</span> lastName = employee.lastName
<span class="hljs-keyword">var</span> position = employee.position
<span class="hljs-keyword">var</span> yearHired = employee.yearHired
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解体を使用すると、コードがより簡潔になり、時間がかかりません。</font><font style="vertical-align: inherit;">破壊構文は次のとおりです。受信するオブジェクトプロパティを中かっこ（{}）で囲みます。配列の場合は、角かっこ（[]）で囲みます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { firstName, lastName, position, yearHired } = employee
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数名を変更するには、「propertyName：newName」を使用します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { <span class="hljs-attr">firstName</span>: fName, <span class="hljs-attr">lastName</span>: lName, position, yearHired } = employee
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数にデフォルト値を割り当てるには、「propertyName = 'defaultValue'」を使用します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { firstName = <span class="hljs-string">'Mark'</span>, <span class="hljs-attr">lastName</span>: lName, position, yearHired } = employee
</code></pre><br>
<a name="47"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">47.モジュールとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールを使用すると、さまざまなファイルのコードを結合（使用）でき、すべてのコードを1つの大きなファイルに保存する必要がなくなります。</font><font style="vertical-align: inherit;">JSにモジュールが登場する前は、コードをサポートするための2つの一般的なモジュールシステムがありました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CommonJS-Nodejs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD（AsyncronousModuleDefinition）-ブラウザ</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールの構文は非常に単純です。インポートを使用して、機能または値を別のファイルからインポートし、エクスポートしてエクスポートします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能を別のファイルにエクスポートする（exportという名前）：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - helpers.js</span>
exports.isNull = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
}<font></font>
<font></font>
exports.isUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
}<font></font>
<font></font>
exports.isNullOrUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> exports.isNull(val) || exports.isUndefined(val)<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNull</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUndefined</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNullOrUndefined</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-keyword">return</span> isNull(val) || isUndefined(val);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能を別のファイルにインポートします。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-keyword">const</span> helpers = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)
<span class="hljs-keyword">const</span> isNull = helpers.isNull
<span class="hljs-keyword">const</span> isUndefined = helpers.isUndefined
<span class="hljs-keyword">const</span> isNullOrUndefined = helpers.isNullOrUndefined<font></font>
<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> { isNull, isUndefined, isNullOrUndefined } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> helpers <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span> <span class="hljs-comment">// helpers -  </span><font></font>
<font></font>
<span class="hljs-comment">// </span>
<span class="hljs-keyword">import</span> { isNull, isUndefined, isNullOrUndefined <span class="hljs-keyword">as</span> isValid} <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span> <span class="hljs-comment">//  "as"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトのエクスポート：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helpers</span> </span>{
    <span class="hljs-keyword">static</span> isNull(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isUndefined(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isNullOrUndefined(val){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNull(val) || <span class="hljs-keyword">this</span>.isUndefined(val)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">module</span>.exports = Helpers<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helpers</span> </span>{
    <span class="hljs-keyword">static</span> isNull(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isUndefined(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isNullOrUndefined(val){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNull(val) || <span class="hljs-keyword">this</span>.isUndefined(val)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Helpers
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インポート：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-keyword">const</span> Helpers = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)
<span class="hljs-built_in">console</span>.log(Helpers.isNull(<span class="hljs-literal">null</span>))<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">import</span> Helpers <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span>
<span class="hljs-built_in">console</span>.log(Helpers.isNull(<span class="hljs-literal">null</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがモジュールの基本的な使い方です。</font><font style="vertical-align: inherit;">私の投稿はすでに大きすぎるため、詳細には触れませんでした。</font></font><br>
<br>
<a name="48"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">48. Setオブジェクトとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setオブジェクトを使用すると、一意の値、プリミティブ、およびオブジェクト参照を保存できます。</font><font style="vertical-align: inherit;">繰り返しますが、セットに追加できるのは一意の値のみです。</font><font style="vertical-align: inherit;">SameZeroValueアルゴリズムを使用して、そこに格納されている値をチェックします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setインスタンスは、Setコンストラクターを使用して作成されます。</font><font style="vertical-align: inherit;">作成時にいくつかの値を渡すこともできます：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()
<span class="hljs-keyword">const</span> set2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>]) <span class="hljs-comment">//  "d"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
addメソッドを使用してSetに値を追加できます。</font><font style="vertical-align: inherit;">addメソッドは戻り可能であるため、一連の呼び出しを使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs">set2.add(<span class="hljs-string">'f'</span>)<font></font>
set2.add(<span class="hljs-string">'g'</span>).add(<span class="hljs-string">'h'</span>).add(<span class="hljs-string">'i'</span>).add(<span class="hljs-string">'j'</span>).add(<span class="hljs-string">'k'</span>).add(<span class="hljs-string">'k'</span>) <span class="hljs-comment">//  "k"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
deleteメソッドを使用して、Setから値を削除できます。</font></font><br>
<br>
<pre><code class="javascript hljs">set2.delete(<span class="hljs-string">'k'</span>) <span class="hljs-comment">// true</span>
set2.delete(<span class="hljs-string">'z'</span>) <span class="hljs-comment">// false,    set2   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
hasメソッドを使用して、Setのプロパティを確認できます。</font></font><br>
<br>
<pre><code class="javascript hljs">set2.has(<span class="hljs-string">'a'</span>) <span class="hljs-comment">// true</span>
set2.has(<span class="hljs-string">'z'</span>) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setの長さを取得するには、sizeメソッドを使用します。</font></font><br>
<br>
<pre><code class="javascript hljs">set2.size <span class="hljs-comment">// 10</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
clearメソッドはSetをクリアします。</font></font><br>
<br>
<pre><code class="javascript hljs">set2.clear() <span class="hljs-comment">// </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setを使用して、配列内の重複する値を削除できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>]
<span class="hljs-keyword">const</span> uniqNums = [...new <span class="hljs-built_in">Set</span>(nums)] <span class="hljs-comment">// [1,2,3,4,5,6,7,8]</span>
</code></pre><br>
<a name="49"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">49.コールバック関数とは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コールバック関数は、その呼び出しが将来に延期される関数です（イベントが発生したときなど、特定の条件下で発生します）。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> btnAdd = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btnAdd'</span>)<font></font>
<font></font>
btnAdd.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickCallback</span>(<span class="hljs-params">e</span>))</span>{
    <span class="hljs-comment">//   </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、識別子「btnAdd」を持つ要素の「クリック」イベントを待機しています。</font><font style="vertical-align: inherit;">クリックすると、clickCallback関数が呼び出されます。</font><font style="vertical-align: inherit;">コールバック関数は、データまたはイベントにいくつかの機能を追加します。</font><font style="vertical-align: inherit;">reduce、filter、mapメソッドには、2番目の引数としてコールバック関数が渡されます。</font><font style="vertical-align: inherit;">コールバックの良い例えは、次の状況です。あなたが誰かに電話をかけ、彼は答えず、あなたは彼にメッセージを残して、彼が電話をかけるのを待ちます。</font><font style="vertical-align: inherit;">コールまたはメッセージはイベントまたはデータであり、コールバックはリターンコールの期待（期待）です。</font></font><br>
<br>
<a name="50"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50.約束とは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロミスは、JSで非同期コードを操作する1つの方法です。</font><font style="vertical-align: inherit;">非同期操作の結果を返します。</font><font style="vertical-align: inherit;">いわゆるコールバック関数の地獄の問題を解決するための約束が発明されました。</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'somefile.txt'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, data</span>)</span>{
    <span class="hljs-keyword">if</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの問題は、最初の（最初の内部）に別の非同期操作を追加し、次に別の非同期操作を追加する必要がある場合に始まります。</font><font style="vertical-align: inherit;">その結果、乱雑で読みにくいコードが生成されます。</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'somefile.txt'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e,data</span>)</span>{
    <span class="hljs-comment">// </span>
    fs.readFile(<span class="hljs-string">'directory'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, files</span>)</span>{
        <span class="hljs-comment">// </span>
        fs.mkdir(<span class="hljs-string">'directory'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{
            <span class="hljs-comment">// </span><font></font>
        })<font></font>
    })<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これはそれが約束でどのように見えるかです：</font></font><br>
<br>
<pre><code class="javascript hljs">promReadFile(<span class="hljs-string">'file/path'</span>)<font></font>
.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> promReaddir(<span class="hljs-string">'directory'</span>)<font></font>
})<font></font>
.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> promMkdir(<span class="hljs-string">'directory'</span>)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.error(e)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promiseには4つの条件があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待機は、約束の初期状態です。</font><font style="vertical-align: inherit;">操作が完了していないため、プロミスの結果は不明です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完了-非同期操作が完了しました。結果があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拒否されました-非同期操作が失敗しました、理由があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完了-完了または拒否されました。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promiseコンストラクターは、解決と拒否をパラメーターとして受け入れます。</font><font style="vertical-align: inherit;">解決策として、操作の結果は拒否され、操作の失敗の理由が記録されます。</font><font style="vertical-align: inherit;">結果は.thenメソッドで処理でき、エラーは.catchメソッドで処理できます。</font><font style="vertical-align: inherit;">.thenメソッドもpromiseを返すため、複数の.thenからなるチェーンを使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromiseAsync = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<font></font>
        doSomeAsync(...args, (error, data) =&gt; {<font></font>
            <span class="hljs-keyword">if</span>(error){<font></font>
                reject(error)<font></font>
            } <span class="hljs-keyword">else</span>{<font></font>
                resolve(data)<font></font>
            }<font></font>
        })<font></font>
    })<font></font>
}<font></font>
<font></font>
myPromiseAsync()<font></font>
.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(result)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.error(reason)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヘルパー関数を作成して、非同期操作をコールバックからpromiseに変換できます。</font><font style="vertical-align: inherit;">Node.jsのutilのように機能します（「約束」）。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> toPromise = <span class="hljs-function">(<span class="hljs-params">asyncFuncWithCallback</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> {<font></font>
            asyncFuncWithCallback(...args, (e, result) =&gt; {<font></font>
                <span class="hljs-keyword">return</span> e ? rej(e) : res(result)<font></font>
            })<font></font>
        })<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> promiseReadFile = toPromise(fs.readFile)<font></font>
<font></font>
promiseReadFile(<span class="hljs-string">'file/path'</span>)<font></font>
.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(e))
</code></pre><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
約束についてもっと読むことができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="51"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">51.非同期/待機とは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / awaitは、JSで非同期（非ブロッキング）コードを記述する比較的新しい方法です。</font><font style="vertical-align: inherit;">彼らは約束に包まれています。</font><font style="vertical-align: inherit;">これにより、promiseやコールバック関数よりもコードが読みやすく、クリーンになります。</font><font style="vertical-align: inherit;">ただし、非同期/待機を使用するには、約束をよく理解する必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callApi</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">'url/to/api/endpoint'</span>)<font></font>
    .then(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> resp.json())<font></font>
    .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-comment">//   </span>
    }).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
        <span class="hljs-comment">//   </span><font></font>
    })<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// async/await</span>
<span class="hljs-comment">//     try/catch</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callApi</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> resp = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'url/to/api/endpoint'</span>)
        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.json()
        <span class="hljs-comment">//   </span>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-comment">//   </span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覚えておいてください：関数がpromiseを強制的に返す前にasyncキーワードを使用します：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> giveMeOne = <span class="hljs-keyword">async</span> () = <span class="hljs-number">1</span><font></font>
<font></font>
giveMeOne()<font></font>
.then(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(num) <span class="hljs-comment">// 1</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
awaitキーワードは、非同期関数内でのみ使用できます。</font><font style="vertical-align: inherit;">別の関数内でawaitを使用すると、エラーが発生します。</font><font style="vertical-align: inherit;">Awaitは、次のコード行を実行する前に、式が終了して値を返すのを待ちます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> giveMeOne = <span class="hljs-keyword">async</span>() =&gt; <span class="hljs-number">1</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOne</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> num = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-built_in">console</span>.log(num)<font></font>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
}<font></font>
<span class="hljs-comment">// Uncaught SyntaxError: await is only valid in an async function</span><font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTwo</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> num1 = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-keyword">const</span> nm2 = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-keyword">return</span> num1 + num2<font></font>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">await</span> getTwo() <span class="hljs-comment">// 2</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
async / awaitの詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="52"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">52.スプレッド演算子とレスト演算子の違いは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
spread文とrest文の構文は同じです（ "..."）。</font><font style="vertical-align: inherit;">違いは、spreadを使用して配列のデータを他のデータに転送または拡散し、restを使用して関数のすべてのパラメーターを取得して配列に配置する（またはパラメーターの一部を抽出する）ことです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>)</span>{
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> nums = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
<span class="hljs-keyword">const</span> sum = add(...nums)
<span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">// 11</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、nums配列データを使用してadd関数を呼び出すときに、spreadを使用します。</font><font style="vertical-align: inherit;">変数「a」の値は5、b = 6、合計= 11になります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">...rest</span>)</span>{
    <span class="hljs-keyword">return</span> rest.reduce(<span class="hljs-function">(<span class="hljs-params">total, current</span>) =&gt;</span> total + current)<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// 3</span>
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment">// 15</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、任意の数の引数を指定してadd関数を呼び出します。</font><font style="vertical-align: inherit;">Addは、これらの引数の合計を返します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> [first, ...others] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-built_in">console</span>.log(first) <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.log(others) <span class="hljs-comment">// [2, 3, 4, 5]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、restを使用して、最初のパラメーターを除く任意の数のパラメーターを他の配列に配置しています。</font></font><br>
<br>
<a name="53"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">53.デフォルトのパラメーターは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、デフォルトの変数値を定義する比較的新しい方法です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>{<font></font>
    a = a || <span class="hljs-number">0</span>
    b = b || <span class="hljs-number">0</span>
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span></span>)</span>{
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<span class="hljs-comment">//      "a"  "b" - ,    0</span>
add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは破壊を使用することができます：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFirst</span>(<span class="hljs-params">[first, ...rest] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span>)</span>{
    <span class="hljs-keyword">return</span> first<font></font>
}<font></font>
<font></font>
getFirst() <span class="hljs-comment">// 0</span>
getFirst([<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]) <span class="hljs-comment">// 10</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArr</span>(<span class="hljs-params">{ nums } = { nums: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] }</span>)</span>{
    <span class="hljs-keyword">return</span> nums<font></font>
}<font></font>
<font></font>
getArr <span class="hljs-comment">// [1,2,3,4]</span>
getArr({<span class="hljs-attr">nums</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]}) <span class="hljs-comment">// [5,4,3,2,1]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ場所で宣言されているデフォルトのパラメーターを使用することもできます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomethingWithValue</span>(<span class="hljs-params">value = <span class="hljs-string">'Hello World'</span>, callback = (</span>) =&gt; </span>{ <span class="hljs-built_in">console</span>.log(value) }){<font></font>
    callback()<font></font>
}<font></font>
doSomethingWithValue() <span class="hljs-comment">// Hello World</span>
</code></pre><br>
<a name="54"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">54.オブジェクトラッパー（ラッパーオブジェクト）とは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリミティブstring、number、およびbooleanには、オブジェクトではないにもかかわらず、プロパティとメソッドがあります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> name = <span class="hljs-string">'marko'</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> name) <span class="hljs-comment">// string</span>
<span class="hljs-built_in">console</span>.log(name.toUpperCase()) <span class="hljs-comment">// MARKO</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前は、プロパティとメソッドを持たない文字列（プリミティブ型）ですが、toUpperCase（）メソッドを呼び出すと、エラーではなく「MARKO」が発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この動作の理由は、名前が一時的にオブジェクトに変換されるためです。</font><font style="vertical-align: inherit;">nullと未定義を除く各プリミティブには、ラッパーオブジェクトがあります。</font><font style="vertical-align: inherit;">そのようなオブジェクトは、String、Number、Boolean、Symbol、およびBigIntです。</font><font style="vertical-align: inherit;">この場合、コードは次の形式を取ります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(name).toUpperCase()) <span class="hljs-comment">// MARKO</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一時オブジェクトは、プロパティまたはメソッドでの作業が完了すると破棄されます。</font></font><br>
<br>
<a name="55"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">55. ImplicitとExplicit Coercionの違いは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗黙的な変換は、私たちの知識（参加）なしで値を別の型にキャストする方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のものがあるとします。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-string">'6'</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> + <span class="hljs-literal">true</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span> * <span class="hljs-string">'2'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のconsole.logの結果は16になります。他の言語では、これはエラーになりますが、JS 1では文字列に変換され、6から連結（添付）されます。何もしなかったため、変換は自動的に行われました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のconsole.logの結果は1になります。Falseは0に、trueは1に変換されます。0+ 1 = </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1。3番目のconsole.logの結果は12になります。2行目は6を掛ける前に数値に</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変換</font><font style="vertical-align: inherit;">されました。</font><font style="vertical-align: inherit;">明示的な変換は、値を別の型にキャストする：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'6'</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、parseIntを使用して文字列6を数値にキャストし、2つの数値を加算して7を取得します。</font></font><br>
<br>
<a name="56"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">56. NaNとは何ですか？</font><font style="vertical-align: inherit;">値がNaNかどうかを確認するにはどうすればよいですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NaNまたは非数（非数）は、非数値に対して数値演算を実行した結果として得られる値です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> a<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'abc'</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-literal">null</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-literal">undefined</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(++a))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>({} * <span class="hljs-number">10</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'abc'</span> - <span class="hljs-number">2</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0</span> / <span class="hljs-number">0</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'10a'</span> * <span class="hljs-number">10</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSには、値がNaNであるかどうかを確認できるisNaNメソッドが組み込まれていますが、非常に奇妙な動作をします。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>()) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>({})) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">'a'</span>))) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { })) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どの値もNaNではないという事実にもかかわらず、すべてのconsole.logの結果はtrueです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ES6では、Number.isNaNメソッドを使用して、値がNaNかどうかを確認することをお勧めします。</font><font style="vertical-align: inherit;">「NaN不等式自体」の問題を解決するための補助関数を作成することもできます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkIsNan</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> value !== value<font></font>
}<font></font>
</code></pre><br>
<a name="57"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">57.値が配列かどうかを確認する方法は？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、Array.isArrayメソッドを使用します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-number">5</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-string">''</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray()) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray( {<span class="hljs-attr">length</span>: <span class="hljs-number">5</span> })) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray([])) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業している環境がこの方法をサポートしていない場合は、次のポリファイルを使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(value) === <span class="hljs-string">'[object Array]'</span><font></font>
}<font></font>
</code></pre><br>
<a name="58"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">58.剰余除算や剰余付き除算（演算子 "％"）を使用せずに、数値が偶数であることを確認するにはどうすればよいですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するには、演算子 "＆"（バイナリーand）を使用できます。</font><font style="vertical-align: inherit;">＆演算子は、オペランドをバイナリ値として比較します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">num</span>)</span>{
    <span class="hljs-keyword">if</span>(num &amp; <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    } <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2進数で0 000 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 -これは001で</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2から010 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3から011 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4から100 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5から101 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6から110 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7から111 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、等 </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y8/zo/m2/y8zom220osynreetfh8fp-dkuog.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Console.log（5＆1）は1を返します。最初に、＆演算子は両方の数値をバイナリ値に変換します。5は101に、1は001に変換されます。次にビットごとの比較が行われます：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vy/4k/em/vy4kemefvzxgjlwdp3dmsh64ae8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1と0を比較して、0を取得します。0と0を</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較します。 、0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を取得します。1と1を比較し、1を取得します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリ値を整数に変換する</font><font style="vertical-align: inherit;">と、1を取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この情報が複雑すぎる場合は、再帰関数を使用して問題を解決できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">num</span>)</span>{
    <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span> || num === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    <span class="hljs-keyword">return</span> isEven(num - <span class="hljs-number">2</span>)<font></font>
}<font></font>
</code></pre><br>
<a name="59"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59.オブジェクト内のプロパティの存在を確認する方法は？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これには3つの方法があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の方法は、in演算子を使用することです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {
    <span class="hljs-string">'prop'</span>: <span class="hljs-string">'bwahahah'</span>,
    <span class="hljs-string">'prop2'</span>: <span class="hljs-string">'hweasa'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop1'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つ目は、hasOwnPropertyメソッドを使用することです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop2'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop1'</span>)) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目は、配列のインデックス表記です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o[<span class="hljs-string">'prop'</span>]) <span class="hljs-comment">// bwahahah</span>
<span class="hljs-built_in">console</span>.log(o[<span class="hljs-string">'prop1'</span>]) <span class="hljs-comment">// undefined</span>
</code></pre><br>
<a name="60"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">60. AJAXとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AJAXまたは非同期JavaScriptおよびXMLは、非同期モードでデータを操作できるようにする相互接続されたテクノロジーのセットです。</font><font style="vertical-align: inherit;">これは、Webページをリロードすることなく、サーバーにデータを送信し、サーバーからデータを受信できることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AJAXは次のテクノロジーを使用します：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTML-Webページ構造。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSS-Webページのスタイル。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript-ページの動作とDOMとの連携。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XMLHttpRequest API-サーバーとのデータの送受信 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP、Python、Nodejs-ある種のサーバー言語。</font></font><br>
<br>
<a name="61"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61. JSでオブジェクトを作成するには？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトリテラル：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Mark'</span>,<font></font>
    greeting(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
    }<font></font>
}<font></font>
<font></font>
o.greeting <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンストラクター関数：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">this</span>.name = name<font></font>
}<font></font>
<font></font>
Person.prototype.greeting = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> mark = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Mark'</span>)<font></font>
<font></font>
mark.greeting() <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Object.createメソッド：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> n = {<font></font>
    greeting(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> o = <span class="hljs-built_in">Object</span>.create(n)<font></font>
<font></font>
o.name = <span class="hljs-string">'Mark'</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(o.greeting) <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br>
<a name="62"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">62. Object.freezeメソッドとObject.sealメソッドの違いは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
違いは、Object.freezeメソッドを使用する場合、オブジェクトのプロパティを変更または編集できないことと、Object.sealを使用する場合、そのような機会があることです。</font></font><br>
<br>
<a name="63"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63. in演算子とhasOwnPropertyメソッドの違いは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
違いは、「in」演算子は、オブジェクト自体だけでなく、そのプロトタイプにも、hasOwnPropertyメソッド（オブジェクト内のみ）にもプロパティが存在するかどうかをチェックすることです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'toString'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'toString'</span>)) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="64"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64. JSで非同期コードを操作するためのどのようなテクニックを知っていますか？</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバック</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">約束（約束）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期/待機します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async.js、blueprint、q、coなどのライブラリ。</font></font></li>
</ul><br>
<a name="65"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65.通常の関数と関数式の違いは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のものがあるとします。</font></font><br>
<br>
<pre><code class="javascript hljs">hoistedFunc()<font></font>
notHoistedFunc()<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hoistedFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I am hoisted'</span>)<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> notHoistedFunc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I will not be hoisted!'</span>)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
notHoistedFuncの呼び出しはエラーになりますが、hoistedFuncの呼び出しはグローバルスコープに上昇しますが、notHoistedFuncは上昇しません。</font></font><br>
<br>
<a name="66"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">66. JSで関数を呼び出す方法は？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSでは、関数を呼び出す方法が4つあります。</font><font style="vertical-align: inherit;">呼び出しは、この値または関数の「所有者」を定義します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数として呼び出します。</font><font style="vertical-align: inherit;">関数がメソッド、コンストラクターとして呼び出されるか、applyメソッドまたはcallメソッドを使用して呼び出される場合、関数は関数として呼び出されます。</font><font style="vertical-align: inherit;">このような関数の所有者はウィンドウオブジェクトです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
add(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">// window, 6</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> o = {<font></font>
    method(callback){<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
<font></font>
o.method(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// window</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドとして呼び出す。</font><font style="vertical-align: inherit;">関数がオブジェクトのプロパティである場合、それをメソッドと呼びます。</font><font style="vertical-align: inherit;">メソッドが呼び出されると、thisオブジェクトがこのメソッドのオブジェクトになります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko'</span>,<font></font>
    getName(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name<font></font>
    }<font></font>
}<font></font>
<font></font>
details.getName() <span class="hljs-comment">// Marko,  this   details</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンストラクタとして呼び出します。</font><font style="vertical-align: inherit;">「new」キーワードを使用して関数を呼び出す場合、その関数をコンストラクターと呼びます。</font><font style="vertical-align: inherit;">これにより、次の値である空のオブジェクトが作成されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">name, position, yearHired</span>)</span>{
    <span class="hljs-comment">//   ,   this</span>
    <span class="hljs-comment">// this = {}</span>
    <span class="hljs-keyword">this</span>.name = name
    <span class="hljs-keyword">this</span>.position = position
    <span class="hljs-keyword">this</span>.yearHired = yearHired
    <span class="hljs-comment">//   Employee.prototype   this,    </span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> emp = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">'Marko Polo'</span>, <span class="hljs-string">'Software Development'</span>, <span class="hljs-number">2017</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
applyメソッドまたはcallメソッドを使用した呼び出し。</font><font style="vertical-align: inherit;">thisまたは関数の所有者の値を明示的に決定する場合は、これらのメソッドを使用します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj1 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> obj2 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduceAdd</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++){<font></font>
        result += <span class="hljs-built_in">arguments</span>[i]<font></font>
    }<font></font>
    <span class="hljs-keyword">this</span>.result = result<font></font>
}<font></font>
<font></font>
reduceAdd.apply(obj1, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment">//  this  obj1</span>
reduceAdd.call(obj2, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//  this  obj2</span>
</code></pre><br>
<a name="67"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67.暗記またはメモ化とは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモ化は、以前に計算された結果や値を記憶できる関数を作成する手法です。</font><font style="vertical-align: inherit;">メモ化の利点は、同じ引数で関数を再実行しないことです。</font><font style="vertical-align: inherit;">欠点は、結果を保存するために追加のメモリを割り当てる必要があることです。</font></font><br>
<br>
<a name="68"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68.暗記の補助機能をどのように実装しますか？</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params">fn</span>)</span>{
    <span class="hljs-keyword">const</span> cache = {}
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">param</span>)</span>{
        <span class="hljs-keyword">if</span>(cache[param]){
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'cached'</span>)
            <span class="hljs-keyword">return</span> cache[param]<font></font>
        } <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">let</span> result = fn(param)<font></font>
            cache[param] = result<font></font>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'not cached'</span>)
            <span class="hljs-keyword">return</span> result<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> toUpper = <span class="hljs-function">(<span class="hljs-params">str = <span class="hljs-string">''</span></span>) =&gt;</span> str.toUpperCase()<font></font>
<font></font>
<span class="hljs-keyword">const</span> toUpperMemoized = memoize(toUpper)<font></font>
<font></font>
toUpperMemoized(<span class="hljs-string">'abcdef'</span>)<font></font>
toUpperMemoized(<span class="hljs-string">'abcdef'</span>) <span class="hljs-comment">//  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモ化関数を1つの引数で実装しました。</font><font style="vertical-align: inherit;">それを「マルチ引数」にしましょう：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> slice = <span class="hljs-built_in">Array</span>.prototype.slice
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params">fn</span>)</span>{
    <span class="hljs-keyword">const</span> cache = {}
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> params = slice.call(args)
        <span class="hljs-built_in">console</span>.log(params)
        <span class="hljs-keyword">if</span>(cache[params]){
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'cached'</span>)
            <span class="hljs-keyword">return</span> cache[params]<font></font>
        } <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">let</span> result = fn(...args)<font></font>
            cache[params] = result<font></font>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'not cached'</span>)
            <span class="hljs-keyword">return</span> result<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<span class="hljs-keyword">const</span> makeFullName = <span class="hljs-function">(<span class="hljs-params">fName, lName</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${fName}</span> <span class="hljs-subst">${lName}</span>`</span>
<span class="hljs-keyword">const</span> reduceAdd = <span class="hljs-function">(<span class="hljs-params">numbers, startValue = <span class="hljs-number">0</span></span>) =&gt;</span> numbers.reduce(<span class="hljs-function">(<span class="hljs-params">total, cur</span>) =&gt;</span> total + cur, startValue)<font></font>
<font></font>
<span class="hljs-keyword">const</span> memoizedFullName = memoize(makeFullName)
<span class="hljs-keyword">const</span> memoizeReduceAdd = memoize(reduceAdd)<font></font>
<font></font>
memoizedFullName(<span class="hljs-string">'Marko'</span>, <span class="hljs-string">'Polo'</span>)<font></font>
memoizedFullName(<span class="hljs-string">'Marko'</span>, <span class="hljs-string">'Polo'</span>) <span class="hljs-comment">//  </span><font></font>
<font></font>
memoizeReduceAdd([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<span class="hljs-number">5</span>)<font></font>
memoizeReduceAdd([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<span class="hljs-number">5</span>) <span class="hljs-comment">//  </span>
</code></pre><br>
<a name="69"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69. typeof nullがオブジェクトを返す理由 </font><font style="vertical-align: inherit;">値がnullかどうかを確認するにはどうすればよいですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
typeof null == 'object'は、歴史的な理由から常にtrueを返します。</font><font style="vertical-align: inherit;">typeof null = 'object'をtypeof null = 'null'に変更することでこのエラーを修正する提案がありましたが、下位互換性を維持するために拒否されました（このような変更は多数のエラーを伴います）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値がnullかどうかを確認するには、厳密な等価演算子（===）を使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNull</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> value === <span class="hljs-literal">null</span><font></font>
}<font></font>
</code></pre><br>
<a name="70"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70.「新しい」キーワードは何に使用されますか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーワード「new」は、コンストラクター関数で新しいオブジェクト（クラスの新しいインスタンス）を作成するために使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のようなコードがあるとします。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">name, position, yearHired</span>)</span>{
    <span class="hljs-keyword">this</span>.name = name
    <span class="hljs-keyword">this</span>.position = position
    <span class="hljs-keyword">this</span>.yearHired = yearHired<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> emp = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">'Marko Polo'</span>, <span class="hljs-string">'Software Development'</span>, <span class="hljs-number">2017</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーワード「新しい」は4つのことを行います。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空のオブジェクトを作成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this値をそれにバインドします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数はfunctionName.prototypeを継承します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特に指定のない限り、これを返します。</font></font></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja486804/index.html">グローバルヘルスインフォマティクス：クラウドテクノロジー</a></li>
<li><a href="../ja486808/index.html">薬局の電子妊娠検査：仕組み</a></li>
<li><a href="../ja486810/index.html">新しいOdnoklassnikiフロントエンド：ReactをJavaで起動します。パートII</a></li>
<li><a href="../ja486814/index.html">Zabbix：ネットワークトポロジは明確で自動</a></li>
<li><a href="../ja486818/index.html">QuakeをiPod Classicに移植する</a></li>
<li><a href="../ja486822/index.html">[ドックで]フラッター。パート4. Web開発者向け</a></li>
<li><a href="../ja486824/index.html">ANTLRを使用する際の悪いアドバイス</a></li>
<li><a href="../ja486826/index.html">Django 2とViber REST APIで本格的なViberbotを作成します。パート1-Webhook</a></li>
<li><a href="../ja486828/index.html">フードデザインダイジェスト、2020年1月</a></li>
<li><a href="../ja486832/index.html">タイガは何年ですか-わかりません</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>