<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍚 👬 🚣🏿 数字不朽-同步互联网 🤷🏻 👩‍⚕️ 🥕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我建议继续上一篇文章（https://habr.com/en/post/489068/）中开始的主题。如果事实上，如果她沉迷于那种在20XX年出现技术奇异性和数字永生性时一切都会好起来（或严重取决于人的类型）的梦想，那么在本篇及后续文章中，我将尽一切可能确保美好的未来（奇异性）来得更快，即为第五代处...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>数字不朽-同步互联网</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491632/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我建议继续上一篇文章（https://habr.com/en/post/489068/）中开始的主题。如果事实上，如果她沉迷于那种在20XX年出现技术奇异性和数字永生性时一切都会好起来（或严重取决于人的类型）的梦想，那么在本篇及后续文章中，我将尽一切可能确保美好的未来（奇异性）来得更快，即为第五代处理器创建一个计算范例（请记住有两行有关此内容）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将使用“版权”并将创建的计算范例命名为“ Rutel”。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们尝试弄清楚：真的需要一种全新的东西，还是可以让老人冯·诺依曼“萨满化”并且足够？</font><font style="vertical-align: inherit;">日本人正处于大火中：他们试图制造新的体系结构和并行处理器时，传统串行处理器的生产技术得到了改善。</font><font style="vertical-align: inherit;">它们已经进行了很大的改进，以至于可以实现常规串行上并行处理器的所有预期参数。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">许多原因，目前</font><b><font style="vertical-align: inherit;">重复发生这种情况的可能性</font></b><font style="vertical-align: inherit;">很低：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现有的体系结构积压工作已经用尽（Lebedev等人的工作）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">晶体管的尺寸已经可以与分子相媲美了。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">散热实际上不会随着技术标准的降低而下降；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加处理器频率不会提高性能。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
计算机技术的开发人员没有任何想法，除了计算机系统中内核数量的平庸增加。</font><font style="vertical-align: inherit;">我认为，这种方法对于不基于“并行计算”概念的系统没有效果。</font><font style="vertical-align: inherit;">而且，人（程序员）的逻辑（顺序）思维也不会因并行性而发光。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
给定已发现的问题，让我们定义</font><font style="vertical-align: inherit;">当前对有前途的计算系统提出</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并行性</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决复杂性问题。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">容错能力。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以根据需要创建任何设备。现代计算机技术是为应对大量科学和工程计算的需求而创建的。当前，计算机技术的主要用途是各种虚拟模型的“计算”，“振兴”，其中一些是来自真实物理世界的对象的简化模型，其他通常是完全虚拟的，并且同时通过各种接口与外界交互。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个人的个性向这种系统的转移也是现代的需要。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
冯·诺依曼（Von Neumann）的计算范例本质上是足够先进和强大的，但仍然是一个计算器。现代计算技术的基础是对人的逻辑思维的“模仿”（注意：仅是逻辑思维，而不是整个大脑的结构），但这并不是要模拟周围的世界。一个人的逻辑思维是一个高级的心理过程，并且在根本上是一致的。考虑一下这句话：一种编程语言。编程语言是与计算机系统进行交互的基础，在逻辑上与人体的一部分相连，并继承了其许多功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，尝试同时说两个短语。是的，并且不能同时收听两个人（尤其是声音相似的声音）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主要任务</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，应该承担维护或“激活”虚拟世界对象的任务。</font><font style="vertical-align: inherit;">虚拟世界既包含现实世界中的对象模型，也包括通过各种传感器和操纵器进行连接的对象模型，以及其中没有类似物的模型。</font><font style="vertical-align: inherit;">在极限情况下，不应将“新的计算范式”视为解决当前问题的另一种工具，而应将其视为我们物理世界的一组附加维度。</font><font style="vertical-align: inherit;">我想指出，一个人（作为一个整体）是一个生物系统，可以解决完全相同的问题；因此，要转移一个人的个性，将需要一个功能相同或更高的系统。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从哪里开始？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自然，您需要从虚拟空间属性的假定开始。</font><font style="vertical-align: inherit;">当今的计算技术由一维空间（无限地址空间）表示。</font><font style="vertical-align: inherit;">但这还不足以对三维（+时间）世界进行建模，从而不断产生需要“拐杖”解决问题的问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将举例说明现代计算范式固有的问题：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将对象放置在内存中之后，就无法更改其大小而无需重新创建。</font><font style="vertical-align: inherit;">您必须使用间接寻址，以解决碎片整理和内存分配问题。</font><font style="vertical-align: inherit;">堆栈溢出和各种缓冲区的问题。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据表示系统中没有缺少数据的概念，物理内存中的任何垃圾都是合法数据，这会导致错误。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有其他计算系统（对象）的概念，只有一个“磁带”存储器和一个修改它的自动机。</font><font style="vertical-align: inherit;">这种方法甚至在同一处理器内（任务是顺序执行的）也会引起任务交互的问题，如果一个以上的计算机系统需要交互，那么“拐杖”将达到史诗般的比例。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些示例仅用于理解大多数大问题是计算范式的核心，即最简单的“砖墙”元素。</font><font style="vertical-align: inherit;">这些“砖”在某些时候不希望形成一个单一的结构，而整个“建筑物”都将倒塌。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（它们将被补充，然后减少为几个基本的</font><b><font style="vertical-align: inherit;">假设</font></b><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<ol>
<li>     «»,          «»   .</li>
<li>   «»  .    «»    (  )   «»      «»    «».  ,                  «»  .</li>
<li>      .</li>
<li>      ,          «» « »  «»,   .</li>
</ol><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简而言之，虚拟空间是相互接触的气泡的多维泡沫。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
这些假定条件使您可以从真实（物理）或虚拟世界中创建任何系统（交互对象集）。示例：使用“地址”维通过“内存”对象访问地址，并且可以有任意数量的此类地址空间。寻址对象具有对应于不同地址空间的其他尺寸。以物理对象形式存在的对象“内存”可能不存在（纯虚拟模型）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很重要的一点</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：假设不指示对象的位置，存在和存储的设备，甚至没有地址空间的概念（少一个）。可以说的是空间的潜在存在（“气泡”）；只有通过“接触”的存在，才能使人确信气泡本身的存在。在“气泡”内部，所有可以“编号”的是接触点。如果没有联系，则它们是完全独立的，并且在理论上不会影响彼此的系统，但同时它们都位于原始的“泡沫”中，并且将来可以开始交互。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于个性转移的任务，数字大脑将看起来像一个普通的气泡，包括1000亿个气泡，其中包含一个模拟神经元的对象或与生物大脑进行交流的对象。</font><font style="vertical-align: inherit;">在视觉上，甚至可以想象到螺纹（树枝状轴突）在接触点上的拉伸（“气泡”在三维空间中的变形）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的范式中通信系统的实现</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告</font></font></b> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
本文中介绍的所有思想和算法都是我独立和完全独立的智力活动的结果。</font><font style="vertical-align: inherit;">作为作者，我授权您随便使用，修改，补充所有思想和算法，并以我的著作权为前提，在任何类型的项目中向任何个人或组织。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于现代范式，将空间实现为一维环非常简单：地址，“写”-“读”的数据和“读”-“写”的信号。对于具有多维“泡沫”的范例，需要为“所有人与每个人”（在极限内）创建一个通信系统，当然，实际上这是不可能的。大多数对象将通过中间节点连接。 “通信范围”的分布将具有“正常类型”，节点之间的距离越小，此类连接的数量就越多（逻辑和常识表明需要将交互对象尽可能地标记为彼此靠近）。具有中间节点的通信系统的基础是一种用于在多个源之间复用（划分）通信信道的算法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，最好对物理通信信道的多路复用算法的工作原理进行简化说明。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
传输的数据可以表示为磁珠的“散射”（每个磁珠都是唯一的，序列无法更改），必须通过直径等于磁珠直径的管子来传输。</font><font style="vertical-align: inherit;">如果有一个珠子源，那么访问“电信管道”就没有问题，它是专有的。</font><font style="vertical-align: inherit;">如果有大量的珠子源，那么它们可能会在“管”的入口发生碰撞，甚至在珠子的出口处，您也需要分成单独的容器。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提出的算法</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（例如，总线）如下所示：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用弹性线将来自各种来源的珠子串起来并固定（每个来源都有单独的线）</font></font></li>
<li>  ,     ,          (   ).        ,    .</li>
<li>     ,        .</li>
<li>       (  )</li>
<li>       (        )</li>
<li>        :   ,         (        ).</li>
<li> ,           (,    ),    ,        . </li>
<li>          ,       ( ).</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果在需要将微珠放入试管中时，微珠尚未通过进入的试管转移，并且料斗是空的，则为确保分选算法的唯一性，您需要放置一个特殊的“空”微珠。在接收侧，空珠不会放在料斗中，而只是丢弃。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来是针对电信专业人员的文本。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于希望涵盖电信范式的所有方面，因此案文显得有些混乱和肿。需要仔细考虑的内容可能会有不正确的术语和逻辑错误（我将感谢您的更正）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
难以理解文本存在问题，我想用图片来补充说明，但是我没有精美的绘画能力。</font><font style="vertical-align: inherit;">如果有人愿意承担这样的负担，我将不胜感激。</font><font style="vertical-align: inherit;">对此，我只能在每个图中注明作者身份。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于那些不怕的人</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据传输网络的当前状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现代数据传输网络的设计要求连接强度相对较低（通道数或单个消息数），同时对时间的稳定性，传输速度，虚拟通道的创建时间，使用备用数据传输路径所花费的时间以及物理通道带宽的最大利用百分比提出了降低的同时要求。 。严格地基于这种原理构建的数据网络不能满足新的计算范式提出的要求。要了解预期的流量和速度需求增长的规模，您可以获取通过处理器堆栈传输的数据和内存中关联数据的数量和速度（指针通常通过堆栈传输），然后乘以典型超级计算机的计算核心数量。这些要求将是数据网络的最低​​要求。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分布式计算系统是大量相互连接（参与联合计算）的计算模块（块），在通常情况下，它们会生成大量的短期连接。</font><font style="vertical-align: inherit;">连接要求更高的传输速度，同时具有较低的稳定延迟和可保证的传递。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从分布式（分布式）计算机系统的角度对数据传输网络提出的要求，整个系统的性能最终取决于其实现。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虚拟通道创建时间极短。</font><font style="vertical-align: inherit;">虚拟通道创建时间应与填充发送器（路由器）的本地缓冲区的时间相当。</font></font></li>
<li>                    .</li>
<li>                      .  ,                 ,     .</li>
<li>           .</li>
<li>  ,              .        ()    .</li>
<li>            (90%  ). </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想情况下，通信系统需要将系统的每个组件与每个组件直接连接，但实际上这是不可能的，您必须通过中间节点传输数据。在这种网络的每个节点中，都有一个使用共享通信线路（进入虚拟通道）连接到几个相同节点的交换机。这种通信系统的基础是用于将物理信道复用（划分）为大量虚拟信道并在各种物理信道中的虚拟信道之间传输数据的算法。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
物理信道的这种分离（复用）的当前使用的（主要）算法（同步层级和分组数据传输系统）严重地不能满足提出的要求。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过同步层次结构（SDH）的方法创建的信道在传输速度的稳定性，没有冲突以及信道利用率对这些参数的影响方面具有出色的性能。同时，传输延迟还有很多需要改进的地方（它在尺寸足够大的容器上运行），并且所创建通道的参数没有灵活性。为了使计算机网络最佳运行，需要延迟时间（即数据传输时间），它必须由两个参数确定：物理距离（电缆长度），并与所请求的数据传输速率成正比。交换机必须能够以恒定的切换时间同时支持大量的虚拟通道（同时最多支持数百万个）。此外，频道（SHD）在创建频道的速度方面没有足够的灵活性，创建虚拟频道所花费的时间通常令人沮丧（我们需要与传输延迟时间相当的时间）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用分组交换根本没有意义（当以规范形式使用时），根本就不能满足单个要求（对于足够大的计算系统）。通道创建时间仅在发送器端部分执行，没有实时处理大量可能的路由，您无法为所有连接选项建立表格（太大和管理成本太大）。原则上不可能保证分组数据传输的延迟。只能通过保留带宽来调节数据传输速度和保证访问，而使用大量虚拟通道则不可能。数据丢失（冲突）从根本上存在于数据包传输中（对于交换机中缓冲区的实际值）。当接近最大物理信道容量时，分组数据传输的所有问题都会严重恶化。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：为了使分布式计算系统最佳运行，需要建立数据传输系统的新范例。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据传输系统的基础是一种方法（算法），用于将一个物理信道划分为所需数量的虚拟和最大同步信道，以在接收器和发送器之间建立端到端虚拟信道。根据对情况的初步分析结果，最佳的是SDH算法。为了克服SDH固有的缺点，有必要“重新设计”该系统。 SDH算法在很大程度上是PDH体现的思想的延续，PDH起源于座机电话系统。对于分布式计算系统而言，持续时间为125μs的帧以及拆分为多个具有相同性能的通道（以及具有端到端同步的层次结构）的存在绝对是毫无意义的限制（对于电话而言，所有这些都是基础知识）。对于计算系统中最低级别的数据传输系统“ TK”将如下所示：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将源流分成给定数量的虚拟数据通道，每个通道具有给定的比特率。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了确保有效载荷从输入通道到输出通道的传输，请使用大小趋于一个字符的数据缓冲区。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没有明确要求存在恒定或可变大小的帧，建议不要引入它，即使将其作为确定虚拟信道列表（将物理信道划分为该时间）的时间段的一种手段也是如此。如果您介绍框架的概念，那么创建额外的通道将需要时间，具体取决于框架的大小。如果不采取其他措施，则创建新通道的延迟平均将是帧时间乘以转接开关数量的一半，这将大大增加创建新虚拟通道（和删除旧虚拟通道）的时间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何根据速度总和（虚拟信道的速度之和加上管理信道的成本之和，不应超过主信道的速度）的规则来将单个物理信道划分为具有任意传输速率的任意数量的独立虚拟信道？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，将同步的要求，即各个传输的数据之间的时间相等，提出给正在创建的通道，这确保了缓冲区的最小大小。最小缓冲区大小的要求是由于无法在开关中的开关晶体外部组织缓冲区。尝试缓冲100G（400G）或更高的流，如果有十或一百个这样的流，则即使最小的不均匀性也会溢出任何合理大小的内存，并且典型RAM的吞吐量甚至不到一个这样的流的速度。如果要创建一个虚拟通道（或几个具有相同传输速度的通道），则没有问题（SDH），但是当创建两个或多个具有不同数据传输速率的通道时，可能会发生冲突，同时，必须传输属于各种虚拟信道的数据。为了满足数据传输系统的要求，我们将修改SDH复用算法。</font></font><br>
<br>
<h3>   </h3><br>
<ol>
<li>              .</li>
<li>    — .       ,           (    ),     .      :  ,      (). <br>
<br>
            .                        (   ).           (,  ,    ,     ).      (  )  ,      ,      ,      .         .         .    100     ,          .         (   )     (),             .          (     ),             . </li>
<li>   (   )      «»,       .      ,           .      .           ,    .</li>
<li>   «»  (   )           .        (   )          .</li>
<li>            .            .</li>
<li>        ,      (   )          (   ).</li>
<li>      .   (  )       «».      ,     (      ), ,    FIFO   .       ,     ,          ( ).              «» (    ),     FIFO       . <br>
<br>
 ,      (      ),    .    «»    -    .         ,    « ».    « »,    «»              FIFO   .           ,      (  ).     ,   ,       —    ,          ,      (   ). (         )</li>
<li>        32 (24)     64 /,      E1(T1). ,    PHD        .</li>
<li>       .         ( 100)    ( ).     106    .      120 .          2.5  (    )   (  ).. (                .)</li>
<li>  (   )  ,    ( )    «»  « »,       (   ).                 .       «»  « »,      .</li>
<li>        ,     « »               (          ),        « ».         « »,               .            .</li>
<li>      (    )        (         ).          .   « »         ,                () .     « »      ,       .   ,           (  ).        ,      ()   .       ,     ,         .   ,     ,            .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过物理通道传输后，不仅必须重新分配物理流之间的虚拟通道，还必须分解总流，还因为可能需要添加或删除``无数据''字符（仅在向缓冲区写入或读取字符时才有可能）。部分“编辑”或替换数据没有多大意义。您可以添加创建中间交换机无法理解的总流的功能-隧道（它不能理解中间交换机中的组件）。如果您使用替代服务符号创建摘要流（算法保持不变，每个隧道级别需要其自己的服务符号集），然后将生成的摘要流作为常规虚拟通道进行传输，则可以创建虚拟“隧道”。在接收方，需要额外的程序才能将这种通道分解成其组件（分析的数量等于“隧道”的级别）。由于减少了虚拟通道的数量，因此，创建了“隧道”是有益的，因此，中间交换机中所需的缓冲区（与虚拟通道速度成比例的切换延迟将更小）。缓冲区的数量限制了同时通过交换机的虚拟通道的数量。任何物理信道（用于接收或传输）都可以使用任何缓冲区（缓冲区是一种公共资源），这会增加其使用系数。从物理上讲，该缓冲区是一个小的FIFO，用于存储几个字符（最多10个字符，并由创建新的虚拟通道所需的时间和数据传输时间的最大不均匀性决定），读和写接口的数量等于此开关中收集或拆卸总通道的模块的数量（所有物理通道和物理通道）。虚拟频道），同时保证每个时钟周期不超过一个通话。缓冲器的时钟同步周期与字符的接收和发送频率一致。如果您有一个宽带通道，并且有大量较小的通道，则可以将大字符分配给快速通道，然后一次将多个数据写入缓冲区（或另一种选择）。所描述的体系结构非常好级联。有许多配置选项，因此有必要寻求最佳折衷方案。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当在单个芯片上建立通信网络时，发送器模块将变成两个寄存器（一个在发送器侧，一个在接收器侧），算法本身不会改变。如果创建的通道的速度和组成恒定，则可以极大地优化交换机硬件的大小。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总体而言，数据传输网络由交换机和端口之间的通信电缆组成。网络的目的是提供最高质量的客户数据。客户端通过类似于常规交换机的设备连接到网络，该设备的显着特征是能够通过计算系统本身的硬件及其较大的大小访问数据缓冲区。一旦将已创建的虚拟通道的接收数据写入连接到计算机系统的交换机的缓冲区（用于接收）中，就应打开机制（类似于通常的计算机系统中的中断），等待信息出现足以确定被叫服务，然后将连接相应的软件以维护该缓冲区。与现代“网卡”的区别在于创建大量并行通道（并行访问数据网络）的能力，从而消除了从（到）网络到（从）大量计算核心（线程）的数据包的内部队列。自动化启动“数据处理程序”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建通道可以分为两个阶段：管理（路径搜索，速度分配，访问权限等）和直接创建虚拟通道（需要数据传输时）。第一阶段执行的频率相对较低（网络是相对静态的），可以在应用程序启动阶段提前执行。第二阶段需要尽快执行，正是这一阶段决定了数据网络的性能以及整个分布式计算系统的性能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
直接创建和删除虚拟通道（所有必要的数据都在第一阶段准备好）应该以最快的速度发生。正确地说，通道的创建和数据的传输必须同时发生。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该算法应如下所示：在最初的时间，虚拟通道尚不存在（数据的第一部分被写入与数据源关联的缓冲区中），多路复用器尚未为其分配物理通道带宽的一部分，只有服务通道，您需要确定哪个从物理通道将创建一个新的虚拟通道。当缓冲区中出现足够数量的数据以创建虚拟通道时（方向和要求的速度，从替代列表中选择它们），有必要形成并发送一个数据包（使用服务通道），并请求在所需的物理通道中创建虚拟通道。与创建的虚拟通道的请求和参数打包在一起，通过发送器的总信道的合成设备并解析所选物理信道的接收器的总信道，改变了接收器和发送器的虚拟信道表的组成。带有参数的程序包应包含“添加频道”服务符号，此后控制器开始传输添加了新虚拟频道的总流。在添加新的虚拟通道时，将从缓冲区进行数据采样，并将创建的虚拟通道的字符发送到所选路由器的一侧。仅基于本地物理通道的可用带宽，创建新通道时无需通知远程交换机。创建的通道的性能始终低于服务通道的初始性能（物理通道的空闲部分），通过将部分资源与服务通道分开来创建一个新通道。在处理（从物理通道接收）具有创建新虚拟通道请求的数据包时，有必要确定在接收“添加通道”符号之前的剩余时间内，在哪个可用（空闲）缓冲区中开始保存新通道的数据。无法将请求保存在内存中并在以后进行处理，接收到“创建频道”符号（或具有已知延迟）后，总流的组成将立即更改，并且将开始接收包含已创建的虚拟通道的符号的总流，这将破坏总流的解码过程（如果接收器中的频道列表是不会改变）。计算必须从分配的缓冲区开始向其发送数据的传出物理信道的数量的时间，应该是最小的（由缓冲区的大小决定），这意味着速度和路由数据应该已经在带有创建新虚拟通道的请求的数据包头中（基本上没有时间访问外部存储器中的表）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅在接收到有关切换方向和所创建通道的速度的所有必要数据之后，才可能形成带有请求的数据包。交换机中的虚拟通道缓冲区必须较小，这意味着该数据（下一个交换机中的速度和端口号）应位于传输数据的最开始，但是当前缓冲区的大小将允许保存所有后续数据，直到形成新的总通道为止没有溢出。形成带有请求的数据包后，您需要删除带有通往下一个交换机的物理通道号上的数据的符号（如果通过指定交换机端口的顺序指定了路由）。要关闭虚拟通道，无需使用服务通道转发数据包，将“删除频道”服务符号放在已删除频道的传输数据中就足够了。在多路复用信道综合模块接收到“删除信道”符号时，删除相应的虚拟信道，然后生成的更新的摘要信道不再包含远程虚拟信道。为了自动删除（清理），防止物理通道的性能``泄漏''，有必要将虚拟通道的硬件计数器中集成一个已传输字符数（任意）的计数器，并在达到一定值（超时）时自动传输符号``关闭通道''。为了延长虚拟通道的寿命，可以输入添加到数据中的“复位计数器”符号。本地交换机可能会忽略通道寿命延长，这将是物理信道带宽不足的答案。如果在创建虚拟通道期间必须将其切换到缺少可用带宽的物理通道，服务通道速度不足以创建新的虚拟通道或没有可用缓冲区或其他原因，则必须破坏请求数据包。更正确地说，它被重定向到存根模块，该存根模块将接收故障虚拟通道的所有字符，并为发送方生成所有必需的消息（这些消息是通过服务通道发送的）。由于实现的复杂性，我不考虑带缓冲的选项。这种方法最适合长度较短的频道，对于他们来说，传送超时是最小的，并且由于重复创建虚拟频道而不会极大地影响整体性能。如果成功创建了通道，那么所有可能发生的就是由于设备干扰导致的数据失真。与现有网络（以太网）相比，不仅需要发送数据包，而且还必须确保已成功将其成功建立到了最低服务等级的接收方。 “无处发送”数据通常无法满足任何人的需求，并且由于需要未知的时间，因此通过等待响应消息来检查数据的传递非常“令人不快”。发送有关使用服务频道建立频道的通知，该操作不需要特别大的资源。您可以实现另一个选项-立即创建一个将传输数据的源和接收者组合在一起的环（该数据包将立即整体循环运行，或者由接收方的交换机形成一个响应数据包）。您可以在每个中间交换机上生成这样的通知（如果创建通道失败），以便发送器尽快知道创建通道的可能性。如果您真的不想在无法以所需速度创建虚拟通道时重新传输数据，这对于具有非常长的传递时间（通过卫星到达地球另一端）的路由来说是最佳选择，那么您可以尝试使用部分传递算法。您可以在每个中间交换机上生成这样的通知（如果创建通道失败），以便发送器尽快知道创建通道的可能性。如果您真的不想在无法以所需速度创建虚拟通道时重新传输数据，这对于具有非常长的传递时间（通过卫星到达地球另一端）的路由来说是最佳选择，那么您可以尝试使用部分传递算法。您可以在每个中间交换机上生成这样的通知（如果创建通道失败），以便发送器尽快知道创建通道的可能性。如果您真的不想在无法以所需速度创建虚拟通道时重新传输数据，这对于具有非常长的传递时间（通过卫星到达地球另一端）的路由来说是最佳选择，那么您可以尝试使用部分传递算法。那么您可以尝试使用部分投放算法。那么您可以尝试使用部分投放算法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当无法创建所需速度的通道时，将创建较低速度的通道（然后以该速度创建通道），并且在切换缓冲区溢出时，缓冲区将被清除，并在其中放置表示缓冲区溢出的符号和丢弃的字符数。接收者接受了这样的字符，就形成了这样的减速列表，并将其发送给发送器。发送器降低主通道的速度，计算跳过了哪些数据（可以从速度降低列表和缓冲区大小中简单确定跳过的数据），并以最佳方式发送它们（尽管有替代路由）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现有数据包交换网络中的路由基于数据包标头中的地址，路由表以及中间路由器中的其他规则。此方法适用于较少数量的路由定义以及缓冲单个数据包的接收数据的可能性；确定数据包应发送到的端口号花费相对较长的时间。对于虚拟通道寿命短的高速系统，将没有足够的访问速度访问交换表的内存（并且每个物理通道表本身的大小以兆字节为单位-您需要分配的RAM等于虚拟通道的最大可能数量），使用直接方法描述路由更有利物理通道的枚举通过它应该建立虚拟通道。地址信息的大小不会太大，中间交换机的数量相对较小，如果为每个交换机分配8位（物理端口或隧道的数量），则IP6地址的模拟将允许您构建16个交换机的路由。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于所提出的方法，对于每个缓冲区（即现有的，并且可能不存在的虚拟通道），将该表转换为一个字节。另外，有必要考虑到仅在创建通道时才发送地址（地址在移至接收器时逐渐被删除），并且虚拟隧道的使用显着降低了路由成本。要建立物理通道链，您可以使用传统搜索引擎的类似物或现代网络中的DNS，设置目标参数（任何参数集：IP地址也是常规参数），然后我们会获得一组具有备用路由的链。相对寻址增强了针对未经授权访问的保护，对路由进行了完全控制。为了使网络正常工作，不需要高级组件的强制存在（运行），可以预先设置路由（对于具有永久性通信系统的网络，例如，印刷电路板上的布线-连接不会更改）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于创建通道的速度很高，而且网络规模可能很大，因此无法进行直接的流量控制，带宽的分配（规划）等。为了平衡信道的负载，有必要使用间接方法，例如规划各种路径，考虑到虚拟信道使用的累积统计信息来分配传输速率。当物理通道超载时，来自现有虚拟通道的数据不会被丢弃，不可能仅创建一个新通道。如果我们考虑流量的性质（主要是短消息和频繁消息），备用路由的可用性以及创建（删除）虚拟通道的非常快速的过程，那么拒绝创建通道不会导致性能上的灾难性下降，计算速度只会稍有下降（在收到有关连接错误或预定时间到期的消息时，将重新创建通道）。当累积了否定统计信息（即统计信息，而不是对单个事件的反应）时，交换机管理软件将监视连接错误的频率，并根据该数据调度通道参数。拥塞本身很有可能在几百纳秒的时间内停止，路由器软件应该处理战略规划问题。这样的计划包括编辑已经创建的路线的能力（数据存储在多路复用器中），否则无法可靠地重建路线网络（当软件仍要求重新创建路线时）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与传输数据的源（接收方）的通信程序（计算过程的线程）是根据与交换机相同的方案构造的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
计算系统是由通信网络集成的大量不同的执行模块。通信网络取代了所有本地总线和接口，从访问内存到连接键盘。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
计算系统的这种体系结构从根本上改变了整个计算范式（稍后将在描述操作系统和软件结构的文章中考虑此问题）。</font><font style="vertical-align: inherit;">网络设备在计算体系结构中的作用正在发生巨大变化。</font><font style="vertical-align: inherit;">如果以前的网络是连接单独的计算机和在其上运行的应用程序的一种方式，那么现在基本上不存在单独的计算机的概念，并且可以在各种网络硬件资源上“分发”该应用程序。</font><font style="vertical-align: inherit;">管理问题（通过计算机系统的访问参数进行资源管理）完全进入了连接各个执行模块（不再有中央处理器）的网络管理层面。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应对传输错误</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以将最低级别的错误控制视为对已传输字符的编码，并且在发生一个或多个错误（数量取决于数据传输通道）时可以恢复。如果尽管进行了编码，但是仍然出现了错误的符号（或一组符号），则发送器和接收器的虚拟通道列表的同步将产生最不愉快的影响。因此，更改表（创建或删除通道）的请求应具有最大的恢复可能性。如果请求仍然丢失，那么所有速度低于请求速度的虚拟通道的数据都会失真。此外，还有两种响应方式：完全破坏所有虚拟通道或仅破坏数据失真的虚拟通道（传输速率低于丢失通道的传输速率），在遭受失真的数据中添加符号“错误”（此符号由接收器处理）。如果检测到不同步，则必须尽快恢复表的身份，并且通道的恢复时间应由电缆的长度（连接两个交换机）确定。从发送器到接收器的表的完整传输是最简单的选择，但是最好在每个表编辑请求中添加一个循环请求号。根据请求编号，确定不同步的时刻（这些编号不会顺序出现），并生成一个请求以重新发送丢失的更改。通道恢复时间应由电缆的长度（连接两个开关）决定。从发送器到接收器的表的完整传输是最简单的选择，但是最好在每个表编辑请求中添加一个循环请求号。根据请求编号，确定不同步的时刻（这些编号不会顺序出现），并生成一个请求以重新发送丢失的更改。通道恢复时间应由电缆的长度（连接两个开关）决定。从发送器到接收器的表的完整传输是最简单的选择，但是最好在每个表编辑请求中添加一个循环请求号。根据请求编号，确定不同步的时刻（这些编号不会顺序出现），并生成一个请求以重新发送丢失的更改。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所提出的通信范例不仅可以用于构建下一代计算系统，而且可以用于改善现有网络。创建的虚拟通信通道的同步性和高服务质量将最佳地解决传输，语音，视频（无衰减）的所有问题。对于实时系统或高可靠性系统而言，创建许多替代路由的能力，对创建通道的时间进行严格控制以及数据传递的能力非常有用。可以通过新的范式透明地模拟数据包交换，数据包传输只是临时通道的创建，数据传输和关闭。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不能通过分组交换对新网络进行反向仿真。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
希望您喜欢有关通信系统的文章。如果在读取过程中发现错误并且没有对接，请指出这些错误。我希望本文将成为大型组织将收购的新项目和初创公司的基础。如果希望在诸如OpenCores.org之类的社区中将这样的系统实现为HDL模型，我将感到非常高兴（不要忘记指向源代码）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下文章将描述计算范例的其他方面（部分）。规划了一篇有关设计“头像”的机械原理的文章。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所描述的用于构建通信系统的算法可以成为一个整体的一部分，甚至可以成为国际标准的一部分（我非常希望）。</font><font style="vertical-align: inherit;">如果您有任何疑问，我随时准备针对具体的实际实施情况进行回答，提供建议并检查“是否符合党的总路线”。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN491620/index.html">是什么使赛普拉斯非常适合自动化初学者？</a></li>
<li><a href="../zh-CN491622/index.html">使用Python预测金融危机</a></li>
<li><a href="../zh-CN491624/index.html">在Unity Universal Render管道中创建轮廓效果</a></li>
<li><a href="../zh-CN491628/index.html">Spelunky是优秀游戏设计的一个例子</a></li>
<li><a href="../zh-CN491630/index.html">Firefox浏览器扩展程序应用程序（WebExtensions）</a></li>
<li><a href="../zh-CN491634/index.html">保护和黑客Xbox 360（第1部分）</a></li>
<li><a href="../zh-CN491636/index.html">GRASP模板：信息专家</a></li>
<li><a href="../zh-CN491638/index.html">云1C。一切都万里无云</a></li>
<li><a href="../zh-CN491640/index.html">大数据会信守承诺吗？</a></li>
<li><a href="../zh-CN491642/index.html">我们如何在Alconost制作视频以及客户如何参与其中</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>