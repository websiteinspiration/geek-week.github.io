<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍💼 💲 ⚠️ SQLガイド：クエリをより適切に記述する方法（パート1） 🎁 🙄 👰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="アンチパターン、実行計画、時間の複雑さ、クエリのチューニング、SQLの最適化について学ぶ
 構造化クエリ言語（SQL）は、コンピューターサイエンス業界で不可欠なスキルであり、一般的に言えば、このスキルの学習は比較的簡単です。ただし、ほとんどの場合、SQLはクエリを記述することだけでなく、将来の最初の...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SQLガイド：クエリをより適切に記述する方法（パート1）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465547/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アンチパターン、実行計画、時間の複雑さ、クエリのチューニング、SQLの最適化について学ぶ</font></font></h3><br>
<img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造化クエリ言語（SQL）は、コンピューターサイエンス業界で不可欠なスキルであり、一般的に言えば、このスキルの学習は比較的簡単です。</font><font style="vertical-align: inherit;">ただし、ほとんどの場合、SQLはクエリを記述することだけでなく、将来の最初のステップにすぎないことを忘れています。</font><font style="vertical-align: inherit;">クエリのパフォーマンスを保証したり、作業中のコンテキストを一致させたりすることは、まったく異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このため、このSQLガイドでは、クエリを評価するために実行できるいくつかの手順の概要を説明しています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初に、データサイエンスの分野で働くためのSQL学習の重要性の概要を説明します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、質の高いクエリを作成することの重要性を理解するために、最初にSQLクエリを処理および実行する方法を学びます。</font><font style="vertical-align: inherit;">具体的には、リクエストが分析、書き換え、最適化され、最終的に評価されることがわかります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これを念頭に置いて、初心者がクエリを作成するときに作成するクエリのアンチパターンのいくつかに進むだけでなく、これらの考えられるエラーの代替策と解決策についても学びます。</font><font style="vertical-align: inherit;">さらに、セットベースのクエリアプローチについて詳しく学びます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">また、これらのアンチパターンはパフォーマンスの問題に起因していること、SQLクエリを改善するための「手動」アプローチに加えて、クエリ計画の確認に役立つ他のツールを使用して、より構造化された詳細な方法でクエリを分析できることもわかります。</font><font style="vertical-align: inherit;">そして、</font></font></li>
<li>    time complexity  big O notation,            ;</li>
<li>    ,   .</li>
</ul><a name="habracut"></a><br>
<h2>   SQL    ?</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQLは完全に死にかけているわけではありません。これは、データ分析、データエンジニア、データスペシャリスト、またはその他の役割に応募するかどうかに関係なく、データ処理および分析業界の職務記述書で最も求められるスキルの1つです。これは、2016年のO 'Reilly Data Science Salary Surveyの回答者の70％によって確認されており、専門的なコンテキストでSQLを使用していると回答しています。さらに、この調査では、SQLがプログラミング言語R（57％）およびPython（54％）よりも際立っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状況を理解する：SQLは、IT業界での就職に取り組むときに必要なスキルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1970年代初頭に開発された言語としては悪くないでしょう？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、なぜそれがそれほど頻繁に使用されるのですか？そして、彼が長い間存在しているにもかかわらず、なぜ彼は死ななかったのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの理由があります。最初の理由の1つは、企業が主にリレーショナルデータベース管理システム（RDBMS）またはリレーショナルデータフロー管理システム（RDSMS）にデータを格納しており、SQLがこのデータにアクセスする必要があることです。 SQLは</font><font style="vertical-align: inherit;">データの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共通語です</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ほとんどすべてのデータベースと対話したり、ローカルで独自のデータベースを構築したりすることもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも不十分な場合は、ベンダー間で互換性がなく、必ずしも標準に準拠していないSQL実装が多数あることに注意してください。したがって、標準SQLの知識は、業界（コンピューターサイエンス）で自分の道を見つけるための要件です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、大規模なデータセットをクエリおよび管理するためのSQLのようなクエリ言語インターフェイスであるHiveや、SQLクエリの実行に使用できるSpark SQLなどの新しいテクノロジもSQLに参加していると言っても過言ではありません。繰り返しになりますが、SQLは学習できる標準とは異なりますが、学習曲線ははるかに単純になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較したい場合は、線形代数の学習と見なしてください。これらのすべての努力をこの1つの主題に入れれば、それを使用して機械学習を習得することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、これがこのクエリ言語を学ぶべき理由です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初心者でも簡単に習得できます。</font><font style="vertical-align: inherit;">学習曲線は非常に単純で段階的であるため、できるだけ早くクエリを記述します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「一度学ぶとどこでも使える」という原則に従うので、これはあなたの時間の大きな投資です！</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはプログラミング言語へのすばらしい追加です。</font><font style="vertical-align: inherit;">場合によっては、コードを書くよりもクエリを書く方が効率的です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはまだ何を待っていますか？</font><font style="vertical-align: inherit;">:)</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL処理とクエリ実行</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQLクエリのパフォーマンスを向上させるには、まずクエリをクリックしてショートカットを実行したときの内部の動作を知る必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、要求が解析ツリーに解析されます。リクエストは、構文およびセマンティックの要件に準拠しているか分析されます。パーサーは、入力要求の内部表現を作成します。次に、この出力は書き換えメカニズムに転送されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、オプティマイザは、指定されたクエリに最適な実行またはクエリプランを見つける必要があります。実行計画は、各操作に使用されるアルゴリズム、および操作の調整方法を正確に決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最適な実行プランを見つけるために、オプティマイザは可能なすべての実装プランを一覧表示し、各プランの品質またはコストを決定し、データベースの現在の状態に関する情報を受け取って、それらのうち最適なものを最終的な実装プランとして選択します。クエリオプティマイザーは不完全な場合があるため、ユーザーおよびデータベース管理者は、パフォーマンスを向上させるために、オプティマイザーによって作成された計画を手動で調べて調整する必要がある場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、何が「適切なクエリプラン」と見なされるのか疑問に思われるでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたがすでに読んだように、計画のコストの質は重要な役割を果たします。</font><font style="vertical-align: inherit;">具体的には、計画の評価に必要なディスクI / Oの数、計画のCPUのコスト、データベースクライアントが監視できる合計応答時間、合計実行時間などが重要です。</font><font style="vertical-align: inherit;">ここで、時間の複雑さの概念が生まれます。</font><font style="vertical-align: inherit;">これについては後で詳しく学びます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、選択したクエリプランが実行され、システム実行メカニズムによって評価されて、クエリ結果が返されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/3n/1f/xo3n1fcyfe4sth2z1v0qxdgux0m.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLクエリの作成</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のセクションから、ガベージイン、ガベージアウト（GIGO）の原則がクエリの処理と実行のプロセスに自然に現れることは明らかになっていなかった可能性があります。クエリを作成するものは、SQLクエリのパフォーマンスにも重要です。オプティマイザが不十分に定式化されたリクエストを受け取った場合、それはできることしかできません... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、リクエストを書くときにできることがいくつかあることを意味します。冒頭で見たように、ここでの責任は2つあります。それは、特定の基準を満たすクエリを記述することだけでなく、パフォーマンスの問題がクエリのどこに隠れているかについてのアイデアを収集することについてもです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的な出発点は、問題が発生する可能性があるクエリの「場所」を考えることです。</font><font style="vertical-align: inherit;">また、一般に、初心者がパフォーマンスの問題の発生を予測できる4つのキーワードがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態</font></font><code>WHERE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーワード</font></font><code>INNER JOIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>LEFT JOIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">そして、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態</font></font><code>HAVING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、このアプローチは単純で素朴ですが、初心者にとっては、これらのポイントは優れた指針であり、最初に起動したときに、これらの場所でエラーが発生し、奇妙なことに、それらもまた気づきにくいと言えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、パフォーマンスは意味のあるものになるはずであることも理解する必要があります。ただし、これらの文やキーワードが悪いと言うだけでは、SQLのパフォーマンスについて考える必要はありません。申し出があっ</font></font><code>WHERE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たり</font></font><code>HAVING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエストに含まれてい</font><font style="vertical-align: inherit;">たり</font><font style="vertical-align: inherit;">しても、必ずしも悪いリクエストであるとは限りません...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のセクションをチェックして、クエリを作成するためのアンチパターンと代替アプローチの詳細を確認してください。</font><font style="vertical-align: inherit;">これらのヒントとコツはガイドとして意図されています。</font><font style="vertical-align: inherit;">どのように、そして本当にあなたのリクエストを書き直す必要があるかは、とりわけ、データの量、データベース、そしてあなたがリクエストを完了する必要がある回数に依存します。</font><font style="vertical-align: inherit;">それは完全にあなたの要求の目的に依存し、あなたが作業するデータベースについての予備知識を持っていることが重要です！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.必要なデータのみを取得する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「データが多いほど良い」という結論-SQLを作成するときに従う必要はありません。本当に必要以上のデータを取得することで混乱するだけでなく、クエリが受信するデータが多すぎるためにパフォーマンスが低下する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、原則として、演算子</font></font><code>SELECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、文</font></font><code>DISTINCT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、演算</font><font style="vertical-align: inherit;">子</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">注意を払う必要が</font><font style="vertical-align: inherit;">あります</font></font><code>LIKE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーター </font></font><code>SELECT</code></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリを作成するときに最初に確認できることは、命令が</font></font><code>SELECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">できるだけコンパクトである</font><font style="vertical-align: inherit;">かどうか</font><font style="vertical-align: inherit;">です。ここでの目標は、から不要な列を削除すること</font></font><code>SELECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。このようにして、クエリの目的にかなうデータのみを取得するように強制します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
でサブクエリを関連付けて</font><font style="vertical-align: inherit;">いる場合は、実際の列の値を選択する代わりに</font></font><code>EXISTS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>SELECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このサブクエリ</font><font style="vertical-align: inherit;">の演算子で定数を使用する必要</font><font style="vertical-align: inherit;">があります。これは、存在を確認するだけの場合に特に便利です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">覚えておいてください</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相関サブクエリは、外部クエリから値を使用するサブクエリであること。また</font></font><code>NULL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、このコンテキストでは「定数」として機能する場合がありますが、非常に混乱します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定数を使用することの意味を理解するには、次の例を検討してください。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> driverslicensenr, <span class="hljs-keyword">name</span>                                   
 <span class="hljs-keyword">FROM</span> Drivers                                             
 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span>                                             
        (<span class="hljs-keyword">SELECT</span> <span class="hljs-string">'1'</span>                                              
        <span class="hljs-keyword">FROM</span> Fines                                               
        <span class="hljs-keyword">WHERE</span> fines.driverslicensenr = drivers.driverslicensenr); </code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒント：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相関サブクエリを持つことは必ずしも良い考えではないことを知っておくと役に立ちます。</font><font style="vertical-align: inherit;">あなたはいつでもそれらを取り除くことを考えることができます、例えば、それらを</font></font><code>INNER JOIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次の</font><font style="vertical-align: inherit;">ように書き換えます</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> driverslicensenr, <span class="hljs-keyword">name</span>                                   
 <span class="hljs-keyword">FROM</span> drivers                                             
 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> fines <span class="hljs-keyword">ON</span> fines.driverslicensenr = drivers.driverslicensenr; </code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作 </font></font><code>DISTINCT</code></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この命令は、</font></font><code>SELECT DISTINCT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまな値のみを返すために使用されます。</font></font><code>DISTINCT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-もちろん、これは可能な限り避けなければならない点です。</font><font style="vertical-align: inherit;">他の例と同様に、この文がリクエストに追加された場合にのみ実行時間が増加します。</font><font style="vertical-align: inherit;">したがって、</font></font><code>DISTINCT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">達成したい結果を得るために</font><font style="vertical-align: inherit;">この操作が本当に必要かどうかを検討することは常に役立ち</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーター </font></font><code>LIKE</code></h4><br><font style="vertical-align: inherit;"></font><code>LIKE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリで</font><font style="vertical-align: inherit;">
演算子</font><font style="vertical-align: inherit;">を使用する場合、パターンが</font></font><code>%</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはで</font><font style="vertical-align: inherit;">始まる場合、インデックスは使用されません</font></font><code>_</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これにより、データベースはインデックス（存在する場合）を使用できなくなります。</font><font style="vertical-align: inherit;">もちろん、別の観点から見ると、このタイプの要求は、必ずしも要求の目的を満たさないレコードを取得しすぎる可能性を残していると主張することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しになりますが、データベースに保存されているデータを知ることは、すべてのデータを正しくフィルタリングして、クエリにとって本当に重要な行のみを見つけるテンプレートを作成するのに役立ちます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.結果を制限する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演算子のフィルタリングを回避できない場合は</font></font><code>SELECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、他の方法で結果を制限できます。</font><font style="vertical-align: inherit;">ここで、文</font></font><code>LIMIT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">やデータ型の変換</font><font style="vertical-align: inherit;">などのアプローチが登場し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子</font></font><code>TOP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>LIMIT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>ROWNUM</code></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステートメント</font></font><code>LIMIT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>TOP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリを</font><font style="vertical-align: inherit;">追加</font><font style="vertical-align: inherit;">して、結果セットの最大行数を指定できます。</font><font style="vertical-align: inherit;">ここではいくつかの例を示します。</font></font><br>
<br>
<pre><code class="sql hljs">  <span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">3</span> * 
  <span class="hljs-keyword">FROM</span> Drivers;</code></pre><br><font style="vertical-align: inherit;"></font><code>PERCENT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、クエリの最初の行をで変更する場合、</font><font style="vertical-align: inherit;">
オプションでを指定できることに注意してください</font></font><code>SELECT TOP 50 PERCENT *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> driverslicensenr, <span class="hljs-keyword">name</span>                                   
 <span class="hljs-keyword">FROM</span> Drivers 
 <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">2</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、</font><font style="vertical-align: inherit;">クエリでの</font></font><code>ROWNUM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><code>LIMIT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">同等</font><font style="vertical-align: inherit;">の文を追加することもでき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> *
<span class="hljs-keyword">FROM</span> Drivers
<span class="hljs-keyword">WHERE</span> driverslicensenr = <span class="hljs-number">123456</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">ROWNUM</span> &lt;= <span class="hljs-number">3</span>;</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ型変換</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も効果的なものを常に使用する必要があります。</font><font style="vertical-align: inherit;">最小のデータ型。</font><font style="vertical-align: inherit;">巨大なデータ型を提供する場合は常にリスクがありますが、小さいデータ型で十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、データ型変換をクエリに追加すると、実行時間のみが増加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の方法は、データ型の変換をできるだけ回避することです。</font><font style="vertical-align: inherit;">また、クエリからデータ型変換を常に削除またはスキップできるとは限らないことに注意してください。ただし、常にそれらを含めて、クエリを実行する前に追加の効果を確認する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.クエリを必要以上に複雑にしないでください</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ型の変換により、次の点につながります。クエリを過度に設計しないでください。</font><font style="vertical-align: inherit;">シンプルで効果的なものにしてください。</font><font style="vertical-align: inherit;">これは、主に要求が複雑になる可能性があるため、ヒントとしても単純すぎるか愚かに思えるかもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、次のセクションで説明する例では、単純なクエリを必要以上に複雑にすることが簡単に開始できることがわかります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーター </font></font><code>OR</code></h4><br><font style="vertical-align: inherit;"></font><code>OR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリで</font><font style="vertical-align: inherit;">
演算子を使用する場合</font><font style="vertical-align: inherit;">、おそらくインデックスを使用していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インデックスは、データベーステーブルでデータを検索する速度を向上させるデータ構造ですが、コストがかかります。インデックスデータ構造を維持するには、追加のレコードが必要になり、追加のストレージスペースが必要になります。インデックスを使用すると、データベーステーブルにアクセスするたびにデータベースのすべての行を検索する必要がなく、データをすばやく検索または検索できます。インデックスは、データベーステーブルの1つ以上の列を使用して作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースに含まれるインデックスを使用しない場合、クエリの実行に必然的に時間がかかります。このため、演算子を使用する代わりの方法を探すのが最善です。</font></font><code>OR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたの要求で; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のクエリについて考えてみます。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> driverslicensenr, <span class="hljs-keyword">name</span>
<span class="hljs-keyword">FROM</span> Drivers
<span class="hljs-keyword">WHERE</span> driverslicensenr = <span class="hljs-number">123456</span>
<span class="hljs-keyword">OR</span> driverslicensenr = <span class="hljs-number">678910</span>
<span class="hljs-keyword">OR</span> driverslicensenr = <span class="hljs-number">345678</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演算子は次のように置き換えることができます：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
条件c </font></font><code>IN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">または</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> driverslicensenr, <span class="hljs-keyword">name</span>
<span class="hljs-keyword">FROM</span> Drivers
<span class="hljs-keyword">WHERE</span> driverslicensenr <span class="hljs-keyword">IN</span> (<span class="hljs-number">123456</span>, <span class="hljs-number">678910</span>, <span class="hljs-number">345678</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの指示</font></font><code>SELECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>UNION</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒント：</font></font></b><font style="vertical-align: inherit;"></font><code>UNION</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じテーブルを何度も表示しているため</font><font style="vertical-align: inherit;">、ここでは不要な操作を使用しないように注意する必要があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">同時に、</font></font><code>UNION</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエストで</font><font style="vertical-align: inherit;">使用する</font><font style="vertical-align: inherit;">と、実行時間が増加</font><font style="vertical-align: inherit;">することを理解する必要</font><font style="vertical-align: inherit;">があります。</font><font style="vertical-align: inherit;">操作の代替</font></font><code>UNION</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：すべての条件が1つの命令</font></font><code>SELECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">配置されるように要求を再編成する</font><font style="vertical-align: inherit;">か、</font></font><code>OUTER JOIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わりに</font><font style="vertical-align: inherit;">使用し</font><font style="vertical-align: inherit;">ます</font></font><code>UNION</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒント：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、ことを覚えておいてください</font></font><code>OR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-と、次のセクションで言及される他の演算子-最も可能性の高いインデックスを使用しない、インデックス検索は必ずしも好ましくない！</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーター </font></font><code>NOT</code></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリに演算子が含まれている場合、演算子の</font></font><code>NOT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ようにインデックスが使用されない可能性があります</font></font><code>OR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは必然的にあなたの要求を遅くします。</font><font style="vertical-align: inherit;">ここの意味がわからない場合は、次のクエリを検討してください。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> driverslicensenr, <span class="hljs-keyword">name</span>
<span class="hljs-keyword">FROM</span> Drivers
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> (<span class="hljs-keyword">year</span> &gt; <span class="hljs-number">1980</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このリクエストは、予想よりも遅くなる可能性があります。これは、主に複雑な形式になっているためです。このような場合は、別の方法を探すのが最善です。</font><font style="vertical-align: inherit;">置換考える</font></font><code>NOT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ような比較演算子を</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>&lt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>!&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">上記の例は実際に書き換えることができ、次のようになります。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> driverslicensenr, <span class="hljs-keyword">name</span>
<span class="hljs-keyword">FROM</span> Drivers
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">year</span> &lt;= <span class="hljs-number">1980</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう良く見えますよね？</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーター </font></font><code>AND</code></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステートメント</font></font><code>AND</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、次の例のように、インデックスを使用しない別のステートメントであり、非常に複雑で非効率的な方法で使用するとクエリの速度が低下する可能性があります。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> driverslicensenr, <span class="hljs-keyword">name</span>
<span class="hljs-keyword">FROM</span> Drivers
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">year</span> &gt;= <span class="hljs-number">1960</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">year</span> &lt;= <span class="hljs-number">1980</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演算子を使用してこのクエリを書き直すことをお勧めします</font></font><code>BETWEEN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> driverslicensenr, <span class="hljs-keyword">name</span>
<span class="hljs-keyword">FROM</span> Drivers
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">year</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1960</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">1980</span>;</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子</font></font><code>ANY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>ALL</code></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、</font></font><code>ANY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">演算子</font></font><code>ALL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、クエリに含めるとインデックスが使用されなくなるため、注意が必要な演算子です。</font><font style="vertical-align: inherit;">などの代替集計関数</font></font><code>MIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはが</font><font style="vertical-align: inherit;">ここに便利です</font></font><code>MAX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒント：あなたが代替案を使用する場合、次のようなことすべて集計関数、知っておくべき</font></font><code>SUM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>AVG</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>MIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>MAX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くのラインの上に、長期的な需要につながることができます。</font><font style="vertical-align: inherit;">このような場合、これらの値を処理または事前計算する行の数を最小限に抑えることができます。</font><font style="vertical-align: inherit;">もう一度、環境、要求の目的を知ることが重要であることがわかります...使用する要求を決定するとき！</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件でカラムを分離する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、列が計算またはスカラー関数で使用される場合、インデックスは使用されません。</font><font style="vertical-align: inherit;">考えられる解決策は、特定の列を単に選択して、計算または関数の一部ではなくなるようにすることです。</font><font style="vertical-align: inherit;">次の例を考えてみます。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> driverslicensenr, <span class="hljs-keyword">name</span>
<span class="hljs-keyword">FROM</span> Drivers
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">year</span> + <span class="hljs-number">10</span> = <span class="hljs-number">1980</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
面白そうですね。</font><font style="vertical-align: inherit;">代わりに、計算を修正してクエリを次のように書き直してください。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> driverslicensenr, <span class="hljs-keyword">name</span>
<span class="hljs-keyword">FROM</span> Drivers
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">year</span> = <span class="hljs-number">1970</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.力ずくの欠如</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この最後のヒントは、パフォーマンスに影響を与える可能性があるため、リクエストを制限しすぎないことを意味します。</font><font style="vertical-align: inherit;">これは、結合とHAVING句に特に当てはまります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結合におけるテーブルの順序</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのテーブルを結合するときは、結合におけるテーブルの順序を考慮することが重要な場合があります。</font><font style="vertical-align: inherit;">1つのテーブルが他のテーブルよりも大幅に大きい場合、最大のテーブルが結合の最後に配置されるようにクエリを書き直す必要がある場合があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">過度の接続条件</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQL接続に追加する条件が多すぎる場合は、特定のパスを選択する必要があります。</font><font style="vertical-align: inherit;">ただし、この方法の方が効率的であるとは限りません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態 </font></font><code>HAVING</code></h4><br><font style="vertical-align: inherit;"></font><code>HAVING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーワード</font></font><code>WHERE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は集約関数で使用できなかった</font><font style="vertical-align: inherit;">ため、</font><font style="vertical-align: inherit;">
条件</font><font style="vertical-align: inherit;">は最初にSQLに追加されました</font><font style="vertical-align: inherit;">。</font></font><code>HAVING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常</font></font><code>GROUP BY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、返される文字列のグループを特定の条件を満たすものだけに制限</font><font style="vertical-align: inherit;">する操作で使用され</font><font style="vertical-align: inherit;">ます。ただし、この条件がクエリで使用される場合、インデックスは使用されません。これは、ご存じのとおり、クエリが実際にはあまり機能しないという事実につながる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の方法を探している場合は、条件を使用してみてください</font></font><code>WHERE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のクエリを検討してください。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> state, <span class="hljs-keyword">COUNT</span>(*)
  <span class="hljs-keyword">FROM</span> Drivers
 <span class="hljs-keyword">WHERE</span> state <span class="hljs-keyword">IN</span> (<span class="hljs-string">'GA'</span>, <span class="hljs-string">'TX'</span>)
 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> state
 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> state</code></pre><br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> state, <span class="hljs-keyword">COUNT</span>(*)
  <span class="hljs-keyword">FROM</span> Drivers
 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> state
<span class="hljs-keyword">HAVING</span> state <span class="hljs-keyword">IN</span> (<span class="hljs-string">'GA'</span>, <span class="hljs-string">'TX'</span>)
 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> state</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のクエリは文</font></font><code>WHERE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して</font><font style="vertical-align: inherit;">合計する必要がある行の数を制限し、2番目のクエリはテーブルのすべての行を合計し</font></font><code>HAVING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">てから</font><font style="vertical-align: inherit;">、それを使用</font><font style="vertical-align: inherit;">して計算された金額を破棄します。そのような場合、</font></font><code>WHERE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソースを無駄にしないため</font><font style="vertical-align: inherit;">、提案オプションは</font><font style="vertical-align: inherit;">明らかに優れています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは結果セットを制限することではなく、クエリ内のレコードの中間数を制限することであることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これら2つの条件の間の区別は提案がすることであることに留意すべきである</font></font><code>WHERE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提案はしながら、個々の行のための要件を導入する</font></font><code>HAVING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、単一の結果、結果の凝集または選択のための要件を導入する、など</font></font><code>MIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>MAX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>SUM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、...複数の行から作成されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
品質の評価、リクエストの作成とリライトは、可能な限り生産的でなければならないことを考えると、簡単な作業ではありません。</font><font style="vertical-align: inherit;">アンチパターンの防止と代替案の検討も、プロフェッショナル環境のデータベースで実行する必要があるクエリを作成する際の責任の一部になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このリストは、初心者に役立つと思われるアンチパターンとヒントのほんの一部です。</font><font style="vertical-align: inherit;">古い開発者が最も一般的なアンチパターンをどのように考えているかを知りたい場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このディスカッションを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェック</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">して</font></a><font style="vertical-align: inherit;">ください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリを作成するためのセットベースのアプローチと手続き型のアプローチ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述のアンチパターンは、実際にはクエリを構築するためのセットベースの手続き型アプローチの違いに帰着することを示唆しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリへの手続き型アプローチは、プログラミングと非常によく似たアプローチです。システムに何をどのように実行するかを指示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例は</font></font><code>HAVING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、上記の例のように、</font><font style="vertical-align: inherit;">接続の過剰な条件や</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">条件を悪用した場合です。この例では</font><font style="vertical-align: inherit;">、関数を実行してから別の関数を呼び出してデータベースにクエリを実行するか、条件、ループ、ユーザー定義関数（UDF）を含むロジックを使用します。 ）、カーソル、...最終結果を取得します。このアプローチでは、多くの場合、データのサブセットを要求してから、データの別のサブセットを要求します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然のことながら、このアプローチは「ステップバイステップ」または「ラインバイライン」クエリと呼ばれることがよくあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つのアプローチは、セットベースのアプローチで、何をするかを単に指定するだけです。役割は、クエリから受け取る結果セットの条件または要件を指定することです。データの取得方法は、クエリの実装を決定する内部メカニズムに任せます。データベースエンジンに、クエリを実行するための最適なアルゴリズムまたは処理ロジックを決定させます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQLはセットベースであるため、このアプローチが手続き型よりも効率的であることは当然のことですが、SQLが場合によってはコードよりも速く実行できる理由も説明します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒント</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリへのセットベースのアプローチも、情報技術業界のほとんどの主要な雇用主が習得するように要求するものです！</font><font style="vertical-align: inherit;">多くの場合、これら2つのタイプのアプローチを切り替える必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意してください</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたは今までに手続き申請が必要な場合は、あなたがそれを書き換えたりリファクタリングを検討すべきであるということ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のパートでは、計画とクエリの最適化について説明します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja465535/index.html">誰がIPv6を実装し、その開発を妨げているもの</a></li>
<li><a href="../ja465537/index.html">Yandex：大人のスマートホーム</a></li>
<li><a href="../ja465539/index.html">766 km-LoRaWANの新記録</a></li>
<li><a href="../ja465541/index.html">エンタープライズからSMBへ：SaaSモデルを使用した収益化により、中小企業向けの企業ソリューションの適応に関する経験を共有します</a></li>
<li><a href="../ja465545/index.html">州のさまざまな側面：Facebookが米国議会でどのように揚げられたのか、テレグラムはFSBと戦った</a></li>
<li><a href="../ja465551/index.html">9月のITイベントダイジェスト（パート1）</a></li>
<li><a href="../ja465553/index.html">プログラミング言語Ü。導入、作成の動機、目標</a></li>
<li><a href="../ja465557/index.html">製品開発期限</a></li>
<li><a href="../ja465561/index.html">一流のプログラマーから学んだこと</a></li>
<li><a href="../ja465569/index.html">モバイル開発者開発マップ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>