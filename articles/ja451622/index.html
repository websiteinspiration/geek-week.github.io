<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🏭 🤪 🛀🏾 Kotlinのビットカウント、符号なし型、および一致の保存が正当化される状況について 🧑🏾‍🤝‍🧑🏼 ⁉️ 👨🏼‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この執筆は、この解説によって促されました。より正確には、そこから1つのフレーズ。
 ...数十億ドルのアイテムにメモリまたはプロセッササイクルを費やすのはよくありません...
 たまたまそうなったのですが、最近それをしなければなりませんでした。そして、私が記事で検討するケースはかなり特別です-結論と...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kotlinのビットカウント、符号なし型、および一致の保存が正当化される状況について</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/451622/"><img src="https://habrastorage.org/webt/b6/qc/5k/b6qc5klplot_lkmjsi0edrecbye.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この執筆は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この解説</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって促され</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ました</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">より正確には、そこから1つのフレーズ。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...数十億ドルのアイテムにメモリまたはプロセッササイクルを費やすのはよくありません...</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たまたまそうなったのですが、最近それをしなければなりませんでした。</font><font style="vertical-align: inherit;">そして、私が記事で検討するケースはかなり特別です-結論と適用された解決策は誰かにとって役立つかもしれません。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少しコンテキスト</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iFunnyアプリケーションは膨大な量のグラフィックおよびビデオコンテンツを扱い、重複のあいまい検索は非常に重要なタスクの1つです。</font><font style="vertical-align: inherit;">これ自体は別の記事に値する大きなトピックですが、今日は、この検索に関連して非常に大きな数の配列を計算するためのいくつかのアプローチについて少しお話します。</font><font style="vertical-align: inherit;">もちろん、「非常に大きな配列」については誰もが異なる理解を持っているため、ハドロン衝突型加速器と競争するのは愚かですが、それでもまだです。</font><font style="vertical-align: inherit;">:)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムが簡単に説明されている場合、各画像のデジタル署名（署名）は968の整数から作成され、2つの署名間の「距離」を見つけることによって比較が行われます。過去2か月だけでコンテンツの量が約1,000万枚に達したことを考えると、注意深い読者は彼の心の中で容易にそれを理解します。これらはまさに「数十億のボリュームの要素」です。誰が気に-猫へようこそ。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は時間とメモリの節約について退屈な話があり、最後にはソースを見ることが非常に役立つことがあるという事実についての短い有益な話があります。注目を集める絵は、この有益な物語に直接関連しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は少し狡猾だったと認めなければなりません。アルゴリズムの予備分析では、各シグネチャの値の数を968から420に減らすことが可能でした。すでに2倍になっていますが、大きさの順序は同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたがそれについて考えるなら、私はそんなにだましているわけではありません、そしてこれは最初の結論です：タスクを開始する前に、それは検討する価値があります-何らかの方法で事前にそれを単純化することは可能ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較アルゴリズムは非常に単純です。2つのシグネチャの差の2乗の合計のルートが計算され、以前に計算された値の合計で除算されます（つまり、各反復で、合計は依然として一定であり、一定であると見なすことはできません）、しきい値と比較されます。</font><font style="vertical-align: inherit;">署名要素は-2から+2までの値に制限されているため、差の絶対値は0から4までの値に制限されています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/cl/yh/m8/clyhm8caq35-td519odrgd95msq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複雑なことは何もありませんが、量によって決まります。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のアプローチ、素朴</font></font></h1><br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// </span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> d = <span class="hljs-number">0.3</span><font></font>
<font></font>
<span class="hljs-comment">// 10.000.000 . </span>
<span class="hljs-comment">//      ,</span>
<span class="hljs-comment">//       </span>
<span class="hljs-keyword">val</span> collection: MutableList&lt;Signature&gt; = mutableListOf()        <font></font>
<font></font>
<span class="hljs-comment">// signature —   420   Byte</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Signature</span></span>(<span class="hljs-keyword">val</span> signature: Array&lt;<span class="hljs-built_in">Byte</span>&gt;, <span class="hljs-keyword">val</span> norma: <span class="hljs-built_in">Double</span>)  <font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getSimilar</span><span class="hljs-params">(signature: <span class="hljs-type">Signature</span>)</span></span> = collection<font></font>
    .filter { calculateDistance(it, signature) &lt; d }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calculateDistance</span><span class="hljs-params">(first: <span class="hljs-type">Signature</span>, second: <span class="hljs-type">Signature</span>)</span></span>: <span class="hljs-built_in">Double</span> = <font></font>
	Math.sqrt(first.signature.mapIndexed { index, value -&gt;<font></font>
        Math.pow((value - second.signature[index]).toDouble(), <span class="hljs-number">2.0</span>)<font></font>
    }.sum()) / (first.norma + second.norma)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
：私たちは操作の数とここに持っているものレッツ・計算</font></font><br>
<br>
<code>10M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の平方根</font></font><code>Math.sqrt</code><br>
<code>10M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加との分割</font></font><code>/ (first.norma + second.norma)</code><br>
<code>4.200M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">減算および二乗</font></font><code>Math.pow((value - second.signature[index]).toDouble(), 2.0)</code><br>
<code>4.200M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加</font></font><code>.sum()</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たちの選択肢は何：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのようなボリュームがある</font></font><code>Byte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、</font></font><code>Int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3つの重要なビットを格納</font><font style="vertical-align: inherit;">するために</font><font style="vertical-align: inherit;">全体</font><font style="vertical-align: inherit;">（または、禁じられていますが、誰かがを使用すると推測したでしょう</font><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">費やすこと</font><font style="vertical-align: inherit;">は、許されない無駄です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たぶん、数学の量を減らす方法は？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、それほど計算コストが高くないいくつかの事前フィルタリングを実行することは可能ですか？</font></font></li>
</ol><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二のアプローチは、パック</font></font></h1><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ちなみに、誰かがそのようなパッケージで計算をどのように簡略化できるかを提案すると、大きな感謝とカルマのプラスを受け取ることになります。</font><font style="vertical-align: inherit;">1つですが、私の心の底から:)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1つ</font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は64ビットです。この場合、21ビットの値を格納できます（1ビットは未解決のままです）。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">//   20   Long</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Signature</span></span>(<span class="hljs-keyword">val</span> signature: Array&lt;<span class="hljs-built_in">Long</span>&gt;, <span class="hljs-keyword">val</span> norma: <span class="hljs-built_in">Double</span>) <font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calculateDistance</span><span class="hljs-params">(first: <span class="hljs-type">Signature</span>, second: <span class="hljs-type">Signature</span>)</span></span>: <span class="hljs-built_in">Double</span> =<font></font>
    Math.sqrt(first.signature.mapIndexed { index, value -&gt;<font></font>
        calculatePartial(value, second.signature[index])<font></font>
    }.sum()) / (first.norma + second.norma)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calculatePartial</span><span class="hljs-params">(first: <span class="hljs-type">Long</span>, second: <span class="hljs-type">Long</span>)</span></span>: <span class="hljs-built_in">Double</span> {
    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0L</span>
    (<span class="hljs-number">0</span>..<span class="hljs-number">60</span> step <span class="hljs-number">3</span>).onEach {
        <span class="hljs-keyword">val</span> current = (first.ushr(it) and <span class="hljs-number">0x7</span>) - (second.ushr(it) and <span class="hljs-number">0x7</span>)<font></font>
        sum += current * current<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> sum.toDouble()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリからのほうが（</font><font style="vertical-align: inherit;">失礼な場合はバイト</font></font><code>4.200M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に対して）</font><font style="vertical-align: inherit;">優れています</font></font><code>1.600M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、計算はどうですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
操作の数は同じままで、</font></font><code>8.400M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シフトと</font></font><code>8.400M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">論理的な</font><font style="vertical-align: inherit;">操作が追加されていることは明らかだと思います</font><font style="vertical-align: inherit;">。最適化できるかもしれませんが、傾向はまだ満足できません-これは私たちが望んでいたことではありません。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3番目のアプローチは、サブサブで再パックする</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
午前中は匂いがします、ここでビットマジックを使用できます！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値を3つではなく4ビットで保存しましょう。</font><font style="vertical-align: inherit;">この方法では：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0b1100</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0b0100</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0b0000</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0b0010</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0b0011</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、以前のバージョンと比較してパッキング密度は失われ</font><font style="vertical-align: inherit;">ますが、一度に16個の要素</font></font><code>XOR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を受け取る</font><font style="vertical-align: inherit;">ことができ</font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます（違いはありますが）。さらに、各最終ニブルのビットの分布には11のオプションしかないため、事前に計算された差の2乗の値を使用できます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">//   27   Long</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Signature</span></span>(<span class="hljs-keyword">val</span> signature: Array&lt;<span class="hljs-built_in">Long</span>&gt;, <span class="hljs-keyword">val</span> norma: <span class="hljs-built_in">Double</span>) <font></font>
<font></font>
<span class="hljs-comment">// -1   </span>
<span class="hljs-keyword">val</span> precomputed = arrayOf(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calculatePartial</span><span class="hljs-params">(first: <span class="hljs-type">Long</span>, second: <span class="hljs-type">Long</span>)</span></span>: <span class="hljs-built_in">Double</span> {
    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0L</span>
    <span class="hljs-keyword">val</span> difference = first xor second<font></font>
    (<span class="hljs-number">0</span>..<span class="hljs-number">60</span> step <span class="hljs-number">4</span>).onEach {<font></font>
        sum += precomputed[(difference.ushr(it) and <span class="hljs-number">0xF</span>).toInt()]<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> sum.toDouble()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリから、だった</font></font><code>2.160M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反対</font></font><code>1.600M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-不快、それでも良好な初期のものより</font></font><code>4.200M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
：私たちは、以下のステップを計算</font></font><br>
<br>
<code>10M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平方根、部門および総和を（消えていなかった）</font></font><br>
<code>270M</code> <code>XOR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font></font><br>
<code>4.320</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列からの加算、シフトと論理AND抽出物を。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでにもっと興味深いように見えますが、それでも、計算が多すぎます。</font><font style="vertical-align: inherit;">残念ながら、私たちはすでに20％の努力を費やして結果の80％を達成しているようです。それでは、他にどこに利益をもたらすことができるかについて考える時が来ました。</font><font style="vertical-align: inherit;">最初に頭に浮かぶのは、それを計算に持ち込むことではなく、軽量フィルターで明らかに不適切なシグネチャを除外することです。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4番目のアプローチ、大きなふるい</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計算式を少し変換すると、次の不等式が得られます（計算された距離が小さいほど良い）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nu/ny/mv/nunymvgccfhu2hlexvir0d0dlvq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。</font><font style="vertical-align: inherit;">ここで、</font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'ahに</font><font style="vertical-align: inherit;">設定されたビット数に関する情報に基づいて、</font><font style="vertical-align: inherit;">不等式の左側の可能な最小値</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">計算</font><font style="vertical-align: inherit;">する方法を理解する必要があり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">次に、彼を満たさないすべての署名を破棄します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
x </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は0から4までの値を取ることができることを</font><font style="vertical-align: inherit;">思い出させてください</font><font style="vertical-align: inherit;">（符号は重要ではありません。理由は明らかです）。</font><font style="vertical-align: inherit;">各項が二乗されていることを考えると、一般的なパターンを簡単に導き出すことができます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/em/pk/um/empkumsytnx11yoplffogdf4dbc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終的な式は次のようになります（これは必要ありませんが、私は長い間推測していたので、忘れて誰にも見せないのは残念です）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/md/xd/ramdxdoczcczinkn8bouj_40zls.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、Bは設定されたビット数です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際</font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には</font><font style="vertical-align: inherit;">、1つ</font><font style="vertical-align: inherit;">に64ビットしかなく、64の可能な結果を​​読み取ります。また、前のセクションと同様に、事前に完全に計算され、配列に追加されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、27をすべて計算することは完全にオプションです。次の27 </font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のしきい値を超えるのに十分であり、チェックを中断してfalseを返すことができます。ちなみに、メインの計算でも同じアプローチを使用できます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getSimilar</span><span class="hljs-params">(signature: <span class="hljs-type">Signature</span>)</span></span> = collection<font></font>
        .asSequence()  <span class="hljs-comment">//      !?</span><font></font>
        .filter { estimate(it, signature) }<font></font>
        .filter { calculateDistance(it, signature) &lt; d }<font></font>
<font></font>
<span class="hljs-keyword">val</span> estimateValues = arrayOf(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">19</span>, <span class="hljs-number">22</span>, <span class="hljs-number">25</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">34</span>, <span class="hljs-number">37</span>, <span class="hljs-number">40</span>, <span class="hljs-number">43</span>, <span class="hljs-number">46</span>, <span class="hljs-number">49</span>, <span class="hljs-number">52</span>, <span class="hljs-number">55</span>, <span class="hljs-number">58</span>, <span class="hljs-number">61</span>, <span class="hljs-number">64</span>, <span class="hljs-number">69</span>, <span class="hljs-number">74</span>, <span class="hljs-number">79</span>, <span class="hljs-number">84</span>, <span class="hljs-number">89</span>, <span class="hljs-number">94</span>, <span class="hljs-number">99</span>, <span class="hljs-number">104</span>, <span class="hljs-number">109</span>, <span class="hljs-number">114</span>, <span class="hljs-number">119</span>, <span class="hljs-number">124</span>, <span class="hljs-number">129</span>, <span class="hljs-number">134</span>, <span class="hljs-number">139</span>, <span class="hljs-number">144</span>, <span class="hljs-number">151</span>, <span class="hljs-number">158</span>, <span class="hljs-number">165</span>, <span class="hljs-number">172</span>, <span class="hljs-number">179</span>, <span class="hljs-number">186</span>, <span class="hljs-number">193</span>, <span class="hljs-number">200</span>, <span class="hljs-number">207</span>, <span class="hljs-number">214</span>, <span class="hljs-number">221</span>, <span class="hljs-number">228</span>, <span class="hljs-number">235</span>, <span class="hljs-number">242</span>, <span class="hljs-number">249</span>, <span class="hljs-number">256</span>)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">estimate</span><span class="hljs-params">(first: <span class="hljs-type">Signature</span>, second: <span class="hljs-type">Signature</span>)</span></span>:<span class="hljs-built_in">Boolean</span>{
    <span class="hljs-keyword">var</span> bitThreshold = Math.pow(d * (first.norma + second.norma), <span class="hljs-number">2.0</span>).toLong()<font></font>
    first.signature.forEachIndexed { index, value -&gt;<font></font>
        bitThreshold -= estimateValues[java.lang.<span class="hljs-built_in">Long</span>.bitCount(value xor second.signature[index])]
        <span class="hljs-keyword">if</span> (bitThreshold &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、このフィルターの有効性（最大で負）は、選択したしきい値に大きく影響し、入力データにはあまり影響しないことを理解する必要があります。</font><font style="vertical-align: inherit;">幸い、必要なしきい値としては、</font></font><code>d=0.3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">かなり少数のオブジェクトがフィルターを通過でき、合計応答時間に対するそれらの計算の寄与が非常に小さいため、無視できます。</font><font style="vertical-align: inherit;">その場合は、もう少し節約できます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーケンスを取り除く5番目のアプローチ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大きなコレクションを操作する場合、</font></font><code>sequence</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは非常に不快な</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ不足からの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優れた保護</font><b><font style="vertical-align: inherit;">になります</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、最初のフィルターでコレクションが適切なサイズに削減されることが明らかにわかっている場合は、中間のコレクションを作成するループで通常の列挙を使用する方がはるかに合理的な選択です。これ</font></font><code>sequence</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、流行で若々しいだけでなく、反復子も含まれるためです。</font></font><code>hasNext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まったく自由ではない仲間。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getSimilar</span><span class="hljs-params">(signature: <span class="hljs-type">Signature</span>)</span></span> = collection<font></font>
        .filter { estimate(it, signature) }<font></font>
        .filter { calculateDistance(it, signature) &lt; d }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここは幸せそうですが、「綺麗にしたい」と思いました。</font><font style="vertical-align: inherit;">ここで、約束された有益な話に行きます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6番目のアプローチ、最高の</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはコトリンについて書いています、そしていくつかの外国人のものがあります</font></font><code>java.lang.Long.bitCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font><font style="vertical-align: inherit;">そして最近では、符号なしの型が言語に取り入れられました。</font><font style="vertical-align: inherit;">攻撃！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
否や言うほどない。</font><font style="vertical-align: inherit;">すべてがに</font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">置き換えられ</font></font><code>ULong</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ルートが取り除かれたJavaソースから</font></font><code>java.lang.Long.bitCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、拡張機能として書き直されました</font></font><code>ULong</code><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> ULong.<span class="hljs-title">bitCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">var</span> i = <span class="hljs-keyword">this</span>
    i = i - (i.shr(<span class="hljs-number">1</span>) and <span class="hljs-number">0x5555555555555555</span>uL)<font></font>
    i = (i and <span class="hljs-number">0x3333333333333333</span>uL) + (i.shr(<span class="hljs-number">2</span>) and <span class="hljs-number">0x3333333333333333</span>uL)<font></font>
    i = i + i.shr(<span class="hljs-number">4</span>) and <span class="hljs-number">0x0f0f0f0f0f0f0f0f</span>uL<font></font>
    i = i + i.shr(<span class="hljs-number">8</span>)<font></font>
    i = i + i.shr(<span class="hljs-number">16</span>)<font></font>
    i = i + i.shr(<span class="hljs-number">32</span>)
    <span class="hljs-keyword">return</span> i.toInt() and <span class="hljs-number">0x7f</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
始めて…何かがおかしい。</font><font style="vertical-align: inherit;">コードは著しく遅くなり始めました。</font><font style="vertical-align: inherit;">プロファイラーを開始すると、奇妙なことがわかります（記事の見出しを参照）。100万弱の呼び出し、</font></font><code>bitCount()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほぼ1600万の呼び出し</font></font><code>Kotlin.ULong.constructor-impl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">WAT！？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぞなぞは簡単に説明されています-クラスコードを調べてください</font></font><code>ULong</code><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ULong</span> <span class="hljs-meta">@PublishedApi</span> <span class="hljs-keyword">internal</span> <span class="hljs-keyword">constructor</span></span>(<span class="hljs-meta">@PublishedApi</span> <span class="hljs-keyword">internal</span> <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span>: <span class="hljs-built_in">Long</span>) : Comparable&lt;ULong&gt; {
    <span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(other: <span class="hljs-type">ULong</span>)</span></span>: ULong = ULong(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>.plus(other.<span class="hljs-keyword">data</span>))
    <span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">minus</span><span class="hljs-params">(other: <span class="hljs-type">ULong</span>)</span></span>: ULong = ULong(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>.minus(other.<span class="hljs-keyword">data</span>))
    <span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shl</span><span class="hljs-params">(bitCount: <span class="hljs-type">Int</span>)</span></span>: ULong = ULong(<span class="hljs-keyword">data</span> shl bitCount)
    <span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span></span>: ULong = ULong(<span class="hljs-keyword">data</span>.inc())<font></font>
     ..<font></font>
 }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいえ、私は</font></font><code>ULong</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今</font></font><code>experimental</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">すべてを理解しています</font><font style="vertical-align: inherit;">が、どのように！？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、このアプローチは失敗したと認識していますが、残念です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、それでもまだ、何か他に改善できることがありますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際にできます。</font><font style="vertical-align: inherit;">元のコード</font></font><code>java.lang.Long.bitCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は最適ではありません。</font><font style="vertical-align: inherit;">一般的なケースでは良好な結果が得られますが、アプリケーションが機能するプロセッサが事前にわかっている場合は、より最適な方法を選択できます。これはHabréに関する非常に優れた記事です。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルビットをカウントする</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことを強くお勧めします。これを読むことを強くお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「結合法」を使った</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Long</span>.<span class="hljs-title">bitCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">var</span> n = <span class="hljs-keyword">this</span>
    n -= (n.shr(<span class="hljs-number">1</span>)) and <span class="hljs-number">0x5555555555555555L</span>
    n = ((n.shr(<span class="hljs-number">2</span>)) and <span class="hljs-number">0x3333333333333333L</span>) + (n and <span class="hljs-number">0x3333333333333333L</span>)<font></font>
    n = ((((n.shr(<span class="hljs-number">4</span>)) + n) and <span class="hljs-number">0x0F0F0F0F0F0F0F0FL</span>) * <span class="hljs-number">0x0101010101010101</span>).shr(<span class="hljs-number">56</span>)
    <span class="hljs-keyword">return</span> n.toInt() and <span class="hljs-number">0x7F</span><font></font>
}<font></font>
</code></pre><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オウムを数える</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての測定は、ローカルマシンでの開発中に不用意に行われ、メモリから再現されるため、正確さについて話すのは困難ですが、各アプローチのおおよその寄与を推定できます。</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼らがしていたこと</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> オウム（秒）</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のアプローチ、素朴</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25±</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二のアプローチは、パック</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3番目のアプローチは、サブサブで再パックする</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11〜14</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4番目のアプローチ、大きなふるい</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2-3</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーケンスを取り除く5番目のアプローチ</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.8〜2.2</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6番目のアプローチ、最高の</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3〜4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セットビットを数える「結合法」</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.5〜1.7</font></font></td>
</tr>
</tbody></table></div><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h1><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大量のデータの処理を扱う場合、予備分析に時間を費やす価値があります。</font><font style="vertical-align: inherit;">おそらく、このデータのすべてを処理する必要があるわけではありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">粗いが安価なプレフィルタリングを使用できる場合、これは非常に役立ちます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビットマジックは私たちのすべてです。</font><font style="vertical-align: inherit;">もちろん、該当する場合はもちろんです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準のクラスと関数のソースコードを確認すると、非常に役立つことがあります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご清聴ありがとうございました！</font><font style="vertical-align: inherit;">:) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてはい、継続されます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja451606/index.html">インターネットの歴史：崩壊、パート2</a></li>
<li><a href="../ja451610/index.html">セキュリティウィーク20：Firefox拡張機能を無効にする</a></li>
<li><a href="../ja451614/index.html">「私たちがロシアで話し合っていることは、西洋でも同様です」：デニス・ネクリドフへのインタビュー</a></li>
<li><a href="../ja451618/index.html">CampusInsight：インフラストラクチャの監視からユーザーエクスペリエンスの分析まで</a></li>
<li><a href="../ja451620/index.html">Stravaヒートマップカードの自動認証</a></li>
<li><a href="../ja451624/index.html">もちろん、ハリー・ポッターがどのようにロシアの教育を形作るかについて、あなたがそれを必要とする場所ではない</a></li>
<li><a href="../ja451626/index.html">教師なしで学ぶ：好奇心旺盛な学生</a></li>
<li><a href="../ja451628/index.html">2019年4月のトップ3D Expoレビュー</a></li>
<li><a href="../ja451630/index.html">継続的な監視-CI / CDパイプラインでのソフトウェア品質チェックの自動化</a></li>
<li><a href="../ja451634/index.html">ショップやレストランでの分析方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>