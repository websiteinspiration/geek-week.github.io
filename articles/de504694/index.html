<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏻 💇🏼 🖕🏽 So kompilieren Sie einen Dekorator - C ++, Python und seine eigene Implementierung. Teil 1 🔀 🏐 👩🏼‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diese Artikelserie befasst sich mit der Möglichkeit, einen Dekorator in C ++ zu erstellen , den Funktionen ihrer Arbeit in Python, und wir werden auch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>So kompilieren Sie einen Dekorator - C ++, Python und seine eigene Implementierung. Teil 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504694/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Artikelserie befasst sich mit der Möglichkeit, einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dekorator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in C ++ zu </font><font style="vertical-align: inherit;">erstellen </font><font style="vertical-align: inherit;">, den Funktionen ihrer Arbeit in Python, und wir werden auch eine der Optionen für die Implementierung dieser Funktionalität in unserer eigenen kompilierten Sprache betrachten, wobei der allgemeine Ansatz zum Erstellen von Closures verwendet wird - Closure-Konvertierung und Modernisierung des Syntaxbaums.</font></font></p><br>
<img src="https://habrastorage.org/webt/mm/gu/wn/mmguwnnsrlpzur2dgs8pf0woq7m.png"><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haftungsausschluss</font></font></b>
                        <div class="spoiler_text">        ,    Python —    .   Python  ,    (). -   ( ),        -    ( ,    ..),   Python  «»      .<br>
</div>
                    </div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dekorateur in C ++</font></font></h2><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles begann mit der Tatsache, dass mein Freund </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VoidDruid</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beschlossen hat, einen kleinen Compiler als Diplom zu schreiben, dessen Hauptmerkmal Dekorateure sind. Selbst während der Vorverteidigung, als er alle Vorteile seines Ansatzes skizzierte, einschließlich der Änderung des AST, fragte ich mich: Ist es wirklich unmöglich, dieselben Dekorateure in das großartige und leistungsstarke C ++ zu implementieren und auf komplizierte Begriffe und Ansätze zu verzichten? Als ich dieses Thema googelte, fand ich keine einfachen und allgemeinen Ansätze zur Lösung dieses Problems (übrigens stieß ich nur auf Artikel über die Implementierung des Entwurfsmusters) und setzte mich dann hin, um meinen eigenen Dekorateur zu schreiben.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor ich jedoch zu einer direkten Beschreibung meiner Implementierung übergehe, möchte ich kurz darauf eingehen, wie Lambdas und Closures in C ++ angeordnet sind und was der Unterschied zwischen ihnen ist. </font><font style="vertical-align: inherit;">Machen Sie sofort einen Vorbehalt, dass ich standardmäßig C ++ 20 meine, wenn kein bestimmter Standard erwähnt wird. </font><font style="vertical-align: inherit;">Kurz gesagt, Lambdas sind anonyme Funktionen, und Schließungen sind Funktionen, die Objekte aus ihrer Umgebung verwenden. </font><font style="vertical-align: inherit;">So kann beispielsweise ab C ++ 11 ein Lambda wie folgt deklariert und aufgerufen werden:</font></font><br>
<br>
</p><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{<font></font>
    [] (<span class="hljs-keyword">int</span> a) <font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    }(<span class="hljs-number">10</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oder weisen Sie den Wert einer Variablen zu und rufen Sie ihn später auf.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{
    <span class="hljs-keyword">auto</span> lambda = [] (<span class="hljs-keyword">int</span> a) <font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
    lambda(<span class="hljs-number">10</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber was passiert beim Kompilieren und was ist Lambda? </font><font style="vertical-align: inherit;">Um in die interne Struktur des Lambda einzutauchen, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besuchen Sie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einfach die Website </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">cppinsights.io</font></a><font style="vertical-align: inherit;"> und führen Sie unser erstes Beispiel aus. </font><font style="vertical-align: inherit;">Als nächstes habe ich eine mögliche Schlussfolgerung angehängt:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> __<span class="hljs-title">lambda_60_19</span>
{</span>
<span class="hljs-keyword">public</span>: 
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> <span class="hljs-keyword">const</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>.<span class="hljs-keyword">operator</span>&lt;&lt;(a).<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">using</span> retType_60_19 = <span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">int</span>);
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">retType_60_19</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
    </span>{
        <span class="hljs-keyword">return</span> __invoke;<font></font>
    };<font></font>
    <font></font>
<span class="hljs-keyword">private</span>: 
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __invoke(<span class="hljs-keyword">int</span> a)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>.<span class="hljs-keyword">operator</span>&lt;&lt;(a).<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>);<font></font>
    }    <font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Kompilieren verwandelt sich das Lambda in eine Klasse oder vielmehr in einen Funktor (ein Objekt, für das der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operator ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definiert ist </font><font style="vertical-align: inherit;">) mit einem automatisch generierten eindeutigen Namen, der einen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operator () enthält</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der die Parameter übernimmt, die wir an unser Lambda übergeben haben und deren Körper enthält der Code, den unser Lambda ausführen muss. </font><font style="vertical-align: inherit;">Damit ist alles klar, aber was ist mit den beiden anderen Methoden, warum sind sie? </font><font style="vertical-align: inherit;">Der erste ist der Operator für das Umwandeln in einen Funktionszeiger, dessen Prototyp mit unserem Lambda übereinstimmt, und der zweite ist der Code, der ausgeführt werden soll, wenn unser Lambda nach vorläufiger Zuweisung zu seinem Zeiger aufgerufen wird, beispielsweise wie folgt:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">void</span> (*p_lambda) (<span class="hljs-keyword">int</span>) = lambda;<font></font>
p_lambda(<span class="hljs-number">10</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, es gibt weniger Rätsel, aber was ist mit Schließungen? </font><font style="vertical-align: inherit;">Schreiben wir das einfachste Beispiel für einen Abschluss, der die Variable „a“ als Referenz erfasst und um eins erhöht.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">auto</span> closure = [&amp;a] () { a += <span class="hljs-number">1</span>; };<font></font>
    closure();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, ist der Mechanismus zum Erstellen von Closures und Lambdas in C ++ nahezu identisch. Daher werden diese Konzepte häufig verwechselt und Lambdas und Closures werden einfach als Lambdas bezeichnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber zurück zur internen Darstellung des Abschlusses in C ++.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> __<span class="hljs-title">lambda_61_20</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span>
    </span>{<font></font>
        a += <span class="hljs-number">1</span>;<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> &amp; a;
<span class="hljs-keyword">public</span>:<font></font>
    __lambda_61_20(<span class="hljs-keyword">int</span> &amp; _a)<font></font>
    : a{_a}<font></font>
    {}<font></font>
};</code></pre><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen können, haben wir einen neuen, nicht standardmäßigen Konstruktor hinzugefügt, der unseren Parameter als Referenz verwendet und als Mitglied der Klasse speichert. </font><font style="vertical-align: inherit;">Aus diesem Grund müssen Sie beim Festlegen von [&amp;] oder [=] äußerst vorsichtig sein, da der gesamte Kontext innerhalb des Abschlusses gespeichert wird und dies aus dem Speicher heraus möglicherweise nicht optimal ist. </font><font style="vertical-align: inherit;">Außerdem haben wir den Operator des Castings auf einen Funktionszeiger verloren, da jetzt für seinen normalen Aufruf Kontext benötigt wird. </font><font style="vertical-align: inherit;">Und jetzt wird der obige Code nicht kompiliert:</font></font><br>
<br>
</p><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">auto</span> closure = [&amp;a] () { a += <span class="hljs-number">1</span>; };<font></font>
    closure();<font></font>
    <span class="hljs-keyword">void</span> (*ptr)(<span class="hljs-keyword">int</span>) = closure;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie den Abschluss jedoch noch irgendwo übergeben müssen, hat niemand die Verwendung der Funktion std :: abgebrochen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt; function = closure;<font></font>
function();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir grob herausgefunden haben, was Lambdas und Verschlüsse in C ++ sind, schreiben wir den Dekorateur direkt. </font><font style="vertical-align: inherit;">Aber zuerst müssen Sie sich für unsere Anforderungen entscheiden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Dekorateur sollte also unsere Funktion oder Methode als Eingabe verwenden, die benötigte Funktionalität hinzufügen (dies wird beispielsweise weggelassen) und beim Aufruf eine neue Funktion zurückgeben, die unseren Code und den Funktions- / Methodencode ausführt. An diesem Punkt wird jeder selbstbewusste Pythonist sagen: „Aber wie so! Der Dekorateur muss das ursprüngliche Objekt ersetzen und jeder Aufruf mit Namen sollte eine neue Funktion aufrufen! “ Nur dies ist die Hauptbeschränkung von C ++. Wir können den Benutzer nicht davon abhalten, die alte Funktion aufzurufen. Natürlich gibt es die Möglichkeit, die Adresse im Speicher abzurufen und zu mahlen (in diesem Fall führt der Zugriff darauf zu einer abnormalen Beendigung des Programms) oder den Textkörper durch eine Warnung zu ersetzen, dass er nicht in der Konsole verwendet werden sollte. Dies ist jedoch mit schwerwiegenden Konsequenzen verbunden. Wenn die erste Option überhaupt ziemlich schwierig erscheint,dann kann die zweite, wenn verschiedene Compiler-Optimierungen verwendet werden, ebenfalls zu einem Absturz führen, weshalb wir sie nicht verwenden werden. Auch die Verwendung von Makromagie halte ich hier für überflüssig.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schreiben wir also unseren Dekorateur. </font><font style="vertical-align: inherit;">Die erste Option, die mir in den Sinn kam, war folgende:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> Decorator<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ...Args&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">make</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;R(Args...)&gt;&amp; f)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Do something"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> [=](Args... args) <font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> f(<span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...);<font></font>
        };<font></font>
    }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sei eine Struktur mit einer statischen Methode, die std :: function verwendet und einen Abschluss zurückgibt, der dieselben Parameter wie unsere Funktion annimmt. Wenn sie aufgerufen wird, ruft sie einfach unsere Funktion auf und gibt ihr Ergebnis zurück. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns eine einfache Funktion erstellen, die wir dekorieren möchten.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"here"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und unser Haupt wird so aussehen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span>)&gt; f = myFunc;
    <span class="hljs-keyword">auto</span> decorated = Decorator::make(f);<font></font>
    decorated(<span class="hljs-number">10</span>);<font></font>
}</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles funktioniert, alles ist in Ordnung und im Allgemeinen Hurra. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich weist diese Lösung mehrere Probleme auf. </font><font style="vertical-align: inherit;">Beginnen wir in der richtigen Reihenfolge:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Code kann nur mit Version C ++ 14 und höher kompiliert werden, da der zurückgegebene Typ nicht im Voraus bekannt ist. </font><font style="vertical-align: inherit;">Leider muss ich damit leben und habe keine anderen Möglichkeiten gefunden.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für make muss die Funktion std :: übergeben werden, und die Übergabe einer Funktion nach Namen führt zu Kompilierungsfehlern. </font><font style="vertical-align: inherit;">Und das ist überhaupt nicht so bequem, wie wir möchten! </font><font style="vertical-align: inherit;">Wir können keinen Code wie diesen schreiben:</font></font><br>
<br>
<pre><code class="cpp hljs">Decorator::make([](){});<font></font>
Decorator::make(myFunc);<font></font>
<span class="hljs-keyword">void</span>(*ptr)(<span class="hljs-keyword">int</span>) = myFunc;<font></font>
Decorator::make(ptr);</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist auch nicht möglich, eine Klassenmethode zu dekorieren.</font></font><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher wurde nach einem kurzen Gespräch mit Kollegen die folgende Option für C ++ 17 und höher erfunden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> Decorator<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Function&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">make</span><span class="hljs-params">(Function&amp;&amp; func)</span>
    </span>{
        <span class="hljs-keyword">return</span> [func = <span class="hljs-built_in">std</span>::forward&lt;Function&gt;(func)] (<span class="hljs-keyword">auto</span> &amp;&amp; ...args) <font></font>
        {<font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Do something"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::invoke(<font></font>
                func,<font></font>
                <span class="hljs-built_in">std</span>::forward&lt;<span class="hljs-keyword">decltype</span>(args)&gt;(args)...<font></font>
            );<font></font>
        };<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Vorteile dieser speziellen Option sind, dass wir jetzt absolut jedes Objekt mit einem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operator ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dekorieren können </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">So können wir beispielsweise den Namen einer freien Funktion, eines Zeigers, eines Lambda, eines beliebigen Funktors, einer std :: -Funktion und natürlich einer Klassenmethode übergeben. </font><font style="vertical-align: inherit;">Im letzteren Fall muss beim Aufrufen der dekodierten Funktion auch ein Kontext übergeben werden.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendungsoptionen</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> decorated_1 = Decorator::make(myFunc);<font></font>
    decorated_1(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<font></font>
<font></font>
    <span class="hljs-keyword">auto</span> my_lambda = [] (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) <font></font>
    { <font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <font></font>
    };<font></font>
    <span class="hljs-keyword">auto</span> decorated_2 = Decorator::make(my_lambda);<font></font>
    decorated_2(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<font></font>
<font></font>
    <span class="hljs-keyword">int</span> (*ptr)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) = myFunc;
    <span class="hljs-keyword">auto</span> decorated_3 = Decorator::make(ptr);<font></font>
    decorated_3(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; fun = myFunc;
    <span class="hljs-keyword">auto</span> decorated_4 = Decorator::make(fun);<font></font>
    decorated_4(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);<font></font>
<font></font>
    <span class="hljs-keyword">auto</span> decorated_5 = Decorator::make(decorated_4);<font></font>
    decorated_5(<span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<font></font>
<font></font>
    <span class="hljs-keyword">auto</span> decorated_6 = Decorator::make(&amp;MyClass::func);<font></font>
    decorated_6(MyClass(<span class="hljs-number">10</span>));<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus kann dieser Code mit C ++ 14 kompiliert werden, wenn es eine Erweiterung für die Verwendung von std :: invoke gibt, die durch std :: __ invoke ersetzt werden muss. </font><font style="vertical-align: inherit;">Wenn es keine Erweiterung gibt, müssen Sie die Möglichkeit zum Dekorieren von Klassenmethoden aufgeben, und diese Funktionalität ist nicht mehr verfügbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das umständliche "std :: forward &lt;decltype (args)&gt; (args) ..." nicht zu schreiben, können Sie die mit C ++ 20 verfügbare Funktionalität nutzen und unser Lambda-Boilerplate erstellen!</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> Decorator<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Function&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">make</span><span class="hljs-params">(Function&amp;&amp; func)</span>
    </span>{
        <span class="hljs-keyword">return</span> [func = <span class="hljs-built_in">std</span>::forward&lt;Function&gt;(func)] <font></font>
        &lt;<span class="hljs-keyword">typename</span> ...Args&gt; (Args &amp;&amp; ...args) <font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::invoke(<font></font>
                func,<font></font>
                <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...<font></font>
            );<font></font>
        };<font></font>
    }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles ist absolut sicher und funktioniert sogar so, wie wir es wollen (oder zumindest so tun). </font><font style="vertical-align: inherit;">Dieser Code wurde sowohl für gcc- als auch für clang 10-x-Versionen kompiliert und ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier zu finden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es wird auch Implementierungen für verschiedene Standards geben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den nächsten Artikeln werden wir uns mit der kanonischen Implementierung von Dekoratoren am Python-Beispiel und ihrer internen Struktur befassen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de504682/index.html">Nostalgie Post: j2me, Schwerkraft trotzt, 64kb</a></li>
<li><a href="../de504686/index.html">Wie zeichnet man eine Katze?</a></li>
<li><a href="../de504688/index.html">Masken sind nutzlos: wissenschaftliche Kritik an der Sozialpolitik bei KOVID-19</a></li>
<li><a href="../de504690/index.html">Die Geschichte, wie ich Azure AD B2C für React and React Native konfiguriert habe Teil 3 (Tutorial)</a></li>
<li><a href="../de504692/index.html">ZFS-Grundlagen: Speicher und Leistung</a></li>
<li><a href="../de504696/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 513 (12.05.2020-18.05.2020)</a></li>
<li><a href="../de504698/index.html">Onboarding an einem Remote-Standort</a></li>
<li><a href="../de504700/index.html">Sowjetische Grafiktafel "Skizze"</a></li>
<li><a href="../de504702/index.html">Die Leute wollen kein Englisch</a></li>
<li><a href="../de504706/index.html">Automatische Wi-Fi-Energieverwaltung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>