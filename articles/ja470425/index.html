<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍟 🔎 ↪️ セルオートマトンのルール30の問題を解決するための30,000ドル-Stephen Wolframとの競争 📡 👱🏿 🛥️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私のブログの元の翻訳
 
 Steven Wolframのライブコンテストブロードキャスト（英語）
 コンテストのウェブサイト
 
  , « 30» — (. Wiki), ( ) 0-0-0-1-1-1-1-0, 30 .
 , ? — « 30»
 それはどのようにその何かをすることができ非常...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>セルオートマトンのルール30の問題を解決するための30,000ドル-Stephen Wolframとの競争</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wolfram/blog/470425/"><img src="https://habrastorage.org/webt/ry/bq/0l/rybq0lxvljpas9rj1uxfiwiwdnq.png"><br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私のブログの元の翻訳</font></font></a></b><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Steven Wolframのライブコンテストブロードキャスト（英語）</font></font></b><div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/1zyGu4Zxpb8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテストのウェブサイト</font></font></a></b><br>
<br>
<blockquote>  ,   « 30» —     (. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Wiki</a>),   (       )       0-0-0-1-1-1-1-0,     30    .</blockquote><br>
<h2>,    ? — « 30»</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはどのようにその何かをすることができ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に簡単には信じられないほど複雑な何かを作り出しますか</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？私が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初にルール30を知って</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からほぼ40年になります</font><font style="vertical-align: inherit;">が、それでも私は驚き、喜びます。長い間、それ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は科学</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">歴史の中で</font></a><font style="vertical-align: inherit;">私の個人的なお気に入りの発見になりました。長年</font><font style="vertical-align: inherit;">にわたり、それは私の世界観全体を変え、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">科学、技術、哲学などのさまざまな新しいタイプの理解に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">導いてくれました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、非常に長い年月を経ても、私たちがアクセスできないままであるルール30に関する多くの基本的な概念があります。そして、私はこれらの基本的なパターンの基本的なセットを識別するプロセスを刺激するために可能な限りのことをする時だと判断しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから、今日、私は規則30についての三つの主要な質問に答えるための賞金総額として申請者に$ 30,000提供</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">規則30は、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常にシンプル。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">黒と白のセル（セル）の行のシーケンスがあり、黒と白のセルの特定の行が与えられると、下の線のセルの色が決定され、各セルとその隣接するセルを個別に見て、次の単純な置換ルールがそれらに適用されます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5fe/dd5/f5b/5fedd5f5b8b914c9c8dded542e61841c.png"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>RulePlot[CellularAutomaton[30]]</code></div></div></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ビデオを見ると、数分でセルオートマトンの本質とルール30がわかります-翻訳者によるメモ]</font></font><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/6YeXkAq7EAY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つの黒いセルから始めるとどうなりますか？</font><font style="vertical-align: inherit;">[ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">白いセルの行が取られ、両側が無限で黒い四角形が1つある場合、上記のルールがこの行に適用され、新しい行が取得されるなど-翻訳者のメモ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]と仮定します（私自身が最初に行ったように）ルールは非常に単純であり、その作業に基づいて取得されるテンプレートもそれに応じて単純でなければなりません。</font><font style="vertical-align: inherit;">ただし、実験を行うと、アルゴリズムの最初の50ステップ後に何が起こるかがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8ee/cb0/ffc/8eecb0ffc1f78ab9483576561057a25e.png"><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>RulePlot[CellularAutomaton[30], {{1}, 0}, 50, Mesh -&gt; All, <br>
 ImageSize -&gt; Full]</code></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然、アルゴリズムの結果として、はるかに単純な数学的オブジェクトが得られると想定できます。ただし、これは最初の300ステップ後に発生します。</font></font><br>
<br>
<img alt="ルール30の最初の300ステップ—クリックして拡大" title="ルール30の最初の300ステップ—クリックして拡大" src="https://habrastorage.org/getpro/habr/post_images/e23/4e9/731/e234e9731e3f2a76bbdfc8c78d5a20df.png" width="620"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここから、特定の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ピラミッドの左側に</font></a><font style="vertical-align: inherit;">表示されることがわかり</font><font style="vertical-align: inherit;">ます。しかし同時に、このテンプレートの多くの側面は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランダムに形成され</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">もののように見えます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような単純なルールが最終的にそのような複雑なシステム動作につながる可能性があることは理解できません。これに基づいて、</font><font style="vertical-align: inherit;">考えられるすべてのコンピュータープログラムの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンピューティングユニバースで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、そのような動作は非常に一般的であり、さらにほとんどすべての場所で見られる</font><font style="vertical-align: inherit;">という結論に達し</font><font style="vertical-align: inherit;">ました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この仮説に基づいて、私は完全に科学の形成へのアプローチを開発しました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいタイプ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><font style="vertical-align: inherit;">単純なアルゴリズムの動作を監視する</font><font style="vertical-align: inherit;">という</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原則に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基づいてい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
徐々に、より多くの証拠がこれらの原則の蓄積でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、規則30に戻り、それによって何ができるのか、そして何を使用するのかを詳細に検討してみましょう。このアルゴリズムの動作について正確に何が言えるでしょうか？最も明白な質問への回答でさえ難しいことが判明することはすぐに明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何十年にもわたって答えが見つからなかった後でも、私はルール30についていくつかの具体的な質問をする時がきたと判断し、深刻な賞金でこの領域を刺激しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はすでに2007年に同じようなことをしようとしまし</font><font style="vertical-align: inherit;">た、特定のことに関する主要な質問に答えるため</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の賞</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">設定しました</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チューリングマシン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。そしてこの場合、結果は肯定的で、待つのにそれほど時間はかかりませんでした。わずか数か月後にこの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">賞が受賞しました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -可能な最も単純なユニバーサルチューリングマシンが何であるかを永久に確立し</font><font style="vertical-align: inherit;">、私が以前に個人的に開発した</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算等価の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">原則を</font></a><font style="vertical-align: inherit;">非常に説得力のある形で証明</font><font style="vertical-align: inherit;">しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルール30の競争は、再び主要なタスクを解決するという目標を設定します。つまり</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ルール30の動作はどれほど複雑か</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font><font style="vertical-align: inherit;">各タスクは、この領域で独自の方法で具体的に質問を投げかけます。</font><font style="vertical-align: inherit;">ルール30自体と同様に、元の設定ではすべて一見単純です。</font><font style="vertical-align: inherit;">それにもかかわらず、それらのいずれかに対する解決策は大きな成果となり、最終的には、コンピューティングユニバースの形成の特性の基本原則を明らかにするのに役立ち、ルール30の詳細をはるかに超え</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ています</font><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">これらの問題のそれぞれに35年以上取り組んで</font></a><font style="vertical-align: inherit;">き</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして今までずっと、これらの問題の少なくとも1つを最終的に解決することを目標として、一貫した数学的または計算的思考の枠組みの中で適切なアイデアを見つけようとしました。</font><font style="vertical-align: inherit;">今、私はこのプロセスを世界のコミュニティ全体に開放したいと思います。</font><font style="vertical-align: inherit;">ただし、これらの問題を解決するために何を達成できるか、この場合にどのような方法を使用できるかを知りたいと思います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルール30-解決すべきタスク</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルール30に基づく競争的タスクについては、ルール30のアルゴリズムの主要な機能の1つ、つまり</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中央列の</font></font></a></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">セルの形成の明らかなランダム性</font></b><font style="vertical-align: inherit;">を優先し</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">1つの黒いセルから始めて、この列のセルのカラー値のシーケンスを確認すると、それらがランダムであるという結論に達します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/843/516/3bc/8435163bc8a0b9c09c533e8e0d644658.png" alt="Arrayplot" title="Arrayplot" width="362" height="192"> <br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>ArrayPlot[<br>
 MapIndexed[If[#2[[2]] != 21, # /. {0 -&gt; 0.2, 1 -&gt; .6}, #] &amp;, <br>
 CellularAutomaton[30, {{1}, 0}, 20], {2}], Mesh -&gt; All]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、どのような意味で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「本当にランダム」なの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でしょうか。</font><font style="vertical-align: inherit;">そして、この仮定は証明できますか？</font><font style="vertical-align: inherit;">コンテストのフレームワークの各タスクは、独自のランダム性基準を使用し、この基準に従ってシーケンスがランダムかどうかを尋ねます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク1：中央の列は常に非周期的なままですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルール30の中央の列の始まりを考えてみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/72f/e64/303/72fe64303911057eb3b0be5e70cb310d.png" alt="Arrayplot" title="Arrayplot" width="620" height="23"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>ArrayPlot[List@CellularAutomaton[30, {{1}, 0}, {80, {{0}}}], <br>
 Mesh -&gt; True, ImageSize -&gt; Full]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この列の値が繰り返されていないことを見つけることは難しくありません-それは定期的ではありません。</font><font style="vertical-align: inherit;">しかし、問題は、中央の柱が周期的になるかどうかです。</font><font style="vertical-align: inherit;">ルール30を起動すると、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の10億ステップで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もシーケンスが定期的にならないことがわかり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これを確立して証明するために何をする必要があるか。</font><font style="vertical-align: inherit;">これは、このシーケンス</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の100万</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10億の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値が配置されて</font><font style="vertical-align: inherit;">いるリンク</font><font style="vertical-align: inherit;">です（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolframデータウェアハウス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク2：セルの各色（黒または白）は、中央の列に平均して同じくらいありそうですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ルール30アルゴリズムの中央の列のより多くのステップで黒と白のセルの数を順番に数えると得られるものです。 </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b0d/b01/226/b0db01226649be09633530c68c772a0f.png" alt="ルール30の中央の列にある黒と白のセルの数" title="ルール30の中央の列にある黒と白のセルの数" width="339" height="249"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>Dataset[{{1, 1, 0, ""}, {10, 7, 3, 2.3333333333333335}, {100, 52, 48, 1.0833333333333333}, <br>
 {1000, 481, 519, 0.9267822736030829}, {10000, 5032, 4968, 1.0128824476650564}, <br>
 {100000, 50098, 49902, 1.0039276982886458}, {1000000, 500768, 499232, <br>
 1.003076725850907}, {10000000, 5002220, 4997780, 1.0008883944471345}, <br>
 {100000000, 50009976, 49990024, 1.000399119632349}, <br>
 {1000000000, 500025038, 499974962, 1.0001001570154626}}]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果は黒と白のセルでほぼ同じです。</font><font style="vertical-align: inherit;">ここで問題となるのは（問題の問題）、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この関係がサイクルのステップ数の増加に伴って1に収束するかどうか</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の問題です</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題3：</font><font style="vertical-align: inherit;">中央の列の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目のセルの</font><font style="vertical-align: inherit;">計算は、</font><font style="vertical-align: inherit;">少なくとも約（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）回の演算ですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中央の列の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n番目の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セル</font><font style="vertical-align: inherit;">
を見つけるには、</font><font style="vertical-align: inherit;">常に</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステップ</font><font style="vertical-align: inherit;">に対してルール30を</font><font style="vertical-align: inherit;">実行し、下の図で強調表示されている菱形内のすべてのセルの値を計算します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/271/2e5/b4a/2712e5b4a3b27cfdf3522c6c39738468.png" alt="Arrayplot" title="Arrayplot" width="310" height="307"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>With[{n = 100}, <br>
 ArrayPlot[<br>
 MapIndexed[If[Total[Abs[#2 - n/2 - 1]] &lt;= n/2, #, #/4] &amp;, <br>
 CellularAutomaton[30, CenterArray[{1}, n + 1], n], {2}]]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これを直接行うと、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/7b1/a5d/319/7b1a5d319f09ce4dc0445b81a1d19dcc.png" width="10" height="31"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></sup><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">個の</font></em><font style="vertical-align: inherit;">個別のセル更新が</font><font style="vertical-align: inherit;">実行される</font><font style="vertical-align: inherit;">ため、必要な計算能力はO（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">として増加し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">この問題の問題は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">すべての中間計算なしに、または特にO（</font><em><font style="vertical-align: inherit;">n</font></em><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">未満の演算</font><font style="vertical-align: inherit;">で、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n番目の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルの</font><font style="vertical-align: inherit;">値を計算するためのより高速な（または最も高速な）方法が存在するかどうか</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Piを構成する数値</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルール30は、コンピューティングユニバースの製品です。コンピューティングのパラダイムによって提供される、新しい知的構造を持つ単純なプログラムの可能性の研究に基づくシステムです。</font><font style="vertical-align: inherit;">ただし</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ルール30のコンテストで私が定義したタスクには、数世紀にわたって存在していた数学の類似点があります</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">数Piの数値</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検討してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらの数値の動作は、ルール30アルゴリズムの中央の列にあるデータの生成に似ています。つまり、数値を計算するための特定のアルゴリズムがあり、一度定式化すると、どのタスクでもほぼランダムに見えます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/49e/ae6/17d/49eae617de3c0c9a864d4624413c6ce8.png" alt="N [Pi、85]" title="N [Pi、85]" width="620" height="13"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>N[Pi, 85]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アナログを少し近づけるために、基数2の数体系のPiの最初の数桁を次に示します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/18e/d4b/8f6/18ed4b8f6fd778443cc62470ea0956a9.png" alt="BaseForm [N [Pi、25]、2]" title="BaseForm [N [Pi、25]、2]" width="620" height="17"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>BaseForm[N[Pi, 25], 2]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルール30の中央列の最初の数ビットは次のとおりです。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/9e9/f64/a52/9e9f64a521480621d3adbb859609742a.png" alt="行[CellularAutomaton [30、{{1}、0}、{90、{{0}}}]" title="行[CellularAutomaton [30、{{1}、0}、{90、{{0}}}]" width="620" height="15"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>Row[CellularAutomaton[30, {{1}, 0}, {90, {{0}}}]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
楽しみのために、それらを10進数に変換できます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0df/d67/782/0dfd677828ca278c971d267948d88ad3.png" alt="N [FromDigits [{Flatten [CellularAutomaton [30、{{1}、0}、{500、{0}}]]、0}、2]、85]" title="N [FromDigits [{Flatten [CellularAutomaton [30、{{1}、0}、{500、{0}}]]、0}、2]、85]" width="620" height="16"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>N[FromDigits[{Flatten[CellularAutomaton[30, {{1}, 0}, {500, {0}}]], <br>
 0}, 2], 85]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、Piの数字を計算するためのよく知られたアルゴリズムは、ルール30の中央列にあるセルを生成するための比較的単純なルールよりもはるかに複雑です。では、Piの数値について何を知っていますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、それらが繰り返されないことを知っています。</font><font style="vertical-align: inherit;">これは、18世紀の60年代に証明されました。このとき</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Piは無理数</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;">ある</font></a><font style="vertical-align: inherit;">ことが示さ</font><font style="vertical-align: inherit;">れました。数が繰り返されるのは有理数だけだからです。</font><font style="vertical-align: inherit;">（で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1882、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またした</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Piは超越的であることを示し</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それが多項式の根を通って表現できないことです）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、問題2の定式化でどのような類推を引き出すことができますか？</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;">Pi</font></a><font style="vertical-align: inherit;">の数字のシーケンスで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じ頻度で異なる数値が発生しますか？現在までに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100兆を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超える</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;">2進数</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;">が計算され</font></a><font style="vertical-align: inherit;">、測定された数字の頻度は非常に近くなっています（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;">Piの</font></a><font style="vertical-align: inherit;">最初の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">40兆の2進数では</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゼロに対する単位</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;">の</font></a><font style="vertical-align: inherit;">比率は約0.99999998064です）。しかし、限界を計算するとき、周波数はまったく同じですか？科学者は数世紀にわたってこの質問をしてきましたが、これまでのところ、数学はそれに答えることができませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有理数の場合、それらが構成される数字のシーケンスは周期的であり、これらの数の数の中での相対的な出現頻度を決定するのは簡単です。ただし、他のすべての「自然に作成された（自然に作成された）」数値の数字のシーケンスでは、ほとんどの場合、数値に含まれる数字の頻度がどのような傾向にあるかについては、ほとんど何もわかっていません。実際、Piの数字（およびルール30の中央の列）は、「</font><font style="vertical-align: inherit;">個々の数字だけでなく、指定された長さの数字のブロックも同じ制限頻度で出会う」という意味で</font><font style="vertical-align: inherit;">「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」である</font><font style="vertical-align: inherit;">と想定するのは当然</font><font style="vertical-align: inherit;">です。そして、1930年代のこの主題に関する研究で指摘されたように、通常の数値の「デジタル構造（モデル）を構築する」ことはかなり可能です。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chemternounの定数</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">連続した整数の数字を組み合わせることによって得られることは、上記の推論の例です（同じことは、連続した整数の関数の値を組み合わせることによって、通常の数に基づいて得ることができます）：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/253/f93/8f3/253f938f3261e70f8985a49bf1158dde.png" alt="N [ChampernowneNumber [10]、85]" title="N [ChampernowneNumber [10]、85]" width="620" height="15"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>N[ChampernowneNumber[10], 85]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでのポイントは、標準の数学関数の組み合わせによって形成される「自然に構成された」数の場合、規則的な数列が見つかる単一の発見された例が見つからないということです。当然、最終的には、この規定は「規則性」が何を意味するかに依存し、ある段階で、タスクは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地球外情報の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一種の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">デジタルアナログ検索に</font></a><font style="vertical-align: inherit;">変わり</font><font style="vertical-align: inherit;">ます。ただし、たとえば、非常に明白な規則性を持つ一連の数値を持つ平方根の複雑な組み合わせを見つけることができないという証拠はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、最後に、Piの問題3の類似物を検討してください。</font><font style="vertical-align: inherit;">シーケンス内の要素を計算する明白な方法が一度に1ステップである規則30とは異なり、Piの桁を計算する従来の方法には、正確な数としてPiへの最良の近似を取得することが含まれます。</font><font style="vertical-align: inherit;">1910年に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラマヌジャン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって発明され</font><font style="vertical-align: inherit;">、1989年に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チュドノフスキー兄弟によって</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改良さ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;">れ</font></a><font style="vertical-align: inherit;">た標準（「奇妙な」）シリーズ</font><font style="vertical-align: inherit;">では、このシリーズの最初の数人のメンバーは次の概算を示します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ee8/35a/8b9/ee835a8b9141e62f63f3b764130d6539.png" alt="標準シリーズ" title="標準シリーズ" width="474" height="140"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>Style[Table[N[(12*\!\(<br>
\*UnderoverscriptBox[\(\[Sum]\), \(k = 0\), \(n\)]<br>
\*FractionBox[\(<br>
\*SuperscriptBox[\((\(-1\))\), \(k\)]*\(\((6*k)\)!\)*\((13591409 + <br>
 545140134*k)\)\), \(\(\((3*k)\)!\) <br>
\*SuperscriptBox[\((\(k!\))\), \(3\)]*<br>
\*SuperscriptBox[\(640320\), \(3*k + 3/2\)]\)]\))^-1, 100], {n, 10}] //<br>
 Column, 9]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">桁目</font><font style="vertical-align: inherit;">を見つけるには何回の操作が必要なの</font><font style="vertical-align: inherit;">でしょうか。行に必要な用語の数はO（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）です。ただし、各条件は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">桁の精度で</font><font style="vertical-align: inherit;">計算する必要があります</font><font style="vertical-align: inherit;">。これには、少なくともO（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の別個の計算操作</font><font style="vertical-align: inherit;">が必要</font><font style="vertical-align: inherit;">です。つまり、一般的な計算ワークロードはO（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">よりも大きくなり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1990年代までは</font><font style="vertical-align: inherit;">、Pi </font><font style="vertical-align: inherit;">の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">桁目を計算するには、以前の桁をすべて</font><font style="vertical-align: inherit;">計算する方法はないと想定されて</font><font style="vertical-align: inherit;">いました。しかし、1995年に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simon Pluff</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、確率はあるものの、実際には</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前のものを計算せずにth桁。</font><font style="vertical-align: inherit;">そして、これは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目の桁がAbout（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）演算</font><font style="vertical-align: inherit;">よりも小さい</font><font style="vertical-align: inherit;">と考えるかもしれませんが</font><font style="vertical-align: inherit;">、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -tsifrの</font><font style="vertical-align: inherit;">精度で計算を実行する必要があるという事実</font><font style="vertical-align: inherit;">は、少なくとも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">約（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果、アナロジー、直感</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク1：中央の列は常に非周期的なままですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルール30コンテストの3つの賞のうち、これはこの問題の解決におけるほとんどの進歩がすでに達成されているものです。</font><font style="vertical-align: inherit;">規則30の中央の列が周期的になるかどうかはまだ不明なので、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エリカジェン</font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1986年</font><font style="vertical-align: inherit;">に2つの列が周期的になることはできないことを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;">示し</font></a><font style="vertical-align: inherit;">ました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして実際、これはそうであり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ある列が別の列の個々のセルと組み合わされて周期的であることができない</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という事実に賛成することも</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">できます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列のペアの証明は、ルール30の機能を使用します。ルールの構造を検討してください。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5fa/ca7/858/5faca785893d90e7969ef2a4dad73c58.png" alt="RulePlot [CellularAutomaton [30]]" title="RulePlot [CellularAutomaton [30]]" width="368" height="45"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>RulePlot[CellularAutomaton[30]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セルの3つのトリプルごとに、ルールによってその中央のセルの色が決まると簡単に言うことができますが、ルール30では、ルールを横に効果的に実行することもできます。右側と上のセルを考慮すると、左側のセルの色を一意に決定することもできます。</font><font style="vertical-align: inherit;">つまり、隣接する2つの列を取得する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、左側のテンプレート全体を復元できます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b04/fa8/308/b04fa830855515a9902b5ee6d732a80d.png" alt="Arrayplot" title="Arrayplot" width="620" height="64"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>GraphicsRow[<br>
 ArrayPlot[#, PlotRange -&gt; 1, Mesh -&gt; All, PlotRange -&gt; 1, <br>
 Background -&gt; LightGray, <br>
 ImageSize -&gt; {Automatic, 80}] &amp; /@ (PadLeft[#, {Length[#], 10}, <br>
 10] &amp; /@ <br>
 Module[{data = {{0, 1}, {1, 1}, {0, 0}, {0, 1}, {1, 1}, {1, <br>
 0}, {0, 1}, {1, 10}}}, <br>
 Flatten[{{data}, <br>
 Table[Join[<br>
 Table[Module[{p, q = data[[n, 1]], r = data[[n, 2]], <br>
 s = data[[n + 1, 1]] },<br>
 p = Mod[-q - r - q r + s, 2];<br>
 PrependTo[data[[n]], p]], {n, 1, Length[data] - i}], <br>
 PrependTo[data[[-#]], 10] &amp; /@ Reverse[Range[i]]], {i, 7}]}, <br>
 1]])]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、列に周期的な構造がある場合、復元されたテンプレートも周期的である必要があります。したがって、たとえば、構造上、少なくとも初期条件は明らかに周期的ではないため、両方の列を周期的にすることはできません。列が隣接しておらず、両方の列のすべてのセルが不明な場合も、同じことが言えます。ただし、中央列などの単一列にこの規定を配布する既知の方法はないため、ルール30に基づくコンテストの最初のタスクは解決されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それを解決するために何が使用できるのでしょうか？中央の列が最終的に周期的であることがわかった場合は、それを計算するだけです。最初の数十億のステップでは周期的ではないことはわかっていますが、少なくとも数兆のステップを持つ遷移プロセスがあり、その後周期的になると想定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは信じられますか？</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">過渡現象が発生します</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -理論的には（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チューリングマシンを停止するという</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古典的な</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">問題の</font></a><font style="vertical-align: inherit;">ように）、それらは任意の長さになることさえあります。ここでは、検索中に見つかったいくつかの例を見てみましょう- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能な4色のルール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（共通コード150898）。</font><font style="vertical-align: inherit;">200ステップ実行するとしましょう。ご覧のとおり、中央の列は完全にランダムです。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/387/480/11a/38748011a2611f16ce9d604ab2fb7ca9.png" alt="ルール150898" title="ルール150898" width="620" height="416"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>ArrayPlot[<br>
 CellularAutomaton[{150898, {4, 1}, 1}, {{1}, 0}, {200, 150 {-1, 1}}],<br>
 ColorRules -&gt; {0 -&gt; Hue[0.12, 1, 1], 1 -&gt; Hue[0, 0.73, 0.92], <br>
 2 -&gt; Hue[0.13, 0.5, 1], 3 -&gt; Hue[0.17, 0, 1]}, <br>
 PixelConstrained -&gt; 2, Frame -&gt; False]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
500ステップ後、テンプレート全体は完全にランダムに見えます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d33/83e/7d0/d3383e7d0efa08c9e0526c96d2ddb563.png" alt="ルール150898" title="ルール150898" width="620" height="517"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>ArrayPlot[<br>
 CellularAutomaton[{150898, {4, 1}, 1}, {{1}, 0}, {500, 300 {-1, 1}}],<br>
 ColorRules -&gt; {0 -&gt; Hue[0.12, 1, 1], 1 -&gt; Hue[0, 0.73, 0.92], <br>
 2 -&gt; Hue[0.13, 0.5, 1], 3 -&gt; Hue[0.17, 0, 1]}, Frame -&gt; False, <br>
 ImagePadding -&gt; 0, PlotRangePadding -&gt; 0, PixelConstrained -&gt; 1]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、中央の列に近づくと、驚くべきことが起こります：251ステップ後、中央の列は固定値（または、少なくとも100万以上のステップに固定）に生まれ変わるようです：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/75d/f1a/aba/75df1aabaee33f921d9012f21e8e5686.png" alt="ルール150898" title="ルール150898" width="620" height="415"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>Grid[{ArrayPlot[#, Mesh -&gt; True, <br>
 ColorRules -&gt; {0 -&gt; Hue[0.12, 1, 1], 1 -&gt; Hue[0, 0.73, 0.92], <br>
 2 -&gt; Hue[0.13, 0.5, 1], 3 -&gt; Hue[0.17, 0, 1]}, ImageSize -&gt; 38,<br>
 MeshStyle -&gt; Lighter[GrayLevel[.5, .65], .45]] &amp; /@ <br>
 Partition[<br>
 CellularAutomaton[{150898, {4, 1}, 1}, {{1}, 0}, {1400, {-4, 4}}],<br>
 100]}, Spacings -&gt; .35]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルール30でも同じ移行が起こりますか？</font><font style="vertical-align: inherit;">ルール30のパターンを検討し、左側の対角線に周期性があるパターンを選択します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/df0/877/d53/df0877d53e1fd0b0d9501383ed3fbcc7.png" alt="Arrayplot" title="Arrayplot" width="579" height="289"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>steps = 500;<br>
 diagonalsofrule30 = <br>
 Reverse /@ <br>
 Transpose[<br>
 MapIndexed[RotateLeft[#1, (steps + 1) - #2[[1]]] &amp;, <br>
 CellularAutomaton[30, {{1}, 0}, steps]]];<br>
<br>
diagonaldataofrule30 = <br>
 Table[With[{split = <br>
 Split[Partition[Drop[diagonalsofrule30[[k]], 1], 8]], <br>
 ones = Flatten[<br>
 Position[Reverse[Drop[diagonalsofrule30[[k]], 1]], <br>
 1]]}, {Length[split[[1]]], split[[1, 1]], <br>
 If[Length[split] &gt; 1, split[[2, 1]], <br>
 Length[diagonalsofrule30[[k]]] - Floor[k/2]]}], {k, 1, <br>
 2 steps + 1}];<br>
<br>
transientdiagonalrule30 = %;<br>
<br>
transitionpointofrule30 = <br>
 If[IntegerQ[#[[3]]], #[[3]], <br>
 If[#[[1]] &gt; 1, <br>
 8 #[[1]] + Count[Split[#[[2]] - #[[3]]][[1]], 0] + 1, 0] ] &amp; /@ <br>
 diagonaldataofrule30;<br>
<br>
decreasingtransitionpointofrule30 = <br>
 Append[Min /@ Partition[transitionpointofrule30, 2, 1], 0];<br>
<br>
transitioneddiagonalsofrule30 = <br>
 Table[Join[<br>
 Take[diagonalsofrule30[[n]], <br>
 decreasingtransitionpointofrule30[[n]]] + 2, <br>
 Drop[diagonalsofrule30[[n]], <br>
 decreasingtransitionpointofrule30[[n]]]], {n, 1, 2 steps + 1}];<br>
<br>
transientdiagonalrule30 = <br>
 MapIndexed[RotateRight[#1, (steps + 1) - #2[[1]]] &amp;, <br>
 Transpose[Reverse /@ transitioneddiagonalsofrule30]];<br>
 <br>
 smallertransientdiagonalrule30 = <br>
 Take[#, {225, 775}] &amp; /@ Take[transientdiagonalrule30, 275];<br>
<br>
Framed[ArrayPlot[smallertransientdiagonalrule30, <br>
 ColorRules -&gt; {0 -&gt; White, 1 -&gt; Gray, 2 -&gt; Hue[0.14, 0.55, 1], <br>
 3 -&gt; Hue[0.07, 1, 1]}, PixelConstrained -&gt; 1,<br>
 Frame -&gt; None,<br>
 ImagePadding -&gt; 0, ImageMargins -&gt; 0,<br>
 PlotRangePadding -&gt; 0, PlotRangePadding -&gt; Full<br>
 ], FrameMargins -&gt; 0, FrameStyle -&gt; GrayLevel[.75]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どうやら、混乱の左側にある順序を右側に分ける境界があります。</font><font style="vertical-align: inherit;">そして、少なくとも最初の100,000ステップほど、境界線は各ステップで平均して約0.252ステップ左にシフトしているように見えます- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランダムな偏差があり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f42/a47/b52/f42a47b522b2195312ef3766ea97b709.png" alt="ListLinePlot" title="ListLinePlot" width="620" height="166"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>data = CloudGet[<br>
 CloudObject[<br>
 "https://www.wolframcloud.com/obj/bc470188-f629-4497-965d-\<br>
a10fe057e2fd"]];<br>
<br>
ListLinePlot[<br>
 MapIndexed[{First[#2], -# - .252 First[#2]} &amp;, <br>
 Module[{m = -1, w}, <br>
 w = If[First[#] &gt; m, m = First[#], m] &amp; /@ data[[1]]; m = 1;<br>
 Table[While[w[[m]] &lt; i, m++]; m - i, {i, 100000}]]], <br>
 Filling -&gt; Axis, AspectRatio -&gt; 1/4, MaxPlotPoints -&gt; 10000, <br>
 Frame -&gt; True, PlotRangePadding -&gt; 0, AxesOrigin -&gt; {Automatic, 0}, <br>
 PlotStyle -&gt; Hue[0.07`, 1, 1], <br>
 FillingStyle -&gt; Directive[Opacity[0.35`], Hue[0.12`, 1, 1]]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、どのようにしてこれらの変動が重要でなくなる時点で最終的にどのようにして、左側の次数が中央列と交差するように強制し、テンプレート全体を定期的にすることさえできるのでしょうか？</font><font style="vertical-align: inherit;">利用可能なデータから判断すると、仮定はありそうにありませんが、これをどのように決定できるかは正確には言えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これは、非常に長い「トランジェント」を持つシステムの存在を示すまさにその場合です。</font><font style="vertical-align: inherit;">今素数の分布を考慮し、計算</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LogIntegral</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PrimePi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/70b/f25/322/70bf253223dfca57c0556fbc788b24c3.png" alt="DiscretePlot" title="DiscretePlot" width="620" height="171"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>DiscretePlot[LogIntegral[n] - PrimePi[n], {n, 10000}, <br>
 Filling -&gt; Axis,<br>
 Frame -&gt; True, PlotRangePadding -&gt; 0, AspectRatio -&gt; 1/4, <br>
 Joined -&gt; True, PlotStyle -&gt; Hue[0.07`, 1, 1], <br>
 FillingStyle -&gt; Directive[Opacity[0.35`], Hue[0.12`, 1, 1]]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、変動がありますが、この図では、この差が常にプラスの領域にあるように見えます。そしてこれは、例えば、ラマヌジャンが議論していた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことですが</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、結局</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;">これはそうではないことがわかりました</font></a><font style="vertical-align: inherit;">。当初、彼が失敗した場所の境界は、その当時、天文学的に大きかった（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スカイブ数</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">964</font></font></sup></sup></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。そして</font><font style="vertical-align: inherit;">、差が負である</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明示的な値をまだ誰も見つけていませんが、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">317</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">までは存在する必要がある</font><font style="vertical-align: inherit;">ことが知られてい</font><font style="vertical-align: inherit;">ます（最終的に差は負になります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は規則30の中央の列にはそのようなことは何も起こらないという意見を形成しましたが、これまでのところ、これが不可能であることを示す証拠はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
規則30の中央列の規則性を明らかにすることで周期性を証明することは基本的に可能であるが、非周期性に対してはそのようなことは何もできないと仮定することが可能であることに注意すべきである。</font><font style="vertical-align: inherit;">非常に規則的ではあるが、中央の列が非周期的であるパターンがあることが知られています。</font><font style="vertical-align: inherit;">このような例の主なクラスは、ネストされたテンプレートです。</font><font style="vertical-align: inherit;">たとえば、次の図はルール161の非常に単純な図で、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 2 </font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kの</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ときに中央の列に白いセルが表示されます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a5f/b8d/875/a5fb8d875d2af2d543852f9d158d7af9.png" alt="ルール161" title="ルール161" width="620" height="156"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>GraphicsRow[<br>
 ArrayPlot[CellularAutomaton[161, {{1}, 0}, #]] &amp; /@ {40, 200}]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ここで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（二ネイバーの2色の規則69540422から）わずかに複雑な例</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中央の列がである、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThueMorse配列</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThueMorse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/94b/4b3/25a/94b4b325a83cbd44ff3e37f0cf70ed9b.png" alt="木モールスシーケンス" title="木モールスシーケンス" width="617" height="157"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>GraphicsRow[<br>
 ArrayPlot[<br>
 CellularAutomaton[{69540422, 2, 2}, {{1}, <br>
 0}, {#, {-#, #}}]] &amp; /@ {40, 400}]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thue – Morseシーケンスは、置換を連続して適用することによって生成されると想定できます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/71b/2f4/877/71b2f48772278798384acd24c732fb18.png" alt="RulePlot" title="RulePlot" width="195" height="37"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>RulePlot[SubstitutionSystem[{0 -&gt; {0, 1}, 1 -&gt; {1, 0}}], <br>
 Appearance -&gt; "Arrow"]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ターン</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、n-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この順に番目の用語は次のように与えられる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュレーション</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DigitCount</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、2、1] 2] -このオブジェクトは、周期的ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルール30の中央の列は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">置換</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって生成できるの</font><font style="vertical-align: inherit;">でしょうか？これがそうである場合、私はこの事実に驚かれるでしょう（ただし</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、非常に複雑な代替システムが現れると自然な例があるように見えます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）が、これの証拠がない限り。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルール30のすべての競合タスクは、無数のセルで実行されるアルゴリズムの公式化で考慮されることに注意してください。しかし、あなた</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">だけ</font></a><font style="vertical-align: inherit;">を考えようとする</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">と</font></a><font style="vertical-align: inherit;">どうなりますか</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n個の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、たとえば、周期的な境界条件（つまり、右端のセルの右隣を左端のセルとし、その逆も同様）</font><font style="vertical-align: inherit;">さらに、</font><font style="vertical-align: inherit;">システム</font><font style="vertical-align: inherit;">には2</font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nの</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全な状態</font><font style="vertical-align: inherit;">が存在する</font><font style="vertical-align: inherit;">可能性</font><font style="vertical-align: inherit;">があることは明らかであり</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">どの状態がどの状態に発展するかを示す</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遷移状態図</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作成</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">する</font></a><font style="vertical-align: inherit;">ことが可能</font><font style="vertical-align: inherit;">です。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 5の</font><font style="vertical-align: inherit;">ダイアグラムを考えてみ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/41d/49b/159/41d49b15998b88e4560b83b8331aa552.png" alt="グラフ" title="グラフ" width="350" height="337"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>Graph[# -&gt; CellularAutomaton[30][#] &amp; /@ Tuples[{1, 0}, 4], <br>
 VertexLabels -&gt; ((# -&gt; <br>
 ArrayPlot[{#}, ImageSize -&gt; 30, Mesh -&gt; True]) &amp; /@ <br>
 Tuples[{1, 0}, 4])]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 5から</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 11の場合です。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/64b/706/137/64b706137561e64636cb1c24ef42ac93.png" alt="グリッド" title="グリッド" width="620" height="305"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>Row[Table[<br>
 Framed[Graph[# -&gt; CellularAutomaton[30][#] &amp; /@ <br>
 Tuples[{1, 0}, n]]], {n, 4, 11}]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その構造は、過渡状態としてのみ現れる状態のグループと、サイクルにある他の状態が存在するという事実にあります。</font><font style="vertical-align: inherit;">サイクルが2 </font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より長くなることは避けられません</font><font style="vertical-align: inherit;">（実際、対称性の考慮事項で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、常にわずかに小さいはず</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、サイズ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列では</font><em><font style="vertical-align: inherit;">、</font></em><font style="vertical-align: inherit;">ルール30は常に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em></sup></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">未満の</font></a><font style="vertical-align: inherit;">周期で周期的になる動作を示す必要</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">があり</font></a><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">以下は、</font><font style="vertical-align: inherit;">1つの黒いセルの初期条件から始まる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">既存の期間</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の長さです</font><font style="vertical-align: inherit;">（グラフは対数スケールで作成されています）。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d92/e3f/84f/d92e3f84f989261b59e3135500ea2610.png" alt="Listlogplot" title="Listlogplot" width="620" height="219"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>ListLogPlot[<br>
 Normal[Values[<br>
 ResourceData[<br>
 "Repetition Periods for Elementary Cellular Automata"][<br>
 Select[#Rule == 30 &amp;]][All, "RepetitionPeriods"]]], <br>
 Joined -&gt; True, Filling -&gt; Bottom, Mesh -&gt; All, <br>
 MeshStyle -&gt; PointSize[.008], AspectRatio -&gt; 1/3, Frame -&gt; True, <br>
 PlotRange -&gt; {{47, 2}, {0, 10^10}}, PlotRangePadding -&gt; .1, <br>
 PlotStyle -&gt; Hue[0.07`, 1, 1], <br>
 FillingStyle -&gt; Directive[Opacity[0.35`], Hue[0.12`, 1, 1]]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、少なくともこれらの</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値の場合、</font><font style="vertical-align: inherit;">周期は関数2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.63 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によってかなりよく近似され</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">そして、はい、少なくともこれらすべての場合において、中央の列の周期は、セルオートマトンの一般的な進化の周期と同じです。</font><font style="vertical-align: inherit;">しかし、これらの結果は、無限のサイズのセルのセットに基づいて得られた結論を広める場合、有限のサイズに対して何を意味するのでしょうか。</font><font style="vertical-align: inherit;">答えは明白で簡単ではありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク2：平均して、各セルの色は中央の列で同じ頻度で一致するかどうか。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルール30の中央列の10,000ステップでのゼロからのユニット数の偏差のグラフを考えてみます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5fd/74b/df9/5fd74bdf908b5f1ef931fecfef14e2c6.png" alt="ListLinePlot" title="ListLinePlot" width="620" height="165"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>RListLinePlot[<br>
 Accumulate[2 CellularAutomaton[30, {{1}, 0}, {10^4 - 1, {{0}}}] - 1],<br>
 AspectRatio -&gt; 1/4, Frame -&gt; True, PlotRangePadding -&gt; 0, <br>
 AxesOrigin -&gt; {Automatic, 0}, Filling -&gt; Axis, <br>
 PlotStyle -&gt; Hue[0.07`, 1, 1], <br>
 FillingStyle -&gt; Directive[Opacity[0.35`], Hue[0.12`, 1, 1]]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
百万ステップで：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/321/52a/44d/32152a44d911e2e27f5408674ced5e7b.png" alt="ListLinePlot" title="ListLinePlot" width="620" height="184"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>ListLinePlot[<br>
 Accumulate[<br>
 2 ResourceData[<br>
 "A Million Bits of the Center Column of the Rule 30 Cellular Automaton"] - 1], Filling -&gt; Axis, Frame -&gt; True, PlotRangePadding -&gt; 0, AspectRatio -&gt; 1/4, MaxPlotPoints -&gt; 1000, PlotStyle -&gt; Hue[0.07`, 1, 1], <br>
 FillingStyle -&gt; Directive[Opacity[0.35`], Hue[0.12`, 1, 1]]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして10億ステップ：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/483/f17/8fa/483f178fad9e71f2d1f72fd56c6f8e78.png" alt="ListLinePlot" title="ListLinePlot" width="620" height="165"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>data=Flatten[IntegerDigits[#,2,8]&amp;/@Normal[ResourceData["A <br>
Billion Bits of the Center Column of the Rule 30 Cellular Automaton"]]];<br>
data=Accumulate[2 data-1];<br>
sdata=Downsample[data,10^5];<br>
ListLinePlot[Transpose[{Range[10000] 10^5,sdata}],Filling-&gt;Axis,Frame-&gt;True,PlotRangePadding-&gt;0,AspectRatio-&gt;1/4,MaxPlotPoints-&gt;1000,PlotStyle-&gt;Hue[0.07`,1,1],FillingStyle-&gt;Directive[Opacity[0.35`],Hue[0.12`,1,1]]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのデータに基づいて、0（ゼロ）に対して1（ユニット）が過剰になる場合、またはその逆の場合があることがわかりますが、10億ステップに近づくと、ユニットの数は、少なくとも0を上回ります。この瞬間。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユニットの総数とゼロの総数の比率を計算してみましょう。</font><font style="vertical-align: inherit;">これは、10,000ステップ後に取得した画像です。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5d9/36b/09b/5d936b09b9d44629a03b54a2c2639094.png" alt="ListLinePlot" title="ListLinePlot" width="620" height="168"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>Quiet[ListLinePlot[<br>
 MapIndexed[#/(First[#2] - #) &amp;, <br>
 Accumulate[CellularAutomaton[30, {{1}, 0}, {10^4 - 1, {{0}}}]]], <br>
 AspectRatio -&gt; 1/4, Filling -&gt; Axis, AxesOrigin -&gt; {Automatic, 1}, <br>
 Frame -&gt; True, PlotRangePadding -&gt; 0, PlotStyle -&gt; Hue[0.07`, 1, 1],<br>
 FillingStyle -&gt; Directive[Opacity[0.35`], Hue[0.12`, 1, 1]], <br>
 PlotRange -&gt; {Automatic, {.88, 1.04}}]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは値1に近づいていると思いますか？</font><font style="vertical-align: inherit;">言うのは難しいです... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう少し先に進みましょう、そしてこれが私たちが見るものです：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8c9/2bc/353/8c92bc3538d581f5b1bb97f0f964ab03.png" alt="ListLinePlot" title="ListLinePlot" width="620" height="169"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>Quiet[ListLinePlot[<br>
 MapIndexed[#/(First[#2] - #) &amp;, <br>
 Accumulate[CellularAutomaton[30, {{1}, 0}, {10^5 - 1, {{0}}}]]], <br>
 AspectRatio -&gt; 1/4, Filling -&gt; Axis, AxesOrigin -&gt; {Automatic, 1}, <br>
 Frame -&gt; True, PlotRangePadding -&gt; 0, PlotStyle -&gt; Hue[0.07`, 1, 1],<br>
 FillingStyle -&gt; Directive[Opacity[0.35`], Hue[0.12`, 1, 1]], <br>
 PlotRange -&gt; {Automatic, {.985, 1.038}}]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
偏差は小さくなっていますが、最終的に何が起こるかを言うのはまだ難しいです。</font><font style="vertical-align: inherit;">単位とゼロの数の比率の偏差が、10億ステップのグラフで1から構築された場合、体系的に減少していることがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/549/676/86e/54967686e06c2346d2e15a3ec943f1ab.png" alt="ListLogLogPlot" title="ListLogLogPlot" width="605" height="166"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>accdata=Accumulate[Flatten[IntegerDigits[#,2,8]&amp;/@Normal[ResourceData["A<br>
Billion Bits of the Center Column of the Rule 30 Cellular Automaton"]]]];<br>
<br>
diffratio=FunctionCompile[Function[Typed[arg,TypeSpecifier["PackedArray"]["MachineInteger",1]],MapIndexed[Abs[N[#]/(First[#2]-N[#])-1.]&amp;,arg]]];<br>
<br>
data=diffratio[accdata];<br>
<br>
ListLogLogPlot[Join[Transpose[{Range[3,10^5],data[[3;;10^5]]}],Transpose[{Range[10^5+1000,10^9,1000],data[[10^5+1000;;10^9;;1000]]}]],Joined-&gt;True,AspectRatio-&gt;1/4,Frame-&gt;True,Filling-&gt;Axis,PlotRangePadding-&gt;0,PlotStyle-&gt;Hue[0.07`,1,1],FillingStyle-&gt;Directive[Opacity[0.35`],Hue[0.12`,1,1]]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この傾向が続くことをどのように確認できますか？現時点では、そのような確信は持てません。そして確かに、物事はかなり悪いことが判明する可能性があります。おそらく、ゼロに対する単位の変動が大きくなるため、長いシーケンスで平均をとっても、一般的な比率が特定の値に収束することはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しになりますが、これが規則30の中央列で発生するかどうかは疑問ですが、証拠がなければ、確実に知ることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、黒と白のセルの出現頻度を検討しますが、ここで明白な一般化は、代わりに長さ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のセルのブロックの頻度の質問をすることです</font><font style="vertical-align: inherit;">。すべての2 </font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのようなブロックは、同じ限界周波数を持っているか、持っていません。</font><font style="vertical-align: inherit;">または、これらのすべてのブロックが今までに見つかったかどうか、つまり、1つのブロックが十分に遠くにある場合、ルール30の中央の列には、長さ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意のシーケンスが含まれます</font><font style="vertical-align: inherit;">（文学作品のビットごとの表現としましょう） ）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後の手段として、ここで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">経験的な証拠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を得ることができます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえば、少なくとも</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 22までは、すべての2 </font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーケンスが存在する場所があり、これを確認するために必要なステップ数を</font><font style="vertical-align: inherit;">次に示し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/19e/d52/9d8/19ed529d8268e1b4dab3778f29945528.png" alt="Listlogplot" title="Listlogplot" width="620" height="173"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>ListLogPlot[{3, 7, 13, 63, 116, 417, 1223, 1584, 2864, 5640, 23653, <br>
 42749, 78553, 143591, 377556, 720327, 1569318, 3367130, 7309616, <br>
 14383312, 32139368, 58671803}, Joined -&gt; True, AspectRatio -&gt; 1/4, <br>
 Frame -&gt; True, Mesh -&gt; True, <br>
 MeshStyle -&gt; <br>
 Directive[{Hue[0.07, 0.9500000000000001, 0.99], PointSize[.01]}], <br>
 PlotTheme -&gt; "Detailed", <br>
 PlotStyle -&gt; Directive[{Thickness[.004], Hue[0.1, 1, 0.99]}]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ長さのブロックでは許容できる結果が得られますが、大きなブロックでは失敗することに注意してください。たとえば、上記のThue – Morseシーケンス</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ゼロと単位の等しい頻度を持っていますが、ペアは同じ頻度で出会うことはなく、同じ要素のトリプルが単に出会うことはありません</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従来の数学、特に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的システム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">理論で</font></a><font style="vertical-align: inherit;">は、アプローチの1つは、1つのセルで構成される初期条件からの進化だけでなく、考えられる</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">すべての</font></a><font style="vertical-align: inherit;">初期条件からの進化を考慮</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">することです。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この場合、テンプレートがすべての可能な初期条件から等しい確率で展開する場合、ルール30によって生成されるセル列には実際</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に同じ頻度の各ブロックが含まれ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ますが、初期条件の異なる分布に同じものを設定した場合、の場合、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果は異なる結果</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">になります。単細胞の初期条件の特定のケースに対するこのタイプの分析の意味は何ですか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異なる頻度の異なるブロックが規則30の中央の列に表示された場合、これは中央の列が「</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ランダムで</font></a><font style="vertical-align: inherit;">は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ない</font></a><font style="vertical-align: inherit;">」ことをすぐに示します。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」、または言い換えれば、少なくとも統計的予測に使用できる統計パターンがあります。もちろん、中央の列は原則として「予測可能」です。ルール30アルゴリズムを実行してそれを計算する必要があるだけですが、問題は中央の列の値のみを考慮して、それらを個別に予測または絞る方法があるかどうかです。 Rule 30テンプレート全体で任意の数のステップを生成するよりも計算コストが低い</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまなデータ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">圧縮</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズム</font><font style="vertical-align: inherit;">または</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">統計分析の</font></a><font style="vertical-align: inherit;">起動を想像してください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、これらのアルゴリズムがシーケンス内のパターンを見つけることができるかどうかについて自分自身に質問します。特にルール30の一般的な計算機能について考え始めると</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、可能な分析アルゴリズムの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">範囲に</font></a><font style="vertical-align: inherit;">制限があり、ルール30の進化に関連する必要な計算能力をどれだけ削減できる</font><font style="vertical-align: inherit;">かを証明するものがあると想定</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">できます</font></a><font style="vertical-align: inherit;">。しかし、上記のすべてがあったとしても、黒と白のセルの相対頻度の特定のケースについて何かを言うことは依然として深刻な問題になる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、この問題のもう1つの数学的な類似点について言及するのが適切です。 Rule 30テンプレートの行の値の処理を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、実数の数字</font></a><font style="vertical-align: inherit;">として考えます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、たとえば、中央の列の小数部の最初の桁。</font><font style="vertical-align: inherit;">さて、私たちが知る限り、ルール30の進化は、実数で実行される標準の演算（乗算や度の取得など）とは関係ありませんが、テンプレートの右側を見ることによって形成される数列について尋ねることができます。ルール30.最初の200ステップで考えられるシナリオは次のとおりです。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ef4/a76/829/ef4a768290b8c1f14babceed901fa7f5.png" alt="ListLinePlot" title="ListLinePlot" width="620" height="172"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>ListLinePlot[<br>
 FromDigits[{#, 0}, 2] &amp; /@ <br>
 CellularAutomaton[30, {{1}, 0}, {200, {0, 200}}], Mesh -&gt; All, <br>
 AspectRatio -&gt; 1/4, Frame -&gt; True, <br>
 MeshStyle -&gt; <br>
 Directive[{Hue[0.07, 0.9500000000000001, 0.99], PointSize[.0085]}], <br>
 PlotTheme -&gt; "Detailed", PlotStyle -&gt; Directive[{<br>
Hue[0.1, 1, 0.99]}], ImageSize -&gt; 575]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これは次のステップで達成された値のヒストグラムです：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0f2/6f6/f19/0f26f6f19560a1ca000e8036ac2a754a.png" alt="ヒストグラム" title="ヒストグラム" width="620" height="156"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>Grid[{Table[<br>
 Histogram[<br>
 FromDigits[{#, 0}, 2] &amp; /@ <br>
 CellularAutomaton[30, {{1}, 0}, {10^n, {0, 20}}], {.01}, <br>
 Frame -&gt; True, <br>
 FrameTicks -&gt; {{None, <br>
 None}, {{{0, "0"}, .2, .4, .6, .8, {1, "1"}}, None}}, <br>
 PlotLabel -&gt; (StringTemplate["`` steps"][10^n]), <br>
 ChartStyle -&gt; Directive[Opacity[.5], Hue[0.09, 1, 1]], <br>
 ImageSize -&gt; 208, <br>
 PlotRangePadding -&gt; {{0, 0}, {0, Scaled[.06]}}], {n, 4, 6}]}, <br>
 Spacings -&gt; .2]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この仮説は、限界に向かう傾向のあるヒストグラムがフラットである、つまりこれらの数値が0〜1の範囲で均等に分布しているという事実と一致しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1900年代初頭には、この形式の一様分布について多くの数学的結果が得られました。特に、</font><em><font style="vertical-align: inherit;">hが</font></em><font style="vertical-align: inherit;">有理数</font><em><font style="vertical-align: inherit;">で</font></em><font style="vertical-align: inherit;">ない</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、シーケンシャル</font><em><font style="vertical-align: inherit;">nの</font></em></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FractionalPart</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hn</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">形式のシーケンス</font><font style="vertical-align: inherit;">は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">常に均一に分布</font></a><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">ことが知られています</font><font style="vertical-align: inherit;">。また、配列することが知られている</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">FractionalPart</font></a><font style="vertical-align: inherit;"> [ </font><em><font style="vertical-align: inherit;">時間</font></em><sup><em><font style="vertical-align: inherit;">nは</font></em></sup><font style="vertical-align: inherit;"> ]れる</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">均一ほぼすべてのための分散</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em><font style="vertical-align: inherit;">時間</font></em></a><font style="vertical-align: inherit;">（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ピソ番号</font></a><font style="vertical-align: inherit;">等</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><sup><em><font style="vertical-align: inherit;"></font></em></sup><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">黄金比</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は例外です）が、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FractionalPart</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [（3/2）</font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">などの特定のケースで</font><font style="vertical-align: inherit;">は、少なくとも半世紀にわたって分析が行われていませんでした。</font><font style="vertical-align: inherit;">（ちなみに、</font><font style="vertical-align: inherit;">16進数のシステムではPiの桁、したがって2桁のシステムでは、再帰式</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">FractionalPart</font></a><font style="vertical-align: inherit;"> [16 </font><em><font style="vertical-align: inherit;">x </font></em><sub><em><font style="vertical-align: inherit;">n</font></em></sub><sub><font style="vertical-align: inherit;"> -1</font></sub><font style="vertical-align: inherit;"> + </font><em><font style="vertical-align: inherit;">r</font></em><font style="vertical-align: inherit;"> [ </font><em><font style="vertical-align: inherit;">n</font></em><font style="vertical-align: inherit;"> ]] </font><font style="vertical-align: inherit;">を使用して生成できる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことが知られてい</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。ここで、</font><em><font style="vertical-align: inherit;">r</font></em><font style="vertical-align: inherit;"> [ </font><em><font style="vertical-align: inherit;">n</font></em><font style="vertical-align: inherit;"> ]は有理固定です</font><em><font style="vertical-align: inherit;">nの</font></em><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">。）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><sub><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">質問3：</font><font style="vertical-align: inherit;">使用についての中央列の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目のセルの</font><font style="vertical-align: inherit;">計算は、</font><font style="vertical-align: inherit;">（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）操作</font><font style="vertical-align: inherit;">について</font><font style="vertical-align: inherit;">ですか？</font></font></h3><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルール150で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
作成されたテンプレートについて考えてみ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfb/b41/77d/bfbb4177d1f4877020313f9c7da1a0b3.png" alt="ルール150" title="ルール150" width="620" height="162"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>Row[{ArrayPlot[CellularAutomaton[150, {{1}, 0}, 30], Mesh -&gt; All, <br>
 ImageSize -&gt; 315], <br>
 ArrayPlot[CellularAutomaton[150, {{1}, 0}, 200], ImageSize -&gt; 300]}]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはかなり普通のネストされたテンプレートであり、その中央の列は取るに足らない（つまり、すべてのセルが黒）ですが、左または右の1つの列を見ると、次のことがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7e0/aa7/dab/7e0aa7dab64163f3e5e3a5d0575e93e4.png" alt="Arrayplot" title="Arrayplot" width="620" height="15"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>ArrayPlot[{Table[Mod[IntegerExponent[t, 2], 2], {t, 80}]}, <br>
 Mesh -&gt; All, ImageSize -&gt; Full]</code></div></div><br>
<br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n番目の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルの</font><font style="vertical-align: inherit;">
値をどのように決定します</font><font style="vertical-align: inherit;">か？まあ、この特定のケースでは、本質的に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純な式</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があることが</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">わかり</font></a><font style="vertical-align: inherit;">ます。値は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mod</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntegerExponent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、2]、2] </font><font style="vertical-align: inherit;">として指定され</font><font style="vertical-align: inherit;">ます。つまり、</font><font style="vertical-align: inherit;">バイナリシステムの</font><font style="vertical-align: inherit;">数値</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nを</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見</font><font style="vertical-align: inherit;">て、最後のゼロの数が偶数か奇数かを尋ねます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「この式を評価する」にはどのくらいの計算能力が必要ですか？まあ、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em><font style="vertical-align: inherit;">nの</font></em></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのビット</font></font><em><font style="vertical-align: inherit;"></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をチェックする必要がある場合でも、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Log</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [2、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">についてしかありませ</font><font style="vertical-align: inherit;">ん。したがって、O（log </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）操作</font><font style="vertical-align: inherit;">が必要</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">なると予想できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、ルール30の場合はどうでしょうか？</font><font style="vertical-align: inherit;">ルール30アルゴリズムを明示的に適用してルールを</font><em><font style="vertical-align: inherit;">n </font></em><sup><font style="vertical-align: inherit;">2</font></sup><font style="vertical-align: inherit;">回</font><font style="vertical-align: inherit;">更新するだけで中央列の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n番目の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルの</font><font style="vertical-align: inherit;">値を決定できることはわかっています</font><font style="vertical-align: inherit;">が、問題は、必要な計算作業を削減する方法があるかどうかです。過去には、数学に適切な数学的モデルがある場合、科学者が十分な創意工夫を示すだけで、予測を行う方法を常に見つける、つまり、システムモデルがどのように反応するかを見つけるという暗黙の仮定が数理科学にありました。システムの実際の進化が必要とするよりもはるかに少ない計算能力を使用します。</font><font style="vertical-align: inherit;">
「正確なソリューション」の例はたくさんあります（たとえば、</font></font><em><font style="vertical-align: inherit;"></font></em><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2体問題、2次元イジングモデル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など）。ここでは、本質的に、システムが実行することの式を取得しますが、他のケースもあります（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3体問題</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dイジングモデル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など）。 。）これが達成できない場合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1980年代の初めに提案したように、</font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算処理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の量を大幅に削減する方法がないという意味で、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">計算処理でき</font></a><font style="vertical-align: inherit;">ないシステムを含む多くのシステムがあると思う傾向があります</font><font style="vertical-align: inherit;">。彼らの行動を決定するために必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、実際には、問題3はルール30の計算上の既約性、または少なくともその特定の側面に提起されています。 （O（の複雑さの推定</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この問題の別のバージョンは、O（必要な場合があります;）の動作は幾分任意で</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N </font></font></em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">αを</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意のα&lt;2の場合）、又は、この点で、O（ログ</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">β</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）） -または両方に基づいて、いくつかの基準時間とRAMリソースに依存します。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題3の質問に対する答えが否定的である場合</font><font style="vertical-align: inherit;">、O（</font><em><font style="vertical-align: inherit;">n</font></em><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">よりも少ない計算量で中央列の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n番目の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">を正常に計算する明示的なプログラムを与えることは明らかです。</font><font style="vertical-align: inherit;">その前にルール150でこれを行いました。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">の計算の複雑さは何</font><font style="vertical-align: inherit;">ですか？計算にはどのようなシステム（環境）を使用する必要がありますか。「計算能力」はどのように測定しますか？ここで、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算の普遍性</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という</font><font style="vertical-align: inherit;">現象は</font><font style="vertical-align: inherit;">、いくつかの基本的な制限の枠内で、最終的には問題にならないことを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確実性を高めるために、常に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チューリングマシンで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算を実行したいと言うことができます</font><font style="vertical-align: inherit;">。また、たとえば、</font><font style="vertical-align: inherit;">チューリングマシンのテープの初期状態として</font><font style="vertical-align: inherit;">数値</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数字を入力</font><font style="vertical-align: inherit;">すると</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、チューリングマシンは</font></font></a><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">nの</font></em><font style="vertical-align: inherit;">場合よりもはるかに</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">うまく機能する</font></a><font style="vertical-align: inherit;">こと</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">が</font></a><font style="vertical-align: inherit;">期待できます。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回答を受け取る前のステップ（そして、それが本当に「式」のように見える場合は、おそらくO（log </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）ステップになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、Turingマシンを使用して結論を​​正当化する必要はありません。セルラーオートマトンを含むユニバーサルコンピューティングが可能なシステムであり、この点で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolfram言語</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は私たちに非常に適してい</font><font style="vertical-align: inherit;">ます。しかし、そのようなシステムでは、必要な「コンピューティングパワー」を測定することがますます困難になっています。セルの更新。Wolfram言語では</font><font style="vertical-align: inherit;">、これに使用したプログラム</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を実行する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ための</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">プロセッサ時間を</font></a><font style="vertical-align: inherit;">測定するだけ</font><font style="vertical-align: inherit;">で済みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
規則30は計算上既約であり、その質問3は肯定的な応答であると信じていますが、そうでない場合、結局のところ</font><font style="vertical-align: inherit;">、約（</font><em><font style="vertical-align: inherit;">n</font></em><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">未満の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目の値を</font><font style="vertical-align: inherit;">明らかに計算するプログラムになると思い</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">操作、およびこれには、コンピューティングリソースが正しく計算されているかどうかの詳細について多くの議論が必要になります。</font><font style="vertical-align: inherit;">
ただし、そのようなプログラムが存在しないことを証明することははるかに困難です。そして、計算上の既約性は至る所にあると思いますが、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">明確な下限</font></a><font style="vertical-align: inherit;">を示すことは常に非常に困難です</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定の計算を実行する複雑さ。実際には、現在知られているほぼすべての明示的な下限はかなり弱いと、実際には、情報の内容についての推論に降りてくる-たとえば、あなたは（ログOを必要とする</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n個</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）だけの価値のすべての桁を読み取るために、手順</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のn</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
間違いなく、下限の最も有名な問題は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスPとNPの同等性の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題です</font><font style="vertical-align: inherit;">。ルール30の問題（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LOGTIME</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に対する質問Pにより類似）と直接の関係があるとは思いません</font><font style="vertical-align: inherit;">が、おそらくこれらすべてのタスクが論理的にどのように関連しているかを理解する必要があります。要するに、セルオートマトンの直接進化は、たとえば</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n個のセルが示されている初期条件からのステップは、O（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">計算にすぎない</font><font style="vertical-align: inherit;">ため、P（「多項式時間」）で発生しますが、問題は、特定の特定の条件を生成するために発展する初期条件があるかどうかです。最終結果はクラスNPになります。 （「非決定的」に）正しい初期条件を選択できた場合、出力に多項式時間を費やし</font><font style="vertical-align: inherit;">てこれを検証しますが、この検証</font><font style="vertical-align: inherit;">には2 </font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nの</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">潜在的</font><font style="vertical-align: inherit;">な初期条件</font><font style="vertical-align: inherit;">がある可能性があることを忘れないでください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべての2 </font><sup><em><font style="vertical-align: inherit;">n</font></em></sup><font style="vertical-align: inherit;">をチェックする必要がない多くのセルラーオートマトンがあります。</font></font><sup><em><font style="vertical-align: inherit;"></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期条件、および計算は多項式時間で実行されます。これは明らかに十分です。初期条件の検索が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NP完全問題</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">あるセルラーオートマトンを構築することができ</font><font style="vertical-align: inherit;">ます。つまり、セルラーオートマトンを反転する特定の特定の問題について、NPの問題をエンコードできます。ルール30を適用するタスクはNPで完了していますか？私たちはこれを知りませんが、これが証明される可能性はかなり高いようです（そして誰かがこれを証明した場合、ルール30は最終的に</font><font style="vertical-align: inherit;">完全確率NPの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗号システム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">になる</font><font style="vertical-align: inherit;">可能性があります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、ルール30の反転問題と中央列の状態を予測する問題の間にはおそらく直接の関係はありません。それにもかかわらず、別のグローバルな質問との直接的な関係があります。ルール30は計算に対して普遍的です。つまり、ルール30に初期条件があり、「自己プログラミング」して任意の計算を実行できます。チューリングマシン。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256、最も単純なセルオートマトンのうち、ことが知られている</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルール110は普遍的である</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（その単純な変換であり、他の3つのルールのような）が、典型的な例を見て</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルール110の進化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、特定のあることが明らかになっ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">識別できるモジュール構造</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">実際、それによって証明が続き、これらの構造を適切に組み立てることによって、ルール110からよく知られているユニバーサルシステムを「設計」する方法を示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/412/e52/bd5/412e52bd51359ec36b6f453db1f654bb.png" alt="ルール110" title="ルール110" width="612" height="412"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>SeedRandom[23542345]; ArrayPlot[<br>
 CellularAutomaton[110, RandomInteger[1, 600], 400], <br>
 PixelConstrained -&gt; 1]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ルール30は明らかなモジュール性を示していないため、他のすべての既知のユニバーサルシステムにインストールされる「エンジニアリング」方法によってユニバーサル性を確立することが可能であるとは考えられません。それにもかかわらず、私が開発</font><font style="vertical-align: inherit;">した</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算等価性</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">原則は</font></a><font style="vertical-align: inherit;">、規則30が確かに普遍的であることを示唆していますが、残念ながら、現在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それを証明しようとする方向</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はありません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムが普遍的であることを示すことが可能であると仮定すると、結果はルール30の問題に近いものになります。特に、システムが普遍的である場合は、システムに関する質問（たとえば、停止問題）が発生します。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無限時間の振る舞い。これは解決</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">できず、有限時間を保証する計算では答えを出すことができません。しかし、そのため、普遍性は、この計算を再現する初期条件の存在についての声明です。特定の初期条件の詳細や、特定の結果の計算にかかる時間については何も述べていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、問題3に関する経験的なデータを取得する可能性がある別の方向について考えてみましょう。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統計</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗号解読</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数学</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">機械学習</font></a><font style="vertical-align: inherit;">を使用する方法はあります</font><font style="vertical-align: inherit;">か</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンプレートの中央の列の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n番目の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">を計算するために必要な計算能力を少なくともわずかに減らすには</font><font style="vertical-align: inherit;">？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルール30の2次元モデル全体は、ランダムではないことが知られています。実際、すべての2 </font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スポットのうち、存在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">できるの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のみ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">で</font></a><font style="vertical-align: inherit;">あり、実際にはこの確率加重数ははるかに小さくなります。同様の事実を使用して中央の列の計算能力をO（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">未満の値に削減できることは間違いありません</font><font style="vertical-align: inherit;">（これは部分的な結果として適切です）。しかし、これはO（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の計算</font><font style="vertical-align: inherit;">よりも少ないの</font><font style="vertical-align: inherit;">でしょうか？これははるかに複雑な質問です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスク1が否定的に回答された場合、それは可能性がありますが、ある意味では、O（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">未満の中央列を計算</font><font style="vertical-align: inherit;">する要求は、「予測可能なパターン」の要求と同じです。もちろん、シーケンスで小規模の統計的規則性を見つけることができたとしても（おそらく、質問2に否定的に答える場合）、シーケンスを計算する速度の定数係数をわずかに改善するだけで、それだけでは可能以上のことはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニューラルネットワークを使用してシーケンスを計算するために、ある種の体系的に削減された方法はありますか？これは、実際には、実際の変数の組み込み関数のセットです。かつて、私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現代のディープラーニングテクノロジー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してそのようなニューラルネットワークを見つけようとしましたが、</font><font style="vertical-align: inherit;">何も見つけることができませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するには、統計的手法を使用してみます。シーケンスで統計的な「非ランダム性」を検出できた場合、これはシーケンスを圧縮する機能を意味し、したがって、シーケンスの冗長性または予測可能性を取得できます。しかし、私</font><font style="vertical-align: inherit;">は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ランダム性</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">についてあらゆる種類の統計的検定</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を行い</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルール30の中央の列にあり、偶然からの大きな逸脱は見つかりませんでした。 （そして、長年-少し効果的なルールが見つかるまで-有限サイズのRule 30システムのシーケンスを</font><font style="vertical-align: inherit;">Wolfram言語</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の疑似乱数乱数のジェネレーター</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として使用しました</font><font style="vertical-align: inherit;">が、「これは偶然ではありません！」という基本的なエラーはありませんでした。 ）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
統計的ランダムテストは通常​​、次のように機能します。「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランダムであると思われるシーケンスを取得して何らかの方法で処理し、結果が明らかにランダムでないかどうかを確認します。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」しかし、ここではどのような処理を行う必要がありますか？同じ頻度のブロックがあるかどうか、相関関係があるかどうか、または何らかの圧縮アルゴリズムが正常に圧縮を実行できるかどうかを確認することは可能ですか？しかし、通常、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストスイート</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は最終的には</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少しランダムで恣意的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。実際、すべての可能なテストを列挙することが可能です。つまり、特定のシーケンスに適用できるすべての可能なプログラムをリストします。ただし、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえばセルラーオートマトンのルールクラスに対してこれを実行しようとした</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とき</font><font style="vertical-align: inherit;">、ルール30のシーケンスに「非ランダム性」を見つけることができませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">数学のアイデア</font></a><font style="vertical-align: inherit;">を使用してみましょう</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルール30のシーケンスを予測します。ルール30は、十分に発達した数学の領域に関連付けられていないことが明らかになります。</font><font style="vertical-align: inherit;">しかし、もちろん、数論に類似した分野などで、規則30とアイデアの間で何らかの比較が見つかる可能性があり、それらは規則30の計算の前提条件を見つけるのに役立つか、ある種の計算が同等であることを示すことができる基本的に複雑であると考えられる整数因数分解などのタスク。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従来の数学的構造とセルオートマトンの間の非常に興味深い相互作用のいくつかの例があります。</font><font style="vertical-align: inherit;">たとえば</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、基数2と基数6の連続する次数3の数を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考え</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c50/006/328/c500063289356d0cdfafdd7857d4fc46.png" alt="連続する力の桁" title="連続する力の桁" width="620" height="281"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>Row[Riffle[<br>
 ArrayPlot[#, ImageSize -&gt; {Automatic, 275}] &amp; /@ {Table[<br>
 IntegerDigits[3^t, 2, 159], {t, 100}], <br>
 Table[IntegerDigits[3^t, 6, 62], {t, 100}]}, Spacer[10]]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベース6の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、セルオートマトン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が生成規則であることがわかり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます。</font></a><font style="vertical-align: inherit;">（ベース2の場合、追加の長距離送迎があります）。これらのパターンはどちらも複雑に見えますが、その数学的構造により、特定の予測を高速化できることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検討</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文字列の右端から番目の数字</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nは</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各パターンです。これ</font><font style="vertical-align: inherit;">は3 </font><sup><em><font style="vertical-align: inherit;">nの</font></em></sup></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目の数字であり</font><font style="vertical-align: inherit;">、「式」によって与えられます（</font><em><font style="vertical-align: inherit;">b</font></em><font style="vertical-align: inherit;">はベース、この場合は2または6です）</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Mod</font></a><font style="vertical-align: inherit;"> [ </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Quotient</font></a><font style="vertical-align: inherit;"> [3 </font><sup><em><font style="vertical-align: inherit;">n</font></em></sup><font style="vertical-align: inherit;">、b </font><sup><em><font style="vertical-align: inherit;">s</font></em></sup></font><sup><em><font style="vertical-align: inherit;"></font></em></sup><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><sup><em><font style="vertical-align: inherit;"></font></em></sup><font style="vertical-align: inherit;"></font><sup><em><font style="vertical-align: inherit;"></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]、b]。それでは、この式を評価するのはどれほど簡単ですか？ 3 </font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を計算</font><font style="vertical-align: inherit;">するには</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乗算</font><font style="vertical-align: inherit;">を実行する必要</font><font style="vertical-align: inherit;">があると思うかもしれませんが、そうで</font><font style="vertical-align: inherit;">はありません。たとえば、</font><font style="vertical-align: inherit;">繰り返し2乗を使用して</font><font style="vertical-align: inherit;">3 </font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">構築し</font><font style="vertical-align: inherit;">、log（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">乗算することができます</font><font style="vertical-align: inherit;">。これは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おそらく乗法的連想性の特性の結果であるということです</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。明らかに、ルール30のようなものはありませんが、このような数学的構造への何らかのマッピングを見つけることが常に可能である可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスク3では、私たちは、計算の処理能力について話</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目を</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルール30の中央の列の値を確認し、それがO（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">未満になる可能性があるかどうかを尋ねます</font><font style="vertical-align: inherit;">が、計算を実行するための特定のアルゴリズムがあり、特定の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について、それが使用するコンピューティングリソースを確認できるとします。結果は想定</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]、我々はかどうかを尋ねる</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nは</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">】以下「O-大」から以上である</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、換言すれば、または、それ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のMaxLimit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] / </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> →∞] &lt;∞。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムを実装する特定のチューリングマシン（またはその他のコンピューティングシステム）があるとします。それは起こるかもしれ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rを</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]漸近単に滑らかまたはそれ以外の場合は通常の関数少なくとも、ある</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nは</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、誰かがちょうど可能チューリングマシンを分類し始めているならば、それは制限があるかを確認するのは簡単であるため、しかし、彼はどこの例に出くわす</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はランダムな場所にランダムな高さのピークがあり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。どこかに</font><font style="vertical-align: inherit;">Turingマシンがまったく停止しない（またはそのようなもの）</font><font style="vertical-align: inherit;">値</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が存在する可能性さえある</font><font style="vertical-align: inherit;">ので、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]際限なく。</font><font style="vertical-align: inherit;">一般に、後で詳しく説明するように、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">O（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">に対して</font><font style="vertical-align: inherit;">どのように大きくなるかを決定することさえ不可能である場合があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正式な問題設定ルール30</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでは主にコンテストのタスクを言葉で説明していましたが、計算言語で（数学と同じくらい効果的に）説明することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wolfram言語では</font><font style="vertical-align: inherit;">、ルール30の中央の列の</font><font style="vertical-align: inherit;">最初の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">は次のように定義されています：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/219/e07/f8e/219e07f8ec41111ce3457989e3d3c188.png" alt="c [t_]" title="c [t_]" width="329" height="20"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>c[t_] := CellularAutomaton[30, {{1}, 0}, {t, {{0}}}]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この定義により、3つの問題を述語</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">として定式化できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク1：中央の列は常に非周期的なままですか？</font></font></h3><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fd6/b62/41e/fd6b6241e1828f88e2c5705effa27f0c.png" alt="問題1" title="問題1" width="198" height="27"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>\!\(<br>
\*SubscriptBox[\(\[NotExists]\), \({p, i}\)]\(<br>
\*SubscriptBox[\(\[ForAll]\), \(t, t &gt; i\)]c[t + p] == c[t]\)\)</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/9a7/72b/976/9a772b97673c5175cf10c00fcc2549a5.png" alt="存在しません" title="存在しません" width="305" height="19"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>NotExists[{p, i}, ForAll[t, t &gt; i, c[t + p] == c[t]]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、周期</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と初期長さ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iが</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ないため、すべての</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">と等しくなり</font><em><font style="vertical-align: inherit;">ます</font></em><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク2：セルの各色は、中央の列に平均して同じくらい頻繁に見つかるかどうか。</font></font></h3><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a08/8bf/469/a088bf469759ccf0f9ecbf05d97398bd.png" alt="問題2" title="問題2" width="143" height="49"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>\!\(\*UnderscriptBox[\(\[Limit]\), \(t\*<br>
UnderscriptBox["\[Rule]", <br>
TemplateBox[{},<br>
"Integers"]]\[Infinity]\)]\) Total[c[t]]/t == 1/2</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ff8/5f0/e55/ff85f0e55df25041ccfb0a24a0f1fd9f.png" alt="離散限界" title="離散限界" width="312" height="18"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>DiscreteLimit[Total[c[t]]/t, t -&gt; Infinity] == 1/2</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
またはの値の総和の限界</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] / </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tは、</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> →∞は1/2です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題3：</font><font style="vertical-align: inherit;">中央の列の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目のセルの</font><font style="vertical-align: inherit;">計算は、</font><font style="vertical-align: inherit;">少なくとも約（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）回の演算ですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我々は、マシン[定義</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mを</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によってパラメータ関数として】</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（例えば、チューリングマシンが存在してもよい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チューリングマシン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [...]）、及びマシン[せ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]リストを出力{ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> }、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vは</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、出力値であるとそして</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tは</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ステップの例えば、番号）を行う計算能力の数です。</font><font style="vertical-align: inherit;">次に、タスクは次のように定式化できます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/703/17d/c2f/70317dc2f546b0f3f2f2c3f59c5557f1.png" alt="問題3" title="問題3" width="495" height="49"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>\!\(<br>
\*SubscriptBox[\(\[NotExists]\), \(m\)]\((<br>
\*SubscriptBox[\(\[ForAll]\), \(n\)]\(\(machine[m]\)[n]\)[[1]] == <br>
 Last[c[n]]\ \[And] \ <br>
\*UnderscriptBox[\(\[MaxLimit]\), \(n -&gt; \[Infinity]\)]<br>
\*FractionBox[\(\(\(machine[m]\)[n]\)[[<br>
 2]]\), \(n\)] &lt; \[Infinity])\)\)</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または「</font><font style="vertical-align: inherit;">すべての</font><em><font style="vertical-align: inherit;">n</font></em><font style="vertical-align: inherit;">に対して</font><font style="vertical-align: inherit;">マシン[ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">が</font><em><font style="vertical-align: inherit;">c</font></em><font style="vertical-align: inherit;"> [ </font><em><font style="vertical-align: inherit;">n</font></em><font style="vertical-align: inherit;"> ]を</font><font style="vertical-align: inherit;">生成</font><font style="vertical-align: inherit;">し、</font><em><font style="vertical-align: inherit;">n</font></em><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">除算される操作の数の制限</font><font style="vertical-align: inherit;">が有限で</font><font style="vertical-align: inherit;">あるような数mはありません</font><font style="vertical-align: inherit;">。」</font><font style="vertical-align: inherit;">（また</font><font style="vertical-align: inherit;">、マシンの「ルール」が答えを格納できないように、</font><em><font style="vertical-align: inherit;">m</font></em><font style="vertical-align: inherit;">が有限で</font><font style="vertical-align: inherit;">あるという要件もあります</font><font style="vertical-align: inherit;">）。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定の正式な性質</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクを個別に説明する前に、尋ねる必要がある明白な質問は、問題の相互依存性が何であるかです。質問3の答えが否定的（私は個人的には非常に疑わしい）である場合、問題1と2の答えが続く単純なアルゴリズムまたは式に機会が提供され、それが単純になる可能性があります。タスク3の回答が肯定的である場合（私が強く望んでいるように）、これはタスク1の回答も肯定的であることを意味します。逆も当てはまります。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク1の回答が否定的である場合、これはタスク3の回答も否定的でなければならないことを意味し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、問題1の答えが否定的である場合、中央の列に定期的なシーケンスがあります。つまり、このシーケンスを明確に知っている人は、問題2にすぐに答えることができます。タスク2の答えが否定的な形であると、問題3.実際、黒と白の不等確率は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャノン情報</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の形式で一定の係数で圧縮することを意味</font><font style="vertical-align: inherit;">しますが、O（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）演算</font><font style="vertical-align: inherit;">よりも少ない値を計算するには</font><font style="vertical-align: inherit;">、したがって、問題3に対する否定的な回答の場合、次のことが必要です。ある意味で、無限に大きな収縮を特定することが可能でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、すべてのタスクに対する回答を得るためには何が必要ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題1に対する否定的な回答を受け取った場合は、ルール30によって特定のステップで生成されたテンプレートを明確に示し、中央に定期的なシーケンスが表示されることを想像できます。もちろん、タスク1は否定的に答えることができますが、建設的ではありません。結局、シーケンスは周期的である必要があることを示すことができますが、これが発生する可能性のある境界も知りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題2と問題3の両方を否定的に解決できる方法の1つ（私の考えでは非常にあり得ない）-これは、中央の列にアルゴリズムがあり、白黒のセルが同じ頻度。一般に、問題3に否定的な回答が与えられた場合、これを行う方法は、O（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">未満の演算を使用して計算を実行するアルゴリズム（または、たとえば、チューリングマシン）を明示的に示すこと</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰かがそのようなアルゴリズムを持っているとしましょう。すべての</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nに対して、</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムが</font><em><font style="vertical-align: inherit;">n-を</font></em><font style="vertical-align: inherit;">正しく再現</font><font style="vertical-align: inherit;">することを証明する必要が</font><em><font style="vertical-align: inherit;">あり</font></em><font style="vertical-align: inherit;">ます</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目の値。次に、これを非常に簡単に行う方法を説明します。帰納法などによる単純な証明かもしれませんが、同時に、それは任意に複雑にすることができます。たとえば、ほとんどの</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、アルゴリズムの実行時間が</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よりも明らかに短い場合があり</font><font style="vertical-align: inherit;">ます。ただし、実行時間が常に有限であることは明らかでない場合があります。実際、アルゴリズムの「停止タスク」は、単に解決できない場合があります。ただし、特定のアルゴリズムが特定の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nに対して</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">停止</font><font style="vertical-align: inherit;">しないことを示すだけでは、タスクへの回答を受け取ったときに実際には何も言われません。これを行うには、O（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">未満の</font><font style="vertical-align: inherit;">演算</font><font style="vertical-align: inherit;">で正常に停止するアルゴリズムがないことを示す必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、解けないことの言及は問題を提起します：</font><font style="vertical-align: inherit;">問題を解決するために</font><font style="vertical-align: inherit;">どの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公理系</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用すべきですか？コンテストの目的のために、私は単に「標準数学の伝統的な公理」と言います。これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ペアノ算術</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および/または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集合論の公理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（連続体仮説ありまたはなし）</font><font style="vertical-align: inherit;">と</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">見なす</font></a><font style="vertical-align: inherit;">ことができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
質問への回答は、公理の選択のシステムに依存するか、または（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ゲーデルの不完全性定理の</font></a><font style="vertical-align: inherit;">意味</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">で）</font></a><font style="vertical-align: inherit;">従来の公理に依存しないという事実にさえ依存する可能性がありますか？</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）？数学の歴史的経験は、これは非常にありそうもないことを示唆しています。なぜなら、今日、数学におけるすべての「自然な」問題は、数学で使用される公理の（時には暗黙的な）体系で解決できるように思われるからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、コンピューティングの世界では、歴史的な数学的伝統の境界から解放されて、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解決不能に遭遇する可能性</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がはるかに</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">高くなり</font></a><font style="vertical-align: inherit;">ます。そして実際、私は、長い間未解決の問題のかなりの部分が、伝統的な数学においてさえ、解決できないことを証明するであろうと思います。したがって、これは間違いなく、ここでの問題が少なくとも一部の標準公理システム（セット）から独立している可能性をわずかに高めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
世界には解決できないものはなく、「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この明示的な構造を見てください</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」と言って問題に単純に答えることができるいくつかのケースを扱っていないとします</font><font style="vertical-align: inherit;">。しかし、問題を解決するためには、その証拠を提供する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本質的に、証明の必要性は問題の中に無限の何かが存在することです。</font><font style="vertical-align: inherit;">無限大など、</font><font style="vertical-align: inherit;">任意の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について何かを知りたいと思っています</font><font style="vertical-align: inherit;">。これに対処する唯一の方法は、それを記号で表すことです（「記号の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無限大</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は無限</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">大を</font></a><font style="vertical-align: inherit;">意味する」など）。そして、公理のシステムの基礎となる公理を形成する装置を含め、すべてに正式なルールを適用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最良のケースでは、明確に示すことができます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この一連のルールアプリケーション</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -コンピュータがそれらが正しいことをすぐに確認できるようにします。おそらく、（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FindEquationalProofのように</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">定理の自動証明を使用して、多くのルールアプリケーションを見つけることができます</font><font style="vertical-align: inherit;">。ほとんどの場合、それ（証拠）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は証拠アシスタントのシステムを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用して構築できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、</font><font style="vertical-align: inherit;">すべての問題に対する答えの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全に形式化された証明</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を取得することは興味深いでしょうが</font><font style="vertical-align: inherit;">、標準的な証明（すべての数学者が伝統的に行うこと）を作成する方がはるかに簡単になると思います。 -これは、結果の正確さを他の人々に納得させる議論です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
証明とは何かという概念の正確な定義はありません。私たちの中で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolfram | Alphaの</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ステップバイステップのソリューション</font></a><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">は、生徒が結果を追跡できるように、（たとえば計算で）結果を効果的に証明します。学術数学ジャーナルは、レビュープロセスに成功した証拠を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の提案は、誰か</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が数学の文献</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">ほとんどの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">自明でない証明</font></a><font style="vertical-align: inherit;">を形式化しようとした場合</font><font style="vertical-align: inherit;">、新しい結果を必要とする小さなコーナーを見つけるだろうというものでしたが、通常はそれほど難しくはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテストで実際にこれをどのように処理できますか？本質的に、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">計算上の「契約」を</font></a><font style="vertical-align: inherit;">定義する必要があります</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成功とは何か、いつ賞金を支払うべきか。建設的な証明の</font><font style="vertical-align: inherit;">ために、結果を決定するのに十分な大きさの任意のコンピューターで明示的に実行できる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolfram言語</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">取得</font><font style="vertical-align: inherit;">できます。正式な証拠として、Wolfram言語コードを取得できます。このコードは、段階的な検証に合格できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、「人間の証拠」はどうですか？</font><font style="vertical-align: inherit;">結局のところ、私たちはある種の人間による審査プロセスに頼らざるを得ません。</font><font style="vertical-align: inherit;">複数の人に証拠の確認を依頼できます。</font><font style="vertical-align: inherit;">私たちはブロックチェーンに触発されたある種のスキームを持っているかもしれません、そこで人々は証拠が真実であると「頼りに」し、そして誰かが最終的に同意を得た場合（それが何であれ）、彼はレートに比例して賞金の一部を人々に支払います。</font><font style="vertical-align: inherit;">しかし、何が行われても、それは不完全で「公開された」結果になります。これまでに世界中で行われているほとんどすべての純粋な数学と同様です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題を解決するには何が必要ですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのタスクに取り組むことに関心のある人々に関連するスキルは何ですか？実際、私はこれを知りません。それは、離散的な組み合わせ数学でありえます。数ベースのシステムで一致が見つかった場合、それは数論である可能性があります。代数的システムとの対応が見つかれば、それは代数的数学のいくつかの分岐になる可能性があります。これは力学系の理論かもしれません。それは、たとえば、数学的論理または理論的なコンピューターサイエンス、たとえばルールの書き換えの理論に近いものかもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、数学の分野など、既存の知識の「塔」が検討中の問題に関連することはなく、それらを解決するには、新しい塔を最初から構築する必要があることが判明する場合があります。実際、これはまさに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、2007年の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">2.3チューリング賞の</font></a><font style="vertical-align: inherit;">問題の解決策で最終的に起こったこと</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はコンピュータ実験の力を信じています。そしてもちろん、コンピュータ実験に基づいて、ルール30コンテストの目的を定式化しましたが、実行できるコンピュータ実験は確かにあります。これまでに</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">10億の数</font></a><font style="vertical-align: inherit;">を知ってい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中央の列の順序で。そして、これまでのところ、シーケンスはランダム性からの逸脱を示していません（少なくとも私が試みたテストに基づいて）。ただし、1兆個の要素（最新のコンピューターシステムの範囲内にある必要があります）または4兆個以上の要素を使用すると、最終的に、そのような検証に十分な数の要素が取得されます。</font><font style="vertical-align: inherit;">中央の列の</font><em><font style="vertical-align: inherit;">n個の</font></em><font style="vertical-align: inherit;">要素</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を計算する直接的な方法</font><font style="vertical-align: inherit;">は、中間ステップで最大</font><em><font style="vertical-align: inherit;">n個の</font></em><font style="vertical-align: inherit;">メモリセル</font><font style="vertical-align: inherit;">を使用して、</font><em><font style="vertical-align: inherit;">n</font></em><font style="vertical-align: inherit;">ステップ</font><font style="vertical-align: inherit;">に対してルール30を実行</font><font style="vertical-align: inherit;">すること</font><font style="vertical-align: inherit;">です。実際の計算のタイプは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、Wolfram言語で</font></a><font style="vertical-align: inherit;">かなり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">よく最適化され</font></a><font style="vertical-align: inherit;">て</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">います</font></a></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">デスクトップコンピューターで作業すると、100,000アイテムを計算するのに0.4秒もかかりません。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/71e/d97/32f/71ed9732f34a70e8faaf1be71d435461.png" alt="セルラーオートマトン" title="セルラーオートマトン" width="425" height="51"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>CellularAutomaton[30, {{1}, 0}, {100000, {{0}}}]; // Timing</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部アルゴリズムは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルール30が</font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Or</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">q</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]] </font><font style="vertical-align: inherit;">として</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">表現できる</font></a><font style="vertical-align: inherit;">という事実を利用しており</font><font style="vertical-align: inherit;">、同時にデータワード全体に対する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビット単位の演算</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">使用して実装され</font></a><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">長整数に</font><font style="vertical-align: inherit;">明示的な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビット操作</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">すると、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CellularAutomaton</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数に組み込まれている</font><font style="vertical-align: inherit;">アルゴリズムの</font><font style="vertical-align: inherit;">約2倍の時間がかかります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3d8/fe3/a41/3d8fe3a41564271ac1b4bdb5bf285ee5.png" alt="モジュール" title="モジュール" width="443" height="78"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>Module[{a = 1}, <br>
 Table[BitGet[a, a = BitXor[a, BitOr[2 a, 4 a]]; i - 1], {i, <br>
 100000}]]; // Timing</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの結果は、ユニプロセッサソリューションを使用して取得されました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くのプロセッサ間の並列</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">化やGPUの使用</font><font style="vertical-align: inherit;">を想像することができ</font><font style="vertical-align: inherit;">ます。 Rule 30の進化における多くのステージの結果を効果的にキャッシュすることで計算を高速化することは可能であると想定できますが、すべてのブロックがRule 30テンプレートのすべての行に少なくともほぼ同じ頻度で表示されるという事実により、次のようになります。プログラムの大幅な加速につながります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのタイプの数学問題は、既存の高水準数学の詳細な知識を必要とします。たとえば</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、フェルマーの最後の定理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">4色の</font></a><font style="vertical-align: inherit;">定理の</font><font style="vertical-align: inherit;">「初等」証明が存在する可能性は低い</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、ルール30コンテストでは、まだはっきりしていません。タスクごとに複雑な数学が必要かどうかはわかりません。</font><font style="vertical-align: inherit;">この知識は、専門的に数学の訓練を受けている人だけがアクセスできます。または、複雑な数学を使わずに、プログラミングスタイルまたはパズルスタイルの骨の折れる作業の助けを借りて解決できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汎化と関係</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の問題を解決する最良の方法は、最初にそれに関連する問題を解決することです。多くの場合、より一般的な問題を解決してから、特定のタスクに戻ります。もちろん、これについて考慮できるルール30の競合タスクに関連する多くのタスクがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、ルール30テンプレートの中央にあるセルの縦の列を見る代わり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、反対方向のセル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">列を</font></a><font style="vertical-align: inherit;">見ることができます</font><font style="vertical-align: inherit;">。ルール30で生成されたパターンに対して45度の角度を見ると、シーケンスが周期的であることが簡単にわかります。左側では、期間が非常にゆっくりと増加しています。右側は急激に増加しています。しかし、さまざまな角度から見た場合はどうでしょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、テンプレートで一連のセルを表示してみませんか？すべての可能なブロックが見つかりましたか？ブロックは何ステップかかりますか？</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">経験的データで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランダム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">発生するブロック</font></a><font style="vertical-align: inherit;">からの逸脱は見られません</font><font style="vertical-align: inherit;">が、たとえば、連続シリーズは強く相関していることは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異なる初期条件はどうですか？</font><font style="vertical-align: inherit;">可能なすべての無限初期条件からの等しい確率から始めて、ルール30の動作に関する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的システムのスタイルに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は多くの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">結果</font></a><font style="vertical-align: inherit;">があり</font><font style="vertical-align: inherit;">ます。この場合、たとえば、</font><font style="vertical-align: inherit;">特定の行と</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">特定の垂直列の</font></a><font style="vertical-align: inherit;">両方で、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての可能なブロックが同じ頻度</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">発生する</font></a><font style="vertical-align: inherit;">ことを簡単に示すこと</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ができ</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定の有限状態機械によって生成されるすべての可能なシーケンスに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対応する初期条件を誰かが要求した場合、状況は複雑になり</font><font style="vertical-align: inherit;">、可能な初期条件のさまざまなセットに関する結果のシーケンスから、最終的に初期ケースについて何かを言うことができると想像できます。単一の黒いセルの状態。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの単純な一般化は、1つのブラックセルの初期状態ではなく、他の「特別な」初期条件を見ることです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無限の周期的な初期条件</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、常に周期的な動作を提供します（周期的な境界条件のある有限サイズの領域に該当するものと同じです）。ただし、たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">周期モデルに「1つの欠陥」を入れる</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6d4/681/5a3/6d46815a3ca3f273fa19794b5e8a4e7c.png" alt="周期的パターンの「単一欠陥」" title="周期的パターンの「単一欠陥」" width="620" height="105"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>GraphicsRow[(ArrayPlot[<br>
 CellularAutomaton[30, <br>
 MapAt[1 - #1 &amp;, Flatten[Table[#1, Round[150/Length[#1]]]], 50], <br>
 100]] &amp;) /@ {{1, 0}, {1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0}, {1, <br>
 0, 0, 0, 0, 0, 0}, {1, 1, 1, 0, 0}}]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、黒いセルが1つだけでなく、初期条件でより長いシーケンスがある場合に何が起こるかについて考えることもできます。</font><font style="vertical-align: inherit;">中央の列は、異なる初期シーケンスでどのように変化しますか？</font><font style="vertical-align: inherit;">「より単純な」中央カラムにつながる有限の開始シーケンスはありますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あるいは、他のコンピューティングシステム（たとえば、置換システム）によって生成され、周期的ではないが、ルール30の何らかの単純なパターンを提供する無限の初期条件がありますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、「ルール30」を超える方法を想像できます。</font><font style="vertical-align: inherit;">ルールに長距離の「例外」を追加するとどうなりますか？</font><font style="vertical-align: inherit;">ルール30の拡張は、何らかの方法で分析できる動作をいつ示しますか？</font><font style="vertical-align: inherit;">そして、ルールの「例外」を排除する効果を見ることができますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、ルール30とは完全に異なるルールを検討することもできます。おそらく、他のルールを見ることによって、ルール30に関連する直感または方法を開発したいと考えています。</font><font style="vertical-align: inherit;">256の2色ルール（特定のセルの隣接セルを処理）の中にも、単純な初期条件から始まる複雑な動作を示すものがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/06b/b9a/183/06bb9a183a26b872051be9979e742d6a.png" alt="Arrayplot" title="Arrayplot" width="620" height="173"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><code>Row[Riffle[<br>
 Labeled[ArrayPlot[CellularAutomaton[#, {{1}, 0}, {150, All}], <br>
 PixelConstrained -&gt; 1, Frame -&gt; False], <br>
 Style[Text[StringTemplate["rule ``"][#]], 12], <br>
 LabelStyle -&gt; Opacity[.5]] &amp; /@ {45, 73}, Spacer[8]]]</code></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに多くの花や隣人を見ると、無数の例を見つけることができます。誰もが目にするあらゆる種類の行動があります。たとえば、特定のシーケンスについて、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それを中央列として生成するルールを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検索でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。また、表示される中央列のシーケンスを分類して、グローバルステートメントを作成できる一般的なクラスを「ルール30として」識別することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、「ルール30」コンペティションの特定の賞ルールについて説明します。ルール30（問題1と同様）の周期性の可能性を調査するために、多くの異なるルールを調査し、非常に長い期間または非常に長いトランジェントの例を探し、それらを使用して、これがいつどのように発生するかについてのアイデアを開発するように試みることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスク2で同じ頻度の現象を調査するために、さまざまな統計的特徴を調べて、規則30と、規則の動作の規則性を検出できる場合は異なる規則の両方を確認できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスク3では、さまざまなレベルのコンピューティング能力を検討し始めることができます。</font><font style="vertical-align: inherit;">About（</font><em><font style="vertical-align: inherit;">n </font></em><sup><font style="vertical-align: inherit;">gammaの</font></sup></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目の値</font><font style="vertical-align: inherit;">を見つけることができますか？</font></font><em><font style="vertical-align: inherit;"></font></em><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）γ&lt;2の操作（これを達成する方法はわかりません）？</font><font style="vertical-align: inherit;">About（log（</font><em><font style="vertical-align: inherit;">n</font></em><font style="vertical-align: inherit;">））オペレーション</font><font style="vertical-align: inherit;">より小さい</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目の値が</font><font style="vertical-align: inherit;">見つからないことを示すことはでき</font><font style="vertical-align: inherit;">ますか？ O（log（</font><em><font style="vertical-align: inherit;">n</font></em><font style="vertical-align: inherit;">））</font><font style="vertical-align: inherit;">より少ない</font><font style="vertical-align: inherit;">利用可能なメモリはどうですか？異なるルールはどうですか？周期的でネストされたパターンは迅速かつ簡単に計算されます。他にどのような例がありますか？</font><font style="vertical-align: inherit;">
すでに述べたように、期待される大きな成果は、ルール30の計算の普遍性を示すことです。ルール30でこれを実行できない場合でも、追加の例（たとえば、ルール110以外）を探すと、ルールで発生する可能性のあるビジョンの構築に役立ちます30。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NP完全性がある場合、質問がNP完全であることを証明できる初期条件のファミリについて、ルール30の動作について質問する方法はありますか？</font><font style="vertical-align: inherit;">これが機能した場合、暗号化タスクは驚くほど成功します。</font><font style="vertical-align: inherit;">ルール30よりも「意図的に構築された」ルールであっても、他のルールを見ることでソリューションの前提条件を作成することは可能ですか？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンペティションで設定されたタスクは難しいですか？</font></font></h2><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2007年</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.3チューリング賞</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を制定した</font><font style="vertical-align: inherit;">
とき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、</font></a><font style="vertical-align: inherit;">それがどのくらいの期間で解決されるかわかりませんでした。結局のところ、それは約4か月後に実際に解決されました。では、ルール30の賞金競争の目的はどうなるのでしょうか。知りません。約40年後、1か月で解決できるものがあるとは驚きます（しかし、これが起こったとしたら信じられないでしょう！）。そして、もちろん、一見似たような問題（たとえば、Pi数の特殊性）が1世紀以上にわたって存在しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日、問題の解決に役立つ複雑な数学（またはコンピューターサイエンス）が存在するかどうかは明らかではありませんが、それらを解決するために費やされるすべてのものが、他の問題を解決するために重要になる構造を提供すると確信していますコンピューティングユニバース。そして、時間がかかるほど（フェルマーの最後の定理を思い出してください）、このソリューションに至るまでに、より新しい有用な理論が構築される可能性が高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提起された問題の解決策が「明らかに正しい」か（建設的に解決され、計算可能な形式で提示されれば非常に役立つ）か、または証拠の検証が長期間必要かどうかはわかりません。証拠が比較的短いのか、信じられないほど長いのかはわかりません。決定が公理システムの詳細に依存するかどうかはわかりません（「連続体仮説を想定する」など）。または、公理の合理的な選択に対して信頼性があります。 3つのタスクがどういうわけか「比較的難しい」か、または1つまたは2つが解決できるのに他のタスクが非常に長い間解決されないままであるかどうかはわかりません...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、問題の解決は大きな成果になると確信しています。</font><font style="vertical-align: inherit;">具体的かつ具体的にするために、これらのタスクを選択しました。</font><font style="vertical-align: inherit;">しかし、彼らが触れているランダム性と計算上の既約性の問題は非常に深く一般的です。</font><font style="vertical-align: inherit;">そして、これらの問題に対する解決策の知識は、それらが発生する可能性のある知識の分野において、これらの問題を反映するための重要な証拠と予備を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然のことながら、約30年間、ルール30の未解決のタスクを抱えて現在住んでいるので、私は個人的に彼の素晴らしい行動について何か他に新しいことを知って喜んでいます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳について</font></font></b><div class="spoiler_text">    (Stephen Wolfram) "<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Announcing the Rule 30 Prizes</a>".<br>
   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>       .</div></div><br>
<blockquote>     Wolfram Language?<br>
   «<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">     Wolfram</a>»    <b> </b> (<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b></b></a>).</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja470413/index.html">2020年には何を選ぶべきですか-ReactまたはVue？</a></li>
<li><a href="../ja470415/index.html">FAQ.Net-無料のWindows用ノートブックまたはノートプログラム</a></li>
<li><a href="../ja470417/index.html">インダストリー4.0：SAPおよびKUKAの自律型エンタープライズアイデア</a></li>
<li><a href="../ja470421/index.html">最新のWindowsシステムの攻撃とセキュリティ</a></li>
<li><a href="../ja470423/index.html">エディションベースの再定義。パート2</a></li>
<li><a href="../ja470429/index.html">生産における未開発のERP：集中治療または遺体安置所？（続き）</a></li>
<li><a href="../ja470437/index.html">デジタルブレークスルー：世界最大のハッカソンの決勝</a></li>
<li><a href="../ja470441/index.html">さまざまなタイプのJavaオブジェクトのサイズ</a></li>
<li><a href="../ja470443/index.html">Goでの継続的なプロファイリング</a></li>
<li><a href="../ja470445/index.html">ロシアで最初の量子コンピューターのプロトタイプがNUST“ MISiS”で発売されました</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>