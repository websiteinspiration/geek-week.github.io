<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➰ 🦀 🥛 環境オブジェクトとの簡単なAI相互作用の作成 🤳🏽 🍹 🤭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ビデオゲームの人工知能を作成する場合、最も重要な側面の1つはその場所です。 AIキャラクターの位置は、彼の行動のタイプと将来の決定を完全に変える可能性があります。このチュートリアルでは、ゲーム環境がAIにどのように影響するか、およびそれを正しく使用する方法を理解します。
 
 この記事は、Micha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>環境オブジェクトとの簡単なAI相互作用の作成</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496080/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b5/840/cec/6b5840cec8e3b42adad879472c47930d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオゲームの人工知能を作成する場合、最も重要な側面の1つはその場所です。 AIキャラクターの位置は、彼の行動のタイプと将来の決定を完全に変える可能性があります。このチュートリアルでは、ゲーム環境がAIにどのように影響するか、およびそれを正しく使用する方法を理解します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は</font><font style="vertical-align: inherit;">、Michael Dagrackによって作成され、Packt Publishingによって発行され</font><font style="vertical-align: inherit;">た書籍、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Practical Game AI Programming</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からの抜粋です。この本では、ゲームAIの作成方法を学び、最も高度なAIアルゴリズムをゼロから実装することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
視覚的な操作は基本的なものであり、ゲームプレイに直接影響することはありませんが、ビデオゲームとそのキャラクターを、私たちが作成する環境の一部にすることで改善でき、プレーヤーのゲームへの没入感に大きく影響します。</font><font style="vertical-align: inherit;">これは、画面のスペースを埋めるだけでなく、ゲームの一部である環境の重要性を私たちに証明します。</font><font style="vertical-align: inherit;">同様の相互作用がゲームでますます見られるようになり、プレイヤーはそれらを目にすることを期待しています。</font><font style="vertical-align: inherit;">ゲーム内にオブジェクトがある場合、最も重要なものではありませんが、何らかの機能を果たす必要があります。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
環境との相互作用の最初の例の1つは、1986年にニンテンドーエンターテインメントシステム向けにリリースされた最初のキャッスルバニアにあります。</font><font style="vertical-align: inherit;">最初から、プレイヤーはムチを使って、もともと背景の一部であったろうそくや火を破壊できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90c/a93/19c/90ca9319cffa8e665c51bc56297876a5.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これとその時代のいくつかのゲームは、ゲーム内のキャラクターの背景と環境の現代的な認識に関して多くの扉と機会を開きました。</font><font style="vertical-align: inherit;">明らかに、その世代のコンソールにはハードウェアの制限があるため、現在の標準で一般に受け入れられている単純なものを作成することははるかに困難でした。</font><font style="vertical-align: inherit;">しかし、コンソールの世代ごとに新しい機能がもたらされ、開発者はそれらを使用して素晴らしいゲームを作成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、視覚的な相互作用の最初の例は、ゲームプレイに直接影響を与えずに破棄できる背景上のオブジェクトです。</font><font style="vertical-align: inherit;">このタイプの相互作用は、多くのゲームで見られます。</font><font style="vertical-align: inherit;">実装は簡単で、攻撃されたときにオブジェクトをアニメーション化するだけです。</font><font style="vertical-align: inherit;">その後、ゲームを探索したプレーヤーに報酬を与えるポイントまたはオブジェクトをオブジェクトからドロップするかどうかを決定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、次の例に進むことができます。ゲーム内のオブジェクトは、アニメートされるか、キャラクターが通過するときに移動します。ここでの原理は破壊可能なオブジェクトの場合と同じですが、今回の相互作用はより微妙です。オブジェクトが存在するポイントにキャラクターが移動する必要があります。これは、草、ほこり、水の動きから、飛んでいる鳥や面白いジェスチャーをしている人々まで、ゲームのさまざまな要素に適用できます。可能性は無限大。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの相互作用を分析すると、それらが必ずしもAIを使用していないことが簡単に判断できます。ほとんどの場合、特定のアクションに従ってアクティブ化されるのは単なるブール関数です。ただし、これらは環境の一部であるため、環境とAIの間に高品質の相互作用を実装するときに考慮する必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">環境との簡単な相互作用を作成する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに見てきたように、環境はかつてゲームプレイの一部になり、これが将来のゲームのための多くの新しい概念とアイデアを生み出しました。</font><font style="vertical-align: inherit;">次のステップは、ゲームプレイにおけるこれらの小さな変更の統合と、ゲーム内でのプレーヤーの動作を変更するためのそれらの使用でした。</font><font style="vertical-align: inherit;">これは間違いなくビデオゲームの歴史に良い影響を与えました。シーンのすべての要素が徐々に活気づき始め、プレイヤーは環境がいかに豊かであるかを認識し始めたからです。</font><font style="vertical-align: inherit;">環境を使用してゲーム内の目標を達成することは、ゲームプレイの一部となっています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/0c6/39f/ad20c639fd190d338f6e2e72847338b1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームプレイに直接影響する環境の1つの例を示すために、優れた例であるトゥームレイダーフランチャイズを取り上げます。この例では、キャラクターのララクロフトがマークされた領域に着地するまで立方体を押す必要があります。これにより、環境が変更され、新しいパスが開かれ、プレイヤーはさらにレベルを上げることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなパズルは多くのゲームで見つけることができます。マップの特定のポイントでアクションを実行して、別の部分で何かが発生するようにする必要があり、これを使用してゲームの目標を達成できます。通常、レベルをさらに上げるには、環境自体を変更する必要があります。したがって、開発者はマップまたはレベルを計画するときに、これを考慮に入れて、各対話に関連するすべてのルールを作成します。例えば：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(cube.transform.position == mark.transform.position)<font></font>
{<font></font>
  openDoor = <span class="hljs-literal">true</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、ララクロフトがこのボックスをその場所に置くのを助けることが主な役割である同盟者の性格を持っていることを想像してみてください。</font><font style="vertical-align: inherit;">そしてこの章では、このタイプの相互作用だけを考慮します：AIキャラクターは、環境がどのように機能し、どのように使用されるかを理解します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トゥームレイダーの移動環境</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシナリオに直接進み、プレーヤーが目標を達成するのに役立つAIキャラクターがいる状況を再現してみましょう。</font><font style="vertical-align: inherit;">この例では、プレイヤーが閉じ込められており、プレイヤーを解放できるインタラクティブなオブジェクトにアクセスできない場合を想定しています。</font><font style="vertical-align: inherit;">私たちが作成するキャラクターは、立方体を見つけて正しい方向に押すことができなければなりません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b5/840/cec/6b5840cec8e3b42adad879472c47930d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、すべてのキャラクターとオブジェクトが揃いました。この状況でAIキャラクターがどのように動作するかを計画しましょう。まず、プレーヤーが近くにいることを確認し、キューブを検索して目的の位置に移動できるようにします。立方体がマークにある場合、砂から新しいブロックが表示され、プレーヤーがさらにレベルを上げることができると仮定します。 AIキャラクターは、立方体を左、右、前方、後方の4方向に押すことができるため、ポジションマークと完全に一致します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/804/463/982/8044639827005d84bcf50014f095b46e.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AIキャラクターは、この動作ツリーに表示されるすべてのアクションを検証および検証する必要があります。タスクを続行するための最初かつ最も重要なことは、キャラクターがプレーヤーが自分のマークの上にいることを確認する必要があることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレイヤーがまだそこに到達していない場合、キャラクターは待機して所定の位置に留まる必要があります。プレイヤーがすでにマークに到達している場合、AIキャラクターは実行を続け、キューブオブジェクトからどれくらい離れているかを自問します。そうでない場合、キャラクターは立方体に向かって移動し、このアクションが確認されたら、同じ質問をする必要があります。答えが正になり、キャラクターがキューブの隣にいる場合、彼は最初にキューブを押す必要がある方法を理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、立方体をマーキング位置と一致してタスクが完了するまで、Y軸またはX軸に沿って立方体を押し始めます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueYplayerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレイヤーがマークされた位置の隣にいるかどうかをキャラクターが確認できるようにするコードに情報を追加し始めています。これを行うには、プレーヤーとプレーヤーの位置との間の距離を計算するために必要なすべての変数を作成します。</font></font><code>playerMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレーヤーの3Dモデルを参照し、そこから彼の位置を抽出してとして使用します</font></font><code>currentPlayerPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マークに近いかどうかを知るには、マークの位置を表す変数が必要です。この例では</font></font><code>playerMark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、プレーヤーの位置を書き込むことができる</font><font style="vertical-align: inherit;">変数を作成しました</font><font style="vertical-align: inherit;">。次に、プレーヤーが近くにいるかどうかを知らせる3つの変数を追加しました。</font></font><code>proximityValueX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレーヤーとX軸マークの</font></font><code>proximityValueY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間の距離を計算し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">プレーヤーとY軸マークの間の距離を計算します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、</font></font><code>nearValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AIキャラクターが目標を達成するために作業を開始できるときに、プレーヤーがマークの位置からどれだけ離れているかを判断できます。プレーヤーがマークに近づくとすぐに、ブール変数</font></font><code>playerOnMark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は値をに変更します</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレーヤーとマークの間の距離を計算するために、以下を使用しました：プレーヤーと彼のマークの間の距離</font></font><code>(mark.position - player.position)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、AIキャラクターが立方体の近くにあるかどうかを判断するために、AIと立方体の間の距離を計算することによって同じ方程式を計算します。さらに、両方のマーク（プレーヤーとキューブ）の位置をコードに追加しました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
   Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
   Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
   nearValue = <span class="hljs-number">0.5f</span>;<font></font>
   nearCube = <span class="hljs-number">0.5f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AIキャラクターがキューブの隣にいるかどうかがわかったので、これで質問に答えて、計画した次のブランチに進むことができるかどうかを判断できます。</font><font style="vertical-align: inherit;">しかし、キャラクターがキューブの隣にいない場合はどうなりますか？</font><font style="vertical-align: inherit;">彼は立方体に近づく必要があります。</font><font style="vertical-align: inherit;">したがって、これをコードに追加します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform cubeMesh;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Finding;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
   Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
   Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
   nearValue = <span class="hljs-number">0.5f</span>;<font></font>
   nearCube = <span class="hljs-number">0.5f</span>;<font></font>
   speed = <span class="hljs-number">1.3f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  { <font></font>
      playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
      cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
      cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">false</span> &amp;&amp; Finding == <span class="hljs-literal">false</span>)<font></font>
  {<font></font>
     PositionChanging();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">true</span>)<font></font>
  {<font></font>
     Finding = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PositionChanging</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  Finding = <span class="hljs-literal">true</span>;<font></font>
  Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
  Vector3 positionB = cubeMesh.transform.position;<font></font>
  <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、AIキャラクターは自分と立方体の間の距離を計算できます。</font><font style="vertical-align: inherit;">それらが離れすぎている場合、彼は立方体に行きます。</font><font style="vertical-align: inherit;">このタスクを完了した後、彼は次のフェーズに進み、キューブのプッシュを開始できます。</font><font style="vertical-align: inherit;">彼が計算する必要がある最後の事柄は、立方体がマークの位置からどれだけ離れているかであり、その後、彼は、立方体のどちらの側にマークが近いかを考慮して、押し方を決定します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/be5/bf7/de1be5bf7e65540dfaeb6ab186a8e3c8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
立方体はX軸とZ軸に沿ってのみ押すことができます。立方体をインストールするとボタンがアクティブになるため、その回転はまだ重要ではありません。これがすべて与えられた場合、AIキャラクターは、キューブがXのマークの位置とZのマークの位置からどれだけ離れているかを計算する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、2つの軸の2つの値を比較し、どちらが望ましい位置から離れているかを選択して、これに沿ってプッシュを開始します軸。キャラクターは、立方体がマークの位置に揃うまでこの方向に押し続け、次に反対側に切り替わり、マークの位置を完全に超えるまで押し込みます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform cubeMesh;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeMarkProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeMarkProximityZ;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Finding;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
        Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
        nearValue = <span class="hljs-number">0.5f</span>;<font></font>
        nearCube = <span class="hljs-number">0.5f</span>;<font></font>
        speed = <span class="hljs-number">1.3f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">false</span> &amp;&amp; Finding == <span class="hljs-literal">false</span>)<font></font>
  {<font></font>
      PositionChanging();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">true</span>)<font></font>
  {<font></font>
      Finding = <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
   cubeMarkProximityX = cubeMark.transform.position.x - currentCubePosition.transform.position.x;<font></font>
   cubeMarkProximityZ = cubeMark.transform.position.z - currentCubePosition.transform.position.z;<font></font>
<font></font>
   <span class="hljs-keyword">if</span>(cubeMarkProximityX &gt; cubeMarkProximityZ)<font></font>
   {<font></font>
     PushX();<font></font>
   }<font></font>
<font></font>
   <span class="hljs-keyword">if</span>(cubeMarkProximityX &lt; cubeMarkProximityZ)<font></font>
   {<font></font>
     PushZ();<font></font>
   }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PositionChanging</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  Finding = <span class="hljs-literal">true</span>;<font></font>
  Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
  Vector3 positionB = cubeMesh.transform.position;<font></font>
  <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードに最新のアクションを追加した後、キャラクターは自分の目標を決定し、キューブを見つけて目的の位置にプッシュし、プレイヤーがレベルを通過して終了できるようにする必要があります。</font><font style="vertical-align: inherit;">この例では、シーンオブジェクトとキャラクター間の距離を計算する方法に焦点を当てました。</font><font style="vertical-align: inherit;">これは、ゲームオブジェクトを特定の位置に配置する必要がある同様のタイプのインタラクションを作成するのに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例は、プレイヤーを助けるフレンドリーなAIキャラクターを示していますが、反対の効果（キャラクターが敵の場合）が必要な場合も同じ原則を適用できます。つまり、プレイヤーをできるだけ早くキューブを見つけてプレイヤーを停止する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Age of Empiresの例を使用した環境内の障害物オブジェクト</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前に見たように、ゲーム内のオブジェクトを使用または移動して目標を達成できますが、オブジェクトの一部がキャラクターのパスを遮るとどうなりますか？オブジェクトは、プレーヤーが配置することも、デザイナーがマップのこの位置に配置することもできます。いずれの場合でも、AIキャラクターは、この状況で何をする必要があるかを決定できる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、Ensemble Studiosによって開発されたAge of Empires IIと呼ばれる戦略で、この動作を観察できます。城壁に囲まれているためにゲームキャラクターが敵の領土に到達できないたびに、AIは壁の一部を破壊するように切り替わります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタイプのインタラクションも非常にスマートで重要です。それ以外の場合、キャラクターは入り口を求めて壁に沿ってさまようだけであり、これは妥当な動作のようには見えません。</font><font style="vertical-align: inherit;">補強された壁はプレーヤーによって作成されるので、どこにでも配置でき、どのような形状でもかまいません。</font><font style="vertical-align: inherit;">したがって、敵AIを開発するときは、これについて考える必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/137/655/f44137655e3220988033bcb97db85b96.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例は、記事のトピックにも関連しています。計画段階でビヘイビアーツリーを作成するとき、何かがキャラクターの邪魔になり、目標を達成できない場合にどうなるかを考える必要があるためです。</font><font style="vertical-align: inherit;">この側面については、本の次の章で詳しく検討しますが、ここでは状況を簡略化し、環境オブジェクトが目標を達成できない場合にAIキャラクターがどのように動作するかを分析します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfb/464/89b/dfb46489b482f383bc95662246308536.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの例では、AIキャラクターは家に入る必要がありますが、近づくと、彼は自分が通過できない木製のフェンスに囲まれていることに気付きます。この段階でキャラクターにターゲットを選択させ、フェンスのこの部分が破壊されて家に入ることができるようになるまで攻撃を開始してもらいます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、フェンスの距離と現在のヘルスステータスを考慮して、キャラクターが攻撃するフェンスを計算する必要があります。 HPが低いフェンスは、HPが完全なフェンスよりも攻撃の優先度が高くなる必要があるため、計算ではこれを考慮します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/223/23f/ac4/22323fac4373a3556b58383bfb6b36fe.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャラクターの周囲を設定します。その範囲内で、最も近いフェンスが人工知能に情報を送信して、破壊しやすい方を決定で​​きるようにします。これは、フェンスのプレーヤーとの衝突の認識を使用するか、フェンス/オブジェクトとプレーヤーの間の距離を計算するよう強制するかのいずれかで、さまざまな方法で実装できます。プレイヤーがフェンスの状態を知覚し始める距離の値を設定します。この例では、距離を計算し、それを使用してHPフェンスについてキャラクターに通知します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、fenceオブジェクトに適用されるコードを作成してみましょう。それらはすべて同じスクリプトになります：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> HP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> distanceValue;
<span class="hljs-keyword">private</span> Transform characterPosition;
<span class="hljs-keyword">private</span> GameObject characterMesh;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-comment">// Use this for initialization</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  HP = <span class="hljs-number">100f</span>;<font></font>
  distanceValue = <span class="hljs-number">1.5f</span>;<font></font>
<font></font>
  <span class="hljs-comment">// Find the Character Mesh</span>
  characterMesh = GameObject.Find(<span class="hljs-string">"AICharacter"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Update is called once per frame</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Obtain the Character Mesh Position</span><font></font>
  characterPosition = characterMesh.transform;<font></font>
<font></font>
  <span class="hljs-comment">//Calculate the distance between this object and the AI Character</span>
  proximityValueX = characterPosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  proximityValueY = characterPosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  nearValue = proximityValueX + proximityValueY;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスクリプトでは、AIキャラクターとの接続に使用されるHPと距離に関する基本情報を追加しました。今回は、距離計算スクリプトをキャラクターではなく環境オブジェクトに追加します。これにより、オブジェクトにより多くのダイナミズムが与えられ、より多くの機会を生み出すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、ゲームのキャラクターもフェンスの作成に従事している場合、それらは異なる状態になります。たとえば、「建設中」、「完了」、「損傷」などです。その後、キャラクターはこの情報を受け取り、自分の目的に使用することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
環境オブジェクトと相互作用するキャラクターを設定しましょう。彼の主な目標は家へのアクセスを得ることですが、彼がそれに近づくと、彼は木製のフェンスに囲まれているために彼は中に入ることができないことに気付きます。私たちは状況を分析した後、私たちのキャラクターがフェンスを破壊して彼の目標を達成し、家に入ることを望みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャラクタースクリプトでは、静的関数を追加します。このフェンスの入力に、現在の「健康」に関する情報を送信できるフェンスがあります。これは、キャラクターが破壊に最も適したフェンスを選択するのに役立ちます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> fenceHP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> lowerFenceHP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> fencesAnalyzed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject bestFence;<font></font>
<font></font>
<span class="hljs-keyword">private</span> Transform House;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> timeWasted;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;<font></font>
<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        fenceHP = <span class="hljs-number">100f</span>;<font></font>
        lowerFenceHP = fenceHP;<font></font>
        fencesAnalyzed = <span class="hljs-number">0</span>;<font></font>
        speed = <span class="hljs-number">0.8</span>;<font></font>
<font></font>
        Vector3 House = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">300.2f</span>, <span class="hljs-number">83.3f</span>, <span class="hljs-number">-13.3f</span>);<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        timeWasted += Time.deltaTime;<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(fenceHP &gt; lowerFenceHP)<font></font>
        {<font></font>
            lowerFenceHP = fenceHP;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(timeWasted &gt; <span class="hljs-number">30f</span>)<font></font>
        {<font></font>
            GoToFence();  <font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GoToFence</span><span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
        Vector3 positionB = bestFence.transform.position;<font></font>
        <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/970/af0/7a8970af0c9b5aa303ba32d6dc021ec8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャラクターには最も基本的な情報がすでに追加されています。</font></font><code>fenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的変数になり、キャラクターの近所の半径内にある各フェンスが現在のHPに関する情報を記録します。次に、AIキャラクターは受け取った情報を分析し、HPが最も少ないフェンスと比較し</font></font><code>lowerFenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャラクターには、</font></font><code>timeWasted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破壊するのに適したフェンスの検索に費やした秒数を表す</font><font style="vertical-align: inherit;">変数があります</font><font style="vertical-align: inherit;">。</font></font><code>fencesAnalyzed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードにフェンスが既に存在するかどうかを確認するために使用され、存在しない場合は、キャラクターが見つけた最初のフェンスが追加されます。フェンスが同じHP値を持つ場合、キャラクターは最初にそれらを攻撃します。次に、フェンスのコードを追加して、キャラクターがスクリプトにアクセスして役立つ情報を入力できるようにします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> HP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> distanceValue;
<span class="hljs-keyword">private</span> Transform characterPosition;
<span class="hljs-keyword">private</span> GameObject characterMesh;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> nearValue;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        HP = <span class="hljs-number">100f</span>;<font></font>
        distanceValue = <span class="hljs-number">1.5f</span>;<font></font>
<font></font>
        <span class="hljs-comment">// Find the Character Mesh</span>
        characterMesh = GameObject.Find(<span class="hljs-string">"AICharacter"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        <span class="hljs-comment">// Obtain the Character Mesh Position</span><font></font>
        characterPosition = characterMesh.transform;<font></font>
<font></font>
        <span class="hljs-comment">//Calculate the distance between this object and the AI Character</span>
        proximityValueX = characterPosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
        proximityValueY = characterPosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
        nearValue = proximityValueX + proximityValueY;<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(nearValue &lt;= distanceValue){
            <span class="hljs-keyword">if</span>(AICharacter.fencesAnalyzed == <span class="hljs-number">0</span>){<font></font>
                AICharacter.fencesAnalyzed = <span class="hljs-number">1</span>;<font></font>
                AICharacter.bestFence = <span class="hljs-keyword">this</span>.gameObject;<font></font>
            }<font></font>
<font></font>
            AICharacter.fenceHP = HP;<font></font>
<font></font>
            <span class="hljs-keyword">if</span>(HP &lt; AICharacter.lowerFenceHP){<font></font>
                AICharacter.bestFence = <span class="hljs-keyword">this</span>.gameObject;<font></font>
            }<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ようやくこの例が完成しました。</font><font style="vertical-align: inherit;">これで、フェンスは現在のHPをキャラクターのデータ（</font></font><code>lowerFenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">と比較し</font><font style="vertical-align: inherit;">、そのHPがキャラクターの最低値よりも低い場合、このフェンスが考慮され</font></font><code>bestFence</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例は、ゲーム内のさまざまな動的オブジェクトにAIキャラクターを適応させる方法を示しています。</font><font style="vertical-align: inherit;">同じ原理を拡張して、ほとんどすべてのオブジェクトとの対話に使用できます。</font><font style="vertical-align: inherit;">また、オブジェクトを使用してキャラクターと対話し、それらの間で情報をリンクする場合にも適用可能で便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この投稿では、環境と相互作用するさまざまな方法を探りました。</font><font style="vertical-align: inherit;">この章で説明する手法は、さまざまなジャンルのゲームに拡張でき、AIキャラクターと環境の間の単純および複雑な相互作用を実行するために使用できます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja496058/index.html">Почему нужно роботизировать сельхозкомбайны, в чём сложности, и как мы это сделали за два года</a></li>
<li><a href="../ja496060/index.html">Intel 0x7E4サマートレーニング-すべてのウイルスに対応</a></li>
<li><a href="../ja496062/index.html">Deep Q Trading：オブジェクト指向Rコード</a></li>
<li><a href="../ja496064/index.html">レーザー「ブラスター」操作モデル</a></li>
<li><a href="../ja496074/index.html">アラン・ケイ：SmallTalkの歴史（要約と紹介）</a></li>
<li><a href="../ja496082/index.html">データエンジニアとデータサイエンティスト：違いは何ですか？</a></li>
<li><a href="../ja496084/index.html">Blazorクライアント側オンラインストア：パート6-注文の作成と代償アクションの操作</a></li>
<li><a href="../ja496086/index.html">Zextrasデジタルジョブを使用したリモート作業の整理</a></li>
<li><a href="../ja496088/index.html">4月21日ライブ！Badooローカリゼーションのミートアップ</a></li>
<li><a href="../ja496090/index.html">Zyxelで削除</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>