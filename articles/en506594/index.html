<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêÔ∏è üêß ‚è∫Ô∏è Redis Best Practices, Part 3 üíÄ üëáüèª ü§µüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Final translation of Redis Best Practices sections from the Redis Labs official website. The most unusual and interesting today under the cut!
 
 
 Th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Redis Best Practices, Part 3</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506594/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Final translation of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Best Practices</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sections </font><font style="vertical-align: inherit;">from the Redis Labs official website. </font><font style="vertical-align: inherit;">The most unusual and interesting today under the cut!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hr/6y/f5/hr6yf5w1hp0fh-i5vfa0p1pxeuy.png" width="15%"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first part is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the second is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This article contains the following topics:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time sequences on sorted sets;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time sequences on lexicographically sorted sets;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time sequences on bit fields;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic bandwidth limitation pattern;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloom filter;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">counter;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit counting pattern;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperLogLog;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lua scripts.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time Sequence Data</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Time sequence data, or data with a natural time order, can be modeled in Redis in several ways, depending on the data itself and the way you want to access it. </font><font style="vertical-align: inherit;">We will look at a few of these patterns:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time sequences on sorted sets;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time sequences on lexicographically sorted sets;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time sequences on bit fields;</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time sequences on sorted sets</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Time sequences on sorted sets (zsets) are a typical way of modeling a time sequence in Redis. </font><font style="vertical-align: inherit;">Sorted sets consist of unique objects whose scores are stored under one key. </font><font style="vertical-align: inherit;">Using this data type for sorted sets means that the count behaves as a kind of time indicator (often it is a time stamp accurate to the millisecond), and the element is recorded data. </font><font style="vertical-align: inherit;">The only benefit is that since this is a form of a set, only unique elements are allowed, and trying to record time sequences with the same values ‚Äã‚Äãwill only refresh the score. </font><font style="vertical-align: inherit;">To illustrate this problem, we take the following example of periodic recording of temperature:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time stamp</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temperature, C</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697976001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697977001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697978001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you simply add them to the sorted set using ZADD, you may lose some values: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ANTI-PATTERN</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD temperature 1586697976001 21<font></font>
(integer) 1<font></font>
&gt; ZADD temperature 1586697977001 22<font></font>
(integer) 1<font></font>
&gt; ZADD temperature 1586697978001 21<font></font>
(integer) 0<font></font>
&gt; ZRANGEBYSCORE temperature -inf +inf WITHSCORES<font></font>
1) "22"<font></font>
2) "1586697977001"<font></font>
3) "21"<font></font>
4) "1586697978001"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note that the third call to ZADD returns 0, which indicates that the new item has not been added to the set. Then in ZRANGEBYSCORE we see that there are only two records in the sorted set. Why? Because the first and third share the same object, and we just updated the account for this object. There are several ways around this problem. One of them is to include some random data with sufficient variation, thereby ensuring uniqueness. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, create a pseudo-random real number from 0 to 1, inclusive, then add it to our timestamp. In our example, we will leave it in decimal form for readability (in reality, it would be more reasonable to simply convert it to an 8-byte string to save space).</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD temperature2 1586697976001 21:1586697976001.2583<font></font>
(integer) 1<font></font>
&gt; ZADD temperature2 1586697977001 22:1586697977001.941678<font></font>
(integer) 1<font></font>
&gt; ZADD temperature2 1586697978001 21:1586697978001.732015<font></font>
(integer) 1<font></font>
&gt; ZRANGEBYSCORE temperature2 -inf +inf WITHSCORES<font></font>
1) "21:1586697976001.2583"<font></font>
2) "1511533205001"<font></font>
3) "22:1586697977001.941678"<font></font>
4) "1586697977001"<font></font>
5) "21:1586697978001.732015"<font></font>
6) "1586697978001"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, all ZADDs returned 1, indicating a successful addition, and ZRANGEBYSCORE returned all values. </font><font style="vertical-align: inherit;">This is a working method, however, it is not very efficient due to the waste of bytes to ensure uniqueness, which adds overhead to the storage. </font><font style="vertical-align: inherit;">In most cases, uniqueness will simply be swept away by your application. </font><font style="vertical-align: inherit;">It should be noted that adding uniqueness is not required if your data is already unique (for example, data including UUIDs). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With this method, you have access to all methods of sorted sets for analysis and control:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZRANGEBYSCORE allows you to get a specific slice between two timestamps (ZREVRANGEBYSCORE will return the slice in descending order);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZREMRANGEBYSCORE allows you to delete a specific range of timestamps;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZCOUNT - the number of elements between the timestamp range;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZINTERSTORE - allows you to get the intersection of two pieces of data and save it under a new key;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZUNIONSTORE - allows you to get the union of two pieces of data and also save it under a new key. </font><font style="vertical-align: inherit;">You can also use this to duplicate a sorted set.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZINTERSTORE and ZUNIONSTORE operations that work with multiple keys. </font><font style="vertical-align: inherit;">When working with a shared environment, you need to be careful to check that your new key is in the same segment, otherwise these commands will lead to an error.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time sequences on lexicographically sorted sets</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another way to work with time sequences is to use the lexicographic properties of sorted sets to store a timestamp and value. If you are not already familiar with this, then it's time to read </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this section</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With this method, we store everything with the same count and first encode the timestamp, then add the value as an element. Take an example:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD lex-temperature 0 1589392163001:21<font></font>
(integer) 1<font></font>
&gt; ZADD lex-temperature 0 1589392164001:22<font></font>
(integer) 1<font></font>
&gt; ZADD lex-temperature 0 1589392165001:21<font></font>
(integer) 1<font></font>
&gt; ZRANGE lex-temperature 0 -1<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In these three ZADD calls, the timestamp is separated from the value by a colon, and we can see that 1 is returned each time, which means that all three have been added. In ZRANGE we see the saved order. Why? In sorted sets, if the score is the same, the results with the same score are ordered by binary sort. Since timestamps in this period have the same number of digits, everything will be sorted correctly (if your timestamps are before 2002 or after 2285, you will need more digits to fill in). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To get a range of values ‚Äã‚Äãfrom this type, use the ZRANGEBYLEX command:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature (1511533200001 +<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second argument has a prefix (indicating the exclusivity of the value (inclusiveness is denoted by [). In practice, this format makes inclusiveness and exclusivity irrelevant, since the timestamp will always be followed by additional data. The third argument + indicates the unboundedness of the upper bound. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Try to get the date between 1589392160001 and 1589392165001 inclusive:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature [1589392160001 [1589392165001<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why did the timestamp data 1589392165001 not get into the sample, despite the inclusive prefix? </font><font style="vertical-align: inherit;">I want to believe that Redis somehow understands that this is a timestamp. </font><font style="vertical-align: inherit;">In fact, Redis just sees binary sorting. </font><font style="vertical-align: inherit;">In binary sorting, 1589392165001: 21 is greater than 1589392165001 inclusive or exclusive. </font><font style="vertical-align: inherit;">The correct way to include this in the upper bound is to add 1 millisecond to the desired upper bound and use exclusivity:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature [1589392160001 (1589392165002<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temporary sequences with lexicographically sorted sets have a similar set of useful commands, like temporary sequences with simply sorted sets:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZRANGEBYLEX / ZREVRANGEBYLEX - Gets a range of values ‚Äã‚Äãin ascending or descending order;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZREMRANGEBYLEX - removes a specific sorted range of values;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZLEXCOUNT - Gets the number of elements in a sorted range of values.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZINTERSTORE and ZUNIONSTORE can be used on lexicographically sorted sets, but there is a risk of data loss, because duplicate combinations of timestamps and values ‚Äã‚Äãwill not be duplicated in the returned result. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You may wonder why choose sorted sets with timestamps instead of encoding lexicographically sorted sets. </font><font style="vertical-align: inherit;">As a rule, it is better to work with lexicographically sorted sets for time sequences - if the values ‚Äã‚Äãare not always unique, timestamps will be more effective.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit Field Temporal Sequences</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis can effectively store time sequences in bit fields. </font><font style="vertical-align: inherit;">To do this, you must first select an arbitrary reference point and a numerical format. </font><font style="vertical-align: inherit;">Take the temperature measurement example. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose we want to take the temperature every minute, and we will set the starting point for midnight every day. </font><font style="vertical-align: inherit;">We measure room temperature in degrees Celsius. </font><font style="vertical-align: inherit;">You can structure the data as follows:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 minute = byte 0;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temperature is written in an 8-bit unsigned number (0-255).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a day, data is typed at about 1.44 kb. </font><font style="vertical-align: inherit;">You can record the temperature with the BITFIELD command:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #0 22<font></font>
1) (integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, using the bit-ts key, the temperature value 22 is written to the unsigned 8-bit number (u8) at midnight (# 0). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bit fields are not limited to unsigned 8-bit values. </font><font style="vertical-align: inherit;">Pay attention to the sign of the pound before the offset. </font><font style="vertical-align: inherit;">It means that alignment will occur on the selected type. </font><font style="vertical-align: inherit;">For example, if you specify "# 79" - this will mean the 79th byte, "79" - the 79th bit (see the BITFIELD help). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The offset can be aligned by the type of the stored number, starting from 0. For example, if we want to write 1 am, considering the zero slots, we use offset # 59 or offset # 719 for noon.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #59 23 SET u8 #719 25<font></font>
1) (integer) 0<font></font>
2) (integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The example also shows that BITFIELD is variable, i.e. </font><font style="vertical-align: inherit;">You can work with multiple values ‚Äã‚Äãin one call. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Add a few more values:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #60 21 SET u8 #61 20<font></font>
1) (integer) 0<font></font>
2) (integer) 0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now we will extract:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts GET u8 #59 GET u8 #60 GET u8 #61<font></font>
1) (integer) 23<font></font>
2) (integer) 21<font></font>
3) (integer) 20</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The signature of the GET bit subcommand is similar to the SET signature, with the only difference being that it does not accept a value as the third argument. </font><font style="vertical-align: inherit;">It‚Äôs normal when we know all the indexes that need to be obtained, but sometimes we need a range of values, and each byte individually will be too stressful. </font><font style="vertical-align: inherit;">We can use the GETRANGE command. </font><font style="vertical-align: inherit;">In a normal situation, it is used to get bytes from a string, but BITFIELDs are just another way of addressing the same data.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; GETRANGE bit-ts 59 61<font></font>
"\x17\x15\x14"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The command returned bytes 59 through 61 in hexadecimal (23, 21, and 20 in decimal. Client languages ‚Äã‚Äãhandle binary data better than redis-cli, and can usually get a language-specific byte array. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our example, we used bytes 0 , 59-61 and 719. What happens if we request bytes that have not yet been set?</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts GET u8 #40<font></font>
1) (integer) 0<font></font>
&gt; BITFIELD bit-ts GET u8 #750<font></font>
1) (integer) 0<font></font>
&gt; GETRANGE bit-ts 30 50<font></font>
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis returns unspecified bytes as 0. This can cause difficulties when working with time sequence data - the application logic needs to distinguish between 0 and an undefined value. </font><font style="vertical-align: inherit;">Rounding and omissions of 0 values ‚Äã‚Äãare possible, especially when using signed integers, as this may be a valid value in the middle of your range. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The actual length of the time sequence actually depends on the last byte. </font><font style="vertical-align: inherit;">In the example, the last stored byte is 719, so the data length is 720 bytes.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; STRLEN bit-ts<font></font>
(integer) 720</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BITFIELD-based time sequences are a powerful and compact pattern for storing numerical or binary data. </font><font style="vertical-align: inherit;">However, this solution does not cover all use cases, and its use should be carefully considered to suit your needs.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basic Bandwidth Limit Pattern</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creating bandwidth limiters with Redis is easy thanks to the INCR and EXPIRE commands. </font><font style="vertical-align: inherit;">The idea is that you want to limit requests to a specific service for a given period of time. </font><font style="vertical-align: inherit;">Suppose we have a service in which users are identified by an API key. </font><font style="vertical-align: inherit;">The service has a limit of 20 requests per minute. </font><font style="vertical-align: inherit;">To implement this, we want to create a Redis key on the API key every minute. </font><font style="vertical-align: inherit;">In order not to litter the database, the key validity period is also set to 1 minute. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
API key - zA21X31, bold - limit reached:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Key</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 1</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 2</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 3</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 4</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Value</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">twenty</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">twenty</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expires in</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:05</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:06</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:01</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></b></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The key is made up of the API key and the minute number through a colon. </font><font style="vertical-align: inherit;">Since the keys always expire, it‚Äôs enough for us to use only the minute numbers - with the onset of the new hour we can be sure that there are no other 59 keys (they expired 59 minutes ago). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see how it works:</font></font><br>
<br>
<ol>
<li><pre><code class="plaintext hljs">&gt; GET [ API]:[ ]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the result is less than 20 or not set, go to step 4, otherwise go to step 3;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Display an error message, close the connection and end;</font></font></li>
<li><pre><code class="plaintext hljs">&gt; MULTI<font></font>
OK<font></font>
&gt; INCR [user-api-key]:[current minute number]<font></font>
QUEUED<font></font>
&gt; EXPIRE [user-api-key]:[current minute number] 59<font></font>
QUEUED<font></font>
&gt; EXEC<font></font>
OK</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continue the program.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Two key points:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INCR on a nonexistent key will always be 1;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPIRE is located inside the MULTI transaction along with INCR, which means that it will be one atomic operation.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The worst case scenario is if, for some very strange and unlikely reason, the Redis server dies between INCR and EXPIRE. </font><font style="vertical-align: inherit;">When recovering data from either AOF or an in-memory replica, INCR will not be restored because the transaction was not completed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When using this pattern, it is possible that one user has two keys: one that is currently being used, and the other, which expires at this minute. </font><font style="vertical-align: inherit;">However, the pattern is very effective.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom filter</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Bloom filter is an interesting probabilistic data structure that you can use to check if an item has been added before. Here is the wording intentionally. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The probability is that there can only be a false positive response, but not a false negative. The Bloom Filter provides a much more compact and quick way to check for availability than to save all elements into a set and call SISMEMBER.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Bloom filter works by passing an element through the quick hash function, selecting bits from it and setting them to 1 and 0 at a certain interval in the bit field. To check for the presence of a filter, the same bits are selected. Many elements may have bits that overlap, but since the hash function creates unique identifiers, if one bit from the hash is still 0, then we know that it has not been added before. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis has been using the filter for many years as a client library that uses GETBIT and SETBIT to work with bit fields. Fortunately, the ReBloom module is available from Redis 4.0, which eliminates the need to create your own implementation of the Bloom filter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A good use case for this filter is to check if the username has already been used. </font><font style="vertical-align: inherit;">There are no problems with small data sizes, but as the service grows, database queries can be expensive. </font><font style="vertical-align: inherit;">This is easy to fix with ReBloom. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Add a few names for the test:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BF.ADD usernames funnyfred<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames fredisfunny<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames fred<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames funfred<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now test the Bloom filter:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BF.EXISTS usernames fred<font></font>
(integer) 1<font></font>
&gt; BF.EXISTS usernames fred_is_funny<font></font>
(integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As expected, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fred_is_funny</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> returned 0. This means that such a name was not used. </font><font style="vertical-align: inherit;">Although it is impossible to say for sure, since bits can simply overlap between several elements. </font><font style="vertical-align: inherit;">Basically, the chance of false positives is low, but not 0. As the Bloom filter fills, the chance increases, but you can adjust the error rate and the initial size (defaults to 0.01 and 100, respectively).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Counter</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A counter in Redis can be implemented in several ways. </font><font style="vertical-align: inherit;">The most obvious is INCR et al (INCRBY, INCRBYFLOAT, HINCRBY, HINCRBYFLOAT, ZINCRBY), which can be found by simply reading the documentation. </font><font style="vertical-align: inherit;">Less obvious are the use of BITCOUNT and PFADD.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit Counting Pattern</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BITCOUNT counts the number of bits set to 1 in the bit field by key. </font><font style="vertical-align: inherit;">This can be used to calculate a series of activities over an arbitrary period of time (similar to the pattern of time sequences on bit fields). </font><font style="vertical-align: inherit;">The process is to choose a point in time, and each bit represents a unit of period. </font><font style="vertical-align: inherit;">Each time an action is performed during this period, run SETBIT at a distance of 1 unit from the last point.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:00</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></th>
</tr>
<tr>
<td></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 2 1</code></pre></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 3 1</code></pre></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 4 1</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[starting point]</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Act</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Act</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Act</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To calculate at what minutes from 12:00 to 12:30 activity occurred, you can do this:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITCOUNT btct 0 30<font></font>
(integer) 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, this pattern answers the question ‚ÄúHow often?‚Äù Rather than ‚ÄúHow many times?‚Äù. </font><font style="vertical-align: inherit;">For example, a user could be active 20 times in one minute, but this will count as 1. The </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
real advantage of this template is that it provides the minimum possible score for a certain period of time, since bits are the most elementary building blocks of storage. </font><font style="vertical-align: inherit;">This is literally the smallest (uncompressed) repository for counting.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperLogLog</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Counting unique items can be tricky. This usually means storing each unique element and then invoking this information in some way. In Redis, this can be done using many and one team, however, both the volume occupied and the time complexity of this will be very large. HyperLogLog provides a probabilistic alternative. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HyperLogLog is internally similar to a Bloom filter, it also feeds elements through a non-cryptographic hash function and sets bits in a bit field. But, unlike the Bloom filter, HyperLogLog stores an element counter that increments when a new element is added that has not been added before. This gives a low error rate when counting unique elements in a set. HyperLogLog is built right into Redis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are 3 HyperLogLog commands in Redis: PFADD, PFCOUNT, and PFMERGE. </font><font style="vertical-align: inherit;">Let's say we create a web scanner and want to count the number of unique URLs of pages viewed during the day. </font><font style="vertical-align: inherit;">For each page, run the following command:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFADD crawled:20200613 "http://www.google.com/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200613 "http://www.redislabs.com/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200613 "http://www.redis.io/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200614 "http://www.redisearch.io/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200614 "http://www.redis.io/"<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each key above is indexed by day. </font><font style="vertical-align: inherit;">To see how many pages were viewed on 06/13/2020, you can do this:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFCOUNT crawled:20200613<font></font>
(integer) 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To view the number of pages for 06/13/2020 and 06/14/2020, use the PFMERGE command to create a new key with a value that combines two counters. </font><font style="vertical-align: inherit;">Please note that, since </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.redis.io</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is stored in both sets, it will be calculated once:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFMERGE crawled:20200613-14 crawled:20200613 crawled:20200614<font></font>
OK<font></font>
&gt; PFCOUNT crawled:20200613-14<font></font>
(integer) 4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This operation can work with several keys, so be careful in a divided environment, so that the keys are on the same shard.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lua scripts</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis can do amazing things just from ‚Äúredis-cli‚Äù and even more between Redis and your programming language. But sometimes you may need behavior that cannot be obtained in the client-server architecture due to efficiency or security issues - the logic needs to be executed in the database layer. In such cases, Lua comes to the rescue. Lua works in Redis as a scripting language. With it, you can execute code in Redis, without the cost of transport to and from the client.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A test case is adding a value to a hash field. </font><font style="vertical-align: inherit;">While Redis can easily add a value to a string key using APPEND, there is no command to add a value to a hash field. </font><font style="vertical-align: inherit;">You can try to get this by extracting the value from the client, adding a new line to the value and dropping the hash fields, but this is a bad idea. </font><font style="vertical-align: inherit;">Since this is non-atomic, it is likely that while you add a value, another client may change it earlier, and then you will overwrite the new value.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Customer 1</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Client 2</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HGET myhash myfield</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[hello returns]</font></font></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[adds ‚Äúworld‚Äù to ‚Äúhello‚Äù]</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HSET myhash myfield "goodbye"</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HSET myhash myfield "hello world"</code></pre></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; HGET myhash myfield</code></pre></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see on line 2, the update will be lost. </font><font style="vertical-align: inherit;">You can use Lua scripts to get around this problem and remove the cost of sending / receiving values ‚Äã‚Äãfrom the client. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In any text editor, create a script and call it </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">happened.lua</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">local</span> original = redis.call(<span class="hljs-string">'HGET'</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>])<font></font>
<span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">'HSET'</span>,KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], original .. ARGV[<span class="hljs-number">2</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the first line, create a local variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">original</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in which we save the current value of the hash key from the first argument passed, and the field is the first non-key argument. It is important to understand that runtime Lua scripts distinguish between keys and non-key arguments. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the second line, HSET is called for the same key and field, then we combine the original value with the second non-key argument. This returns back to Redis, so we will keep the original HSET return value.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Direct execution of Lua scripts with the EVAL command can be confusing and inefficient. </font><font style="vertical-align: inherit;">Redis has a built-in script cache that allows you to preload the script, then access it using the SHA1 hash from the main script. </font><font style="vertical-align: inherit;">You can download this script from the command line using "cat" and "redis-cli". </font><font style="vertical-align: inherit;">Please note that if your script differs by at least one character, it will have a completely different hash.</font></font><br>
<br>
<pre><code class="bash hljs">$ redis-cli -a yourRedisPassword SCRIPT LOAD <span class="hljs-string">"<span class="hljs-subst">$(cat ./happend.lua)</span>"</span><font></font>
<span class="hljs-string">"d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now you can use EVALSHA to invoke the script and add:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; HSET mynewhash greeting "Hello"<font></font>
(integer) 1<font></font>
&gt; EVALSHA d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099 1 mynewhash greeting " world"<font></font>
(integer) 0<font></font>
&gt; HGET mynewhash greeting<font></font>
"Hello world"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first argument to the EVALSHA command is the hash of the script generated by SCRIPT LOAD. The second argument is the number of keys. In our case, the key is one. The third argument is the key on which we perform the action. And finally, the fourth is the value that we add to the field. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the addition occurs inside the Lua script, the above script will abort because the Lua scripts are executed synchronously and atomically. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although Lua can be very helpful in resolving problems, you need to use it carefully. The script blocks the server and may lead to a non-responsive database. In sharding situations, scripts try to save all operations on a single server in order to avoid cross errors.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is where the Redis Best Practices section ends. </font><font style="vertical-align: inherit;">Do not be afraid to try and experiment, Redis is very rich in functionality. </font><font style="vertical-align: inherit;">Leave your interesting use cases in the comments. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I hope that the described techniques will help you if not directly, then at least by pointing to the right path to solving problems!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en506574/index.html">Visualization of a list of women Nobel Prize winners in the form of crystals in 3d using Vue, WebGL, three.js</a></li>
<li><a href="../en506578/index.html">Managed Lead Volume</a></li>
<li><a href="../en506586/index.html">Logical FizzBuzz</a></li>
<li><a href="../en506588/index.html">What is an algorithm! (part 2)</a></li>
<li><a href="../en506590/index.html">Conference DEVOXX UK. Choose a framework: Docker Swarm, Kubernetes or Mesos. Part 2</a></li>
<li><a href="../en506598/index.html">Microsoft: Rust is the 'Best Chance' in the Safe Systems Programming Industry</a></li>
<li><a href="../en506600/index.html">The contract for the development of the site in terms of project management (theory + sample)</a></li>
<li><a href="../en506604/index.html">Concurrency and Efficiency: Python vs FSM</a></li>
<li><a href="../en506606/index.html">PIXI.js clicker creation</a></li>
<li><a href="../en506610/index.html">WAL-G: PostgreSQL Database Backups and Recovery</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>