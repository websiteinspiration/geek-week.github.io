<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛑️ 🚙 🎵 Développement de firmware pour une caméra vidéo analogique EVR-Y2022F 🔎 👃 👩🏽‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans un article précédent, l'appareil d'une caméra vidéo analogique a été examiné en détail afin de créer son propre firmware. Comme déjà mentionné, l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Développement de firmware pour une caméra vidéo analogique EVR-Y2022F</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499546/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans un article précédent, l'appareil d'une caméra vidéo analogique a été examiné en détail afin de créer son propre firmware. Comme déjà mentionné, la caméra possède un microcontrôleur d'origine inconnue. Il est beaucoup plus riche que les AVR habituels: il a deux tensions d'alimentation 3,3V et 1,8V, et il a également une fonction DSP. Je suis arrivé à cette conclusion en pensant à la mise en œuvre de l'algorithme de mise au point automatique. Néanmoins, je n'ai pas préféré les MK complexes comme STM32 et d'autres, ne serait-ce que parce que je n'ai jamais travaillé avec eux du tout. J'ai définitivement décidé d'utiliser l'un des AVR MK pour implémenter mon firmware. Par conséquent, déjà à ce stade, j'ai commencé à réaliser que la mise en œuvre de la fonction de mise au point automatique ne sera pas très facile à gérer, ou plutôt impossible.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon choix s'est porté sur l'ATmega128 MK, car c'est lui qui est tombé dans mon bras. L'ATmega8 MK ne sera évidemment pas suffisant en termes de nombre de conclusions, d'autant que, au cas où, j'ai décidé de réserver un port MK entier pour le flux vidéo numérique du processeur vidéo. Tout d'abord, j'ai compris quelles fonctions seront dans mon propre firmware, en particulier les fonctions qui n'étaient pas dans le firmware d'origine et quelles fonctions devront être négligées.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons une variante de l'algorithme de mise au point automatique pour analyser un flux vidéo numérique. J'ai réussi à découvrir que les données du flux vidéo sont une alternance d'octets synchronisés avec les impulsions «CK». Les octets du flux vidéo codent les niveaux des composantes Y, Cr, Cb du signal vidéo avec une gradation de 8 bits (256 niveaux). C'est-à-dire que la sortie vidéo numérique du processeur vidéo de cette caméra est multiplexée en composantes. Les informations sur la luminosité (Y) sont contenues dans chaque deuxième octet du flux vidéo et les informations sur les couleurs sont deux fois moins fréquentes. C'est-à-dire que des informations sur le signal de différence de couleur du Cr rouge sont contenues dans chaque quatrième octet, ainsi que des informations sur le signal de différence de couleur du bleu. Ainsi, le flux représente la séquence suivante: Cb0, Y0, Cr0, Y1, Cb2, Y2, Cr2, Y3, Cb4, Y4, Cr4, Y5, .... C'est à dire,tandis que les informations sur la luminosité de chaque pixel sont fournies sans lacunes, les informations sur la couleur des pixels sont fournies successivement par composants. Cet amincissement est dû aux propriétés d'insensibilité à la couleur des petits détails et à une réduction de la bande de couleur dans le signal vidéo. Ces propriétés sont utilisées dans la télévision analogique et la numérisation vidéo. La «compression» (sous-échantillonnage des couleurs) ci-dessus a un rapport de composants de 4: 2: 2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour que l'algorithme de mise au point automatique fonctionne, il suffit d'analyser uniquement la composante de luminosité, ce qui est également facile à réaliser en interceptant le flux vidéo «octet par octet». Si la fréquence CK est d'environ 18 MHz, alors CK / 2 est de 9 MHz, ce qui semble tout à fait réalisable pour l'ATmega128 MK. Les impulsions de synchronisation horizontale et verticale permettent au contrôleur de «compter» et d'analyser n'importe quelle zone de l'image. Peut-être, pour l'algorithme de mise au point automatique, il suffit d'analyser uniquement le centre du raster. De toute évidence, meilleure est la mise au point, plus l'image est nette, et donc plus la bande de fréquences du signal vidéo est large (plus de composants RF). Autrement dit, il est possible (voire nécessaire) d'appliquer l'algorithme de transformation de Fourier rapide (FFT) à des fragments d'un flux vidéo numérique et d'analyser les composants RF. Dans ce cas, vous devez tordre la mise au point à chaque fois,en utilisant la méthode de la «demi-division» comme méthode d'optimisation mathématique. Ainsi, vous pouvez obtenir le meilleur résultat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne me suis pas soucié de la fonction autofocus, considérant que c'était impossible sur MK avec une architecture simple, même si, en tout cas, j'ai réservé un port pour la vidéo numérique. Au lieu de l'autofocus, j'ai décidé d'implémenter un certain nombre d'autres fonctions qui n'étaient pas disponibles dans le firmware d'origine. Mais pour cela, la caméra vidéo devra être limitée à des conditions stationnaires, ce qui est typique de la vidéosurveillance. Il est supposé que la caméra pourra ensuite tourner dans le plan horizontal et vertical en utilisant des mécanismes spéciaux, à la fois automatiquement et manuellement. Lorsque l'appareil photo vise automatiquement un objet spécifique, dont les coordonnées sphériques seront pré-enregistrées dans la mémoire de l'appareil de commande, les «coordonnées» du zoom et de la mise au point changeront également, qui seront également présélectionnées et stockées dans la mémoire.La gestion peut être organisée selon le protocole PELCO-D, de plus, dans la spécification de ce protocole, il y a une équipe spéciale pour cette entreprise. Les coordonnées du zoom et de la mise au point seront, bien entendu, «jumelées» pour une distance spécifique. Autrement dit, un objet qui sera situé à une distance donnée sera mis au point.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de commencer à écrire un micrologiciel, vous devez réfléchir aux périphériques de MK et aux conclusions qui seront impliquées. Ensuite, vous devez réfléchir à la façon de placer et de fixer la carte avec son propre MK à l'intérieur de la caméra. Et pour que ce soit aussi pratique et maintenable que possible. J'ai décidé d'utiliser une planche avec MK, dont les conclusions seront complètement acheminées vers les côtés gauche et droit. La carte sera située au bas de la caméra, où il y a peu d'espace, et sera maintenue sur une connexion détachable. Dans le même temps, il y aura des «broches» du connecteur sur la carte elle-même, et il y aura des prises de raccordement sur les côtés de la caméra. Pour les prises de réponse, j'ai décidé de fabriquer deux autres cartes adaptatrices, de la taille du côté de la caméra. Les lamelles de ces cartes vont en haut de la caméra, directement sur la carte principale. Il est supposé que chaque lamelle sera câblée au point souhaité sur la carte principale de la caméra.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant le développement de la carte avec MK, j'ai eu l'idée de compléter le caméscope avec une horloge (RTC), et j'ai mis en évidence la ligne I2C, placée sur la carte RTC DS1307 (je sais déjà quoi) avec du quartz et une batterie et, juste au cas où, EEPROM 24AA512, qui étaient par la main. Sur la carte du bord supérieur se trouvent également des connecteurs pour connecter les programmeurs SPI et JTAG. Sur la carte mère d'origine, MK est cadencé à partir de quartz 12 MHz. C'est la même chose pour moi. En général, il est préférable d'y mettre du quartz à 11,0592 MHz pour un fonctionnement UART clair. Les distances entre les "peignes" des articulations détachables ont été soigneusement calculées au préalable. J'ai décidé d'alimenter MK à partir du «Krenka» de cinq volts, qui sera vissé sur le châssis sous la carte principale (il servira également de dissipateur de chaleur). L'alimentation sera prélevée sur la tension d'entrée 12V immédiatement après le fusible FB801, comme indiqué sur la figure.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pk/rs/q8/pkrsq8mtjjredo8w2mfne5goziy.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 1. Gestion de l'alimentation du microcontrôleur.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En dessinant des planches dans "SprintLayout", je me suis demandé à quoi sert chaque broche du MK, qui est sortie "out" vers le connecteur. Le résultat est une telle image. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/95/xg/bm95xgf-akgycofwc_mdsjp8rki.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 2. Croquis de cartes de circuits imprimés supplémentaires.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pour vous dire la vérité, j'ai dessiné les planches latérales (le long des bords) au stade de la rédaction de cet article. Mais en fait, je les ai faites avec un cutter. Il s'est avéré que ce n'était pas l'option la plus réussie. Et la planche elle-même avec MK a été faite de travers. J'ai en quelque sorte vissé les cartes auxiliaires latérales sur les côtés du cadre de la caméra, en soudant des écrous de flux à la surface en cuivre du PCB. Le fait est qu'il y a très peu d'espace sur les côtés et que le couvercle de l'appareil photo est pratiquement «serré» dos à dos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les figures ci-dessous montrent la répartition des conclusions du MK, ainsi que leur objectif.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cc/ry/d2/ccryd2b_viknimo-w0asy0j8fuy.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 3. Le but des conclusions du microcontrôleur.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Il y a de nombreux points à commenter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour le programmeur SPI (STK200 +), la sortie «PEN» n'était pas nécessaire. L'activation a lieu par «RESET», comme d'habitude. Mais au lieu de «MISO» et «MOSI», le MK a une interface séparée (PDI / PDO), et la ligne «CLK» est combinée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme tension de référence pour l'ADC, j'ai choisi le même 5V, à partir duquel le MK lui-même est alimenté. J'ai essayé d'obtenir séparément 3,3 V (comme dans le circuit d'origine), mais en même temps, il y avait des pièges. Et pour passer à la tension de référence de 5 V, vous devez changer légèrement le circuit, comme indiqué sur la figure. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mn/od/wr/mnodwrbakf5xlxkq1qskzeuhmkc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 4. Traduction des boutons sur la tension de référence 5V.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Autrement dit, vous devez dessouder un côté de la résistance R505 du côté de l'alimentation 3,3 V, et lui appliquer à la place 5 V à partir de la ligne d'alimentation MK.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des conclusions de MK, qui ne sont utilisées qu'à l'intérieur de la carte conçue, seulement trois sont impliquées. Un signal d'impulsion de 1 Hz avec RTC arrive à PB7 pour mettre à jour l'heure. Les broches PD0 et PD1 sont affectées au bus I2C. Il sera implémenté par programme à l'aide de la bibliothèque CVAVR «i2c.h», malgré le fait qu'une interface matérielle i2c (TWI) soit attachée à ces sorties. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La broche MC «RESET» est sortie, mais la réinitialisation MK se fera d'elle-même sans chaîne de réinitialisation externe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il était entendu que les impulsions d'horloge HD et VD arriveraient au MK via des ports d'interruption externes pour la précision de la lecture du champ vidéo. Cependant, à l'exception de la fonction de mise au point automatique, ils ne sont plus nécessaires. Les signaux des commutateurs de fin de course de zoom et de mise au point arrivent aux ports voisins des interruptions externes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le port «A» MK est réservé au flux vidéo numérique. Le port "C" est entièrement réservé à SD.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La broche PD4 est utilisée pour commuter TX / RX RS-485. Il n'y avait pas de commutation dans le circuit d'origine: les 2ème et 3ème étapes de la puce MAX485 étaient au sol. Le MK d'origine ne pouvait recevoir des données pour contrôler la caméra via PELCO-D. J'ai décidé de faire une petite mise à jour. L'idée était la suivante. Si le caméscope est suspendu haut et dans un boîtier fermé, il sera tout simplement impossible de mettre à jour rapidement le firmware. Et un tel besoin surgira sûrement: éliminer divers bogues et améliorer les fonctionnalités deviendront une pratique régulière pour la première fois. Par conséquent, j'ai eu l'idée d'implémenter un chargeur de démarrage pour MK, et l'utilisant déjà à distance pour mettre à jour le firmware via RS-485. Et dans ce cas, un échange bidirectionnel est très souhaitable. À propos du chargeur de démarrage sera une partie distincte de cet article. Et pour connecter le MAX485 (2 et 3 pieds) à cette broche MK,vous devez apporter une petite modification à la première et la deuxième carte. Ces cartes sont connectées par un câble en boucle, sur les connecteurs duquel se trouve un contact «IRL» inutilisé pour le contrôle du rétroéclairage. Sur la deuxième carte (principale), vous devez dessouder la résistance R520 et souder à la place le fil qui passe par la carte adaptateur à l'ATmega128 MK à la sortie correspondante. Et sur la première carte, vous devez dessouder et plier 2 et 3 pieds d'U202, les souder ensemble et les tirer du câblage vers la sortie libre d'un connecteur J302. Ces opérations de changement de circuit sont représentées sur la figure.qui passera par la carte adaptateur à l'ATmega128 MK jusqu'à la sortie correspondante. Et sur la première carte, vous devez dessouder et plier 2 et 3 pieds d'U202, les souder ensemble et les tirer du câblage vers la sortie libre d'un connecteur J302. Ces opérations de changement de circuit sont représentées sur la figure.qui passera par la carte adaptateur à l'ATmega128 MK jusqu'à la sortie correspondante. Et sur la première carte, vous devez dessouder et plier 2 et 3 pieds d'U202, les souder ensemble et les tirer du câblage vers la sortie libre d'un connecteur J302. Ces opérations de changement de circuit sont représentées sur la figure.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qu/20/oe/qu20oe_mzvupcc4mpsbtg4omwma.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 5. Organisation de la ligne TRX pour contrôler le TX / RX MAX485.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Il y a deux interfaces UART à bord de l'ATmega128. Dans ce cas, vous devez utiliser la deuxième interface (broches 27, 28), car la première interface sur les broches (broches 2, 3) est combinée avec l'interface du programmeur SPI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au tableau, presque toutes les conclusions du MK sont en cause. Les conclusions du port «G» se sont avérées inutilisées. Soit dit en passant, il était possible d'implémenter l'horloge par programmation sur la base de MK. Il fournit un mode veille avec l'utilisation d'une batterie pour compter le temps lorsque l'alimentation principale est coupée. Il y a même des conclusions pour connecter un quartz basse fréquence séparé. Cependant, je n'ai pas pris la peine de gifler le DS1307.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La figure ci-dessous montre le but de chaque sortie de la carte avec MK. De plus, il est marqué sous condition quoi et de quel côté de la carte principale les fils de chaque broche seront soudés. Il est également nécessaire de faire quelques commentaires. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i0/fd/df/i0fddfrritx4bjzwqgsfl3bu1r4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 6. Affectation des conclusions d'un paiement supplémentaire à MK.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les signaux des commutateurs de fin de course de zoom et de mise au point arrivent non seulement aux ports d'interruption, mais également aux entrées ADC. Le fait est que même au stade de l'étude du DD, j'ai remarqué une telle fonctionnalité. Si le mécanisme de zoom ou de mise au point est à «zéro», le signal de sortie de la remorque peut prendre un état «intermédiaire». Pour mieux capturer ces cas rares, j'ai décidé d'utiliser l'ADC. Bien sûr, ce n'est pas une approche très compétente, mais en faisant cela, je suis rapidement sorti du problème qui se posait parfois au stade de l'initialisation dans mon firmware de test. Ainsi, j'ai augmenté la stabilité de l'algorithme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les signaux SDA / SCL de l'I2C sont simplement branchés dans le connecteur, juste au cas où, et ils ne sont pas utilisés en dehors de cette carte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les noms de chaque broche pour le contrôle de l'ID sont signés en fonction de la connexion réelle. La connexion des données, tournée vers l'avenir, a finalement été corrigée au stade du débogage. Il y avait beaucoup de confusion, mais les erreurs ne concernaient que l'alternance de phases précises à l'inverse, et non leur ordre. Les alternances «4-1-2-3» (pour le zoom) et «2-3-4-1» (pour la mise au point) sont identiques, ainsi que «1-2-3-4», qui et a été pris comme base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A la fin de l'article </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(pour ne pas faire honte)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deux photos sont présentées. Le premier est la vue de dessous du caméscope avec une vue du circuit imprimé supplémentaire. La seconde est une vue de dessus de dessus sur la carte principale d'une caméra vidéo avec un MK standard scellé (microprocesseur, pour être plus précis), un tas de cavaliers et autres morve.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai écrit le programme (firmware) avec ses tests préliminaires dans le programme ISIS 7 Professional (Proteus). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/qr/f7/mtqrf7iej-6e3adbtcg-bgghokq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 7. Vue du projet dans Proteus.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Au lieu des puces uniques du générateur de caractères et du processeur vidéo (qui, bien sûr, ne sont pas dans Proteus), j'ai installé des débogueurs SPI. Avec leur aide, il est pratique de contrôler les octets que MK envoie par SPI. Mais la véritable réaction à ces octets est contrôlée directement sur le matériel. Avec Proteus, vous pouvez surveiller et déboguer les commandes PELCO-D provenant d'un vrai DVR. Pour ce faire, en option, vous devez connecter le DVR au port COM de l'ordinateur via l'adaptateur unidirectionnel le plus simple RS485-&gt; RS232. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, j'ai commencé à développer et à modéliser. Excel y a beaucoup aidé.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez d'abord décider des temporisateurs et de leur configuration. Une minuterie - pour réaliser la rotation du moteur pas à pas et la mise en œuvre d'opérations répétées des boutons tout en les maintenant. Lorsque vous maintenez tel ou tel bouton pendant les réglages via le menu, le fonctionnement du SD sera exclu. Et lorsque vous maintenez l'un des boutons de contrôle du zoom ou de la mise au point en dehors du menu, le SD pivote avec le paramètre de temps correspondant. Ainsi, il n'y a pas de conflits. J'avais prévu d'utiliser le deuxième temporisateur pour implémenter PWM pour la SD, mais au fil du temps, j'ai décidé de l'abandonner. En effet, dans mon cas, lorsqu'il n'y a pas d'autofocus, il n'y a pas besoin de PWM. De plus, le mécanisme de transmission a une structure hélicoïdale, par conséquent, au repos, vous ne pouvez pas "tenir" le SD par courant continu, le mécanisme ne se glissera nulle part.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, vous devez réviser l'alphabet des caractères du générateur de caractères, selon la fiche technique, et le comparer avec l'alphabet standard ASCII. L'alphabet du générateur de caractères se compose de 128 caractères, soit la moitié de la taille du dernier. Par exemple, les caractères cyrilliques dans le générateur de caractères sont complètement absents, mais il y a des caractères spéciaux qui sont caractéristiques de son application (soleil, sablier, petit homme, note, téléphone, etc.). J'ai fait un tableau de «smb [256]» de 256 éléments, en le plaçant dans l'EEPROM MK. La notation smb [i] = adr signifie qu'à l'adresse adr dans le générateur de caractères il y a un caractère avec le code ASCII i. Et si le symbole i n'est pas dans l'alphabet du générateur de caractères, alors la valeur de l'élément de tableau fait référence à "l'espace" avec l'adresse 0x7E. Autrement dit, près de la moitié des éléments du tableau ont une valeur de "0x7E". Ce tableau est présenté sous forme de tableau dans la figure ci-dessous.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yo/_b/_g/yo_b_gqswkjfk1smuefynrwgs0e.png"><br>
<i>. 8.    ASCII    PD6464A.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, vous devez réfléchir à la façon de traiter les boutons via l'ADC. Selon la loi d'Ohm, il est facile de calculer les valeurs de tension à l'entrée de l'ADC lorsque vous cliquez sur un bouton. Après cela, il est facile de calculer les limites des intervalles, dont le milieu sera les mêmes valeurs de contrainte. Au total, six intervalles sont obtenus: cinq d'entre eux correspondent à chaque bouton et un à l'absence de pression (aucun bouton n'est enfoncé). Au niveau matériel, l'ADC MK analyse périodiquement la valeur de tension des boutons. La minuterie pour l'anti-rebond peut être implémentée sur la base du calcul des cycles d'horloge ADC, ce que j'ai fait. Au stade du débogage, cette partie du programme avait ses pièges. Je pense que ça ne vaut pas la peine d'écrire des détails. Pour réaliser le travail clair de cette fonctionnalité, j'ai dû bricoler longtemps. La fonction de reconnaissance des boutons est placée dans la section d'interruption ADC, et sur sa sortie est le numéro du bouton,drapeau de dépression et drapeau de libération. Un traitement ultérieur des boutons a lieu dans le cycle de programme principal. La fréquence de scrutation des boutons (fréquence ADC) était de 12000/128 = 93,75 (kHz), où 128 est le diviseur maximum possible.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, j'ai compilé un tableau de valeurs de registre UART UBRR1 de la configuration UART, en fonction de l'un ou l'autre débit en bauds PELCO-D, qui peut être sélectionné dans la liste des paramètres via le menu. </font><font style="vertical-align: inherit;">Ces valeurs peuvent être calculées en utilisant la formule de la fiche technique sur le MK, et peuvent également être obtenues en utilisant l'auto-configurateur AVR Wizard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai ensuite commencé à modéliser le menu. </font><font style="vertical-align: inherit;">Il s'agit de l'étape principale et chronophage de l'écriture d'un programme. </font><font style="vertical-align: inherit;">En principe, je n'allais pas répéter le menu du firmware standard, sauf pour cela, j'ai décidé de le compliquer à une structure hiérarchique (section dans la section). </font><font style="vertical-align: inherit;">Ci-dessous, une description du modèle et les définitions du menu que je me suis fait.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne peut pas lire</font></font></b>
                        <div class="spoiler_text">     .<br>
          .<br>
      .<br>
          .<br>
       «MENU».<br>
<br>
    «»    .<br>
    «»  «»       .<br>
  «»       .<br>
  «»       .<br>
  (   )   ,         .<br>
   « »,     .<br>
<br>
   :<br>
 — ;<br>
 — ;<br>
 — ;<br>
 — .<br>
<br>
    ,   ,   .<br>
    &lt;&gt;.<br>
     .<br>
         "&lt;..&gt;".<br>
      «».<br>
      ,   .<br>
        ( ) .<br>
    "&lt;..&gt;"      .<br>
        ,    .<br>
           .<br>
<br>
      .<br>
     .<br>
        .<br>
     "&lt;•&gt;" ( ).<br>
     "&lt; &gt;" ().<br>
      «».<br>
<br>
    .<br>
           .<br>
     «l*l» (,   «l»).<br>
     «l l» (,   «l»).<br>
        «».<br>
<br>
  ,       .<br>
     .<br>
           .<br>
            .<br>
       : «000», «00», «0».<br>
        .<br>
         : ": ".<br>
  —      (    )       .<br>
 ,   ,     «»  «».<br>
    «»     1.<br>
    «»     1.<br>
<br>
         .<br>
         .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la navigation dans les menus est quelque peu similaire à la navigation dans les fichiers et dossiers via «Total Commander». Le code d'implémentation de ce modèle de menu n'est pas très compliqué, mais très lourd. Il existe deux variables clés: le numéro de la page active et le numéro de la position active sur la page. Pour les deux variables, deux fonctions «boîtier de commutation» fonctionnent l'une dans l'autre. Cette paire de fonctions est impliquée dans le processus d'appuyer sur les boutons "Gauche", "Droite" et "Menu". À chaque endroit (pour chaque bouton, page et élément actuel) certaines actions sont enregistrées. Chaque page de menu possède une fonction qui implémente l'affichage de la page à l'écran avec toutes les inscriptions et les paramètres. Avant d'implémenter les fonctions de sortie de page, je les modélisais auparavant dans Excel, comme on dit, «par cellules».Ainsi, les coordonnées des cellules de chaque symbole sur le champ de l'écran sont présentées plus clairement, et cette information est nécessaire au stade de la programmation. Dans la figure ci-dessous, à titre d'exemple, j'ai donné la vue de la page 9, sur laquelle la vitesse de transmission PELCO-D est sélectionnée dans la liste. L'élément d'interface sur la page est un bouton radio. En plus de cela, le premier paragraphe &lt;..&gt; consiste à quitter cette section.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c0/s1/uy/c0s1uyuaoh9dawm-bqpf5g4pmjg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 9. Modélisation de l'OSD dans Excel.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
J'ai également créé un tableau qui reflète le nombre de points sur chaque page. Il est utilisé dans le traitement de la pression des boutons Haut et Bas. Ceci est fait pour réduire le code et éviter d'utiliser la fonction switch-case.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un appui virtuel répété tout en maintenant les boutons est implémenté dans le corps de l'interruption de la minuterie par la fonction «switch-case», travaillant sur une variable entière, qui est un drapeau. La valeur de l'indicateur est unique pour chaque action d'un bouton sur une page spécifique et un élément de menu spécifique. Il est attribué au drapeau en tant que numéro de série uniquement aux endroits où des clics virtuels sont nécessaires. Dans le même temps, à l'intérieur de la fonction «boîtier de commutation» (dans le corps de l'interruption de la minuterie) sont placées des copies des fonctions qui mettent en œuvre les actions des boutons. Pour économiser de la mémoire, il était possible de placer des «raccourcis» (liens) sur les appels réguliers à la fonction de traitement des boutons. C'est encore plus raisonnable, mais à ce moment-là, je n'avais pas la patience de penser à mieux le faire, car je voulais terminer le projet le plus tôt possible. Et la mémoire dans ATmega128 s'est avérée être beaucoup.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, j'ai implémenté des «bibliothèques» pour travailler avec un processeur vidéo, un générateur de caractères et le RTC DS1307 avec les fonctions nécessaires. Après cela, j'ai déterminé les adresses de l'EEPROM MK pour stocker telle ou telle information. Les 32 premiers octets sont réservés au stockage des informations sur les paramètres du menu. Les 32 octets suivants sont réservés au stockage de texte pouvant être affiché à l'écran ou modifié à l'aide de la commande standard "Pelco-D Write Char. À l'écran. " Les 256 octets suivants de la zone EEPROM sont réservés à l'alphabet (conversion d'un caractère ASCII en une adresse pour un générateur de caractères, comme mentionné ci-dessus). Enfin, les 128 octets suivants sont réservés au stockage de «préréglages» (modèles) de zoom / focus. J'ai introduit cette fonctionnalité en raison du manque d'autofocus. J'ai écrit à ce sujet au début de l'article. Un total de 32 modèles. Les coordonnées du zoom ou de la mise au point sont codées sur deux octets.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Séparément, il vaut la peine d'écrire sur la mise en œuvre de la gestion SD. La rotation du SD est obtenue en appelant les fonctions StepF () et StepZ () dans le bloc d'interruption de temporisation. La vitesse de rotation est déterminée par la configuration de cette minuterie. Et la mise en œuvre des fonctions ci-dessus implémente la promotion de la mise au point ou du zoom (respectivement) à un minimum. Pendant la rotation du zoom et de la mise au point, leur position finale est contrôlée. La position de la mise au point maximale et la position du zoom minimum sont représentées dans le programme par des constantes (280 et -600, respectivement). Mais la position du focus minimum et la position du zoom maximum - sous forme de variables F_min et Z_max (plus précisément, fonctions). Cette approche a été facilitée par une zone de travail non rectangulaire avec un coin inférieur droit coupé. Pour calculer les valeurs de F_min et Z_max, des fonctions définies par morceaux F_min (Z) et Z_max (F) sont utilisées. Outre,lorsque le zoom SD tourne dans le sens positif à Z (coordonnée zoom)&gt; 500, la mise au point SD tourne simultanément dans le même sens si ce dernier a des coordonnées &lt;(- 180). Autrement dit, la position de zoom maximale, en principe, n'est pas limitée par la position de mise au point actuelle, mais est limitée par le nombre 600. Simplement, deux SD tournent simultanément lorsque la limite angulaire correspondante de la région pentagonale est atteinte, et le mouvement à ce stade se produit le long du «côté coupé» (si interprété graphiquement) ) Du point de vue de la mécanique, cela équivaut au processus décrit dans l'article précédent, lorsque, en l'absence de SD et lors du déplacement manuel des nœuds de zoom et de mise au point, le nœud de zoom à la fin du chemin «tire» le nœud de mise au point. Étant donné que la coordonnée du zoom domine la coordonnée de mise au point (c'est pourquoi je considère la dépendance F (Z),mais pas l'inverse), je n'ai pas commencé à implémenter une procédure de "défilement" de zoom similaire dans la fonction Step_F ().</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le firmware d'origine, la vitesse de changement du zoom et de la mise au point avait des valeurs fixes. Ce n'est pas toujours pratique. Dans mon firmware, j'ai fourni quatre valeurs des vitesses de zoom et de mise au point (indépendamment), qui peuvent être sélectionnées à la fois via le menu et en utilisant la commande PELCO-D affectée à cette fonction. Ces quatre valeurs sont présélectionnées au stade du débogage en fonction de la commodité, puis elles sont entrées dans le micrologiciel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction d'initialisation BD init_MR () est nécessaire pour lier la mécanique du zoom et la mise au point au système de coordonnées. Elle est effectuée une fois à chaque mise sous tension du caméscope. L'algorithme de son travail est approximativement le suivant. Tout d'abord, il est supposé que le zoom ou la mise au point est au point zéro, et une tentative est faite pour capter le rebond du signal des fins de course par des fonctions d'interruption externes. Je noterai tout de suite que si le zoom ou la mise au point est "à zéro" (à la limite du partitionnement de la bande-annonce optique), le signal à la sortie de la bande-annonce a un état "intermédiaire" entre "0" et "1" logique. De tels cas sont très improbables, mais ils ne peuvent être exclus. Cependant, la fonction d'interruption n'interprète pas un signal tel qu'un rebond. C'est pourquoi je suis venu utiliser l'ADC MK, déclenchant des signaux à partir des interrupteurs de fin de course et de fin de course sur ses deux canaux libres. Donc,la première étape est la "numérisation" des signaux des fins de course avec une précision de 8 bits. Cela se fait à l'aide d'une seule conversion analogique-numérique. Il convient de rappeler que la tension de référence dans notre cas est de 5 V et que le niveau logique «1» du fin de course est de 3,3 V. Pour un «0» logique, la valeur ADC sera nulle et pour un «1» - 3,3 / 5 * 255 = 168. Si la valeur du signal de l'une ou l'autre bande-annonce tombe dans la plage, disons, de 2 à 165 (un intervalle flou est pris), cela signifie que le nœud correspondant est déjà «à zéro», et la procédure d'initialisation pour ce nœud peut être arrêtée. Sinon, par la valeur logique du signal de fin ("0" ou "1"), vous devez déterminer dans quelle partie (la moitié) le nœud est situé. Le sens de rotation du SD en dépendra. D'une manière ou d'une autre, le SD doit être tourné dans cette direction,de sorte que le nœud correspondant se déplace vers le "zéro" (fin de course). Ainsi, la rotation de l'entraînement du moteur démarre avec le calcul simultané du nombre de pas jusqu'à ce que le fin de course soit atteint. Dès que le fin de course correspondant est atteint, ce qui détermine la fonction d'interruption externe en fonction de la différence de niveau logique, il y aura une rotation inverse de l'entraînement du moteur. Il tournera dans la direction opposée du même nombre d'étapes, revenant ainsi à sa position d'origine. La valeur du nombre de pas pour chaque BD avec le signe correspondant sera copiée dans les variables correspondantes avant de quitter la fonction d'initialisation. La procédure décrite ci-dessus se produit indépendamment pour la mise au point et le zoom dans la même fonction (pas à son tour).La vitesse de rotation de l'entraînement du moteur à l'étape d'initialisation est déterminée par une constante distincte et correspond à la vitesse maximale pour une rotation correcte et sûre du SM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons l'exemple où, avant d'allumer l'appareil photo, le zoom était dans la zone négative et la mise au point était dans la zone positive. La figure montre schématiquement la trajectoire du point (Z; F) pendant la procédure d'initialisation du moteur pas à pas. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1p/59/6d/1p596dlrqriwqff1jh4jfrtvu-8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 10. Le processus d'initialisation du zoom et de la mise au point.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Le point A est la position initiale du zoom et de la mise au point. Le mouvement des deux nœuds se produit dans le sens "zéro" avec la même vitesse (vitesse d'initialisation). Au point B, la mise au point atteint zéro, car elle était plus proche de zéro que le zoom. Ensuite, la mise au point est inversée. Au point C, le focus termine le processus d'initialisation, revenant à sa position d'origine. Dans le même temps, le zoom se déplace toujours vers son «zéro». Au point D, il atteint son «zéro» et revient à sa position d'origine (point A).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de la fonction d'initialisation init_MR (), il existe une fonction goto_zf (z, f). </font><font style="vertical-align: inherit;">Basé sur le nom, il est destiné à passer d'un préréglage à un autre, dont j'ai parlé au début de l'article. </font><font style="vertical-align: inherit;">La vitesse de rotation du moteur pas à pas pendant la transition est la même que lors de l'initialisation. </font><font style="vertical-align: inherit;">Le processus de transition en zoom et mise au point s'effectue simultanément. </font><font style="vertical-align: inherit;">Autrement dit, s'il est nécessaire de passer du point (z1; f1) au point (z2; f2), la rotation simultanée de deux SD est lancée. </font><font style="vertical-align: inherit;">Si, par exemple, | f2-f1 | &lt;| z2-z1 |, le focus SD s'arrêtera plus tôt. </font><font style="vertical-align: inherit;">Ceci est démontré dans la figure ci-dessous. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fb/-y/ya/fb-yyanbovlb6i3pe6rxsfh0ax8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. </font><font style="vertical-align: inherit;">11. Processus de modification du zoom et de la mise au point lors du choix d'un préréglage.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant toute la durée de fonctionnement du moteur pas à pas pendant le passage du limiteur de top zéro, la coordonnée correspondante est mise à zéro. </font><font style="vertical-align: inherit;">Et cela malgré le fait que théoriquement cela ne peut pas être fait. </font><font style="vertical-align: inherit;">Cependant, dans la pratique, il y a toujours une erreur de 1-2 étapes de la SD.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient d'ajouter que, contrairement au firmware d'origine, dans mon cas, lors du contrôle du zoom et de la mise au point (à la fois à partir des boutons et via PELCO-D), j'ai prévu la possibilité d'un mouvement pas à pas. Cela fonctionne comme suit. Lorsque vous cliquez sur l'un des 4 boutons pour contrôler le zoom ou la mise au point, la SD correspondante est tournée d'un pas, minimisant ainsi le mouvement du nœud de zoom ou de mise au point. Si vous ne relâchez pas le bouton, la rotation normale du moteur pas à pas commencera après une courte période de temps. Ce retard est sélectionné empiriquement à l'avance. Cette fonction est similaire aux pressions répétées virtuelles tout en maintenant le bouton enfoncé. Grâce à cette fonctionnalité, le problème de «coller» le bouton lors du contrôle du zoom ou de la mise au point sur le périphérique distant PELCO-D via une mauvaise connexion Internet est éliminé. Plus précisément, l'occasion se présente comme impoli,et affiner le zoom ou la mise au point.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'interpréteur des commandes PELCO-D se fait par la même analogie que dans le dispositif de commutation de charges via PTZ. Plus tôt, j'ai consacré un petit article séparé sur Habré à ce dispositif simple. Contrairement au firmware d'origine, les commandes de contrôle du zoom et de la mise au point se réfèrent entièrement à la pression des boutons correspondants. Autrement dit, il est possible de «grimper» dans le menu à l'aide des boutons de zoom et de mise au point PELCO-D. Et afin d'appeler à distance le menu via PELCO-D, ou plutôt d'appuyer sur le bouton "MENU", j'ai comparé le bouton d'ouverture d'ouverture avec lui, car cette fonction n'est pas utilisée dans ce modèle d'appareil photo. Ainsi, il existe cinq commandes de base PELCO-D pour appuyer, ainsi que cinq commandes de base pour relâcher les boutons. De plus, comme je l'ai déjà écrit avec désinvolture tout au long de l'article, des commandes supplémentaires sont traitées: «Set Preset», «Clear Preset»,«Aller au préréglage», «Écrire le caractère. Vers l'écran »,« Effacer l'écran »,« Définir la vitesse du zoom »,« Définir la vitesse de mise au point ».</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La date et l'heure avec RTC sont affichées dans le coin inférieur gauche de l'image par analogie avec les anciennes caméras VHS, si cette option est activée dans le menu. De plus, dans le menu, vous pouvez sélectionner le format de sortie, que j'ai également fourni à l'avance. Sur l'écran à côté de la date et de l'heure, il est possible d'afficher le jour de la semaine. En plus de l'horloge, les coordonnées actuelles du zoom et de la mise au point sont affichées à l'écran comme informations supplémentaires. Cette option est nécessaire principalement au stade du débogage.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vais vous parler des fonctions du menu que j'ai implémenté. Au fil du temps, si nécessaire, le menu sera révisé: certaines fonctions peuvent être supprimées et d'autres ajoutées. La structure de menu que j'ai dessinée dans SPlan, avec les pages vues, est illustrée dans la figure ci-dessous. Flèches rouges - entrez dans la section. Flèches bleues - sortie de la section. Je n'ai pas dessiné de flèches bleues sur chaque page du menu, je n'en ai dessiné que deux par exemple. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/vs/mp/rlvsmpdeoixbmwlg-jmf2uwj51m.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 12. La structure du menu à l'écran.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certaines sections de mon menu sont un peu comme des sections de l'original. Tout d'abord, ce sont les deux premières sections: la balance des blancs et l'exposition. Dans la troisième section, vous pouvez spécifier l'adresse de la caméra PELCO-D et sélectionner le débit de données (débit en bauds) dans la liste. La quatrième section est consacrée à la date et à l'heure. Vous pouvez définir la date, l'heure, le jour de la semaine, choisir l'un des quatre formats d'affichage et choisir une méthode d'affichage. La cinquième section - travailler avec des préréglages (modèles) de zoom et de mise au point, où vous pouvez l'appeler par numéro, ainsi qu'effacer ou écraser. Toujours dans cette section du menu, vous pouvez choisir l'une des quatre vitesses pour changer la mise au point ou le zoom. La cinquième section vous permet de modifier les paramètres du processeur vidéo, situé dans l'octet 9 de la catégorie 3. Il s'agit du niveau et de l'inversion de la composante de rafale du signal vidéo et de la mise en miroir vidéo. La dernière section du menu est pour le débogage.En l'utilisant, vous pouvez écrire sur le processeur vidéo n'importe quelle valeur de n'importe quel octet dans n'importe quelle catégorie. La valeur peut être définie à la fois sous forme décimale et binaire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vais maintenant dire quelques mots sur le chargeur de démarrage. Comme je l'ai déjà écrit, le chargeur de démarrage est nécessaire pour flasher à distance le caméscope via RS-485. Au départ, je pensais implémenter entièrement le chargeur de démarrage moi-même. Cependant, afin de gagner du temps, j'ai décidé de faire avec l'un des téléchargeurs prêts à l'emploi déjà implémentés qui peuvent être trouvés sur Internet. De plus, je ne les ai jamais utilisés, en ayant une idée uniquement au niveau théorique. L'un des critères importants pour choisir un chargeur de démarrage est le support RS-485. En règle générale, les téléchargeurs AVR fonctionnent sur UART RS-232. Et le chargeur de démarrage avec prise en charge RS-485 ne diffère que par le fait qu'une sortie supplémentaire est allouée du côté MK pour commuter l'émetteur-récepteur RS-485 (par exemple, MAX485) pendant le transfert de données du MK vers le PC. Lors du flashage de MK, le chargeur de démarrage transmet à l'ordinateur des informations sur l'enregistrement réussi ou échoué. Premier chargeur de démarrageque j'ai trouvé vous permet d'enregistrer non seulement la mémoire FLASH de MK avec le firmware, mais aussi l'EEPROM. En plus d'écrire, vous pouvez également lire des données. Mais ce projet avec le code source de l'assembleur était assez déroutant et je ne l'ai pas compris. De plus, l'accent principal de ce chargeur de démarrage visait la possibilité de flasher plusieurs périphériques individuellement, sans les déconnecter du réseau RS-485, en accédant à chaque périphérique à une adresse qui lui était auparavant connectée. Je n'ai pas besoin de telles fonctionnalités, car j'utilise une topologie différente du réseau RS-485, et il est possible de passer rapidement du caméscope du DVR au PC. Le deuxième chargeur de démarrage est le Chip45 allemand. Le code source n'est pas dans le domaine public, il peut être acheté auprès de l'auteur. Au lieu de cela, il existe plusieurs centaines de fichiers HEX pour différents AVR MK, différentes interfaces UART (s'il y en a plusieurs, comme dans mon cas),RS-485 ou RS-232 au choix. Bref, pour toutes les occasions. Dans le même temps, l'auteur note que dans le cas du RS-485, la broche de commutation TX / RX est fixe et correspond à la broche XCK UART de l'interface du contrôleur, qui n'est pratiquement pas utilisée dans UART. Dans mon cas, la 30ème broche du XCK de la deuxième interface UART de l'Atmega128 MK est PORTD.5 ​​et sert à activer les interrupteurs de fin de course de zoom et de mise au point. En principe, cette fonction n'est pas nécessaire, car, comme l'ont montré des études, les interrupteurs de fin de course sont toujours actifs, comme je l'ai déjà écrit. Et si nécessaire, vous pouvez transférer cette fonction sur n'importe quelle autre sortie libre MK. Mais, de toute façon, ce chargeur de démarrage ne m'a pas non plus impressionné, d'autant plus que je suis tombé sur un chargeur de démarrage plus intéressant appelé «AVR Universal Bootloader» de conception chinoise. Comme Chip45, il ne peut écrire et que dans la mémoire FLASH de MK.Mais il a un grand nombre de possibilités, et j'ai donc fermement décidé de rester dessus. Il s'agit d'un projet AVR Studio avec du code source C. Étant donné que je travaille dans CodeVisionAVR, j'ai dû installer AVR Studio avec WinAVR. Pour obtenir le fichier HEX du micrologiciel du chargeur de démarrage, vous devez compiler le projet en apportant des modifications préliminaires au code source de la configuration de votre appareil et vous avez besoin de la vôtre. La compilation du projet consiste à lancer un fichier bat (fichier batch), dans lequel les commandes de compilation sont écrites. Il n'est donc pas nécessaire d'ouvrir un projet dans AVR Studio. Les changements dans le code source peuvent être effectués soit manuellement (au niveau du programmeur), soit en utilisant le configurateur. Le rôle de ce dernier est une fenêtre supplémentaire de l'utilitaire qui fonctionne avec le chargeur de démarrage, qui est également attaché.Dans le configurateur, vous pouvez spécifier la broche MK pour la commutation TX / RX RS-485, la broche MK pour la LED de contrôle clignotante, la broche MK pour entrer dans le chargeur de démarrage, la façon d'entrer le chargeur de démarrage, le nom et la fréquence MK, etc. De plus, le programme standard bien connu «HyperTerminal» peut servir d'utilitaire pour charger un programme utilisateur dans MK, c'est-à-dire pour travailler avec le chargeur de démarrage. Il utilise le protocole «Xmodem» pour télécharger le firmware. Et afin de travailler de manière pratique et visuelle avec le chargeur de démarrage via le terminal texte, la fonction spéciale «Mode verbeux» est fournie dans le configurateur. Mais malgré l'attrait de l'hyperterminal, j'ai décidé d'utiliser l'utilitaire fourni avec le chargeur de démarrage. Le fait est qu'avec la fonction Verbose pratique activée dans le configurateur, via le terminal, je suis tombé sur la situation suivante.Parfois, cela arrivait lorsque le trafic de données sur la ligne «entrait en collision» (les deux appareils en mode TX), à la suite de quoi le MAX485 dans le caméscope est devenu très chaud et a échoué, ou plutôt, pas complètement, mais uniquement la section RX (transmission de données via RS-485 à la caméra) . Pour cette raison, j'ai abandonné HyperTerminal. Et il y a encore un inconvénient. HyperTerminal ne fonctionne pas avec les fichiers texte HEX et accepte uniquement un fichier binaire. Par conséquent, je devrais appliquer une conversion supplémentaire de hex en bin. Après avoir généré le fichier HEX du chargeur de démarrage, je l'ai cousu dans le MK à l'aide du programme PonyProg et du programmeur SPI habituel. Par conséquent, le chargeur de démarrage fonctionne comme suit. Lorsque vous allumez le caméscope, le chargeur de démarrage est immédiatement activé. Il attend une connexion de l'utilitaire pendant une seconde, puis le firmware principal commence à fonctionner. Si la connexion est établie avec succès,puis le processus de clignotement commence. Dans le même temps, l'autre extrémité de la ligne RS-485 doit être préalablement déconnectée du DVR et connectée au PC via l'adaptateur USB RS485 &lt;-&gt; RS232 ou RS485 &lt;-&gt; USB. Soit dit en passant, sur les adaptateurs. La question s'est posée de savoir comment fabriquer soi-même un tel adaptateur, car les adaptateurs achetés sont chers. En fouillant sur Internet, j'ai trouvé un simple circuit adaptateur RS485 &lt;-&gt; RS232. Il est illustré dans la figure ci-dessous. Il se compose principalement de microcircuits bien connus MAX232 et MAX485, et TX / RX est commuté par le signal de la 3e sortie du connecteur de port COM de l'ordinateur via un circuit à diode zener. Autrement dit, le MAX485 est commuté par le trafic de données que le PC transmet. Tout est simple et ingénieux.RS232 ou RS485 &lt;-&gt; USB. Soit dit en passant, sur les adaptateurs. La question s'est posée de savoir comment fabriquer soi-même un tel adaptateur, car les adaptateurs achetés sont chers. En fouillant sur Internet, j'ai trouvé un simple circuit adaptateur RS485 &lt;-&gt; RS232. Il est illustré dans la figure ci-dessous. Il se compose principalement de microcircuits bien connus MAX232 et MAX485, et TX / RX est commuté par le signal de la 3e sortie du connecteur de port COM de l'ordinateur via un circuit à diode zener. Autrement dit, le MAX485 est commuté par le trafic de données que le PC transmet. Tout est simple et ingénieux.RS232 ou RS485 &lt;-&gt; USB. Soit dit en passant, sur les adaptateurs. La question s'est posée de savoir comment fabriquer soi-même un tel adaptateur, car les adaptateurs achetés sont chers. En fouillant sur Internet, j'ai trouvé un simple circuit adaptateur RS485 &lt;-&gt; RS232. Il est illustré dans la figure ci-dessous. Il se compose principalement de microcircuits bien connus MAX232 et MAX485, et TX / RX est commuté par le signal de la 3e sortie du connecteur de port COM de l'ordinateur via un circuit à diode zener. Autrement dit, le MAX485 est commuté par le trafic de données que le PC transmet. Tout est simple et ingénieux.Il se compose principalement de microcircuits bien connus MAX232 et MAX485, et TX / RX est commuté par le signal de la 3e sortie du connecteur de port COM de l'ordinateur via un circuit à diode zener. Autrement dit, le MAX485 est commuté par le trafic de données que le PC transmet. Tout est simple et ingénieux.Il se compose principalement de microcircuits bien connus MAX232 et MAX485, et TX / RX est commuté par le signal de la 3e sortie du connecteur de port COM de l'ordinateur via un circuit à diode zener. Autrement dit, le MAX485 est commuté par le trafic de données que le PC transmet. Tout est simple et ingénieux.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dg/_j/xg/dg_jxg5vy5h-i32yee8szg8urho.png"><br>
<i>. 13.   RS-232 &lt;-&gt; RS-485.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir maîtrisé le bootloader, dans mon temps libre, j'ai décidé de rechercher l'optique du caméscope. Plus précisément, il m'est devenu intéressant de savoir quelles combinaisons de valeurs de zoom et de mise au point produiraient des images focalisées à différentes distances de l'objectif au sujet. Permettez-moi de vous rappeler que la région de diverses valeurs mutuelles de zoom et de mise au point est décrite par une région pentagonale (presque rectangulaire). Par exemple, prenez la distance de l'objectif au sujet de 10 cm. L'argument (le long de l'axe des abscisses) du zoom a une plage de valeurs de -600 à 600. Il est nécessaire de sélectionner la valeur de mise au point à chaque valeur de zoom à laquelle le sujet devant l'objectif dans l'image vidéo sera mis au point. Ensuite, vous devez faire un tableau. Bien sûr, cela n'a aucun sens de trier les 1200 valeurs de zoom, il suffit de prendre quelques dizaines de valeurs avec un certain pas égal. En tant que telle étape, j'ai choisi la valeur 50.À chaque valeur de zoom avec cette étape (-600, -550, -500, ...) j'ai sélectionné la valeur de mise au point et enregistré les résultats de mesure. J'ai fait une procédure similaire avec d'autres distances de l'objectif au sujet: 50 cm, 1 m, 10 m, 100 m. Le résultat était une famille de courbes que j'ai affichées dans Excel.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5o/_4/qi/5o_4qikxragcwmdaeespjactaoi.png"><br>
<i>. 14.  Z-F   .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En regardant les graphiques, je veux faire beaucoup de commentaires. Au zoom minimum, les valeurs de mise au point sont légèrement inférieures au «milieu» (zéro) pour presque toutes les distances. La courbe rose sur une distance de 10 cm se termine à une valeur de zoom d'environ 250, ce qui correspond à la valeur de mise au point minimale. Cette courbe a un caractère décroissant et est convexe vers le haut. La courbe rouge sur une distance de 1 m a une forme complètement différente. D'une part, elle n'est pas monotone, et d'autre part, en ce qui concerne la propriété de convexité, il existe un point d'inflexion. Les courbes pour des distances de 10 m et 100 m sont de même nature, celles-ci coïncident d'ailleurs pratiquement, que je connaissais déjà à l'avance. Par conséquent, les distances mesurées de 10 et 100 mètres, bien sûr, j'ai pris environ. Ce qui fait osciller la courbe bleue sur une distance d'un demi-mètre - au départ, je n'allais pas prendre de mesures dessus.J'ai choisi cette distance approximativement sur la base du principe que le plus près possible avec un fragment de la courbe correspondante approche de la limite d'angle de la région (coupe). Et c'est arrivé: cette bordure touche pratiquement un fragment de la courbe. En général, il convient de noter que la moitié supérieure de la région (valeurs de mise au point positives) n'est pratiquement pas utilisée. L'exception est à une grande distance du sujet à l'objectif et au plus grand zoom. Et pourtant, pour presque toutes les distances (sauf la plus proche, moins d'un demi-mètre), à ​​faible zoom (150 ou moins), les valeurs de mise au point sont presque les mêmes. D'une manière générale, tous les faits de mesure énoncés doivent avoir une interprétation théorique, basée sur les lois de l'optique. Mais à l'heure actuelle, je n'ai aucune idée des appareils de lentilles de ce genre. Maximum,ce que j'ai rencontré dans le domaine de l'optique, c'est la construction d'un simple télescope réfracteur à deux lentilles. Et dans le cas de ce caméscope - je ne comprenais pas la mécanique de l'optique. En sortie, seuls deux nœuds en mouvement ne sont pas disponibles: le nœud de mise au point (responsable de la mise au point) et le nœud de zoom. Et je ne sais pas combien de lentilles il y a au total. Je suppose que deux sont connectés à ces nœuds mobiles. Il convient également de noter que lors du réglage de la mise au point, le zoom change également visuellement légèrement, même si le nœud correspondant est fixe.connecté à ces nœuds mobiles. Il convient également de noter que lors du réglage de la mise au point, le zoom change également visuellement légèrement, même si le nœud correspondant est fixe.connecté à ces nœuds mobiles. Il convient également de noter que lors du réglage de la mise au point, le zoom change également visuellement légèrement, même si le nœud correspondant est fixe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À la fin de l'article, nous passons aux tests pratiques du caméscope. J'ai décidé de ne pas prendre beaucoup de photos, mais de télécharger immédiatement toute la vidéo. J'ai enregistré une capture vidéo via l'appareil, le son a été écrit séparément sur l'enregistreur audio. La résolution d'origine est de 720 par 576. Après avoir téléchargé la vidéo sur YouTube, sa qualité a sensiblement changé.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/H4agAlZlWW8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous allumez l'appareil photo, la première chose qui se produit est l'initialisation des moteurs pas à pas de zoom et la mise au point sur l'arrière-plan de l'image vidéo. Cette image est en noir et blanc et sans AGC, car la procédure d'initialisation du processeur vidéo n'est pas encore terminée. En bas à gauche, la date et l'heure actuelles afficheront la date et l'heure de compilation du micrologiciel actuel de l'appareil photo. Dans le code source du firmware, j'ai créé les variables correspondantes qui se trouvent à des adresses fixes dans le code HEX. Il est supposé qu'au stade de la compilation, plus précisément après celui-ci, un programme sera automatiquement exécuté qui prend les valeurs des variables de l'heure système et les insère dans le fichier HEX aux adresses souhaitées. De plus, il faut encore recompter les sommes de contrôle. Il existe peut-être un moyen plus simple. Dans l'exemple de la vidéo, ces variables sont égales à zéro, car je n'ai pas encore implémenté cette fonction.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après l'initialisation de la SD, le processeur vidéo est initialisé et un message d'accueil est immédiatement affiché sur l'arrière-plan de l'image vidéo. Lors du réglage du zoom et de la mise au point, leurs coordonnées sont affichées en bas à droite. Dans la vidéo, je démontre l'utilisation de la fonction d'enregistrement et de rappel de modèles (préréglages) de zoom et de mise au point dans diverses parties de l'image. Lors de la suppression d'un préréglage, les variables correspondantes acquièrent la valeur 0xFFFF, ce qui correspond à une valeur de -1. Cette fonction, en principe, est superflue, elle peut être exclue.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la dernière section du menu, qui est utilisée pour le débogage, je montre l'enregistrement de la catégorie 9 octet 3. Les fonctions correspondant à cet octet sont dans la section précédente du menu, j'ai écrit à leur sujet plusieurs fois. Étant donné que l'état actuel de l'octet n'est pas lu à partir du processeur vidéo, je l'ai défini manuellement sur «48» comme l'un des acceptables. Après cela, je change les bits individuels de cet octet, montrant ainsi les fonctions "Mirror" et "Inverse Burst". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous ajustez le niveau "Rafale" dans l'avant-dernière section du menu, vous remarquerez un petit bug du firmware qui est facile à corriger. Parmi les autres défauts - parfois, lors de la mise à jour de l'heure, des lacunes dans les caractères se produisent. Je pense que cela est dû à l'installation «tordue» de l'électronique à l'intérieur du caméscope.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, lors de l'utilisation de l'appareil photo, des inconvénients mineurs liés à la navigation dans les menus ont été trouvés. </font><font style="vertical-align: inherit;">Il est donc tout à fait possible que la révision nécessaire soit effectuée au fil du temps. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, j'ai presque oublié. </font><font style="vertical-align: inherit;">Comme promis, j'apporte deux photos de ce qu'est devenu le remplissage du caméscope après le développement. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m-/0-/ah/m-0-ahq2z2xqxpr988ndcfae5uu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. </font><font style="vertical-align: inherit;">15. Une vue mise à jour du caméscope à l'intérieur du bas. </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/gs/8_/bw/gs8_bwxf2yy1mqyrt2gmbgzoyu8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. </font><font style="vertical-align: inherit;">16. Une vue mise à jour du caméscope à l'intérieur du haut.</font></font></i><br>
<br></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr499534/index.html">Guide de développement du service backend Python</a></li>
<li><a href="../fr499536/index.html">Growbox comme méthode de se connaître</a></li>
<li><a href="../fr499540/index.html">Fonctionnement du rendu de jeu 3D: texturation et filtrage de texture</a></li>
<li><a href="../fr499542/index.html">Top Fakapov Cyan</a></li>
<li><a href="../fr499544/index.html">Apprenez les réseaux de neurones dans Google Sheets</a></li>
<li><a href="../fr499548/index.html">Masque - prendre soin des autres ou une illusion de sécurité?</a></li>
<li><a href="../fr499550/index.html">Solutions éco-low-code</a></li>
<li><a href="../fr499556/index.html">Serveur de jeu sur MS Orleans - Partie 3: Résumé</a></li>
<li><a href="../fr499560/index.html">Correcteur de disposition Xswitcher pour Linux: deuxième étape</a></li>
<li><a href="../fr499562/index.html">Article infructueux sur l'accélération de la réflexion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>