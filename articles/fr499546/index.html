<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â›‘ï¸ ğŸš™ ğŸµ DÃ©veloppement de firmware pour une camÃ©ra vidÃ©o analogique EVR-Y2022F ğŸ” ğŸ‘ƒ ğŸ‘©ğŸ½â€ğŸ¤â€ğŸ‘¨ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans un article prÃ©cÃ©dent, l'appareil d'une camÃ©ra vidÃ©o analogique a Ã©tÃ© examinÃ© en dÃ©tail afin de crÃ©er son propre firmware. Comme dÃ©jÃ  mentionnÃ©, l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>DÃ©veloppement de firmware pour une camÃ©ra vidÃ©o analogique EVR-Y2022F</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499546/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans un article prÃ©cÃ©dent, l'appareil d'une camÃ©ra vidÃ©o analogique a Ã©tÃ© examinÃ© en dÃ©tail afin de crÃ©er son propre firmware. Comme dÃ©jÃ  mentionnÃ©, la camÃ©ra possÃ¨de un microcontrÃ´leur d'origine inconnue. Il est beaucoup plus riche que les AVR habituels: il a deux tensions d'alimentation 3,3V et 1,8V, et il a Ã©galement une fonction DSP. Je suis arrivÃ© Ã  cette conclusion en pensant Ã  la mise en Å“uvre de l'algorithme de mise au point automatique. NÃ©anmoins, je n'ai pas prÃ©fÃ©rÃ© les MK complexes comme STM32 et d'autres, ne serait-ce que parce que je n'ai jamais travaillÃ© avec eux du tout. J'ai dÃ©finitivement dÃ©cidÃ© d'utiliser l'un des AVR MK pour implÃ©menter mon firmware. Par consÃ©quent, dÃ©jÃ  Ã  ce stade, j'ai commencÃ© Ã  rÃ©aliser que la mise en Å“uvre de la fonction de mise au point automatique ne sera pas trÃ¨s facile Ã  gÃ©rer, ou plutÃ´t impossible.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon choix s'est portÃ© sur l'ATmega128 MK, car c'est lui qui est tombÃ© dans mon bras. L'ATmega8 MK ne sera Ã©videmment pas suffisant en termes de nombre de conclusions, d'autant que, au cas oÃ¹, j'ai dÃ©cidÃ© de rÃ©server un port MK entier pour le flux vidÃ©o numÃ©rique du processeur vidÃ©o. Tout d'abord, j'ai compris quelles fonctions seront dans mon propre firmware, en particulier les fonctions qui n'Ã©taient pas dans le firmware d'origine et quelles fonctions devront Ãªtre nÃ©gligÃ©es.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons une variante de l'algorithme de mise au point automatique pour analyser un flux vidÃ©o numÃ©rique. J'ai rÃ©ussi Ã  dÃ©couvrir que les donnÃ©es du flux vidÃ©o sont une alternance d'octets synchronisÃ©s avec les impulsions Â«CKÂ». Les octets du flux vidÃ©o codent les niveaux des composantes Y, Cr, Cb du signal vidÃ©o avec une gradation de 8 bits (256 niveaux). C'est-Ã -dire que la sortie vidÃ©o numÃ©rique du processeur vidÃ©o de cette camÃ©ra est multiplexÃ©e en composantes. Les informations sur la luminositÃ© (Y) sont contenues dans chaque deuxiÃ¨me octet du flux vidÃ©o et les informations sur les couleurs sont deux fois moins frÃ©quentes. C'est-Ã -dire que des informations sur le signal de diffÃ©rence de couleur du Cr rouge sont contenues dans chaque quatriÃ¨me octet, ainsi que des informations sur le signal de diffÃ©rence de couleur du bleu. Ainsi, le flux reprÃ©sente la sÃ©quence suivante: Cb0, Y0, Cr0, Y1, Cb2, Y2, Cr2, Y3, Cb4, Y4, Cr4, Y5, .... C'est Ã  dire,tandis que les informations sur la luminositÃ© de chaque pixel sont fournies sans lacunes, les informations sur la couleur des pixels sont fournies successivement par composants. Cet amincissement est dÃ» aux propriÃ©tÃ©s d'insensibilitÃ© Ã  la couleur des petits dÃ©tails et Ã  une rÃ©duction de la bande de couleur dans le signal vidÃ©o. Ces propriÃ©tÃ©s sont utilisÃ©es dans la tÃ©lÃ©vision analogique et la numÃ©risation vidÃ©o. La Â«compressionÂ» (sous-Ã©chantillonnage des couleurs) ci-dessus a un rapport de composants de 4: 2: 2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour que l'algorithme de mise au point automatique fonctionne, il suffit d'analyser uniquement la composante de luminositÃ©, ce qui est Ã©galement facile Ã  rÃ©aliser en interceptant le flux vidÃ©o Â«octet par octetÂ». Si la frÃ©quence CK est d'environ 18 MHz, alors CK / 2 est de 9 MHz, ce qui semble tout Ã  fait rÃ©alisable pour l'ATmega128 MK. Les impulsions de synchronisation horizontale et verticale permettent au contrÃ´leur de Â«compterÂ» et d'analyser n'importe quelle zone de l'image. Peut-Ãªtre, pour l'algorithme de mise au point automatique, il suffit d'analyser uniquement le centre du raster. De toute Ã©vidence, meilleure est la mise au point, plus l'image est nette, et donc plus la bande de frÃ©quences du signal vidÃ©o est large (plus de composants RF). Autrement dit, il est possible (voire nÃ©cessaire) d'appliquer l'algorithme de transformation de Fourier rapide (FFT) Ã  des fragments d'un flux vidÃ©o numÃ©rique et d'analyser les composants RF. Dans ce cas, vous devez tordre la mise au point Ã  chaque fois,en utilisant la mÃ©thode de la Â«demi-divisionÂ» comme mÃ©thode d'optimisation mathÃ©matique. Ainsi, vous pouvez obtenir le meilleur rÃ©sultat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne me suis pas souciÃ© de la fonction autofocus, considÃ©rant que c'Ã©tait impossible sur MK avec une architecture simple, mÃªme si, en tout cas, j'ai rÃ©servÃ© un port pour la vidÃ©o numÃ©rique. Au lieu de l'autofocus, j'ai dÃ©cidÃ© d'implÃ©menter un certain nombre d'autres fonctions qui n'Ã©taient pas disponibles dans le firmware d'origine. Mais pour cela, la camÃ©ra vidÃ©o devra Ãªtre limitÃ©e Ã  des conditions stationnaires, ce qui est typique de la vidÃ©osurveillance. Il est supposÃ© que la camÃ©ra pourra ensuite tourner dans le plan horizontal et vertical en utilisant des mÃ©canismes spÃ©ciaux, Ã  la fois automatiquement et manuellement. Lorsque l'appareil photo vise automatiquement un objet spÃ©cifique, dont les coordonnÃ©es sphÃ©riques seront prÃ©-enregistrÃ©es dans la mÃ©moire de l'appareil de commande, les Â«coordonnÃ©esÂ» du zoom et de la mise au point changeront Ã©galement, qui seront Ã©galement prÃ©sÃ©lectionnÃ©es et stockÃ©es dans la mÃ©moire.La gestion peut Ãªtre organisÃ©e selon le protocole PELCO-D, de plus, dans la spÃ©cification de ce protocole, il y a une Ã©quipe spÃ©ciale pour cette entreprise. Les coordonnÃ©es du zoom et de la mise au point seront, bien entendu, Â«jumelÃ©esÂ» pour une distance spÃ©cifique. Autrement dit, un objet qui sera situÃ© Ã  une distance donnÃ©e sera mis au point.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de commencer Ã  Ã©crire un micrologiciel, vous devez rÃ©flÃ©chir aux pÃ©riphÃ©riques de MK et aux conclusions qui seront impliquÃ©es. Ensuite, vous devez rÃ©flÃ©chir Ã  la faÃ§on de placer et de fixer la carte avec son propre MK Ã  l'intÃ©rieur de la camÃ©ra. Et pour que ce soit aussi pratique et maintenable que possible. J'ai dÃ©cidÃ© d'utiliser une planche avec MK, dont les conclusions seront complÃ¨tement acheminÃ©es vers les cÃ´tÃ©s gauche et droit. La carte sera situÃ©e au bas de la camÃ©ra, oÃ¹ il y a peu d'espace, et sera maintenue sur une connexion dÃ©tachable. Dans le mÃªme temps, il y aura des Â«brochesÂ» du connecteur sur la carte elle-mÃªme, et il y aura des prises de raccordement sur les cÃ´tÃ©s de la camÃ©ra. Pour les prises de rÃ©ponse, j'ai dÃ©cidÃ© de fabriquer deux autres cartes adaptatrices, de la taille du cÃ´tÃ© de la camÃ©ra. Les lamelles de ces cartes vont en haut de la camÃ©ra, directement sur la carte principale. Il est supposÃ© que chaque lamelle sera cÃ¢blÃ©e au point souhaitÃ© sur la carte principale de la camÃ©ra.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant le dÃ©veloppement de la carte avec MK, j'ai eu l'idÃ©e de complÃ©ter le camÃ©scope avec une horloge (RTC), et j'ai mis en Ã©vidence la ligne I2C, placÃ©e sur la carte RTC DS1307 (je sais dÃ©jÃ  quoi) avec du quartz et une batterie et, juste au cas oÃ¹, EEPROM 24AA512, qui Ã©taient par la main. Sur la carte du bord supÃ©rieur se trouvent Ã©galement des connecteurs pour connecter les programmeurs SPI et JTAG. Sur la carte mÃ¨re d'origine, MK est cadencÃ© Ã  partir de quartz 12 MHz. C'est la mÃªme chose pour moi. En gÃ©nÃ©ral, il est prÃ©fÃ©rable d'y mettre du quartz Ã  11,0592 MHz pour un fonctionnement UART clair. Les distances entre les "peignes" des articulations dÃ©tachables ont Ã©tÃ© soigneusement calculÃ©es au prÃ©alable. J'ai dÃ©cidÃ© d'alimenter MK Ã  partir du Â«KrenkaÂ» de cinq volts, qui sera vissÃ© sur le chÃ¢ssis sous la carte principale (il servira Ã©galement de dissipateur de chaleur). L'alimentation sera prÃ©levÃ©e sur la tension d'entrÃ©e 12V immÃ©diatement aprÃ¨s le fusible FB801, comme indiquÃ© sur la figure.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pk/rs/q8/pkrsq8mtjjredo8w2mfne5goziy.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 1. Gestion de l'alimentation du microcontrÃ´leur.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En dessinant des planches dans "SprintLayout", je me suis demandÃ© Ã  quoi sert chaque broche du MK, qui est sortie "out" vers le connecteur. Le rÃ©sultat est une telle image. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/95/xg/bm95xgf-akgycofwc_mdsjp8rki.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 2. Croquis de cartes de circuits imprimÃ©s supplÃ©mentaires.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pour vous dire la vÃ©ritÃ©, j'ai dessinÃ© les planches latÃ©rales (le long des bords) au stade de la rÃ©daction de cet article. Mais en fait, je les ai faites avec un cutter. Il s'est avÃ©rÃ© que ce n'Ã©tait pas l'option la plus rÃ©ussie. Et la planche elle-mÃªme avec MK a Ã©tÃ© faite de travers. J'ai en quelque sorte vissÃ© les cartes auxiliaires latÃ©rales sur les cÃ´tÃ©s du cadre de la camÃ©ra, en soudant des Ã©crous de flux Ã  la surface en cuivre du PCB. Le fait est qu'il y a trÃ¨s peu d'espace sur les cÃ´tÃ©s et que le couvercle de l'appareil photo est pratiquement Â«serrÃ©Â» dos Ã  dos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les figures ci-dessous montrent la rÃ©partition des conclusions du MK, ainsi que leur objectif.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cc/ry/d2/ccryd2b_viknimo-w0asy0j8fuy.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 3. Le but des conclusions du microcontrÃ´leur.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Il y a de nombreux points Ã  commenter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour le programmeur SPI (STK200 +), la sortie Â«PENÂ» n'Ã©tait pas nÃ©cessaire. L'activation a lieu par Â«RESETÂ», comme d'habitude. Mais au lieu de Â«MISOÂ» et Â«MOSIÂ», le MK a une interface sÃ©parÃ©e (PDI / PDO), et la ligne Â«CLKÂ» est combinÃ©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme tension de rÃ©fÃ©rence pour l'ADC, j'ai choisi le mÃªme 5V, Ã  partir duquel le MK lui-mÃªme est alimentÃ©. J'ai essayÃ© d'obtenir sÃ©parÃ©ment 3,3 V (comme dans le circuit d'origine), mais en mÃªme temps, il y avait des piÃ¨ges. Et pour passer Ã  la tension de rÃ©fÃ©rence de 5 V, vous devez changer lÃ©gÃ¨rement le circuit, comme indiquÃ© sur la figure. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mn/od/wr/mnodwrbakf5xlxkq1qskzeuhmkc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 4. Traduction des boutons sur la tension de rÃ©fÃ©rence 5V.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Autrement dit, vous devez dessouder un cÃ´tÃ© de la rÃ©sistance R505 du cÃ´tÃ© de l'alimentation 3,3 V, et lui appliquer Ã  la place 5 V Ã  partir de la ligne d'alimentation MK.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des conclusions de MK, qui ne sont utilisÃ©es qu'Ã  l'intÃ©rieur de la carte conÃ§ue, seulement trois sont impliquÃ©es. Un signal d'impulsion de 1 Hz avec RTC arrive Ã  PB7 pour mettre Ã  jour l'heure. Les broches PD0 et PD1 sont affectÃ©es au bus I2C. Il sera implÃ©mentÃ© par programme Ã  l'aide de la bibliothÃ¨que CVAVR Â«i2c.hÂ», malgrÃ© le fait qu'une interface matÃ©rielle i2c (TWI) soit attachÃ©e Ã  ces sorties. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La broche MC Â«RESETÂ» est sortie, mais la rÃ©initialisation MK se fera d'elle-mÃªme sans chaÃ®ne de rÃ©initialisation externe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il Ã©tait entendu que les impulsions d'horloge HD et VD arriveraient au MK via des ports d'interruption externes pour la prÃ©cision de la lecture du champ vidÃ©o. Cependant, Ã  l'exception de la fonction de mise au point automatique, ils ne sont plus nÃ©cessaires. Les signaux des commutateurs de fin de course de zoom et de mise au point arrivent aux ports voisins des interruptions externes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le port Â«AÂ» MK est rÃ©servÃ© au flux vidÃ©o numÃ©rique. Le port "C" est entiÃ¨rement rÃ©servÃ© Ã  SD.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La broche PD4 est utilisÃ©e pour commuter TX / RX RS-485. Il n'y avait pas de commutation dans le circuit d'origine: les 2Ã¨me et 3Ã¨me Ã©tapes de la puce MAX485 Ã©taient au sol. Le MK d'origine ne pouvait recevoir des donnÃ©es pour contrÃ´ler la camÃ©ra via PELCO-D. J'ai dÃ©cidÃ© de faire une petite mise Ã  jour. L'idÃ©e Ã©tait la suivante. Si le camÃ©scope est suspendu haut et dans un boÃ®tier fermÃ©, il sera tout simplement impossible de mettre Ã  jour rapidement le firmware. Et un tel besoin surgira sÃ»rement: Ã©liminer divers bogues et amÃ©liorer les fonctionnalitÃ©s deviendront une pratique rÃ©guliÃ¨re pour la premiÃ¨re fois. Par consÃ©quent, j'ai eu l'idÃ©e d'implÃ©menter un chargeur de dÃ©marrage pour MK, et l'utilisant dÃ©jÃ  Ã  distance pour mettre Ã  jour le firmware via RS-485. Et dans ce cas, un Ã©change bidirectionnel est trÃ¨s souhaitable. Ã€ propos du chargeur de dÃ©marrage sera une partie distincte de cet article. Et pour connecter le MAX485 (2 et 3 pieds) Ã  cette broche MK,vous devez apporter une petite modification Ã  la premiÃ¨re et la deuxiÃ¨me carte. Ces cartes sont connectÃ©es par un cÃ¢ble en boucle, sur les connecteurs duquel se trouve un contact Â«IRLÂ» inutilisÃ© pour le contrÃ´le du rÃ©troÃ©clairage. Sur la deuxiÃ¨me carte (principale), vous devez dessouder la rÃ©sistance R520 et souder Ã  la place le fil qui passe par la carte adaptateur Ã  l'ATmega128 MK Ã  la sortie correspondante. Et sur la premiÃ¨re carte, vous devez dessouder et plier 2 et 3 pieds d'U202, les souder ensemble et les tirer du cÃ¢blage vers la sortie libre d'un connecteur J302. Ces opÃ©rations de changement de circuit sont reprÃ©sentÃ©es sur la figure.qui passera par la carte adaptateur Ã  l'ATmega128 MK jusqu'Ã  la sortie correspondante. Et sur la premiÃ¨re carte, vous devez dessouder et plier 2 et 3 pieds d'U202, les souder ensemble et les tirer du cÃ¢blage vers la sortie libre d'un connecteur J302. Ces opÃ©rations de changement de circuit sont reprÃ©sentÃ©es sur la figure.qui passera par la carte adaptateur Ã  l'ATmega128 MK jusqu'Ã  la sortie correspondante. Et sur la premiÃ¨re carte, vous devez dessouder et plier 2 et 3 pieds d'U202, les souder ensemble et les tirer du cÃ¢blage vers la sortie libre d'un connecteur J302. Ces opÃ©rations de changement de circuit sont reprÃ©sentÃ©es sur la figure.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qu/20/oe/qu20oe_mzvupcc4mpsbtg4omwma.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 5. Organisation de la ligne TRX pour contrÃ´ler le TX / RX MAX485.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Il y a deux interfaces UART Ã  bord de l'ATmega128. Dans ce cas, vous devez utiliser la deuxiÃ¨me interface (broches 27, 28), car la premiÃ¨re interface sur les broches (broches 2, 3) est combinÃ©e avec l'interface du programmeur SPI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au tableau, presque toutes les conclusions du MK sont en cause. Les conclusions du port Â«GÂ» se sont avÃ©rÃ©es inutilisÃ©es. Soit dit en passant, il Ã©tait possible d'implÃ©menter l'horloge par programmation sur la base de MK. Il fournit un mode veille avec l'utilisation d'une batterie pour compter le temps lorsque l'alimentation principale est coupÃ©e. Il y a mÃªme des conclusions pour connecter un quartz basse frÃ©quence sÃ©parÃ©. Cependant, je n'ai pas pris la peine de gifler le DS1307.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La figure ci-dessous montre le but de chaque sortie de la carte avec MK. De plus, il est marquÃ© sous condition quoi et de quel cÃ´tÃ© de la carte principale les fils de chaque broche seront soudÃ©s. Il est Ã©galement nÃ©cessaire de faire quelques commentaires. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i0/fd/df/i0fddfrritx4bjzwqgsfl3bu1r4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 6. Affectation des conclusions d'un paiement supplÃ©mentaire Ã  MK.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les signaux des commutateurs de fin de course de zoom et de mise au point arrivent non seulement aux ports d'interruption, mais Ã©galement aux entrÃ©es ADC. Le fait est que mÃªme au stade de l'Ã©tude du DD, j'ai remarquÃ© une telle fonctionnalitÃ©. Si le mÃ©canisme de zoom ou de mise au point est Ã  Â«zÃ©roÂ», le signal de sortie de la remorque peut prendre un Ã©tat Â«intermÃ©diaireÂ». Pour mieux capturer ces cas rares, j'ai dÃ©cidÃ© d'utiliser l'ADC. Bien sÃ»r, ce n'est pas une approche trÃ¨s compÃ©tente, mais en faisant cela, je suis rapidement sorti du problÃ¨me qui se posait parfois au stade de l'initialisation dans mon firmware de test. Ainsi, j'ai augmentÃ© la stabilitÃ© de l'algorithme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les signaux SDA / SCL de l'I2C sont simplement branchÃ©s dans le connecteur, juste au cas oÃ¹, et ils ne sont pas utilisÃ©s en dehors de cette carte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les noms de chaque broche pour le contrÃ´le de l'ID sont signÃ©s en fonction de la connexion rÃ©elle. La connexion des donnÃ©es, tournÃ©e vers l'avenir, a finalement Ã©tÃ© corrigÃ©e au stade du dÃ©bogage. Il y avait beaucoup de confusion, mais les erreurs ne concernaient que l'alternance de phases prÃ©cises Ã  l'inverse, et non leur ordre. Les alternances Â«4-1-2-3Â» (pour le zoom) et Â«2-3-4-1Â» (pour la mise au point) sont identiques, ainsi que Â«1-2-3-4Â», qui et a Ã©tÃ© pris comme base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A la fin de l'article </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(pour ne pas faire honte)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deux photos sont prÃ©sentÃ©es. Le premier est la vue de dessous du camÃ©scope avec une vue du circuit imprimÃ© supplÃ©mentaire. La seconde est une vue de dessus de dessus sur la carte principale d'une camÃ©ra vidÃ©o avec un MK standard scellÃ© (microprocesseur, pour Ãªtre plus prÃ©cis), un tas de cavaliers et autres morve.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai Ã©crit le programme (firmware) avec ses tests prÃ©liminaires dans le programme ISIS 7 Professional (Proteus). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/qr/f7/mtqrf7iej-6e3adbtcg-bgghokq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 7. Vue du projet dans Proteus.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Au lieu des puces uniques du gÃ©nÃ©rateur de caractÃ¨res et du processeur vidÃ©o (qui, bien sÃ»r, ne sont pas dans Proteus), j'ai installÃ© des dÃ©bogueurs SPI. Avec leur aide, il est pratique de contrÃ´ler les octets que MK envoie par SPI. Mais la vÃ©ritable rÃ©action Ã  ces octets est contrÃ´lÃ©e directement sur le matÃ©riel. Avec Proteus, vous pouvez surveiller et dÃ©boguer les commandes PELCO-D provenant d'un vrai DVR. Pour ce faire, en option, vous devez connecter le DVR au port COM de l'ordinateur via l'adaptateur unidirectionnel le plus simple RS485-&gt; RS232. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, j'ai commencÃ© Ã  dÃ©velopper et Ã  modÃ©liser. Excel y a beaucoup aidÃ©.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez d'abord dÃ©cider des temporisateurs et de leur configuration. Une minuterie - pour rÃ©aliser la rotation du moteur pas Ã  pas et la mise en Å“uvre d'opÃ©rations rÃ©pÃ©tÃ©es des boutons tout en les maintenant. Lorsque vous maintenez tel ou tel bouton pendant les rÃ©glages via le menu, le fonctionnement du SD sera exclu. Et lorsque vous maintenez l'un des boutons de contrÃ´le du zoom ou de la mise au point en dehors du menu, le SD pivote avec le paramÃ¨tre de temps correspondant. Ainsi, il n'y a pas de conflits. J'avais prÃ©vu d'utiliser le deuxiÃ¨me temporisateur pour implÃ©menter PWM pour la SD, mais au fil du temps, j'ai dÃ©cidÃ© de l'abandonner. En effet, dans mon cas, lorsqu'il n'y a pas d'autofocus, il n'y a pas besoin de PWM. De plus, le mÃ©canisme de transmission a une structure hÃ©licoÃ¯dale, par consÃ©quent, au repos, vous ne pouvez pas "tenir" le SD par courant continu, le mÃ©canisme ne se glissera nulle part.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, vous devez rÃ©viser l'alphabet des caractÃ¨res du gÃ©nÃ©rateur de caractÃ¨res, selon la fiche technique, et le comparer avec l'alphabet standard ASCII. L'alphabet du gÃ©nÃ©rateur de caractÃ¨res se compose de 128 caractÃ¨res, soit la moitiÃ© de la taille du dernier. Par exemple, les caractÃ¨res cyrilliques dans le gÃ©nÃ©rateur de caractÃ¨res sont complÃ¨tement absents, mais il y a des caractÃ¨res spÃ©ciaux qui sont caractÃ©ristiques de son application (soleil, sablier, petit homme, note, tÃ©lÃ©phone, etc.). J'ai fait un tableau de Â«smb [256]Â» de 256 Ã©lÃ©ments, en le plaÃ§ant dans l'EEPROM MK. La notation smb [i] = adr signifie qu'Ã  l'adresse adr dans le gÃ©nÃ©rateur de caractÃ¨res il y a un caractÃ¨re avec le code ASCII i. Et si le symbole i n'est pas dans l'alphabet du gÃ©nÃ©rateur de caractÃ¨res, alors la valeur de l'Ã©lÃ©ment de tableau fait rÃ©fÃ©rence Ã  "l'espace" avec l'adresse 0x7E. Autrement dit, prÃ¨s de la moitiÃ© des Ã©lÃ©ments du tableau ont une valeur de "0x7E". Ce tableau est prÃ©sentÃ© sous forme de tableau dans la figure ci-dessous.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yo/_b/_g/yo_b_gqswkjfk1smuefynrwgs0e.png"><br>
<i>. 8.    ASCII    PD6464A.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, vous devez rÃ©flÃ©chir Ã  la faÃ§on de traiter les boutons via l'ADC. Selon la loi d'Ohm, il est facile de calculer les valeurs de tension Ã  l'entrÃ©e de l'ADC lorsque vous cliquez sur un bouton. AprÃ¨s cela, il est facile de calculer les limites des intervalles, dont le milieu sera les mÃªmes valeurs de contrainte. Au total, six intervalles sont obtenus: cinq d'entre eux correspondent Ã  chaque bouton et un Ã  l'absence de pression (aucun bouton n'est enfoncÃ©). Au niveau matÃ©riel, l'ADC MK analyse pÃ©riodiquement la valeur de tension des boutons. La minuterie pour l'anti-rebond peut Ãªtre implÃ©mentÃ©e sur la base du calcul des cycles d'horloge ADC, ce que j'ai fait. Au stade du dÃ©bogage, cette partie du programme avait ses piÃ¨ges. Je pense que Ã§a ne vaut pas la peine d'Ã©crire des dÃ©tails. Pour rÃ©aliser le travail clair de cette fonctionnalitÃ©, j'ai dÃ» bricoler longtemps. La fonction de reconnaissance des boutons est placÃ©e dans la section d'interruption ADC, et sur sa sortie est le numÃ©ro du bouton,drapeau de dÃ©pression et drapeau de libÃ©ration. Un traitement ultÃ©rieur des boutons a lieu dans le cycle de programme principal. La frÃ©quence de scrutation des boutons (frÃ©quence ADC) Ã©tait de 12000/128 = 93,75 (kHz), oÃ¹ 128 est le diviseur maximum possible.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, j'ai compilÃ© un tableau de valeurs de registre UART UBRR1 de la configuration UART, en fonction de l'un ou l'autre dÃ©bit en bauds PELCO-D, qui peut Ãªtre sÃ©lectionnÃ© dans la liste des paramÃ¨tres via le menu. </font><font style="vertical-align: inherit;">Ces valeurs peuvent Ãªtre calculÃ©es en utilisant la formule de la fiche technique sur le MK, et peuvent Ã©galement Ãªtre obtenues en utilisant l'auto-configurateur AVR Wizard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai ensuite commencÃ© Ã  modÃ©liser le menu. </font><font style="vertical-align: inherit;">Il s'agit de l'Ã©tape principale et chronophage de l'Ã©criture d'un programme. </font><font style="vertical-align: inherit;">En principe, je n'allais pas rÃ©pÃ©ter le menu du firmware standard, sauf pour cela, j'ai dÃ©cidÃ© de le compliquer Ã  une structure hiÃ©rarchique (section dans la section). </font><font style="vertical-align: inherit;">Ci-dessous, une description du modÃ¨le et les dÃ©finitions du menu que je me suis fait.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne peut pas lire</font></font></b>
                        <div class="spoiler_text">     .<br>
          .<br>
      .<br>
          .<br>
       Â«MENUÂ».<br>
<br>
    Â«Â»    .<br>
    Â«Â»  Â«Â»       .<br>
  Â«Â»       .<br>
  Â«Â»       .<br>
  (   )   ,         .<br>
   Â« Â»,     .<br>
<br>
   :<br>
 â€” ;<br>
 â€” ;<br>
 â€” ;<br>
 â€” .<br>
<br>
    ,   ,   .<br>
    &lt;&gt;.<br>
     .<br>
         "&lt;..&gt;".<br>
      Â«Â».<br>
      ,   .<br>
        ( ) .<br>
    "&lt;..&gt;"      .<br>
        ,    .<br>
           .<br>
<br>
      .<br>
     .<br>
        .<br>
     "&lt;â€¢&gt;" ( ).<br>
     "&lt; &gt;" ().<br>
      Â«Â».<br>
<br>
    .<br>
           .<br>
     Â«l*lÂ» (,   Â«lÂ»).<br>
     Â«l lÂ» (,   Â«lÂ»).<br>
        Â«Â».<br>
<br>
  ,       .<br>
     .<br>
           .<br>
            .<br>
       : Â«000Â», Â«00Â», Â«0Â».<br>
        .<br>
         : ": ".<br>
  â€”      (    )       .<br>
 ,   ,     Â«Â»  Â«Â».<br>
    Â«Â»     1.<br>
    Â«Â»     1.<br>
<br>
         .<br>
         .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la navigation dans les menus est quelque peu similaire Ã  la navigation dans les fichiers et dossiers via Â«Total CommanderÂ». Le code d'implÃ©mentation de ce modÃ¨le de menu n'est pas trÃ¨s compliquÃ©, mais trÃ¨s lourd. Il existe deux variables clÃ©s: le numÃ©ro de la page active et le numÃ©ro de la position active sur la page. Pour les deux variables, deux fonctions Â«boÃ®tier de commutationÂ» fonctionnent l'une dans l'autre. Cette paire de fonctions est impliquÃ©e dans le processus d'appuyer sur les boutons "Gauche", "Droite" et "Menu". Ã€ chaque endroit (pour chaque bouton, page et Ã©lÃ©ment actuel) certaines actions sont enregistrÃ©es. Chaque page de menu possÃ¨de une fonction qui implÃ©mente l'affichage de la page Ã  l'Ã©cran avec toutes les inscriptions et les paramÃ¨tres. Avant d'implÃ©menter les fonctions de sortie de page, je les modÃ©lisais auparavant dans Excel, comme on dit, Â«par cellulesÂ».Ainsi, les coordonnÃ©es des cellules de chaque symbole sur le champ de l'Ã©cran sont prÃ©sentÃ©es plus clairement, et cette information est nÃ©cessaire au stade de la programmation. Dans la figure ci-dessous, Ã  titre d'exemple, j'ai donnÃ© la vue de la page 9, sur laquelle la vitesse de transmission PELCO-D est sÃ©lectionnÃ©e dans la liste. L'Ã©lÃ©ment d'interface sur la page est un bouton radio. En plus de cela, le premier paragraphe &lt;..&gt; consiste Ã  quitter cette section.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c0/s1/uy/c0s1uyuaoh9dawm-bqpf5g4pmjg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 9. ModÃ©lisation de l'OSD dans Excel.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
J'ai Ã©galement crÃ©Ã© un tableau qui reflÃ¨te le nombre de points sur chaque page. Il est utilisÃ© dans le traitement de la pression des boutons Haut et Bas. Ceci est fait pour rÃ©duire le code et Ã©viter d'utiliser la fonction switch-case.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un appui virtuel rÃ©pÃ©tÃ© tout en maintenant les boutons est implÃ©mentÃ© dans le corps de l'interruption de la minuterie par la fonction Â«switch-caseÂ», travaillant sur une variable entiÃ¨re, qui est un drapeau. La valeur de l'indicateur est unique pour chaque action d'un bouton sur une page spÃ©cifique et un Ã©lÃ©ment de menu spÃ©cifique. Il est attribuÃ© au drapeau en tant que numÃ©ro de sÃ©rie uniquement aux endroits oÃ¹ des clics virtuels sont nÃ©cessaires. Dans le mÃªme temps, Ã  l'intÃ©rieur de la fonction Â«boÃ®tier de commutationÂ» (dans le corps de l'interruption de la minuterie) sont placÃ©es des copies des fonctions qui mettent en Å“uvre les actions des boutons. Pour Ã©conomiser de la mÃ©moire, il Ã©tait possible de placer des Â«raccourcisÂ» (liens) sur les appels rÃ©guliers Ã  la fonction de traitement des boutons. C'est encore plus raisonnable, mais Ã  ce moment-lÃ , je n'avais pas la patience de penser Ã  mieux le faire, car je voulais terminer le projet le plus tÃ´t possible. Et la mÃ©moire dans ATmega128 s'est avÃ©rÃ©e Ãªtre beaucoup.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, j'ai implÃ©mentÃ© des Â«bibliothÃ¨quesÂ» pour travailler avec un processeur vidÃ©o, un gÃ©nÃ©rateur de caractÃ¨res et le RTC DS1307 avec les fonctions nÃ©cessaires. AprÃ¨s cela, j'ai dÃ©terminÃ© les adresses de l'EEPROM MK pour stocker telle ou telle information. Les 32 premiers octets sont rÃ©servÃ©s au stockage des informations sur les paramÃ¨tres du menu. Les 32 octets suivants sont rÃ©servÃ©s au stockage de texte pouvant Ãªtre affichÃ© Ã  l'Ã©cran ou modifiÃ© Ã  l'aide de la commande standard "Pelco-D Write Char. Ã€ l'Ã©cran. " Les 256 octets suivants de la zone EEPROM sont rÃ©servÃ©s Ã  l'alphabet (conversion d'un caractÃ¨re ASCII en une adresse pour un gÃ©nÃ©rateur de caractÃ¨res, comme mentionnÃ© ci-dessus). Enfin, les 128 octets suivants sont rÃ©servÃ©s au stockage de Â«prÃ©rÃ©glagesÂ» (modÃ¨les) de zoom / focus. J'ai introduit cette fonctionnalitÃ© en raison du manque d'autofocus. J'ai Ã©crit Ã  ce sujet au dÃ©but de l'article. Un total de 32 modÃ¨les. Les coordonnÃ©es du zoom ou de la mise au point sont codÃ©es sur deux octets.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SÃ©parÃ©ment, il vaut la peine d'Ã©crire sur la mise en Å“uvre de la gestion SD. La rotation du SD est obtenue en appelant les fonctions StepF () et StepZ () dans le bloc d'interruption de temporisation. La vitesse de rotation est dÃ©terminÃ©e par la configuration de cette minuterie. Et la mise en Å“uvre des fonctions ci-dessus implÃ©mente la promotion de la mise au point ou du zoom (respectivement) Ã  un minimum. Pendant la rotation du zoom et de la mise au point, leur position finale est contrÃ´lÃ©e. La position de la mise au point maximale et la position du zoom minimum sont reprÃ©sentÃ©es dans le programme par des constantes (280 et -600, respectivement). Mais la position du focus minimum et la position du zoom maximum - sous forme de variables F_min et Z_max (plus prÃ©cisÃ©ment, fonctions). Cette approche a Ã©tÃ© facilitÃ©e par une zone de travail non rectangulaire avec un coin infÃ©rieur droit coupÃ©. Pour calculer les valeurs de F_min et Z_max, des fonctions dÃ©finies par morceaux F_min (Z) et Z_max (F) sont utilisÃ©es. Outre,lorsque le zoom SD tourne dans le sens positif Ã  Z (coordonnÃ©e zoom)&gt; 500, la mise au point SD tourne simultanÃ©ment dans le mÃªme sens si ce dernier a des coordonnÃ©es &lt;(- 180). Autrement dit, la position de zoom maximale, en principe, n'est pas limitÃ©e par la position de mise au point actuelle, mais est limitÃ©e par le nombre 600. Simplement, deux SD tournent simultanÃ©ment lorsque la limite angulaire correspondante de la rÃ©gion pentagonale est atteinte, et le mouvement Ã  ce stade se produit le long du Â«cÃ´tÃ© coupÃ©Â» (si interprÃ©tÃ© graphiquement) ) Du point de vue de la mÃ©canique, cela Ã©quivaut au processus dÃ©crit dans l'article prÃ©cÃ©dent, lorsque, en l'absence de SD et lors du dÃ©placement manuel des nÅ“uds de zoom et de mise au point, le nÅ“ud de zoom Ã  la fin du chemin Â«tireÂ» le nÅ“ud de mise au point. Ã‰tant donnÃ© que la coordonnÃ©e du zoom domine la coordonnÃ©e de mise au point (c'est pourquoi je considÃ¨re la dÃ©pendance F (Z),mais pas l'inverse), je n'ai pas commencÃ© Ã  implÃ©menter une procÃ©dure de "dÃ©filement" de zoom similaire dans la fonction Step_F ().</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le firmware d'origine, la vitesse de changement du zoom et de la mise au point avait des valeurs fixes. Ce n'est pas toujours pratique. Dans mon firmware, j'ai fourni quatre valeurs des vitesses de zoom et de mise au point (indÃ©pendamment), qui peuvent Ãªtre sÃ©lectionnÃ©es Ã  la fois via le menu et en utilisant la commande PELCO-D affectÃ©e Ã  cette fonction. Ces quatre valeurs sont prÃ©sÃ©lectionnÃ©es au stade du dÃ©bogage en fonction de la commoditÃ©, puis elles sont entrÃ©es dans le micrologiciel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction d'initialisation BD init_MR () est nÃ©cessaire pour lier la mÃ©canique du zoom et la mise au point au systÃ¨me de coordonnÃ©es. Elle est effectuÃ©e une fois Ã  chaque mise sous tension du camÃ©scope. L'algorithme de son travail est approximativement le suivant. Tout d'abord, il est supposÃ© que le zoom ou la mise au point est au point zÃ©ro, et une tentative est faite pour capter le rebond du signal des fins de course par des fonctions d'interruption externes. Je noterai tout de suite que si le zoom ou la mise au point est "Ã  zÃ©ro" (Ã  la limite du partitionnement de la bande-annonce optique), le signal Ã  la sortie de la bande-annonce a un Ã©tat "intermÃ©diaire" entre "0" et "1" logique. De tels cas sont trÃ¨s improbables, mais ils ne peuvent Ãªtre exclus. Cependant, la fonction d'interruption n'interprÃ¨te pas un signal tel qu'un rebond. C'est pourquoi je suis venu utiliser l'ADC MK, dÃ©clenchant des signaux Ã  partir des interrupteurs de fin de course et de fin de course sur ses deux canaux libres. Donc,la premiÃ¨re Ã©tape est la "numÃ©risation" des signaux des fins de course avec une prÃ©cision de 8 bits. Cela se fait Ã  l'aide d'une seule conversion analogique-numÃ©rique. Il convient de rappeler que la tension de rÃ©fÃ©rence dans notre cas est de 5 V et que le niveau logique Â«1Â» du fin de course est de 3,3 V. Pour un Â«0Â» logique, la valeur ADC sera nulle et pour un Â«1Â» - 3,3 / 5 * 255 = 168. Si la valeur du signal de l'une ou l'autre bande-annonce tombe dans la plage, disons, de 2 Ã  165 (un intervalle flou est pris), cela signifie que le nÅ“ud correspondant est dÃ©jÃ  Â«Ã  zÃ©roÂ», et la procÃ©dure d'initialisation pour ce nÅ“ud peut Ãªtre arrÃªtÃ©e. Sinon, par la valeur logique du signal de fin ("0" ou "1"), vous devez dÃ©terminer dans quelle partie (la moitiÃ©) le nÅ“ud est situÃ©. Le sens de rotation du SD en dÃ©pendra. D'une maniÃ¨re ou d'une autre, le SD doit Ãªtre tournÃ© dans cette direction,de sorte que le nÅ“ud correspondant se dÃ©place vers le "zÃ©ro" (fin de course). Ainsi, la rotation de l'entraÃ®nement du moteur dÃ©marre avec le calcul simultanÃ© du nombre de pas jusqu'Ã  ce que le fin de course soit atteint. DÃ¨s que le fin de course correspondant est atteint, ce qui dÃ©termine la fonction d'interruption externe en fonction de la diffÃ©rence de niveau logique, il y aura une rotation inverse de l'entraÃ®nement du moteur. Il tournera dans la direction opposÃ©e du mÃªme nombre d'Ã©tapes, revenant ainsi Ã  sa position d'origine. La valeur du nombre de pas pour chaque BD avec le signe correspondant sera copiÃ©e dans les variables correspondantes avant de quitter la fonction d'initialisation. La procÃ©dure dÃ©crite ci-dessus se produit indÃ©pendamment pour la mise au point et le zoom dans la mÃªme fonction (pas Ã  son tour).La vitesse de rotation de l'entraÃ®nement du moteur Ã  l'Ã©tape d'initialisation est dÃ©terminÃ©e par une constante distincte et correspond Ã  la vitesse maximale pour une rotation correcte et sÃ»re du SM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons l'exemple oÃ¹, avant d'allumer l'appareil photo, le zoom Ã©tait dans la zone nÃ©gative et la mise au point Ã©tait dans la zone positive. La figure montre schÃ©matiquement la trajectoire du point (Z; F) pendant la procÃ©dure d'initialisation du moteur pas Ã  pas. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1p/59/6d/1p596dlrqriwqff1jh4jfrtvu-8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 10. Le processus d'initialisation du zoom et de la mise au point.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Le point A est la position initiale du zoom et de la mise au point. Le mouvement des deux nÅ“uds se produit dans le sens "zÃ©ro" avec la mÃªme vitesse (vitesse d'initialisation). Au point B, la mise au point atteint zÃ©ro, car elle Ã©tait plus proche de zÃ©ro que le zoom. Ensuite, la mise au point est inversÃ©e. Au point C, le focus termine le processus d'initialisation, revenant Ã  sa position d'origine. Dans le mÃªme temps, le zoom se dÃ©place toujours vers son Â«zÃ©roÂ». Au point D, il atteint son Â«zÃ©roÂ» et revient Ã  sa position d'origine (point A).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de la fonction d'initialisation init_MR (), il existe une fonction goto_zf (z, f). </font><font style="vertical-align: inherit;">BasÃ© sur le nom, il est destinÃ© Ã  passer d'un prÃ©rÃ©glage Ã  un autre, dont j'ai parlÃ© au dÃ©but de l'article. </font><font style="vertical-align: inherit;">La vitesse de rotation du moteur pas Ã  pas pendant la transition est la mÃªme que lors de l'initialisation. </font><font style="vertical-align: inherit;">Le processus de transition en zoom et mise au point s'effectue simultanÃ©ment. </font><font style="vertical-align: inherit;">Autrement dit, s'il est nÃ©cessaire de passer du point (z1; f1) au point (z2; f2), la rotation simultanÃ©e de deux SD est lancÃ©e. </font><font style="vertical-align: inherit;">Si, par exemple, | f2-f1 | &lt;| z2-z1 |, le focus SD s'arrÃªtera plus tÃ´t. </font><font style="vertical-align: inherit;">Ceci est dÃ©montrÃ© dans la figure ci-dessous. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fb/-y/ya/fb-yyanbovlb6i3pe6rxsfh0ax8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. </font><font style="vertical-align: inherit;">11. Processus de modification du zoom et de la mise au point lors du choix d'un prÃ©rÃ©glage.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant toute la durÃ©e de fonctionnement du moteur pas Ã  pas pendant le passage du limiteur de top zÃ©ro, la coordonnÃ©e correspondante est mise Ã  zÃ©ro. </font><font style="vertical-align: inherit;">Et cela malgrÃ© le fait que thÃ©oriquement cela ne peut pas Ãªtre fait. </font><font style="vertical-align: inherit;">Cependant, dans la pratique, il y a toujours une erreur de 1-2 Ã©tapes de la SD.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient d'ajouter que, contrairement au firmware d'origine, dans mon cas, lors du contrÃ´le du zoom et de la mise au point (Ã  la fois Ã  partir des boutons et via PELCO-D), j'ai prÃ©vu la possibilitÃ© d'un mouvement pas Ã  pas. Cela fonctionne comme suit. Lorsque vous cliquez sur l'un des 4 boutons pour contrÃ´ler le zoom ou la mise au point, la SD correspondante est tournÃ©e d'un pas, minimisant ainsi le mouvement du nÅ“ud de zoom ou de mise au point. Si vous ne relÃ¢chez pas le bouton, la rotation normale du moteur pas Ã  pas commencera aprÃ¨s une courte pÃ©riode de temps. Ce retard est sÃ©lectionnÃ© empiriquement Ã  l'avance. Cette fonction est similaire aux pressions rÃ©pÃ©tÃ©es virtuelles tout en maintenant le bouton enfoncÃ©. GrÃ¢ce Ã  cette fonctionnalitÃ©, le problÃ¨me de Â«collerÂ» le bouton lors du contrÃ´le du zoom ou de la mise au point sur le pÃ©riphÃ©rique distant PELCO-D via une mauvaise connexion Internet est Ã©liminÃ©. Plus prÃ©cisÃ©ment, l'occasion se prÃ©sente comme impoli,et affiner le zoom ou la mise au point.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'interprÃ©teur des commandes PELCO-D se fait par la mÃªme analogie que dans le dispositif de commutation de charges via PTZ. Plus tÃ´t, j'ai consacrÃ© un petit article sÃ©parÃ© sur HabrÃ© Ã  ce dispositif simple. Contrairement au firmware d'origine, les commandes de contrÃ´le du zoom et de la mise au point se rÃ©fÃ¨rent entiÃ¨rement Ã  la pression des boutons correspondants. Autrement dit, il est possible de Â«grimperÂ» dans le menu Ã  l'aide des boutons de zoom et de mise au point PELCO-D. Et afin d'appeler Ã  distance le menu via PELCO-D, ou plutÃ´t d'appuyer sur le bouton "MENU", j'ai comparÃ© le bouton d'ouverture d'ouverture avec lui, car cette fonction n'est pas utilisÃ©e dans ce modÃ¨le d'appareil photo. Ainsi, il existe cinq commandes de base PELCO-D pour appuyer, ainsi que cinq commandes de base pour relÃ¢cher les boutons. De plus, comme je l'ai dÃ©jÃ  Ã©crit avec dÃ©sinvolture tout au long de l'article, des commandes supplÃ©mentaires sont traitÃ©es: Â«Set PresetÂ», Â«Clear PresetÂ»,Â«Aller au prÃ©rÃ©glageÂ», Â«Ã‰crire le caractÃ¨re. Vers l'Ã©cran Â»,Â« Effacer l'Ã©cran Â»,Â« DÃ©finir la vitesse du zoom Â»,Â« DÃ©finir la vitesse de mise au point Â».</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La date et l'heure avec RTC sont affichÃ©es dans le coin infÃ©rieur gauche de l'image par analogie avec les anciennes camÃ©ras VHS, si cette option est activÃ©e dans le menu. De plus, dans le menu, vous pouvez sÃ©lectionner le format de sortie, que j'ai Ã©galement fourni Ã  l'avance. Sur l'Ã©cran Ã  cÃ´tÃ© de la date et de l'heure, il est possible d'afficher le jour de la semaine. En plus de l'horloge, les coordonnÃ©es actuelles du zoom et de la mise au point sont affichÃ©es Ã  l'Ã©cran comme informations supplÃ©mentaires. Cette option est nÃ©cessaire principalement au stade du dÃ©bogage.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vais vous parler des fonctions du menu que j'ai implÃ©mentÃ©. Au fil du temps, si nÃ©cessaire, le menu sera rÃ©visÃ©: certaines fonctions peuvent Ãªtre supprimÃ©es et d'autres ajoutÃ©es. La structure de menu que j'ai dessinÃ©e dans SPlan, avec les pages vues, est illustrÃ©e dans la figure ci-dessous. FlÃ¨ches rouges - entrez dans la section. FlÃ¨ches bleues - sortie de la section. Je n'ai pas dessinÃ© de flÃ¨ches bleues sur chaque page du menu, je n'en ai dessinÃ© que deux par exemple. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/vs/mp/rlvsmpdeoixbmwlg-jmf2uwj51m.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 12. La structure du menu Ã  l'Ã©cran.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certaines sections de mon menu sont un peu comme des sections de l'original. Tout d'abord, ce sont les deux premiÃ¨res sections: la balance des blancs et l'exposition. Dans la troisiÃ¨me section, vous pouvez spÃ©cifier l'adresse de la camÃ©ra PELCO-D et sÃ©lectionner le dÃ©bit de donnÃ©es (dÃ©bit en bauds) dans la liste. La quatriÃ¨me section est consacrÃ©e Ã  la date et Ã  l'heure. Vous pouvez dÃ©finir la date, l'heure, le jour de la semaine, choisir l'un des quatre formats d'affichage et choisir une mÃ©thode d'affichage. La cinquiÃ¨me section - travailler avec des prÃ©rÃ©glages (modÃ¨les) de zoom et de mise au point, oÃ¹ vous pouvez l'appeler par numÃ©ro, ainsi qu'effacer ou Ã©craser. Toujours dans cette section du menu, vous pouvez choisir l'une des quatre vitesses pour changer la mise au point ou le zoom. La cinquiÃ¨me section vous permet de modifier les paramÃ¨tres du processeur vidÃ©o, situÃ© dans l'octet 9 de la catÃ©gorie 3. Il s'agit du niveau et de l'inversion de la composante de rafale du signal vidÃ©o et de la mise en miroir vidÃ©o. La derniÃ¨re section du menu est pour le dÃ©bogage.En l'utilisant, vous pouvez Ã©crire sur le processeur vidÃ©o n'importe quelle valeur de n'importe quel octet dans n'importe quelle catÃ©gorie. La valeur peut Ãªtre dÃ©finie Ã  la fois sous forme dÃ©cimale et binaire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vais maintenant dire quelques mots sur le chargeur de dÃ©marrage. Comme je l'ai dÃ©jÃ  Ã©crit, le chargeur de dÃ©marrage est nÃ©cessaire pour flasher Ã  distance le camÃ©scope via RS-485. Au dÃ©part, je pensais implÃ©menter entiÃ¨rement le chargeur de dÃ©marrage moi-mÃªme. Cependant, afin de gagner du temps, j'ai dÃ©cidÃ© de faire avec l'un des tÃ©lÃ©chargeurs prÃªts Ã  l'emploi dÃ©jÃ  implÃ©mentÃ©s qui peuvent Ãªtre trouvÃ©s sur Internet. De plus, je ne les ai jamais utilisÃ©s, en ayant une idÃ©e uniquement au niveau thÃ©orique. L'un des critÃ¨res importants pour choisir un chargeur de dÃ©marrage est le support RS-485. En rÃ¨gle gÃ©nÃ©rale, les tÃ©lÃ©chargeurs AVR fonctionnent sur UART RS-232. Et le chargeur de dÃ©marrage avec prise en charge RS-485 ne diffÃ¨re que par le fait qu'une sortie supplÃ©mentaire est allouÃ©e du cÃ´tÃ© MK pour commuter l'Ã©metteur-rÃ©cepteur RS-485 (par exemple, MAX485) pendant le transfert de donnÃ©es du MK vers le PC. Lors du flashage de MK, le chargeur de dÃ©marrage transmet Ã  l'ordinateur des informations sur l'enregistrement rÃ©ussi ou Ã©chouÃ©. Premier chargeur de dÃ©marrageque j'ai trouvÃ© vous permet d'enregistrer non seulement la mÃ©moire FLASH de MK avec le firmware, mais aussi l'EEPROM. En plus d'Ã©crire, vous pouvez Ã©galement lire des donnÃ©es. Mais ce projet avec le code source de l'assembleur Ã©tait assez dÃ©routant et je ne l'ai pas compris. De plus, l'accent principal de ce chargeur de dÃ©marrage visait la possibilitÃ© de flasher plusieurs pÃ©riphÃ©riques individuellement, sans les dÃ©connecter du rÃ©seau RS-485, en accÃ©dant Ã  chaque pÃ©riphÃ©rique Ã  une adresse qui lui Ã©tait auparavant connectÃ©e. Je n'ai pas besoin de telles fonctionnalitÃ©s, car j'utilise une topologie diffÃ©rente du rÃ©seau RS-485, et il est possible de passer rapidement du camÃ©scope du DVR au PC. Le deuxiÃ¨me chargeur de dÃ©marrage est le Chip45 allemand. Le code source n'est pas dans le domaine public, il peut Ãªtre achetÃ© auprÃ¨s de l'auteur. Au lieu de cela, il existe plusieurs centaines de fichiers HEX pour diffÃ©rents AVR MK, diffÃ©rentes interfaces UART (s'il y en a plusieurs, comme dans mon cas),RS-485 ou RS-232 au choix. Bref, pour toutes les occasions. Dans le mÃªme temps, l'auteur note que dans le cas du RS-485, la broche de commutation TX / RX est fixe et correspond Ã  la broche XCK UART de l'interface du contrÃ´leur, qui n'est pratiquement pas utilisÃ©e dans UART. Dans mon cas, la 30Ã¨me broche du XCK de la deuxiÃ¨me interface UART de l'Atmega128 MK est PORTD.5 â€‹â€‹et sert Ã  activer les interrupteurs de fin de course de zoom et de mise au point. En principe, cette fonction n'est pas nÃ©cessaire, car, comme l'ont montrÃ© des Ã©tudes, les interrupteurs de fin de course sont toujours actifs, comme je l'ai dÃ©jÃ  Ã©crit. Et si nÃ©cessaire, vous pouvez transfÃ©rer cette fonction sur n'importe quelle autre sortie libre MK. Mais, de toute faÃ§on, ce chargeur de dÃ©marrage ne m'a pas non plus impressionnÃ©, d'autant plus que je suis tombÃ© sur un chargeur de dÃ©marrage plus intÃ©ressant appelÃ© Â«AVR Universal BootloaderÂ» de conception chinoise. Comme Chip45, il ne peut Ã©crire et que dans la mÃ©moire FLASH de MK.Mais il a un grand nombre de possibilitÃ©s, et j'ai donc fermement dÃ©cidÃ© de rester dessus. Il s'agit d'un projet AVR Studio avec du code source C. Ã‰tant donnÃ© que je travaille dans CodeVisionAVR, j'ai dÃ» installer AVR Studio avec WinAVR. Pour obtenir le fichier HEX du micrologiciel du chargeur de dÃ©marrage, vous devez compiler le projet en apportant des modifications prÃ©liminaires au code source de la configuration de votre appareil et vous avez besoin de la vÃ´tre. La compilation du projet consiste Ã  lancer un fichier bat (fichier batch), dans lequel les commandes de compilation sont Ã©crites. Il n'est donc pas nÃ©cessaire d'ouvrir un projet dans AVR Studio. Les changements dans le code source peuvent Ãªtre effectuÃ©s soit manuellement (au niveau du programmeur), soit en utilisant le configurateur. Le rÃ´le de ce dernier est une fenÃªtre supplÃ©mentaire de l'utilitaire qui fonctionne avec le chargeur de dÃ©marrage, qui est Ã©galement attachÃ©.Dans le configurateur, vous pouvez spÃ©cifier la broche MK pour la commutation TX / RX RS-485, la broche MK pour la LED de contrÃ´le clignotante, la broche MK pour entrer dans le chargeur de dÃ©marrage, la faÃ§on d'entrer le chargeur de dÃ©marrage, le nom et la frÃ©quence MK, etc. De plus, le programme standard bien connu Â«HyperTerminalÂ» peut servir d'utilitaire pour charger un programme utilisateur dans MK, c'est-Ã -dire pour travailler avec le chargeur de dÃ©marrage. Il utilise le protocole Â«XmodemÂ» pour tÃ©lÃ©charger le firmware. Et afin de travailler de maniÃ¨re pratique et visuelle avec le chargeur de dÃ©marrage via le terminal texte, la fonction spÃ©ciale Â«Mode verbeuxÂ» est fournie dans le configurateur. Mais malgrÃ© l'attrait de l'hyperterminal, j'ai dÃ©cidÃ© d'utiliser l'utilitaire fourni avec le chargeur de dÃ©marrage. Le fait est qu'avec la fonction Verbose pratique activÃ©e dans le configurateur, via le terminal, je suis tombÃ© sur la situation suivante.Parfois, cela arrivait lorsque le trafic de donnÃ©es sur la ligne Â«entrait en collisionÂ» (les deux appareils en mode TX), Ã  la suite de quoi le MAX485 dans le camÃ©scope est devenu trÃ¨s chaud et a Ã©chouÃ©, ou plutÃ´t, pas complÃ¨tement, mais uniquement la section RX (transmission de donnÃ©es via RS-485 Ã  la camÃ©ra) . Pour cette raison, j'ai abandonnÃ© HyperTerminal. Et il y a encore un inconvÃ©nient. HyperTerminal ne fonctionne pas avec les fichiers texte HEX et accepte uniquement un fichier binaire. Par consÃ©quent, je devrais appliquer une conversion supplÃ©mentaire de hex en bin. AprÃ¨s avoir gÃ©nÃ©rÃ© le fichier HEX du chargeur de dÃ©marrage, je l'ai cousu dans le MK Ã  l'aide du programme PonyProg et du programmeur SPI habituel. Par consÃ©quent, le chargeur de dÃ©marrage fonctionne comme suit. Lorsque vous allumez le camÃ©scope, le chargeur de dÃ©marrage est immÃ©diatement activÃ©. Il attend une connexion de l'utilitaire pendant une seconde, puis le firmware principal commence Ã  fonctionner. Si la connexion est Ã©tablie avec succÃ¨s,puis le processus de clignotement commence. Dans le mÃªme temps, l'autre extrÃ©mitÃ© de la ligne RS-485 doit Ãªtre prÃ©alablement dÃ©connectÃ©e du DVR et connectÃ©e au PC via l'adaptateur USB RS485 &lt;-&gt; RS232 ou RS485 &lt;-&gt; USB. Soit dit en passant, sur les adaptateurs. La question s'est posÃ©e de savoir comment fabriquer soi-mÃªme un tel adaptateur, car les adaptateurs achetÃ©s sont chers. En fouillant sur Internet, j'ai trouvÃ© un simple circuit adaptateur RS485 &lt;-&gt; RS232. Il est illustrÃ© dans la figure ci-dessous. Il se compose principalement de microcircuits bien connus MAX232 et MAX485, et TX / RX est commutÃ© par le signal de la 3e sortie du connecteur de port COM de l'ordinateur via un circuit Ã  diode zener. Autrement dit, le MAX485 est commutÃ© par le trafic de donnÃ©es que le PC transmet. Tout est simple et ingÃ©nieux.RS232 ou RS485 &lt;-&gt; USB. Soit dit en passant, sur les adaptateurs. La question s'est posÃ©e de savoir comment fabriquer soi-mÃªme un tel adaptateur, car les adaptateurs achetÃ©s sont chers. En fouillant sur Internet, j'ai trouvÃ© un simple circuit adaptateur RS485 &lt;-&gt; RS232. Il est illustrÃ© dans la figure ci-dessous. Il se compose principalement de microcircuits bien connus MAX232 et MAX485, et TX / RX est commutÃ© par le signal de la 3e sortie du connecteur de port COM de l'ordinateur via un circuit Ã  diode zener. Autrement dit, le MAX485 est commutÃ© par le trafic de donnÃ©es que le PC transmet. Tout est simple et ingÃ©nieux.RS232 ou RS485 &lt;-&gt; USB. Soit dit en passant, sur les adaptateurs. La question s'est posÃ©e de savoir comment fabriquer soi-mÃªme un tel adaptateur, car les adaptateurs achetÃ©s sont chers. En fouillant sur Internet, j'ai trouvÃ© un simple circuit adaptateur RS485 &lt;-&gt; RS232. Il est illustrÃ© dans la figure ci-dessous. Il se compose principalement de microcircuits bien connus MAX232 et MAX485, et TX / RX est commutÃ© par le signal de la 3e sortie du connecteur de port COM de l'ordinateur via un circuit Ã  diode zener. Autrement dit, le MAX485 est commutÃ© par le trafic de donnÃ©es que le PC transmet. Tout est simple et ingÃ©nieux.Il se compose principalement de microcircuits bien connus MAX232 et MAX485, et TX / RX est commutÃ© par le signal de la 3e sortie du connecteur de port COM de l'ordinateur via un circuit Ã  diode zener. Autrement dit, le MAX485 est commutÃ© par le trafic de donnÃ©es que le PC transmet. Tout est simple et ingÃ©nieux.Il se compose principalement de microcircuits bien connus MAX232 et MAX485, et TX / RX est commutÃ© par le signal de la 3e sortie du connecteur de port COM de l'ordinateur via un circuit Ã  diode zener. Autrement dit, le MAX485 est commutÃ© par le trafic de donnÃ©es que le PC transmet. Tout est simple et ingÃ©nieux.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dg/_j/xg/dg_jxg5vy5h-i32yee8szg8urho.png"><br>
<i>. 13.   RS-232 &lt;-&gt; RS-485.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AprÃ¨s avoir maÃ®trisÃ© le bootloader, dans mon temps libre, j'ai dÃ©cidÃ© de rechercher l'optique du camÃ©scope. Plus prÃ©cisÃ©ment, il m'est devenu intÃ©ressant de savoir quelles combinaisons de valeurs de zoom et de mise au point produiraient des images focalisÃ©es Ã  diffÃ©rentes distances de l'objectif au sujet. Permettez-moi de vous rappeler que la rÃ©gion de diverses valeurs mutuelles de zoom et de mise au point est dÃ©crite par une rÃ©gion pentagonale (presque rectangulaire). Par exemple, prenez la distance de l'objectif au sujet de 10 cm. L'argument (le long de l'axe des abscisses) du zoom a une plage de valeurs de -600 Ã  600. Il est nÃ©cessaire de sÃ©lectionner la valeur de mise au point Ã  chaque valeur de zoom Ã  laquelle le sujet devant l'objectif dans l'image vidÃ©o sera mis au point. Ensuite, vous devez faire un tableau. Bien sÃ»r, cela n'a aucun sens de trier les 1200 valeurs de zoom, il suffit de prendre quelques dizaines de valeurs avec un certain pas Ã©gal. En tant que telle Ã©tape, j'ai choisi la valeur 50.Ã€ chaque valeur de zoom avec cette Ã©tape (-600, -550, -500, ...) j'ai sÃ©lectionnÃ© la valeur de mise au point et enregistrÃ© les rÃ©sultats de mesure. J'ai fait une procÃ©dure similaire avec d'autres distances de l'objectif au sujet: 50 cm, 1 m, 10 m, 100 m. Le rÃ©sultat Ã©tait une famille de courbes que j'ai affichÃ©es dans Excel.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5o/_4/qi/5o_4qikxragcwmdaeespjactaoi.png"><br>
<i>. 14.  Z-F   .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En regardant les graphiques, je veux faire beaucoup de commentaires. Au zoom minimum, les valeurs de mise au point sont lÃ©gÃ¨rement infÃ©rieures au Â«milieuÂ» (zÃ©ro) pour presque toutes les distances. La courbe rose sur une distance de 10 cm se termine Ã  une valeur de zoom d'environ 250, ce qui correspond Ã  la valeur de mise au point minimale. Cette courbe a un caractÃ¨re dÃ©croissant et est convexe vers le haut. La courbe rouge sur une distance de 1 m a une forme complÃ¨tement diffÃ©rente. D'une part, elle n'est pas monotone, et d'autre part, en ce qui concerne la propriÃ©tÃ© de convexitÃ©, il existe un point d'inflexion. Les courbes pour des distances de 10 m et 100 m sont de mÃªme nature, celles-ci coÃ¯ncident d'ailleurs pratiquement, que je connaissais dÃ©jÃ  Ã  l'avance. Par consÃ©quent, les distances mesurÃ©es de 10 et 100 mÃ¨tres, bien sÃ»r, j'ai pris environ. Ce qui fait osciller la courbe bleue sur une distance d'un demi-mÃ¨tre - au dÃ©part, je n'allais pas prendre de mesures dessus.J'ai choisi cette distance approximativement sur la base du principe que le plus prÃ¨s possible avec un fragment de la courbe correspondante approche de la limite d'angle de la rÃ©gion (coupe). Et c'est arrivÃ©: cette bordure touche pratiquement un fragment de la courbe. En gÃ©nÃ©ral, il convient de noter que la moitiÃ© supÃ©rieure de la rÃ©gion (valeurs de mise au point positives) n'est pratiquement pas utilisÃ©e. L'exception est Ã  une grande distance du sujet Ã  l'objectif et au plus grand zoom. Et pourtant, pour presque toutes les distances (sauf la plus proche, moins d'un demi-mÃ¨tre), Ã  â€‹â€‹faible zoom (150 ou moins), les valeurs de mise au point sont presque les mÃªmes. D'une maniÃ¨re gÃ©nÃ©rale, tous les faits de mesure Ã©noncÃ©s doivent avoir une interprÃ©tation thÃ©orique, basÃ©e sur les lois de l'optique. Mais Ã  l'heure actuelle, je n'ai aucune idÃ©e des appareils de lentilles de ce genre. Maximum,ce que j'ai rencontrÃ© dans le domaine de l'optique, c'est la construction d'un simple tÃ©lescope rÃ©fracteur Ã  deux lentilles. Et dans le cas de ce camÃ©scope - je ne comprenais pas la mÃ©canique de l'optique. En sortie, seuls deux nÅ“uds en mouvement ne sont pas disponibles: le nÅ“ud de mise au point (responsable de la mise au point) et le nÅ“ud de zoom. Et je ne sais pas combien de lentilles il y a au total. Je suppose que deux sont connectÃ©s Ã  ces nÅ“uds mobiles. Il convient Ã©galement de noter que lors du rÃ©glage de la mise au point, le zoom change Ã©galement visuellement lÃ©gÃ¨rement, mÃªme si le nÅ“ud correspondant est fixe.connectÃ© Ã  ces nÅ“uds mobiles. Il convient Ã©galement de noter que lors du rÃ©glage de la mise au point, le zoom change Ã©galement visuellement lÃ©gÃ¨rement, mÃªme si le nÅ“ud correspondant est fixe.connectÃ© Ã  ces nÅ“uds mobiles. Il convient Ã©galement de noter que lors du rÃ©glage de la mise au point, le zoom change Ã©galement visuellement lÃ©gÃ¨rement, mÃªme si le nÅ“ud correspondant est fixe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ã€ la fin de l'article, nous passons aux tests pratiques du camÃ©scope. J'ai dÃ©cidÃ© de ne pas prendre beaucoup de photos, mais de tÃ©lÃ©charger immÃ©diatement toute la vidÃ©o. J'ai enregistrÃ© une capture vidÃ©o via l'appareil, le son a Ã©tÃ© Ã©crit sÃ©parÃ©ment sur l'enregistreur audio. La rÃ©solution d'origine est de 720 par 576. AprÃ¨s avoir tÃ©lÃ©chargÃ© la vidÃ©o sur YouTube, sa qualitÃ© a sensiblement changÃ©.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/H4agAlZlWW8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous allumez l'appareil photo, la premiÃ¨re chose qui se produit est l'initialisation des moteurs pas Ã  pas de zoom et la mise au point sur l'arriÃ¨re-plan de l'image vidÃ©o. Cette image est en noir et blanc et sans AGC, car la procÃ©dure d'initialisation du processeur vidÃ©o n'est pas encore terminÃ©e. En bas Ã  gauche, la date et l'heure actuelles afficheront la date et l'heure de compilation du micrologiciel actuel de l'appareil photo. Dans le code source du firmware, j'ai crÃ©Ã© les variables correspondantes qui se trouvent Ã  des adresses fixes dans le code HEX. Il est supposÃ© qu'au stade de la compilation, plus prÃ©cisÃ©ment aprÃ¨s celui-ci, un programme sera automatiquement exÃ©cutÃ© qui prend les valeurs des variables de l'heure systÃ¨me et les insÃ¨re dans le fichier HEX aux adresses souhaitÃ©es. De plus, il faut encore recompter les sommes de contrÃ´le. Il existe peut-Ãªtre un moyen plus simple. Dans l'exemple de la vidÃ©o, ces variables sont Ã©gales Ã  zÃ©ro, car je n'ai pas encore implÃ©mentÃ© cette fonction.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AprÃ¨s l'initialisation de la SD, le processeur vidÃ©o est initialisÃ© et un message d'accueil est immÃ©diatement affichÃ© sur l'arriÃ¨re-plan de l'image vidÃ©o. Lors du rÃ©glage du zoom et de la mise au point, leurs coordonnÃ©es sont affichÃ©es en bas Ã  droite. Dans la vidÃ©o, je dÃ©montre l'utilisation de la fonction d'enregistrement et de rappel de modÃ¨les (prÃ©rÃ©glages) de zoom et de mise au point dans diverses parties de l'image. Lors de la suppression d'un prÃ©rÃ©glage, les variables correspondantes acquiÃ¨rent la valeur 0xFFFF, ce qui correspond Ã  une valeur de -1. Cette fonction, en principe, est superflue, elle peut Ãªtre exclue.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la derniÃ¨re section du menu, qui est utilisÃ©e pour le dÃ©bogage, je montre l'enregistrement de la catÃ©gorie 9 octet 3. Les fonctions correspondant Ã  cet octet sont dans la section prÃ©cÃ©dente du menu, j'ai Ã©crit Ã  leur sujet plusieurs fois. Ã‰tant donnÃ© que l'Ã©tat actuel de l'octet n'est pas lu Ã  partir du processeur vidÃ©o, je l'ai dÃ©fini manuellement sur Â«48Â» comme l'un des acceptables. AprÃ¨s cela, je change les bits individuels de cet octet, montrant ainsi les fonctions "Mirror" et "Inverse Burst". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous ajustez le niveau "Rafale" dans l'avant-derniÃ¨re section du menu, vous remarquerez un petit bug du firmware qui est facile Ã  corriger. Parmi les autres dÃ©fauts - parfois, lors de la mise Ã  jour de l'heure, des lacunes dans les caractÃ¨res se produisent. Je pense que cela est dÃ» Ã  l'installation Â«tordueÂ» de l'Ã©lectronique Ã  l'intÃ©rieur du camÃ©scope.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En gÃ©nÃ©ral, lors de l'utilisation de l'appareil photo, des inconvÃ©nients mineurs liÃ©s Ã  la navigation dans les menus ont Ã©tÃ© trouvÃ©s. </font><font style="vertical-align: inherit;">Il est donc tout Ã  fait possible que la rÃ©vision nÃ©cessaire soit effectuÃ©e au fil du temps. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, j'ai presque oubliÃ©. </font><font style="vertical-align: inherit;">Comme promis, j'apporte deux photos de ce qu'est devenu le remplissage du camÃ©scope aprÃ¨s le dÃ©veloppement. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m-/0-/ah/m-0-ahq2z2xqxpr988ndcfae5uu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. </font><font style="vertical-align: inherit;">15. Une vue mise Ã  jour du camÃ©scope Ã  l'intÃ©rieur du bas. </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/gs/8_/bw/gs8_bwxf2yy1mqyrt2gmbgzoyu8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. </font><font style="vertical-align: inherit;">16. Une vue mise Ã  jour du camÃ©scope Ã  l'intÃ©rieur du haut.</font></font></i><br>
<br></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr499534/index.html">Guide de dÃ©veloppement du service backend Python</a></li>
<li><a href="../fr499536/index.html">Growbox comme mÃ©thode de se connaÃ®tre</a></li>
<li><a href="../fr499540/index.html">Fonctionnement du rendu de jeu 3D: texturation et filtrage de texture</a></li>
<li><a href="../fr499542/index.html">Top Fakapov Cyan</a></li>
<li><a href="../fr499544/index.html">Apprenez les rÃ©seaux de neurones dans Google Sheets</a></li>
<li><a href="../fr499548/index.html">Masque - prendre soin des autres ou une illusion de sÃ©curitÃ©?</a></li>
<li><a href="../fr499550/index.html">Solutions Ã©co-low-code</a></li>
<li><a href="../fr499556/index.html">Serveur de jeu sur MS Orleans - Partie 3: RÃ©sumÃ©</a></li>
<li><a href="../fr499560/index.html">Correcteur de disposition Xswitcher pour Linux: deuxiÃ¨me Ã©tape</a></li>
<li><a href="../fr499562/index.html">Article infructueux sur l'accÃ©lÃ©ration de la rÃ©flexion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>