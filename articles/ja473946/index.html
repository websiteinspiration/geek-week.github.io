<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏾 👨🏽‍🏭 🥄 マイクロサービスの分散ロギングとトレース 📪 🌘 🏜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ロギングはあらゆるアプリケーションの重要な部分です。ロギングシステムは、3つの主要な進化的ステップを経ます。 1つ目はコンソールへの出力、2つ目はファイルへのロギングと構造化ロギングのフレームワークの外観、3つ目は単一のセンターでの分散型ロギングまたはさまざまなサービスのログの収集です。
 
 ログ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>マイクロサービスの分散ロギングとトレース</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/473946/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロギングはあらゆるアプリケーションの重要な部分です。ロギングシステムは、3つの主要な進化的ステップを経ます。 1つ目はコンソールへの出力、2つ目はファイルへのロギングと構造化ロギングのフレームワークの外観、3つ目は単一のセンターでの分散型ロギングまたはさまざまなサービスのログの収集です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ログが適切に構成されている場合は、何がいつ、どのように問題が発生したかを理解し、これらのエラーを修正する必要がある人に必要な情報を伝えることができます。 190か国の10か所のデータセンターで毎秒10万通のメッセージが送信され、350人のエンジニアが毎日何かを展開するシステムの場合、ロギングシステムは特に重要です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sy/7i/u_/sy7iu_dnjrrvar7krt8llrje1ga.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イヴァン・レテンコ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;-Infobipのチームリーダー兼開発者。このような巨大な負荷の下でのマイクロサービスアーキテクチャにおける集中処理とログトレースの問題を解決するために、同社はELK、Graylog、Neo4j、MongoDBスタックのさまざまな組み合わせを試しました。その結果、多くのレーキの後、彼らはElasticsearchにログサービスを書き、PostgreSQLは追加情報のデータベースとして採用されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
猫の下で詳細に例とグラフを示します。システムのアーキテクチャと進化、レーキ、ロギングとトレース、メトリックスとモニタリング、Elasticsearchクラスターの操作、および限られたリソースの状況でのクラスターの管理の実践。</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Sr71xsI6X5I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテキストを紹介するために、会社について少しお話します。</font><font style="vertical-align: inherit;">タクシーサービスからのメッセージ、キャンセルに関する銀行からのSMS、またはVCに入るときのワンタイムパスワードなど、クライアント組織がクライアントにメッセージを配信するのを支援します。</font><font style="vertical-align: inherit;">190か国のクライアントに対して、</font><font style="vertical-align: inherit;">毎日</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3億5000万通のメッセージ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">届きます。</font><font style="vertical-align: inherit;">それらのそれぞれは、受け入れ、処理、請求、ルーティング、適応、オペレーターへの送信、そして反対方向に、配信レポートの処理と分析の生成を行います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがそのようなボリュームで機能するために、私たちは持っています：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">世界中に36のデータセンター。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5000以上の仮想マシン</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">350人以上のエンジニア;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">730以上の異なるマイクロサービス。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは複雑なシステムであり、グルを一人で理解することはできません。当社の主な目標の1つは、ビジネス向けの新機能とリリースの高速配信です。この場合、すべてが機能し、落下しないはずです。現在取り組んでいるのは、2017年に4万回、2018年に8万回、1日あたり300回の展開です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちには350人のエンジニア</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がいます</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、</font><b><font style="vertical-align: inherit;">すべてのエンジニアが毎日何かを配備</font></b><font style="vertical-align: inherit;">して</font><b><font style="vertical-align: inherit;">いる</font></b><font style="vertical-align: inherit;">ことが</font><b><font style="vertical-align: inherit;">わかります</font></b><font style="vertical-align: inherit;">。ほんの数年前、会社でたった1人しかこのようなパフォーマンスを発揮しませんでした-私たちの主任エンジニアであるクレシミール。しかし、すべてのエンジニアが[展開]ボタンを押すかスクリプトを実行するとき、クレシミールと同じように自信を持つことができるようにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これには何が必要ですか？まず</font><b><font style="vertical-align: inherit;">、システムで何が起こっているかを理解している</font></b><font style="vertical-align: inherit;">という</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">確信</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そしてそれがどのような状態にあるか。</font><font style="vertical-align: inherit;">信頼性は、システムに質問して、インシデント中およびコードの開発中に問題の原因を見つける能力によって与えられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この信頼を実現するために、私たちは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">観察可能性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に投資してい&nbsp; </font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">従来、この用語は次の3つのコンポーネントを組み合わせています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロギング;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メトリック</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">痕跡。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これについてお話します。</font><font style="vertical-align: inherit;">まず、ロギングのソリューションを見てみましょう。しかし、メトリックとトレースにも触れます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">進化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロギングを含むほとんどすべてのアプリケーションまたはシステムは、いくつかの進化段階を経ています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のステップは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コンソール</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">への</font><b><font style="vertical-align: inherit;">出力</font></b><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルへのログの書き込み</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を開始</font><b><font style="vertical-align: inherit;">すると、ファイル</font></b><font style="vertical-align: inherit;">への構造化された出力のための</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレームワーク</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が表示さ</font><font style="vertical-align: inherit;">れます。 JVMに住んでいるため、通常はLogbackを使用します。この段階で、ファイルへの構造化されたロギングが表示され、異なるログには異なるレベル、警告、エラーが必要であることを理解しています。</font><b><font style="vertical-align: inherit;">私たちのサービス</font></b><font style="vertical-align: inherit;">または異なるサービスの</font><b><font style="vertical-align: inherit;">インスタンス</font></b><b><font style="vertical-align: inherit;">がすでにいくつか</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
あるとすぐに</font><font style="vertical-align: inherit;">、</font><b><font style="vertical-align: inherit;">一元化されたアクセスの</font></b><font style="vertical-align: inherit;">タスク</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発者とサポートのログに。</font><font style="vertical-align: inherit;">分散ロギングに移ります。さまざまなサービスを1つのロギングサービスに結合します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分散ロギング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も有名なオプションはELKスタック、Elasticsearch、Logstash、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kibana</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font><font style="vertical-align: inherit;">が、Graylogを選択し</font><b><font style="vertical-align: inherit;">ました</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ロギング向けのクールなインターフェースを備えています。</font><font style="vertical-align: inherit;">たとえば、Kibanaにはない、無料バージョンのアラートはすぐに利用できます。</font><font style="vertical-align: inherit;">私たちにとって、これはログに関して優れた選択であり、内部的には同じElasticsearchです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x1/en/7f/x1en7fmypsgbipabhmfhy6y7rts.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graylogでは、アラート、Kibanaのようなグラフ、さらにはログメトリックを作成できます。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの会社は成長しており、ある時点で、Graylogに問題があることが明らかになりました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">過剰な負荷</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">パフォーマンスの問題がありました。</font><font style="vertical-align: inherit;">多くの開発者は、Graylogの優れた機能を使い始めました。データの集計を実行するメトリックとダッシュボードを作成しました。</font><font style="vertical-align: inherit;">記録の負荷が高いElasticsearchクラスターで高度な分析を構築するのに最適ではありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">衝突</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">多くのチームがあり、単一のスキームはありません。</font><font style="vertical-align: inherit;">従来、1つのIDが最初に長い間グレイログにヒットすると、マッピングが自動的に発生しました。</font><font style="vertical-align: inherit;">別のチームがUUIDを文字列として書き込む必要があると判断した場合-これはシステムを破壊します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の決定</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分離されたアプリケーションログと通信ログ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。異なるログには、異なるシナリオと適用方法があります。たとえば、さまざまなチームがさまざまなパラメーターに対してさまざまな要件を持っているアプリケーションログがあります。システム内の保存時間、検索速度などです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、最初に行ったのは、アプリケーションログと通信ログを分離することでした。 2番目のタイプは、プラットフォームと外界との相互作用およびプラットフォーム内の相互作用に関する情報を格納する重要なログです。これについては、後で詳しく説明します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ログのかなりの部分をメトリックに置き換えました</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私たちの会社では、標準的な選択はプロメテウスとグラファナです。</font><font style="vertical-align: inherit;">一部のチームは他のソリューションを使用しています。</font><font style="vertical-align: inherit;">ただし、Graylog内に集約された多数のダッシュボードを削除し、すべてをPrometheusとGrafanaに転送したことが重要です。</font><font style="vertical-align: inherit;">これにより、サーバーの負荷が大幅に軽減されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ログ、メトリック、トレースを適用するシナリオを見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ログ</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高い次元性、デバッグ、研究</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">良いログとは何ですか？</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ログは、記録するイベントです。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらは大きなディメンションを持つことができます：リクエストID、ユーザーID、リクエスト属性、およびその他のデータをログに記録できます。そのディメンションは制限されていません。</font><font style="vertical-align: inherit;">また、デバッグと調査、システムに何が起こったかについての質問、原因と影響の調査にも適しています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指標</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低次元性、集約、監視、アラート</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">すべてのメトリックコレクションシステムの内部には、時系列データベースがあります。</font><font style="vertical-align: inherit;">これらのデータベースは優れた集計機能を備えているため、メトリックはアラートの集計、監視、および構築に適しています。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指標はデータディメンションに非常に敏感です。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指標の場合、データのディメンションは1,000を超えてはなりません。</font><font style="vertical-align: inherit;">値のサイズが無制限のリクエストIDを追加すると、深刻な問題がすぐに発生します。</font><font style="vertical-align: inherit;">すでにこのレーキを踏んでいます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相関とトレース</font></font></h3><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ログは相関している必要があります。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造化ログでは、データで簡単に検索するには不十分です。特定の値を持つフィールドがあるはずです：リクエストID、ユーザーID、ログの送信元のサービスからの他のデータ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従来の解決策は、システムの入り口でトランザクション（ログ）に一意のIDを割り当てることです。次に、このID（コンテキスト）は、サービス内またはサービス間の一連の呼び出しを通じてシステム全体に転送されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sk/ba/ht/skbahtrbo1zjpc7x8u8hy_odxg4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相関とトレース。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
確立された用語があります。トレースはスパンに分割され、あるサービスのコールスタックを別のサービスに関連付け、1つのメソッドを別のサービスに関連付け、タイムラインを示します。メッセージパス、すべてのタイミングを明確に追跡できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初にZipkinを使用しました。 2015年にはすでに、これらのソリューションの概念実証（パイロットプロジェクト）がありました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/iw/jg/f1/iwjgf1st5rm6ymwppx3g9scb_uw.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分散トレース </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような画像を取得するには、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードをインストルメント化する必要があります</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">すでに存在するコードベースを使用している場合は、コードベースを確認する必要があります-変​​更が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体像を把握し、トレースを活用</font><font style="vertical-align: inherit;">するには、現在作業している1つのサービスだけでなく</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、チェーン内のすべてのサービス</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><b><font style="vertical-align: inherit;">インストルメント化する</font></b><font style="vertical-align: inherit;">必要が</font><b><font style="vertical-align: inherit;">あります</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは強力なツールですが、管理とハードウェアに多大なコストがかかるため、Zipkinから「サービスとして」提供される別のソリューションに切り替えました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配送通知</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ログは相関している必要があります。</font><font style="vertical-align: inherit;">トレースも相関している必要があります。</font><font style="vertical-align: inherit;">単一のIDが必要です。これは、コールチェーン全体に転送できる共通のコンテキストです。</font><font style="vertical-align: inherit;">しかし、多くの場合、これは不可能</font><font style="vertical-align: inherit;">です。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相関関係は、その操作の結果としてシステム内で発生します</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">1つ以上のトランザクションを開始しても、それらが単一の大きな全体の一部であることはまだわかりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の例を考えてみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/05/lf/ds/05lfdssmlzvh6h41nzgl3w8cjwu.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配送通知。</font></font></i><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントがメッセージのリクエストを送信し、内部プラットフォームがそれを処理しました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーターとの対話に従事しているサービスは、このメッセージをオペレーターに送信しました-エントリーがログシステムに表示されました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後、オペレーターは配送レポートを送信します。</font></font><br>
</li>
<li>,   , &nbsp;, &nbsp;      &nbsp;.       .<br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの関連トランザクションは、1つのトランザクション全体の一部です。この情報は、サポートエンジニアや統合開発者にとって非常に重要です。しかし、これは単一のトレースまたは単一のIDに基づいて見ることは完全に不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のケースも同様です。クライアントが大きなバンドルでメッセージを送信してから、それらを逆アセンブルします。それらもバッチで返されます。パックの数は異なる場合がありますが、それらすべてが組み合わされます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/67/jg/w3/67jgw3eyg33a7bwjsx8savqmgxo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントの観点から、彼はメッセージを送信し、応答を受信しました。しかし、組み合わせる必要のあるいくつかの独立したトランザクションがありました。 1対多の関係であり、配信レポートも1対1です。これは基本的にグラフです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h6/bm/ak/h6bmak77dcsvoqebnfriqxuiqcq.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラフを作成しています。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフが表示されたら、Neo4jなどのグラフデータベースが適切です。</font><font style="vertical-align: inherit;">Neo4jがカンファレンスでクールなTシャツと無料の本を提供するため、選択は明白でした。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neo4j</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概念実証を実装しました。1億のノードと1億5000万のリンクのグラフを処理できる16コアのホストです。</font><font style="vertical-align: inherit;">グラフは15 GBのディスクしか占有しませんでした。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aa/5q/bk/aa5qbkmdwshpycitkyz3-lztkck.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちの決定。</font><font style="vertical-align: inherit;">ログのアーキテクチャ。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neo4jに加えて、関連するログを表示するためのシンプルなインターフェースが追加されました。</font><font style="vertical-align: inherit;">彼と一緒に、エンジニアは全体像を見ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、すぐに、このデータベースに失望しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neo4jの問題</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データローテーション</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">強力なボリュームがあり、データをローテーションする必要があります。</font><font style="vertical-align: inherit;">ただし、Neo4jからノードを削除すると、ディスク上のデータは消去されません。</font><font style="vertical-align: inherit;">複雑なソリューションを構築し、グラフを完全に再構築する必要がありました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンス</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">すべてのグラフデータベースは読み取り専用です。</font><font style="vertical-align: inherit;">録音時のパフォーマンスは著しく低下します。</font><font style="vertical-align: inherit;">私たちのケースはまったく逆です。私たちはたくさん書き込み、比較的めったに読むことはありません-これらは、1秒あたり、または1分あたりのリクエストの単位です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有償の高可用性とクラスター分析</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私たちの規模では、これはまともなコストに変換されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、私たちは反対に行きました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLによるソリューション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはめったに読まないので、読むときにその場でグラフを作成できると判断しました。したがって、PostgreSQLリレーショナルデータベースでは、IDの隣接リストを、2つの列と両方のインデックスを持つ単純なプレートの形式で保存します。リクエストが到着すると、おなじみのDFSアルゴリズム（深度トラバーサル）を使用して接続グラフをバイパスし、関連するすべてのIDを取得します。しかし、これは必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データのローテーションも簡単に解決できます。毎日、新しいプレートを開始し、数日後に時間が来ると、それを削除してデータをリリースします。シンプルなソリューション。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、PostgreSQLには8億5,000万の接続があり、100 GBのディスクを使用しています。ここでは毎秒30千の速度で書き込みますが、この場合、データベースには2つのCPUと6 GBのRAMを備えたVMが2つしかありません。必要に応じて、PostgreSQLはlongをすばやく書き込むことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回転して制御するサービス自体のための小さなマシンはまだあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yk/re/vq/ykrevqnk3xx8rpa3lkc9lkgiram.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アーキテクチャがどのように変化したか。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graylogの課題</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同社は成長し、新しいデータセンターが登場し、通信ログを備えたソリューションを使用しても負荷は著しく増加しました。グレイログはもはや完璧ではないと考えました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統一スキームと一元化</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 1つのクラスター管理ツールを10のデータセンターに配置したいと考えています。また、衝突が発生しないように統一されたデータマッピング方式の問題が発生しました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。独自のインターフェイスを使用してログと標準のGraylog APIの間の接続を表示します。たとえば、さまざまなデータセンターからのデータを表示し、それらを正しくソートしてマークする必要がある場合など、必ずしも便利ではありませんでした。したがって、私たちは好きなようにAPIを変更できるようにしたかったのです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンス、損失の見積もりは困難</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">トラフィックは1日あたり3 TBのログであり、まともです。</font><font style="vertical-align: inherit;">したがって、Graylogは常に安定して動作するわけではなく、障害の原因を理解するために内部に入る必要がありました。</font><font style="vertical-align: inherit;">もはやそれをツールとして使用していないことがわかりました-私たちはそれについて何かをしなければなりませんでした。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">処理遅延（キュー）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">グレイログのキューの標準的な実装は好きではありませんでした。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MongoDBをサポートする必要性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">GraylogはMongoDBをドラッグします。このシステムも管理する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、独自のソリューションが必要であることを認識しました。</font><font style="vertical-align: inherit;">おそらく、ダッシュボードでは使用されていないアラートの優れた機能は少ないですが、それらの機能のほうが優れています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちの決定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
独自のログサービスを開発しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2e/cl/zb/2eclzbtgkkzyjdy1u9amvwujcw8.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ログサービス。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その瞬間、私たちは大規模なElasticsearchクラスターのサービスと保守に関する専門知識をすでに持っていたので、Elasticsearchを基礎として採用しました。</font><font style="vertical-align: inherit;">社内の標準スタックはJVMですが、バックエンドではKotlinも有名に使用しているため、この言語をサービスに採用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の質問は、データをローテーションする方法とマッピングをどうするかです。</font><font style="vertical-align: inherit;">固定マッピングを使用します。</font><font style="vertical-align: inherit;">Elasticsearchでは、同じサイズのインデックスを使用することをお勧めします。</font><font style="vertical-align: inherit;">しかし、そのようなインデックスを使用すると、特にいくつかのデータセンター、分散システム、および分散状態のデータを何らかの形でマッピングする必要があります。</font><font style="vertical-align: inherit;">ZooKeeperを固定するアイデアはありましたが、これもメンテナンスとコードの複雑化です。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したがって、私たちは単に決めました-時間通りに書いてください。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1時間に1つのインデックス、他のデータセンターでは1時間に2つのインデックス、3つ目のインデックスには3時間のインデックスがすべて時間内にあります。</font><font style="vertical-align: inherit;">インデックスはさまざまなサイズで取得されます。これは、夜間のトラフィックは日中のトラフィックよりも少ないためですが、通常は機能します。</font><font style="vertical-align: inherit;">経験上、合併症は必要ないことが示されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
移行を容易にし、大量のデータを考慮して、GELFプロトコルを選択しました。これは、TCPに基づく単純なグレイログプロトコルです。</font><font style="vertical-align: inherit;">そこで、Netty用のGELFサーバーとGELFデコーダーを手に入れました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、JSONをエンコードしてElasticsearchに書き込みます。</font><font style="vertical-align: inherit;">Elasticsearchの公式Java APIを使用し、一括で書き込みます。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">録音速度を上げるには、Bulk'amiと書く必要があります。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは重要な最適化です。</font><font style="vertical-align: inherit;">APIは、リクエストを自動的に蓄積し、バンドルまたは時間をかけて記録するために送信するバルクプロセッサを提供します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バルクプロセッサの問題</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべて問題ないようです。しかし、始めてみて、Bulkプロセッサに依存していることに気づきました。これは予想外でした。私たちは、頼りにしていた価値を達成することはできません-問題はどこからも起こりました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f8/eh/aq/f8ehaq7rjnpje-lcnrr3gtbk6ho.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準実装では、並列処理設定があるにもかかわらず、Bulkプロセッサはシングルスレッドで同期します。それが問題でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ぶらぶら調べたところ、これは既知のバグであり、解決されていないことが判明しました。 Bulkプロセッサを少し変更しました-ReentrantLockを介して明示的なロックを作成しました。 5月にのみ、公式のElasticsearchリポジトリに同様の変更が加えられ、バージョン7.3以降でのみ使用可能になります。現在のバージョンは7.1で、バージョン6.3を使用しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bulkプロセッサも使用していて、Elasticsearchのエントリをオーバークロックする場合</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">は、GitHubで</font></a><font style="vertical-align: inherit;">これらの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">変更を</font></a><font style="vertical-align: inherit;">確認してください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お使いのバージョンに移植してください。</font><font style="vertical-align: inherit;">変更は一括プロセッサにのみ影響します。</font><font style="vertical-align: inherit;">以下のバージョンに移植する必要がある場合、問題はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが順調で、Bulkプロセッサがなくなって、速度が加速しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/al/kk/nz/alkknzzqgvbtqc-lx0alpunp27y.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インデックスのマージ、フラッシュなどのさまざまな操作がそこで行われるため、Elasticsearchの書き込みパフォーマンスは時間とともに不安定になります。</font><font style="vertical-align: inherit;">また、ノードの一部がクラスターから削除された場合など、メンテナンス中にパフォーマンスがしばらく低下します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この点で、メモリ内のバッファだけでなくキューも実装する必要があることに気付きました。</font><font style="vertical-align: inherit;">拒否されたメッセージのみをキューに送信することを決定しました-BulkプロセッサーがElasticsearchに書き込めなかったメッセージのみ。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォールバックを再試行</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは単純な実装です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拒否されたメッセージをファイルに保存します</font></font><code>RejectedExecutionHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別のエグゼキューターで指定された間隔で再送信します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただし、新しいトラフィックを遅らせることはありません。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サポートエンジニアと開発者にとって、システムの新しいトラフィックは、Elasticsearchの急上昇またはスローダウン中に何らかの理由で遅延したトラフィックよりも、著しく重要です。</font><font style="vertical-align: inherit;">彼は残りましたが、彼は後で来るでしょう-大したことはありません。</font><font style="vertical-align: inherit;">新しいトラフィックが優先されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_f/jf/xz/_fjfxzutbmmt88ibablan9les0i.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちの計画はこのように見え始めました。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Elasticsearchを準備する方法、使用したパラメーター、およびセットアップ方法について説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elasticsearch構成</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが直面している問題は、Elasticsearchをオーバークロックして書き込み用に最適化する必要があることです。これは、読み取りの数が著しく少ないためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのパラメーターを使用しました。</font></font><br>
<br>
<code>"ignore_malformed": true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-&nbsp; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメント全体ではなく、間違ったタイプのフィールドを破棄します</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。何らかの理由で不正なマッピングを持つフィールドがリークした場合でも、データを保存したいと考えています。このオプションは、パフォーマンスに完全に関連しているわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
鉄については、Elasticsearchにはニュアンスがあります。大規模なクラスターを要求し始めたとき、ボリューム用のSSDドライブからのRAIDアレイは非常に高価であると言われました。ただし、フォールトトレランスとパーティション分割は既にElasticsearchに組み込まれているため、配列は必要ありません。公式サイトでも、安くて良い鉄よりも安い鉄を取ることをお勧めします。 Elasticsearch全体の並列性が非常に高いため、これはディスクとプロセッサコアの数の両方に当てはまります。</font></font><br>
<br>
<code>"index.merge.scheduler.max_thread_count": 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-&nbsp; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HDDを推奨</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SSDではなく通常のHDDを入手した場合は、このパラメーターを1に設定します。インデックスは断片に書き込まれ、これらの断片は凍結されます。これにより、ディスクが少し節約されますが、何よりも検索が高速化されます。また、インデックスへの書き込みを停止すると、次のことができます</font></font><code>force merge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。クラスターの負荷が少ない場合、クラスターは自動的にフリーズします。</font></font><br>
<br>
<code>"index.unassigned.node_left.delayed_timeout": "5m"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-&nbsp; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノードが消えたときのデプロイメントの遅延</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、ノードが再起動、デプロイ、またはメンテナンスのために撤回された場合に、Elasticsearchがインデックスとデータの実装を開始するまでの時間です。ただし、ディスクとネットワークの負荷が大きい場合、展開は困難な操作です。それらを過負荷にしないために、このタイムアウトは、必要な遅延を制御および理解するのに適しています。</font></font><br>
<br>
<code>"index.refresh_interval": -1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-&nbsp; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検索クエリがない場合は、インデックスを更新しないでください</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。その後、検索クエリが表示されるとインデックスが更新されます。このインデックスは、秒と分で設定できます。</font></font><br>
<br>
<code>"index.translogDurability": "async"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-fsyncを実行する頻度：要求ごとまたは時間内。遅いドライブのパフォーマンスを向上させます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それを使用する興味深い方法もあります。</font><font style="vertical-align: inherit;">サポートと開発者は、メッセージ本文全体で全文検索を行い、正規表現を使用できるようにしたいと考えています。</font><font style="vertical-align: inherit;">ただし、Elasticsearchではこれは不可能です。システムにすでに存在するトークンでのみ検索できます。</font><font style="vertical-align: inherit;">RegExpとワイルドカードを使用できますが、トークンを一部のRegExpで始めることはできません。</font><font style="vertical-align: inherit;">したがって、</font></font><code>word_delimiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィルター</font><font style="vertical-align: inherit;">に追加</font><font style="vertical-align: inherit;">しました。</font></font><br>
<br>
<pre><code class="plaintext hljs">"tokenizer": "standard"	<font></font>
"filter" : [ "word_delimiter" ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単語を自動的にトークンに分割します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Wi-Fi」→「Wi」、「Fi」;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「PowerShot」→「Power」、「Shot」;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「SD500」→「SD」、「500」。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスの名前、さまざまなデバッグ情報は同様の方法で記述されます。</font><font style="vertical-align: inherit;">これにより、全文検索の問題のいくつかを解決しました。</font><font style="vertical-align: inherit;">ログインを使用する場合は、このような設定を追加することをお勧めします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスターについて</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャードの数は、ロードバランシングのデータノードの数と同じである必要があります</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。レプリカの最小数は1で、各ノードには1つのメインシャードと1つのレプリカがあります。ただし、財務トランザクションなどの2つ以上の貴重なデータがある場合。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャードのサイズは、数GBから数十GB</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。もちろん、ノード上のシャードの数は、Elasticsearchヒップの1 GBあたり20以下です。さらにElasticsearchは遅くなります-私たちはそれも攻撃しました。トラフィックの少ないこれらのデータセンターでは、データの量が循環せず、数千のインデックスが表示され、システムがクラッシュしました。</font><font style="vertical-align: inherit;">たとえば、メンテナンスの場合は、ハイパーバイザーの名前でを</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用し</font></font></b> <code>allocation awareness</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。インデックスとシャードをさまざまなハイパーバイザーに分散させ、ハイパーバイザーがドロップしたときに重複しないようにします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事前にインデックスを作成します</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。特に時間どおりに書く場合は、良い習慣です。インデックスはすぐにホットで準備ができており、遅延はありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノードごとに1つのインデックスのシャードの数を制限します</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>"index.routing.allocation.total_shards_per_node": 4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノードあたりの1つのインデックスのシャードの最大数です。理想的なケースでは、2つありますが、まだ車の数が少ない場合に備えて、4つを配置します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここの問題は何ですか？を使用しております</font></font><code>allocation awareness</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-Elasticsearchは、ハイパーバイザー全体にインデックスを適切に分散する方法を知っています。</font><font style="vertical-align: inherit;">しかし、ノードが長期間オフにされてからクラスターに戻った後、Elasticsearchはそれが正式に少ないインデックスを持っていることを確認し、それらが復元されることを発見しました。</font><font style="vertical-align: inherit;">データが同期されるまで、正式にはノードにインデックスはほとんどありません。</font><font style="vertical-align: inherit;">必要に応じて、新しいインデックスを割り当てます。Elasticsearchは、このマシンを新しいインデックスでできる限り密にハンマーしようとします。</font><font style="vertical-align: inherit;">したがって、ノードは、データがノードにレプリケートされるという事実だけでなく、このノードに該当する新しいトラフィック、インデックス、および新しいデータによっても負荷を受け取ります。</font><font style="vertical-align: inherit;">それを制御し、制限します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elasticsearchメンテナンスの推奨事項</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elasticsearchを使用するユーザーは、これらの推奨事項に精通しています。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定期メンテナンス中に、ローリングアップグレードの推奨事項を適用します。シャード割り当てを無効にし、フラッシュを同期します。</font></font></blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャード割り当てを無効にし</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">レプリカシャードの割り当てを無効にし、プライマリのみを割り当てる機能を残します。</font><font style="vertical-align: inherit;">これはElasticsearchを著しく助けます-不要なデータを再割り当てしません。</font><font style="vertical-align: inherit;">たとえば、30分でノードが上昇することがわかっています。なぜすべてのシャードを1つのノードから別のノードに転送するのでしょうか。</font><font style="vertical-align: inherit;">プライマリシャードしか使用できない場合、黄色のクラスターに30分滞在しても、何もひどいことはありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期されたフラッシュ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この場合、ノードがクラスターに戻ると、ノードの同期がはるかに速くなります。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスへの書き込みまたはリカバリの負荷が大きい場合、レプリカの数を減らすことができます。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピーク負荷などの大量のデータをダウンロードする場合、シャードをオフにして、後でElasticsearchにコマンドを送信して、負荷がすでに少ないときにそれらを作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここに私が使用したいいくつかのコマンドがあります：</font></font><br>
<br>
<ul>
<li><code>GET _cat/thread_pool?v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>thread_pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各ノード</font><font style="vertical-align: inherit;">を確認できます。</font><font style="vertical-align: inherit;">現在のホットなもの、書き込みと読み取りのキューは何</font><font style="vertical-align: inherit;">ですか</font><font style="vertical-align: inherit;">。</font></font><br>
</li>
<li><code>GET _cat/recovery/?active_only=true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -どのインデックスがどこで販売されているか、どこで回復が起こっているか。</font></font><br>
</li>
<li><code>GET _cluster/allocation/explain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -便利な人間の形で、なぜまたはどのインデックスまたはレプリカが割り当てられなかったか。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
監視にはGrafanaを使用します。</font><b><font style="vertical-align: inherit;">Vincent van Hollebekeの</font></b></font><br>
<br>
<img src="https://habrastorage.org/webt/zg/wz/pm/zgwzpmdlzs580aaf88kv-l_rnh4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
優れた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エクスポーター</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とGrafanaチームプレイが&nbsp; </font><font style="vertical-align: inherit;">あり、クラスターとそのすべての主要パラメーターのステータスを視覚的に確認できます。</font><font style="vertical-align: inherit;">ボックスからデプロイするときに、それをDockerイメージとすべてのメトリックに追加しました。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロギングの結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ログは：</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一元化</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;-開発者の単一のエントリポイント。</font></font><br>
</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">利用可能</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;-すばやく検索する機能。</font></font><br>
</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造化</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;-貴重な情報を迅速かつ便利に抽出します。</font></font><br>
</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相関</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;-それらの間だけでなく、使用する他のメトリックやシステムとも</font><b><font style="vertical-align: inherit;">相関</font></b><font style="vertical-align: inherit;">します。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スウェーデンの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melodifestivalen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテストが最近開催されました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、スウェーデンからのEurovisionの代表者の抜粋です。</font><font style="vertical-align: inherit;">コンテストの前に、サポートサービスから連絡がありました。</font><font style="vertical-align: inherit;">トラフィックは非常に機密性が高く、一部のデータを関連付けたいと考えています。</font><font style="vertical-align: inherit;">Grafanaダッシュボードにないログのデータがあります。</font><font style="vertical-align: inherit;">Prometheusから取得できる指標はありますが、特定のIDリクエストに関するデータが必要です。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは、ElasticsearchをGrafanaのソースとして追加し、このデータを相互に関連付け、問題を閉じ、非常に良い結果を十分に速く得ることができました。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自のソリューションを利用する方がはるかに簡単です。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在、このソリューションで機能していた10個のGraylogクラスターの代わりに、いくつかのサービスがあります。</font><font style="vertical-align: inherit;">これらは10のデータセンターですが、専用のチームやサービスを提供する人もいません。</font><font style="vertical-align: inherit;">それらに取り組み、必要に応じて何かを変更した人が何人かいます。</font><font style="vertical-align: inherit;">この小さなチームは完全に私たちのインフラストラクチャに統合されています-展開とサービスはより簡単で安価です。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ケースを分けて適切なツールを使用します。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらは、ロギング、トレース、モニタリングのための個別のツールです。すべてのニーズをカバーする「黄金の道具」はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要なツール、監視対象、ログの使用場所、ログの要件を理解するには、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SLI / SLO-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;サービスレベルインジケーター/サービスレベル目標</font><font style="vertical-align: inherit;">を必ず参照してください&nbsp; </font><font style="vertical-align: inherit;">。あなたはあなたの顧客とあなたのビジネスにとって何が重要であるか、彼らがどの指標を見ているかを知る必要があります。</font></font><br>
<br>
<blockquote>   &nbsp;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">HighLoad++ 2019</a>.  7    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>,    Redis  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a> 150     . <br>
<br>
 &nbsp; &nbsp;  HighLoad++ 2019&nbsp;, &nbsp;  . &nbsp;     &nbsp; &nbsp;— &nbsp;,  &nbsp;-. .    &nbsp; &nbsp;—  &nbsp; <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a> .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja473932/index.html">ハイブリッドゲームAIの仕組みとその利点</a></li>
<li><a href="../ja473936/index.html">インタラクティブなオーディオパフォーマンス-音声アシスタントゲームの新時代</a></li>
<li><a href="../ja473938/index.html">IConfigurationを介してアプリケーション設定をユニバーサルに保存する</a></li>
<li><a href="../ja473940/index.html">強度テスト：真珠貝の貴族の耳介のナノメカニクス</a></li>
<li><a href="../ja473944/index.html">RimWorldの作成者からのアドバイス：ゲームのファンを予測する際の認知の歪み</a></li>
<li><a href="../ja473948/index.html">Operon：Ansibleのパフォーマンスをスピードアップ</a></li>
<li><a href="../ja473950/index.html">実装、スケーリング：VTBで自動テストを使用した経験</a></li>
<li><a href="../ja473952/index.html">ターンベースの戦略のためにAIを書いたとき</a></li>
<li><a href="../ja473956/index.html">ドラッグディーラーの電話会社からの秘密情報</a></li>
<li><a href="../ja473958/index.html">NICTの日本人が、1 Pbit / sの帯域幅で動作するファイバークラスターを紹介しました</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>