<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏽 👈🏿 👊🏾 Clasificación suave 🌕 😘 👩🏼‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos sumergiéndonos en una variedad de montones. 
 
 Hoy analizaremos un método de pedido elegante que utiliza montones especiales basados ​​en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Clasificación suave</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/496852/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img align="left" width="350" height="350" src="https://habrastorage.org/webt/rn/rl/bg/rnrlbgzncwdiackzlubtakt02u0.jpeg"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Continuamos sumergiéndonos en una variedad de montones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoy analizaremos un método de pedido elegante que utiliza montones especiales basados ​​en los números de Leonardo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muchos han escuchado sobre esta clasificación, pero pocas personas saben exactamente cómo funciona. Hoy veremos que no hay nada complicado en ello. </font><font style="vertical-align: inherit;">
El método fue inventado por el legendario Edsger Dijkstra. Además de los muchos logros más brillantes en la teoría de algoritmos, también es autor de una afirmación tan ingeniosa: </font><i><font style="vertical-align: inherit;">“Los estudiantes que han estudiado previamente Básico, es casi imposible enseñar una buena programación. Como programadores potenciales, han sufrido una degradación mental irreversible ".</font></i><font style="vertical-align: inherit;"> 
Espero que no sea una blasfemia que la animación del artículo se haya creado usando VBA :-)</font></font><br>
<br>
<img width="750" height="1" src="https://habrastorage.org/webt/63/4u/g_/634ug_fmfdzyhgeg6ta-ddcdpau.gif"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img align="right" width="195" height="280" src="https://habrastorage.org/webt/fq/vt/v1/fqvtv1xelqwwshwtuxa3frztsle.jpeg"></a><br clear="left"><font style="vertical-align: inherit;"></font><br>
<br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="Software EDISON - desarrollo web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Software EDISON - desarrollo web"></a><br clear="right">
     EDISON.<br>
<br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    </a>,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   Android  iOS</a>.<br>
<br>
    ! ;-)</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La ordenación del montón en sí misma es muy buena, ya que su complejidad temporal es </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> independientemente de los datos. Para no representar una matriz, la complejidad del montón nunca se degrada a </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></b><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lo que puede suceder, por ejemplo, con una ordenación rápida. La otra cara de la moneda es que no se puede acelerar la clasificación por un montón binario, </font><font style="vertical-align: inherit;">tampoco se puede esperar </font><font style="vertical-align: inherit;">complejidad </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (pero la misma clasificación rápida, bajo ciertas condiciones, puede alcanzar tales indicadores). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, había una pregunta en la agenda: ¿es posible idear para que la complejidad temporal de la clasificación por un montón, por un lado, no sea inferior a</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero en un escenario favorable (en particular, si se procesa una matriz casi ordenada) aumenta a </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este problema fue abordado personalmente por el propio Edsger Dijkstra, quien descubrió que sí, es posible. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se supone que aquellos que leen este artículo entienden cómo funciona la clasificación por montón en general, saben qué es el árbol de clasificación y por qué se necesita un tamizado. </font><font style="vertical-align: inherit;">Si alguien tiene lagunas en este conocimiento, entonces antes de continuar leyendo, le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomiendo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">lea el artículo anterior</font></a><font style="vertical-align: inherit;"> .</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué tiene de malo un montón binario?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Echemos un vistazo a cómo ordena el montón una matriz casi ordenada y veamos por qué este algoritmo no procesa esos datos entrantes más rápido.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><div style="text-align:center;"><img width="646" height="303" src="https://habrastorage.org/webt/mr/x_/g9/mrx_g9exydmumk4rh-efffgvw_u.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haga clic en la animación para ir al artículo "Ordenar por una pirámide n".</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lo primero que llama la atención es que, al tamizar, los máximos se empujan constantemente a la raíz del montón, que corresponde al primer elemento de la matriz. Si la matriz de entrada está casi ordenada, entonces para el algoritmo esto solo agregará un poco de trabajo. Los elementos más pequeños aún irán primero por el árbol, es decir. acercarse al final de la matriz, no a su comienzo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo factor de desaceleración, que no es tan obvio, es que el montón binario estándar en sí mismo es siempre un árbol equilibrado. </font><font style="vertical-align: inherit;">En el caso de los datos inicialmente ordenados, esto juega un papel negativo. </font><font style="vertical-align: inherit;">Si hay datos aleatorios en la matriz original, se distribuyen uniformemente en un árbol equilibrado, y el cribado múltiple pasa por todas las ramas aproximadamente el mismo número de veces. </font><font style="vertical-align: inherit;">Para datos casi ordenados, es más preferible un árbol desequilibrado; en este caso, los datos en esa parte de la matriz que corresponden a ramas más largas del árbol se procesarán con menos frecuencia que otros.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leonardo números</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver ambos problemas, Dijkstra propuso usar montones binarios especiales basados ​​en números de Leonardo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los números de Leonardo son casi como los números de Fibonacci, pero solo mejores. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se da una serie recursiva de números de Leonardo: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los primeros 20 números de Leonardo: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1, 1, 3, 5, 9, 15, 25, 41, 67 , 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, 13529 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Absolutamente cualquier número entero puede representarse como la suma de los números de Leonardo que tienen diferentes números de serie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es muy útil en nuestro caso. Matriz de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">los elementos no siempre se pueden representar como un solo montón de Leonardo (si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no </font><b><font style="vertical-align: inherit;">es</font></b><font style="vertical-align: inherit;"> un número Leonardo). </font><font style="vertical-align: inherit;">Pero entonces, cualquier matriz siempre se puede dividir en varias submatrices que corresponderán a diferentes números de Leonardo, es decir. </font><font style="vertical-align: inherit;">ser montones de diferente orden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay un ejemplo de una matriz del elemento 21, que consta de tres montones de Leonard. </font><font style="vertical-align: inherit;">En cada uno de los montones, el número de nodos corresponde a cualquier número de Leonardo.</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="369" src="https://habrastorage.org/webt/-9/w7/1b/-9w71bwg0hst69nkbnewpiyku9m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puntos importantes a saber:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada pila de Leonardov es un árbol binario desequilibrado.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La raíz de cada montón es el último (y no el primero, como en un montón binario regular) del subarreglo correspondiente.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cualquier nodo con todos sus descendientes es también un montón de Leonard de menor orden.</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construye y desmonta montones</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la fórmula de recurrencia para los números de Leonardo, </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 está </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
muy satisfecho con la unidad al final. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y es por eso. Supongamos que tenemos dos submatrices adyacentes en la matriz que corresponden a montones construidos en dos números Leonardo adyacentes. Usando el elemento inmediatamente después de estas submatrices, estas submatrices se pueden combinar en un montón común, que corresponde al siguiente número de Leonard.</font></font><br>
<br>
<div style="text-align:center;"><img width="694" height="423" src="https://habrastorage.org/webt/ds/jv/5b/dsjv5bfc0ao4k9d-frevjzg3wee.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al revisar los elementos en la matriz, construimos un montón de montones de Leonard. Si usa el elemento, puede combinar los dos montones anteriores (esto es posible si y solo si los dos montones anteriores corresponden a dos números Leonardo consecutivos), entonces combine. Si la combinación no es posible (los dos montones anteriores no corresponden a dos números Leonardo consecutivos), entonces el elemento actual simplemente forma un nuevo montón de un elemento correspondiente al primer (o segundo, si el primero se usa antes) número Leonardo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la segunda etapa del algoritmo, se produce el proceso inverso: analizamos los montones. Si eliminamos la raíz en el montón, obtenemos dos montones más pequeños correspondientes a los dos números anteriores de Leonardo. Esto se puede hacer porque: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 1 = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En los números de Fibonacci no existe una unidad tan útil, por lo tanto, no utilizamos el montón de Fibonacci.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clasificación suave :: Smoothsort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El algoritmo final:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I. Cree un montón de montones de Leonard de la matriz, cada uno de los cuales es un árbol de clasificación.</font></font></b><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.1 </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterar sobre los elementos de la matriz de izquierda a derecha.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificamos si al usar el elemento actual es posible combinar los dos montones más a la izquierda en el montón de montones de Leonard existente:</font></font><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1.a. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En caso afirmativo, combinamos los dos montones más a la izquierda en uno, el elemento actual se convierte en la raíz de este montón, hacemos un tamiz para el montón combinado.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1.b. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De lo contrario, agregue el elemento actual como un nuevo montón (que consta de un nodo hasta ahora) al montón existente de montones de Leonard.</font></font></li>
</ul></li>
</ul></li>
<li><b>II.      ,       :</b><ul>
<li><b>II.1.</b>     .          ,      .</li>
<li><b>II.2.</b>   (     )       (     ).</li>
<li><b>II.3.</b>    ,         .     .</li>
<li><b>II.4.</b>      (    ),          .</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.5. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Después de mover el elemento máximo al final, la parte ordenada de la matriz aumentó y la parte no ordenada disminuyó. </font><font style="vertical-align: inherit;">Repita los pasos II.1-II.4 para la parte no ordenada restante de la matriz.</font></font></li>
</ul></li>
</ul><br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/wo/hc/ve/wohcve4fi78vdotmyfuw9pr2yyo.gif"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo de implementación de Python</font></font></h3><br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> random<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">smoothsort</span>(<span class="hljs-params">lst</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#    </span><font></font>
    leo_nums = leonardo_numbers(len(lst))<font></font>
<font></font>
<font></font>
    <span class="hljs-comment">#       </span><font></font>
    heap = []<font></font>
<font></font>
    <span class="hljs-comment">#   </span>
    <span class="hljs-comment">#       </span>
    <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(lst)):
        <span class="hljs-keyword">if</span> len(heap) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> heap[<span class="hljs-number">-2</span>] == heap[<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>:<font></font>
            heap.pop()<font></font>
            heap[<span class="hljs-number">-1</span>] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> len(heap) &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> heap[<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>:<font></font>
                heap.append(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">else</span>:<font></font>
                heap.append(<span class="hljs-number">1</span>)<font></font>
        restore_heap(lst, i, heap, leo_nums)<font></font>
<font></font>
    <span class="hljs-comment">#  </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> reversed(range(len(lst))):
        <span class="hljs-keyword">if</span> heap[<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">2</span>:<font></font>
            heap.pop()<font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            k = heap.pop()<font></font>
            t_r, k_r, t_l, k_l = get_child_trees(i, k, leo_nums)<font></font>
            heap.append(k_l)<font></font>
            restore_heap(lst, t_l, heap, leo_nums)<font></font>
            heap.append(k_r)<font></font>
            restore_heap(lst, t_r, heap, leo_nums)<font></font>
<font></font>
<span class="hljs-comment">#   ,     </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leonardo_numbers</span>(<span class="hljs-params">hi</span>):</span><font></font>
<font></font>
    a, b = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><font></font>
    numbers = []<font></font>
    <span class="hljs-keyword">while</span> a &lt;= hi:<font></font>
        numbers.append(a)<font></font>
        a, b = b, a + b + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> numbers<font></font>
<font></font>
<span class="hljs-comment">#        </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restore_heap</span>(<span class="hljs-params">lst, i, heap, leo_nums</span>):</span><font></font>
    <font></font>
    <span class="hljs-comment">#      </span><font></font>
    <font></font>
    current = len(heap) - <span class="hljs-number">1</span><font></font>
    k = heap[current]<font></font>
<font></font>
    <span class="hljs-keyword">while</span> current &gt; <span class="hljs-number">0</span>:<font></font>
        j = i - leo_nums[k]<font></font>
        <span class="hljs-keyword">if</span> (lst[j] &gt; lst[i] <span class="hljs-keyword">and</span>
            (k &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> lst[j] &gt; lst[i<span class="hljs-number">-1</span>] <span class="hljs-keyword">and</span> lst[j] &gt; lst[i<span class="hljs-number">-2</span>])):<font></font>
            lst[i], lst[j] = lst[j], lst[i]<font></font>
            i = j<font></font>
            current -= <span class="hljs-number">1</span><font></font>
            k = heap[current]<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span><font></font>
<font></font>
    <span class="hljs-comment"># </span><font></font>
    <font></font>
    <span class="hljs-keyword">while</span> k &gt;= <span class="hljs-number">2</span>:<font></font>
        t_r, k_r, t_l, k_l = get_child_trees(i, k, leo_nums)<font></font>
        <span class="hljs-keyword">if</span> lst[i] &lt; lst[t_r] <span class="hljs-keyword">or</span> lst[i] &lt; lst[t_l]:
            <span class="hljs-keyword">if</span> lst[t_r] &gt; lst[t_l]:<font></font>
                lst[i], lst[t_r] = lst[t_r], lst[i]<font></font>
                i, k = t_r, k_r<font></font>
            <span class="hljs-keyword">else</span>:<font></font>
                lst[i], lst[t_l] = lst[t_l], lst[i]<font></font>
                i, k = t_l, k_l<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span><font></font>
<font></font>
<span class="hljs-comment">#         ,</span>
<span class="hljs-comment">#     </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_child_trees</span>(<span class="hljs-params">i, k, leo_nums</span>):</span><font></font>
<font></font>
    t_r, k_r = i - <span class="hljs-number">1</span>, k - <span class="hljs-number">2</span>
    t_l, k_l = t_r - leo_nums[k_r], k - <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> t_r, k_r, t_l, k_l<font></font>
<font></font>
<span class="hljs-comment">#  </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">n</span>):</span><font></font>
    lst = list(range(n))<font></font>
    random.shuffle(lst)<font></font>
    print(lst)<font></font>
    smoothsort(lst)<font></font>
    print(lst)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complejidad de tiempo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si tomamos una matriz casi ordenada como entrada, entonces la visualización muestra por qué dicha matriz se procesa mucho más rápido.</font></font><br>
<br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/x1/g1/kg/x1g1kglflod3zdnc2vuiqumjoyy.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los ahorros se producen solo debido al tamizado. En datos casi ordenados, el tamizado se hunde poco profundo en el árbol, incluso después de que los montones se disuelven gradualmente en la segunda etapa. En los datos inicialmente aleatorios, el cribado es más costoso, ya que a menudo cae en su montón hasta el último nivel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos a estimar la complejidad del tiempo total. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la primera etapa, iteramos sobre n elementos, agregándolos a los montones que ya existen a la izquierda. Agregar al montón en sí mismo se omite en O (1), pero luego para el montón necesita hacer un tamiz. En los datos ordenados, un tamizado superficial a menudo cuesta O (1) para un elemento agregado al montón. En datos desordenados, el tamizado para cada adición se calcula en </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ya que como resultado de la aleatoriedad, el cribado tiene que pasar a través de los niveles de los árboles a menudo hasta el fondo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, en la primera etapa, la mejor complejidad temporal es: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
para datos casi ordenados - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
para datos aleatorios - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para la segunda etapa, la situación es similar. Al intercambiar el siguiente máximo, nuevamente necesita tamizar el montón en la raíz de la que era. Y las métricas de selección de datos ordenados y desordenados serán diferentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la segunda etapa, la mejor complejidad temporal es la misma que en la primera: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
para datos casi ordenados - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
para datos aleatorios - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregar complejidad de tiempo para la primera y segunda etapa: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
para datos casi ordenados - O (2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
para datos aleatorios - O (2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, la complejidad de tiempo peor y promedio para una ordenación suave es O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dijkstra en sus cálculos (con los que no te aburriré) demostró que la mejor complejidad </font><font style="vertical-align: inherit;">tiende </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suavemente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que la más ordenada de los datos entrantes. </font><font style="vertical-align: inherit;">De ahí el nombre: ordenación suave.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complejidad de memoria extra</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para descomponer los datos en un montón de montones de Leonard, solo necesita recordar exactamente qué números de Leonardo están involucrados en cada paso. </font><font style="vertical-align: inherit;">Conociendo estos números, los montones mismos están alineados algorítmicamente. </font><font style="vertical-align: inherit;">Esta serie de números crece muy rápidamente, por lo que incluso para matrices grandes necesitará un conjunto muy pequeño de números de Leonard.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clasificación del montón binomial :: Clasificación del montón binomial</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay una estructura de árbol, muy similar a la que resolvimos: un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">montón binomial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esto también es un montón de montones de diferentes tamaños, en cada uno de los cuales el número de nodos es una potencia de dos. </font><font style="vertical-align: inherit;">Cualquier conjunto de cualquier número de elementos puede expandirse en este montón, ya que cualquier número natural se descompone en la suma de dos de diferentes grados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En principio, puede hacer una ordenación suave basada en binomios:</font></font><br>
<br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/rw/p9/0y/rwp90yy_ub8vvvk2uczfoa4db8y.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Funcionará más rápido? </font><font style="vertical-align: inherit;">Apenas. </font><font style="vertical-align: inherit;">El montón binomial no es binario, y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el último artículo descubrimos que aumentar el número de descendientes no acelera, sino que ralentiza la pantalla</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Además, puede observar que el montón binomial tiene ramas más largas, por lo que las regiones ordenadas vecinas de la matriz serán un poco más lentas para conectarse entre sí. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No se sabe si el montón binomial de Dijkstra se consideró generalmente como una posible base para su algoritmo. </font><font style="vertical-align: inherit;">Sea como fuere, el montón de Leonardov es probablemente más óptimo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trailer de la próxima serie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, incluso si una pila binomial no es la mejor opción para una clasificación suave, no debe descartarla por completo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el árbol binomial está </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ligeramente modificado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y se usan ideas completamente diferentes (muy audaces) para rodearlo, entonces obtenemos un algoritmo original y efectivo que tiene sus propias ventajas. </font><font style="vertical-align: inherit;">¿De qué vamos a hablar la próxima vez?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/1l/ay/j-/1layj-xmzm4dl7p5yv7_5iag5pa.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haga clic en la animación para ir al artículo con la siguiente clasificación por montón.</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referencias</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El número liso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liso de </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leonardo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">montón </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">binomial</font></a><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">montón binomial</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artículos de la serie:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplicación Excel AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clases de intercambio</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clases de inserción</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordenar por selección</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clases de montón: N-Pirámides</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clases de montón: números de Leonardo</font></font></b></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo de montón: montón débil</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clases de racimos: árbol cartesiano</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otras clasificaciones de montón: montón de espejo, mini-montón, tamizado de abajo hacia arriba</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clases de montón: montón de Jung</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combinar clasificaciones</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordenar por distribución</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clasificación híbrida</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La ordenación suave de hoy se ha agregado a la aplicación AlgoLab. </font><font style="vertical-align: inherit;">Además de una bonificación, y ordenar con una pila binomial. </font><font style="vertical-align: inherit;">Entonces, ¿quién quiere manejar personalmente los datos en los montones de montón? Actualice el archivo Excel con macros.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es496840/index.html">Musk cree que 12 mil satélites no interferirán con los astrónomos. Su opinión no es consistente con el modelo.</a></li>
<li><a href="../es496842/index.html">Un modelo epidémico simple con herramientas básicas de Python.</a></li>
<li><a href="../es496846/index.html">Mecánica del lenguaje de pilas y punteros.</a></li>
<li><a href="../es496848/index.html">El resumen de materiales interesantes para el desarrollador móvil # 340 (del 6 al 12 de abril)</a></li>
<li><a href="../es496850/index.html">Complemento Maven para JPackage de Java 14</a></li>
<li><a href="../es496856/index.html">Hogar inteligente sin control remoto, pero con un cubo.</a></li>
<li><a href="../es496858/index.html">FOSS News No. 11: una revisión del software gratuito y de código abierto del 6 al 12 de abril de 2020</a></li>
<li><a href="../es496860/index.html">Primer DI: primer DI en interfaces para aplicaciones mecanografiadas</a></li>
<li><a href="../es496862/index.html">Arduino Bubble Display</a></li>
<li><a href="../es496868/index.html">Sinfonía espacial pequeña</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>