<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>㊙️ 👩🏼‍💼 🍻 3D lakukan sendiri. Bagian 1: piksel dan garis ☝🏼 👨🏿‍✈️ 🈯️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya ingin mencurahkan seri artikel ini untuk pembaca yang ingin menjelajahi dunia pemrograman 3D dari awal, kepada orang-orang yang ingin mempelajari...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>3D lakukan sendiri. Bagian 1: piksel dan garis</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/494094/"><img src="https://habrastorage.org/webt/-u/-n/6a/-u-n6axbw6fowganklzotzai0sk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin mencurahkan seri artikel ini untuk pembaca yang ingin menjelajahi dunia pemrograman 3D dari awal, kepada orang-orang yang ingin mempelajari dasar-dasar membuat komponen 3D dari permainan dan aplikasi. </font><font style="vertical-align: inherit;">Kami akan menerapkan setiap operasi dari awal untuk memahami setiap aspek, bahkan jika sudah ada fungsi siap pakai yang membuatnya lebih cepat. </font><font style="vertical-align: inherit;">Setelah belajar, kami akan beralih ke alat bawaan untuk bekerja dengan 3D. </font><font style="vertical-align: inherit;">Setelah membaca serangkaian artikel, Anda akan memahami cara membuat adegan tiga dimensi yang kompleks dengan cahaya, bayangan, tekstur dan efek, cara melakukan semua ini tanpa pengetahuan mendalam dalam matematika, dan banyak lagi. </font><font style="vertical-align: inherit;">Anda dapat melakukan semua ini baik secara mandiri maupun dengan bantuan alat yang sudah jadi.</font></font><br>
<a name="habracut"></a><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian pertama kami akan mempertimbangkan:</font></font><br>
</b><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsep rendering (perangkat lunak, perangkat keras)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa itu pixel / permukaan?</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis terperinci dari keluaran saluran</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar tidak membuang waktu berharga Anda membaca artikel, yang mungkin tidak bisa dipahami oleh orang yang tidak siap, saya akan segera beralih ke persyaratan. Anda dapat dengan aman mulai membaca artikel pada 3D, jika Anda tahu dasar-dasar pemrograman dalam bahasa apa pun, karena Saya hanya akan fokus pada studi pemrograman 3D, dan bukan pada studi fitur bahasa dan dasar-dasar pemrograman. Adapun persiapan matematika, Anda tidak perlu khawatir di sini, meskipun banyak yang tidak memiliki keinginan untuk belajar 3D, karena mereka takut dengan perhitungan yang rumit dan formula-formula murka karena itu mimpi buruk kemudian diimpikan, tetapi sebenarnya tidak ada yang perlu dikhawatirkan. Saya akan mencoba menjelaskan sejelas mungkin semua yang diperlukan untuk 3D, Anda hanya harus dapat melipatgandakan, membagi, menambah dan mengurangi. Jadi, jika Anda telah melewati kriteria seleksi, Anda dapat mulai membaca.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum mulai menjelajahi dunia 3D yang menarik, mari kita pilih bahasa pemrograman untuk contoh, serta lingkungan pengembangan. Bahasa apa yang harus saya pilih untuk pemrograman grafik 3D? Siapa pun, Anda dapat bekerja di mana Anda merasa paling nyaman, matematika akan sama di mana-mana. Dalam artikel ini, semua contoh akan ditampilkan dalam konteks JS (di sini tomat terbang ke saya). Mengapa js? Ini sederhana - akhir-akhir ini saya telah bekerja terutama dengannya, dan karena itu saya dapat lebih efektif menyampaikan esensi kepada Anda. Saya akan memotong semua fitur JS dalam contoh, karena kami hanya membutuhkan fitur paling dasar yang dimiliki bahasa apa pun, jadi kami akan memperhatikan 3D secara khusus. Tetapi Anda memilih apa yang Anda sukai, karena dalam artikel, semua rumus tidak akan terikat ke fitur bahasa pemrograman apa pun. Lingkungan mana yang harus dipilih? Tidak masalah,dalam kasus JS, editor teks apa pun cocok, Anda dapat menggunakan yang lebih dekat dengan Anda.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua contoh akan menggunakan kanvas untuk melukis dengan itu, Anda dapat mulai menggambar dengan sangat cepat, tanpa analisis rinci. Kanvas adalah alat yang ampuh, dengan banyak metode yang sudah jadi untuk menggambar, tetapi dari semua fitur-fiturnya, untuk pertama kalinya, kami hanya akan menggunakan keluaran piksel!&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua tampilan tiga dimensi di layar menggunakan piksel, kemudian di artikel Anda akan melihat bagaimana ini terjadi. Apakah akan melambat? Tanpa akselerasi perangkat keras (misalnya, akselerasi dengan kartu video) - akan terjadi. Pada artikel pertama, kami tidak akan menggunakan akselerasi, kami akan menulis semuanya dari awal untuk memahami aspek dasar 3D. Mari kita lihat beberapa istilah yang akan disebutkan di artikel mendatang:</font></font><br>
<br>
<ul>
<li><i> (Rendering)</i> —    3D-    . ,     3D-     ,        ,        .</li>
<li><i>  (Software Rendering) </i> —     .  ,  , ,    -  .       ,     .       3D-   ,    —  .</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hardware Rendering</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Proses rendering yang dibantu perangkat keras. </font><font style="vertical-align: inherit;">Saya menggunakannya game dan aplikasi. </font><font style="vertical-align: inherit;">Semuanya bekerja sangat cepat, karena </font><font style="vertical-align: inherit;">banyak komputasi rutin mengambil alih kartu video, yang dirancang untuk ini.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak bercita-cita untuk judul "definisi tahun" dan saya mencoba untuk menyatakan semua deskripsi istilah sejelas mungkin. </font><font style="vertical-align: inherit;">Hal utama adalah memahami ide, yang kemudian dapat dikembangkan secara mandiri. </font><font style="vertical-align: inherit;">Saya juga ingin menarik perhatian pada kenyataan bahwa semua contoh kode yang akan ditampilkan dalam artikel sering tidak dioptimalkan untuk kecepatan, untuk menjaga kemudahan pemahaman. </font><font style="vertical-align: inherit;">Ketika Anda memahami hal utama - bagaimana grafik 3D bekerja, Anda dapat mengoptimalkan semuanya sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, buat proyek, bagi saya itu hanya </font><font style="vertical-align: inherit;">file </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">text.html</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> teks </font><font style="vertical-align: inherit;">, dengan konten berikut:</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>3D it’s easy. Part 1<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">&lt;!--         --&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"surface"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"800"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"600"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//    </span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak akan terlalu fokus pada JS dan kanvas sekarang - ini bukan karakter utama dari artikel ini. </font><font style="vertical-align: inherit;">Tetapi untuk pemahaman umum, saya akan mengklarifikasi bahwa &lt;canvas ...&gt; adalah sebuah persegi panjang (dalam kasus saya, berukuran 800 x 600 piksel) di mana saya akan menampilkan semua gambar. </font><font style="vertical-align: inherit;">Saya mendaftar kanvas sekali dan tidak akan mengubahnya lagi.</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span> … <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&nbsp;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Script - elemen di mana kita akan menulis semua logika untuk rendering grafik 3D dengan tangan kita sendiri (dalam JavaScript).&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kami baru saja meninjau struktur file </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index.html</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari proyek yang </font><font style="vertical-align: inherit;">baru dibuat, kami akan mulai berurusan dengan grafik 3D.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kita menggambar sesuatu di jendela, ini dalam hitungan akhir berubah menjadi piksel, karena monitor itulah yang ditampilkan. Semakin banyak piksel, semakin tajam gambarnya, tetapi komputer juga memuat lebih banyak. Bagaimana cara kita menggambar di jendela yang disimpan? Grafik di jendela apa pun dapat direpresentasikan sebagai larik piksel, dan piksel itu sendiri hanyalah warna. Artinya, resolusi layar 800x600 berarti bahwa jendela kita masing-masing berisi 600 baris 800 piksel, yaitu 800 * 600 = 480000 piksel, banyak, bukan? Pixel disimpan dalam array. Mari kita pikirkan di array mana kita akan menyimpan piksel. Jika kita harus memiliki 800 x 600 piksel, maka opsi yang paling jelas adalah dalam array dua dimensi dari 800 x 600. Dan ini hampir merupakan opsi yang tepat, atau lebih tepatnya, opsi yang sepenuhnya benar. Tetapi piksel jendela, lebih baik untuk menyimpan dalam array satu dimensi dari 480.000 elemen (jika resolusinya adalah 800 oleh 600),hanya karena lebih cepat bekerja dengan array satu dimensi, karena itu disimpan dalam memori dalam urutan byte yang berkelanjutan (semuanya terletak di dekatnya dan karena itu mudah untuk mendapatkannya). Dalam array dua dimensi (misalnya, dalam kasus JS), setiap baris dapat tersebar di berbagai tempat dalam memori, sehingga mengakses elemen-elemen dari array tersebut akan memakan waktu lebih lama. Juga, untuk beralih pada array satu dimensi, hanya diperlukan 1 siklus, dan untuk bilangan bulat dua dimensi 2, mengingat perlunya melakukan puluhan ribu iterasi siklus, kecepatan sangat penting di sini. Apa itu pixel dalam array seperti itu? Seperti disebutkan di atas - ini hanya warna, atau lebih tepatnya 3 komponennya (merah, hijau, biru). Apa pun, bahkan gambar paling berwarna hanyalah serangkaian piksel warna berbeda. Sebuah piksel dalam memori dapat disimpan sesuka Anda, baik array 3 elemen, atau dalam struktur di mana merah, biru,biru; atau sesuatu yang lain. Gambar yang terdiri dari array piksel yang baru saja kita uraikan, saya akan terus memanggil permukaan. Ternyata karena semua yang ditampilkan di layar disimpan dalam array piksel, maka perubahan elemen (piksel) dalam array ini - kami akan mengubah piksel demi piksel gambar di layar. Inilah yang akan kita lakukan di artikel ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada fungsi menggambar piksel di kanvas, tetapi dimungkinkan untuk mengakses array piksel satu dimensi, yang kita bahas di atas. </font><font style="vertical-align: inherit;">Cara melakukannya ditunjukkan dalam contoh di bawah ini (ini dan semua contoh di masa depan hanya akan berada di dalam elemen skrip):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     ()    </span>
<span class="hljs-keyword">const</span> ctx = <span class="hljs-built_in">document</span>
.getElementById(<span class="hljs-string">'surface'</span>)<font></font>
.getContext(<span class="hljs-string">'2d'</span>)<font></font>
<font></font>
<span class="hljs-comment">//     ,   &nbsp;</span>
<span class="hljs-comment">// +       </span>
<span class="hljs-keyword">const</span> imageData = ctx.createImageData(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh, imageData adalah objek di mana ada 3 properti:</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tinggi dan lebar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - bilangan bulat menyimpan tinggi dan lebar jendela untuk menggambar</font></font><br>
</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - array integer tanpa tanda 8-bit (Anda dapat menyimpan angka dalam rentang dari 0 hingga 255 di dalamnya)</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Array data memiliki struktur yang sederhana namun jelas. </font><font style="vertical-align: inherit;">Array satu dimensi ini menyimpan data setiap piksel, yang akan kami tampilkan di layar dalam format berikut:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4 elemen pertama array (indeks 0,1,2,3) adalah data piksel pertama di baris pertama. 4 elemen kedua (indeks 4, 5, 6, 7) adalah data piksel kedua dari baris pertama. Ketika kita sampai pada pixel ke 800 dari baris pertama, asalkan jendelanya selebar 800 pixel - pixel ke 801 sudah menjadi milik baris kedua. Jika kita mengubahnya, di layar kita akan melihat bahwa piksel ke-1 dari baris ke-2 telah berubah (meskipun menurut hitungan dalam array, itu akan menjadi piksel ke-801). Mengapa ada 4 elemen untuk setiap piksel dalam array? Ini karena di kanvas, selain mengalokasikan 1 elemen untuk setiap warna - merah, hijau, biru (ini adalah 3 elemen), 1 elemen lagi untuk transparansi (mereka juga mengatakan saluran alpha atau opacity). Saluran alfa, seperti warna, diatur dalam kisaran dari 0 (transparan) hingga 255 (buram). Dengan struktur ini, kita mendapatkan gambar 32-bit,karena setiap pixel terdiri dari 4 elemen 8 bit. Untuk meringkas: setiap piksel berisi: warna merah, hijau, biru dan saluran alfa (transparansi). Skema warna ini disebut ARGB (Alpha Red Green Blue). Dan fakta bahwa setiap piksel menempati 32 bit mengatakan bahwa kita memiliki gambar 32 bit (mereka juga mengatakan gambar dengan kedalaman warna 32 bit).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara default, seluruh array piksel imageData.data (data adalah properti di mana array piksel, dan imageData hanya sebuah objek) diisi dengan nilai 0, dan jika kami mencoba menampilkan array seperti itu, kami tidak akan melihat sesuatu yang menarik di layar, karena 0 , 0, 0 berwarna hitam, tetapi karena transparansi di sini juga akan 0, dan ini adalah warna yang benar-benar transparan, kami bahkan tidak akan melihat warna hitam di layar!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sangat tidak nyaman untuk bekerja secara langsung dengan array satu dimensi seperti itu, jadi kita akan menulis kelas untuk itu di mana kita akan membuat metode untuk menggambar. Saya akan beri nama kelas - Laci. Kelas ini hanya akan menyimpan data yang diperlukan dan melakukan perhitungan yang diperlukan, mengabstraksi sebanyak mungkin dari alat yang digunakan untuk rendering. Itu sebabnya kami akan menempatkan semua perhitungan dan bekerja dengan array di dalamnya. Dan panggilan untuk metode tampilan di kanvas, kita akan menempatkan di luar kelas, karena mungkin ada sesuatu yang lain, bukan kanvas. Dalam hal ini, kelas kita tidak perlu diubah. Untuk bekerja dengan array piksel (permukaan), lebih mudah bagi kita untuk menyimpannya di kelas Drawer, serta lebar dan tinggi gambar, sehingga kita dapat mengakses piksel yang diinginkan dengan benar. Jadi, kelas Drawer, sambil menjaga data minimum yang diperlukan untuk menggambar, terlihat seperti ini untukku:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Drawer</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;surface = <span class="hljs-literal">null</span>
&nbsp;&nbsp;&nbsp;&nbsp;width = <span class="hljs-number">0</span>
&nbsp;&nbsp;&nbsp;&nbsp;height = <span class="hljs-number">0</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(surface, width, height) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface = surface
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.width = width
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.height = height<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat di konstruktor, kelas Drawer mengambil semua data yang diperlukan dan menyimpannya. </font><font style="vertical-align: inherit;">Sekarang Anda dapat membuat instance kelas ini dan mengirimkan array piksel, lebar, dan tinggi ke dalamnya (kami sudah memiliki semua data ini, karena kami membuatnya di atas dan menyimpannya di imageData):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> drawer = <span class="hljs-keyword">new</span> Drawer(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.data,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.width,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.height<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di kelas Drawer, kita akan menulis beberapa fungsi menggambar, untuk memudahkan pekerjaan di masa depan. </font><font style="vertical-align: inherit;">Kami akan memiliki fungsi untuk menggambar piksel, fungsi untuk menggambar garis, dan dalam artikel selanjutnya fungsi untuk menggambar segitiga dan bentuk lainnya akan muncul. </font><font style="vertical-align: inherit;">Tapi mari kita mulai dengan metode menggambar piksel. </font><font style="vertical-align: inherit;">Saya akan memanggilnya drawPixel. </font><font style="vertical-align: inherit;">Jika kita menggambar piksel, maka itu harus memiliki koordinat, serta warna:</font></font><br>
<br>
<pre><code class="javascript hljs">drawPixel(x, y, r, g, b)&nbsp; { }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harap dicatat bahwa fungsi drawPixel tidak menerima parameter alfa (transparansi), dan di atas kami menemukan bahwa susunan piksel terdiri dari 3 parameter warna dan 1 parameter transparansi. Saya tidak secara khusus menunjukkan transparansi, karena kami benar-benar tidak membutuhkannya sebagai contoh. Secara default, kami akan menetapkan 255 (mis. Semuanya akan menjadi buram). Sekarang mari kita pikirkan tentang bagaimana menulis warna yang diinginkan ke dalam array piksel dalam koordinat x, y. Karena kami memiliki semua informasi tentang gambar disimpan dalam array satu dimensi, di mana 1 piksel (8 bit) dialokasikan untuk setiap piksel. Untuk mengakses piksel yang diinginkan dalam array, pertama-tama kita perlu menentukan indeks lokasi merah, karena setiap piksel dimulai dengan itu (misalnya [r, g, b, a]). Sedikit penjelasan tentang struktur array:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uz/4j/8o/uz4j8olujyuhzo3z1anuexucnoc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tabel berwarna hijau menunjukkan bagaimana komponen warna disimpan dalam array permukaan satu dimensi. Indeks mereka dalam array yang sama ditunjukkan dengan warna biru, dan koordinat piksel yang menerima fungsi drawPixel, yang perlu kita konversi menjadi indeks dalam array satu dimensi, menunjukkan r, g, b, a untuk piksel berwarna biru. Jadi, dari tabel dapat dilihat bahwa untuk setiap piksel komponen warna merah yang lebih dulu, mari kita mulai dengan itu. Misalkan kita ingin mengubah komponen merah dari warna piksel dalam koordinat X1Y1 dengan ukuran gambar 2 kali 2 piksel. Dalam tabel kita melihat bahwa ini adalah indeks 12, tetapi bagaimana cara menghitungnya? Pertama kita menemukan indeks dari baris yang kita butuhkan, untuk ini kita mengalikan lebar gambar dengan Y dan dengan 4 (jumlah nilai per piksel) - ini akan menjadi:</font></font><br>
<br>
<pre><code class="plaintext hljs">width * y * 4 <font></font>
//  :<font></font>
2 * 1 * 4 = 8</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita melihat bahwa baris ke-2 dimulai dengan indeks 8. Jika kita bandingkan dengan plat, hasilnya konvergen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang Anda perlu menambahkan kolom offset ke indeks baris yang ditemukan untuk mendapatkan indeks merah yang diinginkan. </font><font style="vertical-align: inherit;">Untuk melakukan ini, tambahkan X kali 4 ke indeks baris. Rumus lengkapnya adalah:</font></font><br>
<br>
<pre><code class="plaintext hljs">width * y * 4 + x * 4 <font></font>
//     :<font></font>
(width * y + x) * 4<font></font>
//  :<font></font>
(2 * 1 + 1) * 4 = 12</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita membandingkan 12 dengan tabel dan melihat bahwa piksel X1Y1 benar-benar dimulai dengan indeks 12. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menemukan indeks komponen warna lainnya, Anda perlu menambahkan offset warna ke indeks merah: +1 (hijau), +2 (biru), +3 (alpha) . </font><font style="vertical-align: inherit;">Sekarang kita bisa menerapkan metode drawPixel di dalam kelas Drawer menggunakan rumus di atas:</font></font><br>
<br>
<pre><code class="javascript hljs">drawPixel(x, y, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> offset = (<span class="hljs-keyword">this</span>.width * y + x) * <span class="hljs-number">4</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset] = r
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">1</span>] = g
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">2</span>] = b
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">3</span>] = <span class="hljs-number">255</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam metode drawPixel ini, saya merender bagian berulang rumus ke konstanta offset. Juga terlihat bahwa dalam alpha saya hanya menulis 255, karena itu dalam struktur, tetapi sekarang kita tidak perlu untuk menghasilkan piksel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sudah waktunya untuk menguji kode dan akhirnya melihat piksel pertama di layar. Berikut adalah contoh menggunakan metode render piksel:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     Drawer</span>
drawer.drawPixel(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
drawer.drawPixel(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
<font></font>
<span class="hljs-comment">//         canvas</span>
ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh di atas, saya menggambar 2 piksel, satu merah 255, 0, 0, biru lainnya 0, 0, 255. Tetapi perubahan dalam array imageData.data (juga merupakan permukaan di dalam kelas Drawer) tidak akan muncul di layar. Untuk menggambar, Anda perlu memanggil ctx.putImageData (imageData, 0, 0), di mana imageData adalah objek di mana array piksel dan lebar / tinggi area gambar, dan 0, 0 adalah titik relatif di mana array piksel akan ditampilkan (selalu meninggalkan 0, 0 ) Jika Anda melakukan semuanya dengan benar, maka Anda akan memiliki gambar berikut di kiri atas elemen kanvas di jendela browser: Apakah Anda melihat </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d8/xn/cz/d8xnczchpgfg-9amhgdlyrpvzma.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
piksel? Mereka sangat kecil, dan berapa banyak pekerjaan yang telah dilakukan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita coba menambahkan sedikit dinamika pada contoh, misalnya, sehingga setiap 10 milidetik piksel kami bergeser ke kanan (kami akan mengubah piksel X dengan +1 setiap 10 milidetik), kami akan memperbaiki kode gambar piksel satu per satu pada suatu interval:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>
setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.drawPixel(x++, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
<font></font>
}, <span class="hljs-number">10</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh ini, saya hanya menyisakan output dari piksel biru dan membungkus fungsi setInterval dengan parameter 10 dalam JavaScript. Ini berarti bahwa kode akan dipanggil kira-kira setiap 10 milidetik. Jika Anda menjalankan contoh seperti itu, Anda akan melihat bahwa alih-alih piksel bergeser ke kanan, Anda akan memiliki sesuatu seperti ini: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8o/0v/uu/8o0vuuurtmmqgu8uy7sufdka16o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Potongan panjang (atau jejak) tersebut tetap ada karena kami tidak menghapus warna piksel sebelumnya dalam susunan permukaan, jadi dengan setiap pemanggilan interval, kami juga menambahkan satu piksel. Mari kita menulis metode yang akan membersihkan permukaan ke keadaan semula. Dengan kata lain, isi array dengan nol. Tambahkan metode clearSurface ke kelas Drawer:</font></font><br>
<br>
<pre><code class="javascript hljs">clearSurface() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> surfaceSize = <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height * <span class="hljs-number">4</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; surfaceSize; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[i] = <span class="hljs-number">0</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada logika dalam array ini, hanya diisi dengan nol. </font><font style="vertical-align: inherit;">Anda disarankan untuk memanggil metode ini setiap kali sebelum menggambar gambar baru. </font><font style="vertical-align: inherit;">Dalam hal animasi piksel, sebelum menggambar piksel ini:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>
setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.clearSurface()<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.drawPixel(x++, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
}, <span class="hljs-number">10</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang jika Anda menjalankan contoh ini, piksel akan bergeser ke kanan, satu per satu - tanpa jejak yang tidak perlu dari koordinat sebelumnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal terakhir yang kami terapkan dalam artikel pertama adalah metode menggambar garis. </font><font style="vertical-align: inherit;">Tambahkan, tentu saja, ke kelas Drawer. </font><font style="vertical-align: inherit;">Metode yang saya sebut drawLine. </font><font style="vertical-align: inherit;">Apa yang akan dia ambil? </font><font style="vertical-align: inherit;">Tidak seperti titik, garis masih memiliki koordinat di mana ia berakhir. </font><font style="vertical-align: inherit;">Dengan kata lain, garis memiliki awal, akhir dan warna, yang akan kita sampaikan ke metode:</font></font><br>
<br>
<pre><code class="javascript hljs">drawLine(x1, y1, x2, y2, r, g, b) { }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baris apa pun terdiri dari piksel, hanya tinggal mengisinya dengan benar dari piksel x1, y1 ke x2, y2. Untuk memulainya, karena garis terdiri dari piksel, maka kita akan menampilkannya piksel demi piksel dalam lingkaran, tetapi bagaimana cara menghitung berapa piksel yang akan dihasilkan? Misalnya, untuk menggambar garis dari [0, 0] hingga [3, 0] secara intuitif jelas bahwa Anda memerlukan 4 piksel ([0, 0], [1, 0], [2, 0], [3, 0],) . Tetapi dari [12, 6] hingga [43, 14], belum jelas berapa lama garis itu akan (berapa banyak piksel untuk ditampilkan) dan koordinat apa yang akan mereka miliki. Untuk melakukan ini, ingat geometri kecil. Jadi, kita memiliki garis yang dimulai pada x1, y1 dan berakhir di x2, y2.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/z7/ip/ouz7ipd2uiokmmijlro7wldayzw.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita menggambar garis putus-putus dari awal dan akhir sehingga kita mendapatkan segitiga (gambar di atas). </font><font style="vertical-align: inherit;">Kita akan melihat bahwa di persimpangan garis yang ditarik, sudut 90 derajat telah terbentuk. </font><font style="vertical-align: inherit;">Jika segitiga memiliki sudut seperti itu, maka segitiga disebut segi empat, dan sisi-sisinya, di antaranya sudut 90 derajat, disebut kaki. </font><font style="vertical-align: inherit;">Garis solid ketiga (yang kami coba gambar) disebut hypotenuse in a triangle. </font><font style="vertical-align: inherit;">Dengan menggunakan kedua kaki yang diperkenalkan ini (c1 dan c2 pada gambar), kita dapat menghitung panjang sisi miring menggunakan teorema Pythagoras. </font><font style="vertical-align: inherit;">Mari kita lihat bagaimana melakukannya. </font><font style="vertical-align: inherit;">Rumus untuk panjang sisi miring (atau panjang garis) adalah sebagai berikut:&nbsp;</font></font><br>
<p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x433;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x438;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43F;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43E;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43D;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x443;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x437;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mo>=</mo><msqrt><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43A;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43A;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><msup><mn>2</mn><mn>2</mn></msup></msqrt></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="31.778ex" height="4.759ex" viewBox="0 -1401.3 13682.2 2049.1" role="img" focusable="false" style="vertical-align: -1.505ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text><g transform="translate(376,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(861,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1345,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1776,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(2152,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(2535,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3019,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3450,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3790,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhgRt_3NkvzfAI1-vplKu4GjFDEoOw#MJMAIN-3D" x="4499" y="0"></use><g transform="translate(5555,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhgRt_3NkvzfAI1-vplKu4GjFDEoOw#MJSZ2-221A" x="0" y="87"></use><rect stroke="none" width="7126" height="60" x="1000" y="1178"></rect><g transform="translate(1000,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text><g transform="translate(430,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(861,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1237,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1620,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1997,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhgRt_3NkvzfAI1-vplKu4GjFDEoOw#MJMAIN-31" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhgRt_3NkvzfAI1-vplKu4GjFDEoOw#MJMAIN-32" x="707" y="583"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhgRt_3NkvzfAI1-vplKu4GjFDEoOw#MJMAIN-2B" x="3173" y="0"></use><g transform="translate(4174,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(4605,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5035,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5412,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5795,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(6171,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhgRt_3NkvzfAI1-vplKu4GjFDEoOw#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhgRt_3NkvzfAI1-vplKu4GjFDEoOw#MJMAIN-32" x="707" y="583"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mo>=</mo><msqrt><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><msup><mn>2</mn><mn>2</mn></msup></msqrt></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> = \sqrt{1^2 + 2^2}</script></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cara mendapatkan kedua kaki juga dilihat dari segi tiga. </font><font style="vertical-align: inherit;">Sekarang, menggunakan rumus di atas, kami menemukan sisi miring, yang akan menjadi garis panjang (jumlah piksel):</font></font><br>
<br>
<pre><code class="javascript hljs">&nbsp;drawLine(x1, y1, x2, y2, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c1 = y2 - y1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita sudah tahu berapa banyak piksel untuk menggambar untuk menggambar garis. Namun kami belum tahu bagaimana cara menggeser piksel. Artinya, kita perlu menggambar garis dari x1, y1 ke x2, y2, kita tahu bahwa panjang garis akan, misalnya, 20 piksel. Kita dapat menggambar piksel pertama dalam x1, y1 dan yang terakhir dalam x2, y2, tetapi bagaimana cara menemukan koordinat piksel menengah? Untuk melakukan ini, kita perlu mendapatkan cara menggeser setiap piksel berikutnya sehubungan dengan x1, y1 untuk mendapatkan garis yang diinginkan. Saya akan memberikan satu contoh lagi untuk lebih memahami perpindahan seperti apa yang sedang kita bicarakan. Kami memiliki poin [0, 0] dan [0, 3], kita perlu menggambar garis pada mereka. Dari contoh tersebut terlihat dengan jelas bahwa titik berikutnya setelah [0, 0] adalah [0, 1], dan kemudian [0, 2] dan akhirnya [0, 3]. Artinya, X dari setiap titik tidak bergeser, baik, atau kita dapat mengatakan bahwa itu digeser oleh 0 piksel, dan Y digeser oleh 1 piksel, ini adalah offset,dapat ditulis sebagai [0, 1]. Contoh lain: kita memiliki titik [0, 0] dan titik [3, 6], mari kita coba hitung dalam pikiran kita bagaimana mereka berubah, yang pertama adalah [0, 0], lalu [0,5, 1], lalu [1, 2] kemudian [1,5, 3] dan seterusnya ke [3, 6], dalam contoh ini offsetnya adalah [0,5, 1]. Bagaimana cara menghitungnya?&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat menggunakan rumus berikut:</font></font><br>
<br>
<pre><code class="javascript hljs">   = <span class="hljs-number">2</span> /  <font></font>
  Y = <span class="hljs-number">1</span> /  &nbsp;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kode program, kita akan memiliki ini:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> xStep = c2 / length
<span class="hljs-keyword">const</span> yStep = c1 / length</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua data sudah ada di sana: panjang garis, offset piksel sepanjang X dan Y. Kita mulai dalam siklus untuk menggambar:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.drawPixel(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r, g, b,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai koordinat X dari fungsi Pixel, kami melewatkan awal garis X + mengimbangi X * i, dengan demikian, mendapatkan koordinat piksel ke-i, kami juga menghitung koordinat Y. Math.trunc adalah metode dalam JS yang memungkinkan Anda membuang bagian fraksional dari suatu bilangan. </font><font style="vertical-align: inherit;">Seluruh kode metode terlihat seperti ini:</font></font><br>
<br>
<pre><code class="javascript hljs">drawLine(x1, y1, x2, y2, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c1 = y2 - y1
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> xStep = c2 / length
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> yStep = c1 / length<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.drawPixel(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r, g, b,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagian pertama telah berakhir, sebuah jalan panjang namun menarik untuk memahami dunia 3D. </font><font style="vertical-align: inherit;">Belum ada yang tiga dimensi, tetapi kami melakukan operasi persiapan untuk menggambar: kami menerapkan fungsi menggambar pixel, garis, membersihkan jendela dan belajar beberapa istilah. </font><font style="vertical-align: inherit;">Semua kode kelas Drawer dapat dilihat di bawah spoiler:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode kelas laci</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Drawer</span> </span>{<font></font>
  surface = <span class="hljs-literal">null</span>
  width = <span class="hljs-number">0</span>
  height = <span class="hljs-number">0</span><font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(surface, width, height) {
    <span class="hljs-keyword">this</span>.surface = surface
    <span class="hljs-keyword">this</span>.width = width
    <span class="hljs-keyword">this</span>.height = height<font></font>
  }<font></font>
<font></font>
  drawPixel(x, y, r, g, b)  {<font></font>
    <span class="hljs-keyword">const</span> offset = (<span class="hljs-keyword">this</span>.width * y + x) * <span class="hljs-number">4</span><font></font>
<font></font>
    <span class="hljs-keyword">this</span>.surface[offset] = r
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">1</span>] = g
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">2</span>] = b
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">3</span>] = <span class="hljs-number">255</span><font></font>
  }<font></font>
<font></font>
  drawLine(x1, y1, x2, y2, r, g, b) {<font></font>
    <span class="hljs-keyword">const</span> c1 = y2 - y1
    <span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
    <span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)<font></font>
<font></font>
    <span class="hljs-keyword">const</span> xStep = c2 / length
    <span class="hljs-keyword">const</span> yStep = c1 / length<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; length ; i++) {
        <span class="hljs-keyword">this</span>.drawPixel(
          <span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
          <span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
          r, g, b,<font></font>
        )<font></font>
    }<font></font>
  }<font></font>
<font></font>
  clearSurface() {<font></font>
    <span class="hljs-keyword">const</span> surfaceSize = <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height * <span class="hljs-number">4</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; surfaceSize; i++) {
      <span class="hljs-keyword">this</span>.surface[i] = <span class="hljs-number">0</span><font></font>
    }<font></font>
  }<font></font>
}<font></font>
</code></pre></div></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa berikutnya?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada artikel selanjutnya, kita akan melihat bagaimana operasi sederhana seperti output dari pixel dan garis dapat berubah menjadi objek 3D yang menarik. </font><font style="vertical-align: inherit;">Kami akan berkenalan dengan matriks dan operasi pada mereka, menampilkan objek tiga dimensi di jendela dan bahkan menambahkan animasi.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id494076/index.html">Analisis: strategi perilaku investor selama crash pasar saham</a></li>
<li><a href="../id494082/index.html">Dalenka: artikel paling berguna tentang kerja efektif dari rumah</a></li>
<li><a href="../id494084/index.html">Coronavirus: layanan informasi online</a></li>
<li><a href="../id494090/index.html">Throttling seledri - menetapkan batas laju antrian</a></li>
<li><a href="../id494092/index.html">Degradasi struktur yang terhubung</a></li>
<li><a href="../id494096/index.html">Penggunaan intranet. Pengalaman, kesalahan, rekomendasi</a></li>
<li><a href="../id494098/index.html">Pendekatan imperatif terhadap data reaktif pada contoh Jetbrains KTor dan R2DBC</a></li>
<li><a href="../id494100/index.html">Apa yang Anda butuhkan untuk membuat model ideal pusat pendidikan untuk melatih spesialis IT</a></li>
<li><a href="../id494114/index.html">Cara mengurangi angka dan meningkatkan pembacaan kode di react-redux, redux-saga</a></li>
<li><a href="../id494118/index.html">COVID-19 Telegram-bot // Kami menjawab pertanyaan FAQ secara otomatis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>