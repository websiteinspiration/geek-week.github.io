<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏻 📃 🙎 引擎盖下飘动 🥊 🐩 ♒️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！我叫Mikhail Zotiev，我是Surf的Flutter开发人员。我和大多数使用Flutter的开发人员一样，大多数人都喜欢在它的帮助下创建美观，便捷的应用程序如此容易。只需很少的时间即可进入Flutter开发。我最近从事游戏开发，现在我已经完全转向Flutter上的跨平台移动开发。
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>引擎盖下飘动</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/501862/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大家好！我叫Mikhail Zotiev，我是Surf的Flutter开发人员。我和大多数使用Flutter的开发人员一样，大多数人都喜欢在它的帮助下创建美观，便捷的应用程序如此容易。只需很少的时间即可进入Flutter开发。我最近从事游戏开发，现在我已经完全转向Flutter上的跨平台移动开发。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简单是什么？</font><font style="vertical-align: inherit;">借助许多基本的小部件，您可以构建相当不错的用户界面。</font><font style="vertical-align: inherit;">随着时间的流逝，当所使用的行李相当不错时，某种任务不太可能使您处于停顿状态：是不寻常的设计还是精美的动画。</font><font style="vertical-align: inherit;">最有趣的是-您甚至可能不用考虑以下问题就可以使用它：“它怎么工作？” </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于Flutter具有开源功能，因此我决定弄清楚幕后情况（在部队的Dart方面），并与您分享。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/ln/q6/lglnq6t8sbc8gq-emifhx1dxjwu.png"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小部件</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们所有人都多次听到过框架开发团队的说法：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ Flutter中的一切都是小部件</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">” </font></i><font style="vertical-align: inherit;">让我们看看是否真的是这样。</font><font style="vertical-align: inherit;">为此，我们转到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">（以下简称Widget），开始逐渐熟悉其内容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将在该类文档中阅读的第一件事：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述[元素]的配置。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实证明，小部件本身只是对某些</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Element</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（以下简称-element）的描述。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小部件是Flutter框架中的中心类层次结构。</font><font style="vertical-align: inherit;">小部件是用户界面一部分的不变描述。</font><font style="vertical-align: inherit;">可以将小部件放大为元素，以管理基础渲染树。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总而言之，短语</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ Flutter中的所有内容都是小部件”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是了解如何使用Flutter安排所有内容的最低级别。</font><font style="vertical-align: inherit;">小部件是Flutter层次结构中的中心类。</font><font style="vertical-align: inherit;">同时，围绕它的许多其他机制可以帮助框架完成其任务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们了解了更多事实：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小部件-用户界面一部分的不变描述；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小部件与称为元素的某些高级视图相关联； </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素控制渲染树的某些实体。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您一定注意到了一件奇怪的事。</font><font style="vertical-align: inherit;">用户界面和不变性很难很好地融合在一起，我什至可以说它们是完全不兼容的概念。</font><font style="vertical-align: inherit;">但是，当出现有关Flutter世界的设备的更完整图片时，我们将返回到这一点，但是现在，我们将继续熟悉该小部件的文档。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">窗口小部件本身没有可变状态（它们的所有字段都必须为final）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果希望将可变状态与窗口小部件相关联，请考虑使用[StatefulWidget]，该状态会在膨胀为一个元素并合并到树中时创建一个[State]对象（通过[StatefulWidget.createState]）。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本段对第一段进行了补充：如果我们需要可变的配置，则使用特殊的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实体</font><font style="vertical-align: inherit;">（以下称为state），它描述了此小部件的当前状态。</font><font style="vertical-align: inherit;">但是，状态不与窗口小部件关联，而是与其基本表示形式关联。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定的小部件可以零次或多次包含在树中。</font><font style="vertical-align: inherit;">特别地，给定的小部件可以多次放置在树中。</font><font style="vertical-align: inherit;">每次将小部件放置在树中时，它都会膨胀为[Element]，这意味着多次合并到树中的小部件将被多次膨胀。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同的窗口小部件可以多次包含在窗口小部件树中，或者根本不包含。</font><font style="vertical-align: inherit;">但是，每当窗口小部件树中包含窗口小部件时，就会将一个元素映射到该窗口小部件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，在此阶段，小部件几乎完成了，让我们总结一下：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小部件-层次结构的中心类；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小部件是一些配置； </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小部件-用户界面一部分的不变描述； </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小部件与以某种方式控制渲染的元素相关联； </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小部件的更改状态可以由某些实体描述，但它与小部件无关，但与代表此小部件的元素有关。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元件</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从我们学到的问题开始，问题开始了：“这些因素支配着一切？” </font><font style="vertical-align: inherit;">进行相同操作-打开Element类的文档。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">树中特定位置的[Widget]的实例化。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素是小部件在树中特定位置的某种表示形式。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">窗口小部件描述了如何配置子树，但是由于窗口小部件是不可变的，因此可以使用同一窗口小部件同时配置多个子树。</font><font style="vertical-align: inherit;">[Element]表示使用小部件来配置树中的特定位置。</font><font style="vertical-align: inherit;">随着时间的流逝，与给定元素关联的窗口小部件可以更改，例如，如果父窗口小部件为该位置重建并创建了一个新窗口小部件。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该小部件描述了用户界面的某些部分的配置，但是我们已经知道，同一小部件​​可以在树的不同位置使用。每个这样的地方将由相应的元素表示。但是随着时间的流逝，与该项目关联的窗口小部件可能会更改。这意味着元素更加顽强并且继续使用，仅更新它们的连接。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个相当合理的决定。正如我们在上面已经定义的那样，小部件是一个不变的配置，仅描述了接口的特定部分，这意味着它们必须非常轻巧。而且控制区域中的元素要沉重得多，但不必不必要地重新创建它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要了解如何完成此操作，请考虑元素的生命周期：</font></font><br>
<br>
<ul>
<li>     Widget.createElement    ,     .</li>
<li>   mount        .              .</li>
<li>       .</li>
<li>   ,    (,    ),     .       runtimeType  key,     .   ,     ,           .</li>
<li> ,       ,    ,             ,      (  deactivate).</li>
<li>   ,     .           ,       ,   (unmount),           .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，当您在树中重新包含元素时，如果该元素或其祖先具有全局键，则将从非活动元素列表中将其删除，将调用activate方法，并且与此元素关联的渲染对象将再次嵌入渲染树中。</font><font style="vertical-align: inherit;">这意味着该项目应再次出现在屏幕上。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在类声明中，我们看到该元素实现了BuildContext接口。</font><font style="vertical-align: inherit;">BuildContext是控制小部件在小部件树中的位置的工具，如其文档所述。</font><font style="vertical-align: inherit;">几乎完全符合商品说明。</font><font style="vertical-align: inherit;">该接口用于避免对元素的直接操作，但同时允许访问必要的上下文方法。</font><font style="vertical-align: inherit;">例如，findRenderObject，它允许您查找与此元素对应的渲染树对象。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染对象</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仍然需要处理此三元组的最后一个链接</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-RenderObject</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。顾名思义，这是可视化树的对象。它具有父对象，以及父对象用来存储有关该对象本身的特定信息（例如其位置）的数据字段。该对象负责基本渲染和布局协议的实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RenderObject并不限制使用子对象的模型：可能不存在，一个或多个。</font><font style="vertical-align: inherit;">同样，定位系统不限于：笛卡尔系统，极坐标，所有这些以及更多可供使用。</font><font style="vertical-align: inherit;">使用位置协议没有任何限制：调整宽度或高度，限制大小，设置父对象的大小和位置，或者在必要时使用父对象的数据。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">颤抖的世界图片</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们尝试对所有事物如何协同工作进行全面了解。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上面我们已经提到，小部件是一个不变的描述，但是用户界面并不是完全静态的。</font><font style="vertical-align: inherit;">通过将对象划分为3个级别和划分责任区，可以消除这种差异。</font></font><br>
<br>
<ul>
<li> ,          . </li>
<li> ,               . </li>
<li>  ,   — ,     .</li>
</ul><br>
<img src="https://habrastorage.org/webt/j_/n_/og/j_n_ogui1a0iawbuoq5vxclsnne.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们用一个简单的示例看一下这些树的外观：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/u7/0o/wk/u70owkgirs6krcos85rwn-acli8.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，我们将一些StatelessWidget包装在Padding小部件中并在其中包含文本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们代替Flutter-我们得到了这个小部件树。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“嘿，填充，我需要您的元素”</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Padding：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“当然，握住SingleChildRenderObjectElement”</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/jj/u7/zn/jju7znfat7skocfex74adc4cu7o.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“元素，这是您的位置，安顿下来”</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
SingleChildRenderObjectElement：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“伙计，一切正常，但我需要RenderObject”</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ Padding，喜欢完全吸引你？”</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
填充：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“保留它，RenderPadding”</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
SingleChildRenderObjectElement：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“很棒，开始工作”</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/zk/ty/se/zktyse7pgo6jdd6x7impyivfhy0.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“那么下一个是谁？” StatelessWidget，现在让元素»</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
StatelessWidget：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«这里StatelessElement»</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«StatelessElement，您将服从SingleChildRenderObjectElement，在这里着手进行»</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
StatelessElement：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«OK»</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/7w/tb/ke/7wtbkebtfn_xeq1ieqxqbarpkro.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«RichText，elementik存在，请»</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
RichText给MultiChildRenderObjectElement </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ MultiChildRenderObjectElement，开始，开始”</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
MultiChildRenderObjectElement：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“我需要工作渲染”</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ RichText，我们需要渲染对象”</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
RichText：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“这里是RenderParagraph”</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ RenderParagraph您将收到RenderPadding指令，而MultiChildRenderObjectElement将控制您”</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
MultiChildRenderObjectElement：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“现在一切正常，我已经准备就绪”，</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/s4/24/fn/s424fnivo4j2tb4sv9pcirmxov0.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
您肯定会问一个逻辑问题：“ StatelessWidget的渲染对象在哪里，为什么不在那里，我们在上面决定了元素绑定配置显示？” </font><font style="vertical-align: inherit;">让我们注意mount方法的基本实现，该方法在生命周期描述的这一部分中进行了讨论。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">void</span> mount(Element parent, dynamic newSlot) {<font></font>
    assert(_debugLifecycleState == _ElementLifecycle.initial);<font></font>
    assert(widget != <span class="hljs-literal">null</span>);<font></font>
    assert(_parent == <span class="hljs-literal">null</span>);<font></font>
    assert(parent == <span class="hljs-literal">null</span> || parent._debugLifecycleState == _ElementLifecycle.active);<font></font>
    assert(slot == <span class="hljs-literal">null</span>);<font></font>
    assert(depth == <span class="hljs-literal">null</span>);<font></font>
    assert(!_active);<font></font>
    _parent = parent;<font></font>
    _slot = newSlot;<font></font>
    _depth = _parent != <span class="hljs-literal">null</span> ? _parent.depth + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<font></font>
    _active = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>)<font></font>
        _owner = parent.owner;<font></font>
    <span class="hljs-keyword">if</span> (widget.key is GlobalKey) {<font></font>
        final GlobalKey key = widget.key;<font></font>
        key._register(<span class="hljs-keyword">this</span>);<font></font>
    }<font></font>
    _updateInheritance();<font></font>
    assert(() {<font></font>
        _debugLifecycleState = _ElementLifecycle.active;<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }());<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们不会在其中看到渲染对象的创建。</font><font style="vertical-align: inherit;">但是该元素实现了BuildContext，该上下文具有findRenderObject可视化对象搜索方法，该方法将导致我们进入以下获取方法：</font></font><br>
<br>
<pre><code class="javascript hljs">RenderObject get renderObject {<font></font>
    RenderObject result;<font></font>
    <span class="hljs-keyword">void</span> visit(Element element) {<font></font>
        assert(result == <span class="hljs-literal">null</span>); 
        <span class="hljs-keyword">if</span> (element is RenderObjectElement)<font></font>
            result = element.renderObject;<font></font>
        <span class="hljs-keyword">else</span><font></font>
            element.visitChildren(visit);<font></font>
    }<font></font>
    visit(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> result;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在基本情况下，元素可能不会创建渲染对象；仅需要RenderObjectElement及其后代才能执行此操作，但是，在这种情况下，处于某个嵌套级别的元素必须具有包含渲染对象的子元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看来为什么所有这些困难。多达3棵树，不同职责范围等答案很简单-这就是Flutter性能的基础。小部件是不可变的配置，因此，通常会重新创建它们，但是同时它们非常轻巧，这不会影响性能。但是Flutter正在尝试尽可能多地重用重元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑一个例子。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">屏幕中间的文本。这种情况下的代码如下所示：</font></font></i><br>
<br>
<pre><code class="javascript hljs">body: Center(<font></font>
    child: Text(“Hello world!”)<font></font>
),</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，小部件树将如下所示：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lc/wt/fa/lcwtfazdhkpaprcu9tqvhssvck4.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter构建了所有3棵树之后，我们得到以下图片：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/vx/ph/ucvxphu5r2ds-6_kmoizgyoczo8.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果更改将要显示的文本会发生什么？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_u/8b/do/_u8bdowthfzx9jshpbprfnpj1ai.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们有了一个新的小部件树。上面我们讨论了元素的最大可能重用。看一看Widget类的方法，它的话语为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canUpdate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">static</span> bool canUpdate(Widget oldWidget, Widget newWidget) {
    <span class="hljs-keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType &amp;&amp; oldWidget.key == newWidget.key;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们检查以前的小部件和新的小部件的类型，以及它们的键。如果它们相同，则无需更改项目。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，升级之前，第一个元素是“中心”，升级之后，也是“中心”。两者都没有键，完全是巧合。我们可以将项目链接更新为新的小部件。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/tr/s4/hetrs4cgzrimhibqeilfoja5xzi.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是除了类型和键之外，小部件是描述和配置，显示所需的参数值可能会更改。这就是为什么元素在更新到小部件的链接之后，应该启动对渲染对象的更新。就Center而言，什么都没有改变，我们将继续进行比较。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再次，类型和键告诉我们重新创建元素没有意义。文本是StatelessWidget的后代；它没有直接的显示对象。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dp/yy/6m/dpyy6mckv6cddryb0_yu5asy_uy.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
转到RichText。该小部件也没有更改其类型；键中没有任何差异。该项目使用新的小部件更新其关联。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hw/vh/95/hwvh952jekjwhudyj6czju3hq6a.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
连接已更新，仅保留以更新属性。结果，RenderParagraph将显示新的文本值。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/_p/g-/lv_pg-n6wlmcmlunokumb60nqw0.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一个图纸框架的时间到了，我们将看到我们期望的结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于这种工作，Flutter的高性能得以实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上面的示例描述了微件结构本身未更改的情况。但是，如果结构发生变化会怎样？正如我们从生命周期描述中了解到的那样，Flutter当然将继续尝试最大限度地利用现有对象，但是将为所有新的小部件创建新元素，并在帧末尾删除旧的和更多不必要的小部件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看几个例子。</font><font style="vertical-align: inherit;">为了确保以上所述，我们使用Android Studio工具-Flutter Inspector。</font></font><br>
<br>
<pre><code class="javascript hljs">@override<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> Scaffold(<font></font>
        body: Center(<font></font>
            child: _isFirst ? first() : second(),<font></font>
        ),<font></font>
        <span class="hljs-attr">floatingActionButton</span>: FloatingActionButton(<font></font>
            child: Text(<span class="hljs-string">"Switch"</span>),
            <span class="hljs-attr">onPressed</span>: () {<font></font>
                setState(() {<font></font>
                    _isFirst = !_isFirst;<font></font>
                });<font></font>
            },<font></font>
        ),<font></font>
    );<font></font>
}<font></font>
<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">first</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    mainAxisAlignment: MainAxisAlignment.center,
    children: &lt;Widget&gt;[
        Text(
            <span class="hljs-string">"test"</span>,
            style: TextStyle(fontSize: <span class="hljs-number">25</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">SizedBox</span>(<span class="hljs-params">
            width: <span class="hljs-number">5</span>,
        </span>),
        <span class="hljs-title">Icon</span>(<span class="hljs-params">
            Icons.error,
        </span>),<font></font>
    ],<font></font>
);<font></font>
<font></font>
<span class="hljs-title">Widget</span> <span class="hljs-title">second</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    mainAxisAlignment: MainAxisAlignment.center,
    children: &lt;Widget&gt;[
        Text(
            <span class="hljs-string">"one more test"</span>,
            style: TextStyle(fontSize: <span class="hljs-number">25</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">Padding</span>(<span class="hljs-params">
            padding: EdgeInsets.only(left: <span class="hljs-number">5</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">Icon</span>(<span class="hljs-params">
            Icons.error,
        </span>),<font></font>
    ],<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，通过单击按钮，将更改一个小部件。</font><font style="vertical-align: inherit;">让我们看看检查员向我们展示了什么。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wi/vt/vt/wivtvtojhv4uq3l7ouoje3le-u0.png" alt="图片"><br>
<br>
<img src="https://habrastorage.org/webt/f4/rb/0a/f4rb0avn7pombux2ct6pkap2edi.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如我们所见，Flutter仅为Padding重新创建了渲染，其余的仅被重用了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再考虑1个选项，其中结构以更全局的方式更改-我们更改嵌套级别。</font></font><br>
<br>
<pre><code class="javascript hljs">Wid<span class="hljs-keyword">get</span> <span class="hljs-title">second</span>() =&gt; <span class="hljs-title">Container</span>(<span class="hljs-params">child: first(</span>),);</code></pre><br>
<img src="https://habrastorage.org/webt/yt/8i/gs/yt8igsxt3r3b-ofhkrlcyjaqryc.png" alt="图片"><br>
<br>
<img src="https://habrastorage.org/webt/j7/na/qw/j7naqwq6060sh-tw_atxna_umpa.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管该树根本没有视觉上的变化，但仍重新创建了渲染树的元素和对象。</font><font style="vertical-align: inherit;">发生这种情况是因为Flutter会按级别进行比较（在这种情况下，大多数树没有变化都没关系），因此在比较Container和Row时进行了这部分的筛选。</font><font style="vertical-align: inherit;">但是，可以摆脱这种情况。</font><font style="vertical-align: inherit;">这将对我们帮助GlobalKey。</font><font style="vertical-align: inherit;">为Row添加这样的键。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> _key = GlobalKey(debugLabel: <span class="hljs-string">"testLabel"</span>);<font></font>
<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">first</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    key: _key,
    …
</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/gg/jp/zj/ggjpzjlpox-ijhgtwxy-i6rvcsk.png" alt="图片"><br>
<br>
<img src="https://habrastorage.org/webt/zy/br/zy/zybrzywy-_ixs_apl7j1fiqsrco.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一旦我们告诉Flutter该零件可以重复使用，他便抓住了机会。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们更加熟悉Flutter魔术，现在我们知道它不仅在小部件中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter是一种协调良好的机制，具有自己的层次结构和职责范围，使用它不仅可以创建美观的应用程序，还可以创建高效的应用程序。</font><font style="vertical-align: inherit;">当然，我们只检查了设备中很小但很小的一部分，因此我们将在以后的文章中继续分析框架内部工作的各个方面。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我希望本文中的信息有助于理解Flutter的内部工作方式，并帮助您在开发过程中找到优雅而有效的解决方案。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
感谢您的关注！</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源资源</font></font></h4><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flutter </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">“ </font></i><i><font style="vertical-align: inherit;">Flutter </font></i></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何渲染小部件”，作者：Andrew Fitz Gibbon，Matt Sullivan</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN501850/index.html">我们将EM算法分解成小块</a></li>
<li><a href="../zh-CN501854/index.html">如何退出编程并开始执行</a></li>
<li><a href="../zh-CN501856/index.html">Tarantool：分析师外观</a></li>
<li><a href="../zh-CN501858/index.html">将所有点都放在“ psi”上</a></li>
<li><a href="../zh-CN501860/index.html">5月15日RU-Center可能会在没有您参与的情况下为您添加付费服务</a></li>
<li><a href="../zh-CN501864/index.html">助理或检查员：机器人要呼叫谁？</a></li>
<li><a href="../zh-CN501866/index.html">机器人将销毁多少工作</a></li>
<li><a href="../zh-CN501868/index.html">如何不让会计师丢脸，还是我们将1C转移到云端。分步指导</a></li>
<li><a href="../zh-CN501870/index.html">枚举第二部分中的最大值数</a></li>
<li><a href="../zh-CN501872/index.html">控制论系统中的学习地点</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>