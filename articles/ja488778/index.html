<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍❤️‍💋‍👨 👩🏻‍🚒 🤹🏻 データ構造：すべてを実行できるリスト* 👍 😦 ℹ️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="*何よりも、配列の単一の要素に対する操作の比較的迅速な実行を意味します。
 
 リストを実装するデータ構造は完全です。誰もが自分の長所と短所を持っています。たとえば、Javaの世界では、必要な操作に応じて、以下を使用できます。
 
 

- add（obj）、get（obj）、set（index、o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>データ構造：すべてを実行できるリスト*</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488778/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*何よりも、配列の単一の要素に対する操作の比較的迅速な実行を意味します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストを実装するデータ構造は完全です。</font><font style="vertical-align: inherit;">誰もが自分の長所と短所を持っています。</font><font style="vertical-align: inherit;">たとえば、Javaの世界では、必要な操作に応じて、以下を使用できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add（obj）、get（obj）、set（index、obj）：ほとんどすべてのリストの基本セット（例：ArrayList）。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add（index、obj）：ツリーのような構造。たとえば、Apache common-collectionsのTreeList。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">削除（インデックス）：上記と同じ。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains（obj）、indexOf（obj）：一連のArrayListとHashMapを使用できます。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remove（obj）：...答えるのが難しいと思います。</font><font style="vertical-align: inherit;">場合によっては、LinkedHashSetで問題を解決できることがあります。</font><font style="vertical-align: inherit;">前の2つの点が存在する場合、それは簡単に解決されますが、どちらの構造が両方とも迅速にできますか？</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
迅速な追加（obj）、取得（index）、削除（index）、indexOf（obj）の構造が必要なとき、グーグルは答えを出しませんでした。そのような構造のコード例や説明は見つかりませんでした。多分私はそこを見ていなかったので、自分で発明しなければなりませんでした。しかし、誰かがコメントのリンクをドロップした場合、私はそれを大いに感謝します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく誰かがTreeListを使用すると、リストの中央に項目をすばやく挿入/削除し、オブジェクトからHashMapをTreeListのインデックスに追加して、indexOf（obj）をすばやく実行できると推測した可能性があります。そして、それはシンプルでエレガントですが、間違った決定になります。結局のところ、中央に追加したり、中央から削除したりするときには、要素の半分について、平均してインデックスを再計算する必要があります。これにより、パフォーマンスがO（n）に低下します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、上記のすべてを実行できるデータ構造について説明します。 O（log（n））時間で1つの要素に対して任意の操作を実行します。まあ、ほぼ-リスト内のすべてのオブジェクトが異なる場合に対数が実行されます。リストに同じオブジェクトが含まれている場合は、最大でO（log（n）^ 2）までパフォーマンスが低下する可能性があります。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではコードをペイントしないことをすぐに警告します。</font><font style="vertical-align: inherit;">それは記事にとってかなり複雑になる可能性があります。</font><font style="vertical-align: inherit;">しかし、それはJavaで書かれています。</font><font style="vertical-align: inherit;">Apache common-collectionsのTreeListクラスに基づいています。</font><font style="vertical-align: inherit;">プルリクエストはすでに存在しますが、執筆時点ではまだ記事は流されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、よく知られたアルゴリズムについては説明しません。</font><font style="vertical-align: inherit;">たとえば、ツリーバランシングアルゴリズム。</font><font style="vertical-align: inherit;">ほとんどの場合、ツリーのバランスを保つことができるという事実を当然のことと考えることで十分かもしれません。</font><font style="vertical-align: inherit;">これは、一般的な考えの理解には影響しません。</font><font style="vertical-align: inherit;">もっと知りたい人は簡単に情報を見つけることができます。</font><font style="vertical-align: inherit;">ただし、基本的なことについては非常に簡単に説明します。基本的な知識がないと、多くの重要な要素を理解できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リンクは最後になります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜ必要なのか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、すべてがリストから直接必要とされる状況を思いつくのはそれほど簡単ではありません。</font><font style="vertical-align: inherit;">これがある種の超必要な構造である可能性は低いです。そうでなければ、誰もがそれについて知っているでしょう。</font><font style="vertical-align: inherit;">ただし、そのようなリストが役立ついくつかの例を示すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は多くの例が遠いところにあることを認識しています。</font><font style="vertical-align: inherit;">すべてまたはほとんどすべてが別の方法で解決できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシングと圧縮</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の最初の仕事、そのため私は問題を研究し始めました。</font><font style="vertical-align: inherit;">特定のデータの圧縮で遊んで、オブジェクトキャッシュのリストが必要でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアは次のとおりです。別のオブジェクトを処理するときに、リストからそのオブジェクトを探します。</font><font style="vertical-align: inherit;">見つからない場合は、オブジェクトを保存してリストの一番上に追加します。</font><font style="vertical-align: inherit;">見つかった場合は、リストのインデックスを取得し、オブジェクトの代わりにそのインデックスのみを保存します。その後、オブジェクトをリストの一番上に移動します。</font><font style="vertical-align: inherit;">したがって、頻繁に出会うオブジェクトは小さなインデックスを受け取り、1回だけ出会うオブジェクトは最終的にリストの最後に移動して削除されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">順番</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のFIFOキューの代わりに、一部のタスクで同様の構造が使用されている場合、次の操作を実行できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">質問に答えてください：このタスクの前にキューにあるタスクの数。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューからタスクを削除します。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スーパーのようなものです。</font><font style="vertical-align: inherit;">チョコレートバーに来たが、ラインがゆっくりと移動していることがわかった場合、おそらくチョコレートバーはそれほど必要ではありませんか？</font><font style="vertical-align: inherit;">:)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハイスコ​​ア表</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレイヤーがゲームのレベルを完了する時間を保存するとします。</font><font style="vertical-align: inherit;">多くのプレーヤーがいて、彼らはすべて最短の時間を見せようとして競争します。</font><font style="vertical-align: inherit;">プレーヤーのデータを配列に入れ、時間順に並べ替えることができます。</font><font style="vertical-align: inherit;">この構造を使用すると、次のことができます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前よりも良い結果を示している場合は、リストの上位に移動します。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、不正行為の禁止の場合は、リストからプレーヤーを削除します。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各プレーヤーに自分のいる場所を見せます。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レコードテーブルをページごとに表示します。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">疎なテーブルを場所、たとえば、時間1、2、3、5、10、20、50、100、1000、10000の場所で表示します。 </font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ構造</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造は、暗黙のキーを持つツリーに基づいています。</font><font style="vertical-align: inherit;">たとえば、このアプローチに基づいて、Apache common-collectionsのTreeListが基づいています。</font><font style="vertical-align: inherit;">次に進むには、この構造がどのように機能するかを理解する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗黙のキーツリー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリーはノード（ノード）で構成されます。</font><font style="vertical-align: inherit;">各ノードには、ノードに格納されているオブジェクトへのリンクと、他のノードへの2つのリンク（左と右）が含まれています。</font><font style="vertical-align: inherit;">最上位ノードはルートノードと呼ばれます。</font><font style="vertical-align: inherit;">最も単純なケースでは、ノードは次のようになります。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  obj: T<font></font>
  left: Node&lt;T&gt;<font></font>
  right: Node&lt;T&gt;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左側のサブツリーの各ノードの従来のバイナリツリーでは、すべてのオブジェクトは現在のノードよりも小さく、右側では大きくなります。</font><font style="vertical-align: inherit;">例えば：</font></font><br>
<br>
<pre><code class="plaintext hljs">                             [ element: 25 ]<font></font>
                           /                 \<font></font>
                          /                   \<font></font>
          [ element: 14 ]                       [ element: 45 ]<font></font>
           /          \                           /          \<font></font>
          /            \                         /            \<font></font>
[ element: 10 ]    [ element: 22 ]     [ element: 27 ]    [ element: 90 ]<font></font>
                    /          \                            /<font></font>
                   /            \                          /<font></font>
            [ element: 17 ] [ element: 23 ]         [ element: 80 ] </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私たちの目的には、そのような木は適切ではありません。ソートされたオブジェクトを格納する必要はありませんが、配列のように、インデックスでアクセスする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列をツリーに配置するにはどうすればよいですか？配列の中央からインデックスiの要素を選択してみましょう。配列のi番目の要素をルートノードに配置します。 2つのサブツリーがルートノードを終了します。左側のサブツリーには、配列&lt;iを持つ配列の半分を配置し、右側にはインデックス&gt; iを持つ配列を配置します。どうやってするの？同様に、サブアレイの中央から要素を選択し、この要素をノードに配置すると、さらに2つの小さいサブアレイが取得されます。そして、配列のすべての要素をツリーのノードに配置するまでです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、要素[「q」、「w」、「e」、「r」、「t」、「y」、「u」]を含む配列は次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">                            [el: r,  size: 7]<font></font>
                           /        :        \<font></font>
                          /         :         \<font></font>
         [el: w, size: 3]           :           [el: y, size: 3]<font></font>
           /     :    \             :             /    :     \<font></font>
          /      :     \            :            /     :      \<font></font>
[el: q, size: 1] : [el: e, size: 1] : [el: t, size: 1] : [el: u, size: 1]<font></font>
        :        :         :        :         :        :         :<font></font>
        :        :         :        :         :        :         :<font></font>
       [q]      [w]       [e]      [r]       [t]      [y]       [u]<font></font>
<font></font>
Index:  0        1         2        3         4        5         6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「r」配列の中央の要素は、ルートノードに配置します。 2つのサブ配列[「q」、「w」、「e」]と[「t」、「y」、「u」]は、左右のサブツリーに配置されます。このため、中央の要素はサブ配列から選択されます。この場合、これらは「w」と「y」であり、次のレベルのノードに分類されます。上のようにします。そして、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合は、ツリーがバランスされ、すべてのサブツリーの深さは同じです。しかし、これはそうである必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の図では、要素と左右のノードへのリンクに加えて、各ノードにはサブツリー全体の要素の数が含まれています。この情報は、ツリーが変更されたときに正しく更新する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、そのようなツリーでindex = 4の要素を見つける方法を見てみましょう。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルートノード（ルート、この場合は「r」要素）からクロールを開始します。 3つのオプションがあります。すでに右側のノード、左側の右側のノード、右側の右側のノードです。目的の要素を探す場所を理解するには、左側のサブツリーのサイズ（この場合はleft.size = 3）と現在のインデックス（この場合は4）を比較する必要があります。これらの2つの数値が等しい場合、必要なノードとその中の目的の要素を見つけました。左側のサブツリーのサイズが大きい場合、左側のサブツリーの必要なノード。小さい場合は、正しいサブツリーを調べる必要がありますが、目的のインデックスを減らす必要があります。index= index-left.size-1。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、left.size &lt;indexなので、新しいインデックス4-3-を持つ要素の右側のサブツリーを探しています。 1 =0。要素「y」を持つノードに移動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ルートノードで行ったのと同じことを行います。 left.sizeとindexを比較してください。 1&gt; 0なので、左側のサブツリーを見て、要素「t」のあるノードに移動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このノードには左サブツリーがなく、そのサイズは0です。index= left.size、つまり、インデックス4のノードが見つかり、そこから必要な要素「t」を取得できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
疑似コードでは、次のようになります。</font></font><br>
<br>
<pre><code class="kotlin hljs">function <span class="hljs-keyword">get</span>(node: Node&lt;T&gt;, index: int): T {
  <span class="hljs-keyword">val</span> leftSize: int = (node.left == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : node.left.size;
  <span class="hljs-keyword">if</span> (leftSize == index) {
    <span class="hljs-keyword">return</span> node.obj;<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leftSize &gt; index) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(node.left, index);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(node.right, index — leftSize — <span class="hljs-number">1</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列をツリーに配置する方法の主要な原則を説明しようとしました。</font><font style="vertical-align: inherit;">もちろん、このような構造は、O（log（n））とO（1）の場合、古典的な配列よりも遅くなります。</font><font style="vertical-align: inherit;">しかし、これには重要な利点があります。要素を中央に追加したり、中央から削除したりすることは、配列のO（n）に対してO（log（n））に対しても機能します。</font><font style="vertical-align: inherit;">もちろん、ツリーが多かれ少なかれバランスがとれている限り。</font><font style="vertical-align: inherit;">ほぼバランスのとれた方法でツリーを維持するための多くのアルゴリズムがあります。</font><font style="vertical-align: inherit;">たとえば、赤黒ツリー、AVLツリー、デカルトツリー。</font><font style="vertical-align: inherit;">ツリーのバランシングの詳細は書きませんが、どのアルゴリズムも適しています。</font><font style="vertical-align: inherit;">ツリーが平均的にバランスが取れており、その最大深度が最小深度とそれほど変わらないと仮定しましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">わずかな最適化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左側のツリーのサイズを確認する上記の方法は、認識には便利ですが、もう少し効率的に行うことができます。左側のサブツリーを毎回調べないようにするために、ツリーのサイズの代わりに、親ノードの位置を基準とした相対的な位置をノードに格納できます。ルートノードは、左側のサブツリーのサイズと一致する絶対位置を格納します。</font></font><br>
<br>
<pre><code class="plaintext hljs">                             [el: r, pos: 3]<font></font>
                           /        :        \<font></font>
                          /         :         \<font></font>
         [el: w, pos: -2]           :           [el: y, pos: +2]<font></font>
           /     :    \             :             /    :     \<font></font>
          /      :     \            :            /     :      \<font></font>
[el: q, pos: -1] : [el: e, pos: +1] : [el: t, pos: -1] : [el: u, pos: +1]<font></font>
        :        :         :        :         :        :         :<font></font>
        :        :         :        :         :        :         :<font></font>
       [q]      [w]       [e]      [r]       [t]      [y]       [u]<font></font>
<font></font>
Index:  0        1         2        3         4        5         6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、ルートノード「r」の位置は3です。ノード「w」の位置は親ノードに対して-2、絶対位置は3 +（-2）= 1です。同様に、1つ下のレベルに移動できます。たとえば、ノード「e」の位置は3です。 +（-2）+（+1）= 2.つまり、</font><font style="vertical-align: inherit;">ノードインデックスは、ツリーのルートからこのノードまでの位置の合計です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この最適化は、リスト内のアイテムの高速検索に加えて、ノードのインデックスの高速で簡単な検索を提供します。</font><font style="vertical-align: inherit;">しかし、もちろん、ツリーを変更するときに位置を正しく更新することは、もう少し難しくなっています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスを追加</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ツリーでは、要素をインデックスで取得し、その値を変更し、要素を中央に追加して削除できます。基本的には、値による迅速なインデックス検索indexOf（obj）を追加するだけです。次に、（obj）とremove（obj）が簡単に解決されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、最初に、タスクを少し単純化しましょう。ユニークな要素だけを格納する構造を作ってみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何かをすばやく検索するために、通常はテーブルを使用します。 Javaの世界では、テーブルはMapと呼ばれ、HashMapとTreeMapの2つの主要な実装があります。テーブルへのキーはオブジェクトへのリンクになり、値はそのノードへのリンクになります。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexedTreeListSet</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  root: Node&lt;T&gt;<font></font>
  indexMap: Map&lt;T, Node&lt;T&gt;&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。構造は2つの部分で構成されています。リストツリー自体と、このツリーのオブジェクトおよびノー​​ドへのリンクを持つテーブルです。ツリーを更新するときは、テーブルも更新する必要があります。プロセスについては詳しく説明しません。直感的に理解できるはずです。ノードを追加します-テーブルに追加し、ノードを削除します-テーブルから削除します。実際には、ツリーのバランスには微妙な違いがあります。アルゴリズムはノード間のリンクを変更し、ノード間でオブジェクトを移動するべきではありません。そうしないと、テーブルで多くの更新を行う必要があり、パフォーマンスが低下します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OK、ノードに含まれる要素によってノードをすばやく見つけることができると仮定します。だから何？インデックスを見つける必要がありますが、これはまだできません。しかし、ノードクラスを複雑にして、左ノードと右ノードだけでなくその親へのリンクも含めることができます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  obj: T<font></font>
  left: Node&lt;T&gt;<font></font>
  right: Node&lt;T&gt;<font></font>
  parent: Node&lt;T&gt;<font></font>
  pos: int<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、ツリーの更新はもう少し複雑です。親へのリンクを注意深く更新する必要があるからです。しかし、ノードがわかったので、ツリーを上に移動して任意のノードのインデックスを計算できます。前の章の最適化を使用した場合、現在のノードからルートまでの位置の合計を計算する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一意の要素を含むリストの場合、問題は解決されたと見なすことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確かに、小さな問題があります。</font><font style="vertical-align: inherit;">set（index、obj）を呼び出すとします。</font><font style="vertical-align: inherit;">ノードのある要素を別の要素に簡単に置き換えることができますが、リストに新しい要素がまだない場合に限られます。</font><font style="vertical-align: inherit;">もしそうなら、私は何をすべきですか？</font><font style="vertical-align: inherit;">古い位置から余分なアイテムを削除して、新しいものを入れますか？</font><font style="vertical-align: inherit;">またはその逆、最初に追加してから削除しますか？</font><font style="vertical-align: inherit;">結果は異なる場合があります。</font><font style="vertical-align: inherit;">そして、あなたは何もしないか、例外を投げることができます。</font><font style="vertical-align: inherit;">完璧な解決策はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、リストなどの標準メソッドによるソートも機能しません。</font><font style="vertical-align: inherit;">結局のところ、並べ替えアルゴリズムはオブジェクトの一意性の必要性を認識せず、リスト内のアイテムを移動するときに重複を作成します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">唯一性を取り除く</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに複雑なことに、同じオブジェクトを保持してみましょう。明らかに、あなたはテーブルで何かをする必要があります。ノードのリストをそこに格納するという最初のアイデアはあまりよくありません。リストの長さが長くなると、パフォーマンスが低下します。すべてのリストアイテムが同じ場合は最大O（n）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ノードのソートされたツリーをリストではなくテーブルに保存してみましょう。リスト内の位置でソートされました。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexedTreeList</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  root: Node&lt;T&gt;<font></font>
  indexMap: Map&lt;T, TreeSet&lt;Node&lt;T&gt;&gt;&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、サイズmのTreeSet &lt;Node&gt;への挿入/削除が、ノードの位置のログ（m）比較中に発生し、各比較はログ（n）時間にわたって発生します。同様の構造への挿入または削除の最終的な複雑さはO（log（n）*（1 + log（m）））で発生します。ここで、nはリスト内の要素の総数であり、mは挿入/削除されたリスト内の要素数です。最悪の場合、すべての要素が互いに等しい場合、複雑度O（log（n）^ 2）が得られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意深い読者はおそらく反対するでしょうが、不変性についてはどうでしょうか？</font><font style="vertical-align: inherit;">結局のところ、オブジェクトがテーブルキーである場合、オブジェクトを変更することはできませんか？</font><font style="vertical-align: inherit;">一般的にはそうです。</font><font style="vertical-align: inherit;">ただし、ソートされたオブジェクトをキーに格納するツリーの場合、比較の標準ルールに加えて、不変条件を保持するだけで十分です。&lt;bの場合、このプロパティは時間の経過とともに変化しないはずです。</font><font style="vertical-align: inherit;">これはまさに私たちの場合です。あるノードの位置が別のノードの位置よりも小さい場合、ノード間に追加または削除されたノードの数に関係なく、このプロパティは保持されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造を永続化することは可能ですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短い答え：いいえ、不可能です。</font><font style="vertical-align: inherit;">ツリーの相互接続性により、ルートからリーフへ、そしてその逆に、すべてのツリーノードがそれぞれに接続されています。</font><font style="vertical-align: inherit;">この方法で永続化を行うことはできないため、変更を加えて構造全体を再作成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、リストの中央に要素を挿入する必要がない場合に備えて、永続的な構造を実装する方法については理解しています。</font><font style="vertical-align: inherit;">要素を最初または最後に追加したり、途中から削除したりできます。</font><font style="vertical-align: inherit;">残りのプロパティは同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味があれば、この構造について記事を書こうと思います。</font><font style="vertical-align: inherit;">おそらく、Java、Kotlin、Scalaで実装することもできます。</font><font style="vertical-align: inherit;">しかし、ほとんどの場合、それはすぐではありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかの実装機能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで私が直面しなければならなかったいくつかの機能について説明したいと思います。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストにノードの位置を保存するための最適化の1つについては、上記で説明しました。オープンソースの強みはここに示されています。私は既製のTreeListコードを使用し、AVLツリー、ノードの回転、位置の更新などの詳細については掘り下げませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TreeListから継承されたもう1つの機能は、ツリーリーフのサブツリーへのリンクです。各ノードには、ブール型のleftIsPreviousおよびrightIsNextが格納されます。これらの変数は、左/右サブツリーの有無を示します。サブツリーがない場合は、左/右に、サブツリーへのリンクの代わりに、前または次の要素に対応するノードへのリンクが格納されます。この例では、[「q」、「w」、「e」、「r」、「t」、「y」、「u」]ノード「e」は葉が多く、サブツリーがありません。したがって、leftIsPreviousおよびrightIsNextはtrueであり、leftおよびrightはそれぞれノード「w」および「r」を指します。このアプローチは、リストをより速く反復するのに役立ちます。そして、それは新機能のプログラミングを妨害します:)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テーブルオブジェクト→ノードの操作について少し。理想的には、要素を構造に追加するときに一度テーブルに要素を配置し、構造から削除するときに一度削​​除する必要があります。実際には、これを達成することはできませんでした。アイテムを追加すると、テーブルに追加されます。ただし、アイテムを削除すると、バランシングアルゴリズムによってノード間でアイテムが移動することがあります。結果は、1つの削除ではなく、2つの削除とテーブル内の1つのレコードになります。これは、leftIsPreviousおよびrightIsNextから最適化を削除した場合に修正できます。また、削除中だけでなく、パフォーマンスも少し向上します。一部のテストでは、増加は10〜20％でした。しかし、反復速度は大幅に低下し、私のテストでは1.5〜2.5倍になります。とりあえず、最適化はそのままにすることにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaでは、テーブルの主なタイプはHashMapとTreeMapです。テーブルの場合、オブジェクト→ノードはデフォルトでHashMapを使用します。ただし、タスク固有のコンパレータでTreeMapを使用できます。この場合、indexOf（obj）およびremove（obj）は、コンパレータコードに従って、指定されたオブジェクトと等しいオブジェクトを検索/削除します。たとえば、ユーザーのリストを保存し、コンパレータはユーザーを名前でのみ比較します。次に、「リストのどの位置が「ナポレオン」という名前のユーザーですか？」という質問に答えることができます。または、リストからすべてのナポレオンを削除します:)。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造体はnullをサポートしていません。直せますが、必要という感じはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造が「すべてを知っている」という事実に関しては、もちろん、私は少し誤解を招くものでした。</font><font style="vertical-align: inherit;">もちろん、単一の要素を扱う場合、すべてが問題なく、特定の条件下では対数でも問題ありません。</font><font style="vertical-align: inherit;">しかし、彼女は他の構造ができることをいくつか知りません。</font><font style="vertical-align: inherit;">たとえば、暗黙のキーを持つデカルトツリー、それに関する記事がハブにありました </font><font style="vertical-align: inherit;">indexOfをすばやく実行する方法はわかりませんが、サブリストを作成し、2つのリストを対数用に1つに連結する方法（平均して、保証されません）を知っています。さらに、永続化することもできます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaでは、パフォーマンスは通常jmhフレームワークを使用して測定されます。</font><font style="vertical-align: inherit;">テストは、Java11のもとで2017 MacBook Proで行われました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準のArrayList、Apache common-collectionsのTreeList、および2つのクラスIndexedTreeListとIndexedTreeListSetのパフォーマンスをいくつかのシナリオで比較しました。</font><font style="vertical-align: inherit;">各シナリオでは、同じタイプの操作が1000回実行されたため、結果に1000を掛ける必要があります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スポイラーの下のコード</font></font></b><div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-meta">@Fork(1)</span>
<span class="hljs-meta">@Warmup(iterations = 3)</span>
<span class="hljs-meta">@Measurement(iterations = 5)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceCompare</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Class&gt; CLASSES = Stream.of(TreeList.class, IndexedTreeListSet.class, IndexedTreeList.class,<font></font>
            ArrayList.class)<font></font>
            .collect(Collectors.toMap(c -&gt; c.getSimpleName(), c -&gt; c));<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ITERATIONS = <span class="hljs-number">1000</span>;<font></font>
<font></font>
    <span class="hljs-meta">@State(Scope.Benchmark)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plan</span> </span>{<font></font>
<font></font>
        <span class="hljs-meta">@Param({"10", "100", "1000", "10000", "100000", "1000000"/*, "10000000"*/})</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> size;<font></font>
<font></font>
        <span class="hljs-meta">@Param({"ArrayList", "TreeList", "IndexedTreeList", "IndexedTreeListSet"})</span>
        <span class="hljs-keyword">public</span> String className;<font></font>
<font></font>
        <span class="hljs-keyword">private</span> Random random;
        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<font></font>
<font></font>
        <span class="hljs-meta">@Setup</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException </span>{<font></font>
            random = <span class="hljs-keyword">new</span> Random();<font></font>
            list = (List&lt;Integer&gt;) CLASSES.get(className).newInstance();<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<font></font>
                list.add(i);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">indexOfKnown</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value = list.indexOf(random.nextInt(plan.size));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">indexOfUnknown</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value += list.indexOf(random.nextInt());<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addRemoveRandom</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            list.add(random.nextInt(list.size() + <span class="hljs-number">1</span>), random.nextInt());<font></font>
            value += list.remove(random.nextInt(list.size()));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value += list.get(random.nextInt(list.size()));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Timeout(time = 1, timeUnit = TimeUnit.MILLISECONDS)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException </span>{<font></font>
        Options opt = <span class="hljs-keyword">new</span> OptionsBuilder()<font></font>
                .include(PerformanceCompare.class.getSimpleName())<font></font>
                .forks(<span class="hljs-number">1</span>)
<span class="hljs-comment">//                .jvmArgs("-Xms2048m", "-Xmx2048m", "-XX:MaxDirectMemorySize=512M")</span><font></font>
                .build();<font></font>
<font></font>
        <span class="hljs-keyword">new</span> Runner(opt).run();<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、リストからランダムなアイテムを取得する速度を比較しました。</font><font style="vertical-align: inherit;">このテストではオーバーヘッドが非常に大きいことをすぐに警告します。</font><font style="vertical-align: inherit;">1秒あたり100,000 * 1,000オペレーションに近い結果はひどく歪んでいます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト結果を取得</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.get                       ArrayList       10  thrpt    5  79865.412 ± 10145.202  ops/s<font></font>
PerformanceCompare.get                       ArrayList      100  thrpt    5  81862.243 ±   983.727  ops/s<font></font>
PerformanceCompare.get                       ArrayList     1000  thrpt    5  81033.507 ±  4540.206  ops/s<font></font>
PerformanceCompare.get                       ArrayList    10000  thrpt    5  64096.123 ±  1430.361  ops/s<font></font>
PerformanceCompare.get                       ArrayList   100000  thrpt    5  41289.491 ± 11286.114  ops/s<font></font>
PerformanceCompare.get                       ArrayList  1000000  thrpt    5   8598.944 ±  2048.461  ops/s<font></font>
PerformanceCompare.get                        TreeList       10  thrpt    5  33912.275 ±  3754.284  ops/s<font></font>
PerformanceCompare.get                        TreeList      100  thrpt    5  21346.854 ±   863.588  ops/s<font></font>
PerformanceCompare.get                        TreeList     1000  thrpt    5  14808.414 ±   508.098  ops/s<font></font>
PerformanceCompare.get                        TreeList    10000  thrpt    5   8679.384 ±   109.250  ops/s<font></font>
PerformanceCompare.get                        TreeList   100000  thrpt    5   4605.998 ±  1028.945  ops/s<font></font>
PerformanceCompare.get                        TreeList  1000000  thrpt    5   2241.381 ±   768.147  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList       10  thrpt    5  34054.357 ±  3682.829  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList      100  thrpt    5  21934.002 ±  2339.947  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList     1000  thrpt    5  14626.691 ±   369.893  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList    10000  thrpt    5   7386.863 ±   342.150  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList   100000  thrpt    5   4562.126 ±   352.772  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList  1000000  thrpt    5   2105.718 ±   702.064  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet       10  thrpt    5  33317.503 ±  2307.829  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet      100  thrpt    5  21247.440 ±  1253.386  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet     1000  thrpt    5  14665.557 ±   487.833  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet    10000  thrpt    5   7667.214 ±    80.093  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet   100000  thrpt    5   3454.023 ±    82.994  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet  1000000  thrpt    5   1768.701 ±    35.878  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで奇妙なことに、最大の関心は標準のArrayListです。理論的には、それから出る速度は一定で、要素の数に依存しないはずです。実際には、パフォーマンスは最初に毎秒約90,000 * 1000の操作を保持します（オーバーヘッドを覚えてください）が、リストの長さが数千のアイテムであると、低下し始めます。これの理由は、ますます頻繁にキャッシュミスが発生するためです。プロセッサキャッシュには必要なデータがなく、RAM内のデータにアクセスする必要性が高まっています。 100万要素の場合、テストの速度は10分の1になりますが、実際には、パフォーマンスの低下はさらに大きくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TreeList、IndexedTreeList、およびIndexedTreeListSetは、同様の結果を表示すると予想されます。</font><font style="vertical-align: inherit;">ArrayListよりもはるかに遅いと予想されます。</font><font style="vertical-align: inherit;">要素の数が少ない場合でも、TreeListはArrayListより数倍遅いですが、テストでは2倍しか違いが示されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のテストはaddRemoveRandomです。</font><font style="vertical-align: inherit;">ここでは、各テストで、要素をランダムな位置に挿入し、ランダムな位置から要素を削除します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AddRemoveRandomテスト結果</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.addRemoveRandom           ArrayList       10  thrpt    5  12440.764 ±   485.642  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList      100  thrpt    5   9880.123 ±   464.014  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList     1000  thrpt    5   5288.905 ±  1219.055  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList    10000  thrpt    5   1024.942 ±   179.366  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList   100000  thrpt    5     91.219 ±    25.380  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList  1000000  thrpt    5      5.499 ±     0.400  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList       10  thrpt    5   6242.607 ±   350.290  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList      100  thrpt    5   3117.945 ±   116.066  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList     1000  thrpt    5   1829.778 ±    80.516  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList    10000  thrpt    5   1230.077 ±    53.381  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList   100000  thrpt    5    443.571 ±    69.207  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList  1000000  thrpt    5    308.963 ±    84.077  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList       10  thrpt    5   3556.511 ±   144.596  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList      100  thrpt    5   2120.777 ±    83.848  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList     1000  thrpt    5   1211.112 ±    92.288  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList    10000  thrpt    5    789.458 ±    19.450  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList   100000  thrpt    5    302.989 ±    40.030  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList  1000000  thrpt    5    178.822 ±    92.853  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet       10  thrpt    5   4138.007 ±   119.943  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet      100  thrpt    5   2435.803 ±    20.276  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet     1000  thrpt    5   1445.054 ±   276.909  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet    10000  thrpt    5    972.256 ±    19.987  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet   100000  thrpt    5    366.608 ±    94.487  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet  1000000  thrpt    5    227.677 ±    48.276  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小さなリストでは、ArrayListの方が高速であると想定できます。</font><font style="vertical-align: inherit;">ただし、彼がこのテストで最大10,000要素のリストを獲得したという事実は興味深いようです。</font><font style="vertical-align: inherit;">どうやら、System.arrayCopyは非常に最適化されており、最新のプロセッサのすべての機能を使用しています。</font><font style="vertical-align: inherit;">10,000アイテムから始まり、特殊なデータ構造が勝ち始めています。</font><font style="vertical-align: inherit;">1,000,000要素の場合、速度差は30〜50倍です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IndexedTreeListとIndexedTreeListSetは、TreeListよりも遅いことが予想されます。</font><font style="vertical-align: inherit;">約1.5〜2回。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残りの2つのテストindexOfKnownおよびindexOfUnknownは、この構造の主な機能を示すだけです。</font><font style="vertical-align: inherit;">テストの違いは、リストにある要素を探す場合と、リストにない要素を探す場合があります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト結果indexOfKnownおよびindexOfUnknown</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.indexOfKnown              ArrayList       10  thrpt    5  41424.356 ±   549.047  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList      100  thrpt    5  17216.477 ±  1444.744  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList     1000  thrpt    5   2296.306 ±    76.372  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList    10000  thrpt    5    233.863 ±    26.926  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList   100000  thrpt    5     23.208 ±     2.776  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList  1000000  thrpt    5      0.919 ±     0.455  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList       10  thrpt    5  26740.708 ±  1323.125  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList      100  thrpt    5   5670.923 ±    99.638  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList     1000  thrpt    5    745.408 ±    26.827  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList    10000  thrpt    5     52.288 ±     1.362  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList   100000  thrpt    5      4.224 ±     0.855  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList  1000000  thrpt    5      0.193 ±     0.052  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList       10  thrpt    5  34485.128 ±  1582.703  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList      100  thrpt    5  29209.412 ±  1544.268  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList     1000  thrpt    5  21139.584 ±  1442.867  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList    10000  thrpt    5  12544.306 ±   312.097  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList   100000  thrpt    5   3538.201 ±   272.537  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList  1000000  thrpt    5   1420.119 ±   538.476  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet       10  thrpt    5  39201.995 ±  1887.065  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet      100  thrpt    5  34204.112 ±  1122.517  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet     1000  thrpt    5  25374.557 ±  1596.746  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet    10000  thrpt    5  14291.317 ±   391.180  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet   100000  thrpt    5   4215.898 ±   283.680  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet  1000000  thrpt    5   1729.100 ±  1260.815  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList       10  thrpt    5  59053.313 ±  1845.665  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList      100  thrpt    5  10867.572 ±   142.823  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList     1000  thrpt    5   1186.583 ±    28.003  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList    10000  thrpt    5    120.953 ±     4.146  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList   100000  thrpt    5     11.936 ±     0.320  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList  1000000  thrpt    5      0.566 ±     0.335  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList       10  thrpt    5  28134.237 ±  2291.670  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList      100  thrpt    5   3153.930 ±   158.734  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList     1000  thrpt    5    322.383 ±    44.245  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList    10000  thrpt    5     25.674 ±     1.787  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList   100000  thrpt    5      1.867 ±     0.291  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList  1000000  thrpt    5      0.093 ±     0.008  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList       10  thrpt    5  66625.126 ±  5232.668  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList      100  thrpt    5  70038.055 ±  5803.848  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList     1000  thrpt    5  63240.467 ±   885.956  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList    10000  thrpt    5  54731.988 ±  3950.150  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList   100000  thrpt    5  22049.476 ±   821.924  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList  1000000  thrpt    5   9459.862 ±   804.738  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet       10  thrpt    5  70274.968 ± 15830.355  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet      100  thrpt    5  71017.685 ±  6920.447  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet     1000  thrpt    5  66405.960 ±  1127.231  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet    10000  thrpt    5  57983.963 ±  3276.142  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet   100000  thrpt    5  41277.110 ±  9919.893  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet  1000000  thrpt    5   9840.185 ±  2159.352  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、ArrayListとTreeListにはほとんど驚きはありません。サイズが大きくなると、速度はほぼ直線的に低下します。非リストからのアイテムの検索は、リストからのアイテムの検索よりも2倍遅いと予想されます。平均で半分ではなく、アレイ全体を通過する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ここでのIndexedTreeListとIndexedTreeListSetは、期待どおりの結果を示しています。これらのデータ構造は、10個の要素があっても、ArrayListに匹敵するindexOf実行速度を示しています。 1000個の要素を使用すると、これらの構造は10倍速くなり、1,000,000は1000倍速くなります。リストにないアイテムを検索するときは、リストからアイテムを検索するときよりも高速であることが期待されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他に注目すべき興味深い点は、indexOfUnknownテストにおけるIndexedTreeListとIndexedTreeListSetのパフォーマンス低下です。</font><font style="vertical-align: inherit;">ここでの状況は、ArrayList.getを使用したテストの場合と同様です。</font><font style="vertical-align: inherit;">理論的には、パフォーマンスが低下することはなかったはずですが、実際には、キャッシュミスのために、大幅に低下しました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論の代わりに</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提案された構造に新規性があるかどうかはまだわかりません。一方では、暗黙のキーによってツリーがどのように機能するかを知っていれば、アイデアは複雑ではありません。一方、そのような性質を持つ構造の記述を見たことがありません。もしそうなら、その構造をより有名にすることは理にかなっています、それは誰かにとって有用かもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
でも、これが別のバイクだとしても、私はそれを役に立つようにしようとしました。 common-collectionsのプルリクエストが作成されましたが、この記事の執筆時点では、この記事はまだ注がれていません。オープンソースですべてがゆっくりと発生する可能性があることを知っているので、プロセスが何ヶ月も続いても驚くことはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ArrayListとTreeListのパフォーマンスを比較した結果に多少驚いた。</font><font style="vertical-align: inherit;">テストの結果、TreeListはリストサイズで最大10,000要素を使用しても意味がないことがわかりました。</font><font style="vertical-align: inherit;">二分木の代わりにb-treeを試してみるのは面白いでしょう。</font><font style="vertical-align: inherit;">この構造は、メモリをより注意深く使用し、おそらくより速く動作するはずです。</font><font style="vertical-align: inherit;">そしてそれのためにあなたはインデックス付けでアイデアを適応させることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いずれにせよ、予測可能な複雑さで（ほぼ）すべてを実行できる手段を武器に置くのは楽しいことです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font><br>
</a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JiraのApache common-collections </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">チケットの</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">元の</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">プルリクエスト</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">プロジェクト</font></a></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja488762/index.html">約束のあるエレガントな非同期プログラミング</a></li>
<li><a href="../ja488766/index.html">アートとテクノロジー：マサチューセッツ大学ローウェル校</a></li>
<li><a href="../ja488768/index.html">血まみれの地獄、または英語で培養された人と間違われると誓う方法</a></li>
<li><a href="../ja488770/index.html">KOMPAS-3D APIの操作→レッスン17→テキストドキュメント</a></li>
<li><a href="../ja488776/index.html">Visual Studio 2019 for Macのアクセシビリティの強化</a></li>
<li><a href="../ja488780/index.html">Mozillaはブラウザ戦争で敗北しましたが、それでもインターネットを救えると信じています</a></li>
<li><a href="../ja488782/index.html">Pythonのこの依存関係管理オプションはどうですか？</a></li>
<li><a href="../ja488784/index.html">コピーレフトライセンスに基づく無料ソフトウェアの改良の商用化</a></li>
<li><a href="../ja488786/index.html">ユーザーストーリーはどの程度詳細にすべきですか？</a></li>
<li><a href="../ja488792/index.html">膝の上でロシアのサイト可用性を監視する</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>