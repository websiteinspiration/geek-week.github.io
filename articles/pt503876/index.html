<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ üé≤ üêπ Programando um jogo para um dispositivo incorporado no ESP32: drive, bateria, som ‚öîÔ∏è üåÖ üë©üèª‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In√≠cio: sistema de montagem, entrada, display .
 
 Parte 4: drive
 O Odroid Go possui um slot para cart√£o microSD, que ser√° √∫til para baixar recursos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programando um jogo para um dispositivo incorporado no ESP32: drive, bateria, som</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503876/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/800/42e/44b80042e94aa2f2da9da2d2296461ad.jpg" alt="imagem"></div><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In√≠cio: sistema de montagem, entrada, display</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 4: drive</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Odroid Go possui um slot para cart√£o microSD, que ser√° √∫til para baixar recursos (sprites, arquivos de som, fontes) e, possivelmente, at√© para salvar o estado do jogo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O leitor de cart√£o √© conectado via SPI, mas o IDF facilita a intera√ß√£o com o cart√£o SD abstraindo chamadas SPI e usando fun√ß√µes </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POSIX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> padr√£o </font><font style="vertical-align: inherit;">como </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fopen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fread</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fwrite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tudo isso √© baseado na biblioteca </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FatFs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , portanto, o cart√£o SD deve ser formatado no formato FAT padr√£o.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele est√° conectado ao mesmo barramento SPI do LCD, mas usa uma linha de sele√ß√£o de chip diferente. </font><font style="vertical-align: inherit;">Quando precisamos ler ou gravar no cart√£o SD (e isso n√£o acontece com muita frequ√™ncia), o driver SPI alterna o sinal CS do visor para o leitor de cart√£o SD e, em seguida, executa a opera√ß√£o. </font><font style="vertical-align: inherit;">Isso significa que, ao enviar dados para a tela, n√£o podemos realizar nenhuma opera√ß√£o com o cart√£o SD e vice-versa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No momento, estamos fazendo tudo em um √∫nico segmento e estamos usando o bloqueio de transmiss√£o via SPI para a tela, para que n√£o haja transa√ß√µes simult√¢neas com o cart√£o SD e com a tela LCD. </font><font style="vertical-align: inherit;">De qualquer forma, existe uma alta probabilidade de carregarmos todos os recursos no momento do lan√ßamento.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifica√ß√£o do ESP-IDF</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se tentarmos inicializar a interface do cart√£o SD ap√≥s a inicializa√ß√£o do monitor, encontraremos um problema que impossibilita o carregamento do Odroid Go. </font><font style="vertical-align: inherit;">O ESP-IDF v4.0 n√£o suporta acesso compartilhado ao barramento SPI quando usado com um cart√£o SD. </font><font style="vertical-align: inherit;">Recentemente, os desenvolvedores adicionaram essa funcionalidade, mas ainda n√£o est√° em uma vers√£o est√°vel, portanto faremos uma pequena modifica√ß√£o no IDF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comente a linha 303 </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp-idf / components / driver / sdspi_host.c</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Initialize SPI bus</span>
<span class="hljs-keyword">esp_err_t</span> ret = spi_bus_initialize((<span class="hljs-keyword">spi_host_device_t</span>)slot, &amp;buscfg,<font></font>
    slot_config-&gt;dma_channel);<font></font>
<span class="hljs-keyword">if</span> (ret != ESP_OK) {<font></font>
    ESP_LOGD(TAG, <span class="hljs-string">"spi_bus_initialize failed with rc=0x%x"</span>, ret);
    <span class="hljs-comment">//return ret;</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ap√≥s fazer essa altera√ß√£o, ainda veremos um erro durante a inicializa√ß√£o, mas ele n√£o far√° mais com que o ESP32 seja reiniciado, porque o c√≥digo de erro n√£o se propaga acima.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializa√ß√£o</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57f/4f8/b0f/57f4f8b0fcca66e243637eeb68b39ff7.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/554/eae/9ec/554eae9ec4a3e850eb44e817e8b7b181.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Precisamos informar √† IDF quais pinos do ESP32 est√£o conectados ao leitor MicroSD para que ele configure corretamente o driver SPI subjacente, que realmente se comunica com o leitor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As notas gerais </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VSPI.XXXX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s√£o novamente usadas no </font><strong><font style="vertical-align: inherit;">diagrama</font></strong><font style="vertical-align: inherit;"> , mas podemos passar por elas para os n√∫meros de contato reais no ESP32. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A inicializa√ß√£o √© semelhante √† inicializa√ß√£o do LCD, mas em vez da estrutura geral de configura√ß√£o da SPI, usamos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdspi_slot_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , projetado para um cart√£o SD conectado via barramento da SPI. Configuramos os n√∫meros de contato correspondentes e as propriedades de montagem do cart√£o no sistema FatFS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A documenta√ß√£o do IDF n√£o recomenda o uso da fun√ß√£o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_vfs_fat_sdmmc_mount</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no c√≥digo do programa conclu√≠do. Essa √© uma fun√ß√£o de inv√≥lucro que realiza muitas opera√ß√µes para n√≥s, mas, at√© o momento, funciona normalmente e provavelmente nada mudar√° no futuro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O par√¢metro </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"/ sdcard"</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dessa fun√ß√£o define o ponto de montagem virtual do cart√£o SD, que usaremos como prefixo ao trabalhar com arquivos. Se tiv√©ssemos um arquivo chamado "test.txt" em nosso cart√£o SD, o caminho que usar√≠amos para vincular a ele seria "/sdcard/test.txt". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ap√≥s a inicializa√ß√£o da interface do cart√£o SD, a intera√ß√£o com os arquivos √© trivial: podemos simplesmente usar chamadas padr√£o para fun√ß√µes </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POSIX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o que √© muito conveniente.</font></font><br>
<br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">   8.3</a>,              .    ,   <b>fopen</b>   .        <b>make menuconfig</b>,       ,     <b>8.3</b>.</blockquote><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/62f/94a/d9462f94aeec7fbdce989e34967e637d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Criei </font><font style="vertical-align: inherit;">um sprite de 64x64 </font><font style="vertical-align: inherit;">em </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aseprite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (terr√≠vel) que usa apenas duas cores: completamente preto (pixel desativado) e completamente branco (pixel ativado). O Aseprite n√£o tem a op√ß√£o de salvar a cor RGB565 ou exportar como um bitmap bruto (ou seja, sem compress√£o e cabe√ßalhos de imagem), por isso eu exportei o sprite para um formato PNG tempor√°rio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, usando o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImageMagick,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> converti os dados em um arquivo PPM, que transformou a imagem em dados n√£o compactados brutos com um cabe√ßalho simples. Em seguida, abri a imagem em um editor hexadecimal, exclu√≠ o cabe√ßalho e converti a cor de 24 bits em 16 bits, excluindo todas as ocorr√™ncias de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x000000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e todas as ocorr√™ncias de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A ordem dos bytes aqui n√£o √© um problema, porque </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o s√£o alterados ao alterar a ordem dos bytes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O arquivo bruto pode ser baixado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">FILE* spriteFile = fopen(<span class="hljs-string">"/sdcard/key"</span>, <span class="hljs-string">"r"</span>);<font></font>
assert(spriteFile);<font></font>
<font></font>
<span class="hljs-keyword">uint16_t</span>* sprite = (<span class="hljs-keyword">uint16_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">64</span> * <span class="hljs-number">64</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>));<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i)<font></font>
{<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; ++j)<font></font>
	{<font></font>
		fread(sprite, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>), <span class="hljs-number">64</span> * <span class="hljs-number">64</span>, spriteFile);<font></font>
	}<font></font>
}<font></font>
<font></font>
fclose(spriteFile);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, abrimos o arquivo- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chave</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que </font><font style="vertical-align: inherit;">cont√©m bytes n√£o processados ‚Äã‚Äãe o lemos no buffer. </font><font style="vertical-align: inherit;">No futuro, carregaremos recursos de sprite de maneira diferente, mas para uma demonstra√ß√£o, isso √© suficiente.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> spriteRow = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = y; row &lt; y + <span class="hljs-number">64</span>; ++row)<font></font>
{<font></font>
	spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = x; col &lt; x + <span class="hljs-number">64</span>; ++col)<font></font>
	{<font></font>
		<span class="hljs-keyword">uint16_t</span> pixelColor = sprite[<span class="hljs-number">64</span> * spriteRow + spriteCol];<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pixelColor != <span class="hljs-number">0</span>)<font></font>
		{<font></font>
			gFramebuffer[row * LCD_WIDTH + col] = color;<font></font>
		}<font></font>
<font></font>
		++spriteCol;<font></font>
	}<font></font>
<font></font>
	++spriteRow;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para desenhar um sprite, percorremos iterativamente seu conte√∫do. </font><font style="vertical-align: inherit;">Se o pixel √© branco, desenh√°mo-lo na cor selecionada pelos bot√µes. </font><font style="vertical-align: inherit;">Se for preto, consideramos um plano de fundo e n√£o desenhamos.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seu navegador n√£o suporta v√≠deo HTML5.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_4/media/sprite_drawing.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A c√¢mera do meu telefone distorce bastante as cores. </font><font style="vertical-align: inherit;">E desculpe por sacudi-la. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para testar a grava√ß√£o da imagem, moveremos a tecla para algum lugar da tela, mudaremos sua cor e, em seguida, gravaremos o buffer de quadro no cart√£o SD para que possa ser visualizado no computador.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (input.menu)<font></font>
{<font></font>
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* snapFilename = <span class="hljs-string">"/sdcard/framebuf"</span>;<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Writing snapshot to %s"</span>, snapFilename);<font></font>
<font></font>
	FILE* snapFile = fopen(snapFilename, <span class="hljs-string">"wb"</span>);<font></font>
	assert(snapFile);<font></font>
<font></font>
		fwrite(gFramebuffer, <span class="hljs-keyword">sizeof</span>(gFramebuffer[<span class="hljs-number">0</span>]), LCD_WIDTH * LCD_HEIGHT, snapFile);<font></font>
	}<font></font>
<font></font>
	fclose(snapFile);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pressionar a tecla Menu salva o conte√∫do do buffer de quadros em um arquivo chamado </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">framebuf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Como ser√° um buffer de quadro bruto, os pixels ainda permanecer√£o no formato RGB565 com a ordem dos bytes invertida. </font><font style="vertical-align: inherit;">Podemos novamente usar o ImageMagick para converter esse formato em PNG para visualiz√°-lo em um computador.</font></font><br>
<br>
<pre><code class="cpp hljs">convert -depth <span class="hljs-number">16</span> -size <span class="hljs-number">320</span>x240+<span class="hljs-number">0</span> -endian msb rgb565:FRAMEBUF snap.png</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, podemos implementar leitura / grava√ß√£o no formato BMP / PNG e livrar-nos de todo esse barulho com o ImageMagick, mas este √© apenas um c√≥digo de demonstra√ß√£o. </font><font style="vertical-align: inherit;">At√© agora, ainda n√£o decidi qual formato de arquivo eu quero usar para armazenar sprites.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bd/09c/e66/0bd09ce669a61276676a87b01c15e6f2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° ele! </font><font style="vertical-align: inherit;">O buffer de quadro do Odroid Go √© exibido no computador de mesa.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refer√™ncias</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid esquem√°tico</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documenta√ß√£o ESP-IDF: SDMMC</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 5: bateria</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Odroid Go possui uma bateria de √≠ons de l√≠tio, para que possamos criar um jogo que voc√™ pode jogar em qualquer lugar. </font><font style="vertical-align: inherit;">Essa √© uma ideia tentadora para algu√©m que jogou o primeiro Gameboy quando crian√ßa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, precisamos de uma maneira de solicitar o n√≠vel da bateria do Odroid Go. </font><font style="vertical-align: inherit;">A bateria est√° conectada ao contato no ESP32, para que possamos ler a tens√£o para ter uma id√©ia aproximada do tempo restante de opera√ß√£o.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esquema</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f2/ceb/13b/1f2ceb13bf408d8773f22047464e4e66.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O diagrama mostra </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conectado √† </font><font style="vertical-align: inherit;">tens√£o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ap√≥s ser puxado para o terra atrav√©s de um resistor. Dois resistores ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R21</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R23</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) formam um divisor de tens√£o semelhante ao usado na cruz do gamepad; os resistores novamente t√™m a mesma resist√™ncia, de modo que a tens√£o √© metade da original. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devido ao divisor de tens√£o, o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> l√™ uma tens√£o igual √† metade do </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Provavelmente, isso √© feito porque os contatos do ADC no ESP32 n√£o conseguem ler a alta tens√£o da bateria de √≠on de l√≠tio (4,2 V com carga m√°xima). Seja como for, isso significa que, para obter a tens√£o verdadeira, √© necess√°rio dobrar a tens√£o lida no ADC (ADC).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao ler o valor de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> obtemos um valor digital, mas perdemos o valor anal√≥gico que ele representa. Precisamos de uma maneira de interpretar um valor digital com um ADC na forma de uma tens√£o anal√≥gica f√≠sica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O IDF permite calibrar o ADC, que tenta fornecer um n√≠vel de tens√£o com base na tens√£o de refer√™ncia. Essa tens√£o de refer√™ncia ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vref</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) √© de 1100 mV por padr√£o, mas devido √†s caracter√≠sticas f√≠sicas, cada dispositivo √© um pouco diferente. O ESP32 no Odroid Go possui uma Vref definida manualmente, ‚Äúpiscou‚Äù no eFuse, que podemos usar como uma Vref mais precisa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O procedimento ser√° o seguinte: primeiro, configuraremos a calibra√ß√£o do ADC e, quando quisermos ler a tens√£o, coletaremos um certo n√∫mero de amostras (por exemplo, 20) para calcular as leituras m√©dias; ent√£o usamos o IDF para converter essas leituras em voltagem. O c√°lculo da m√©dia elimina o ru√≠do e fornece leituras mais precisas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, n√£o h√° conex√£o linear entre tens√£o e carga da bateria. Quando a carga diminui, a tens√£o cai, quando aumenta, aumenta, mas de maneira imprevis√≠vel. Tudo o que se pode dizer: se a tens√£o estiver abaixo de 3,6 V, a bateria estar√° descarregada, mas √© surpreendentemente dif√≠cil converter com precis√£o o n√≠vel de tens√£o em uma porcentagem da carga da bateria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para o nosso projeto, isso n√£o √© particularmente importante. </font><font style="vertical-align: inherit;">Podemos implementar uma aproxima√ß√£o aproximada para informar o jogador sobre a necessidade de carregar rapidamente o dispositivo, mas n√£o sofreremos, tentando obter a porcentagem exata.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED de status</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/0ad/2d6/b520ad2d63e2a4c59924debb6c3613bc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No painel frontal da tela do Odroid Go, h√° um LED azul (LED), que podemos usar para qualquer finalidade. Voc√™ pode mostrar a eles que o dispositivo est√° ligado e funcionando, mas, neste caso, ao reproduzir no escuro, um LED azul brilhante brilhar√° em seu rosto. Portanto, vamos us√°-lo para indicar uma carga baixa da bateria (embora eu prefira uma cor vermelha ou √¢mbar). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para usar o LED, voc√™ precisa definir </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como uma sa√≠da e, em seguida, aplicar um sinal alto ou baixo para ligar e desligar o LED. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penso que um </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resistor de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2 kŒ© ( </font><strong><font style="vertical-align: inherit;">resistor limitador de corrente</font></strong><font style="vertical-align: inherit;"> ) ser√° suficiente para n√£o queimarmos o LED e fornecermos muita corrente do pino GPIO.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O LED tem uma resist√™ncia bastante baixa, portanto, se for aplicado 3,3 V, queimaremos alterando a corrente. </font><font style="vertical-align: inherit;">Para proteger contra isso, um resistor geralmente √© conectado em s√©rie com o LED. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, os resistores limitadores de corrente para LEDs geralmente s√£o muito inferiores a 2 kŒ©, ent√£o eu n√£o entendo por que o resistor </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© uma resist√™ncia t√£o grande.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializa√ß√£o</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> BATTERY_READ_PIN = ADC1_GPIO36_CHANNEL;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BATTERY_LED_PIN = GPIO_NUM_2;<font></font>
<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">esp_adc_cal_characteristics_t</span> gCharacteristics;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeBatteryReader</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-comment">// Configure LED</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; BATTERY_LED_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure ADC</span><font></font>
	{<font></font>
		adc1_config_width(ADC_WIDTH_BIT_12);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
<font></font>
    	<span class="hljs-keyword">esp_adc_cal_value_t</span> type = esp_adc_cal_characterize(<font></font>
    		ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_12, <span class="hljs-number">1100</span>, &amp;gCharacteristics);<font></font>
<font></font>
    	assert(type == ESP_ADC_CAL_VAL_EFUSE_VREF);<font></font>
    }<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Battery reader initialized"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, configuramos o LED GPIO como uma sa√≠da, para que possamos troc√°-lo, se necess√°rio. </font><font style="vertical-align: inherit;">Em seguida, configuramos o pino ADC, como fizemos no caso de uma cruz - com uma largura de bit de 12 e atenua√ß√£o m√≠nima. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_characterize</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> realiza c√°lculos para caracterizar o ADC, para que possamos converter posteriormente as leituras digitais em estresse f√≠sico.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leitura da bateria</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">Odroid_ReadBatteryLevel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SAMPLE_COUNT = <span class="hljs-number">20</span>;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> raw = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sampleIndex = <span class="hljs-number">0</span>; sampleIndex &lt; SAMPLE_COUNT; ++sampleIndex)<font></font>
	{<font></font>
		raw += adc1_get_raw(BATTERY_READ_PIN);<font></font>
	}<font></font>
<font></font>
	raw /= SAMPLE_COUNT;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> voltage = <span class="hljs-number">2</span> * esp_adc_cal_raw_to_voltage(raw, &amp;gCharacteristics);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> voltage;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Coletamos vinte amostras brutas do ADC do contato do ADC e as dividimos para obter o valor m√©dio. Como mencionado acima, isso ajuda a reduzir o ru√≠do das leituras. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, usamos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_raw_to_voltage</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para converter o valor bruto para a tens√£o real. Devido ao divisor de tens√£o mencionado acima, dobramos o valor de retorno: o valor de leitura ser√° metade da tens√£o real da bateria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em vez de encontrar maneiras complicadas de converter essa voltagem em uma porcentagem da carga da bateria, retornaremos uma voltagem simples. Deixe a fun√ß√£o de chamada decidir por si mesma o que fazer com a tens√£o - transform√°-la em uma porcentagem da carga ou simplesmente interpret√°-la como um valor alto ou baixo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O valor √© retornado em milivolts, portanto, a fun√ß√£o de chamada precisa executar a convers√£o apropriada. </font><font style="vertical-align: inherit;">Isso evita o estouro da b√≥ia.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configura√ß√£o de LED</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_EnableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_DisableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas duas fun√ß√µes simples s√£o suficientes para usar o LED. </font><font style="vertical-align: inherit;">Podemos ligar ou desligar a luz. </font><font style="vertical-align: inherit;">Deixe a fun√ß√£o de chamada decidir quando faz√™-lo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Poder√≠amos criar uma tarefa que monitore periodicamente a tens√£o da bateria e, consequentemente, altere o status do LED, mas √© melhor eu interrogar a tens√£o da bateria em nosso ciclo principal e decidir como definir a tens√£o da bateria a partir da√≠.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint32_t</span> batteryLevel = Odroid_ReadBatteryLevel();<font></font>
<font></font>
<span class="hljs-keyword">if</span> (batteryLevel &lt; <span class="hljs-number">3600</span>)<font></font>
{<font></font>
	Odroid_EnableBatteryLight();<font></font>
}<font></font>
<span class="hljs-keyword">else</span><font></font>
{<font></font>
	Odroid_DisableBatteryLight();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos simplesmente solicitar o n√≠vel da bateria no ciclo principal e, se a tens√£o estiver abaixo do valor limite, acenda o LED, indicando a necessidade de carregamento. </font><font style="vertical-align: inherit;">Com base nos materiais estudados, posso dizer que 3600 mV (3,6 V) √© um bom sinal de baixa carga de baterias de √≠on-l√≠tio, mas as baterias s√£o complexas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refer√™ncias</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid esquem√°tico</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documenta√ß√£o ESP-IDF: ADC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caracter√≠sticas da bateria</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 6: som</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O passo final para obter uma interface completa para todo o hardware Odroid Go √© escrever uma camada de som. Depois de terminar, podemos come√ßar a avan√ßar para uma programa√ß√£o mais geral do jogo, menos relacionada √† programa√ß√£o para o Odroid. Toda intera√ß√£o com perif√©ricos ser√° realizada atrav√©s das fun√ß√µes </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devido √† minha falta de experi√™ncia com programa√ß√£o de som e √† falta de boa documenta√ß√£o por parte da IDF, ao trabalhar em um projeto, a implementa√ß√£o do som levou mais tempo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por fim, n√£o foi necess√°rio muito c√≥digo para reproduzir o som. A maior parte do tempo foi gasta em como converter os dados de √°udio no ESP32 desejado e em como configurar o driver de √°udio ESP32 para corresponder √† configura√ß√£o de hardware.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No√ß√µes b√°sicas de som digital</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O som digital consiste em duas partes: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grava√ß√£o</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reprodu√ß√£o</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registro</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para gravar som em um computador, primeiro precisamos convert√™-lo do espa√ßo de um sinal cont√≠nuo (anal√≥gico) para o espa√ßo de um sinal discreto (digital). </font><font style="vertical-align: inherit;">Essa tarefa √© realizada usando um </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conversor anal√≥gico-digital (ADC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (sobre o qual falamos quando trabalhamos com a cruz na Parte 2). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O ADC recebe uma </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amostra da</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> onda recebida e digitaliza o valor, que pode ser salvo em um arquivo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toque</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um arquivo de som digital pode ser retornado do espa√ßo digital para o anal√≥gico usando um </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conversor Digital-Anal√≥gico (DAC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">O DAC pode reproduzir valores apenas em um determinado intervalo. </font><font style="vertical-align: inherit;">Por exemplo, um DAC de 8 bits com uma fonte de 3,3 V pode emitir tens√µes anal√≥gicas na faixa de 0 a 3,3 mV em etapas de 12,9 mV (3,3 V dividido por 256). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O DAC pega os valores digitais e os converte novamente em voltagem, que pode ser transmitida a um amplificador, alto-falante ou qualquer outro dispositivo capaz de receber um sinal de √°udio anal√≥gico.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taxa de amostragem</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao gravar som anal√≥gico atrav√©s do ADC, as amostras s√£o coletadas em uma certa frequ√™ncia e cada amostra √© um "instant√¢neo" do sinal sonoro em um determinado momento. Este par√¢metro √© chamado de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frequ√™ncia de amostragem</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e √© medido em </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hertz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quanto maior a frequ√™ncia de amostragem, mais precisamente recriamos as frequ√™ncias do sinal original. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O teorema de Nyquist-Shannon (Kotelnikov)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afirma (em termos simples) que a frequ√™ncia de amostragem deve ser duas vezes a maior frequ√™ncia de sinal que queremos gravar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O ouvido humano pode ouvir aproximadamente na faixa </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de 20 Hz a 20 kHz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , portanto a frequ√™ncia de amostragem de </font><strong><font style="vertical-align: inherit;">44,1 kHz √©</font></strong><font style="vertical-align: inherit;"> mais frequentemente usada para recriar m√∫sica de alta qualidade</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que √© um pouco mais que o dobro da frequ√™ncia m√°xima que o ouvido humano pode reconhecer. Isso garante que um conjunto completo de frequ√™ncias e voz do instrumento seja recriado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, cada amostra ocupa espa√ßo no arquivo, portanto, n√£o podemos selecionar a taxa m√°xima de amostragem. No entanto, se voc√™ n√£o coletar amostras com rapidez suficiente, poder√° perder informa√ß√µes importantes. A frequ√™ncia de amostragem selecionada deve depender das frequ√™ncias presentes no som recriado. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A reprodu√ß√£o deve ser executada na mesma frequ√™ncia de amostragem que a fonte, caso contr√°rio, o som e sua dura√ß√£o ser√£o diferentes.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que dez segundos de som foram gravados a uma frequ√™ncia de amostragem de 16 kHz. </font><font style="vertical-align: inherit;">Se voc√™ o reproduzir com uma frequ√™ncia de 8 kHz, seu tom ser√° mais baixo e a dura√ß√£o ser√° de vinte segundos. </font><font style="vertical-align: inherit;">Se voc√™ o tocar com uma frequ√™ncia de amostragem de 32 kHz, o tom aud√≠vel ser√° mais alto e o som em si durar√° cinco segundos. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este v√≠deo mostra a diferen√ßa nas taxas de amostra com exemplos.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profundidade de bits</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A frequ√™ncia de amostragem √© apenas metade da equa√ß√£o. O som tamb√©m possui uma </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">profundidade de bits</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou seja, o n√∫mero de bits por amostra. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando o ADC captura uma amostra de um sinal de √°udio, ele deve converter esse valor anal√≥gico em digital, e o intervalo de valores capturados depende do n√∫mero de bits usados. 8 bits (256 valores), 16 bits (65.526 valores), 32 bits (4.294.967.296 valores) etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O n√∫mero de bits por amostra est√° relacionado √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faixa din√¢mica do</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> som, ou seja, com as partes mais altas e silenciosas. A profundidade de bits mais comum para m√∫sica √© de 16 bits. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante a reprodu√ß√£o, √© necess√°rio fornecer a mesma profundidade de bits da fonte, caso contr√°rio, o som e sua dura√ß√£o ser√£o alterados.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, voc√™ tem um arquivo de √°udio com quatro amostras armazenadas como 8 bits: [0x25, 0xAB, 0x34, 0x80]. </font><font style="vertical-align: inherit;">Se voc√™ tentar reproduzi-los como se fossem de 16 bits, obter√° apenas duas amostras: [0x25AB, 0x3480]. </font><font style="vertical-align: inherit;">Isso n√£o apenas levar√° a valores incorretos das amostras de som, mas tamb√©m reduzir√° pela metade o n√∫mero de amostras e, portanto, a dura√ß√£o do som. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tamb√©m √© importante conhecer o formato das amostras. </font><font style="vertical-align: inherit;">8 bits n√£o assinado, 8 bits n√£o assinado, 16 bits n√£o assinado, 16 bits n√£o assinado, etc. </font><font style="vertical-align: inherit;">Geralmente, 8 bits n√£o s√£o assinados e 16 bits s√£o assinados. </font><font style="vertical-align: inherit;">Se estiverem confusos, o som ficar√° muito distorcido. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este v√≠deo mostra a diferen√ßa de profundidade de bits com exemplos.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arquivos Wav</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na maioria das vezes, os dados de √°udio n√£o processados ‚Äã‚Äãem um computador s√£o armazenados no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">formato WAV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que possui um cabe√ßalho simples que descreve o formato do som (frequ√™ncia de amostragem, profundidade de bits, tamanho etc.), seguido pelos pr√≥prios dados de √°udio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O som n√£o √© compactado (ao contr√°rio de formatos como MP3), para que possamos reproduzi-lo facilmente sem a necessidade de uma biblioteca de codecs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O principal problema com os arquivos WAV √© que, devido √† falta de compacta√ß√£o, eles podem ser bem grandes. O tamanho do arquivo est√° diretamente relacionado √† dura√ß√£o, taxa de amostragem e profundidade de bits. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamanho = Dura√ß√£o (em segundos) x Taxa de amostragem (amostras / s) x Profundidade de bits (bit / amostra)</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A frequ√™ncia de amostragem afeta mais o tamanho do arquivo; portanto, a maneira mais f√°cil de economizar espa√ßo √© selecionar um valor suficientemente baixo. </font><font style="vertical-align: inherit;">Criaremos um som da velha escola, de modo que uma baixa frequ√™ncia de amostragem nos conv√©m.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I2S</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O ESP32 possui perif√©ricos, devido aos quais √© relativamente simples fornecer uma interface com equipamento de √°udio: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inter-IC Sound (I2S)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O protocolo I2S √© bastante simples e consiste em apenas tr√™s sinais: um sinal de rel√≥gio, uma escolha de canais (esquerdo ou direito) e tamb√©m a pr√≥pria linha de dados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A frequ√™ncia do rel√≥gio depende da frequ√™ncia de amostragem, profundidade de bits e n√∫mero de canais. As batidas s√£o substitu√≠das para cada bit de dados; portanto, para uma reprodu√ß√£o adequada do som, voc√™ deve definir a frequ√™ncia do rel√≥gio de acordo. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frequ√™ncia do rel√≥gio = Frequ√™ncia de amostragem (amostras / s) x Profundidade de bits (bits / amostra) x N√∫mero de canais</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O driver I2S do microcontrolador ESP32 possui dois modos poss√≠veis: ele pode enviar dados para contatos conectados a um receptor I2S externo, que pode decodificar o protocolo e transferir dados para o amplificador ou pode transferir dados para um DAC ESP32 interno que emite um sinal anal√≥gico que pode ser transmitido para o amplificador. amplificador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Odroid Go n√£o possui nenhum decodificador I2S na placa; portanto, teremos que usar o ESP32 DAC interno de 8 bits, ou seja, devemos usar som de 8 bits. </font><font style="vertical-align: inherit;">O dispositivo possui dois DACs, um conectado ao </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e o outro ao </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O procedimento fica assim:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transferimos dados de √°udio para o driver I2S</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O driver I2S envia dados de √°udio para o DAC interno de 8 bits</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O DAC interno emite um sinal anal√≥gico</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O sinal anal√≥gico √© transmitido ao amplificador de som</font></font></li>
<li>      </li>
<li>  </li>
</ol><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/d93/a8e/2d9d93a8ed6eceb35846c0f31e336ec9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se observarmos o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">circuito de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √°udio no </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Odroid Go</font></a><font style="vertical-align: inherit;"> , veremos dois pinos GPIO ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) conectados √†s entradas do amplificador de som ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAM8304A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O IO25</font></font></strong><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
tamb√©m </font><strong><font style="vertical-align: inherit;">est√°</font></strong><font style="vertical-align: inherit;"> conectado ao sinal </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD do</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> amplificador, ou seja, o contato que liga ou desliga o amplificador (sinal baixo significa desligamento). As sa√≠das do amplificador est√£o conectadas a um alto-falante ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembre-se de que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s√£o sa√≠das de DACs ESP32 de 8 bits, ou seja, um DAC est√° conectado ao </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e o outro ao </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s√£o</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entradas diferenciais do</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> amplificador de som. As entradas diferenciais s√£o usadas para reduzir o ru√≠do causado pela </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interfer√™ncia eletromagn√©tica</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Qualquer ru√≠do presente em um sinal tamb√©m estar√° presente em outro. Um sinal √© subtra√≠do de outro, o que elimina o ru√≠do. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ observar as </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especifica√ß√µes do amplificador de som</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ele possui um </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">circuito de aplica√ß√µes t√≠picas</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que √© a maneira recomendada pelo fabricante de usar o amplificador.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/044/d2a/323/044d2a323366c5ddb3c3b87f918bf5f9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele recomenda conectar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao terra, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao sinal de entrada e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao sinal liga / desliga. Se houver um ru√≠do de 0,005 V, em seguida, com </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- </font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0V + 0.005V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ser√£o lidos </font><font style="vertical-align: inherit;">, e com </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN + 0.005V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Os sinais de entrada devem ser subtra√≠dos um do outro e obter o valor real do sinal ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sem ru√≠do. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, os designers do Odroid Go n√£o usaram a configura√ß√£o recomendada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais uma vez, olhando o circuito Odroid Go, vemos que os projetistas conectaram a sa√≠da DAC √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN -</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e que a mesma sa√≠da DAC est√° conectada ao </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Este √© um sinal de desligamento com um n√≠vel baixo ativo; portanto, para o amplificador funcionar, √© necess√°rio definir um sinal alto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso significa que, para usar o amplificador, n√£o devemos usar o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como DAC, mas como uma sa√≠da GPIO com um sinal sempre alto. No entanto, neste caso, um sinal alto √© definido como </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o que n√£o √© recomendado pela especifica√ß√£o do amplificador (ele deve ser aterrado). Em seguida, devemos usar o DAC conectado ao </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pois nossa sa√≠da I2S deve ser alimentada ao </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Isso significa que n√£o obteremos a redu√ß√£o de ru√≠do necess√°ria, porque </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o </font><strong><font style="vertical-align: inherit;">est√°</font></strong><font style="vertical-align: inherit;"> conectado ao terra. O ru√≠do suave emana constantemente dos alto-falantes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Precisamos garantir a configura√ß√£o correta do driver I2S, porque queremos usar apenas o DAC conectado ao </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Se </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">us√°ssemos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um DAC conectado ao </font><strong><font style="vertical-align: inherit;">IO25</font></strong><font style="vertical-align: inherit;"> , ele desligaria constantemente o sinal do amplificador e o som seria terr√≠vel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m dessa estranheza, ao usar um DAC interno de 8 bits, o driver I2S no ESP32 exige que amostras de 16 bits sejam transmitidas a ele, mas envia apenas o byte alto ao DAC de 8 bits. </font><font style="vertical-align: inherit;">Portanto, precisamos pegar nosso som de 8 bits e col√°-lo em um buffer duas vezes maior, enquanto o buffer ficar√° meio vazio. </font><font style="vertical-align: inherit;">Em seguida, passamos para o driver I2S e ele passa ao DAC o byte alto de cada amostra. </font><font style="vertical-align: inherit;">Infelizmente, isso significa que temos que "pagar" por 16 bits, mas s√≥ podemos usar 8 bits.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multitarefa</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, o jogo n√£o pode funcionar em um n√∫cleo, como eu originalmente queria, porque parece haver um bug no driver I2S. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O driver I2S deve usar DMA (como o driver SPI), ou seja, podemos iniciar a transfer√™ncia do I2S e continuar nosso trabalho enquanto o driver I2S est√° transmitindo dados de √°udio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas, em vez disso, a CPU √© bloqueada pela dura√ß√£o do som, o que √© completamente inadequado para o jogo. Imagine que voc√™ pressiona o bot√£o de salto e o sprite do jogador interrompe seu movimento por 100 ms enquanto o som do salto est√° sendo reproduzido.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver esse problema, podemos aproveitar o fato de que existem dois n√∫cleos a bordo do ESP32. </font><font style="vertical-align: inherit;">Podemos criar uma tarefa (ou seja, um thread) no segundo n√∫cleo, que lidar√° com a reprodu√ß√£o de som. </font><font style="vertical-align: inherit;">Gra√ßas a isso, podemos transferir o ponteiro para o buffer de som da tarefa principal do jogo para a tarefa de som, e a tarefa de som inicia a transfer√™ncia do I2S e fica bloqueada durante a reprodu√ß√£o do som. </font><font style="vertical-align: inherit;">Mas a tarefa principal no primeiro n√∫cleo (com processamento e renderiza√ß√£o de entrada) continuar√° sendo executada sem bloqueio.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializa√ß√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sabendo disso, podemos iniciar corretamente o driver I2S. </font><font style="vertical-align: inherit;">Para fazer isso, voc√™ precisa de apenas algumas linhas de c√≥digo, mas a dificuldade √© descobrir quais par√¢metros voc√™ precisa definir para a reprodu√ß√£o adequada do som.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> AUDIO_AMP_SD_PIN = GPIO_NUM_25;<font></font>
<font></font>
<span class="hljs-keyword">static</span> QueueHandle_t gQueue;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlayTask</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span>
</span>{
	<span class="hljs-keyword">for</span>(;;)<font></font>
	{<font></font>
		QueueData data;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (xQueueReceive(gQueue, &amp;data, <span class="hljs-number">10</span>))<font></font>
		{<font></font>
			<span class="hljs-keyword">size_t</span> bytesWritten;<font></font>
			i2s_write(I2S_NUM_0, data.buffer, data.length, &amp;bytesWritten, portMAX_DELAY);<font></font>
			i2s_zero_dma_buffer(I2S_NUM_0);<font></font>
		}<font></font>
<font></font>
		vTaskDelay(<span class="hljs-number">1</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeAudio</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-comment">// Configure the amplifier shutdown signal</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; AUDIO_AMP_SD_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
<font></font>
		gpio_set_level(AUDIO_AMP_SD_PIN, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure the I2S driver</span><font></font>
	{<font></font>
		<span class="hljs-keyword">i2s_config_t</span> i2sConfig= {};<font></font>
<font></font>
		i2sConfig.mode = I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN;<font></font>
		i2sConfig.sample_rate = <span class="hljs-number">5012</span>;<font></font>
		i2sConfig.bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT;<font></font>
		i2sConfig.communication_format = I2S_COMM_FORMAT_I2S_MSB;<font></font>
		i2sConfig.channel_format = I2S_CHANNEL_FMT_ONLY_LEFT;<font></font>
		i2sConfig.dma_buf_count = <span class="hljs-number">8</span>;<font></font>
		i2sConfig.dma_buf_len = <span class="hljs-number">64</span>;<font></font>
<font></font>
		ESP_ERROR_CHECK(i2s_driver_install(I2S_NUM_0, &amp;i2sConfig, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>));<font></font>
		ESP_ERROR_CHECK(i2s_set_dac_mode(I2S_DAC_CHANNEL_LEFT_EN));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Create task for playing sounds so that our main task isn't blocked</span><font></font>
	{<font></font>
		gQueue = xQueueCreate(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(QueueData));<font></font>
		assert(gQueue);<font></font>
<font></font>
		BaseType_t result = xTaskCreatePinnedToCore(&amp;PlayTask, <span class="hljs-string">"I2S Task"</span>, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>);<font></font>
		assert(result == pdPASS);<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, configuramos o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (que est√° conectado ao sinal de desligamento do amplificador) como uma sa√≠da para que ele possa controlar o amplificador de som e aplicamos um sinal alto a ele para ligar o amplificador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, configuramos e instalamos o pr√≥prio driver I2S. </font><font style="vertical-align: inherit;">Analisarei cada parte da configura√ß√£o linha por linha, porque cada uma das linhas requer explica√ß√£o:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modo</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definimos o driver como mestre (controle do barramento), transmissor (porque transferimos dados para os destinat√°rios) e o configuramos para usar o DAC de 8 bits interno (porque a placa Odroid Go n√£o possui um DAC externo).</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">taxa de amostragem</font></font><ul>
<li>    5012,      ,   ,      .   ,      ,          .    -,           2500 .</li>
</ul></li>
<li>bits_per_sample<ul>
<li>  ,    ESP32  8-,   I2S ,      16    ,   8     .</li>
</ul></li>
<li>communication_format<ul>
<li>      ,   ,   -   ,   8-      16- .</li>
</ul></li>
<li>channel_format<ul>
<li> GPIO,    <strong>IN+</strong>   ‚Äî  <strong>IO26</strong>,       ¬´¬ª   I2S.  ,  I2S      ,      <strong>IO25</strong>,      ,          .</li>
</ul></li>
<li>dma_buf_count  dma_buf_len<ul>
<li>  DMA-   ( )  ,        ,   ,        IDF.       ,     .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, criamos uma fila - √© assim que o FreeRTOS envia dados entre tarefas. Colocamos dados na fila de uma tarefa e os extra√≠mos da fila de outra tarefa. Crie uma estrutura chamada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que combine o ponteiro com o buffer de som e o comprimento do buffer em uma √∫nica estrutura que possa ser enfileirada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, crie uma tarefa que seja executada no segundo n√∫cleo. N√≥s o conectamos √† fun√ß√£o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que executa a reprodu√ß√£o do som. A tarefa em si √© um loop sem fim que verifica constantemente se h√° dados na fila. Se estiverem, ela os envia ao driver I2S para que possam ser reproduzidos. Ele bloquear√° a chamada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i2s_write</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e isso nos conv√©m, porque a tarefa √© executada em um kernel separado do thread principal do jogo. </font><font style="vertical-align: inherit;">√â necess√°ria </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
uma chamada para </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i2s_zero_dma_buffer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que, ap√≥s a conclus√£o da reprodu√ß√£o, n√£o haja sons nos alto-falantes. </font><font style="vertical-align: inherit;">N√£o sei se isso √© um bug do driver I2S ou o comportamento esperado, mas sem ele, ap√≥s o t√©rmino da reprodu√ß√£o do buffer de som, o alto-falante emite um sinal de lixo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tocar m√∫sica</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_PlayAudio</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span>* buffer, <span class="hljs-keyword">size_t</span> length)</span>
</span>{<font></font>
	QueueData data = {};<font></font>
<font></font>
	data.buffer = buffer;<font></font>
	data.length = length;<font></font>
<font></font>
	xQueueSendToBack(gQueue, &amp;data, portMAX_DELAY);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devido ao fato de toda a configura√ß√£o j√° estar conclu√≠da, a chamada para a fun√ß√£o de reprodu√ß√£o do buffer de som √© extremamente simples, porque o trabalho principal √© realizado em outra tarefa. </font><font style="vertical-align: inherit;">Colocamos o ponteiro no buffer e o comprimento do buffer na estrutura </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e, em seguida, o colocamos na fila usada pela fun√ß√£o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devido a esse padr√£o de opera√ß√£o, um buffer de som deve concluir a reprodu√ß√£o antes de iniciar o segundo buffer. </font><font style="vertical-align: inherit;">Portanto, se um salto e um disparo ocorrerem simultaneamente, o primeiro som ser√° reproduzido antes do segundo, e n√£o simultaneamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Provavelmente, no futuro, misturarei sons de quadros diferentes no buffer de som que √© transmitido ao driver I2S. </font><font style="vertical-align: inherit;">Isso permitir√° que voc√™ reproduza v√°rios sons simultaneamente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo</font></font></h2><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geraremos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
nossos pr√≥prios efeitos sonoros usando o </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">jsfxr</font></a><font style="vertical-align: inherit;"> , uma ferramenta projetada especificamente para gerar o tipo de som do jogo que precisamos. </font><font style="vertical-align: inherit;">Podemos definir diretamente a frequ√™ncia de amostragem e a profundidade de bits e, em seguida, enviar o arquivo WAV. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu criei um efeito de som de salto simples que se assemelha ao som do salto de Mario. </font><font style="vertical-align: inherit;">Possui uma frequ√™ncia de amostragem de 5012 (como configuramos durante a inicializa√ß√£o) e uma profundidade de bits de 8 (porque o DAC √© de 8 bits).</font></font><br>
<br>
<div class="oembed"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://austinmorlan.com/posts/embedded_game_programming_6/media/jump.wav</font></font></a></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em vez de analisar o arquivo WAV diretamente no c√≥digo, faremos algo semelhante ao que fizemos para carregar o sprite na demonstra√ß√£o da Parte 4: removeremos o cabe√ßalho WAV do arquivo usando o editor hexadecimal. Gra√ßas a isso, o arquivo lido no cart√£o SD ser√° apenas dados brutos. Al√©m disso, n√£o leremos a dura√ß√£o do som, escreveremos no c√≥digo. No futuro, carregaremos recursos de som de maneira diferente, mas isso √© suficiente para a demonstra√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O arquivo bruto pode ser baixado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Load sound effect</span>
<span class="hljs-keyword">uint16_t</span>* soundBuffer;
<span class="hljs-keyword">int</span> soundEffectLength = <span class="hljs-number">1441</span>;<font></font>
{<font></font>
	FILE* soundFile = fopen(<span class="hljs-string">"/sdcard/jump"</span>, <span class="hljs-string">"r"</span>);<font></font>
	assert(soundFile);<font></font>
<font></font>
	<span class="hljs-keyword">uint8_t</span>* soundEffect = <span class="hljs-built_in">malloc</span>(soundEffectLength);<font></font>
	assert(soundEffect);<font></font>
<font></font>
	soundBuffer = <span class="hljs-built_in">malloc</span>(soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	assert(soundBuffer);<font></font>
<font></font>
	fread(soundEffect, soundEffectLength, <span class="hljs-number">1</span>, soundFile);<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; soundEffectLength; ++i)<font></font>
    {<font></font>
        <span class="hljs-comment">// 16 bits required but only MSB is actually sent to the DAC</span>
        soundBuffer[i] = (soundEffect[i] &lt;&lt; <span class="hljs-number">8u</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Carregamos os dados de 8 bits </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> buffer </font><strong><font style="vertical-align: inherit;">soundEffect de</font></strong><font style="vertical-align: inherit;"> 8 bits e </font><strong><font style="vertical-align: inherit;">copiamos</font></strong><font style="vertical-align: inherit;"> esses dados no buffer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soundBuffer de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16 bits </font><font style="vertical-align: inherit;">, onde os dados ser√£o armazenados nos oito bits mais altos. </font><font style="vertical-align: inherit;">Repito - isso √© necess√°rio devido aos recursos da implementa√ß√£o do IDF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de criar um buffer de 16 bits, podemos tocar o som de um clique de um bot√£o. </font><font style="vertical-align: inherit;">Seria l√≥gico usar o bot√£o de volume para isso.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> lastState = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (;;)<font></font>
{<font></font>
	[...]<font></font>
<font></font>
	<span class="hljs-keyword">int</span> thisState = input.volume;<font></font>
<font></font>
	<span class="hljs-keyword">if</span> ((thisState == <span class="hljs-number">1</span>) &amp;&amp; (thisState != lastState))<font></font>
	{<font></font>
		Odroid_PlayAudio(soundBuffer, soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	}<font></font>
<font></font>
	lastState = thisState;<font></font>
<font></font>
	[...]<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Monitoramos o estado do bot√£o para que, acidentalmente, com um clique no bot√£o, voc√™ n√£o chame o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid_PlayAudio</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> acidentalmente </font><font style="vertical-align: inherit;">v√°rias vezes.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seu navegador n√£o suporta v√≠deo HTML5.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_6/media/demo.mp4" type="video/mp4"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonte</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo o c√≥digo fonte est√° </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refer√™ncias</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid esquem√°tico</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ficha de dados do amplificador de √°udio</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documenta√ß√£o ESP-IDF: DAC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documenta√ß√£o ESP-IDF: I2S</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formato de arquivo WAVE</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√≠deo: Explica√ß√£o da profundidade de bits</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√≠deo: Explica√ß√£o da taxa de amostra</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt503854/index.html">Use SIL ao m√°ximo</a></li>
<li><a href="../pt503858/index.html">O livro "Terraform: infraestrutura no n√≠vel do c√≥digo"</a></li>
<li><a href="../pt503860/index.html">Configurando o ambiente de rede neural Mask R-CNN</a></li>
<li><a href="../pt503864/index.html">Organiza√ß√£o de Sabores na Flutter</a></li>
<li><a href="../pt503866/index.html">Desenvolvimento de roteiro publicado Zextras Suite for 2020</a></li>
<li><a href="../pt503880/index.html">Como aprendi a n√£o me preocupar e amei a vis√£o de m√°quina</a></li>
<li><a href="../pt503884/index.html">Como aprender a trabalhar de forma ass√≠ncrona</a></li>
<li><a href="../pt503888/index.html">Algoritmo AdaBoost</a></li>
<li><a href="../pt503890/index.html">O conto de como eu configurei o Azure AD B2C em React e React Native Part 1 (Tutorial)</a></li>
<li><a href="../pt503892/index.html">Mitap: Quarentena, V√° embora</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>