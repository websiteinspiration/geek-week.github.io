<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏽 ↗️ 🚷 Redisのベストプラクティス、パート3 ♋️ 👨🏻‍💻 🥝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Redis Labs公式ウェブサイトのRedisベストプラクティスセクションの最終翻訳。カットの下で今日最も珍しくて興味深いです！
 
 
 最初の部分はここです。
 そして2番目はここです。
 
 この記事には次のトピックが含まれています。
 
 

- ソートされたセットの時系列。
- 辞書式に...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Redisのベストプラクティス、パート3</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506594/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Labs公式ウェブサイト</font><font style="vertical-align: inherit;">の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redisベストプラクティス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクションの最終翻訳</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">カットの下で今日最も珍しくて興味深いです！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hr/6y/f5/hr6yf5w1hp0fh-i5vfa0p1pxeuy.png" width="15%"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の部分は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして2番目は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事には次のトピックが含まれています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソートされたセットの時系列。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">辞書式にソートされたセットの時系列。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビットフィールドの時系列。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的な帯域幅制限パターン。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブルームフィルター;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カウンター;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビットカウントパターン;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperLogLog;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luaスクリプト。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列データ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時系列データ、または自然な時間順序のデータは、Redisでデータ自体とアクセス方法に応じて、いくつかの方法でモデル化できます。</font><font style="vertical-align: inherit;">これらのパターンのいくつかを見てみましょう。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソートされたセットの時系列。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">辞書式にソートされたセットの時系列。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビットフィールドの時系列。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソートされたセットの時系列</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並べ替えられたセット（zsets）の時系列は、Redisで時系列をモデル化する典型的な方法です。</font><font style="vertical-align: inherit;">ソートされたセットは、スコアが1つのキーの下に保存される一意のオブジェクトで構成されます。</font><font style="vertical-align: inherit;">ソートされたセットにこのタイプのデータを使用すると、カウントは一種の時間インジケーターとして機能し（多くの場合、ミリ秒単位の正確なタイムスタンプです）、要素は記録されたデータです。</font><font style="vertical-align: inherit;">唯一の利点は、これはセットの形式であるため、一意の要素のみが許可され、同じ値で時系列を記録しようとするとスコアのみが更新されることです。</font><font style="vertical-align: inherit;">この問題を説明するために、温度の定期的な記録の次の例を取り上げます。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイムスタンプ</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">温度、C</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697976001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697977001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697978001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZADDを使用してそれらを単にソート済みセットに追加すると、一部の値が失われる可能性があります：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ANTI-PATTERN</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD temperature 1586697976001 21<font></font>
(integer) 1<font></font>
&gt; ZADD temperature 1586697977001 22<font></font>
(integer) 1<font></font>
&gt; ZADD temperature 1586697978001 21<font></font>
(integer) 0<font></font>
&gt; ZRANGEBYSCORE temperature -inf +inf WITHSCORES<font></font>
1) "22"<font></font>
2) "1586697977001"<font></font>
3) "21"<font></font>
4) "1586697978001"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZADDへの3番目の呼び出しは0を返すことに注意してください。これは、新しい項目がセットに追加されていないことを示しています。次に、ZRANGEBYSCOREで、ソートされたセットに2つのレコードしかないことがわかります。どうして？ 1つ目と3つ目は同じオブジェクトを共有しているため、このオブジェクトのアカウントを更新しただけです。この問題を回避する方法はいくつかあります。それらの1つは、十分なバリエーションを持つランダムデータを含めることで、一意性を確保することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、0から1までの範囲の擬似乱数実数を作成し、それをタイムスタンプに追加します。この例では、読みやすくするために10進数のままにします（実際には、スペースを節約するために8バイト文字列に変換する方が賢明です）。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD temperature2 1586697976001 21:1586697976001.2583<font></font>
(integer) 1<font></font>
&gt; ZADD temperature2 1586697977001 22:1586697977001.941678<font></font>
(integer) 1<font></font>
&gt; ZADD temperature2 1586697978001 21:1586697978001.732015<font></font>
(integer) 1<font></font>
&gt; ZRANGEBYSCORE temperature2 -inf +inf WITHSCORES<font></font>
1) "21:1586697976001.2583"<font></font>
2) "1511533205001"<font></font>
3) "22:1586697977001.941678"<font></font>
4) "1586697977001"<font></font>
5) "21:1586697978001.732015"<font></font>
6) "1586697978001"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、すべてのZADDは1を返し、追加が成功したことを示し、ZRANGEBYSCOREはすべての値を返しました。</font><font style="vertical-align: inherit;">これは有効な方法ですが、一意性を確保するためにバイトを浪費し、ストレージにオーバーヘッドを追加するため、あまり効率的ではありません。</font><font style="vertical-align: inherit;">ほとんどの場合、一意性はアプリケーションによって単純に一掃されます。</font><font style="vertical-align: inherit;">データがすでに一意である場合（たとえば、UUIDを含むデータ）、一意性を追加する必要がないことに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドを使用すると、分析および制御のためにソートされたセットのすべてのメソッドにアクセスできます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZRANGEBYSCOREを使用すると、2つのタイムスタンプの間の特定のスライスを取得できます（ZREVRANGEBYSCOREは、スライスを降順で返します）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZREMRANGEBYSCOREを使用すると、特定の範囲のタイムスタンプを削除できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZCOUNT-タイムスタンプ範囲間の要素数。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZINTERSTORE-2つのデータの共通部分を取得して、新しいキーの下に保存できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZUNIONSTORE-2つのデータの和集合を取得し、新しいキーの下に保存することもできます。</font><font style="vertical-align: inherit;">これを使用して、ソートされたセットを複製することもできます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のキーで機能するZINTERSTOREおよびZUNIONSTORE操作。</font><font style="vertical-align: inherit;">共有環境で作業するときは、新しいキーが同じセグメントにあることを確認するように注意する必要があります。そうでない場合、これらのコマンドはエラーになります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">辞書式にソートされたセットの時系列</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時系列を操作する別の方法は、ソートされたセットの辞書式プロパティを使用して、タイムスタンプと値を格納することです。これに慣れていない場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このセクション</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を読む時間</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法では、すべてを同じカウントで保存し、最初にタイムスタンプをエンコードしてから、要素として値を追加します。例を挙げましょう：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD lex-temperature 0 1589392163001:21<font></font>
(integer) 1<font></font>
&gt; ZADD lex-temperature 0 1589392164001:22<font></font>
(integer) 1<font></font>
&gt; ZADD lex-temperature 0 1589392165001:21<font></font>
(integer) 1<font></font>
&gt; ZRANGE lex-temperature 0 -1<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの3つのZADD呼び出しでは、タイムスタンプと値がコロンで区切られており、毎回1が返されることがわかります。これは、3つすべてが追加されたことを意味します。 ZRANGEには、保存された注文が表示されます。どうして？ソートされたセットでは、スコアが同じ場合、同じスコアの結果がバイナリソートで並べ替えられます。この期間のタイムスタンプは同じ桁数であるため、すべてが正しくソートされます（タイムスタンプが2002年より前または2285年より後の場合、入力する桁数がさらに必要になります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタイプから値の範囲を取得するには、ZRANGEBYLEXコマンドを使用します。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature (1511533200001 +<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の引数には接頭辞があります（値の排他性を示します（包括性は[で示されます）。実際には、タイムスタンプの後には追加データが続くため、この形式は包括性と排他性を無関係にします。3番目の引数+は、上限の無制限を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
間の日付を取得してみてください1589392160001および1589392165001を含む：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature [1589392160001 [1589392165001<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレフィックスが含まれているにもかかわらず、タイムスタンプデータ1589392165001がサンプルに入らないのはなぜですか？</font><font style="vertical-align: inherit;">これがタイムスタンプであることをRedisが何らかの形で理解していると私は信じたい。</font><font style="vertical-align: inherit;">実際、Redisはバイナリソートのみを認識しています。</font><font style="vertical-align: inherit;">バイナリソートでは、1589392165001：21は1589392165001より大きくまたは大きくなります。</font><font style="vertical-align: inherit;">これを上限に含める正しい方法は、目的の上限に1ミリ秒を追加し、排他性を使用することです。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature [1589392160001 (1589392165002<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
辞書式にソートされたセットを持つ一時シーケンスには、単純にソートされたセットを持つ一時シーケンスのように、同様の便利なコマンドセットがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZRANGEBYLEX / ZREVRANGEBYLEX-昇順または降順で値の範囲を取得します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZREMRANGEBYLEX-ソートされた特定の範囲の値を削除します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZLEXCOUNT-ソートされた値の範囲内の要素の数を取得します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZINTERSTOREとZUNIONSTOREは、辞書順にソートされたセットで使用できますが、タイムスタンプと値の重複した組み合わせが返された結果で重複しないため、データが失われるリスクがあります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
辞書式にソートされたセットをエンコードするのではなく、タイムスタンプ付きのソートされたセットを選択する理由に疑問を感じるかもしれません。</font><font style="vertical-align: inherit;">原則として、辞書式にソートされた時系列のセットを処理することをお勧めします。値が常に一意であるとは限らない場合は、タイムスタンプの方が効果的です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビットフィールドの時間シーケンス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redisは、時間シーケンスをビットフィールドに効果的に格納できます。</font><font style="vertical-align: inherit;">これを行うには、最初に任意の参照点と数値形式を選択する必要があります。</font><font style="vertical-align: inherit;">温度測定の例を見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
毎分気温を計測したいとし、毎日真夜中に開始点を設定するとします。</font><font style="vertical-align: inherit;">室温は摂氏で測定します。</font><font style="vertical-align: inherit;">データは次のように構成できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0分=バイト0;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">温度は、8ビットの符号なし数値（0〜255）で書き込まれます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1日のデータは約1.44 kbで入力されます。</font><font style="vertical-align: inherit;">BITFIELDコマンドで温度を記録できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #0 22<font></font>
1) (integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、bit-tsキーを使用して、温度値22が真夜中（＃0）の符号なし8ビット数値（u8）に書き込まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビットフィールドは、符号なし8ビット値に限定されません。</font><font style="vertical-align: inherit;">オフセットの前のポンドの符号に注意してください。</font><font style="vertical-align: inherit;">これは、選択したタイプで配置が行われることを意味します。</font><font style="vertical-align: inherit;">たとえば、「＃79」を指定した場合、これは79番目のバイト、「79」、79番目のビットを意味します（BITFIELDヘルプを参照）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オフセットは、格納されている数値のタイプによって、0から開始して調整できます。たとえば、午前1時を書き込みたい場合、ゼロスロットを考慮して、正午にオフセット＃59またはオフセット＃719を使用します。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #59 23 SET u8 #719 25<font></font>
1) (integer) 0<font></font>
2) (integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例は、BITFIELDが可変であることも示しています。</font><font style="vertical-align: inherit;">1回の呼び出しで複数の値を処理できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらにいくつかの値を追加します。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #60 21 SET u8 #61 20<font></font>
1) (integer) 0<font></font>
2) (integer) 0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今、私たちは抽出します：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts GET u8 #59 GET u8 #60 GET u8 #61<font></font>
1) (integer) 23<font></font>
2) (integer) 21<font></font>
3) (integer) 20</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GET bitサブコマンドのシグニチャーは、SETシグニチャーと似ていますが、3番目の引数として値を受け入れないという唯一の違いがあります。</font><font style="vertical-align: inherit;">取得する必要のあるすべてのインデックスがわかっているのは正常ですが、値の範囲が必要な場合があり、各バイトが個別にストレスをかけすぎます。</font><font style="vertical-align: inherit;">GETRANGEコマンドを使用できます。</font><font style="vertical-align: inherit;">通常の状況では、文字列からバイトを取得するために使用されますが、BITFIELDは同じデータをアドレス指定するもう1つの方法にすぎません。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; GETRANGE bit-ts 59 61<font></font>
"\x17\x15\x14"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コマンドはバイト59から61を16進数で返しました（10進数で23、21、および20。クライアント言語はバイナリデータをredis-cliよりも適切に処理し、通常は言語固有のバイト配列を取得できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、バイト0を使用しました、59-61および719。まだ設定されていないバイトを要求するとどうなりますか？</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts GET u8 #40<font></font>
1) (integer) 0<font></font>
&gt; BITFIELD bit-ts GET u8 #750<font></font>
1) (integer) 0<font></font>
&gt; GETRANGE bit-ts 30 50<font></font>
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redisは未指定のバイトを0として返します。これにより、時系列データを操作するときに問題が発生する可能性があります。アプリケーションロジックは0と未定義の値を区別する必要があります。</font><font style="vertical-align: inherit;">特に符号付き整数を使用する場合、これは範囲の中央で有効な値になる可能性があるため、0値の丸めと省略が可能です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間シーケンスの実際の長さは、実際には最後のバイトによって異なります。</font><font style="vertical-align: inherit;">この例では、最後に保存されたバイトは719なので、データ長は720バイトです。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; STRLEN bit-ts<font></font>
(integer) 720</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BITFIELDベースの時系列は、数値またはバイナリデータを格納するための強力でコンパクトなパターンです。</font><font style="vertical-align: inherit;">ただし、このソリューションはすべてのユースケースに対応しているわけではなく、ニーズに合わせて慎重に検討する必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的な帯域幅制限パターン</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INCRコマンドとEXPIREコマンドのおかげで、Redisで帯域幅リミッターを簡単に作成できます。</font><font style="vertical-align: inherit;">一定の期間、特定のサービスへのリクエストを制限したいという考えです。</font><font style="vertical-align: inherit;">ユーザーがAPIキーで識別されるサービスがあるとします。</font><font style="vertical-align: inherit;">サービスには、1分あたり20リクエストの制限があります。</font><font style="vertical-align: inherit;">これを実装するには、APIキーに1分ごとにRedisキーを作成します。</font><font style="vertical-align: inherit;">データベースを散らかさないために、キーの有効期間も1分に設定されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APIキー-zA21X31、太字-制限に達しました：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Key</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31：0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31：1</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31：2</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31：3</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31：4</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">３</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二十</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二十</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">期限切れ</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:05</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:06</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:01</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></b></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーは、APIキーとコロンを介した分の数で構成されます。</font><font style="vertical-align: inherit;">キーは常に有効期限が切れるので、分数のみを使用するだけで十分です。新しい時間の開始により、他の59のキーがないことを確認できます（59分前に有効期限が切れた）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それがどのように機能するか見てみましょう：</font></font><br>
<br>
<ol>
<li><pre><code class="plaintext hljs">&gt; GET [ API]:[ ]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果が20未満の場合、または設定されていない場合は、ステップ4に進みます。それ以外の場合は、ステップ3に進みます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラーメッセージを表示し、接続を閉じて終了します。</font></font></li>
<li><pre><code class="plaintext hljs">&gt; MULTI<font></font>
OK<font></font>
&gt; INCR [user-api-key]:[current minute number]<font></font>
QUEUED<font></font>
&gt; EXPIRE [user-api-key]:[current minute number] 59<font></font>
QUEUED<font></font>
&gt; EXEC<font></font>
OK</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムを続行します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの重要なポイント：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存在しないキーのINCRは常に1です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPIREは、INCRとともにMULTIトランザクション内にあります。つまり、1つのアトミック操作になります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最悪のシナリオは、非常に奇妙でありそうもない理由により、RedisサーバーがINCRとEXPIREの間で停止した場合です。</font><font style="vertical-align: inherit;">AOFまたはメモリ内レプリカのいずれかからデータを復元する場合、トランザクションが完了していないため、INCRは復元されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパターンを使用する場合、1人のユーザーが2つのキーを持っている可能性があります。1つは現在使用中のキーで、もう1つはこの時点で期限切れになります。</font><font style="vertical-align: inherit;">ただし、パターンは非常に効果的です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブルームフィルター</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブルームフィルターは、アイテムが以前に追加されたかどうかを確認するために使用できる興味深い確率的データ構造です。意図的な言い回しです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確率は、偽陽性の応答のみが存在し、偽陰性は存在しない可能性があります。ブルームフィルターを使用すると、すべての要素をセットに保存してSISMEMBERを呼び出すよりも、コンパクトで迅速に可用性を確認できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブルームフィルターは、要素をクイックハッシュ関数に渡し、そこからビットを選択し、ビットフィールドで特定の間隔で1と0に設定することで機能します。フィルターの存在を確認するために、同じビットが選択されます。多くの要素には重複するビットがある可能性がありますが、ハッシュ関数は一意の識別子を作成するため、ハッシュの1ビットがまだ0である場合、それが以前に追加されていないことがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redisは、GETBITとSETBITを使用してビットフィールドを操作するクライアントライブラリとして、長年フィルターを使用しています。幸い、ReBloomモジュールはRedis 4.0から利用できます。これにより、Bloomフィルターの独自の実装を作成する必要がなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このフィルターの適切な使用例は、ユーザー名がすでに使用されているかどうかを確認することです。</font><font style="vertical-align: inherit;">小さなデータサイズでも問題はありませんが、サービスが大きくなるにつれて、データベースクエリは高額になる可能性があります。</font><font style="vertical-align: inherit;">これはReBloomで簡単に修正できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストにいくつかの名前を追加します。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BF.ADD usernames funnyfred<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames fredisfunny<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames fred<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames funfred<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブルームフィルターをテストします。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BF.EXISTS usernames fred<font></font>
(integer) 1<font></font>
&gt; BF.EXISTS usernames fred_is_funny<font></font>
(integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予想通り、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fred_is_funny</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は0を返しました。これは、そのような名前が使用されなかったことを意味します。</font><font style="vertical-align: inherit;">確かに言うことは不可能ですが、ビットはいくつかの要素の間で単純にオーバーラップする可能性があるためです。</font><font style="vertical-align: inherit;">基本的に、誤検知の可能性は低くなりますが、0にはなりません。ブルームフィルターが満たされると、可能性は高くなりますが、エラー率と初期サイズを調整できます（デフォルトはそれぞれ0.01と100）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カウンター</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redisのカウンターは、いくつかの方法で実装できます。</font><font style="vertical-align: inherit;">最も明白なのはINCRら（INCRBY、INCRBYFLOAT、HINCRBY、HINCRBYFLOAT、ZINCRBY）で、ドキュメントを読むだけで見つけることができます。</font><font style="vertical-align: inherit;">それほど明白ではないのは、BITCOUNTとPFADDの使用です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビットカウントパターン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BITCOUNTは、ビットフィールドで1に設定されたビットの数をキーごとにカウントします。</font><font style="vertical-align: inherit;">これは、任意の期間にわたる一連のアクティビティを計算するために使用できます（ビットフィールドの時系列のパターンと同様）。</font><font style="vertical-align: inherit;">プロセスは、ある時点を選択することであり、各ビットは期間の単位を表します。</font><font style="vertical-align: inherit;">この期間中にアクションが実行されるたびに、最後のポイントから1ユニットの距離でSETBITを実行します。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:00</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></th>
</tr>
<tr>
<td></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 2 1</code></pre></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 3 1</code></pre></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 4 1</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[出発点]</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行為</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行為</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行為</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
12:00から12:30のアクティビティが何分に発生したかを計算するには、次のようにします。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITCOUNT btct 0 30<font></font>
(integer) 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、このパターンは「何回？」ではなく、「どのくらいの頻度ですか？」という質問に答えます。</font><font style="vertical-align: inherit;">たとえば、ユーザーは1分間に20回アクティブである可能性がありますが、これは1としてカウントされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテンプレート</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">本当の利点は、ビットがストレージの最も基本的なビルディングブロックであるため、特定の期間に可能な限り最小のスコアを提供することです。</font><font style="vertical-align: inherit;">これは文字通り、カウントするための最小の（非圧縮）リポジトリです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperLogLog</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一意のアイテムをカウントするのは難しい場合があります。これは通常、各一意の要素を保存し、何らかの方法でこの情報を呼び出すことを意味します。 Redisでは、これは多数のチームと1つのチームを使用して行うことができますが、占有されるボリュームと時間の複雑さの両方が非常に大きくなります。 HyperLogLogは、確率的な代替手段を提供します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HyperLogLogは内部的にはBloomフィルターに似ており、非暗号化ハッシュ関数を介して要素をフィードし、ビットフィールドにビットを設定します。ただし、Bloomフィルターとは異なり、HyperLogLogには、以前に追加されていない新しい要素が追加されると増分する要素カウンターが格納されます。これにより、セット内の一意の要素をカウントするときにエラー率が低くなります。 HyperLogLogはRedisに直接組み込まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redisには、PFADD、PFCOUNT、PFMERGEの3つのHyperLogLogコマンドがあります。</font><font style="vertical-align: inherit;">Webスキャナーを作成し、日中に表示されたページの一意のURLの数をカウントするとします。</font><font style="vertical-align: inherit;">ページごとに、次のコマンドを実行します。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFADD crawled:20200613 "http://www.google.com/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200613 "http://www.redislabs.com/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200613 "http://www.redis.io/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200614 "http://www.redisearch.io/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200614 "http://www.redis.io/"<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の各キーには、日ごとにインデックスが付けられています。</font><font style="vertical-align: inherit;">2020年6月13日に閲覧されたページ数を確認するには、次のようにします。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFCOUNT crawled:20200613<font></font>
(integer) 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2020年6月13日および2020年6月14日のページ数を表示するには、PFMERGEコマンドを使用して、2つのカウンターを組み合わせた値を持つ新しいキーを作成します。</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.redis.io</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は両方のセットに格納されているため、一度計算されることに</font><font style="vertical-align: inherit;">注意してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFMERGE crawled:20200613-14 crawled:20200613 crawled:20200614<font></font>
OK<font></font>
&gt; PFCOUNT crawled:20200613-14<font></font>
(integer) 4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この操作は複数のキーで機能する可能性があるため、分割された環境では、キーが同じシャードにあるように注意してください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luaスクリプト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redisは、「redis-cli」だけでなく、Redisとプログラミング言語の間でさらに素晴らしいことを行うことができます。ただし、効率やセキュリティの問題によりクライアント/サーバーアーキテクチャで取得できない動作が必要になる場合があります。ロジックはデータベースレイヤーで実行する必要があります。そのような場合、Luaが助けになります。 Luaはスクリプト言語としてRedisで働いています。これにより、クライアントとの間のトランスポートのコストなしで、Redisでコードを実行できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストケースは、ハッシュフィールドに値を追加することです。</font><font style="vertical-align: inherit;">RedisはAPPENDを使用して文字列キーに値を簡単に追加できますが、ハッシュフィールドに値を追加するコマンドはありません。</font><font style="vertical-align: inherit;">クライアントから値を抽出し、値に新しい行を追加してハッシュフィールドを削除することで、これを取得できますが、これは悪い考えです。</font><font style="vertical-align: inherit;">これは非アトミックなので、値を追加している間、別のクライアントが以前に変更して、新しい値を上書きする可能性があります。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顧客1</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアント2</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HGET myhash myfield</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[こんにちは戻ります]</font></font></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[「こんにちは」に「世界」を追加します]</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HSET myhash myfield "goodbye"</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">３</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HSET myhash myfield "hello world"</code></pre></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; HGET myhash myfield</code></pre></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2行目でわかるように、更新は失われます。</font><font style="vertical-align: inherit;">Luaスクリプトを使用してこの問題を回避し、クライアントから値を送受信するコストを削除できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任意のテキストエディターでスクリプトを作成し、それを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起こり</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました.luaと呼びます</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">local</span> original = redis.call(<span class="hljs-string">'HGET'</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>])
<span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">'HSET'</span>,KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], original .. ARGV[<span class="hljs-number">2</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の行で、ローカル変数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">originalを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成し</font><font style="vertical-align: inherit;">ます。ここでは、渡された最初の引数からのハッシュキーの現在の値を保存し、フィールドは最初の非キー引数です。ランタイムLuaスクリプトはキーと非キー引数を区別することを理解することが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2行目では、同じキーとフィールドに対してHSETが呼び出され、元の値を2番目の非キー引数と組み合わせます。これはRedisに戻るので、元のHSET戻り値を保持します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EVALコマンドを使用してLuaスクリプトを直接実行すると、混乱を招き、非効率になる可能性があります。</font><font style="vertical-align: inherit;">Redisには組み込みのスクリプトキャッシュがあり、スクリプトをプリロードしてから、メインスクリプトのSHA1ハッシュを使用してアクセスできます。</font><font style="vertical-align: inherit;">このスクリプトは、「cat」と「redis-cli」を使用してコマンドラインからダウンロードできます。</font><font style="vertical-align: inherit;">スクリプトが少なくとも1文字異なる場合、完全に異なるハッシュになることに注意してください。</font></font><br>
<br>
<pre><code class="bash hljs">$ redis-cli -a yourRedisPassword SCRIPT LOAD <span class="hljs-string">"<span class="hljs-subst">$(cat ./happend.lua)</span>"</span>
<span class="hljs-string">"d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、EVALSHAを使用してスクリプトを呼び出し、以下を追加できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; HSET mynewhash greeting "Hello"<font></font>
(integer) 1<font></font>
&gt; EVALSHA d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099 1 mynewhash greeting " world"<font></font>
(integer) 0<font></font>
&gt; HGET mynewhash greeting<font></font>
"Hello world"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EVALSHAコマンドの最初の引数は、SCRIPT LOADによって生成されたスクリプトのハッシュです。 2番目の引数はキーの数です。私たちの場合、キーは1つです。 3番目の引数は、アクションを実行するキーです。そして最後に、4番目はフィールドに追加する値です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追加はLuaスクリプト内で行われるため、Luaスクリプトは同期的かつアトミックに実行されるため、上記のスクリプトは中止されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luaは問題の解決に非常に役立ちますが、慎重に使用する必要があります。スクリプトによりサーバーがブロックされ、データベースが応答しなくなる可能性があります。シャーディングの状況では、クロスエラーを回避するために、スクリプトはすべての操作を単一のサーバーに保存しようとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがRedisのベストプラクティスセクションの終わりです。</font><font style="vertical-align: inherit;">試してみることを恐れないでください。Redisは機能が非常に豊富です。</font><font style="vertical-align: inherit;">興味深いユースケースをコメントに残してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明した手法が直接ではないにしても、少なくとも問題を解決するための正しい道を示すことで役立つことを願っています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja506574/index.html">Vue、WebGL、three.jsを使用して、3Dでクリスタルの形でノーベル賞受賞女性のリストを視覚化</a></li>
<li><a href="../ja506578/index.html">管理されたリードボリューム</a></li>
<li><a href="../ja506586/index.html">論理的なFizzBu​​zz</a></li>
<li><a href="../ja506588/index.html">アルゴリズムとは！（パート2）</a></li>
<li><a href="../ja506590/index.html">Конференция DEVOXX UK. Выбираем фреймворк: Docker Swarm, Kubernetes или Mesos. Часть 2</a></li>
<li><a href="../ja506598/index.html">マイクロソフト：Rustはセキュアシステムプログラミング業界における「ベストチャンス」です</a></li>
<li><a href="../ja506600/index.html">プロジェクト管理の観点からのサイト開発の契約（理論+サンプル）</a></li>
<li><a href="../ja506604/index.html">同時実行性と効率性：PythonとFSM</a></li>
<li><a href="../ja506606/index.html">PIXI.jsクリッカーの作成</a></li>
<li><a href="../ja506610/index.html">WAL-G：PostgreSQLデータベースのバックアップとリカバリ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>