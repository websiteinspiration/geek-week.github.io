<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📀 🤪 👧🏿 C ++ - Konzeptbasierter Polymorphismus im Produktcode: PassManager in LLVM 📊 🎯 🦓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir über eine interessante Redewendung sprechen, die von Sean Parent (Adobe), einer bekannten Figur in der C ++ - Community, eingeführt w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++ - Konzeptbasierter Polymorphismus im Produktcode: PassManager in LLVM</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/samsung/blog/505850/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heute werden wir über eine interessante Redewendung sprechen, die von Sean Parent (Adobe), einer bekannten Figur in der C ++ - Community, eingeführt wurde. </font><font style="vertical-align: inherit;">Er hält häufig Präsentationen und veröffentlicht eine Reihe von Better Code-Artikeln. </font><font style="vertical-align: inherit;">Eine seiner Ideen, die Photoshop verwendet, ist der konzeptbasierte Polymorphismus. </font><font style="vertical-align: inherit;">In diesem Fall implementieren wir Polymorphismus nicht durch explizite Vererbung, sondern unter Verwendung einer Technik, die verallgemeinerte Programmierung umfasst, und als Ergebnis erhalten wir einige zusätzliche Vorteile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel ist wie folgt aufgebaut:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist konzeptbasierter Polymorphismus und warum wird er benötigt?</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen über LLVM und sein Gerät</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel für einen konzeptbasierten Polymorphismus in LLVM PassManager</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorteile des Ansatzes</font></font><br>
</li>
</ol><br>
<br>
<img src="https://habrastorage.org/webt/hg/ru/az/hgruazi6vbztkex50vkgdcfgknw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Bild, das die These "Vererbung ist böse" illustriert. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></a></i><br>
<a name="habracut"></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist konzeptbasierter Polymorphismus und warum wird er benötigt?</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In C ++ wird dynamischer Polymorphismus mithilfe virtueller Funktionen und Vererbung und statischer Polymorphismus mithilfe von Mustern implementiert. </font><font style="vertical-align: inherit;">Hier kombinieren wir diese beiden Ansätze und nehmen das Beste daraus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die explizite Verwendung der Vererbung führt häufig zu einer übermäßigen Code-Konnektivität und einer Verletzung des Prinzips der Schnittstellentrennung ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Wie kann ein dynamischer Polymorphismus ohne diese Nachteile implementiert werden? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sean Parent schlug eine Redewendung namens Concept-Based Polymorphism vor, bei der die Vererbung implizit und vor dem Benutzer verborgen ist. </font><font style="vertical-align: inherit;">Weitere Informationen hierzu finden Sie in seinem Bericht </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vererbung ist die Basisklasse des Bösen,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in dem er die gesamte Idee am Beispiel von Photoshop und dem Aktionsverlauf zeigt. Sie erfahren, wie der „historische Pinsel“ tatsächlich funktioniert.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen über LLVM und sein Gerät</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte die Vorteile dieser Redewendung am Beispiel von LLVM zeigen. </font><font style="vertical-align: inherit;">Wer nicht weiß, LLVM ist eine Infrastruktur für die Entwicklung von Compilern. </font><font style="vertical-align: inherit;">Im Folgenden finden Sie eine LLVM-Architektur auf sehr hoher Ebene, die nur die Entitäten abdeckt, die später in diesem Artikel verwendet werden. </font><font style="vertical-align: inherit;">Weitere Informationen finden Sie in der offiziellen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eu/zw/wa/euzwwalazlbmv9kqy8mzbrv95hw.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist die Architektur von LLVM und im Prinzip jedes modernen Compilers.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Die Hauptteile lauten wie folgt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Front-End nimmt den Quellcode des Programms und wandelt ihn in eine Zwischendarstellung (IR) um. </font><font style="vertical-align: inherit;">Dies vereinfacht die Arbeit des restlichen Compilers, sodass kein komplexer C ++ - Code verarbeitet wird.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Middle End - eine Reihe von Optimierungen, Analysen und Transformationen. </font><font style="vertical-align: inherit;">In seiner allgemeinsten Form handelt es sich um eine Reihe von Pässen (Pässen). </font><font style="vertical-align: inherit;">Alle Pässe werden von einer speziellen Komponente namens PassManager registriert und gestartet.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Backend generiert direkt den Zielcode.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Compiler präsentiert das Programm in Form mehrerer grundlegender Entitäten. </font><font style="vertical-align: inherit;">Dies ist ein Modul (bedingt CPP-Datei), eine Funktion, eine Basiseinheit, die eine Reihe von Anweisungen enthält. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ig/vi/0i/igvi0icjbjtgmhbfvdwvvtbyy0c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVM hat jetzt zwei Versionen von PassManager:&nbsp;</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LegacyPassManager verwendet den klassischen auf Laufzeitvererbung basierenden Polymorphismus. </font><font style="vertical-align: inherit;">Die Vererbungshierarchie enthält Durchläufe, die für ein Modul, eine Funktion, eine Schleife usw. ausgeführt werden.&nbsp;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PassManager - eine neue Version, die nur auf konzeptbasiertem Polymorphismus basiert und LegacyPassManager ersetzen soll. </font><font style="vertical-align: inherit;">Beide Versionen existieren parallel und entwickeln sich unabhängig voneinander.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee des Artikels ist es, das Konzept des realen Produktcodes zu demonstrieren, der auf zwei verschiedene Arten implementiert wird, und die Vorteile des letzteren Ansatzes aufzuzeigen.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel für einen konzeptbasierten Polymorphismus in LLVM PassManager</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie in Legacy implementiert</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst, wie alles klassisch im LegacyPassManager angeordnet ist. </font><font style="vertical-align: inherit;">Angenommen, wir haben einen PassManager der Klasse und es gibt einen Pass der Klasse - einen Pass. </font><font style="vertical-align: inherit;">Wir haben eine solche Hierarchie: ModulePass, von dem unsere Klasse beispielsweise Constant Propagation erbt. </font><font style="vertical-align: inherit;">Es gibt eine runOnModule-Methode, hier ist sie virtuell. </font><font style="vertical-align: inherit;">Wir haben also den üblichen Laufzeitpolymorphismus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/// ModulePass class - This class is used to implement unstructured</span>
<span class="hljs-comment">/// interprocedural optimizations and analyses. ModulePasses may do anything</span>
<span class="hljs-comment">/// they want to the program.</span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModulePass</span> :</span> <span class="hljs-keyword">public</span> Pass {<font></font>
...<font></font>
<span class="hljs-comment">/// runOnModule - Virtual method overriden by subclasses to process the module</span>
<span class="hljs-comment">/// being operated on.</span>
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/// IPCP - The interprocedural constant propagation pass</span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IPCP</span> :</span> <span class="hljs-keyword">public</span> ModulePass {<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> <span class="hljs-keyword">override</span></span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns den Code an, was ist das Problem hier? Wir sehen, dass in dieser Hierarchie die Methoden zum Starten einer Passage unterschiedlich sind, je nachdem, wofür sie ausgeführt werden sollen (für eine Funktion - runOnFunction, ein Modul - runOnModule, einen Zyklus - runOnLoop usw.). Dies macht es wiederum unmöglich, die Sammlung von Durchläufen, die mit verschiedenen IR-Entitäten arbeiten, auf eine einzige Weise zu verarbeiten (tatsächlich Polymorphismus anwenden). Es scheint offensichtlich, wie man es richtig macht: Sie benötigen eine virtuelle Ausführungsmethode, die in den Erben neu definiert wird. Dann tritt jedoch ein Problem auf: Die Ausführungsmethoden in den Nachfolgeklassen haben eine andere Signatur, da der Parameter immer von seinem Typ übergeben wird - Funktion, Modul usw. Sie müssen also eine Dummy-Basisklasse für Modul, Funktion usw. erstellen, im Lauf einen Zeiger auf diese Klasse übergeben und innerhalb der Methode einen Downcast durchführen.abhängig davon, welche Art von Objekt sich auf diesem Zeiger befindet. Und etwas Seltsames beginnt: Wenn eine neue untergeordnete Entität erscheint, müssen wir jetzt den übergeordneten Code jedes Mal neu schreiben, was allen Gestaltungsprinzipien widerspricht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können für jeden Fall manuell eine Adapterklasse schreiben. </font><font style="vertical-align: inherit;">Dies ist jedoch eine lange und uninteressante und in der Tat seltsame Idee, Wrapper-Klassen zu schreiben, um nur Komponenten bedienen zu können. </font><font style="vertical-align: inherit;">Es ist besser, diesen Code automatisch mithilfe von Vorlagen zu generieren. </font><font style="vertical-align: inherit;">Dies ist genau das, was in dem diskutierten Ansatz angesprochen werden soll. </font><font style="vertical-align: inherit;">Wie Sie später sehen werden, werden wir außerdem einige weitere nützliche Konsequenzen haben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie in der neuen Version vorgeschlagen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Folgendes passiert im neuen PassManager. </font><font style="vertical-align: inherit;">Das Konzept eines polymorphen Objekts wird wie folgt verallgemeinert. </font><font style="vertical-align: inherit;">Wir sagen, wenn ein Objekt eine Methode implementiert, führen wir eine Reihe von Methoden ein, die polymorph sein sollen, und wir sagen, dass alle Klassen, die diese Methode implementieren, polymorph sind, dh wir können sie in austauschbaren Kontexten in verwenden Dies ist PassManager. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie die PassManager-Klasse in LLVM. </font><font style="vertical-align: inherit;">Hier ist eine vereinfachte Version. Die vollständige Version finden Sie in llvm / include / llvm / IR / PassManager.h. </font><font style="vertical-align: inherit;">Der IR-Vorlagenparameter ist direkt auf die Entität spezialisiert, an die wir übergeben (die Ausführungsfunktion). </font><font style="vertical-align: inherit;">Es kann ein Modul, eine Funktion oder ein Zyklus sein. </font><font style="vertical-align: inherit;">Wir schauen uns den Code an, weitere Erklärungen werden sein:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassManager</span> {</span>
<span class="hljs-keyword">public</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; Pass : Passes) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pass-&gt;run(graph, args...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PassT&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addPass</span><span class="hljs-params">(PassT Pass)</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passes.emplace_back(<span class="hljs-keyword">new</span> detail::PassModel&lt;IR, PassT, ArgTs...&gt;(<span class="hljs-built_in">std</span>::move(Pass)));<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;detail::PassConcept&lt;IR, ArgTs...&gt;&gt;&gt; Passes;<font></font>
<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns die folgenden grundlegenden Entitäten an:</font></font><br>
<br>
<ul>
<li> run     ,        run<br>
</li>
<li> addPass     (      )    PassT<br>
</li>
<li> Passes — ,      .         ,       ,        type erasure,     <br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was für ein Typ sollte das sein? </font><font style="vertical-align: inherit;">Was ist im Passes-Vektor gespeichert? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns zunächst sehen, was PassModel und PassConcept sind. </font><font style="vertical-align: inherit;">Dies sind Hilfsklassen innerhalb von PassManager. </font><font style="vertical-align: inherit;">Sie befinden sich beide im Detail-Namespace. </font><font style="vertical-align: inherit;">Lassen Sie uns zunächst sehen, wie die PassConcept-Klasse aussieht. </font><font style="vertical-align: inherit;">Es enthält wieder dieselbe Ausführungsmethode, hier handelt es sich um eine rein virtuelle Methode.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> detail {<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassConcept</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">virtual</span> ~PassConcept() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> </span>= <span class="hljs-number">0</span>;<font></font>
<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite Klasse, PassModel, ist ebenfalls Boilerplate. </font><font style="vertical-align: inherit;">Es wird von PassConcept geerbt.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span> PassT, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassModel</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> PassConcept&lt;IR, ArgTs...&gt; {
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">PassModel</span><span class="hljs-params">(PassT Pass)</span> : <span class="hljs-title">pass_</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::move(pass))</span> </span>{}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> <span class="hljs-keyword">final</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass_.run(ir, args...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PassT pass_;<font></font>
<font></font>
};<font></font>
<font></font>
} <span class="hljs-comment">// end namespace detail</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was es enthält:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Privates pass_-Feld vom Typ PassT</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Konstruktor, der ein Objekt vom Typ PassT als Eingabe akzeptiert. </font><font style="vertical-align: inherit;">Es macht nichts Interessantes, es initialisiert pass_ nur mit der Semantik der Bewegung</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die run-Methode, die einfach die run-Methode beim Pass aufruft. </font><font style="vertical-align: inherit;">Übergabe aller Argumente, die möglicherweise vorhanden sind.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erinnern uns jetzt, wo wir angefangen haben. PassManager speichert wiederum alle diese Passagen. In Vektorübergängen von PassConcept-Typelementen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also das große Ganze. Erstellt von PassManager. Mit AddPass werden die Durchgänge aufgezeichnet, die über das Modul, die Funktion, die Schleife usw. ausgeführt werden sollen. Zum Beispiel Inline, konstante Ausbreitung, Abrollen von Schleifen usw. Sie selbst werden von niemandem geerbt, sie sollten nur eine Ausführungsmethode haben. Und genau dieses ganze Konzept bietet dies. Auf welche Weise?&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir haben Inline-Optimierung. Wir fügen addPass ein Objekt vom Typ Inline hinzu. Dementsprechend setzen wir in Passes im Vektor diese Inline bereits in Form von PassConcept. Wie können wir das machen? Inline wird nicht von der PassConcept-Klasse geerbt. Wie setzen wir ein Element in einen Vektor? Wir können das Casting nicht auf den Basistyp durchführen (Upcasting), da es keine Vererbung gibt. Und hier wird ein solcher Trick gemacht. Wir haben diese PassConcept-Hilfsklasse, die die Schnittstelle definiert. Er sagt, dass alle seine Nachkommen die Ausführungsmethode implementieren müssen. Wir haben PassModel, das wiederum Boilerplate ist. Wenn wir also Inline einfügen, wird dieses PassModel mit diesem Inline-Typ instanziiert. Dieses Objekt wird in dieser Klasse kompiliert. PassModel selbst definiert run neu, was für sich bereits run für diese Passage aufruft.d.h. von der Inline-Klasse ausführen. All dies wird in der Kompilierungszeit behoben: Wenn Inline die Ausführungsmethode nicht definiert, tritt ein Fehler in der Kompilierungszeit auf.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit wird dieser Polymorphismus ohne Vererbung erreicht. Es kann sich die Frage stellen: Wie ist es nicht Vererbung, denn hier ist es, PassModel wird von PassConcept geerbt? Antwort: Es gibt Vererbung, aber es ist intern, es ragt nicht heraus, der Benutzer weiß nichts darüber. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sprechen auf konzeptioneller Ebene. Hier haben wir einen Benutzer, der eine bestimmte Methode überschreiben möchte. Gleichzeitig möchte er nicht vererbt werden, um keine zusätzlichen Abhängigkeiten von sich selbst zu ziehen. Wie kann man das machen? Wir in uns selbst machen durch PassConcept, PassModel Laufzeitpolymorphismus, durch Vererbung, aber der Benutzer weiß nichts davon: Dies sind alle Innenräume dieser beiden Klassen, sie sind in ihrem Namespace definiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wird dies noch einmal erreicht? </font><font style="vertical-align: inherit;">Ich habe eine Klasse, nennen wir sie Inline, was den Compiler betrifft. </font><font style="vertical-align: inherit;">Wir fügen dem Vektor Inline hinzu und erstellen das PassModel-Objekt. </font><font style="vertical-align: inherit;">Es hat einen Konstruktor, der das Objekt dieses Vorlagenparameters aufnimmt. </font><font style="vertical-align: inherit;">Wenn wir also die run-Methode in PassManager aufrufen, werden alle Passagen durchlaufen. In diesem Fall haben wir nur einen Durchgang und den Inline-Typ. </font><font style="vertical-align: inherit;">Es ruft die runC-Methode von PassConcept auf. </font><font style="vertical-align: inherit;">Dieselbe Ausführungsmethode wie in PassModel, die vom Inline-Typ instanziiert wird. </font><font style="vertical-align: inherit;">Und bereits diese Methode ruft die run-Methode für die registrierte Passage auf, in diesem Fall Inline, und als Ergebnis wird run on Inline aufgerufen.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorteile des Ansatzes</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise haben wir uns anders verhalten, ohne die Vererbung explizit zu verwenden. Wir haben jetzt nicht die explizite Abhängigkeit, die zuvor im LegacyPassManager war.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was für eine ungewöhnliche rekursive Sache es sich herausstellt. Wir können Polymorphismus für jedes Objekt verwenden, das die Ausführungsmethode überschreibt. Da die run-Methode PassManager selbst überschreibt, kann sie sich selbst registrieren, dh sich in den Passes-Passvektor einbetten und sich erneut aufrufen.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich heraus, dass wir alles mischen können. Der alte PassManager, der Legacy ist, hat eine klare Trennung. Es gibt eine modulare Optimierung, die am Modul durchgeführt wird. Es gibt eine Optimierung der Funktion. Und hier läuft alles reibungslos. Wir machen PassManager, instanziieren es mit dem Typ "Modul", fügen Inline ein, etwas anderes, einige andere modulare Optimierungen. Dann instanziieren wir den zweiten PassManager, den wir mit dem Typ "Funktion" instanziieren, und optimieren die Funktion. Und dann können Sie im PassManager, der vom Modul instanziiert wird, einen weiteren PassManager, der von der Funktion instanziiert wird, über diesen Passes-Vektor einfügen.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs">PassManager&lt;Module&gt; MPM;
<span class="hljs-comment">// ... register passes on module</span><font></font>
MPM.addPass(GlobalDCEPass())<font></font>
MPM.addPass(PGOInstrumentationGen());<font></font>
<span class="hljs-comment">//... register passes on function</span><font></font>
PassManager&lt;Function&gt; FPM;&nbsp;<font></font>
FPM.addPass(CallSiteSplittingPass());<font></font>
<span class="hljs-comment">//... register all registered passes on function in module pass manager MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hast du Zeit zu folgen? Wir haben zwei PassManager. Eines mit Typ IR-Modul, das andere mit Typ IR-Funktion. Nehmen wir an, wir haben in dem Modul bereits einige Durchgänge durchgeführt. Jetzt wollen wir sie mit Durchläufen mischen, die für eine Funktion ausgeführt werden. Was machen wir? Wir nennen addPass und übergeben PassManager als Pass, was mit dem IR-Typ "Function" instanziiert wird (im realen Code wird nicht PassManager dort platziert, sondern eine spezielle Klasse, die es umschließt, aber auf konzeptioneller Ebene spielt es keine Rolle).&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise können wir verschiedene Optimierungsstufen mischen - dank der Verschachtelung von PassManagern können Sie abwechselnd Durchgänge zum Modul, zur Funktion, zum Zyklus usw. ausführen. </font><font style="vertical-align: inherit;">In Legacy PassManager ist dies komplizierter. Es gibt eine separate Klasse für Module mit einer virtuellen Funktion runOnModule, eine separate Klasse für Funktionen mit einer virtuellen Methode runOnFunction usw. </font><font style="vertical-align: inherit;">Beide Klassen werden vom gemeinsamen Vorfahren von Pass geerbt, sind jedoch unabhängig voneinander und verfügen über eine andere Schnittstelle, wodurch die Verwendung des LegacyPassManager zum Aufrufen von Pässen für verschiedene IR-Entitäten (Modul, Funktion, Schleife) unpraktisch wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzliche Lesematerialien:</font></font><br>
&nbsp;<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM für Studenten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Eine einfache Einführung in LLVM</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Präsentation von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chandler Carrut über die Anordnung von LLVM-Pässen</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Präsentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chandler Carruth über Implementierungsdetails PassManager</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Thread</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der Mailingliste, der den Unterschied zwischen LegacyPassManager und PassManager erläutert</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autoren: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/73/et/tp/73ettpg9jylifuwfvohspok-nv4.png" align="left"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roman Rusyaev, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Experte Ingenieur </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AI Compiler Team </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Samsung F &amp; E-Institut, Russland </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bald wird Roman auf der C ++ Russia 2020 Moskau-Konferenz mit Anton Polukhin sprechen: Dort werden sie über die gegenwärtige und zukünftige Wahl der Kopien sprechen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zum Bericht</font></font></a><br>
<br clear="all">
<img src="https://habrastorage.org/webt/ay/fa/a2/ayfaa2i4aukgor-uh5ija7gstie.png" align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tatyana Volkova, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lead Specialist </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Business Entwicklungsteam </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Samsung R &amp; D Institute, Russland</font></font></i><br>
<br clear="all"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de505824/index.html">Anleitung: Ihr eigenes L2TP-VPN</a></li>
<li><a href="../de505826/index.html">Wie man 100% Vision und noch mehr bekommt</a></li>
<li><a href="../de505834/index.html">Medianproben. Konfidenzintervalle und Vergleich</a></li>
<li><a href="../de505838/index.html">FPGA-Technologie für Tausende von Anwendungen</a></li>
<li><a href="../de505846/index.html">Was sind die wirklichen mathematischen Probleme bei der Entwicklung von Impfstoffen aus COVID-19?</a></li>
<li><a href="../de505856/index.html">Von Brute-Force bis zum Versuch der Privatsphäre - was SaaS-Anbieter erwartet</a></li>
<li><a href="../de505860/index.html">Spring Boot, Hibernate und Kotlin für Anfänger Schritt für Schritt</a></li>
<li><a href="../de505870/index.html">Wie man mobile Spiele und Anwendungen in Japan, Korea und China bewirbt</a></li>
<li><a href="../de505872/index.html">Geschichte unbemannter Fahrzeuge</a></li>
<li><a href="../de505880/index.html">So schreiben Sie Ihren Index in Tarantool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>