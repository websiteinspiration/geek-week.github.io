<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÄ ü§™ üëßüèø C ++ - Konzeptbasierter Polymorphismus im Produktcode: PassManager in LLVM üìä üéØ ü¶ì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir √ºber eine interessante Redewendung sprechen, die von Sean Parent (Adobe), einer bekannten Figur in der C ++ - Community, eingef√ºhrt w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++ - Konzeptbasierter Polymorphismus im Produktcode: PassManager in LLVM</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/samsung/blog/505850/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heute werden wir √ºber eine interessante Redewendung sprechen, die von Sean Parent (Adobe), einer bekannten Figur in der C ++ - Community, eingef√ºhrt wurde. </font><font style="vertical-align: inherit;">Er h√§lt h√§ufig Pr√§sentationen und ver√∂ffentlicht eine Reihe von Better Code-Artikeln. </font><font style="vertical-align: inherit;">Eine seiner Ideen, die Photoshop verwendet, ist der konzeptbasierte Polymorphismus. </font><font style="vertical-align: inherit;">In diesem Fall implementieren wir Polymorphismus nicht durch explizite Vererbung, sondern unter Verwendung einer Technik, die verallgemeinerte Programmierung umfasst, und als Ergebnis erhalten wir einige zus√§tzliche Vorteile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel ist wie folgt aufgebaut:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist konzeptbasierter Polymorphismus und warum wird er ben√∂tigt?</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen √ºber LLVM und sein Ger√§t</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel f√ºr einen konzeptbasierten Polymorphismus in LLVM PassManager</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorteile des Ansatzes</font></font><br>
</li>
</ol><br>
<br>
<img src="https://habrastorage.org/webt/hg/ru/az/hgruazi6vbztkex50vkgdcfgknw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Bild, das die These "Vererbung ist b√∂se" illustriert. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></a></i><br>
<a name="habracut"></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist konzeptbasierter Polymorphismus und warum wird er ben√∂tigt?</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In C ++ wird dynamischer Polymorphismus mithilfe virtueller Funktionen und Vererbung und statischer Polymorphismus mithilfe von Mustern implementiert. </font><font style="vertical-align: inherit;">Hier kombinieren wir diese beiden Ans√§tze und nehmen das Beste daraus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die explizite Verwendung der Vererbung f√ºhrt h√§ufig zu einer √ºberm√§√üigen Code-Konnektivit√§t und einer Verletzung des Prinzips der Schnittstellentrennung ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Wie kann ein dynamischer Polymorphismus ohne diese Nachteile implementiert werden? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sean Parent schlug eine Redewendung namens Concept-Based Polymorphism vor, bei der die Vererbung implizit und vor dem Benutzer verborgen ist. </font><font style="vertical-align: inherit;">Weitere Informationen hierzu finden Sie in seinem Bericht </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vererbung ist die Basisklasse des B√∂sen,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in dem er die gesamte Idee am Beispiel von Photoshop und dem Aktionsverlauf zeigt. Sie erfahren, wie der ‚Äûhistorische Pinsel‚Äú tats√§chlich funktioniert.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen √ºber LLVM und sein Ger√§t</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich m√∂chte die Vorteile dieser Redewendung am Beispiel von LLVM zeigen. </font><font style="vertical-align: inherit;">Wer nicht wei√ü, LLVM ist eine Infrastruktur f√ºr die Entwicklung von Compilern. </font><font style="vertical-align: inherit;">Im Folgenden finden Sie eine LLVM-Architektur auf sehr hoher Ebene, die nur die Entit√§ten abdeckt, die sp√§ter in diesem Artikel verwendet werden. </font><font style="vertical-align: inherit;">Weitere Informationen finden Sie in der offiziellen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eu/zw/wa/euzwwalazlbmv9kqy8mzbrv95hw.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist die Architektur von LLVM und im Prinzip jedes modernen Compilers.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Die Hauptteile lauten wie folgt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Front-End nimmt den Quellcode des Programms und wandelt ihn in eine Zwischendarstellung (IR) um. </font><font style="vertical-align: inherit;">Dies vereinfacht die Arbeit des restlichen Compilers, sodass kein komplexer C ++ - Code verarbeitet wird.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Middle End - eine Reihe von Optimierungen, Analysen und Transformationen. </font><font style="vertical-align: inherit;">In seiner allgemeinsten Form handelt es sich um eine Reihe von P√§ssen (P√§ssen). </font><font style="vertical-align: inherit;">Alle P√§sse werden von einer speziellen Komponente namens PassManager registriert und gestartet.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Backend generiert direkt den Zielcode.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Compiler pr√§sentiert das Programm in Form mehrerer grundlegender Entit√§ten. </font><font style="vertical-align: inherit;">Dies ist ein Modul (bedingt CPP-Datei), eine Funktion, eine Basiseinheit, die eine Reihe von Anweisungen enth√§lt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ig/vi/0i/igvi0icjbjtgmhbfvdwvvtbyy0c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVM hat jetzt zwei Versionen von PassManager:&nbsp;</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LegacyPassManager verwendet den klassischen auf Laufzeitvererbung basierenden Polymorphismus. </font><font style="vertical-align: inherit;">Die Vererbungshierarchie enth√§lt Durchl√§ufe, die f√ºr ein Modul, eine Funktion, eine Schleife usw. ausgef√ºhrt werden.&nbsp;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PassManager - eine neue Version, die nur auf konzeptbasiertem Polymorphismus basiert und LegacyPassManager ersetzen soll. </font><font style="vertical-align: inherit;">Beide Versionen existieren parallel und entwickeln sich unabh√§ngig voneinander.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee des Artikels ist es, das Konzept des realen Produktcodes zu demonstrieren, der auf zwei verschiedene Arten implementiert wird, und die Vorteile des letzteren Ansatzes aufzuzeigen.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel f√ºr einen konzeptbasierten Polymorphismus in LLVM PassManager</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie in Legacy implementiert</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst, wie alles klassisch im LegacyPassManager angeordnet ist. </font><font style="vertical-align: inherit;">Angenommen, wir haben einen PassManager der Klasse und es gibt einen Pass der Klasse - einen Pass. </font><font style="vertical-align: inherit;">Wir haben eine solche Hierarchie: ModulePass, von dem unsere Klasse beispielsweise Constant Propagation erbt. </font><font style="vertical-align: inherit;">Es gibt eine runOnModule-Methode, hier ist sie virtuell. </font><font style="vertical-align: inherit;">Wir haben also den √ºblichen Laufzeitpolymorphismus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/// ModulePass class - This class is used to implement unstructured</span>
<span class="hljs-comment">/// interprocedural optimizations and analyses. ModulePasses may do anything</span>
<span class="hljs-comment">/// they want to the program.</span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModulePass</span> :</span> <span class="hljs-keyword">public</span> Pass {<font></font>
...<font></font>
<span class="hljs-comment">/// runOnModule - Virtual method overriden by subclasses to process the module</span>
<span class="hljs-comment">/// being operated on.</span>
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/// IPCP - The interprocedural constant propagation pass</span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IPCP</span> :</span> <span class="hljs-keyword">public</span> ModulePass {<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> <span class="hljs-keyword">override</span></span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns den Code an, was ist das Problem hier? Wir sehen, dass in dieser Hierarchie die Methoden zum Starten einer Passage unterschiedlich sind, je nachdem, wof√ºr sie ausgef√ºhrt werden sollen (f√ºr eine Funktion - runOnFunction, ein Modul - runOnModule, einen Zyklus - runOnLoop usw.). Dies macht es wiederum unm√∂glich, die Sammlung von Durchl√§ufen, die mit verschiedenen IR-Entit√§ten arbeiten, auf eine einzige Weise zu verarbeiten (tats√§chlich Polymorphismus anwenden). Es scheint offensichtlich, wie man es richtig macht: Sie ben√∂tigen eine virtuelle Ausf√ºhrungsmethode, die in den Erben neu definiert wird. Dann tritt jedoch ein Problem auf: Die Ausf√ºhrungsmethoden in den Nachfolgeklassen haben eine andere Signatur, da der Parameter immer von seinem Typ √ºbergeben wird - Funktion, Modul usw. Sie m√ºssen also eine Dummy-Basisklasse f√ºr Modul, Funktion usw. erstellen, im Lauf einen Zeiger auf diese Klasse √ºbergeben und innerhalb der Methode einen Downcast durchf√ºhren.abh√§ngig davon, welche Art von Objekt sich auf diesem Zeiger befindet. Und etwas Seltsames beginnt: Wenn eine neue untergeordnete Entit√§t erscheint, m√ºssen wir jetzt den √ºbergeordneten Code jedes Mal neu schreiben, was allen Gestaltungsprinzipien widerspricht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen f√ºr jeden Fall manuell eine Adapterklasse schreiben. </font><font style="vertical-align: inherit;">Dies ist jedoch eine lange und uninteressante und in der Tat seltsame Idee, Wrapper-Klassen zu schreiben, um nur Komponenten bedienen zu k√∂nnen. </font><font style="vertical-align: inherit;">Es ist besser, diesen Code automatisch mithilfe von Vorlagen zu generieren. </font><font style="vertical-align: inherit;">Dies ist genau das, was in dem diskutierten Ansatz angesprochen werden soll. </font><font style="vertical-align: inherit;">Wie Sie sp√§ter sehen werden, werden wir au√üerdem einige weitere n√ºtzliche Konsequenzen haben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie in der neuen Version vorgeschlagen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Folgendes passiert im neuen PassManager. </font><font style="vertical-align: inherit;">Das Konzept eines polymorphen Objekts wird wie folgt verallgemeinert. </font><font style="vertical-align: inherit;">Wir sagen, wenn ein Objekt eine Methode implementiert, f√ºhren wir eine Reihe von Methoden ein, die polymorph sein sollen, und wir sagen, dass alle Klassen, die diese Methode implementieren, polymorph sind, dh wir k√∂nnen sie in austauschbaren Kontexten in verwenden Dies ist PassManager. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie die PassManager-Klasse in LLVM. </font><font style="vertical-align: inherit;">Hier ist eine vereinfachte Version. Die vollst√§ndige Version finden Sie in llvm / include / llvm / IR / PassManager.h. </font><font style="vertical-align: inherit;">Der IR-Vorlagenparameter ist direkt auf die Entit√§t spezialisiert, an die wir √ºbergeben (die Ausf√ºhrungsfunktion). </font><font style="vertical-align: inherit;">Es kann ein Modul, eine Funktion oder ein Zyklus sein. </font><font style="vertical-align: inherit;">Wir schauen uns den Code an, weitere Erkl√§rungen werden sein:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassManager</span> {</span>
<span class="hljs-keyword">public</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; Pass : Passes) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pass-&gt;run(graph, args...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PassT&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addPass</span><span class="hljs-params">(PassT Pass)</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passes.emplace_back(<span class="hljs-keyword">new</span> detail::PassModel&lt;IR, PassT, ArgTs...&gt;(<span class="hljs-built_in">std</span>::move(Pass)));<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;detail::PassConcept&lt;IR, ArgTs...&gt;&gt;&gt; Passes;<font></font>
<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns die folgenden grundlegenden Entit√§ten an:</font></font><br>
<br>
<ul>
<li> run     ,        run<br>
</li>
<li> addPass     (      )    PassT<br>
</li>
<li> Passes ‚Äî ,      .         ,       ,        type erasure,     <br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was f√ºr ein Typ sollte das sein? </font><font style="vertical-align: inherit;">Was ist im Passes-Vektor gespeichert? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns zun√§chst sehen, was PassModel und PassConcept sind. </font><font style="vertical-align: inherit;">Dies sind Hilfsklassen innerhalb von PassManager. </font><font style="vertical-align: inherit;">Sie befinden sich beide im Detail-Namespace. </font><font style="vertical-align: inherit;">Lassen Sie uns zun√§chst sehen, wie die PassConcept-Klasse aussieht. </font><font style="vertical-align: inherit;">Es enth√§lt wieder dieselbe Ausf√ºhrungsmethode, hier handelt es sich um eine rein virtuelle Methode.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> detail {<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassConcept</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">virtual</span> ~PassConcept() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> </span>= <span class="hljs-number">0</span>;<font></font>
<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite Klasse, PassModel, ist ebenfalls Boilerplate. </font><font style="vertical-align: inherit;">Es wird von PassConcept geerbt.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span> PassT, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassModel</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> PassConcept&lt;IR, ArgTs...&gt; {
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">PassModel</span><span class="hljs-params">(PassT Pass)</span> : <span class="hljs-title">pass_</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::move(pass))</span> </span>{}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> <span class="hljs-keyword">final</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass_.run(ir, args...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PassT pass_;<font></font>
<font></font>
};<font></font>
<font></font>
} <span class="hljs-comment">// end namespace detail</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was es enth√§lt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Privates pass_-Feld vom Typ PassT</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Konstruktor, der ein Objekt vom Typ PassT als Eingabe akzeptiert. </font><font style="vertical-align: inherit;">Es macht nichts Interessantes, es initialisiert pass_ nur mit der Semantik der Bewegung</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die run-Methode, die einfach die run-Methode beim Pass aufruft. </font><font style="vertical-align: inherit;">√úbergabe aller Argumente, die m√∂glicherweise vorhanden sind.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erinnern uns jetzt, wo wir angefangen haben. PassManager speichert wiederum alle diese Passagen. In Vektor√ºberg√§ngen von PassConcept-Typelementen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also das gro√üe Ganze. Erstellt von PassManager. Mit AddPass werden die Durchg√§nge aufgezeichnet, die √ºber das Modul, die Funktion, die Schleife usw. ausgef√ºhrt werden sollen. Zum Beispiel Inline, konstante Ausbreitung, Abrollen von Schleifen usw. Sie selbst werden von niemandem geerbt, sie sollten nur eine Ausf√ºhrungsmethode haben. Und genau dieses ganze Konzept bietet dies. Auf welche Weise?&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir haben Inline-Optimierung. Wir f√ºgen addPass ein Objekt vom Typ Inline hinzu. Dementsprechend setzen wir in Passes im Vektor diese Inline bereits in Form von PassConcept. Wie k√∂nnen wir das machen? Inline wird nicht von der PassConcept-Klasse geerbt. Wie setzen wir ein Element in einen Vektor? Wir k√∂nnen das Casting nicht auf den Basistyp durchf√ºhren (Upcasting), da es keine Vererbung gibt. Und hier wird ein solcher Trick gemacht. Wir haben diese PassConcept-Hilfsklasse, die die Schnittstelle definiert. Er sagt, dass alle seine Nachkommen die Ausf√ºhrungsmethode implementieren m√ºssen. Wir haben PassModel, das wiederum Boilerplate ist. Wenn wir also Inline einf√ºgen, wird dieses PassModel mit diesem Inline-Typ instanziiert. Dieses Objekt wird in dieser Klasse kompiliert. PassModel selbst definiert run neu, was f√ºr sich bereits run f√ºr diese Passage aufruft.d.h. von der Inline-Klasse ausf√ºhren. All dies wird in der Kompilierungszeit behoben: Wenn Inline die Ausf√ºhrungsmethode nicht definiert, tritt ein Fehler in der Kompilierungszeit auf.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit wird dieser Polymorphismus ohne Vererbung erreicht. Es kann sich die Frage stellen: Wie ist es nicht Vererbung, denn hier ist es, PassModel wird von PassConcept geerbt? Antwort: Es gibt Vererbung, aber es ist intern, es ragt nicht heraus, der Benutzer wei√ü nichts dar√ºber. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sprechen auf konzeptioneller Ebene. Hier haben wir einen Benutzer, der eine bestimmte Methode √ºberschreiben m√∂chte. Gleichzeitig m√∂chte er nicht vererbt werden, um keine zus√§tzlichen Abh√§ngigkeiten von sich selbst zu ziehen. Wie kann man das machen? Wir in uns selbst machen durch PassConcept, PassModel Laufzeitpolymorphismus, durch Vererbung, aber der Benutzer wei√ü nichts davon: Dies sind alle Innenr√§ume dieser beiden Klassen, sie sind in ihrem Namespace definiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wird dies noch einmal erreicht? </font><font style="vertical-align: inherit;">Ich habe eine Klasse, nennen wir sie Inline, was den Compiler betrifft. </font><font style="vertical-align: inherit;">Wir f√ºgen dem Vektor Inline hinzu und erstellen das PassModel-Objekt. </font><font style="vertical-align: inherit;">Es hat einen Konstruktor, der das Objekt dieses Vorlagenparameters aufnimmt. </font><font style="vertical-align: inherit;">Wenn wir also die run-Methode in PassManager aufrufen, werden alle Passagen durchlaufen. In diesem Fall haben wir nur einen Durchgang und den Inline-Typ. </font><font style="vertical-align: inherit;">Es ruft die runC-Methode von PassConcept auf. </font><font style="vertical-align: inherit;">Dieselbe Ausf√ºhrungsmethode wie in PassModel, die vom Inline-Typ instanziiert wird. </font><font style="vertical-align: inherit;">Und bereits diese Methode ruft die run-Methode f√ºr die registrierte Passage auf, in diesem Fall Inline, und als Ergebnis wird run on Inline aufgerufen.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorteile des Ansatzes</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise haben wir uns anders verhalten, ohne die Vererbung explizit zu verwenden. Wir haben jetzt nicht die explizite Abh√§ngigkeit, die zuvor im LegacyPassManager war.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was f√ºr eine ungew√∂hnliche rekursive Sache es sich herausstellt. Wir k√∂nnen Polymorphismus f√ºr jedes Objekt verwenden, das die Ausf√ºhrungsmethode √ºberschreibt. Da die run-Methode PassManager selbst √ºberschreibt, kann sie sich selbst registrieren, dh sich in den Passes-Passvektor einbetten und sich erneut aufrufen.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich heraus, dass wir alles mischen k√∂nnen. Der alte PassManager, der Legacy ist, hat eine klare Trennung. Es gibt eine modulare Optimierung, die am Modul durchgef√ºhrt wird. Es gibt eine Optimierung der Funktion. Und hier l√§uft alles reibungslos. Wir machen PassManager, instanziieren es mit dem Typ "Modul", f√ºgen Inline ein, etwas anderes, einige andere modulare Optimierungen. Dann instanziieren wir den zweiten PassManager, den wir mit dem Typ "Funktion" instanziieren, und optimieren die Funktion. Und dann k√∂nnen Sie im PassManager, der vom Modul instanziiert wird, einen weiteren PassManager, der von der Funktion instanziiert wird, √ºber diesen Passes-Vektor einf√ºgen.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs">PassManager&lt;Module&gt; MPM;
<span class="hljs-comment">// ... register passes on module</span><font></font>
MPM.addPass(GlobalDCEPass())<font></font>
MPM.addPass(PGOInstrumentationGen());<font></font>
<span class="hljs-comment">//... register passes on function</span><font></font>
PassManager&lt;Function&gt; FPM;&nbsp;<font></font>
FPM.addPass(CallSiteSplittingPass());<font></font>
<span class="hljs-comment">//... register all registered passes on function in module pass manager MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hast du Zeit zu folgen? Wir haben zwei PassManager. Eines mit Typ IR-Modul, das andere mit Typ IR-Funktion. Nehmen wir an, wir haben in dem Modul bereits einige Durchg√§nge durchgef√ºhrt. Jetzt wollen wir sie mit Durchl√§ufen mischen, die f√ºr eine Funktion ausgef√ºhrt werden. Was machen wir? Wir nennen addPass und √ºbergeben PassManager als Pass, was mit dem IR-Typ "Function" instanziiert wird (im realen Code wird nicht PassManager dort platziert, sondern eine spezielle Klasse, die es umschlie√üt, aber auf konzeptioneller Ebene spielt es keine Rolle).&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise k√∂nnen wir verschiedene Optimierungsstufen mischen - dank der Verschachtelung von PassManagern k√∂nnen Sie abwechselnd Durchg√§nge zum Modul, zur Funktion, zum Zyklus usw. ausf√ºhren. </font><font style="vertical-align: inherit;">In Legacy PassManager ist dies komplizierter. Es gibt eine separate Klasse f√ºr Module mit einer virtuellen Funktion runOnModule, eine separate Klasse f√ºr Funktionen mit einer virtuellen Methode runOnFunction usw. </font><font style="vertical-align: inherit;">Beide Klassen werden vom gemeinsamen Vorfahren von Pass geerbt, sind jedoch unabh√§ngig voneinander und verf√ºgen √ºber eine andere Schnittstelle, wodurch die Verwendung des LegacyPassManager zum Aufrufen von P√§ssen f√ºr verschiedene IR-Entit√§ten (Modul, Funktion, Schleife) unpraktisch wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zus√§tzliche Lesematerialien:</font></font><br>
&nbsp;<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM f√ºr Studenten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Eine einfache Einf√ºhrung in LLVM</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√§sentation von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chandler Carrut √ºber die Anordnung von LLVM-P√§ssen</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√§sentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chandler Carruth √ºber Implementierungsdetails PassManager</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Thread</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der Mailingliste, der den Unterschied zwischen LegacyPassManager und PassManager erl√§utert</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autoren: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/73/et/tp/73ettpg9jylifuwfvohspok-nv4.png" align="left"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roman Rusyaev, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Experte Ingenieur </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AI Compiler Team </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Samsung F &amp; E-Institut, Russland </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bald wird Roman auf der C ++ Russia 2020 Moskau-Konferenz mit Anton Polukhin sprechen: Dort werden sie √ºber die gegenw√§rtige und zuk√ºnftige Wahl der Kopien sprechen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zum Bericht</font></font></a><br>
<br clear="all">
<img src="https://habrastorage.org/webt/ay/fa/a2/ayfaa2i4aukgor-uh5ija7gstie.png" align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tatyana Volkova, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lead Specialist </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Business Entwicklungsteam </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Samsung R &amp; D Institute, Russland</font></font></i><br>
<br clear="all"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de505824/index.html">Anleitung: Ihr eigenes L2TP-VPN</a></li>
<li><a href="../de505826/index.html">Wie man 100% Vision und noch mehr bekommt</a></li>
<li><a href="../de505834/index.html">Medianproben. Konfidenzintervalle und Vergleich</a></li>
<li><a href="../de505838/index.html">FPGA-Technologie f√ºr Tausende von Anwendungen</a></li>
<li><a href="../de505846/index.html">Was sind die wirklichen mathematischen Probleme bei der Entwicklung von Impfstoffen aus COVID-19?</a></li>
<li><a href="../de505856/index.html">Von Brute-Force bis zum Versuch der Privatsph√§re - was SaaS-Anbieter erwartet</a></li>
<li><a href="../de505860/index.html">Spring Boot, Hibernate und Kotlin f√ºr Anf√§nger Schritt f√ºr Schritt</a></li>
<li><a href="../de505870/index.html">Wie man mobile Spiele und Anwendungen in Japan, Korea und China bewirbt</a></li>
<li><a href="../de505872/index.html">Geschichte unbemannter Fahrzeuge</a></li>
<li><a href="../de505880/index.html">So schreiben Sie Ihren Index in Tarantool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>