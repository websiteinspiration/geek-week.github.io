<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ†— â†–ï¸ ğŸ†– Memerangi kebocoran memori dalam aplikasi web ğŸ¤¶ğŸ½ ğŸ›¤ï¸ ğŸ‘¨ğŸ½â€âœˆï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika kami pindah dari pengembangan situs web, halaman yang dibentuk di server, ke pembuatan aplikasi web satu halaman yang diberikan pada klien, kam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Memerangi kebocoran memori dalam aplikasi web</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/490622/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika kami pindah dari pengembangan situs web, halaman yang dibentuk di server, ke pembuatan aplikasi web satu halaman yang diberikan pada klien, kami mengadopsi aturan tertentu dari permainan. Salah satunya adalah penanganan sumber daya yang akurat pada perangkat pengguna. Ini berarti - jangan menghalangi arus utama, jangan "memutar" kipas laptop, jangan meletakkan baterai ponsel. Kami bertukar peningkatan interaktivitas proyek web, dan fakta bahwa perilaku mereka menjadi lebih seperti perilaku aplikasi biasa, kelas masalah baru yang tidak ada di dunia rendering server.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/wv/_c/nl/wv_cnlo46dgs8op0yzhybzgkpw8.jpeg"></a><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu masalah tersebut adalah kebocoran memori. </font><font style="vertical-align: inherit;">Aplikasi satu halaman yang dirancang dengan buruk dapat dengan mudah melahap megabita atau bahkan gigabita memori. </font><font style="vertical-align: inherit;">Itu dapat mengambil lebih banyak dan lebih banyak sumber daya bahkan ketika itu duduk diam di tab latar belakang. </font><font style="vertical-align: inherit;">Halaman aplikasi semacam itu, setelah menangkap sumber daya dalam jumlah yang sangat tinggi, mungkin mulai "melambat" dengan sangat. </font><font style="vertical-align: inherit;">Selain itu, browser dapat dengan mudah mematikan tab dan memberi tahu pengguna: "Ada yang salah."</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34b/e9d/da8/34be9dda87ca7f35d70a1a934816ce78.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada yang salah</font></font></font></i><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, situs yang dirender di server juga dapat mengalami masalah kebocoran memori. Tetapi di sini kita berbicara tentang memori server. Pada saat yang sama, sangat tidak mungkin aplikasi semacam itu akan menyebabkan kebocoran memori pada klien, karena browser menghapus memori setelah setiap transisi pengguna antar halaman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Topik kebocoran memori tidak tercakup dengan baik dalam publikasi pengembangan web. Dan meskipun demikian, saya hampir yakin bahwa sebagian besar aplikasi halaman tunggal yang tidak sepele menderita kebocoran memori - kecuali tim yang berurusan dengan mereka memiliki alat yang dapat diandalkan untuk mendeteksi dan memperbaiki masalah ini. Intinya di sini adalah bahwa dalam JavaScript sangat mudah untuk secara acak mengalokasikan sejumlah memori, dan kemudian lupa untuk membebaskan memori ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penulis artikel, terjemahan yang kami terbitkan hari ini, akan berbagi dengan pembaca pengalamannya dalam memerangi kebocoran memori dalam aplikasi web, dan juga ingin memberikan contoh deteksi efektif mereka.</font></font><br>
<cut></cut><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa begitu sedikit yang ditulis tentang ini?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, saya ingin berbicara tentang mengapa sedikit sekali yang ditulis tentang kebocoran memori. </font><font style="vertical-align: inherit;">Saya kira di sini Anda dapat menemukan beberapa alasan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurangnya keluhan pengguna: sebagian besar pengguna tidak sibuk memantau task manager saat menjelajah web. </font><font style="vertical-align: inherit;">Biasanya, pengembang tidak menemui keluhan pengguna hingga kebocoran memori sangat serius sehingga menyebabkan ketidakmampuan untuk bekerja atau memperlambat aplikasi.</font></font></li>
<li>  :   Chrome   -   ,     .          .</li>
<li> :            .</li>
<li>      :       Â«Â»     .   ,     ,   , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>,   -.</li>
</ul><br>
<h2><font color="#3AC1EF">  </font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perpustakaan dan kerangka kerja modern untuk mengembangkan aplikasi web, seperti React, Vue dan Svelte, menggunakan model komponen aplikasi. Dalam model ini, cara paling umum untuk menyebabkan kebocoran memori adalah sesuatu seperti ini:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage.bind(<span class="hljs-keyword">this</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu saja. </font><font style="vertical-align: inherit;">Ini semua yang diperlukan untuk "melengkapi" proyek dengan kebocoran memori. </font><font style="vertical-align: inherit;">Untuk melakukan ini, panggil saja metode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addEventListener</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari </font><font style="vertical-align: inherit;">beberapa objek global (seperti </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, atau </font></font><code>&lt;body&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, atau sesuatu yang serupa), dan kemudian, ketika melepas komponen, lupa untuk menghapus pendengar acara menggunakan metode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">removeEventListener</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi konsekuensi dari ini bahkan lebih buruk, karena kebocoran seluruh komponen terjadi. </font><font style="vertical-align: inherit;">Ini disebabkan oleh fakta bahwa metode tersebut </font></font><code>this.onMessage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dilampirkan </font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seiring dengan komponen ini, kebocoran komponen anak terjadi. </font><font style="vertical-align: inherit;">Sangat mungkin bahwa semua node DOM yang terkait dengan komponen ini akan bocor. </font><font style="vertical-align: inherit;">Akibatnya, situasi dapat keluar dari kendali dengan sangat cepat, yang mengakibatkan konsekuensi yang sangat buruk.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inilah cara mengatasi masalah ini:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">this</span>.onMessage = <span class="hljs-keyword">this</span>.onMessage.bind(<span class="hljs-keyword">this</span>);
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage);<font></font>
&nbsp;<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage);</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Situasi di mana kebocoran memori paling sering terjadi</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengalaman memberi tahu saya bahwa kebocoran memori paling sering terjadi ketika menggunakan API berikut:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode </font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Di sinilah kebocoran memori paling sering terjadi. </font><font style="vertical-align: inherit;">Untuk mengatasi masalah, cukup menelepon pada waktu yang tepat </font></font><code>removeEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">setTimeout</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">setInterval</a>.   ,        (,  30 ),  ,   ,      ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">clearTimeout</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">clearInterval</a>. ,    <code>setTimeout</code>,  Â«Â»   ,    ,     <code>setInterval</code>-.  ,    <code>setTimeout</code>       .</li>
<li>API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IntersectionObserver</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ResizeObserver</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MutationObserver</a>   .  ,  ,  .         .     -         ,  ,   ,     ,   ,   <code>disconnect</code>  .    ,     DOM    ,           ,  -.        -,     .  â€”  <code>&lt;body&gt;</code>,  <code>document</code>,   <code>header</code>  <code>footer</code>,     .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Promise-</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>      .   ,    ,     â€”   ,      . , ,  Â«Â»   ,        .    Â«Â»     <code>.then()</code>-.</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repositori diwakili oleh objek global. </font><font style="vertical-align: inherit;">Ketika Anda menggunakan sesuatu seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk mengontrol keadaan aplikasi </font><font style="vertical-align: inherit;">, state store diwakili oleh objek global. </font><font style="vertical-align: inherit;">Akibatnya, jika Anda berurusan dengan penyimpanan seperti itu dengan ceroboh, data yang tidak perlu tidak akan dihapus darinya, sehingga ukurannya akan terus meningkat.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertumbuhan DOM yang tak terbatas. </font><font style="vertical-align: inherit;">Jika halaman mengimplementasikan pengguliran tanpa akhir tanpa menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtualisasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ini berarti bahwa jumlah node DOM pada halaman ini dapat tumbuh tanpa batas.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di atas, kami memeriksa situasi di mana kebocoran memori paling sering terjadi, tetapi, tentu saja, ada banyak kasus lain yang menyebabkan masalah menarik bagi kami.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Identifikasi kebocoran memori</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita telah beralih ke tantangan mengidentifikasi kebocoran memori. Untuk memulainya, saya tidak berpikir bahwa salah satu alat yang ada sangat cocok untuk ini. Saya mencoba alat analisis memori Firefox, mencoba alat dari Edge dan IE. Diuji bahkan Windows Performance Analyzer. Tetapi yang terbaik dari alat-alat ini masih Alat Pengembang Chrome. Benar, dalam alat ini ada banyak "sudut tajam", yang patut diketahui. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di antara alat yang diberikan pengembang Chrome, kami paling tertarik pada profiler </font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari tab </font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang memungkinkan Anda membuat foto tumpukan. Ada alat lain untuk menganalisis memori di Chrome, tetapi saya belum dapat mengekstrak manfaat khusus dari mereka dalam mendeteksi kebocoran memori.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7d/e42/63a/e7de4263abd59eecce420c4bcbfc55ea.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap snapshot tool memungkinkan Anda mengambil snapshot dari memori aliran utama, pekerja web atau elemen iframe.Jika</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
jendela tool Chrome terlihat seperti yang ditunjukkan pada gambar sebelumnya, ketika Anda mengklik tombol</font></font><code>Take snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, informasi tentang semua objek dalam memori mesin virtual yang dipilih ditangkap. JavaScript dari halaman yang diselidiki. Ini termasuk objek yang dirujuk</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, objek yang direferensikan oleh callback yang digunakan dalam panggilan</font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan sebagainya. Sebuah snapshot dari memori dapat dianggap sebagai "momen beku" dari pekerjaan entitas yang diselidiki, mewakili informasi tentang semua memori yang digunakan oleh entitas ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah foto diambil, kita sampai pada langkah berikutnya untuk menemukan kebocoran. Ini terdiri dalam mereproduksi skenario di mana, menurut pengembang, kebocoran memori dapat terjadi. Misalnya, membuka dan menutup jendela modal tertentu. Setelah jendela yang sama ditutup, diharapkan jumlah memori yang dialokasikan akan kembali ke tingkat yang ada sebelum jendela dibuka. Oleh karena itu, mereka mengambil gambar lain, dan kemudian membandingkannya dengan gambar yang diambil sebelumnya. Faktanya, perbandingan gambar adalah fitur yang paling penting yang menarik bagi kami </font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92d/776/4c7/92d7764c7fbe5d561032c3bc092e1541.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengambil snapshot pertama, lalu kami mengambil tindakan yang dapat menyebabkan kebocoran memori, dan kemudian kami mengambil snapshot lain. </font><font style="vertical-align: inherit;">Jika tidak ada kebocoran, ukuran memori yang dialokasikan akan sama.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Benar, ini</font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jauh dari alat yang ideal. </font><font style="vertical-align: inherit;">Ini memiliki beberapa batasan yang perlu diketahui:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan jika Anda mengklik tombol kecil pada panel </font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang memulai pengumpulan sampah ( </font></font><code>Collect garbage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), maka untuk memastikan bahwa memori benar-benar dihapus, Anda mungkin perlu mengambil beberapa gambar berurutan. </font><font style="vertical-align: inherit;">Saya biasanya memiliki tiga tembakan. </font><font style="vertical-align: inherit;">Ini ada baiknya fokus pada ukuran total dari setiap gambar - itu, pada akhirnya, harus stabil.</font></font></li>
<li>    -, -,  <code>iframe</code>,      ,   ,          .   ,        JavaScript.   â€”      ,       ,    .</li>
<li>           Â«Â».             .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada titik ini, jika aplikasi Anda cukup kompleks, Anda mungkin memperhatikan banyak objek "bocor" ketika membandingkan foto. </font><font style="vertical-align: inherit;">Di sini situasinya agak rumit, karena apa yang dapat disalahartikan sebagai kebocoran memori tidak selalu demikian. </font><font style="vertical-align: inherit;">Banyak hal yang mencurigakan hanyalah proses normal untuk bekerja dengan objek. </font><font style="vertical-align: inherit;">Memori yang ditempati oleh beberapa objek dihapus untuk menempatkan objek lain dalam memori ini, ada sesuatu yang memerah ke cache, dan sehingga memori yang sesuai tidak segera dihapus, dan sebagainya.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melewati kebisingan informasi</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menemukan bahwa cara terbaik untuk menembus kebisingan informasi adalah mengulangi tindakan yang seharusnya menyebabkan kebocoran memori. Misalnya, alih-alih membuka dan menutup jendela modal hanya sekali setelah menangkap bidikan pertama, ini dapat dilakukan 7 kali. Mengapa 7? Ya, jika hanya karena 7 adalah prima yang terlihat. Maka Anda perlu mengambil bidikan kedua dan, membandingkannya dengan yang pertama, cari tahu apakah benda tertentu "bocor" 7 kali (atau 14 kali, atau 21 kali).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/ac2/243/2a7ac2243dc82f0e7887b23098e7c893.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bandingkan snapshot tumpukan. Harap perhatikan bahwa kami membandingkan gambar No. 3 dengan gambar No. 6. Faktanya adalah saya mengambil tiga pemotretan berturut-turut sehingga Chrome akan memiliki lebih banyak sesi pengumpulan sampah. Selain itu, perhatikan bahwa beberapa benda "bocor" sebanyak 7 kali.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Trik lain yang bermanfaat adalah bahwa, pada awal penelitian, sebelum membuat gambar pertama, lakukan prosedur satu kali, di mana, seperti yang diharapkan, kebocoran memori. Ini terutama disarankan jika pemisahan kode digunakan dalam proyek. Dalam kasus seperti itu, sangat mungkin bahwa pada pelaksanaan pertama dari tindakan yang mencurigakan, modul JavaScript yang diperlukan akan dimuat, yang akan mempengaruhi jumlah memori yang dialokasikan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang Anda mungkin memiliki pertanyaan tentang mengapa Anda harus memberi perhatian khusus pada jumlah objek, dan bukan pada jumlah total memori. Di sini kita dapat mengatakan bahwa kita secara intuitif berusaha mengurangi jumlah "kebocoran" memori. Dalam hal ini, Anda mungkin berpikir bahwa Anda harus memantau jumlah total memori yang digunakan. Tetapi pendekatan ini, untuk satu alasan penting, tidak cocok untuk kita secara khusus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika sesuatu â€œbocorâ€, itu terjadi karena (menceritakan kembali </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Joe Armstrong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) Anda memerlukan pisang, tetapi Anda berakhir dengan pisang, gorila yang memegangnya, dan juga, di samping itu, semua hutan. Jika kita fokus pada jumlah total ingatan, itu akan sama dengan "mengukur" hutan, dan bukan pisang yang menarik minat kita.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e8/af8/847/7e8af8847ab7e8689e1638ac218582d6.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorila makan pisang.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sekarang kembali ke contoh di atas dengan</font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sumber kebocoran adalah pendengar acara yang mereferensikan suatu fungsi. Dan fungsi ini, pada gilirannya, mengacu pada komponen yang, mungkin, menyimpan tautan ke banyak barang bagus seperti array, string, dan objek.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda menganalisis perbedaan antara gambar, menyortir entitas dengan jumlah memori yang ditempati, ini akan memungkinkan Anda untuk melihat banyak array, garis, objek, yang sebagian besar kemungkinan besar tidak terkait dengan kebocoran. Dan setelah semua, kita perlu menemukan pendengar acara dari mana semuanya dimulai. Dia, dibandingkan dengan apa yang dia maksudkan, hanya menggunakan sedikit memori. Untuk memperbaiki kebocoran, Anda perlu menemukan pisang, bukan rimba.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, jika Anda mengurutkan catatan berdasarkan jumlah objek "bocor", Anda akan melihat 7 pendengar acara. </font><font style="vertical-align: inherit;">Dan mungkin 7 komponen, dan 14 subkomponen, dan mungkin sesuatu yang lain seperti itu. </font><font style="vertical-align: inherit;">Angka 7 ini harus menonjol dari gambaran besar, karena bagaimanapun, angka yang agak mencolok dan tidak biasa. </font><font style="vertical-align: inherit;">Dalam hal ini, tidak masalah berapa kali tindakan mencurigakan diulang. </font><font style="vertical-align: inherit;">Saat memeriksa gambar, jika kecurigaan dibenarkan, itu akan direkam seperti banyak objek "bocor". </font><font style="vertical-align: inherit;">Ini adalah bagaimana Anda dapat dengan cepat mengidentifikasi sumber kebocoran memori.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis Tautan Pohon</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alat untuk membuat snapshot menyediakan kemampuan untuk melihat "rantai penghubung" yang membantu Anda menemukan objek mana yang dirujuk oleh objek lain. </font><font style="vertical-align: inherit;">Inilah yang memungkinkan aplikasi berfungsi. </font><font style="vertical-align: inherit;">Dengan menganalisis "rantai" atau "pohon" tautan seperti itu, Anda dapat mengetahui dengan tepat di mana memori dialokasikan untuk objek "bocor".</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bf/77a/07d/7bf77a07dd2d15e479f77c2279b9942d.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rantai tautan memungkinkan Anda menemukan objek mana yang merujuk ke objek "bocor". </font><font style="vertical-align: inherit;">Saat membaca rantai ini, perlu diperhitungkan bahwa objek yang terletak di bawahnya merujuk ke objek yang terletak di atas.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pada contoh di atas, ada variabel yang disebut</font></font><code>someObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direferensikan dalam closure (</font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) yang dirujuk oleh event listener. </font><font style="vertical-align: inherit;">Jika Anda mengklik tautan yang mengarah ke kode sumber, teks program yang cukup dapat dimengerti akan ditampilkan:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeObject</span> () </span>{ <span class="hljs-comment">/* ... */</span> }<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> someObject = <span class="hljs-keyword">new</span> SomeObject();
<span class="hljs-keyword">const</span> onMessage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">/* ... */</span> };
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, onMessage);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita membandingkan kode ini dengan gambar sebelumnya, ternyata </font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angka itu adalah penutup </font></font><code>onMessage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang merujuk </font></font><code>someObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contoh buatan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kebocoran memori nyata bisa menjadi kurang jelas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu dicatat bahwa alat snapshot tumpukan memiliki beberapa keterbatasan:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda menyimpan file snapshot dan kemudian mengunggahnya lagi, tautan ke file dengan kode hilang. </font><font style="vertical-align: inherit;">Misalnya, setelah mengunduh snapshot, tidak mungkin untuk mengetahui bahwa kode penutupan pendengar acara ada di baris 22 file </font></font><code>foo.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Karena informasi ini sangat penting, menyimpan file snapshot tumpukan, atau, misalnya, mentransfernya ke seseorang, hampir tidak berguna.</font></font></li>
<li>     <code>WeakMap</code>,  Chrome       ,      . ,   ,     ,    ,   .    <code>WeakMap</code> â€”     .</li>
<li>Chrome  ,    .  ,        ,     ,     ,     .      ,       <code>object</code>,    <code>EventListener</code>.   <code>object</code> â€”     ,  ,   ,  Â«Â»   7  .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah deskripsi strategi dasar saya untuk mengidentifikasi kebocoran memori. </font><font style="vertical-align: inherit;">Saya telah berhasil menggunakan teknik ini untuk mendeteksi lusinan kebocoran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Benar, saya harus mengatakan bahwa panduan ini untuk menemukan kebocoran memori hanya mencakup sebagian kecil dari apa yang terjadi dalam kenyataan. </font><font style="vertical-align: inherit;">Ini baru permulaan pekerjaan. </font><font style="vertical-align: inherit;">Selain itu, Anda harus dapat menangani pemasangan breakpoints, logging, pengujian koreksi untuk menentukan apakah mereka memecahkan masalah. </font><font style="vertical-align: inherit;">Dan, sayangnya, semua ini, pada intinya, diterjemahkan menjadi investasi waktu yang serius.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis kebocoran memori otomatis</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin memulai bagian ini dengan fakta bahwa saya tidak dapat menemukan pendekatan yang baik untuk mengotomatiskan deteksi kebocoran memori. Chrome memiliki </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">performance.memory</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API sendiri </font><font style="vertical-align: inherit;">, tetapi untuk alasan privasi, </font><font style="vertical-align: inherit;">Chrome </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak memungkinkan Anda untuk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengumpulkan data yang cukup rinci. Akibatnya, API ini tidak dapat digunakan dalam produksi untuk mendeteksi kebocoran. Kelompok Kerja Kinerja Web W3C sebelumnya membahas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memori, tetapi para anggotanya belum menyetujui standar baru yang dirancang untuk menggantikan API ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di lingkungan pengujian, Anda dapat meningkatkan rincian output data </font></font><code>performance.memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan bendera Chrome - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengaktifkan-tepatnya-memori-info</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Snapshot tumpukan masih dapat dibuat menggunakan tim Chromedriver sendiri </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: takeHeapSnapshot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tim ini memiliki keterbatasan yang sama dengan yang telah kita diskusikan. Sangat mungkin bahwa jika Anda menggunakan perintah ini, maka, untuk alasan yang dijelaskan di atas, masuk akal untuk memanggilnya tiga kali, dan kemudian hanya menerima apa yang diterima sebagai hasil dari panggilan terakhirnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena pendengar peristiwa adalah sumber kebocoran memori yang paling umum, saya akan berbicara tentang teknik deteksi kebocoran lain yang saya gunakan. Ini terdiri dari membuat tambalan monyet untuk API </font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>removeEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam menghitung tautan untuk memeriksa apakah jumlahnya kembali ke nol. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contoh bagaimana hal ini dilakukan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di Alat Pengembang Chrome, Anda juga dapat menggunakan API asli </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getEventListeners</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk mengetahui pendengar acara mana yang dilampirkan ke elemen tertentu. </font><font style="vertical-align: inherit;">Namun, perintah ini hanya tersedia dari bilah alat pengembang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin menambahkan bahwa Matthias Binens memberi tahu saya tentang API alat Chrome lain yang bermanfaat. </font><font style="vertical-align: inherit;">Ini adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queryObjects</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dengannya, Anda bisa mendapatkan informasi tentang semua objek yang dibuat menggunakan konstruktor tertentu. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beberapa materi bagus tentang topik ini tentang mengotomatisasi deteksi kebocoran memori di Puppeteer.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ringkasan</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mencari dan memperbaiki kebocoran memori dalam aplikasi web masih dalam tahap awal. Di sini saya berbicara tentang beberapa teknik yang, dalam kasus saya, berkinerja baik. Tetapi harus diakui bahwa penerapan teknik ini masih penuh dengan kesulitan-kesulitan tertentu dan menyita waktu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti halnya masalah kinerja, seperti yang mereka katakan, sejumput sebelumnya bernilai satu pound. Mungkin seseorang akan merasa berguna untuk menyiapkan tes sintetik yang sesuai daripada menganalisis kebocoran setelah itu terjadi. Dan jika itu bukan satu kebocoran, tetapi beberapa, maka analisis masalah dapat berubah menjadi sesuatu seperti mengupas bawang: setelah satu masalah diperbaiki, yang lain ditemukan, dan kemudian proses ini berulang (dan selama ini, seperti dari bawang , air mata. Ulasan kode juga dapat membantu mengidentifikasi pola kebocoran umum. Tapi ini - jika Anda tahu - ke mana harus mencari.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript adalah bahasa yang memberikan keamanan bekerja dengan memori. </font><font style="vertical-align: inherit;">Oleh karena itu, ada beberapa ironi dalam betapa mudahnya kebocoran memori terjadi dalam aplikasi web. </font><font style="vertical-align: inherit;">Benar, ini sebagian karena fitur antarmuka pengguna perangkat. </font><font style="vertical-align: inherit;">Anda perlu mendengarkan banyak acara: acara mouse, acara gulir, acara keyboard. </font><font style="vertical-align: inherit;">Menerapkan semua pola ini dapat dengan mudah menyebabkan kebocoran memori. </font><font style="vertical-align: inherit;">Tetapi, berusaha untuk memastikan bahwa aplikasi web kami menggunakan memori dengan hemat, kami dapat meningkatkan kinerjanya dan melindunginya dari "gangguan". </font><font style="vertical-align: inherit;">Selain itu, dengan demikian kami menunjukkan penghormatan terhadap batas sumber daya perangkat pengguna. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembaca yang budiman! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pernahkah Anda mengalami kebocoran memori di proyek web Anda?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id490610/index.html">Baidu Beats Waymo di California Peringkat otonomi Robomobile</a></li>
<li><a href="../id490612/index.html">Pendekatan fungsional untuk transaksi di Scala atau tulis monad Anda sendiri yang bermanfaat</a></li>
<li><a href="../id490616/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 404 (24 Februari - 1 Maret 2020)</a></li>
<li><a href="../id490618/index.html">Goroutine Stack Buffer</a></li>
<li><a href="../id490620/index.html">Ketika saya mendengar kata-kata "memulihkan jaringan saraf", saya memanjat untuk memeriksa cadangan</a></li>
<li><a href="../id490624/index.html">Fitur-Kebijakan HTTP Header dan Kontrol Browser Web</a></li>
<li><a href="../id490626/index.html">Panduan lengkap untuk data- * atribut HTML</a></li>
<li><a href="../id490628/index.html">Apa yang harus dilakukan ketika CSS memblokir parsing halaman?</a></li>
<li><a href="../id490630/index.html">Memuat NumPy Array dari Disk: Perbandingan memmap () dan Zarr / HDF5</a></li>
<li><a href="../id490634/index.html">Acara digital di Moskow dari 2 hingga 8 Maret</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>