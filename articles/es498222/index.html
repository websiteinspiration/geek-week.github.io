<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèø üßôüèø üòå ZX Spectrum de coronavirus y sticks (en realidad, no realmente) üêÄ üîî üèê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El autoaislamiento es el flagelo de la humanidad moderna. Aqu√≠, por ejemplo, en la ciudad vecina, los viernes y s√°bados, despu√©s de los aplausos tradi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ZX Spectrum de coronavirus y sticks (en realidad, no realmente)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498222/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El autoaislamiento es el flagelo de la humanidad moderna. Aqu√≠, por ejemplo, en la ciudad vecina, los viernes y s√°bados, despu√©s de los aplausos tradicionales a las 8 pm, organizan conciertos en el balc√≥n. Se sienten bien, sus casas son altas y sus vecinos son j√≥venes. Nuestros vecinos son ancianos, no quieren conciertos. Y las casas son bajas, lo que tampoco contribuye a la ociosidad. Por lo tanto, somos salvos como podemos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por la tarde, en un sitio remoto, no est√° tan mal. Como en la noche, hasta que los ni√±os se duerman. Como en los primeros d√≠as, hasta que se agoten los libros y la serie se aburra. Pero pasa un mes, seguido de otro. El alma requiere hierro viejo. Pero no solo, sino con perversi√≥n. Y rebusqu√© en los contenedores de basura y encontr√© el procesador Zilog Z80 all√≠:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7f1/fe7/7c9/7f1fe77c9972b2270ad8478702521555.jpg" alt="imagen"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debo decir que realmente amo este procesador. Probablemente lo √∫nico que me gusta de √©l es el chip 486, pero mis manos no lo alcanzar√°n pronto, porque es dif√≠cil e in√∫til insertarlo en el tablero. Hay que soldar. Pero todav√≠a no quiero soldar. E incluso m√°s que el Z80 en s√≠, me encanta la computadora ZX Spectrum construida sobre esta base. Pero el Spectrum nativo sufre un desastre en forma de un chip l√≥gico personalizado ULA, y sus clones sueltos, aunque no son particularmente dif√≠ciles de construir y refinar, todav√≠a no son para el modelo de placa de pruebas, y de hecho, ¬øpor qu√© tantas preocupaciones cuando hay arduino?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un lector inteligente, equilibrado y adecuado aqu√≠ dejar√° de leer o arrojar√° algo como "1 chip FPGA acomodar√° la clase de computadora Spectrum" antes de detenerlo. No soy inteligente, ni adecuado, aunque equilibrado, pero solo s√© sobre FPGA que es genial. Solo puedo hacer arduino. Pero realmente quiere meter los cables en el Z80. Muy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Empecemos </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, comencemos. Pero primero, descargo de responsabilidad.</font></font><b>,   ,   ,    .  ‚Äî       .      ,    , .      ,    (,   ?), ,   ,   ,     ,  .       ,    ,  ,   ,   ,    .</b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para empezar, qu√© es una computadora adecuada de 8 bits. Esto, de hecho, es un procesador conectado a ROM y RAM, y en el lateral hay un par de contadores para mostrar en la pantalla compuesta. A veces, un temporizador para chirriar. ZX Spectrum no es diferente del esquema tradicional, excepto por uno pero. Hay una ULA. Este, de hecho, es el "chipset" del Spectrum. ULA administra perif√©ricos, como una grabadora de cinta, tweeter, teclado (parcialmente), salida a la pantalla (s√≠, s√≠, la tarjeta de video integrada apareci√≥ en el conjunto de chips Spectrum antes de que se generalizara). Tambi√©n hubo un monumento compartido, los primeros 16 KiB de RAM (direcciones de 0x4000 a 0x5B00). A partir de √©l, el ULA dibuj√≥ un compuesto en la pantalla, y para que el Z80 no cayera all√≠ cuando no fuera necesario, el ULA podr√≠a detener el procesador, si es necesario, porque la se√±al del reloj del Z80 proven√≠a de √©l. Es decir, si ULA trabaj√≥ con memoria y detect√≥,que el procesador tambi√©n se arrastra en esta memoria (para esto, monitorea constantemente el MREQ y las l√≠neas A15 y A14), simplemente detuvo el reloj del procesador hasta que termin√≥ de hacer lo que necesitaba. Por cierto, para evitar la corrupci√≥n de datos en el bus, partes del bus en el lado del procesador y en el lado ULA fueron delimitadas por ... resistencias ... Adem√°s, la memoria estaba en el bus desde el lado ULA y, en consecuencia, en caso de una colisi√≥n, ignoraba por completo los datos y la direcci√≥n desde el lado del procesador.ignor√≥ completamente los datos y la direcci√≥n del procesador.ignor√≥ completamente los datos y la direcci√≥n del procesador.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, Spectrum ten√≠a ROM (direcciones 0x0000 - 0x3FFF) y su propia memoria de procesador (0x8000 - 0xFFFF), a la que ULA no ten√≠a acceso, y que funcionaba a m√°s de 16 KiB de memoria compartida, ya que el procesador no interfer√≠a con ULA en esta √°rea . Pero eso fue solo en la versi√≥n 48K de la computadora. En la versi√≥n b√°sica, solo hab√≠a ROM y 16 KiB compatibles con ULA. Comenzaremos con ella.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es conveniente que el procesador Z80 pueda regenerar DRAM, pero de alguna manera no quiero molestarlo, porque SRAM es m√°s f√°cil de encontrar y no tengo un multiplexor (o no puedo encontrarlo). Entonces, usaremos SRAM. Para comenzar, ensamblaremos el esqueleto principal, en el que luego se puede colgar todo lo dem√°s. El esqueleto ser√° un procesador, ROM con firmware, mapeado a la direcci√≥n de la ROM, RAM de Spectrum, mapeado a los primeros 16 KiB despu√©s de la ROM y algunos chips para envolver todo ... Debo decir que durante mucho tiempo no quise rotar, porque tengo dise√±os chinos $ 1 por 2 piezas en ibee. Pero, para m√≠, el alboroto vale la pena. Si no desea perder el tiempo durante mucho tiempo, tome buenos dise√±os. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, instale el Z80. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hoja de datos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ee/n6/i0/een6i0aw3zjgv2b4gah5oo9t2ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El procesador tiene 40 pines divididos en grupos: bus de direcci√≥n, bus de datos, control del sistema, control del procesador, control del bus del procesador, pozo, alimentaci√≥n y reloj. No todas estas conclusiones se usan en sistemas reales, como el ZX Spectrum, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como se puede ver en el diagrama.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Del grupo "control de procesador" en Spectrum, solo se usan las se√±ales INT y RESET. La se√±al M1 no se usa del grupo "control del sistema", el grupo "control de bus" no se usa en absoluto. Hay una raz√≥n para esto. Los viejos sistemas de 8 bits eran muy simples, y Spectrum fue creado con la idea de ser lo m√°s simple posible y todo lo que pod√≠a ignorarse era ignorado. Por supuesto, los fabricantes de perif√©ricos podr√≠an usar interrupciones (se√±ales INT y NMI), se enrutaron a la ranura de expansi√≥n, pero NMI no se us√≥ en el espectro en s√≠. Como se puede ver en el diagrama anterior, las se√±ales de NMI, WAIT, BUSREQ son activadas por resistencias de potencia, ya que estas son entradas activadas de bajo nivel (esto se indica mediante la barra sobre el nombre de la se√±al), y debe haber una unidad l√≥gica (es decir, + 5V) para que Dios no permita que la se√±al innecesaria no funcion√≥. Y aqu√≠ est√°n los resultados, BUSACK, HALT, M1,y colgar en el aire, no conectado a nada. Por cierto, tenga en cuenta que no hay un bot√≥n de reinicio en el Spectrum. El pin de reinicio se conecta a trav√©s de</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RC encadena</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al poder (RESET tambi√©n se activa por un nivel bajo), ya que, de acuerdo con la hoja de datos, despu√©s de encender RESET, al menos 3 ciclos de reloj deben estar activos para que el procesador entre en el modo operativo. Este circuito RC mantiene un nivel bajo hasta que el condensador se carga a un nivel alto a trav√©s de una resistencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Repasemos brevemente el resto de las se√±ales: </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M1.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No necesitamos. √âl informa que el procesador comenz√≥ a ejecutar la siguiente instrucci√≥n. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MREQ.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lo necesito. Informa que el procesador est√° accediendo a la memoria. Si esta se√±al se vuelve baja (es decir, conectada a tierra), tendremos que activar la memoria conectada al procesador. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOREQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lo necesito. Informa que el procesador est√° accediendo a un dispositivo perif√©rico. Por ejemplo, al teclado.</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lo necesito. Informa que el procesador leer√° datos de la memoria (si MREQ est√° activo) o perif√©ricos (IOREQ). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lo necesito. Informa que el procesador escribir√° datos en la memoria / perif√©ricos. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFSH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lo necesito. En general, esta se√±al es necesaria para la memoria din√°mica (DRAM). No planeo usarlo, ya que su direccionamiento es m√°s dif√≠cil (matriz, no lineal, es decir, ser√° necesario instalar un multiplexor), y en general, en nuestro tiempo, los microcircuitos SRAM de baja capacidad son m√°s f√°ciles de obtener. Pero dado que el propio procesador regenera DRAM al ordenar las direcciones en el bus de memoria, esta se√±al nos permitir√° ignorar los ciclos de regeneraci√≥n y no activar la memoria con RFSH activo. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HALT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Innecesario. Indica que el procesador est√° detenido. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESPERE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Innecesario. Esta se√±al es necesaria para pedirle al procesador que se detenga y espere un poco. Usualmente utilizado por perif√©ricos lentos o memoria. Pero no en el espectro. Cuando en los perif√©ricos Spectrum (ULA) decide detener el procesador, simplemente deja de enviarle una se√±al de reloj. Esto es m√°s confiable, porque despu√©s de recibir WAIT, el procesador no se detiene inmediatamente. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Interrumpir. A√∫n no est√° claro. Suponemos que a√∫n no es necesario. Entonces lo resolveremos. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El NMI</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Interrupci√≥n indescifrable. Super interrupci√≥n. No es necesario. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">REINICIO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sin ella, no volar√°. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUSREQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Innecesario. Pide al procesador que se desconecte de los buses de datos / direcciones, as√≠ como de las se√±ales de control. Es necesario si alg√∫n dispositivo quiere controlar el bus. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUSACK</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Innecesario. Sirve para informar al dispositivo que realiz√≥ BUSREQ que el bus est√° libre. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El reloj</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se√±al de reloj. Claramente, √©l es necesario. </font><font style="vertical-align: inherit;">Tambi√©n se necesitan </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comidas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Gloria a los desarrolladores, solo + 5V / GND. No 3 te estresa. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A0-A15</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el bus de direcciones. En √©l, el procesador muestra una direcci√≥n de memoria (MREQ est√° activa) o una direcci√≥n de puerto de E / S (IOREQ est√° activa) con las llamadas apropiadas. Como puede ver, el bus tiene 16 bits de ancho, lo que le permite direccionar directamente 64 KiB de memoria. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D0-D7</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - bus de datos. El procesador le env√≠a (WR activo) o lee (RD activo) los datos solicitados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, colocaremos el procesador en la placa de pruebas. Entonces sus conclusiones est√°n ubicadas f√≠sicamente:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dcb/b3f/2c4/dcbb3f2c401007d7aa3e1083e403f301.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conecte la alimentaci√≥n (pin 11 y 29). Por si acaso, tambi√©n puse un condensador de 10 pF entre estas patas. Pero al final no me ayud√≥. Los pines 27, 23, 18 pueden permanecer desconectados de cualquier cosa. Los pines 26, 25, 24, 17, 16 est√°n conectados a trav√©s de resistencias (us√© 10 kOhm) a la fuente de alimentaci√≥n. Llev√© el bus de direcciones (pines 1-5 y 30-40) al lado opuesto de la placa de pruebas, y el bus de datos (pines 7-10 y 12-15) a un bus de datos separado hecho de prototipos de buses de potencia. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los pines 6 (se√±al de reloj) y 26 (RESET) est√°n conectados (m√°s tarde) a Arduin para que pueda controlar el procesador desde √©l. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Result√≥ as√≠:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/in/rx/jminrxjfjixmm4pod6jhxw3kzfy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasta que preste atenci√≥n a los cables desde arriba, van desde la ROM, pasaremos a ello un poco m√°s tarde. Adem√°s, en la foto al lado del procesador, se ve un chip m√°s. Lo necesitamos para decodificar los bits superiores de la direcci√≥n. Como dije anteriormente, hay 3 tipos de memoria en el Spectrum. Los 16 KiB inferiores del espacio de direcciones son ROM. En consecuencia, si los terminales A14 y A15 est√°n en un estado bajo (0 voltios), necesitamos desconectar todo excepto el chip ROM del bus. El siguiente es 16 KiB de memoria compartida. En consecuencia, necesitamos conectar esta memoria al bus (y desconectar el resto) si la salida A15 es baja y A14 es alta (+5 voltios). Bueno, entonces viene 32 KiB de memoria r√°pida. Adjuntaremos esta memoria m√°s tarde, y la activaremos si la salida A15 est√° en un estado alto. Adem√°s, no olvide que solo activamos la memoria cuando est√° activa (aqu√≠, activa - baja,0 voltios) MREQ e inactivo (aqu√≠, inactivo - alto, + 5V) RFSH. Todo esto es bastante simple de implementar en la l√≥gica est√°ndar, en las mismas NAND, como 74HC00 u Orthodox K155LA3, y entiendo que esta tarea es para el grupo preparatorio del jard√≠n de infantes, sin embargo, solo puedo pensar en tablas de verdad en libertad y en cautiverio</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tengo un diagrama de Arlequ√≠n completo all√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , del que simplemente puede tomar la parte donde se extrae U4 (74HC138, afortunadamente tengo alrededor de un centenar de ellos). </font><font style="vertical-align: inherit;">Ignoraremos U11 por claridad, ya que los 32KiB superiores no nos interesan hasta ahora. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conectarse es muy simple. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2h/my/p2/2hmyp2xuiiuejpixie4e1mnoo1w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se puede ver en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">breve descripci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El microcircuito es un decodificador que recibe n√∫meros binarios del 000 al 111 en los terminales 1 a 3 y activa una de las 8 salidas (patas 7 y 9 a 15) correspondientes a este n√∫mero. </font><font style="vertical-align: inherit;">Como solo se pueden almacenar 8 n√∫meros diferentes en 3 bits, solo hay ocho salidas. </font><font style="vertical-align: inherit;">Como puede ver, las conclusiones est√°n invertidas, es decir, la que estar√° activa tendr√° un nivel de 0V, y todas las dem√°s + 5V. </font><font style="vertical-align: inherit;">Adem√°s, una llave en forma de una puerta de 3 entradas de tipo "I" est√° integrada en el chip, y dos de sus tres entradas tambi√©n est√°n invertidas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestro caso, conectamos el decodificador en s√≠ de la siguiente manera: el bit m√°s significativo (tercer tramo) al suelo, siempre habr√° 0. El bit central es la l√≠nea A15. Habr√° 1 solo si el procesador accede a los 32 KB superiores de memoria (direcciones 0x8000 - 0xFFFF, o 1000000000000000 - 1111111111111111 en binario, cuando el bit m√°s significativo siempre se establece en 1). Conectamos el bit menos significativo a la l√≠nea A14, donde el nivel alto ser√° en caso de acceder a la memoria despu√©s de los primeros 16 KiB, pero hasta los 32 KiB superiores (direcciones 0x4000 - 0x7FFF o 0100000000000000 - 0111111111111111 en forma binaria), o al 16 KiB m√°s reciente de la direcci√≥n espacios (direcciones 0xB000 - 0xFFFF, o 1100000000000000 - 1111111111111111 en forma binaria). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos cu√°l ser√° la salida en cada uno de los casos:</font></font><br>
<br>
<ul>
<li>  14  15    ,       16  ,    ,     000,  0    (    ),     Y0 (15 ).      ,      .</li>
<li>  14   ,   15 ‚Äî  ,         16 ,   32 ,    001,  1   ,     Y1 (14 ).      ,  16 ,       .</li>
<li>  14   ,   15 ‚Äî  ,     -  32   48 ,    010,     Y2 (13 ).      ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si ambas l√≠neas (A14 y A15) est√°n activas, el procesador accede a los 16 KiB superiores de la memoria, de 48 a 64 KiB, no lo tenemos, por lo que el pin Y3 (pin 12) tambi√©n est√° en el aire.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, gracias a otro elemento, el microcircuito activar√° sus hallazgos solo si las entradas 4 y 5 son bajas y 6 son altas. </font><font style="vertical-align: inherit;">La cuarta entrada siempre est√° en estado bajo (est√° conectada directamente a tierra), la quinta solo estar√° baja cuando el procesador est√© accediendo a la memoria (recuerde, MREQ en el estado bajo significa acceder a la memoria), y la sexta ser√° alta cuando el procesador no realice un ciclo de actualizaci√≥n DRAM (tenemos SRAM, por lo que los ciclos de actualizaci√≥n de DRAM son la forma m√°s segura de ignorar). </font><font style="vertical-align: inherit;">Resulta genial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, coloque la ROM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tom√© el W27C512 porque es barato, alegre, todo encajar√° y tambi√©n puedes realizar operaciones bancarias. 64KiB! Se pueden cargar 4 firmware. Bueno, tengo alrededor de un mill√≥n de estos microcircuitos. Decid√≠ que solo coser√≠a la mitad superior, ya que en Harlequin la pierna A15 est√° atada a + 5V, y la A14 es ajustable con un puente. Por lo tanto, puedo probar el firmware en Harlequin para no perder el tiempo durante mucho tiempo. Ver la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hoja de datos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ponemos el chip en el tablero. Nuevamente, lo puse en la esquina derecha para colocar el bus de direcciones a la izquierda. Tiramos de la pata A15 al poder, A14 cableado al suelo. Cableado: esto es para que pueda cambiar los bancos de memoria. Dado que el A15 siempre estar√° en un nivel alto, solo las 32 unidades flash KiB principales estar√°n disponibles para nosotros. De estos, la l√≠nea A14 seleccionar√° el KiB superior (+ 5V) o inferior (tierra) 16. En ellos, llen√© la </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">imagen de prueba con el</font></a><font style="vertical-align: inherit;"> programador</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y firmware </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b√°sico de 48K</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las 14 l√≠neas de direcci√≥n restantes (A0 - A13) est√°n conectadas al bus de direcciones a la izquierda. Conectamos el bus de datos (Q0 - Q7) a nuestro bus improvisado en forma de buses de potencia de los modelos de placa de pruebas. ¬°No te olvides de la comida!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora las se√±ales de control. </font><font style="vertical-align: inherit;">OE es una habilitaci√≥n de salida. </font><font style="vertical-align: inherit;">Necesitamos la ROM para enviar datos al bus de datos cuando el procesador los lea. </font><font style="vertical-align: inherit;">Entonces nos conectamos directamente a la salida del procesador RD. </font><font style="vertical-align: inherit;">Es conveniente que ambos pines, tanto OE en ROM como RD en el procesador est√©n activos en estado bajo. </font><font style="vertical-align: inherit;">Esto es importante; no necesitas invertir nada. </font><font style="vertical-align: inherit;">Adem√°s, la ROM tiene una entrada CS, tambi√©n activa en un estado bajo. </font><font style="vertical-align: inherit;">Si esta entrada no est√° activa, la ROM ignorar√° todas las dem√°s se√±ales y no emitir√° nada al bus de datos. </font><font style="vertical-align: inherit;">Conectaremos esta entrada al pin Y0 (15 pines) del chip 74HC138, que tambi√©n est√° activo en el estado bajo. </font><font style="vertical-align: inherit;">En el circuito </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harlequin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">esta se√±al, por alguna raz√≥n, est√° conectada a trav√©s de una resistencia. </font><font style="vertical-align: inherit;">Haremos lo mismo. </font><font style="vertical-align: inherit;">Por qu√©, no lo s√©. </font><font style="vertical-align: inherit;">Tal vez la gente inteligente me lo diga en los comentarios ... </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Me lo dijeron. </font><font style="vertical-align: inherit;">Gracias,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sterr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><blockquote>  .       ,    ¬´¬ª .            .</blockquote></i><br>
<br>
<img src="https://habrastorage.org/webt/1k/n7/h3/1kn7h3nfgruh121jefz2qfhucts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora RAM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es m√°s dif√≠cil con √©l, ya que no solo el procesador, sino tambi√©n el ULA o, en nuestro caso, Arduino, funcionan con RAM (con nuestros 16 KiB). Dado que es necesario leer algo que se muestra en la pantalla. Por lo tanto, necesitamos poder desconectar las se√±ales de control y el bus de direcciones RAM del procesador. No desconectaremos el bus de datos, actuaremos como en el espectro original (y en Harlequin): dividiremos el bus con resistencias (470-500 ohmios). Por un lado, las resistencias ser√°n el procesador y la ROM, por otro lado, RAM y Arduino. Por lo tanto, en caso de conflicto en el bus de datos, funcionar√° como 2 buses separados. Pero para el resto usamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">74HC245</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , como en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harlequin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (U43, U44 en el diagrama), aunque en el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presente Speccy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n hubo resistencias (entre IC1 por un lado, esto es ULA e IC3, IC4 por el otro). </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El 74HC245</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un b√∫fer de bus de 8 bits. Pero tenemos 2 se√±ales de control (RD - en el caso de leer desde la memoria y CE para activar la RAM en s√≠. Trataremos con WR en el caso de escribir en la memoria m√°s adelante) y 14 bits de la direcci√≥n: recuerde, arriba ya generamos una se√±al a la memoria usando solo 74HC138 En el caso de que el procesador active A14 con A15 inactivo, por lo que no es necesario realizar ninguna decodificaci√≥n adicional de la direcci√≥n, la memoria solo funcionar√° al acceder a los primeros 16 KiB despu√©s de la ROM. Bueno, por supuesto, para abordar 16 KiB necesita solo 14 l√≠neas de direcci√≥n (A0-A13). En total, se obtienen 16 se√±ales, por lo que necesitamos 2 microcircuitos 74HC245. Los conectamos a la placa de pruebas a la izquierda, en lugar del bus de direcciones.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De la hoja de datos en el 74HC245 est√° claro que, en general, no importa a qu√© lado conectar los microcircuitos, pero como comenc√© a construir los dise√±os de abajo hacia arriba, y todos los dem√°s microcircuitos se instalan con el primer pin a la izquierda, el bus de direcciones se conectar√° al lado A (pines 2 -9 chips, en la hoja de datos est√°n designados como A0-A7). La direcci√≥n de transferencia siempre es del procesador a la RAM, ya que la RAM nunca establece la direcci√≥n, sino que solo la recibe. En el 74HC245, el pin 1 (DIR) es responsable de la direcci√≥n de transmisi√≥n. De acuerdo a la </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">hoja</font></a><font style="vertical-align: inherit;"> de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que la salida igual a la entrada del lado A aparezca en el lado B, el DIR debe establecerse en ALTO. As√≠ que conecta el primer pin de ambos circuitos a + 5V. El OE (pin 20, activado por un nivel bajo) se conecta mediante cableado a tierra para que pueda cambiarse r√°pidamente a + 5V y desconectarse del procesador. M√°s simple. Conecte la alimentaci√≥n de ambos chips. Los pines m√°s a la derecha del microcircuito derecho (pines 8 y 9, entradas A6 y A7) ser√°n se√±ales de control. Conect√© A7 al terminal RD del procesador y A6 al pin Y1 del chip 74HC138, ya que habr√° un nivel bajo solo cuando el procesador acceda a nuestra RAM. Las conclusiones restantes del lado A de ambos microcircuitos (patas 2‚Äì9 para la izquierda y piernas 2‚Äì7 para la derecha) las conect√© al bus de direcciones, terminales A13-A0. No necesitamos los 2 bits superiores de la direcci√≥n, porque ya est√°n decodificados en la se√±al del 74HC138.Ahora sobre la RAM en s√≠. Naturalmente, us√© lo que ya ten√≠a: un chip de cach√© de la antigua placa base. Me encontr√© con</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IS61C256</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a 20 ns, pero cualquiera servir√°. Speccy trabaj√≥ a una frecuencia de 3.5 MHz, pero por ahora generalmente trataremos a Arduinki. Si sale 100 kHz, ¬°habr√° felicidad! Entonces, nos conectamos. Por supuesto, no te olvides de la comida. Conclusiones I / O0 - I / O7 est√°n conectadas a la placa del bus de datos DESPU√âS de las resistencias. Tuve suerte (de hecho, no), en mis maquetas chinas, los autobuses de potencia est√°n divididos exactamente en el medio. Us√© esta funci√≥n para separar el bus con resistencias. Si tus dise√±os son incorrectos, debes ser </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pervertido</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haga un segundo bus de datos y con√©ctelo con resistencias al primero. Las conclusiones de A0-A13 se arrojan a las conclusiones B correspondientes de los chips 74HC245, sin olvidar que los m√°s a la derecha est√°n conectados no al bus de datos, sino a las se√±ales de control. A14 - por elecci√≥n, ya sea al suelo, o a + 5V. Un chip de 32 KiB, por lo que esta conclusi√≥n determinar√° qu√© mitad usaremos. Si encuentra una SRAM de 16 KiB, no habr√° una l√≠nea A14 en ella. Las salidas son WE (habilitaci√≥n de escritura), CE (habilitaci√≥n de chip) y OE (habilitaci√≥n de salida). Todos se activan bajo. OE debe estar conectado al RD del procesador, pero, por supuesto, no directamente, sino a trav√©s del 74HC245 derecho, donde el RD llega a mi pie A7 y, en consecuencia, sale del pie B7 (und√©cimo pin). Ah√≠ y con√©ctate. CE debe estar conectado a Y1 desde el 74HC138, que decodifica la direcci√≥n. Su se√±al me llega en el A6 del chip correcto 74HC245, respectivamente,sale del pie B6 (12 pines). WE Me conect√© directamente a la salida del procesador WR. Tambi√©n instal√© un cable de puente de la se√±al de OE y lo pegu√© justo en la parte no utilizada de la placa de pruebas. Al conectar este cable a tierra, puedo forzar la activaci√≥n de la RAM cuando lo leo desde Arduinka. A√∫n as√≠, saqu√© todas las se√±ales de control de la RAM a + 5V usando resistencias de 10 kOhm. Por si acaso. Result√≥ as√≠:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9y/0k/3h/9y0k3ht6ehvrsvzoehp70h428mo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, aqu√≠, y en todo caso, al principio, deber√≠a haber un programa educativo sobre la sincronizaci√≥n de las se√±ales en los neum√°ticos. No har√© esto, ya que muchas personas m√°s inteligentes que yo lo han hecho en la red. Para aquellos interesados, puedo recomendar este video:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/i_wrxBdXTgM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, si no est√° suscrito a este canal y est√° interesado en la electr√≥nica como aficionado, y no como profesional, se lo recomiendo encarecidamente. Este es un contenido de muy alta calidad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, eso es casi todo. Ahora solo necesita comprender c√≥mo leer datos de RAM en Arduino. Para empezar, calculemos cu√°ntas conclusiones de Arduinki necesitamos. Necesitamos dar una se√±al de reloj y controlar el RESET, estos son 2 pines. 8 bits de bus de datos: otros 8 pines. M√°s 13 bits de direcci√≥n, un total de 23 pines. Adem√°s, necesitamos comunicarnos con Arduinka, lo haremos a trav√©s de su interfaz serial, estos son otros 2 pines. Desafortunadamente, solo hay 20 conclusiones sobre mi ADN.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, no importa. No conozco a una sola persona que tenga Arduino y no tenga 74HC595. Me parece que solo se venden en el kit. Al menos solo tengo 74HC00 chips m√°s de 595x. Entonces los usamos. Adem√°s, ahorrar√© espacio en el art√≠culo, porque el trabajo del 595x con arduino se describe perfectamente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. 595mi generaremos la direcci√≥n. El chip necesitar√° 2 piezas (ya que tenemos 13 bits de la direcci√≥n, y el 595 tiene 8 pines). La forma de conectar varios 595x para la expansi√≥n del bus se describe en detalle en el enlace anterior. Solo noto que en los ejemplos en ese enlace OE (pin 13) 595x se tira al suelo. No lo haremos categ√≥ricamente, enviaremos una se√±al desde Arduinki all√≠, ya que los pines 595x se conectar√°n directamente al bus de direcciones RAM, y no necesitamos ninguna se√±al espuria all√≠. Despu√©s de conectar los pines 595x al bus de direcciones RAM, no se necesita hacer nada m√°s en las maquetas. Hora de conectar el arduinka. Pero primero, escribe un boceto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU defines</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CPU_CLOCK_PIN 2</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CPU_RESET_PIN 3</span><font></font>
<font></font>
<span class="hljs-comment">// RAM defines</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_OUTPUT_ENABLE_PIN 4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_WRITE_ENABLE_PIN 5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_CHIP_ENABLE_PIN 6</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_BUFFER_PIN 7</span><font></font>
<font></font>
<span class="hljs-comment">// Shift Register defines</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_DATA_PIN 8</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_OUTPUT_ENABLE_PIN 9</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_LATCH_PIN 10</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_CLOCK_PIN 11</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// All CPU and RAM control signals need to be configured as inputs by default</span>
  <span class="hljs-comment">// and only changed to outputs when used.</span>
  <span class="hljs-comment">// Shift register control signals may be preconfigured</span><font></font>
<font></font>
  <span class="hljs-comment">// CPU controls seetup</span><font></font>
  DDRC = B00000000;<font></font>
  pinMode(CPU_CLOCK_PIN, INPUT);<font></font>
  pinMode(CPU_RESET_PIN, INPUT);<font></font>
<font></font>
  <span class="hljs-comment">// RAM setup</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_BUFFER_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_BUFFER_PIN, LOW);<font></font>
<font></font>
  <span class="hljs-comment">// SR setup</span><font></font>
  pinMode(SR_LATCH_PIN, OUTPUT);<font></font>
  pinMode(SR_CLOCK_PIN, OUTPUT);<font></font>
  pinMode(SR_DATA_PIN, OUTPUT);<font></font>
  pinMode(SR_OUTPUT_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
<font></font>
  <span class="hljs-comment">// common setup</span>
  Serial.begin(<span class="hljs-number">9600</span>);<font></font>
  Serial.println(<span class="hljs-string">"Hello"</span>);<font></font>
}<span class="hljs-comment">// setup</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shiftReadValueFromAddress</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> address, <span class="hljs-keyword">uint8_t</span> *value)</span> </span>{
  <span class="hljs-comment">// disable RAM output</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_WRITE_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span>
  <span class="hljs-comment">// set address</span><font></font>
  digitalWrite(SR_LATCH_PIN, LOW);<font></font>
  shiftOut(SR_DATA_PIN, SR_CLOCK_PIN, MSBFIRST, address&gt;&gt;<span class="hljs-number">8</span>); <font></font>
  shiftOut(SR_DATA_PIN, SR_CLOCK_PIN, MSBFIRST, address);  <font></font>
  digitalWrite(SR_LATCH_PIN, HIGH);<font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, LOW); <span class="hljs-comment">// active low</span>
  <span class="hljs-comment">// write value to RAM</span>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, LOW); <span class="hljs-comment">// active low</span>
  delay(<span class="hljs-number">1</span>);<font></font>
  DDRC = B00000000;<font></font>
  *value = PINC;<font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span>
  <span class="hljs-comment">// disable SR</span>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
}<span class="hljs-comment">// shiftWriteValueToAddress</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">runClock</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> cycles)</span> </span>{
  <span class="hljs-keyword">uint32_t</span> currCycle = <span class="hljs-number">0</span>;<font></font>
  pinMode(CPU_CLOCK_PIN, OUTPUT);<font></font>
  <span class="hljs-keyword">while</span>(currCycle &lt; cycles) {<font></font>
    digitalWrite(CPU_CLOCK_PIN, HIGH);<font></font>
    digitalWrite(CPU_CLOCK_PIN, LOW);<font></font>
    currCycle++;<font></font>
  }<font></font>
  pinMode(CPU_CLOCK_PIN, INPUT);<font></font>
}<span class="hljs-comment">// runClock</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trySpectrum</span><span class="hljs-params">()</span> </span>{<font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
  pinMode(CPU_RESET_PIN, OUTPUT);<font></font>
  digitalWrite(CPU_RESET_PIN, LOW);<font></font>
  runClock(<span class="hljs-number">30</span>);<font></font>
  digitalWrite(CPU_RESET_PIN, HIGH);<font></font>
  runClock(<span class="hljs-number">12500000</span>);<font></font>
}<span class="hljs-comment">// trySpectrum</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">readDisplayLines</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">uint8_t</span> value;<font></font>
  digitalWrite(RAM_BUFFER_PIN, HIGH);<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_CHIP_ENABLE_PIN, LOW);<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">uint16_t</span> i=<span class="hljs-number">16384</span>; i&lt;<span class="hljs-number">16384</span>+<span class="hljs-number">6144</span>;i++) {<font></font>
    shiftReadValueFromAddress(i, &amp;value);<font></font>
    Serial.println(value);<font></font>
  }<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, INPUT);<font></font>
}<span class="hljs-comment">// readDisplayLines</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{<font></font>
  trySpectrum();<font></font>
  Serial.println(<span class="hljs-string">"Hope we are ok now. Please set up memory for reading"</span>);<font></font>
  delay(<span class="hljs-number">40000</span>);<font></font>
  Serial.println(<span class="hljs-string">"Reading memory"</span>);<font></font>
  readDisplayLines();<font></font>
  Serial.println(<span class="hljs-string">"Done"</span>);<font></font>
  delay(<span class="hljs-number">100000</span>);<font></font>
}<span class="hljs-comment">// loop</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver en el boceto (bueno, de repente, alguien lo ley√≥), le√≠ el bus de datos al puerto C. Como Arduischik puede recordar, en el puerto CID C hay 6 pines. Es decir, leo solo 6 bits. S√≠, por la simplicidad del proceso, ignoro los 2 bits altos en cada byte del b√∫fer de pantalla. Esto dar√° como resultado el hecho de que cada 2 p√≠xeles despu√©s de 6 siempre habr√° colores de fondo. Mientras viaja, luego arr√©glenlo. Este es el esqueleto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora para la conexi√≥n en s√≠. En principio, todo est√° pintado en la parte superior del boceto:</font></font><br>
<br>
<pre><code class="plaintext hljs">// CPU defines<font></font>
#define CPU_CLOCK_PIN 2 -  2     6  ( )<font></font>
#define CPU_RESET_PIN 3 -  3     26  (RESET)<font></font>
<font></font>
// RAM defines<font></font>
#define RAM_OUTPUT_ENABLE_PIN 4 -  4     22  (OE)<font></font>
#define RAM_WRITE_ENABLE_PIN 5 -  5    .     .<font></font>
#define RAM_CHIP_ENABLE_PIN 6 -  6     .        ,        .   - ,   -  .   ,   .<font></font>
#define RAM_BUFFER_PIN 7 -  ,    6,    .<font></font>
<font></font>
// Shift Register defines<font></font>
#define SR_DATA_PIN 8   -  8     14 "" 595.        9 ,     .<font></font>
#define SR_OUTPUT_ENABLE_PIN 9 -   13  595<font></font>
#define SR_LATCH_PIN 10 -   12  595<font></font>
#define SR_CLOCK_PIN 11 -   11  595.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo es simple As√≠ es como parece que estoy todo ensamblado (el arduino se cort√≥ en la imagen, pero no hay nada especial que ver): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pj/q5/si/pjq5siebaxafimb_nqnjxyry6_u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al inicio, Arduino saludar√° alegremente al puerto serie de la computadora (aunque sea virtual), y comenzar√° a atormentar el procesador. Despu√©s de haberlo torturado a fondo (un par de minutos), el programa detendr√° al pobre chico y le ofrecer√° reorganizar los puentes con los bol√≠grafos en el tablero, desconectando la memoria del bus de direcciones y las se√±ales de control del procesador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora necesitamos usar las manijas para reorganizar el cableado conectado a los pines 19 de ambos 74HC245 desde el suelo a + 5V. Por lo tanto, desconectamos el procesador de la RAM. El pin 22 del chip RAM en s√≠ debe estar conectado a tierra (escrib√≠ anteriormente sobre el cableado, que acabo de pegar en la placa de prueba hasta ahora, en un lugar sin usar). Por lo tanto, activamos por la fuerza la RAM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de eso, despu√©s de esperar un poco, Arduinka comenzar√° a leer el contenido de la memoria y lo enviar√° en una columna al puerto serie. Habr√° muchos, muchos n√∫meros. Ahora puede copiar estos datos desde all√≠ y pegarlos, digamos, en un archivo de texto, sin olvidar limpiar todo el texto innecesario (un par de l√≠neas en la parte superior y "Listo" en la parte inferior), solo necesitamos n√∫meros. Esto es lo que nuestro Speccy grab√≥ en la memoria de video. Solo queda ver lo que hab√≠a en la memoria de video. Y la memoria de video del Spectrum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">f√°cil</font></a><font style="vertical-align: inherit;"> ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, los p√≠xeles se almacenan por separado del color. Ignoraremos el color por ahora, leamos solo los p√≠xeles. Pero no son tan f√°ciles de decodificar. Despu√©s de mucho dolor en Visual Studio, llegu√© a esta elegante soluci√≥n:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND, UINT, WPARAM, LPARAM)</span></span>;
<span class="hljs-keyword">uint8_t</span> *scrData;<font></font>
<font></font>
<span class="hljs-function">VOID <span class="hljs-title">OnPaint</span><span class="hljs-params">(HDC hdc)</span> </span>{
	<span class="hljs-keyword">size_t</span> arrSize = <span class="hljs-number">6144</span>;<span class="hljs-comment">//sizeof(scrData) / sizeof(scrData[0]);</span>
	<span class="hljs-comment">//int currRow = 0, currX = 0, currBlock = 0, currY = 0, currBase = 0;</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> arrPos = <span class="hljs-number">0</span>; arrPos &lt; arrSize; arrPos++) {
		<span class="hljs-keyword">int</span> blockPos = arrPos % <span class="hljs-number">2048</span>;
		<span class="hljs-keyword">int</span> currBase = (blockPos % <span class="hljs-number">256</span>) / <span class="hljs-number">32</span>;
		<span class="hljs-keyword">int</span> currX = blockPos % <span class="hljs-number">32</span>;
		<span class="hljs-keyword">int</span> currBlock = arrPos / <span class="hljs-number">2048</span>;
		<span class="hljs-keyword">int</span> currRow = blockPos / <span class="hljs-number">256</span>;
		<span class="hljs-keyword">int</span> currY = currBlock * <span class="hljs-number">64</span> + currBase * <span class="hljs-number">8</span> + currRow;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> trueX = <span class="hljs-number">0</span>; trueX &lt; <span class="hljs-number">8</span>; trueX++) {
			<span class="hljs-keyword">char</span> r = ((scrData[arrPos] &gt;&gt; trueX) &amp; <span class="hljs-number">1</span>)*<span class="hljs-number">255</span>;<font></font>
			SetPixel(hdc, currX * <span class="hljs-number">8</span> + (<span class="hljs-number">8</span>-trueX), currY, RGB(r, r, r));<font></font>
		}<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span> </span>{<font></font>
	FILE *file;<font></font>
	<span class="hljs-keyword">errno_t</span> err;
	<span class="hljs-keyword">if</span> ((err = fopen_s(&amp;file, <span class="hljs-string">"data.txt"</span>, <span class="hljs-string">"r"</span>))) {<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, <span class="hljs-string">L"Unable to oopen the file"</span>, <span class="hljs-string">L"Error"</span>, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
	scrData = (<span class="hljs-keyword">uint8_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">6144</span>);
	<span class="hljs-keyword">int</span> currDataPos = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">char</span> buffer[<span class="hljs-number">256</span>];
	<span class="hljs-keyword">char</span> currChar = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span> currLinePos = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span> (currChar != EOF) {<font></font>
		currChar = getc(file);<font></font>
		buffer[currLinePos++] = currChar;<font></font>
		<span class="hljs-keyword">if</span> (currChar == <span class="hljs-string">'\n'</span>) {<font></font>
			buffer[currLinePos] = <span class="hljs-number">0</span>;<font></font>
			scrData[currDataPos++] = (<span class="hljs-keyword">uint8_t</span>)atoi(buffer);<font></font>
			currLinePos = <span class="hljs-number">0</span>;<font></font>
		}<font></font>
	}<font></font>
	fclose(file);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">INT WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE, PSTR, INT iCmdShow)</span> </span>{<font></font>
	HWND                hWnd;<font></font>
	MSG                 msg;<font></font>
	WNDCLASS            wndClass;<font></font>
	wndClass.style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wndClass.lpfnWndProc = WndProc;<font></font>
	wndClass.cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wndClass.cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wndClass.hInstance = hInstance;<font></font>
	wndClass.hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wndClass.hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wndClass.lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wndClass.lpszClassName = TEXT(<span class="hljs-string">"GettingStarted"</span>);<font></font>
	RegisterClass(&amp;wndClass);<font></font>
	hWnd = CreateWindow(<font></font>
		TEXT(<span class="hljs-string">"GettingStarted"</span>),   <span class="hljs-comment">// window class name</span>
		TEXT(<span class="hljs-string">"Getting Started"</span>),  <span class="hljs-comment">// window caption</span>
		WS_OVERLAPPEDWINDOW,      <span class="hljs-comment">// window style</span>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial x position</span>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial y position</span>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial x size</span>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial y size</span>
		<span class="hljs-literal">NULL</span>,                     <span class="hljs-comment">// parent window handle</span>
		<span class="hljs-literal">NULL</span>,                     <span class="hljs-comment">// window menu handle</span>
		hInstance,                <span class="hljs-comment">// program instance handle</span>
		<span class="hljs-literal">NULL</span>);                    <span class="hljs-comment">// creation parameters</span><font></font>
	loadData();<font></font>
	ShowWindow(hWnd, iCmdShow);<font></font>
	UpdateWindow(hWnd);<font></font>
	<span class="hljs-keyword">while</span> (GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) {<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> msg.wParam;<font></font>
}  <span class="hljs-comment">// WinMain</span><font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>{<font></font>
	HDC          hdc;<font></font>
	PAINTSTRUCT  ps;<font></font>
	<span class="hljs-keyword">switch</span> (message) {
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hdc = BeginPaint(hWnd, &amp;ps);<font></font>
		OnPaint(hdc);<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);<font></font>
	}<font></font>
} <span class="hljs-comment">// WndProc</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El programa abre el archivo data.txt desde su directorio. </font><font style="vertical-align: inherit;">En este archivo, la salida de texto del arduino (despu√©s de eliminar todas las l√≠neas adicionales, como se mencion√≥ anteriormente). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo alimentamos con el archivo resultante y, como resultado: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tv/ai/3f/tvai3fcvvg-y53dlrcxogjo9o-c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S√≠, aunque el resultado est√° muy lejos de ser ideal, pero definitivamente es la salida a la pantalla. </font><font style="vertical-align: inherit;">Adem√°s, el que se necesita. </font><font style="vertical-align: inherit;">Desde ROM con firmware de diagn√≥stico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, el esqueleto de la computadora est√° listo. </font><font style="vertical-align: inherit;">S√≠, todav√≠a es imposible usarlo, pero puedes ver lo extremadamente simple que se arreglaron las viejas computadoras de 8 bits. </font><font style="vertical-align: inherit;">Todav√≠a golpe√© un poco por encima del tablero, pero la conclusi√≥n solo empeor√≥. </font><font style="vertical-align: inherit;">Parece que el siguiente paso es soldar en una placa de pruebas normal, sin soldar, con potencia normal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPero es necesario?</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es498208/index.html">Semana de la seguridad 17: Implicaciones del ataque al servidor Linux</a></li>
<li><a href="../es498214/index.html">Maria Popova: ‚ÄúAlgunos se enteraron por primera vez de OpenStreetMap debido al hecho de que marcaban hogweed en el mapa‚Äù</a></li>
<li><a href="../es498216/index.html">Colorear textos en html y React</a></li>
<li><a href="../es498218/index.html">Mientras escrib√≠a m√∫sica de rayos c√≥smicos</a></li>
<li><a href="../es498220/index.html">¬øC√≥mo el coronavirus (COVID-XX) puede ayudar a 1C a conquistar el mundo?</a></li>
<li><a href="../es498224/index.html">Cree una exhibici√≥n interactiva con .NET, Azure Functions y la magia de los servicios cognitivos.</a></li>
<li><a href="../es498226/index.html">Descomposici√≥n. C√≥mo desmontar un gran proyecto en segmentos comprensibles para una evaluaci√≥n preliminar</a></li>
<li><a href="../es498234/index.html">Mitos de gesti√≥n real sobre DevOps</a></li>
<li><a href="../es498238/index.html">Pol√≠mero conductor de la electricidad: c√≥mo los cient√≠ficos fabricaron pl√°stico a partir de metal</a></li>
<li><a href="../es498242/index.html">Usar almacenamiento en contenido multimedia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>