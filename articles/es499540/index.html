<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöª üÜë üöå C√≥mo funciona la renderizaci√≥n de juegos en 3D: texturizado y filtrado de texturas ‚ö±Ô∏è ü§∞üèø üè°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el tercer art√≠culo sobre renderizado en juegos 3D, descubriremos qu√© le sucede al mundo 3D despu√©s de procesar el procesamiento de v√©rtices y raste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C√≥mo funciona la renderizaci√≥n de juegos en 3D: texturizado y filtrado de texturas</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499540/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a4/fee/0c7/2a4fee0c701c2b2200faf2b8c6929832.jpg" alt="imagen"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el tercer art√≠culo sobre renderizado en juegos 3D, descubriremos qu√© le sucede al mundo 3D despu√©s de procesar el procesamiento de v√©rtices y rasterizar la escena. </font><font style="vertical-align: inherit;">El texturizado es una de las etapas m√°s importantes de la representaci√≥n, a pesar de que solo calcula y cambia los colores de una cuadr√≠cula bidimensional de bloques multicolores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mayor√≠a de los efectos visuales en los juegos modernos se reducen al uso deliberado de texturas; sin ellos, los juegos parecer√≠an aburridos y sin vida. </font><font style="vertical-align: inherit;">¬°Entonces veamos c√≥mo funciona todo! </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 1: procesamiento de v√©rtices </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 2: rasterizaci√≥n y trazado de rayos</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos con un simple</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede tomar los juegos tridimensionales m√°s vendidos lanzados durante el a√±o pasado y decir con confianza que todos tienen algo en com√∫n: usan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapas de textura</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (o solo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texturas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Este es un t√©rmino tan com√∫n que al pensar en texturas, la mayor√≠a de las personas presentan la misma imagen: un cuadrado o rect√°ngulo plano simple que contiene una imagen de una superficie (hierba, piedra, metal, tela, cara, etc.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero cuando se usa y combina con c√°lculos complejos, im√°genes tan simples en una escena 3D pueden crear im√°genes incre√≠blemente realistas. Para entender c√≥mo es esto posible, desact√≠velos por completo y veamos c√≥mo se ver√°n los objetos del mundo 3D sin texturas.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como vimos en art√≠culos anteriores, el mundo 3D est√° formado por v√©rtices, formas simples que se mueven y luego colorean. Luego se utilizan para crear primitivas, que a su vez se comprimen en una cuadr√≠cula de p√≠xeles bidimensional. Como no usaremos texturas, necesitamos colorear estos p√≠xeles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uno de los m√©todos que se pueden aplicar se llama </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sombreado plano</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : se toma el color del primer v√©rtice de la primitiva, y luego este color se aplica a todos los p√≠xeles cubiertos por la figura en el r√°ster. Se ve algo como esto:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/f5c/61b/a0bf5c61be539c776d00fa1b11177ced.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, la tetera parece poco realista, y no menos importante debido a los colores irregulares de la superficie. Los colores saltan de un nivel a otro, no hay transiciones suaves. Una soluci√≥n al problema podr√≠a ser usar el </font></font><em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sombreado de Gouraud</font></font></a></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este proceso, se toman los colores de los v√©rtices, despu√©s de lo cual se calcula el cambio de color a lo largo de la superficie del tri√°ngulo. Para esto, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se utiliza la interpolaci√≥n lineal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Suena complicado, pero en realidad esto significa que si, por ejemplo, un lado de la primitiva tiene un color de 0.2 rojo y el otro 0.8 rojo, entonces el centro de la figura tendr√° un color en el medio entre 0.2 y 0.8 (es decir, 0.5).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este proceso es bastante simple, y esta es su principal ventaja, porque la simplicidad significa velocidad. Muchos juegos 3D m√°s antiguos usaban esta t√©cnica porque el equipo de c√≥mputo ten√≠a capacidades limitadas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/447/3c8/1284473c8e1e2ce7d32dbf2202065afe.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barrett y Cloud en toda la grandeza del sombreado de Gouraud (Final Fantasy VII, 1997)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pero incluso tal soluci√≥n tiene problemas: si la luz cae justo en el medio del tri√°ngulo, es posible que sus esquinas (y v√©rtices) no transmitan esta propiedad. </font><font style="vertical-align: inherit;">Esto significa que el resplandor creado por la luz se puede perder por completo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque el sombreado plano y el sombreado de Gouraud han ocupado el lugar que les corresponde en las herramientas de renderizado, los ejemplos que se muestran arriba son claros candidatos para mejorar la textura. </font><font style="vertical-align: inherit;">Y para comprender bien lo que sucede cuando la textura se superpone en la superficie, retrocedemos en el tiempo ... ya en 1996.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breve historia del juego y la GPU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hace unos 23 a√±os, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">id Software</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lanz√≥ Quake, y se convirti√≥ en un hito importante. </font><font style="vertical-align: inherit;">Aunque este no fue el primer juego en usar pol√≠gonos y texturas 3D para renderizar entornos, definitivamente fue uno de los primeros en usarlos de manera efectiva. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero tambi√©n hizo algo m√°s: mostr√≥ lo que se puede hacer con OpenGL (esta API de gr√°ficos estaba en el estado de la primera versi√≥n en ese momento), y tambi√©n ayud√≥ mucho a la primera generaci√≥n de tarjetas gr√°ficas como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendition Verite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dfx Voodoo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a86/9a9/667/a869a966718cfc8ddf4b6d7618b2fdbf.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Picos de iluminaci√≥n y texturas simples. </font><font style="vertical-align: inherit;">Clean 1996, clean Quake. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seg√∫n los est√°ndares modernos, Voodoo era extremadamente simple: sin soporte de gr√°ficos 2D, sin procesamiento de v√©rtices, solo el procesamiento de p√≠xeles m√°s simple. </font><font style="vertical-align: inherit;">Sin embargo, ella era hermosa:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66c/509/911/66c5099113c9b08098b73ce31436ecb8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Museo VGA</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ella ten√≠a un chip completo (TMU) para obtener un p√≠xel de una textura y otro chip (FBI) para luego mezclarlo con un p√≠xel de trama. El mapa podr√≠a llevar a cabo un par de procesos adicionales, por ejemplo, la implementaci√≥n de efectos de niebla o transparencia, pero esto, en esencia, termin√≥ sus capacidades. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si observamos la arquitectura subyacente a la estructura y el funcionamiento de la tarjeta gr√°fica, veremos c√≥mo funcionan estos procesos.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/c83/ee4/064c83ee4f63da2be0d5a968c33df0d5.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Especificaci√≥n 3Dfx. Fuente: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falconfly Central</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
El chip del FBI recibi√≥ dos valores de color y los mezcl√≥; uno de ellos podr√≠a ser un valor de una textura. El proceso de mezcla es matem√°ticamente bastante simple, pero var√≠a ligeramente seg√∫n lo que se mezcle y qu√© API se use para ejecutar las instrucciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si observa lo que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direct3D nos ofrece</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con respecto a las funciones y las operaciones de mezcla, veremos que cada p√≠xel se multiplica primero por un n√∫mero de 0.0 a 1.0. Esto determina cu√°nto afectar√° el color del p√≠xel al resultado final. Luego se suman dos colores de p√≠xel cambiados, restados o multiplicados; En algunas funciones, se realiza una operaci√≥n l√≥gica en la que, por ejemplo, siempre se selecciona el p√≠xel m√°s brillante.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/c8b/c8a/aa1c8bc8a2e35a1867c5f6028d958fa8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blog de tecnolog√≠a Taking Initiative</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
La imagen de arriba muestra c√≥mo funciona esto en la pr√°ctica; Observe que el valor </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alfa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del p√≠xel se utiliza como coeficiente para el </font><font style="vertical-align: inherit;">p√≠xel </font><font style="vertical-align: inherit;">izquierdo </font><font style="vertical-align: inherit;">. Este n√∫mero indica la cantidad de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transparencia del</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> p√≠xel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En otras etapas, se aplica el valor de niebla (se toma de la tabla creada por el programador y luego se realizan los mismos c√°lculos de mezcla); realizar controles y cambios en visibilidad y transparencia; Al final, el color del p√≠xel se escribe en la memoria de la tarjeta gr√°fica.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPor qu√© necesitas esta excursi√≥n a la historia? </font><font style="vertical-align: inherit;">Bueno, a pesar de la relativa simplicidad del dise√±o (especialmente en comparaci√≥n con los monstruos modernos), este proceso describe los principios fundamentales de la textura: tomamos los valores de los colores y los mezclamos para que los modelos y entornos se vean como deber√≠an en una situaci√≥n particular. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los juegos modernos hacen lo mismo, la √∫nica diferencia es la cantidad de texturas utilizadas y la complejidad de los c√°lculos de mezcla. </font><font style="vertical-align: inherit;">Juntos, simulan los efectos visuales encontrados en las pel√≠culas, o la interacci√≥n de la iluminaci√≥n con diferentes materiales y superficies.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conceptos b√°sicos de texturizado</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para nosotros, una textura es una imagen 2D plana superpuesta a los pol√≠gonos que componen la estructura 3D en el marco. Sin embargo, para una computadora, esto es solo un peque√±o bloque de memoria en forma de matriz 2D. Cada elemento de la matriz denota el valor de color de uno de los p√≠xeles en la imagen de textura (com√∫nmente llamados </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texels</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - p√≠xeles de textura). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada v√©rtice del pol√≠gono tiene un conjunto de dos coordenadas (generalmente denotadas como </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), que le </font><font style="vertical-align: inherit;">indican </font><font style="vertical-align: inherit;">a la computadora qu√© p√≠xel de la textura est√° asociado. El v√©rtice en s√≠ tiene un conjunto de tres coordenadas ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x, y, z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), y el proceso de vincular texels a los v√©rtices se denomina </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapeo de texturas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para ver c√≥mo sucede esto, pasemos a la herramienta que ya hemos usado varias veces en esta serie de art√≠culos: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RealGL Rendering en tiempo real</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Por ahora, tambi√©n descartamos la coordenada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de los </font><font style="vertical-align: inherit;">v√©rtices y consideramos todo en un plano plano.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/d20/fbb/8e1d20fbb308d78a19a2e54d5da96900.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De izquierda a derecha: las coordenadas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la </font><font style="vertical-align: inherit;">textura, ligadas directamente a las coordenadas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x, y</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de los </font><font style="vertical-align: inherit;">v√©rtices </font><font style="vertical-align: inherit;">de las </font><font style="vertical-align: inherit;">esquinas. En la segunda imagen, las coordenadas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se incrementan en los v√©rtices superiores </font><font style="vertical-align: inherit;">, pero como la textura todav√≠a est√° unida a ellas, se estira verticalmente. La textura ya ha cambiado en la imagen correcta: los valores de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> han aumentado, pero como resultado, la textura se ha comprimido y luego se ha repetido.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Esto sucedi√≥ porque, a pesar del hecho de que, de hecho, la textura se ha vuelto m√°s alta debido al mayor valor de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , todav√≠a debe caber en la primitiva; de hecho, la textura se repite parcialmente. Esta es una forma de implementar el efecto que a menudo se encuentra en los juegos 3D: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texturas repetidas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se pueden ver ejemplos de este efecto en escenas con paisajes pedregosos o cubiertos de hierba, as√≠ como con paredes de ladrillo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora cambiemos la escena para que haya m√°s primitivas, y nuevamente regresemos a la profundidad de la escena. La vista cl√°sica del paisaje se muestra a continuaci√≥n, pero ahora la textura del cuadro se copia y se repite para todas las primitivas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/9e1/0cb/a9e9e10cb533b78330f90fd7eaea3891.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La textura de la caja en su formato gif original tiene un tama√±o de 66 KB y una resoluci√≥n de 256 x 256 p√≠xeles. La resoluci√≥n inicial de la parte del marco cubierta por las texturas de la caja es 1900 x 680, es decir, desde el punto de vista del ‚Äú√°rea‚Äù de p√≠xeles, dicha √°rea debe mostrar solo 20 texturas de caja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero es obvio que vemos mucho m√°s de veinte cuadros, y esto significa que la textura del cuadro en la distancia debe ser </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mucho</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menor que 256 x 256 p√≠xeles. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , se sometieron a un proceso llamado </font><em><font style="vertical-align: inherit;">"minificaci√≥n de textura"</font></em><font style="vertical-align: inherit;"> (s√≠, ¬°esa palabra existe en ingl√©s!). Ahora, repitamos, pero esta vez acerca la c√°mara a uno de los cajones.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/c02/f70/404c02f70291916245ec931642c79860.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No olvide que la textura tiene un tama√±o de solo 256 x 256 p√≠xeles, pero aqu√≠ vemos una textura que es m√°s grande que la mitad de la imagen con un ancho de 1900 p√≠xeles. </font><font style="vertical-align: inherit;">Esta textura fue sometida a una operaci√≥n de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"aumento de textura"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estos dos procesos de textura ocurren constantemente en los juegos 3D, porque cuando la c√°mara se mueve alrededor de la escena, los modelos se acercan o se alejan, y todas las texturas aplicadas a las primitivas deben escalarse junto con los pol√≠gonos. </font><font style="vertical-align: inherit;">Desde el punto de vista de las matem√°ticas, este es un peque√±o problema, de hecho, incluso los chips gr√°ficos integrados m√°s simples pueden hacer f√°cilmente ese trabajo. </font><font style="vertical-align: inherit;">Sin embargo, la reducci√≥n y ampliaci√≥n de texturas son nuevos desaf√≠os que deben abordarse de alguna manera.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mini-copias de texturas aparecen en la escena.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primer problema a resolver para las texturas es la distancia. Si volvemos a la primera imagen con un paisaje de cuadros, los cuadros ubicados cerca del horizonte tienen un tama√±o de solo unos pocos p√≠xeles. Por lo tanto, tratar de comprimir una imagen de 256 x 256 p√≠xeles en un espacio tan peque√±o no tiene sentido por dos razones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, la textura m√°s peque√±a ocupa menos memoria de la tarjeta gr√°fica, lo cual es conveniente, ya que puede intentar encajarla en un cach√© m√°s peque√±o. Esto significa que es menos probable que se elimine de la memoria cach√©, es decir, el uso repetido de esta textura proporcionar√° un mayor rendimiento, ya que los datos estar√°n en la memoria cercana. Por la segunda raz√≥n, volveremos pronto, porque est√° asociado con el mismo problema que surge en las texturas cercanas a la c√°mara.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La soluci√≥n est√°ndar al problema de la necesidad de comprimir texturas grandes en primitivas peque√±as es usar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texturas mip (mipmaps)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Estas son versiones reducidas de la textura original; pueden ser generados por el propio motor (usando los comandos API apropiados) o creados previamente por dise√±adores de juegos. Cada nivel posterior de textura mip tiene un tama√±o medio en comparaci√≥n con el anterior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, para la textura de la caja, las dimensiones ser√°n: 256 x 256 ‚Üí 128 x 128 ‚Üí 64 x 64 ‚Üí 32 x 32 ‚Üí 16 x 16 ‚Üí 8 x 8 ‚Üí 4 x 4 ‚Üí 2 x 2 ‚Üí 1 x 1.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/074/973/1ea/0749731eae53d112d545c0297ac14584.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas las texturas mip se empaquetan juntas, por lo que la textura tiene el mismo nombre de archivo, pero se hace m√°s grande. La textura est√° empaquetada de tal manera que las coordenadas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no solo determinan qu√© texel se superpone en el p√≠xel en el marco, sino tambi√©n con qu√© textura de mip. Luego, los programadores escriben un renderizador, basado en el valor de la profundidad de p√≠xel del cuadro, que determina qu√© textura de mip utilizar. Por ejemplo, si el valor es muy alto, entonces el p√≠xel est√° muy lejos, lo que significa que puede usar una textura de mip peque√±a.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los lectores atentos podr√≠an notar la falta de texturas mip: tienen que pagarlas aumentando el tama√±o de las texturas. La textura original de la caja era de 256 x 256 p√≠xeles, pero como puede ver en la imagen de arriba, la textura con texturas MIP ahora tiene un tama√±o de 384 x 256. S√≠, tiene mucho espacio vac√≠o, pero no importa c√≥mo empaquetamos texturas m√°s peque√±as, en general El tama√±o de la textura en un lado aumentar√° en al menos un 50%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero esto es cierto solo para texturas mip creadas previamente; Si el motor del juego est√° programado para generarlos correctamente, el aumento no es m√°s del 33% del tama√±o de la textura original. Por lo tanto, debido a un peque√±o aumento en la cantidad de memoria para almacenar texturas mip, obtenemos una ganancia en rendimiento y calidad visual.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n se muestra una comparaci√≥n de im√°genes con texturas mip deshabilitadas / habilitadas:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/b67/e71/e96b67e71c3f41aed3ce09ed728f98ea.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el lado izquierdo de la imagen, las texturas de las cajas se utilizaron "tal cual", lo que condujo a la aparici√≥n de granularidad y el llamado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muar√©</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la distancia. </font><font style="vertical-align: inherit;">A la derecha, el uso de texturas mip permiti√≥ transiciones m√°s suaves, y en el horizonte la textura de la caja se vuelve borrosa en un color uniforme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, ¬øqui√©n quiere texturas borrosas para estropear los fondos de su juego favorito?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bilineal, trilineal, anisotr√≥pico: todo esto es para m√≠ una letra china</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El proceso de seleccionar un p√≠xel de una textura para superponerlo en un p√≠xel en un cuadro se denomina </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texturas de muestreo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y en un mundo ideal habr√≠a una textura que coincida idealmente con la primitiva para la que est√° dise√±ada, independientemente del tama√±o, posici√≥n, direcci√≥n, etc. </font><font style="vertical-align: inherit;">En otras palabras, muestrear la textura ser√≠a un simple mapeo de p√≠xeles de texel uno a uno. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero como esto no es as√≠, hay varios factores a considerar al muestrear texturas:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øSe ha reducido o ampliado la textura?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øEs la textura una fuente o textura de mip?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øA qu√© √°ngulo se muestra la textura?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Analic√©moslos en orden. El primer factor es bastante obvio: si se ha aumentado la textura, entonces en la primitiva habr√° m√°s elementos de textura que cubran el p√≠xel en la primitiva de lo requerido; cuando disminuye, lo contrario es cierto: cada texel ahora debe cubrir varios p√≠xeles. Y eso es un problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo factor no causa problemas, porque las texturas mip se usan para evitar el problema de muestrear las texturas de primitivas lejanas, por lo que la √∫nica tarea es mostrar las texturas en √°ngulo. Y s√≠, esto tambi√©n es un problema. ¬øPor qu√©? Porque todas las texturas son im√°genes generadas para ver "estrictamente al frente". Hablando en lenguaje matem√°tico, la textura normal de la superficie coincide con la superficie nominal en la que se muestra actualmente la textura.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, si los texels son muy pocos o demasiados, o est√°n ubicados en √°ngulo, entonces se requiere un proceso adicional llamado </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"filtrado de texturas"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si este proceso no se usa, obtenemos esto:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/a12/552/792a125529b7f3baa79c072fdf42acba.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Aqu√≠ reemplazamos la textura de la caja con una textura con la letra R, para mostrar m√°s claramente en qu√© desorden se convierte la imagen sin filtrar las texturas! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las API gr√°ficas como Direct3D, OpenGL y Vulkan proporcionan el mismo conjunto de tipos de filtrado, pero usan nombres diferentes para ellos. </font><font style="vertical-align: inherit;">De hecho, todos se reducen a lo siguiente:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muestreo de punto cercano</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filtrado de textura lineal</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filtrado de textura anisotr√≥pica</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muestrear el muestreo de punto m√°s cercano</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no </font><em><font style="vertical-align: inherit;">es</font></em><font style="vertical-align: inherit;"> un filtro, porque con √©l solo se muestrea el texel m√°s cercano del p√≠xel de textura requerido (por ejemplo, copiado de la memoria), y luego se mezcla con el color original del p√≠xel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ el filtrado lineal viene en nuestra ayuda. Las coordenadas de </font><font style="vertical-align: inherit;">texel </font><font style="vertical-align: inherit;">requeridas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se transfieren al equipo de muestreo, pero en lugar de tomar el texel m√°s cercano a estas coordenadas, la muestra toma </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuatro</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texel. Estos son los texels ubicados arriba, abajo, a la izquierda y a la derecha del texel que se selecciona muestreando los puntos m√°s cercanos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estos cuatro texels se mezclan usando una f√≥rmula con pesas. En Vulkan, por ejemplo, la f√≥rmula se ve as√≠:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/9bb/63c/57b9bb63cc81fa5721b007717f6b200a.png"></div><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> denota el color del texel, donde </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el resultado de la filtraci√≥n, y 1-4 es el color de cuatro texels muestreados. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> valores </font><em><font style="vertical-align: inherit;">alfa</font></em><font style="vertical-align: inherit;"> y </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beta</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se toman seg√∫n cu√°n lejos est√© el punto con las coordenadas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del centro de la textura. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afortunadamente para aquellos involucrados con gr√°ficos en 3D, esto sucede autom√°ticamente en el chip de gr√°ficos. De hecho, esto es exactamente lo que hizo el chip TMU de la tarjeta Voodoo 3dfx: tom√≥ muestras de cuatro texels y luego los mezcl√≥. En Direct3D, este proceso tiene un nombre extra√±o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para el filtrado bilineal.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pero desde los d√≠as de Quake y el chip TMU, las tarjetas gr√°ficas ya han aprendido c√≥mo realizar el filtrado bilineal en un solo ciclo de reloj (por supuesto, si la textura ya se encuentra en la memoria m√°s cercana). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El filtrado lineal se puede usar junto con texturas mip, y si desea complicar el filtrado, puede tomar cuatro texels de la textura y luego cuatro m√°s del siguiente nivel de mip-texture, mezcl√°ndolos todos. ¬øY c√≥mo se llama en Direct3D? </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filtraci√≥n trilineal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . ¬øDe d√≥nde vinieron los </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"tres"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en este proceso </font><font style="vertical-align: inherit;">? As√≠ que no sabemos ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El √∫ltimo m√©todo de filtrado que vale la pena mencionar es el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anisotr√≥pico</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . De hecho, es una mejora en el proceso realizado por filtrado bilineal o trilineal. Inicialmente, calcula</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El grado de anisotrop√≠a de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la superficie primitiva (y este es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un proceso sorprendentemente complejo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): este valor aumenta el cambio en la relaci√≥n de aspecto de la primitiva debido a su orientaci√≥n:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/247/dfe/e60/247dfee60846988a5e94a1020d9ecef6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La figura de arriba muestra la misma primitiva cuadrada con lados iguales; pero girando gradualmente, se convierte en un rect√°ngulo, y su ancho cambia m√°s que su altura. Por lo tanto, la primitiva a la derecha tiene un mayor grado de anisotrop√≠a que a la izquierda (y en el caso de un cuadrado, el grado es cero). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muchos juegos 3D modernos le permiten activar el filtro anisotr√≥pico y luego cambiar su nivel (de 1x a 16x), pero ¬øqu√© cambia realmente? Este par√°metro controla el n√∫mero m√°ximo de muestras de texel adicionales que se toman en cada muestra lineal inicial. Supongamos que en el juego se activa un filtrado bilineal anisotr√≥pico de 8x. Esto significa que en lugar de cuatro valores de texel, obtendr√° 32 valores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia al usar el filtro anisotr√≥pico es claramente notable:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/302/372/df7302372c6dc0d34730ba572f695063.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Simplemente vaya a la imagen de arriba y compare el muestreo de los puntos m√°s cercanos con un m√°ximo de 16 filtros anilotr√≥picos trilineales. Incre√≠blemente suave! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero por esta belleza suave de las texturas, debe pagar con el rendimiento: en configuraciones m√°ximas, el filtrado trilineal anisotr√≥pico recibir√° 128 muestras de la textura por cada p√≠xel de renderizado. Incluso con las mejores GPU modernas, esto no se puede lograr en un ciclo de reloj. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si toma, por ejemplo, AMD </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Radeon RX 5700 XT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cada uno de los bloques de texturas dentro del procesador puede usar hasta 32 direcciones de texel en un ciclo de reloj, y luego en el siguiente ciclo de reloj cargar 32 valores de texel de la memoria (cada uno de los cuales tiene un tama√±o de 32 bits), y luego mezclar cuatro de ellos en uno m√°s tacto. Es decir, mezclar 128 muestras de texel en una requiere al menos 16 ciclos de reloj.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/abf/cf4/fa4abfcf4411b6cc2622c8e77986ab3c.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU AMD RDNA Radeon RX 5700 con tecnolog√≠a de proceso de 7 nan√≥metros</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Si la velocidad del reloj del 5700 XT es de 1605 MHz, diecis√©is ciclos toman solo 10 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nanosegundos</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La realizaci√≥n de estos ciclos para cada p√≠xel en un cuadro de 4K con una </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sola</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unidad de textura solo tomar√° 70 milisegundos. ¬°Genial, parece que el rendimiento no es gran cosa! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incluso en 1996, 3Dfx Voodoo y tarjetas similares hicieron frente r√°pidamente a las texturas. A lo sumo, pod√≠an entregar 1 texel con filtrado bilineal por ciclo, y con una frecuencia de chip TMU de 50 MHz, esto significaba que se pod√≠an procesar 50 millones de texels por segundo. Un juego que se ejecuta a 800 x 600 y 30 fps solo requiere 14 millones de texels con filtrado bilineal por segundo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, esto es cierto solo bajo el supuesto de que todas las texturas est√°n en la memoria m√°s cercana y que solo un texel corresponde a cada p√≠xel. </font><font style="vertical-align: inherit;">Hace veinte a√±os, la idea de la necesidad de superponer varias texturas en una primitiva era completamente extra√±a, pero hoy es un est√°ndar. </font><font style="vertical-align: inherit;">Veamos por qu√© todo esto cambia.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregar iluminaci√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para entender por qu√© la textura se ha vuelto tan importante, eche un vistazo a esta escena de Quake:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/dcf/ee4/bdadcfee4354ea561b9239e1ca5a143b.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es una imagen oscura, porque la oscuridad era la atm√≥sfera del juego, pero vemos que la oscuridad no es la misma en todas partes: algunos fragmentos de paredes y pisos son m√°s claros que otros, lo que crea una sensaci√≥n de ligereza en estas √°reas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las primitivas que componen las paredes y el piso se superponen con las mismas texturas, pero hay otra textura llamada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"mapa de luz"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mezclado con los valores de los texels antes de que se apliquen a los p√≠xeles del marco. En los tiempos del terremoto, los mapas de iluminaci√≥n se calculaban por adelantado y los creaba el motor del juego. Se utilizaron para generar niveles de iluminaci√≥n est√°ticos y din√°micos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La ventaja de su uso es que los c√°lculos de iluminaci√≥n complejos se realizaron con texturas en lugar de v√©rtices, lo que mejor√≥ en gran medida la apariencia de la escena a expensas de los costos de baja velocidad. Obviamente, la imagen es imperfecta: en el piso se nota que el borde entre las √°reas iluminadas y las sombras es muy n√≠tido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En muchos sentidos, un mapa de luz es solo otra textura (no olvide que todos son conjuntos de datos 2D normales), por lo que esta escena es uno de los primeros ejemplos de uso de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texturas m√∫ltiples</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Como su nombre lo indica, este es un proceso en el que dos o m√°s texturas se superponen en una primitiva. El uso de mapas de iluminaci√≥n en Quake se ha convertido en una forma de superar las limitaciones del sombreado de Gouraud, pero en el proceso de aumentar la gama de capacidades de las tarjetas gr√°ficas, los m√©todos de aplicaci√≥n de texturas m√∫ltiples tambi√©n se han expandido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dfx Voodoo, como muchas otras tarjetas de esa √©poca, estaba limitado en la cantidad de operaciones que pod√≠a realizar en un solo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pase de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> renderizado. De hecho, un pase es un ciclo de renderizado completo: desde procesar v√©rtices hasta rasterizar el marco, y luego cambiar los p√≠xeles y escribirlos en el b√∫fer de marco terminado. Hace veinte a√±os, los juegos casi siempre usaban renderizado de una pasada.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/0b6/bc9/a550b6bc98c07f1c90276e1aa3721819.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nvidia GeForce 2 Ultra, a finales de 2000. Imagen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikimedia</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Esto sucedi√≥ porque el segundo procesamiento de v√©rtices solo para aplicar texturas adicionales era demasiado costoso en t√©rminos de rendimiento. Despu√©s de Voodoo, tuvimos que esperar un par de a√±os cuando aparecieron las tarjetas gr√°ficas ATI Radeon y Nvidia GeForce 2, capaces de multitexturar en una sola pasada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas GPU ten√≠an varias unidades de textura en el √°rea de procesamiento de p√≠xeles (es decir, en la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tuber√≠a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), por lo que la tarea m√°s simple fue obtener un texel con filtrado bilineal de dos texturas separadas. Esto aument√≥ a√∫n m√°s la popularidad de los mapas de iluminaci√≥n y permiti√≥ que los juegos los hicieran completamente din√°micos, cambiando los valores de iluminaci√≥n dependiendo de las condiciones del entorno de juego.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero con algunas texturas, se podr√≠a hacer mucho m√°s, as√≠ que exploremos sus capacidades.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiar la altura es normal</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta serie de art√≠culos sobre renderizado 3D, no hablamos sobre c√≥mo el papel de la GPU afecta todo el proceso (hablaremos de esto, ¬°pero no ahora!). Pero si vuelve a la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parte 1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y lee sobre todo el complejo proceso de procesamiento de v√©rtices, podr√≠a pensar que esta es la parte m√°s dif√≠cil de todo el trabajo que debe hacer la GPU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante mucho tiempo lo fue, y los programadores de juegos hicieron todo lo posible para reducir esta carga. Tuvieron que recurrir a todo tipo de trucos para garantizar la misma calidad de imagen que cuando se utilizan m√∫ltiples v√©rtices, pero no los procesen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mayor√≠a de estos trucos usaban texturas llamadas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapas de altura</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapas normales.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Estos dos conceptos est√°n conectados por el hecho de que el √∫ltimo puede crearse a partir del primero, pero por ahora, solo veamos una t√©cnica llamada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"mapeo de relieve"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/db2/5b6/1e3db25b6ecefc0dd3f75c84f767800c.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im√°genes creadas en una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">representaci√≥n de demostraci√≥n por Emil Persson</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La textura en relieve est√° deshabilitada / habilitada La textura en relieve</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
utiliza una matriz 2D llamada "mapa de altura" que se parece a una versi√≥n extra√±a de la textura original. </font><font style="vertical-align: inherit;">Por ejemplo, la imagen de arriba muestra una textura de ladrillo realista superpuesta en dos superficies planas. </font><font style="vertical-align: inherit;">La textura y su mapa de altura se ven as√≠:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/87f/221/7a187f2215bcf0723bd4d4f820350858.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los colores del mapa de altura indican las normales de la superficie de los ladrillos (hablamos de las normales en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parte 1 de una</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> serie de art√≠culos). Cuando el proceso de renderizado alcanza la etapa de aplicar la textura de ladrillo a la superficie, se realizan una serie de c√°lculos para cambiar el color de la textura de ladrillo en funci√≥n de sus valores normales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado de esto, los ladrillos se ven m√°s tridimensionales, a pesar de que contin√∫an siendo completamente planos. Si observa de cerca, especialmente en los bordes de los ladrillos, puede ver las limitaciones de esta t√©cnica: la textura se ve ligeramente distorsionada. Pero este es un truco r√°pido que le permite agregar m√°s detalles de superficie, por lo que la textura en relieve es muy popular.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un mapa normal es similar a un mapa de altura, solo los colores de textura son los mismos normales. En otras palabras, no se requieren c√°lculos para convertir el mapa de altura a normal. Puedes hacer una pregunta: ¬øc√≥mo pueden los colores describir un vector en el espacio? La respuesta es simple: cada texel tiene un conjunto de valores </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r, g, b</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (rojo, verde, azul) y estos valores corresponden directamente a los valores </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x, y, z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del vector normal.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1f/105/c3b/c1f105c3b93c455ba7661489770172c9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El diagrama de la izquierda muestra el cambio en la direcci√≥n de las normales en una superficie irregular. Para describir las mismas normales con una textura plana (contorno medio), les asignamos colores. En este caso, utilizamos los valores </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r, g, b</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (0.255.0) para el vector dirigido directamente hacia arriba, y luego aumentamos el valor de rojo para la inclinaci√≥n hacia la izquierda y azul para la inclinaci√≥n hacia la derecha. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que este color no se mezcla con el p√≠xel original, simplemente le dice al procesador en qu√© direcci√≥n indica la normalidad para que pueda calcular correctamente los √°ngulos entre la c√°mara, las fuentes de luz y la superficie texturizada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las ventajas de la textura en relieve y los mapas normales son completamente evidentes cuando se utiliza iluminaci√≥n din√°mica en la escena, y cuando el proceso de renderizado calcula el efecto del cambio de iluminaci√≥n p√≠xel por p√≠xel, y no para cada v√©rtice. Hoy en d√≠a, los juegos modernos usan un conjunto de texturas para mejorar la calidad de este truco.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ef/d59/660/3efd596604528593b16923297f10f044.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ryan Benno</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sorprendentemente, esta pared de aspecto realista es solo una superficie plana, los detalles de ladrillos y cemento de mamposter√≠a no est√°n hechos con millones de pol√≠gonos. En cambio, solo cinco texturas y el uso reflexivo de los c√°lculos son suficientes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se us√≥ un mapa de altura para generar sombras proyectadas con ladrillos, y un mapa normal para simular todos los cambios menores en la superficie. La textura de rugosidad se utiliz√≥ para cambiar la forma en que la luz se refleja desde varios elementos de la pared (por ejemplo, el ladrillo liso refleja la luz de manera m√°s uniforme que el cemento en bruto).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La √∫ltima tarjeta, nombrada en la imagen AO, crea una parte del proceso llamada oclusi√≥n ambiental: examinaremos esta t√©cnica con m√°s detalle en los siguientes art√≠culos, pero por ahora digamos que ayuda a aumentar el realismo de las sombras.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El mapeo de texturas es un proceso cr√≠tico.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La textura es absolutamente esencial al desarrollar juegos. Tomemos, por ejemplo, el juego de 2019 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kingdom Come: Deliverance</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un juego de rol en primera persona ambientado en Bohemia en el siglo XV. Los dise√±adores buscaron crear el mundo m√°s realista de ese per√≠odo. Y para sumergir al jugador en la vida que era hace cientos de a√±os, es mejor implementar un paisaje, edificios, ropa, peinados, art√≠culos cotidianos y mucho m√°s hist√≥ricamente precisos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada textura en esta imagen del juego fue creada manualmente por artistas, y tambi√©n gracias a un motor de renderizado controlado por programadores. Algunos de ellos son peque√±os, con detalles simples y, por lo tanto, est√°n ligeramente filtrados o procesados ‚Äã‚Äãcon otras texturas (por ejemplo, alitas de pollo).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2e/7d0/24a/e2e7d024ad0c700d26390940caf339ed.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otros tienen alta resoluci√≥n y muchos peque√±os detalles; </font><font style="vertical-align: inherit;">se someten a un filtrado anisotr√≥pico y se mezclan con mapas normales y otras texturas, solo mire la cara de la persona en primer plano. </font><font style="vertical-align: inherit;">Los programadores tienen en cuenta la diferencia en los requisitos de textura de cada objeto de escena. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo esto sucede hoy en muchos juegos, porque los jugadores esperan niveles cada vez m√°s altos de detalle y realismo. </font><font style="vertical-align: inherit;">Las texturas se hacen cada vez m√°s grandes, y cada vez m√°s se superponen en la superficie, pero el proceso de muestreo de texels y superposici√≥n de ellos en p√≠xeles esencialmente sigue siendo el mismo que en los d√≠as del terremoto. </font><font style="vertical-align: inherit;">¬°Las mejores tecnolog√≠as nunca mueren, sin importar la edad que tengan!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es499524/index.html">Quarkus: actualizaciones de la aplicaci√≥n utilizando el ejemplo helloworld de JBoss EAP Quickstart</a></li>
<li><a href="../es499528/index.html">Un puente matem√°tico "deslumbrante" que se extiende m√°s all√° del Gran Teorema de Fermat</a></li>
<li><a href="../es499532/index.html">Palabras en n√∫meros: an√°lisis de blog gratuito habravebinary con Yandex.Metrica</a></li>
<li><a href="../es499534/index.html">Gu√≠a de desarrollo del servicio backend de Python</a></li>
<li><a href="../es499536/index.html">Growbox como m√©todo de conocerse</a></li>
<li><a href="../es499542/index.html">Top Fakapov Cyan</a></li>
<li><a href="../es499544/index.html">Aprende redes neuronales en Hojas de c√°lculo de Google</a></li>
<li><a href="../es499546/index.html">Desarrollo de firmware para una videoc√°mara anal√≥gica EVR-Y2022F</a></li>
<li><a href="../es499548/index.html">M√°scara: ¬øcuidar a los dem√°s o una ilusi√≥n de seguridad?</a></li>
<li><a href="../es499550/index.html">Soluciones de ecosistema de c√≥digo bajo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>