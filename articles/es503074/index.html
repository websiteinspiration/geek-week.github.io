<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙 💂 👩🏾‍🚀 Detalles sobre el paquete de proveedor para Flutter 💤 🏎️ 👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 
 
 Nuestros planes a mediano plazo incluyen el lanzamiento del libro Flutter. Con respecto al lenguaje de Dart como tema, aún tomamos una ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Detalles sobre el paquete de proveedor para Flutter</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/503074/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hola Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestros planes a mediano plazo incluyen el lanzamiento del libro Flutter. </font><font style="vertical-align: inherit;">Con respecto al lenguaje de Dart como tema, aún tomamos una posición más cautelosa, por lo que intentaremos evaluar su relevancia de acuerdo con los resultados de este artículo. </font><font style="vertical-align: inherit;">Se centrará en el paquete del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proveedor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y, por lo tanto, en la gestión del estado en Flutter.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El proveedor es un paquete de gestión estatal escrito por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remy Rusle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y adoptado por Google y la comunidad Flutter. </font><font style="vertical-align: inherit;">Pero, ¿qué es la gestión estatal? </font><font style="vertical-align: inherit;">Para empezar, ¿qué es una condición? </font><font style="vertical-align: inherit;">Permítame recordarle que el estado son solo datos para representar la IU en su aplicación. </font><font style="vertical-align: inherit;">La administración del estado es un enfoque para crear estos datos, acceder, manejarlos y eliminarlos. </font><font style="vertical-align: inherit;">Para comprender mejor el paquete del proveedor, resumimos brevemente la historia de la administración del estado en Flutter.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. StatefulWidget</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StatelessWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un componente de interfaz de usuario simple que se muestra solo cuando tiene datos. No </font></font><code>StatelessWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay "memoria"; se crea y destruye según sea necesario. Flutter también tiene un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StatefulWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en el que hay una memoria, gracias a él un satélite de larga duración: el objeto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esta clase tiene un método </font></font><code>setState()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cuando se llama, se inicia un widget que reconstruye el estado y lo muestra en una nueva forma. Esta es la forma más simple de administración de estado de Flutter que se proporciona de inmediato. Aquí hay un ejemplo con un botón que siempre muestra la última vez que se presionó:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyWidget</span>&gt; </span>{
  <span class="hljs-built_in">DateTime</span> _time = <span class="hljs-built_in">DateTime</span>.now();  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(_time.toString()),<font></font>
      onPressed: () {<font></font>
        setState(() =&gt; _time = <span class="hljs-built_in">DateTime</span>.now());<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ¿cuál es el problema con este enfoque? </font><font style="vertical-align: inherit;">Suponga que su aplicación tiene un estado global almacenado en la raíz </font></font><code>StatefulWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Contiene datos destinados a su uso en varias partes de la interfaz de usuario. </font><font style="vertical-align: inherit;">Estos datos se comparten y se pasan a cada widget secundario en forma de parámetros. </font><font style="vertical-align: inherit;">Cualquier evento durante el cual se planee cambiar estos datos aparecerá en forma de devoluciones de llamada. </font><font style="vertical-align: inherit;">Por lo tanto, a través de todos los widgets intermedios, se transfieren muchos parámetros y devoluciones de llamada, lo que pronto puede generar confusión. </font><font style="vertical-align: inherit;">Peor aún, cualquier actualización de la raíz mencionada anteriormente conducirá a una reconstrucción del árbol de widgets completo, lo cual es ineficiente.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. InheritedWidget</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InheritedWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un widget especial cuyos descendientes pueden acceder a él sin un enlace directo. </font><font style="vertical-align: inherit;">Con solo pasar a </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, un widget consumidor puede registrarse para una reconstrucción automática, lo que ocurrirá al reconstruir un widget ancestro. </font><font style="vertical-align: inherit;">Esta técnica le permite organizar de manera más eficiente la actualización de la interfaz de usuario. </font><font style="vertical-align: inherit;">En lugar de reconstruir grandes partes de la aplicación en respuesta a un pequeño cambio de estado, puede seleccionar selectivamente solo aquellos widgets específicos que necesitan ser reconstruidos. </font><font style="vertical-align: inherit;">Ya has trabajado con </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada vez que usaste </font></font><code>MediaQuery.of(context)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>Theme.of(context)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es cierto que es menos probable que haya implementado su propio InheritedWidget con preservación del estado. </font><font style="vertical-align: inherit;">El hecho es que implementarlos correctamente no es fácil.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. ScopedModel</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScopedModel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un paquete creado en 2017 por Brian Egan, que facilita el uso </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para almacenar el estado de la aplicación. </font><font style="vertical-align: inherit;">Primero debe crear un objeto de estado que herede del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y luego llamarlo </font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando cambien sus propiedades. </font><font style="vertical-align: inherit;">La situación recuerda a la implementación de la interfaz </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PropertyChangeListener</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en Java.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Model</span> </span>{<font></font>
  String _foo;  String get foo =&gt; _foo;<font></font>
  <font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> set <span class="hljs-title">foo</span><span class="hljs-params">(String value)</span> </span>{<font></font>
    _foo = value;<font></font>
    notifyListeners();  <font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para proporcionar nuestro objeto de estado, envolvemos este objeto en un widget </font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la raíz de nuestra aplicación:</font></font><br>
<br>
<pre><code class="java hljs">ScopedModel&lt;MyModel&gt;(<font></font>
  model: MyModel(),<font></font>
  child: MyApp(...)<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora cualquier widget descendente podrá acceder </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usando el widget </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScopedModelDescendant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La instancia del modelo se pasa al parámetro </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> ScopedModelDescendant&lt;MyModel&gt;(<font></font>
      builder: (context, child, model) =&gt; Text(model.foo),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cualquier widget descendiente también podrá actualizar el modelo, lo que provocará automáticamente una reconstrucción de cualquiera </font></font><code>ScopedModelDescendants</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(siempre que nuestro modelo llame correctamente </font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = ScopedModel.of&lt;MyModel&gt;(context);<font></font>
        model.foo = <span class="hljs-string">'bar'</span>;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br>
<code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ganó popularidad en Flutter como una herramienta para la gestión del estado, pero su uso se limita a la provisión de objetos que heredan la clase </font></font><code>Model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y usan este patrón de notificación de cambios.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. BLoC</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la conferencia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google I / O '18</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">se introdujo el patrón del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componente lógico de negocios</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (BLoC), que sirve como otra herramienta más para extraer el estado de los widgets. Las clases BLoC son componentes no UI de larga duración que conservan el estado y lo exponen como flujos y receptores. Llevando el estado y la lógica empresarial más allá de la interfaz de usuario, puede implementar el widget de manera simple </font></font><code>StatelessWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y usar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamBuilder</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para la reconstrucción automática. Como resultado, el widget "se vuelve tonto" y se vuelve más fácil de probar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ejemplo de clase BLoC:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBloc</span> </span>{
  <span class="hljs-keyword">final</span> _controller = StreamController&lt;MyType&gt;();  Stream&lt;MyType&gt; <span class="hljs-keyword">get</span> stream =&gt; _controller.stream;<font></font>
  StreamSink&lt;MyType&gt; <span class="hljs-keyword">get</span> sink =&gt; _controller.sink;<font></font>
  <font></font>
  myMethod() {<font></font>
    <span class="hljs-comment">//  </span><font></font>
    sink.add(foo);<font></font>
  }  dispose() {<font></font>
    _controller.close();<font></font>
  }<font></font>
}<font></font>
 ,   BLoC:<font></font>
<span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context) {<font></font>
 <span class="hljs-keyword">return</span> StreamBuilder&lt;MyType&gt;(<font></font>
  stream: myBloc.stream,<font></font>
  builder: (context, asyncSnapshot) {<font></font>
    <span class="hljs-comment">//  </span><font></font>
 });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema con el patrón BLoC es que no es obvio cómo crear y destruir objetos BLoC. </font><font style="vertical-align: inherit;">¿Cómo se creó la instancia </font></font><code>myBloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el ejemplo anterior? </font><font style="vertical-align: inherit;">¿Cómo llamamos </font></font><code>dispose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para deshacernos de él? </font><font style="vertical-align: inherit;">Las transmisiones requieren uso </font></font><code>StreamController</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo cual debería ser </font></font><code>closed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tan pronto como sea innecesario; esto se hace para evitar pérdidas de memoria. </font><font style="vertical-align: inherit;">(No hay tal cosa como un destructor de clase en Dart, sólo una clase </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>StatefulWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene un método </font></font><code>dispose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Además, no está claro cómo compartir este BLoC entre múltiples widgets. </font><font style="vertical-align: inherit;">A menudo es difícil para los desarrolladores dominar BLoC. </font><font style="vertical-align: inherit;">Hay varios paquetes que intentan simplificar esto.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Proveedor</font></font></h4><br>
<code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es un paquete escrito en 2018 por Remy Rusle, similar a </font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero cuyas funciones no se limitan a, proporcionar una subclase de Modelo. Esto también es un contenedor que concluye </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero el proveedor puede proporcionar cualquier objeto de estado, incluidos BLoC, flujos, futuros y otros. Dado que el proveedor es tan simple y flexible, Google anunció en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conferencia Google I / O '19</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que en el futuro </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">será el paquete preferido para administrar el estado. Por supuesto, también se permiten otros paquetes, pero si tiene alguna duda, Google recomienda visitarlo </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">construido "con widgets, para widgets".</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le permite colocar cualquier objeto con un estado en el árbol de widgets y abrir el acceso a él para cualquier otro widget (hijo). </font><font style="vertical-align: inherit;">También </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ayuda a administrar la vida útil de los objetos de estado al inicializarlos con datos y realizar una limpieza después de que se eliminan del árbol de widgets. </font><font style="vertical-align: inherit;">¡Por lo tanto, </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es adecuado incluso para implementar componentes BLoC o puede servir como base para otras soluciones de gestión estatal! </font><font style="vertical-align: inherit;">O simplemente se usa para </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementar dependencias</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un término elegante que significa transferir datos a widgets de una manera que le permite aflojar la conexión y mejorar la capacidad de prueba del código. </font><font style="vertical-align: inherit;">Finalmente,</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viene con un conjunto de clases especializadas, gracias a las cuales es aún más conveniente de usar. </font><font style="vertical-align: inherit;">A continuación, veremos más de cerca cada una de estas clases.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proveedor Básico</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChangeNotifierProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proveedor futuro</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenableProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MultiProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proxyprovider</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instalación</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para usarlo </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, primero agregue una dependencia a nuestro archivo </font></font><code>pubspec.yaml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<code>provider: ^3.0.0</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego importamos el paquete </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donde se necesita: </font></font><br>
<br>
<code>import 'package:provider/provider.dart';</code><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proveedor base</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Cree la base </font></font><code>Provide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r en la raíz de nuestra aplicación; </font><font style="vertical-align: inherit;">Esto contendrá una instancia de nuestro modelo:</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: MyApp(...),<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El parámetro </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crea una instancia </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si desea pasarle una instancia existente, use el constructor aquí </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Provider.value</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego puede consumir esta instancia del modelo en cualquier lugar </font></font><code>MyApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, utilizando el widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> Consumer&lt;MyModel&gt;(<font></font>
      builder: (context, value, child) =&gt; Text(value.foo),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el ejemplo anterior, la clase </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obtiene una instancia </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizando el widget </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consumer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Este widget nos proporciona </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuestro objeto en el parámetro </font></font><code>value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, ¿qué debemos hacer si queremos actualizar los datos en nuestro modelo? Digamos que tenemos otro widget donde, cuando se hace clic en un botón, la propiedad debe actualizarse </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);<font></font>
        model.foo = <span class="hljs-string">'bar'</span>;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta la sintaxis específica utilizada para acceder a la instancia </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Funcionalmente, esto es equivalente a acceder al widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. El widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es útil en los casos en que el código no puede obtener fácilmente el enlace </font></font><code>BuildContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué crees que pasará con el widget original </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que creamos anteriormente? ¿Se mostrará un nuevo significado en él </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lamentablemente no</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . No es posible escuchar los cambios en los antiguos objetos Dart tradicionales (al menos sin reflexión, que no se proporciona en Flutter). Por </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lo </font><font style="vertical-align: inherit;">tanto, </font><font style="vertical-align: inherit;">no podrá "ver" que hemos actualizado correctamente la propiedad </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y ordenado que el widget se </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actualice en respuesta. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChangeNotifierProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero hay esperanza! </font><font style="vertical-align: inherit;">Puede hacer que nuestra clase </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implemente una impureza </font></font><code>ChangeNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cambiará un poco la implementación de nuestro modelo y llamaremos a un método especial </font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada vez que cambie una de nuestras propiedades. </font><font style="vertical-align: inherit;">Funciona aproximadamente de la misma manera </font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero en este caso es bueno que no necesite heredar de una clase particular del modelo. </font><font style="vertical-align: inherit;">Es suficiente para darse cuenta de la mezcla </font></font><code>ChangeNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Así es como se ve:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>{
  <span class="hljs-built_in">String</span> _foo;  <span class="hljs-built_in">String</span> <span class="hljs-keyword">get</span> foo =&gt; _foo;<font></font>
  <font></font>
  <span class="hljs-keyword">void</span> <span class="hljs-keyword">set</span> foo(<span class="hljs-built_in">String</span> value) {<font></font>
    _foo = value;<font></font>
    notifyListeners();  <font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, reemplazamos nuestra propiedad </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con </font></font><code>getter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>setter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, respaldada por la variable privada _foo. </font><font style="vertical-align: inherit;">De esta forma, podemos "interceptar" cualquier cambio realizado en la propiedad foo y dejar que nuestros oyentes sepan que nuestro objeto ha cambiado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, desde afuera </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podemos cambiar nuestra implementación para que use una clase diferente llamada </font></font><code> ChangeNotifierProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs">ChangeNotifierProvider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: MyApp(...),<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Me gusta esto! </font><font style="vertical-align: inherit;">Ahora, cuando nuestras </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actualizaciones actualicen la propiedad </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la instancia </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actualizará automáticamente para reflejar este cambio. </font><font style="vertical-align: inherit;">¿Guay, verdad? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto. </font><font style="vertical-align: inherit;">Probablemente haya notado un controlador de botones </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con el que usamos la siguiente sintaxis:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De manera predeterminada, esta sintaxis provocará automáticamente la reconstrucción de la instancia </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tan pronto como cambie el modelo </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Quizás no necesitamos esto. </font><font style="vertical-align: inherit;">Al final, </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplemente contiene un botón que no cambia en absoluto cuando cambia el valor </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para evitar la reconstrucción, puede usar la siguiente sintaxis para acceder a nuestro modelo sin registrarse para la reconstrucción:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context, listen: <span class="hljs-keyword">false</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es otro encanto proporcionado en el paquete </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">así como así. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
A primera vista, no está claro por qué es necesario </font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al final, puede usar lo habitual </font></font><code>StreamBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si necesita consumir una transmisión en Flutter. </font><font style="vertical-align: inherit;">Por ejemplo, aquí escuchamos la transmisión </font></font><code>onAuthStateChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proporcionada por </font></font><code>FirebaseAuth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context {<font></font>
  <span class="hljs-keyword">return</span> StreamBuilder(<font></font>
   stream: FirebaseAuth.instance.onAuthStateChanged, <font></font>
   builder: (BuildContext context, AsyncSnapshot snapshot){ <font></font>
     ...<font></font>
   });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer lo mismo con ayuda </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podríamos proporcionar nuestra transmisión a través </font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de la raíz de nuestra aplicación:</font></font><br>
<br>
<pre><code class="dart hljs">StreamProvider&lt;FirebaseUser&gt;.value(<font></font>
  stream: FirebaseAuth.instance.onAuthStateChanged,<font></font>
  child: MyApp(...),<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego consuma el widget hijo, como generalmente se hace con </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context) {<font></font>
  <span class="hljs-keyword">return</span> Consumer&lt;FirebaseUser&gt;(<font></font>
    builder: (context, value, child) =&gt; Text(value.displayName),<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro código de widget no solo se ha vuelto mucho más limpio, sino que también resume el hecho de que los datos provienen de la transmisión. Si alguna vez decidimos cambiar la implementación base, por ejemplo, a </font></font><code>FutureProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entonces no se requerirán cambios en el código del widget. Como verá, esto se aplica a todos los demás proveedores que se muestran a continuación. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FutureProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Similar al ejemplo anterior, </font></font><code>FutureProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es una alternativa al estándar </font></font><code> FutureBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando se trabaja con widgets. Aquí hay un ejemplo:</font></font><br>
<br>
<pre><code class="plaintext hljs">FutureProvider&lt;FirebaseUser&gt;.value(<font></font>
  value: FirebaseAuth.instance.currentUser(),<font></font>
  child: MyApp(...),<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para consumir este valor en el widget secundario, utilizamos la misma implementación </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que en el ejemplo </font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anterior. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenableProvider </font></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una interfaz Dart implementada por la clase </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueNotifier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que toma un valor y notifica a los oyentes cuando cambia a otro valor. </font><font style="vertical-align: inherit;">Es posible, por ejemplo, envolver un contador entero en una clase de modelo simple:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> </span>{
  <span class="hljs-keyword">final</span> ValueNotifier&lt;<span class="hljs-built_in">int</span>&gt; counter = ValueNotifier(<span class="hljs-number">0</span>);  <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando se trabaja con tipos complejos, </font></font><code>ValueNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliza el operador del </font></font><code>==</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objeto almacenado en él para determinar si el valor ha cambiado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creemos el más simple </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que contendrá nuestro modelo principal, y será seguido por una </font><font style="vertical-align: inherit;">propiedad de escucha </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anidada </font><font style="vertical-align: inherit;">:</font></font><code>ValueListenableProvider</code><font style="vertical-align: inherit;"></font><code>counter</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: Consumer&lt;MyModel&gt;(builder: (context, value, child) {<font></font>
    <span class="hljs-keyword">return</span> ValueListenableProvider&lt;<span class="hljs-built_in">int</span>&gt;.value(<font></font>
      value: value.counter,<font></font>
      child: MyApp(...)<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que este proveedor anidado es de tipo </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Puede haber otros. </font><font style="vertical-align: inherit;">Si tiene varios proveedores del mismo tipo registrados, el Proveedor devolverá el "más cercano" (antepasado más cercano). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí se explica cómo escuchar una propiedad </font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde cualquier widget secundario:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> Consumer&lt;<span class="hljs-built_in">int</span>&gt;(<font></font>
      builder: (context, value, child) {<font></font>
        <span class="hljs-keyword">return</span> Text(value.toString());<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero aquí se explica cómo actualizar una propiedad </font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde otro widget. </font><font style="vertical-align: inherit;">Tenga en cuenta: necesitamos acceso a la copia original </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);<font></font>
        model.counter.value++;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MultiProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Si usa muchos widgets</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en la raíz de la aplicación obtendrá una estructura fea de muchos archivos adjuntos:</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;Foo&gt;.value( <font></font>
  value: foo, <font></font>
  child: Provider&lt;Bar&gt;.value( <font></font>
    value: bar, <font></font>
    child: Provider&lt;Baz&gt;.value( <font></font>
      value: baz , <font></font>
      child: MyApp(...)<font></font>
    ) <font></font>
  ) <font></font>
)</code></pre><br>
<code>MultiProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le permite declararlos a todos en el mismo nivel. </font><font style="vertical-align: inherit;">Es solo azúcar sintáctico: a nivel intra-sistema, todos permanecen anidados de todos modos.</font></font><br>
<br>
<pre><code class="dart hljs">MultiProvider( <font></font>
  providers: [ <font></font>
    Provider&lt;Foo&gt;.value(value: foo), <font></font>
    Provider&lt;Bar&gt;.value(value: bar), <font></font>
    Provider&lt;Baz&gt;.value(value: baz), <font></font>
  ], <font></font>
  child: MyApp(...), <font></font>
)<font></font>
</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProxyProvider</font></font></i></a><br>
<br>
<code>ProxyProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una clase interesante agregada en el tercer lanzamiento del paquete</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le permite declarar proveedores que pueden depender de otros proveedores, hasta seis en uno. </font><font style="vertical-align: inherit;">En este ejemplo, la clase Bar es específica de la instancia</font></font><code>Foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto es útil al compilar un conjunto raíz de servicios que dependen entre sí.</font></font><br>
<br>
<pre><code class="dart hljs">MultiProvider ( <font></font>
  providers: [ <font></font>
    Provider&lt;Foo&gt; ( <font></font>
      builder: (context) =&gt; Foo(),<font></font>
    ), <font></font>
    ProxyProvider&lt;Foo, Bar&gt;(<font></font>
      builder: (context, value, previous) =&gt; Bar(value),<font></font>
    ), <font></font>
  ], <font></font>
  child: MyApp(...),<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primer argumento de tipo genérico es el tipo del que depende el suyo </font></font><code>ProxyProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y el segundo es el tipo que devuelve.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cómo escuchar a muchos proveedores al mismo tiempo</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué sucede si queremos que un solo widget escuche a muchos proveedores y se reconstruya cuando alguno de ellos cambie? </font><font style="vertical-align: inherit;">Puede escuchar hasta 6 proveedores al mismo tiempo utilizando las opciones de widgets </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Recibiremos instancias como parámetros de métodos adicionales </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="dart hljs">Consumer2&lt;MyModel, <span class="hljs-built_in">int</span>&gt;(<font></font>
  builder: (context, value, value2, child) {<font></font>
    <span class="hljs-comment">//value  MyModel</span>
    <span class="hljs-comment">//value2  int</span><font></font>
  },<font></font>
);</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando se usa, </font></font><code>InheritedWidget</code> <code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le permite administrar el estado como es habitual en Flutter. </font><font style="vertical-align: inherit;">Permite que los widgets accedan a objetos de estado y los escuchen de tal manera que se abstraiga el mecanismo de notificación subyacente. </font><font style="vertical-align: inherit;">Es más fácil administrar la vida útil de los objetos de estado creando puntos de anclaje para crear estos objetos según sea necesario y deshacerse de ellos cuando sea necesario. </font><font style="vertical-align: inherit;">Este mecanismo se puede utilizar para implementar fácilmente dependencias e incluso como base para opciones de administración de estado más avanzadas. </font><font style="vertical-align: inherit;">Con la bendición de Google y el creciente apoyo de la comunidad de Flutter, se </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ha convertido en un paquete que vale la pena probar sin demora.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es503062/index.html">El costo real de vida en Silicon Valley para el desarrollador</a></li>
<li><a href="../es503064/index.html">IoT donde no esperaste (parte 3). Construyendo un modelo de simulación</a></li>
<li><a href="../es503068/index.html">En la encrucijada de tecnología y negocios: los líderes de TI abren una nueva universidad en Suiza</a></li>
<li><a href="../es503070/index.html">Taza electrica. Construyendo un loco scooter eléctrico / bicicleta eléctrica</a></li>
<li><a href="../es503072/index.html">Solo otra herramienta: conocer la configuración del servicio con la Configuración de estado deseada </a></li>
<li><a href="../es503082/index.html">Telegram como NAS / FTP</a></li>
<li><a href="../es503084/index.html">Revisión del curso de Lightbend Academy - Arquitectura reactiva</a></li>
<li><a href="../es503086/index.html">¿Los servicios de transcripción en línea son seguros y confidenciales?</a></li>
<li><a href="../es503088/index.html">Cómo seleccionamos carga para transportistas</a></li>
<li><a href="../es503096/index.html">¿Por qué los gerentes quieren que los trabajadores reciclen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>