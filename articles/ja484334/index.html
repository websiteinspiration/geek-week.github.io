<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐘 ⚗️ 👇🏽 Kubernetes作業ノード：多くの小規模または大規模のノード？ 👩‍🌾 🧓 👨🏽‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kubernetesクラスターを作成するときに、構成する作業ノードの数とタイプは何ですか？オンプレミスクラスターの優れた点：強力なサーバーをいくつか購入するか、データセンターで古いマシンを数十台使用しますか？クラウドで8つのシングルコアまたは2つのクアッドコアインスタンスを取得する方が良いですか？
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kubernetes作業ノード：多くの小規模または大規模のノード？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/484334/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/qv/o_/v8/qvo_v845n_v0saxkdqv4-chybts.jpeg" width="500"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetesクラスターを作成するときに、構成する作業ノードの数とタイプは何ですか？</font><font style="vertical-align: inherit;">オンプレミスクラスターの優れた点：強力なサーバーをいくつか購入するか、データセンターで古いマシンを数十台使用しますか？</font><font style="vertical-align: inherit;">クラウドで8つのシングルコアまたは2つのクアッドコアインスタンスを取得する方が良いですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの質問に対する答え</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">は、Mail.ru Kubernetes aaS</font></a><font style="vertical-align: inherit;">チーム</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">から</font></a><font style="vertical-align: inherit;">翻訳さ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">れた</font></a><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Learnk8sトレーニングプロジェクトのソフトウェアエンジニア兼教師であるDaniel Weibel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">による記事にあり</font><font style="vertical-align: inherit;">ます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスター容量</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、Kubernetesクラスタは大きな「スーパーノード」と見なすことができます。</font><font style="vertical-align: inherit;">その総計算能力は、すべてのコンポーネントノードの容量の合計です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目的のターゲットクラスタ容量を実現するには、いくつかの方法があります。</font><font style="vertical-align: inherit;">たとえば、アプリケーションのセットは非常に多くのリソースを必要とするため、合計で8つのプロセッサコアと32 GBのRAMを備えたクラスターが必要です。</font><font style="vertical-align: inherit;">次に、16 GBのメモリの2つのノードまたは8 GBのメモリの4つのノード、2つのクアッドコアプロセッサ、または4つのデュアルコアをインストールできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスタを作成するには、次の2つの方法があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/491/3be/c6f/4913bec6f7b28bae4ed9f961ce5c646a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どちらのオプションでも同じ容量のクラスターが提供されますが、以下の構成では4つの小さなノードがインストールされ、上記の構成では2つの大きなノードがインストールされます。 </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのオプションが良いですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この質問に答えるために、両方のオプションの利点を検討してください。</font><font style="vertical-align: inherit;">それらをテーブルに持ってきました。</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th width="300"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかの大きなノード</font></font><br>
</th>
<th width="300"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの小さな結び目</font></font><br>
</th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">容易なクラスター管理（オンプレミスの場合）</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スムーズな自動スケーリング</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安価（オンプレミスの場合） </font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">価格に大きな違いはありません（クラウド内） </font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求の厳しいアプリケーションを実行できます </font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なレプリケーション</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソースがより効率的に使用されます（システムデーモンのオーバーヘッドが少なくなります）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高次フェールオーバークラスター</font></font><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは作業ノードについてのみ説明していることに注意してください。</font><font style="vertical-align: inherit;">メインノードの数とサイズの選択は、まったく別のトピックです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、表の各項目について詳しく説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のオプション：いくつかの大きなノード</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も極端なオプションは、クラスター全体の容量に対して1つの稼働ノードです。</font><font style="vertical-align: inherit;">上記の例では、これは、16個のCPUコアと16 GBのRAMを備えた1つの動作中のノードです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長所 </font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラスNo. 1.管理</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の容易さ：車両全体よりも複数の車を管理する方が簡単です。</font><font style="vertical-align: inherit;">更新とパッチの高速化、同期の容易化。</font><font style="vertical-align: inherit;">絶対数での失敗の数も少なくなります。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記のすべてがハードウェア、サーバーに適用され、クラウドインスタンスには適用されないことに注意してください。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラウドの状況は異なります。そこでは、クラウドサービスプロバイダーが管理を処理します。したがって、クラウド内の10個のノードを管理することは、1個のノードを管理することと大差ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラウド内のポッド間のトラフィックルーティングとロードバランシング</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は自動的に実行されます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。インターネットからのトラフィックはメインロードバランサーに送信され、ノードの1つのポートにトラフィックを転送します（NodePortサービスは、クラスターの各ノードで30000〜32767の範囲のポートを設定します）。 kube-proxyによって設定されたルールは、ホストからサブにトラフィックをリダイレクトします。これは、2つのノードの10個の炉の場合の外観です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/xh/zm/m3/xhzmm3jsahvoqhytxlwm3jxgjoe.jpeg" width="400"></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラスNo. 2.ユニットあたりのコストが低い</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
強力なマシンはより高価ですが、価格の上昇は必ずしも直線的ではありません。</font><font style="vertical-align: inherit;">つまり、10 GBのメモリを搭載した1つの10コアサーバーは、通常、同じ容量の10のシングルコアサーバーよりも安価です。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただし、このルールは通常、クラウドサービスでは機能しないことに注意してください。</font><font style="vertical-align: inherit;">すべての主要なクラウドサービスプロバイダー向けの現在の料金体系では、容量の増加に伴って価格が直線的に上昇します。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、クラウドでは通常、より強力なサーバーに保存することはできません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラス番号3。要求の厳しいアプリケーションを実行できます</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
一部のアプリケーションでは、クラスター内に強力なサーバーが必要です。</font><font style="vertical-align: inherit;">たとえば、機械学習システムに8 GBのメモリが必要な場合、1 GBのノードで実行することはできませんが、少なくとも1つの大きな動作ノードがある場合のみです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイナス </font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイナス番号1。ノードごとに多くのポッド</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
同じタスクがより少ないノードで実行される場合、各ノードには当然より多くのポッドがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは問題になる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その理由は、各モジュールがコンテナーランタイム（Dockerなど）だけでなく、kubeletやcAdvisorにもオーバーヘッドをかけるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、kubeletはノードのすべてのコンテナーを定期的に調査して、存続可能性を確認します。コンテナーが多いほど、kubeletの作業は多くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CAdvisorはノード上のすべてのコンテナーのリソースの使用に関する統計を収集し、kubeletは定期的にこの情報を要求し、APIを通じて提供します。繰り返しになりますが、コンテナーが多いほど、cAdvisorとkubeletの両方の作業が多くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールの数が増えると、システムの速度が低下し、信頼性が損なわれる可能性もあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fad/7fc/d9c/fad7fcd9c1007d3ddf682feed3aed379.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetesリポジトリで</font><font style="vertical-align: inherit;">は、ノード上のすべてのコンテナの定期的なkubeletチェックに時間がかかりすぎるため、ノードが準備完了/準備完了ステータスの間でジャンプするという</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不満</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がありました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このため、Kubernetes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はノードあたり110を超えないポッドを配置することをお勧めします</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ノードのパフォーマンスによっては、ノードごとにより多くのハースを実行できますが、問題が発生するかどうか、またはすべてが正常に機能するかどうかを予測することは困難です。事前に作業をテストする価値があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイナス＃2.レプリケーションの制限</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ノードが少なすぎると、アプリケーションのレプリケーションの効果的な度合いが制限されます。たとえば、5つのレプリカの高可用性アプリケーションがあり、ノードが2つしかない場合、アプリケーションレプリケーションの効果的な程度は2つに減少します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5つのレプリカは2つのノードにのみ配布でき、そのうちの1つが機能しない場合、すぐに複数のレプリカが破棄されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5つ以上のノードがある場合、各レプリカは個別のノードで実行され、1つのノードで障害が発生しても、削除されるレプリカは1つだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、高可用性要件では、クラスター内に特定の最小数のノードが必要になる場合があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイナス数3.障害の悪い結果</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
少数のノードでは、各障害はより深刻な結果をもたらします。たとえば、ノードが2つしかなく、そのうちの1つが失敗した場合、モジュールの半分がすぐに消えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、Kubernetesは障害が発生したノードから他のノードにワークロードを転送します。しかし、それらが少ない場合、空き容量は十分ではない可能性があります。その結果、一部のアプリケーションは、障害が発生したノードを選択するまで使用できなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ノードが多いほど、ハードウェア障害の影響が少なくなります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイナス番号4.</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
自動スケーリングの</font><b><font style="vertical-align: inherit;">ステップの</font></b><font style="vertical-align: inherit;">増加Kubernetesには、クラウドインフラストラクチャ用のクラスター自動スケーリングシステムがあり、現在のニーズに応じてノードを自動的に追加または削除できます。ノードが大きい場合、自動スケーリングはよりシャープで不器用になります。たとえば、2つのノードでノードを追加すると、クラスターの容量が一度に50％増加します。そして、たとえあなたがそれらを必要としなくても、あなたはこれらの資源にお金を払わなければならないでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、自動クラスタースケーリングを使用する場合は、ノードが小さいほど、より柔軟で経済的なスケーリングが得られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、多数の小さなノードの利点と欠点を検討します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目のオプション：多くの小さなノード</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの利点は、実際には、いくつかの大きなノードを持つ反対のオプションの欠点から生じます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長所</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラス＃1.障害の結果</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
が少ないノードが多いほど、各ノードのポッドは少なくなります。たとえば、10個のノードごとに100個のモジュールがある場合、各ノードには平均10個のモジュールがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ノードの1つに障害が発生しても、ワークロードの10％しか失われません。影響を受けるレプリカはごく少数であり、アプリケーション全体としては引き続き機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、残りのノードには、障害が発生したノードのワークロードに対して十分な空きリソースがある可能性が高いため、Kubernetesはポッドを自由に再スケジュールでき、アプリケーションは比較的迅速に機能状態に戻ります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラス番号2。優れた複製</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノードが十分にある場合、Kubernetesスケジューラはすべてのレプリカに異なるノードを割り当てることができます。</font><font style="vertical-align: inherit;">したがって、ノードに障害が発生した場合、影響を受けるレプリカは1つだけであり、アプリケーションは引き続き使用可能です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイナス </font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少ない＃1.管理</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
が困難多くのノードは管理が困難です。たとえば、各Kubernetesホストは他のすべてのホストと相互作用する必要があります。つまり、リンクの数は2次的に増加し、これらのすべてのリンクを追跡する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetesコントローラーマネージャーのノードコントローラーは、クラスター内のすべてのノードを定期的にバイパスして、操作性を確認します。ノードが多いほど、コントローラーの負荷が大きくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
etcdデータベースへの負荷も増大しています。各kubeletおよびkube-proxyは</font><font style="vertical-align: inherit;">（APIを介して）etcdの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウォッチャー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">、そこにetcdがオブジェクトの更新をブロードキャストする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、各作業ノードは、メインノードのシステムコンポーネントに追加の負荷をかけます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce0/781/c0a/ce0781c0af525f269c4716c572b79ec7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetesは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大5000ノードの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスタを公式にサポートし</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">てい</font></a><font style="vertical-align: inherit;">ます。ただし、実際には、すでに500ノード</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が重要な問題を引き起こす可能性があります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多数の作業ノードを管理するには、より生産的なメインノードを選択する必要があります。たとえば、kube-up </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作業ノードの数に応じて、メインノードの正しいVMサイズを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">自動的に設定し</font></a><font style="vertical-align: inherit;">ます。つまり、作業ノードが多いほど、メインノードの生産性が向上します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの特定の問題を解決するために、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virtual Kubelet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの特別な開発があります</font><font style="vertical-align: inherit;">。このシステムを使用すると、制限を回避し、膨大な数の作業ノードを持つクラスターを構築できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイナス番号2。オーバーヘッドの増加</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetesは、稼働中の各ノードでシステムデーモンのセットを起動します。これには、cAdvisorを含むコンテナーランタイム（Dockerなど）、kube-proxy、kubeletが含まれます。同時に、一定の固定量のリソースを消費します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小さなノードが多数ある場合、各ノードでのこのオーバーヘッドのシェアは大きくなります。たとえば、単一ノード上のすべてのシステムデーモンが一緒に0.1 CPUコアと0.1 GBのメモリを使用するとします。 10 GBのメモリを備えた1つの10コアノードがある場合、デーモンはクラスター容量の1％を消費します。一方、メモリが1 GBの10個のシングルコアノードでは、デーモンはクラスター容量の10％を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ノードが小さいほど、インフラストラクチャはより効率的に使用されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイナス3。リソースの非効率的な使用</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小さなノードでは、リソースの残りのフラグメントが小さすぎて何らかの種類のワークロードを割り当てることができないため、未使用のままになるという状況が発生する場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、各ポッドには0.75 GBのメモリが必要です。</font><font style="vertical-align: inherit;">10個のノードがあり、それぞれに1 GBのメモリがある場合、10個のポッドを実行できます。その結果、0.25 GBの未使用メモリが各ノードに残ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、クラスター全体のメモリーの25％が無駄になることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 GBのメモリを搭載した大規模なノードでは、これらのモジュールのうち13個を実行できます。未使用の0.25 GBフラグメントは1つだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、メモリの2.5％しか無駄になりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、大きなノードでは、リソースがより最適に使用されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少数の大きなノードまたは多数の小さなノード？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、どちらが良いですか：クラスター内のいくつかの大きなノードまたは多くの小さなノード？いつものように、明確な答えはありません。アプリケーションのタイプに大きく依存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、アプリケーションが10 GBのメモリを必要とする場合、大きなノードの方が有利です。また、アプリケーションで高可用性を実現するために10倍のレプリケーションが必要な場合、レプリカを2つのノードのみに配置するリスクはほとんどありません。クラスターには少なくとも10個のノードが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中間の状況では、各オプションの長所と短所に基づいて選択してください。おそらく、いくつかの議論は他のものよりあなたの状況に関連しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、すべてのノードを同じサイズにする必要はありません。</font><font style="vertical-align: inherit;">最初に1つのサイズのノードを試し、次に異なるサイズのノードを追加して、それらをクラスターに結合することを妨げるものはありません。</font><font style="vertical-align: inherit;">Kubernetesクラスターの作業ノードは完全に異種混合にすることができます。</font><font style="vertical-align: inherit;">したがって、両方のアプローチの利点を組み合わせることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単一のレシピはありませんが、それぞれの状況には独自のニュアンスがあり、生産のみが真実を示します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mail.ru Cloud Solutions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラウドプラットフォームのチームによって準備されました</font><font style="vertical-align: inherit;">。</font></font></i><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetesの詳細：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスターの管理とデプロイに役立つ25のツール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
</td>
</tr>
</tbody></table></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja484320/index.html">Quarkus、Kotlin、Gradleでのマイクロサービスの作成</a></li>
<li><a href="../ja484326/index.html">ジャンプトレーディングでロンドンまたはインターンシップにジャンプ</a></li>
<li><a href="../ja484328/index.html">Paul Grahamが新しいBelプログラミング言語を発表</a></li>
<li><a href="../ja484330/index.html">[Nginx] response_status = 0に勝つ方法</a></li>
<li><a href="../ja484332/index.html">タスク管理に焦点を当てます。管理システムの方法</a></li>
<li><a href="../ja484336/index.html">動的配列とカスタムコレクションクラスを操作するためのルール</a></li>
<li><a href="../ja484338/index.html">サムスンのネオンプロジェクト：デジタルバンカー、TVホスト、コンパニオン</a></li>
<li><a href="../ja484340/index.html">1月17日のJavaダイジェスト。新年の最初の2週間</a></li>
<li><a href="../ja484342/index.html">「Toradex Colibri T20（Linux）」用のEclipseおよびGTK +に基づくツールキット</a></li>
<li><a href="../ja484344/index.html">Kubernetesの3レベルの自動スケーリング：それらを効果的に使用する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>