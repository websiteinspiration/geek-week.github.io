<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏻 👸🏼 👍 新しいGPU追跡アルゴリズム：Wavefrontパストレース 🏂 👉 🚚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、最近リリースされたLighthouse 2プラットフォームで使用されている重要な概念について説明します。NVIDIAからLane、Karras、Ailaと呼ばれるWavefrontパストレース、またはヴァンアントワープの修士論文で最初に呼び出されたストリーミングパストレースは、GPUで...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>新しいGPU追跡アルゴリズム：Wavefrontパストレース</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461017/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_x/t8/rw/_xt8rwehj6jymumaisqg5ehgkro.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、最近リリースされたLighthouse 2プラットフォームで使用されている重要な概念について説明します</font><font style="vertical-align: inherit;">。NVIDIAからLane、Karras、Ailaと呼ばれる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wavefrontパストレース</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、または</font><font style="vertical-align: inherit;">ヴァンアントワープ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の修士論文</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">最初に呼び出されたストリーミングパストレースは、</font><font style="vertical-align: inherit;">GPUで効率的なパストレーサーを開発し、CPUで潜在的にパストレーサーを開発します。</font><font style="vertical-align: inherit;">ただし、これは非常に直観に反するため、理解するにはレイトレーシングアルゴリズムを再考する必要があります。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">占有</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パストレースアルゴリズムは驚くほど簡単で、数行の疑似コードで説明できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">vec3 <span class="hljs-title">Trace</span><span class="hljs-params">( vec3 O, vec3 D )</span>
   IntersectionData i </span>= Scene::Intersect( O, D )
   <span class="hljs-keyword">if</span> (i == NoHit) <span class="hljs-keyword">return</span> vec3( <span class="hljs-number">0</span> ) <span class="hljs-comment">// ray left the scene</span>
   <span class="hljs-keyword">if</span> (i == Light) <span class="hljs-keyword">return</span> i.material.color <span class="hljs-comment">// lights do not reflect</span>
   vec3 R, pdf = RandomDirectionOnHemisphere( i.normal ), <span class="hljs-number">1</span> / <span class="hljs-number">2</span>PI
   <span class="hljs-keyword">return</span> Trace( i.position, R ) *  i.BRDF * dot( i.normal, R ) / pdf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力は、</font><font style="vertical-align: inherit;">カメラからスクリーンピクセルを通過</font><font style="vertical-align: inherit;">する</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主光線</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。このビームでは、シーンプリミティブとの最も近い交点を決定します。交差がない場合、ビームはボイドに消えます。そうでなければ、ビームが光源に到達した場合、光源とカメラの間の光路を見つけました。他に何かが見つかった場合は、反射と再帰を実行して、反射したビームが照明の光源を見つけることを期待します。このプロセスは、シーンの表面で反射するフォトンの（リターン）パスに似ていることに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPUは、マルチスレッドモードでこのタスクを実行するように設計されています。最初は、レイトレーシングがこれに最適であるように思えるかもしれません。そこで、我々は、ピクセルのためのスレッドを作成するためのOpenCLやCUDAを使用して意図したように、各スレッドは、アルゴリズム本当に仕事のことを実行し、同時に見て、ShaderToyにいくつかの例を見てみることを十分に速くしている</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法を</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速く</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">することができます</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">され</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、トレース</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GPUで。しかし、そうであっても、問題は異なります。これらのレイトレーサーは本当に</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能な限り高速</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですか？</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/61d/07d/ce561d07daa3437927ab8ad5a6744ec9.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアルゴリズムには問題があります。一次光線は、すぐに、または1回のランダムな反射の後、または50回の反射の後に光源を見つけることができます。 CPUのプログラマは、スタックオーバーフローの可能性に気づくでしょう。 GPUプログラマーは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">占有問題</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を確認</font><em><font style="vertical-align: inherit;">する</font></em><font style="vertical-align: inherit;">必要があります</font><font style="vertical-align: inherit;">。この問題は条件付きの末尾再帰が原因で発生します。パスは光源で終了するか、継続する可能性があります。これを多くのスレッドに転送してみましょう。一部のスレッドは停止し、他の部分は引き続き機能します。いくつかの考察の後、計算を継続する必要があるいくつかのスレッドがあり、ほとんどのスレッドはこれらの最後のスレッドが機能し終わるのを待ちます。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「雇用」</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の概念</font><font style="vertical-align: inherit;">-有用な作業を実行するGPUスレッドの尺度です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
雇用問題は、SIMT GPUデバイスの実行モデルに適用されます。ストリームはグループに編成されます。たとえば、Pascal GPU（NVidia機器クラス10xx）では、32スレッドが</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワープに</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結合され</font><font style="vertical-align: inherit;">ます。ワープ内のスレッドには、共通のプログラムカウンターがあります。これらは固定ステップで実行されるため、各プログラム命令は32スレッドで同時に実行されます。 SIMTは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一命令複数スレッドの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">略で</font><font style="vertical-align: inherit;">、概念をよく説明しています。 SIMTプロセッサの場合、条件付きのコードは複雑です。これは、Voltaの公式ドキュメントに明確に示されています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/1c0/cb0/9bb1c0cb0c4916e8a7989edeb466d3dd.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIMTの条件付きコード実行。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワープの一部のスレッドに対して特定の条件が当てはまる</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><em><font style="vertical-align: inherit;">ifステートメントの</font></em><font style="vertical-align: inherit;">ブランチ</font><em><font style="vertical-align: inherit;">が</font></em><font style="vertical-align: inherit;">シリアル化されます。</font><font style="vertical-align: inherit;">「すべてのスレッドが同じことを行う」アプローチの代替手段は、「一部のスレッドが無効になる」ことです。</font><font style="vertical-align: inherit;">if-then-elseブロックでは、すべてのスレッドが条件に関して一貫性を持たない限り、ワープの平均占有率は50％になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、レイトレーサーの条件付きのコードはそれほど珍しくありません。</font><font style="vertical-align: inherit;">影の光線は、光源がシェーディングポイントの背後にない場合にのみ放出されます。異なるパスが異なるマテリアルと衝突する可能性があります。ロシアンルーレットメソッドとの統合により、パスが破壊されるか、生き残る可能性があります。</font><font style="vertical-align: inherit;">占有が非効率の主な原因になりつつあり、緊急対策なしでそれを防ぐことはそれほど容易ではないことがわかりました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーミングパストレース</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリーミングパストレースアルゴリズムは、ビジー状態の問題の根本的な原因に対処するように設計されています。</font><font style="vertical-align: inherit;">ストリーミングパストレースは、パストレースアルゴリズムを4つのステップに分割します。</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生む</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">伸ばす</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェード</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続する</font></font></strong></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ステージは個別のプログラムとして実装されます。したがって、フルパストレーサーを単一のGPUプログラム（「カーネル」、カーネル）として実行する代わりに、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4つの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コアで</font><font style="vertical-align: inherit;">作業する必要があり</font><font style="vertical-align: inherit;">ます。さらに、すぐにわかるように、これらはループで実行されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージ1（「生成」）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は一次光線の生成を担当します。これは、ピクセルの数に等しい量で光線の開始点と方向を作成する単純なコアです。このステージの出力は、大きなレイバッファーと、処理する必要があるレイの数を次のステージに通知するカウンターです。一次光線の場合、この値は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><em><font style="vertical-align: inherit;">幅に画面</font></em><font style="vertical-align: inherit;">の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高さを</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">掛けたものに等しく</font><em><font style="vertical-align: inherit;">なります</font></em><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージ2（「更新」）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは2番目のコアです。すべてのピクセルに対してステージ1が完了した後にのみ実行されます。カーネルは、手順1で生成されたバッファを読み取り、各レイとシーンを交差させます。このステージの出力は、バッファーに格納されている各レイの交差結果です。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージ3（「シェード」）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ステージ2の完了後に実行されます。ステージ2から交差の結果を受け取り、各パスのシェーディングモデルを計算します。この操作は、パスが完了したかどうかに応じて、新しい光線を生成する場合としない場合があります。新しいレイを生成するパス（パスが「拡張」）は、新しいレイ（「パスセグメント」）をバッファに書き込みます。光源を直接サンプリングするパス（「明示的に照明をサンプリングする」または「次のイベントを計算する」）は、シャドウビームを2番目のバッファーに書き込みます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージ4（「接続」）は、</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このステージ2と同様であるが、重要な違いがステージ3で生成された影光線をトレース：見つけるシャドウ必要の光線</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交差点を延びる光線は、最も近い交差点を見つける必要があります。</font><font style="vertical-align: inherit;">したがって、このために別のコアが作成されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステップ4を完了すると、パスを拡張するレイを含むバッファーが取得されます。</font><font style="vertical-align: inherit;">これらの光線を取得したら、ステップ2に進みます。拡張光線が残るか、最大反復回数に達するまで、これを続けます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非効率の原因</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パフォーマンスを懸念するプログラマーは、ストリーミングパストレースアルゴリズムのこのようなスキームで多くの危険な瞬間を目にするでしょう。</font></font><br>
<br>
<ul>
<li>        <em>    </em>,   .      ,   .</li>
<li>        .</li>
<li>CPU  ,       ,  GPU   CPU,       3.    GPU  CPU —   ,         .</li>
<li>  3    ,      ?        ?</li>
<li>     ,        ?</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後の質問から始めましょう。100万のタスクをGPUに転送しても、100万のスレッドは生成されません。同時に実行されるスレッドの本当の数は機器に依存しますが、一般的なケースでは、数万のスレッドが実行されます。負荷がこの数を下回ったときにのみ、少数のタスクによって引き起こされる雇用問題に気づくでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの問題は、バッファーの大規模なI / Oです。これは確かに困難ですが、予想されるほど深刻ではありません。データアクセスは、特にバッファへの書き込み時に非常に予測可能であるため、遅延によって問題が発生することはありません。実際、GPUは主にこのタイプのデータ処理用に開発されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPUが非常に適切に処理するもう1つの側面は、アトミックカウンターです。これは、CPUの世界で作業するプログラマにとっては非常に予想外です。</font><font style="vertical-align: inherit;">zバッファーは迅速なアクセスを必要とするため、最新のGPUでのアトミックカウンターの実装は非常に効果的です。</font><font style="vertical-align: inherit;">実際には、アトミック書き込み操作は、グローバルメモリへのキャッシュされていない書き込みと同じくらいのコストがかかります。</font><font style="vertical-align: inherit;">多くの場合、遅延はGPUでの大規模な並列実行によってマスクされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カーネルの呼び出しとカウンターの双方向データ転送の2つの質問が残っています。</font><font style="vertical-align: inherit;">後者は実際には問題であるため、別のアーキテクチャーの変更、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり永続スレッド</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が必要</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">効果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
詳細を説明する前に、波面パストレースアルゴリズムを使用することの影響について説明します。</font><font style="vertical-align: inherit;">まず、バッファについて考えてみましょう。</font><font style="vertical-align: inherit;">ステージ1のデータを出力するためのバッファが必要です。</font><font style="vertical-align: inherit;">一次光線。</font><font style="vertical-align: inherit;">各ビームに必要なもの：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイの原点：3つの浮動小数点値、つまり12バイト</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイ方向：3つの浮動小数点値、つまり12バイト</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、バッファのサイズを増やすことをお勧めします。ビームの開始と方向に16バイトを保存すると、GPUは1回の128ビット読み取り操作でそれらを読み取ることができます。別の方法としては、64ビットの読み取り操作に32ビットの操作が続き、float3を取得します。これは、ほぼ2倍の速度です。つまり、1920×1080の画面の場合、1920x1080x32 =〜64 MBになります。また、Extendカーネルによって作成された交差結果のバッファーも必要です。これは、要素ごとに別の128ビット、つまり32 MBです。さらに、「シャドウ」カーネルは最大1920×1080のパス拡張（上限）を作成できるため、読み取るバッファーにそれらを書き込むことはできません。それは別の64 MBです。最後に、パストレーサーがシャドウレイを放出する場合、これはもう1つの64 MBバッファーです。すべてを合計すると、224 MBのデータが得られますが、これは波面アルゴリズムの場合のみです。または、4K解像度で約1 GB。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、別の機能に慣れる必要があります。十分なメモリがあります。思われるかもしれません。その1 GBはたくさんあり、この数を減らす方法がありますが、これに現実的に近づくと、4Kでパスをトレースする必要があるときまでに、8 GBのGPUで1 GBを使用することで問題が少なくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリ要件よりも深刻なのは、レンダリングアルゴリズムの結果です。</font><font style="vertical-align: inherit;">これまでのところ、Shadowコアのスレッドごとに1つの拡張レイと、場合によっては1つのシャドウレイを生成する必要があることを示唆しました。</font><font style="vertical-align: inherit;">しかし、ピクセルごとに16本の光線を使用してアンビエントオクルージョンを実行したい場合はどうでしょうか。</font><font style="vertical-align: inherit;">16個のAOレイはバッファに格納する必要がありますが、さらに悪いことに、次の反復でのみ表示されます。</font><font style="vertical-align: inherit;">Whitedスタイルで光線を追跡するときにも同様の問題が発生します。複数の光源に対してシャドウビームを放射したり、ガラスとの衝突でビームを分割したりすることはほとんど不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、波面パストレースは、占有セクションにリストした問題を解決します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージ1では、条件のないすべてのフローが1次光線を作成し、それらをバッファーに書き込みます。</font></font></li>
<li>  2              .</li>
<li>  3        100%.</li>
<li>  4        . </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2セグメントの長さの残存光線でステージ2に戻るときまでに、カーネルが開始したときに完全な使用を保証するコンパクトな光線バッファーが再び得られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、過小評価してはならない追加の利点があります。コードは4つのステップで分離されます。各コアは、他のコアを考慮せずに、使用可能なすべてのGPUリソ​​ース（キャッシュ、共有メモリ、レジスタ）を使用できます。これにより、GPUがシーンとの交差コードをより多くのスレッドで実行できるようになる場合があります。これは、このコードがシェーダーコードほど多くのレジスターを必要としないためです。スレッドが多いほど、遅延を隠すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フルタイムの強化された遅延マスキング、ストリーミングレコーディング：これらのメリットはすべて、GPUプラットフォームの出現と性質に直接関係しています。</font><font style="vertical-align: inherit;">GPUの場合、波面パストレースアルゴリズムは非常に自然です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その価値はありますか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、私たちには質問があります：最適化された雇用は、バッファーからのI / Oと追加のコアを呼び出すコストを正当化しますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
答えはイエスですが、これを証明するのは簡単ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ShaderToyでパストレーサーに1秒間戻ると、それらのほとんどがシンプルでハードコーディングされたシーンを使用していることがわかります。それを本格的なシーンに置き換えることは簡単な作業ではありません。何百万ものプリミティブの場合、ビームとシーンの交差が複雑な問題になり、その解決策はNVidia（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、AMD（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Radeon-Rays</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）またはIntel（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Embree</font></a><font style="vertical-align: inherit;">）に</font><font style="vertical-align: inherit;">残されます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）これらのオプションはどれも、CUDA人工レイトレーサーでハードコードされたシーンを簡単に置き換えることができません。 CUDAでは、最も近いアナログ（Optix）はプログラムの実行を制御する必要があります。 Embree in the CPUを使用すると、独自のコードから個々のビームをトレースできますが、これによりパフォーマンスのオーバーヘッドが大幅に増加します。彼は、個々のビームではなく、大きなビームグループをトレースすることを好みます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb4/2a2/409/fb42a240924ba04871abb70421d16cdf.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旅団1を使用してレンダリングから画面「それは時間だ」</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
（レーンや同僚はそれを呼び出すよう、megakernel）速くその代替よりもパストレースを波面のでしょうが、核内に費やした時間（大きなシーンで高価に依存しますシェーダーは、波面アルゴリズムによる相対コストオーバーランを、最大パス長、メガジョン占有率、および4つのステージでのレジスターの負荷の差から削減します。</font><font style="vertical-align: inherit;">元の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brigade Path Tracerの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期バージョンでは</font><font style="vertical-align: inherit;">、GTX480で反射面とランバート面が混在している単純なシーンでも、波面を使用することでメリットが得られることがわかりました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lighthouse 2のストリーミングパストレース</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lighthouse 2プラットフォームには、2つの波面パストレーシングトレーサーがあります。最初のものは、ステージ2と4（光線とシーンの交差のステージ）の実装にOptix Primeを使用します。 2つ目はOptixを直接使用してその機能を実装します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Optix Primeは、一連の光線と三角形で構成されるシーンの交差のみを処理するOptixの簡易バージョンです。完全なOptixライブラリとは異なり、カスタム交差コードをサポートせず、三角形のみを交差します。ただし、これはまさに波面パストレーサーに必要なものです。</font><font style="vertical-align: inherit;">プロジェクトに</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装されたOptix Primeベースの波面パストレーサー</font><font style="vertical-align: inherit;">。 Optix Primeの初期化は関数</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">始まり、</font><font style="vertical-align: inherit;">を使用し</font><font style="vertical-align: inherit;">ます。シーンは、</font></font><code>rendercore.cpp</code><font style="vertical-align: inherit;"></font><code>rendercore_optixprime_b</code><font style="vertical-align: inherit;"></font><code>Init</code><font style="vertical-align: inherit;"></font><code>rtpContextCreate</code><font style="vertical-align: inherit;"></font><code>rtpModelCreate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。関数</font></font><code>SetTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">して、さまざまなレイバッファが作成されます</font></font><code>rtpBufferDescCreate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これらのバッファーについては、通常のデバイスポインターを提供することに注意してください。つまり、これらのバッファーはOptixと通常のCUDAコアの両方で使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レンダリングはメソッドから始まり</font></font><code>Render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。プライマリレイバッファーを満たすために、CUDAコアが呼び出され</font></font><code>generateEyeRays</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。バッファーを満たした後、</font></font><code>rtpQueryExecute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optix Primeが呼び出されます。これにより、交差結果がに書き込まれ</font></font><code>extensionHitBuffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。すべてのバッファーがGPUに残っていることに注意してください。カーネル呼び出しを除いて、CPUとGPUの間にトラフィックはありません。シャドウフェーズは、通常のCUDAコアに実装されてい</font></font><code>shade</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。その実装はにあり</font></font><code>pathtracer.cu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの実装の詳細</font></font><code>optixprime_b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言及する価値があります。まず、シャドウレイは波面サイクルの外側でトレースされます。これは正しいです。シャドウレイは、ブロックされていない場合にのみピクセルに影響しますが、他のすべての場合では、その結果は他のどこにも必要ありません。つまり、シャドウビームは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使い捨てで</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、いつでも任意の順序で追跡できます。今回のケースでは、最終的に追跡されるバッチができるだけ大きくなるように、影の光線をグループ化してこれを使用します。これには1つの不愉快な結果があります。</font><font style="vertical-align: inherit;">波面アルゴリズムの</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回の反復と</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X個の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1次光線では、影光線の数の上限は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XNに</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等しくなり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの詳細は、さまざまなカウンターの処理です。</font><font style="vertical-align: inherit;">「更新」および「シャドウ」のステージでは、アクティブなパスの数を把握する必要があります。</font><font style="vertical-align: inherit;">このためのカウンターはGPUで（原子的に）更新されます。つまり、CPUに戻らなくてもGPUで使用されます。</font><font style="vertical-align: inherit;">残念ながら、これは不可能です。OptixPrimeライブラリは、追跡される光線の数を知る必要があります。</font><font style="vertical-align: inherit;">これを行うには、繰り返しのたびにカウンターの情報を返す必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、波面パストレースとは何か、およびGPUでパストレースを効果的に実行する必要がある理由について説明します。</font><font style="vertical-align: inherit;">その実用的な実装は、オープンソース</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でGithub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">利用可能な</font></a><font style="vertical-align: inherit;"> Lighthouse 2プラットフォームで</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">提供され</font></a><font style="vertical-align: inherit;">ます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja461003/index.html">分析：取引所の高頻度取引市場の仕組み</a></li>
<li><a href="../ja461005/index.html">会社のテスト：面接で適切な質問をする</a></li>
<li><a href="../ja461009/index.html">10日で標準を作成する方法。二部。退屈な</a></li>
<li><a href="../ja461013/index.html">インターネット接続の予約</a></li>
<li><a href="../ja461015/index.html">生活し、学びます。パート2.大学：5年または5つの廊下？</a></li>
<li><a href="../ja461019/index.html">イランの開発者の生活はどうですか</a></li>
<li><a href="../ja461027/index.html">スクリプトエンジンではないJava REPL</a></li>
<li><a href="../ja461029/index.html">マーケティングデータの湖-巨大なテーブルからレポートや視覚化まで</a></li>
<li><a href="../ja461031/index.html">オンライン地図をスマートフォンのナビゲーターに接続します。パート1-標準ラスターマップ</a></li>
<li><a href="../ja461033/index.html">この構成はどこから来たのですか？[Debian / Ubuntu]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>