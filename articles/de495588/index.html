<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêµ üë®üèΩ‚Äçü§ù‚Äçüë®üèº üë®‚Äçüë©‚Äçüë¶‚Äçüë¶ Roguelike in Unity von Grund auf neu erstellen: Dungeon-Generator üëû üë®üèº‚Äçüöí üßíüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieses Mal werden wir uns mit der Implementierung des Algorithmus des Dungeongenerators befassen. Im letzten Artikel haben wir den ersten Raum erstell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Roguelike in Unity von Grund auf neu erstellen: Dungeon-Generator</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Mal werden wir uns mit der Implementierung des Algorithmus des Dungeongenerators befassen. Im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">letzten Artikel haben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir den ersten Raum erstellt und jetzt werden wir den Rest des Dungeon-Levels generieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber bevor wir anfangen, m√∂chte ich einen Fehler aus einem fr√ºheren Beitrag beheben. Tats√§chlich habe ich in den letzten Wochen etwas Neues gelernt, weshalb einige meiner Arbeiten veraltet sind und ich dar√ºber sprechen m√∂chte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnerst du dich an die Positionsklasse, die wir erstellt haben? Tats√§chlich verf√ºgt Unity bereits √ºber eine integrierte Klasse, die genau dieselben Funktionen ausf√ºhrt, jedoch mit etwas besserer Kontrolle - es ist einfacher zu deklarieren und zu verarbeiten. Diese Klasse hei√üt Vector2Int. Daher entfernen wir vor dem Start die Positionsklasse aus MapManager.cs und ersetzen jede Positionsvariable durch die Vector2Int-Variable.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/b7d/f40/656b7df4053976af99cbd2d359edd494.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dasselbe muss an mehreren Stellen im Skript DungeonGenerator.cs ausgef√ºhrt werden. </font><font style="vertical-align: inherit;">Kommen wir nun zum Rest des Algorithmus.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe 7 - Raum- / Hallengenerierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir beginnen mit einer kleinen √Ñnderung der zuletzt erstellten Funktion FirstRoom (). </font><font style="vertical-align: inherit;">Anstatt eine andere Funktion zu erstellen, um alle anderen Elemente der Karte zu generieren und eine Menge Code zu duplizieren, transformieren wir diese Funktion einfach und verwandeln sie in eine verallgemeinerte GenerateFeature (). </font><font style="vertical-align: inherit;">√Ñndern Sie daher den Namen von FirstRoom in GenerateFeature. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt m√ºssen wir Parameter an diese Funktion √ºbergeben. </font><font style="vertical-align: inherit;">Zun√§chst m√ºssen Sie wissen, welche Funktion es erzeugt - einen Raum oder einen Korridor. </font><font style="vertical-align: inherit;">Wir k√∂nnen einfach eine Zeichenfolge namens </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type √ºbergeben</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Als n√§chstes muss die Funktion den Startpunkt des Elements kennen, dh von welcher Wand es kommt (weil wir immer ein neues Element aus der Wand des √§lteren Elements erstellen), und daf√ºr reicht es aus, als Wall-Argument zu √ºbergeben. </font><font style="vertical-align: inherit;">Schlie√ülich weist der erste zu erstellende Raum spezielle Merkmale auf, sodass wir eine optionale Bool-Variable ben√∂tigen, die angibt, ob das Element der erste Raum ist. </font><font style="vertical-align: inherit;">Standardm√§√üig ist es false: bool isFirst = false. </font><font style="vertical-align: inherit;">Der Funktionstitel √§ndert sich also wie folgt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/b79/d17/e5fb79d178098b3bcde238ff733f9ca9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
auf das:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45e/124/afc/45e124afc4b4f60b12ab18deaa060719.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fein. </font><font style="vertical-align: inherit;">Der n√§chste Schritt besteht darin, die Art und Weise zu √§ndern, in der Sie die Breite und H√∂he des Elements berechnen. </font><font style="vertical-align: inherit;">W√§hrend wir sie berechnen, erhalten wir einen zuf√§lligen Wert zwischen den Min- und Max-Werten der H√∂he und Breite der R√§ume - dies ist ideal f√ºr R√§ume, funktioniert jedoch nicht f√ºr Korridore. </font><font style="vertical-align: inherit;">Bisher haben wir also Folgendes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f5/c0d/976/2f5c0d9765a596c2d2188b56b1f7b7ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Korridore haben jedoch je nach Ausrichtung eine konstante Gr√∂√üe von 3 in Breite oder H√∂he. </font><font style="vertical-align: inherit;">Daher m√ºssen wir √ºberpr√ºfen, was das Element ist - ein Raum oder ein Korridor - und dann die entsprechenden Berechnungen durchf√ºhren.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/163/df8/071163df82fc248fc92d370672369743.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit. </font><font style="vertical-align: inherit;">Wir pr√ºfen, ob es sich bei dem Artikel um ein Zimmer handelt. </font><font style="vertical-align: inherit;">Wenn ja, dann machen wir dasselbe wie zuvor </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - wir erhalten eine Zufallszahl im Intervall zwischen min und max von H√∂he und Breite. </font><font style="vertical-align: inherit;">Aber jetzt in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sonst</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gleich, wenn Sie etwas anderes machen m√ºssen. </font><font style="vertical-align: inherit;">Wir m√ºssen die Ausrichtung des Korridors √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Gl√ºcklicherweise speichern wir beim Generieren einer Wand Informationen dar√ºber, in welche Richtung sie gerichtet ist, und verwenden sie, um die Ausrichtung des Korridors zu ermitteln.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91a/a84/328/91aa84328140d1414b8512843e1cd397.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Variable minCorridorLength haben wir jedoch noch nicht deklariert. </font><font style="vertical-align: inherit;">Sie m√ºssen zu Variablendeklarationen zur√ºckkehren und diese direkt √ºber maxCorridorLength deklarieren.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/857/6e1/f138576e1dc1cb4a9949fd51e8c5fe47.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun zur√ºck zu unseren bedingten switch-Anweisungen. </font><font style="vertical-align: inherit;">Was wir hier tun: Wir erhalten den Wert der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtung der</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wand, dh wohin die Wand schaut, von der aus der Korridor verl√§uft. </font><font style="vertical-align: inherit;">Die Richtung kann nur vier m√∂gliche Werte haben: S√ºd, Nord, West und Ost. </font><font style="vertical-align: inherit;">Im Fall von S√ºd und Nord hat der Korridor eine Breite von 3 (zwei W√§nde und ein Boden in der Mitte) und eine variable H√∂he (L√§nge). </font><font style="vertical-align: inherit;">F√ºr West und Ost ist alles umgekehrt: Die H√∂he betr√§gt immer 3, und die Breite hat eine variable L√§nge. </font><font style="vertical-align: inherit;">Also machen wir's.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e2/175/8d6/0e21758d6d2e17406ce516c3fef6ccf5.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beeindruckend. </font><font style="vertical-align: inherit;">Und hier haben wir die Gr√∂√üe des neuen Artikels festgelegt. </font><font style="vertical-align: inherit;">Jetzt m√ºssen Sie entscheiden, wo Sie es platzieren m√∂chten. </font><font style="vertical-align: inherit;">Wir haben den ersten Raum an einer zuf√§lligen Stelle innerhalb der Schwellenwerte relativ zur Kartenmitte platziert.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fb/d53/010/6fbd5301066f6b0ba77ab90142370a5d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei allen anderen Elementen funktioniert dies jedoch nicht. Sie sollten neben dem zuf√§lligen Punkt an der Wand beginnen, von dem aus das Element generiert wird. √Ñndern wir also den Code. Zuerst m√ºssen wir pr√ºfen, ob das Element der erste Raum ist. Wenn dies der erste Raum ist, definieren wir die Startpunkte auf die gleiche Weise wie zuvor - als die halbe Breite und H√∂he der Karte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d29/44d/ff3d2944da973a48200a6c9c3066d20d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn das Element nicht der erste Raum ist, dann bekommen wir einen beliebigen Punkt an der Wand , </font><font style="vertical-align: inherit;">aus dem das Element erzeugt wird. Zuerst m√ºssen wir √ºberpr√ºfen, ob die Wand eine Gr√∂√üe von 3 hat (dies bedeutet, dass es der Endpunkt des Korridors ist), und wenn ja, wird immer der Mittelpunkt ausgew√§hlt, dh Index 1 des Wandarrays (mit 3 Elementen hat das Array Indizes 0, 1, 2). Wenn die Gr√∂√üe jedoch nicht gleich 3 ist (die Wand ist nicht der Endpunkt des Korridors), nehmen wir einen zuf√§lligen Punkt im Intervall zwischen Punkt 1 und der L√§nge der Wand minus 2. Dies ist erforderlich, um Passagen in der Ecke zu vermeiden. Das hei√üt, an einer Wand mit einer L√§nge von 6 schlie√üen wir die Indizes 0 und 5 (erste und letzte) aus und w√§hlen einen zuf√§lligen Punkt unter den Punkten 1, 2, 3 und 4 aus.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/4e1/703/ee24e1703c28b4cfa96e98d84a76c790.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir die Position des Punktes an der Wand, an dem ein neues Element erstellt wird. Wir k√∂nnen aber nicht einfach von dort aus ein Element erzeugen, da es auf diese Weise durch bereits platzierte W√§nde blockiert wird. Es ist auch wichtig zu beachten, dass das Element von seiner unteren linken Ecke aus erzeugt wird und dann das Inkrement nach rechts und oben ausgef√ºhrt wird. Daher m√ºssen wir die Anfangsposition an verschiedenen Stellen festlegen, abh√§ngig von der Richtung, in die die Wand schaut. Au√üerdem sind die erste Spalte x und die erste Zeile y W√§nde. Wenn wir ein neues Element direkt neben einem Punkt an der Wand beginnen, k√∂nnen wir einen Korridor erstellen, der in einer Ecke des Raums und nicht an einer geeigneten Stelle an der Wand endet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Wand nach Norden gerichtet ist, muss das Element an einer Position im Norden entlang der y-Achse beginnen, jedoch an einer zuf√§lligen Anzahl von Positionen im Westen entlang der x-Achse im Bereich von 1 bis zur Breite des Raums 2. </font><font style="vertical-align: inherit;">In s√ºdlicher Richtung verh√§lt sich die x-Achse gleich, aber die Startposition auf der y-Achse ist die Position des Punkts an der Wand abz√ºglich der Raumh√∂he. </font><font style="vertical-align: inherit;">Die West- und Ostwand folgen der gleichen Logik, nur mit umgekehrten Achsen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir dies alles tun, m√ºssen wir die Position des Wandpunkts in der Variablen Vector2Int speichern, damit wir ihn sp√§ter bearbeiten k√∂nnen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/129/41a/37412941a3a58f32fd2dd38c1fc2c252.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gro√üartig. </font><font style="vertical-align: inherit;">Lass uns das tun.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/2c7/ec0/1402c7ec0596d77f9a9b70b5eac076a9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also haben wir ein Element mit der Gr√∂√üe und Position generiert. Der n√§chste Schritt besteht darin, das Element auf der Karte zu platzieren. </font><font style="vertical-align: inherit;">Aber zuerst m√ºssen wir herausfinden, ob auf der Karte wirklich Platz f√ºr dieses Element an dieser Position ist. </font><font style="vertical-align: inherit;">Im Moment rufen wir einfach die Funktion CheckIfHasSpace () auf. </font><font style="vertical-align: inherit;">Es wird rot hervorgehoben, da wir es noch nicht implementiert haben. </font><font style="vertical-align: inherit;">Wir werden dies direkt tun, nachdem wir fertig sind, was hier in der GenerateFeature () -Funktion getan werden muss. </font><font style="vertical-align: inherit;">Ignorieren Sie daher die rote Unterstreichung und fahren Sie fort.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/805/942/b2080594237c23cae023cabb20b2d20e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im n√§chsten Teil werden W√§nde erstellt. </font><font style="vertical-align: inherit;">Bis wir es ber√ºhren, mit Ausnahme des Fragments in der zweiten </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schleife </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/d7f/e2b/227d7fe2bf3c2eef41f423e36b4afc79.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Schreiben dieses Beitrags habe ich festgestellt, dass diese if-else-Konstrukte v√∂llig falsch sind. Zum Beispiel erhalten einige W√§nde in ihnen eine L√§nge von 1. Dies geschieht, weil, wenn die Position beispielsweise zur Nordwand hinzugef√ºgt werden soll, wenn sie sich an der Ecke mit der Ostwand befindet, sie nicht wie gew√ºnscht zur Ostwand hinzugef√ºgt wird. Dies verursachte st√∂rende Fehler im Generierungsalgorithmus. Lassen Sie uns sie beseitigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie zu reparieren ist ziemlich einfach. Es reicht aus, alles </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu l√∂schen </font><em><font style="vertical-align: inherit;">,</font></em><font style="vertical-align: inherit;"> damit die Position alle </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstrukte durchl√§uft </font><font style="vertical-align: inherit;">und nicht beim ersten Mal stoppt, wenn sie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true zur√ºckgibt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dann wird das letzte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (das, das nicht </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anders ist, wenn</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in </font><em><font style="vertical-align: inherit;">if</font></em><font style="vertical-align: inherit;"> ge√§ndert</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hiermit wird √ºberpr√ºft, ob die Position bereits als Wand hinzugef√ºgt wurde. Wenn dies nicht der Fall ist, wird sie als Boden hinzugef√ºgt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/784/834/65c784834461a2d8b05d1d39dd9ee44c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstaunlich, wir sind hier fast fertig. </font><font style="vertical-align: inherit;">Jetzt haben wir ein v√∂llig neues Element, das an der richtigen Stelle erstellt wurde, aber es ist dasselbe wie unser erster Raum: Es ist vollst√§ndig von W√§nden umgeben. </font><font style="vertical-align: inherit;">Dies bedeutet, dass der Spieler diesen neuen Ort nicht erreichen kann. </font><font style="vertical-align: inherit;">Das hei√üt, wir m√ºssen einen Punkt an der Wand (der, wie wir uns erinnern, in einer Variablen vom Typ Vector2Int gespeichert ist) und den entsprechenden Punkt an der Wand eines neuen Elements in Floor konvertieren. </font><font style="vertical-align: inherit;">Aber nur wenn das Element nicht der erste Raum ist.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/350/67f/5ac/35067f5ac7db26fd304578b8dd53326c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code √ºberpr√ºft, ob der neue Artikel der erste Raum ist. </font><font style="vertical-align: inherit;">Wenn nicht, konvertiert es die letzte Position der Wand in den Boden und √ºberpr√ºft dann die Richtung, in die die Wand schaut, um zu √ºberpr√ºfen, welche Fliese des neuen Elements in den Boden verwandelt werden soll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den letzten Teil der Funktion GenerateFeature () erreicht. </font><font style="vertical-align: inherit;">Es enth√§lt bereits Zeilen, die Informationen zu dem von der Funktion erstellten Element hinzuf√ºgen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/165/626/4fe165626aca42951f86568a4d6649c7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier m√ºssen wir etwas √§ndern. </font><font style="vertical-align: inherit;">Erstens ist der Elementtyp nicht immer gleich Raum. </font><font style="vertical-align: inherit;">Gl√ºcklicherweise wird die erforderliche Variable als Parameter an die Funktion √ºbergeben, n√§mlich als Typzeichenfolge. </font><font style="vertical-align: inherit;">Ersetzen wir hier also einfach "Raum" durch Typ.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b57/d12/f17/b57d12f17802ec40e0c609d26803f661.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gut. </font><font style="vertical-align: inherit;">Damit der Algorithmus, der alle Elemente des Spiels generiert, ordnungsgem√§√ü funktioniert, m√ºssen wir hier neue Daten hinzuf√ºgen. </font><font style="vertical-align: inherit;">Ein int, das die Anzahl der erstellten Elemente und eine Liste aller erstellten Elemente z√§hlt. </font><font style="vertical-align: inherit;">Wir gehen zu der Stelle, an der wir alle Variablen deklarieren und ein int mit dem Namen countFeatures sowie eine Liste von Elementen mit dem Namen allFeatures deklarieren. </font><font style="vertical-align: inherit;">Die Liste aller Elemente muss √∂ffentlich sein, und der int-Z√§hler kann privat sein.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/ebf/8dd/bcbebf8ddbc768864ba70331317cc72c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kehren Sie nun zur Funktion GenerateFeature () zur√ºck und f√ºgen Sie am Ende einige Zeilen hinzu: Inkrementieren der Variablen countFeatures und Hinzuf√ºgen eines neuen Elements zur Liste allFeatures.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/8a8/496/5e68a8496d7047c87650a609acb912cf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser GenerateFeature () ist also fast vollst√§ndig. </font><font style="vertical-align: inherit;">Sp√§ter m√ºssen wir darauf zur√ºckgreifen, um die leere CheckIfHasSpace-Funktion auszuf√ºllen, aber zuerst m√ºssen wir sie erstellen. </font><font style="vertical-align: inherit;">Das machen wir jetzt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe 8 - √úberpr√ºfen Sie, ob es einen Platz gibt</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt erstellen wir eine neue Funktion direkt nach Abschluss der GenerateFeature () -Funktion. Sie braucht zwei Argumente: die Position, an der das Element beginnt, und die Position, an der es endet. Sie k√∂nnen zwei Vector2Int-Variablen als diese verwenden. Die Funktion sollte einen Bool-Wert zur√ºckgeben, damit er verwendet werden kann, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nach Speicherplatz gesucht wird.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/998/f03/cad/998f03cad9a6bd8a05bd7d8b9658bad6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist rot unterstrichen, da es bisher nichts zur√ºckgegeben hat. Bald werden wir es reparieren, aber im Moment werden wir nicht darauf achten. In dieser Funktion durchlaufen wir alle Positionen zwischen dem Anfang und dem Ende des Elements und pr√ºfen, ob die aktuelle Position in MapManager.map null ist oder bereits etwas vorhanden ist. Wenn dort etwas ist, stoppen wir die Funktion und geben false zur√ºck. Wenn nicht, fahren Sie fort. Wenn die Funktion das Ende der Schleife erreicht, ohne die gef√ºllten Stellen zu treffen, geben Sie true zur√ºck. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir die Position auf Null √ºberpr√ºfen, ben√∂tigen wir au√üerdem eine Linie, um zu √ºberpr√ºfen, ob sich die Position innerhalb der Karte befindet. Andernfalls kann es zu einem Array-Indexfehler und einem Spielabsturz kommen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/473/582/a5b/473582a5b560d6738de08b2f6190cf6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fein. </font><font style="vertical-align: inherit;">Nun zur√ºck zu der Stelle, an der wir diese Funktion in die GenerateFeature () -Funktion einf√ºgen. </font><font style="vertical-align: inherit;">Wir m√ºssen diesen Aufruf beheben, da er nicht die erforderlichen Argumente √ºbergibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier m√∂chten wir eine </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if-Anweisung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einf√ºgen </font><font style="vertical-align: inherit;">, um zu √ºberpr√ºfen, ob gen√ºgend Platz f√ºr das Element vorhanden ist. </font><font style="vertical-align: inherit;">Wenn das Ergebnis falsch ist, beenden wir die Funktion, ohne ein neues Element in MapManager.map einzuf√ºgen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/068/661/e53/068661e533ef21536a51f17ae3de570b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir m√ºssen die erforderlichen Argumente √ºbergeben, dh zwei Vector2Int-Variablen. </font><font style="vertical-align: inherit;">Beim ersten ist alles einfach, dies ist die Position mit den x- und y-Koordinaten des Startpunkts des Elements.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/869/26d/0c186926d741d2423c791500adbed2cd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite ist schwieriger, aber nicht viel. </font><font style="vertical-align: inherit;">Dies ist der Startpunkt plus H√∂he f√ºr y und Breite f√ºr x, wobei 1 von beiden abgezogen wird (da der Start bereits ber√ºcksichtigt wurde).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a18/f85/4a9/a18f854a9e0a0bbe5883012bf2e313ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fahren wir nun mit dem n√§chsten Schritt fort: Erstellen eines Algorithmus zum Aufrufen der Funktion GenerateFeature ().</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe 9 - Generierte Elemente aufrufen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur√ºck zur GenerateDungeon () -Funktion, die im vorherigen Teil des Artikels erstellt wurde. </font><font style="vertical-align: inherit;">Jetzt sollte es so aussehen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/57c/5e3/3e957c5e316f5329e935353e961df47b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Aufruf von FirstRoom () ist rot unterstrichen, da wir den Namen dieser Funktion ge√§ndert haben. </font><font style="vertical-align: inherit;">Nennen wir einfach die erste Raumgeneration.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d6/926/908/8d692690826997750f3bc860ae9216f0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben die erforderlichen Argumente √ºbergeben: "Raum" als Typ, da der erste Raum immer Raum, neue Wand () sein wird, weil der erste Raum nicht aus einem anderen erstellt wird, also √ºbergeben wir einfach null, und das ist ganz normal. Anstelle von new Wall () k√∂nnen Sie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ersetzen </font><font style="vertical-align: inherit;">. Dies ist eine Frage der pers√∂nlichen Pr√§ferenz. Das letzte Argument bestimmt, ob das neue Element der erste Raum ist. In unserem Fall √ºbergeben wir also </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun kommen wir zum Hauptpunkt. Wir verwenden eine for-Schleife, die 500 Mal ausgef√ºhrt wird - ja, wir werden versuchen, Elemente 500 Mal hinzuzuf√ºgen. Wenn jedoch die Anzahl der erstellten Elemente (Variable countFeatures) der maximal angegebenen Anzahl von Elementen (Variable maxFeatures) entspricht, unterbrechen wir diesen Zyklus.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e6/410/ded/9e6410ded47210776fcda40ae2492229.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Schritt in dieser Schleife besteht darin, das Element zu deklarieren, aus dem das neue Element erstellt wird. </font><font style="vertical-align: inherit;">Wenn wir nur ein Element erstellt haben (den ersten Raum), ist es das urspr√ºngliche. </font><font style="vertical-align: inherit;">Andernfalls w√§hlen wir zuf√§llig eines der bereits erstellten Elemente aus.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddb/e84/f92/ddbe84f92cbb06f56e3ccce561dde991.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun w√§hlen wir aus, an welcher Wand dieses Elements das neue Element erstellt werden soll.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/e7c/0e4/7ade7c0e438985098eed6f5dbdd42e6d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass wir diese ChoseWall () -Funktion noch nicht haben. </font><font style="vertical-align: inherit;">Lass es uns schnell schreiben. </font><font style="vertical-align: inherit;">Gehen Sie zum Ende der Funktion und erstellen Sie sie. </font><font style="vertical-align: inherit;">Es sollte eine Wand zur√ºckgeben und ein Element als Argument verwenden, damit die Funktion die Wand dieses Elements ausw√§hlen kann.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aeb/631/9f1/aeb6319f1ee6f601474d0aa0e32e2c77.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe es zwischen den Funktionen CheckIfHasSpace () und DrawMap () erstellt. </font><font style="vertical-align: inherit;">Beachten Sie, dass Sie bei der Arbeit in Visual Studio, das mit Unity installiert ist, die Felder - / + links verwenden k√∂nnen, um Teile des Codes zu reduzieren / zu erweitern und die Arbeit zu vereinfachen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dieser Funktion finden wir die Wand, aus der das Element noch nicht erstellt wurde. </font><font style="vertical-align: inherit;">Manchmal erhalten wir Elemente mit einer oder mehreren W√§nden, an denen bereits andere Elemente angebracht sind. Daher m√ºssen wir immer wieder √ºberpr√ºfen, ob eine der zuf√§lligen W√§nde frei ist. </font><font style="vertical-align: inherit;">Dazu verwenden wir eine zehnmal wiederholte for-Schleife. Wenn nach diesen zehnmal keine freie Wand gefunden wird, gibt die Funktion null zur√ºck.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/44a/028/b1044a028bf9ab566a0120690311396d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kehren Sie nun zur Funktion GenerateDungeon () zur√ºck und √ºbergeben Sie das urspr√ºngliche Element als Parameter an die Funktion ChoseWall ().</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/281/8aa/0a32818aafc77ddd87f1ffac21b6981e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Zeile </font></font><code>if (wall == null) continue;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet, dass das urspr√ºngliche Element kein neues Element generieren kann, wenn die Wandsuchfunktion false zur√ºckgegeben hat. Daher setzt die Funktion </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zyklus fort, dh sie konnte kein neues Element erstellen und f√§hrt mit der n√§chsten Iteration des Zyklus fort. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt m√ºssen wir den Typ f√ºr das n√§chste Element ausw√§hlen. </font><font style="vertical-align: inherit;">Wenn das Quellelement ein Raum ist, muss das n√§chste ein Korridor sein (wir m√∂chten nicht, dass der Raum direkt zu einem anderen Raum ohne einen Korridor zwischen ihnen f√ºhrt). </font><font style="vertical-align: inherit;">Wenn dies jedoch ein Korridor ist, m√ºssen wir die Wahrscheinlichkeit schaffen, dass ein weiterer Korridor oder Raum als n√§chstes kommt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b22/df0/954/b22df0954bbe21d82506d42e5118a70f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fein. </font><font style="vertical-align: inherit;">Jetzt m√ºssen wir nur noch die GenerateFeature () -Funktion aufrufen, die Wand √ºbergeben und als Parameter eingeben.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a07/90b/834/a0790b83479f46dc17c57fbb981aef81.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wechseln Sie schlie√ülich zum Unity-Inspektor, w√§hlen Sie das GameManager-Objekt aus und √§ndern Sie die Werte wie folgt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cc/09c/786/9cc09c786641bf85a89674cc33042ebf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie jetzt auf die Wiedergabetaste klicken, sehen Sie bereits die Ergebnisse!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie gesagt, dies ist nicht der beste Dungeon. </font><font style="vertical-align: inherit;">Wir haben viele Sackgassen. </font><font style="vertical-align: inherit;">Aber es ist voll funktionsf√§hig und garantiert, dass Sie keinen Raum haben, der mit keinem anderen verbunden ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, dass es Ihnen gefallen hat! </font><font style="vertical-align: inherit;">Im n√§chsten Beitrag erstellen wir einen Spieler, der sich durch den Dungeon bewegt, und verwandeln dann die Karte von ASCII in Sprite.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.UI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Post3</span> : <span class="hljs-title">MonoBehaviour</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapWidth;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapHeight;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMaxRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMaxRoom;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> minCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxFeatures;
    <span class="hljs-keyword">int</span> countFeatures;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isASCII;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> List&lt;Feature&gt; allFeatures;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        MapManager.map = <span class="hljs-keyword">new</span> Tile[mapWidth, mapHeight];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GenerateDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        GenerateFeature(<span class="hljs-string">"Room"</span>, <span class="hljs-keyword">new</span> Wall(), <span class="hljs-literal">true</span>);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) {<font></font>
            Feature originFeature;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (allFeatures.Count == <span class="hljs-number">1</span>) {<font></font>
                originFeature = allFeatures[<span class="hljs-number">0</span>];<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {<font></font>
                originFeature = allFeatures[Random.Range(<span class="hljs-number">0</span>, allFeatures.Count - <span class="hljs-number">1</span>)];<font></font>
            }<font></font>
<font></font>
            Wall wall = ChoseWall(originFeature);<font></font>
            <span class="hljs-keyword">if</span> (wall == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
            <span class="hljs-keyword">string</span> type;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (originFeature.type == <span class="hljs-string">"Room"</span>) {<font></font>
                type = <span class="hljs-string">"Corridor"</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) &lt; <span class="hljs-number">90</span>) {<font></font>
                    type = <span class="hljs-string">"Room"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                    type = <span class="hljs-string">"Corridor"</span>;<font></font>
                }<font></font>
            }<font></font>
<font></font>
            GenerateFeature(type, wall);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (countFeatures &gt;= maxFeatures) <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
<font></font>
        DrawMap(isASCII);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GenerateFeature</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> type, Wall wall, <span class="hljs-keyword">bool</span> isFirst = <span class="hljs-literal">false</span></span>)</span> {<font></font>
        Feature room = <span class="hljs-keyword">new</span> Feature();<font></font>
        room.positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
<font></font>
        <span class="hljs-keyword">int</span> roomWidth = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> roomHeight = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) {<font></font>
            roomWidth = Random.Range(widthMinRoom, widthMaxRoom);<font></font>
            roomHeight = Random.Range(heightMinRoom, heightMaxRoom);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">int</span> xStartingPoint;
        <span class="hljs-keyword">int</span> yStartingPoint;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint = mapWidth / <span class="hljs-number">2</span>;<font></font>
            yStartingPoint = mapHeight / <span class="hljs-number">2</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">int</span> id;
            <span class="hljs-keyword">if</span> (wall.positions.Count == <span class="hljs-number">3</span>) id = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> id = Random.Range(<span class="hljs-number">1</span>, wall.positions.Count - <span class="hljs-number">2</span>);<font></font>
<font></font>
            xStartingPoint = wall.positions[id].x;<font></font>
            yStartingPoint = wall.positions[id].y;<font></font>
        }<font></font>
<font></font>
        Vector2Int lastWallPosition = <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth);<font></font>
            yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint ++;<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    xStartingPoint -= roomWidth;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    xStartingPoint++;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
         <span class="hljs-keyword">if</span> (!CheckIfHasSpace(<span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint), <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint + roomWidth - <span class="hljs-number">1</span>, yStartingPoint + roomHeight - <span class="hljs-number">1</span>))) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        room.walls = <span class="hljs-keyword">new</span> Wall[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; room.walls.Length; i++) {<font></font>
            room.walls[i] = <span class="hljs-keyword">new</span> Wall();<font></font>
            room.walls[i].positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
            room.walls[i].length = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">switch</span> (i) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"South"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"North"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"West"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"East"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; roomHeight; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; roomWidth; x++) {<font></font>
                Vector2Int position = <span class="hljs-keyword">new</span> Vector2Int();<font></font>
                position.x = xStartingPoint + x;<font></font>
                position.y = yStartingPoint + y;<font></font>
<font></font>
                room.positions.Add(position);<font></font>
<font></font>
                MapManager.map[position.x, position.y] = <span class="hljs-keyword">new</span> Tile();<font></font>
                MapManager.map[position.x, position.y].xPosition = position.x;<font></font>
                MapManager.map[position.x, position.y].yPosition = position.y;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">0</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">0</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (y == (roomHeight - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">1</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">1</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">2</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">2</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == (roomWidth - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">3</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">3</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (MapManager.map[position.x, position.y].type != <span class="hljs-string">"Wall"</span>) {<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Floor"</span>;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!isFirst) {<font></font>
            MapManager.map[lastWallPosition.x, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y - <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y + <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    MapManager.map[lastWallPosition.x - <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    MapManager.map[lastWallPosition.x + <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        room.width = roomWidth;<font></font>
        room.height = roomHeight;<font></font>
        room.type = type;<font></font>
        allFeatures.Add(room);<font></font>
        countFeatures++;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckIfHasSpace</span>(<span class="hljs-params">Vector2Int start, Vector2Int end</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = start.y; y &lt;= end.y; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = start.x; x &lt;= end.x; x++) {
                <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= mapWidth || y &gt;= mapHeight) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (MapManager.map != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">Wall <span class="hljs-title">ChoseWall</span>(<span class="hljs-params">Feature feature</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">int</span> id = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) / <span class="hljs-number">25</span>;
            <span class="hljs-keyword">if</span> (!feature.walls[id].hasFeature) {
                <span class="hljs-keyword">return</span> feature.walls[id];<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawMap</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> isASCII</span>)</span> {
        <span class="hljs-keyword">if</span> (isASCII) {<font></font>
            Text screen = GameObject.Find(<span class="hljs-string">"ASCIITest"</span>).GetComponent&lt;Text&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">string</span> asciiMap = <span class="hljs-string">""</span>;<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = (mapHeight - <span class="hljs-number">1</span>); y &gt;= <span class="hljs-number">0</span>; y--) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; mapWidth; x++) {
                    <span class="hljs-keyword">if</span> (MapManager.map[x, y] != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">switch</span> (MapManager.map[x, y].type) {
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Wall"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"#"</span>;
                                <span class="hljs-keyword">break</span>;
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Floor"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"."</span>;
                                <span class="hljs-keyword">break</span>;<font></font>
                        }<font></font>
                    }<font></font>
                    <span class="hljs-keyword">else</span> {<font></font>
                        asciiMap += <span class="hljs-string">" "</span>;<font></font>
                    }<font></font>
<font></font>
                    <span class="hljs-keyword">if</span> (x == (mapWidth - <span class="hljs-number">1</span>)) {<font></font>
                        asciiMap += <span class="hljs-string">"\n"</span>;<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
<font></font>
            screen.text = asciiMap;<font></font>
        }<font></font>
    }<font></font>
}</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495552/index.html">–ú–æ—è –ø–æ–ø—ã—Ç–∫–∞ –∑–∞–¥–µ—Ä–∂–∞—Ç—å COVID-19 (–∞–≤—Ç–æ–Ω–æ–º–Ω—ã–π –¥—ã—Ö–∞—Ç–µ–ª—å–Ω—ã–π –∞–ø–ø–∞—Ä–∞—Ç)</a></li>
<li><a href="../de495554/index.html">Programm zur Suche nach gleichgesinnten VKontakte [Open Source]</a></li>
<li><a href="../de495556/index.html">Fortinet - eine Auswahl n√ºtzlicher Materialien</a></li>
<li><a href="../de495560/index.html">Trends im Internet der Dinge: KI beantwortet Anrufe, Clouds und 5G Tame Big Data, Wohnen und Versorgungsunternehmen - Innovationsf√ºhrer</a></li>
<li><a href="../de495580/index.html">Gurke JVM - nicht nur BDD</a></li>
<li><a href="../de495592/index.html">Verwendung von W√∂rterb√ºchern (und nicht nur)</a></li>
<li><a href="../de495594/index.html">Verdienen Sie Geld mit Software: Erstellen Sie ein Mini-Digital-Gesch√§ft</a></li>
<li><a href="../de495596/index.html">Fernarbeit im B√ºro. RDP, Port Knocking, Mikrotik: einfach und sicher</a></li>
<li><a href="../de495602/index.html">Beginnend mit Kerndaten! In einfachen Worten schwierig [Teil 2]</a></li>
<li><a href="../de495604/index.html">Tempor√§re Lokalisierung auf Symfony 4 + Twig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>