<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐵 👨🏽‍🤝‍👨🏼 👨‍👩‍👦‍👦 Roguelike in Unity von Grund auf neu erstellen: Dungeon-Generator 👞 👨🏼‍🚒 🧒🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieses Mal werden wir uns mit der Implementierung des Algorithmus des Dungeongenerators befassen. Im letzten Artikel haben wir den ersten Raum erstell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Roguelike in Unity von Grund auf neu erstellen: Dungeon-Generator</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Mal werden wir uns mit der Implementierung des Algorithmus des Dungeongenerators befassen. Im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">letzten Artikel haben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir den ersten Raum erstellt und jetzt werden wir den Rest des Dungeon-Levels generieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber bevor wir anfangen, möchte ich einen Fehler aus einem früheren Beitrag beheben. Tatsächlich habe ich in den letzten Wochen etwas Neues gelernt, weshalb einige meiner Arbeiten veraltet sind und ich darüber sprechen möchte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnerst du dich an die Positionsklasse, die wir erstellt haben? Tatsächlich verfügt Unity bereits über eine integrierte Klasse, die genau dieselben Funktionen ausführt, jedoch mit etwas besserer Kontrolle - es ist einfacher zu deklarieren und zu verarbeiten. Diese Klasse heißt Vector2Int. Daher entfernen wir vor dem Start die Positionsklasse aus MapManager.cs und ersetzen jede Positionsvariable durch die Vector2Int-Variable.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/b7d/f40/656b7df4053976af99cbd2d359edd494.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dasselbe muss an mehreren Stellen im Skript DungeonGenerator.cs ausgeführt werden. </font><font style="vertical-align: inherit;">Kommen wir nun zum Rest des Algorithmus.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe 7 - Raum- / Hallengenerierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir beginnen mit einer kleinen Änderung der zuletzt erstellten Funktion FirstRoom (). </font><font style="vertical-align: inherit;">Anstatt eine andere Funktion zu erstellen, um alle anderen Elemente der Karte zu generieren und eine Menge Code zu duplizieren, transformieren wir diese Funktion einfach und verwandeln sie in eine verallgemeinerte GenerateFeature (). </font><font style="vertical-align: inherit;">Ändern Sie daher den Namen von FirstRoom in GenerateFeature. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen wir Parameter an diese Funktion übergeben. </font><font style="vertical-align: inherit;">Zunächst müssen Sie wissen, welche Funktion es erzeugt - einen Raum oder einen Korridor. </font><font style="vertical-align: inherit;">Wir können einfach eine Zeichenfolge namens </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type übergeben</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Als nächstes muss die Funktion den Startpunkt des Elements kennen, dh von welcher Wand es kommt (weil wir immer ein neues Element aus der Wand des älteren Elements erstellen), und dafür reicht es aus, als Wall-Argument zu übergeben. </font><font style="vertical-align: inherit;">Schließlich weist der erste zu erstellende Raum spezielle Merkmale auf, sodass wir eine optionale Bool-Variable benötigen, die angibt, ob das Element der erste Raum ist. </font><font style="vertical-align: inherit;">Standardmäßig ist es false: bool isFirst = false. </font><font style="vertical-align: inherit;">Der Funktionstitel ändert sich also wie folgt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/b79/d17/e5fb79d178098b3bcde238ff733f9ca9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
auf das:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45e/124/afc/45e124afc4b4f60b12ab18deaa060719.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fein. </font><font style="vertical-align: inherit;">Der nächste Schritt besteht darin, die Art und Weise zu ändern, in der Sie die Breite und Höhe des Elements berechnen. </font><font style="vertical-align: inherit;">Während wir sie berechnen, erhalten wir einen zufälligen Wert zwischen den Min- und Max-Werten der Höhe und Breite der Räume - dies ist ideal für Räume, funktioniert jedoch nicht für Korridore. </font><font style="vertical-align: inherit;">Bisher haben wir also Folgendes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f5/c0d/976/2f5c0d9765a596c2d2188b56b1f7b7ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Korridore haben jedoch je nach Ausrichtung eine konstante Größe von 3 in Breite oder Höhe. </font><font style="vertical-align: inherit;">Daher müssen wir überprüfen, was das Element ist - ein Raum oder ein Korridor - und dann die entsprechenden Berechnungen durchführen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/163/df8/071163df82fc248fc92d370672369743.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit. </font><font style="vertical-align: inherit;">Wir prüfen, ob es sich bei dem Artikel um ein Zimmer handelt. </font><font style="vertical-align: inherit;">Wenn ja, dann machen wir dasselbe wie zuvor </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - wir erhalten eine Zufallszahl im Intervall zwischen min und max von Höhe und Breite. </font><font style="vertical-align: inherit;">Aber jetzt in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sonst</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gleich, wenn Sie etwas anderes machen müssen. </font><font style="vertical-align: inherit;">Wir müssen die Ausrichtung des Korridors überprüfen. </font><font style="vertical-align: inherit;">Glücklicherweise speichern wir beim Generieren einer Wand Informationen darüber, in welche Richtung sie gerichtet ist, und verwenden sie, um die Ausrichtung des Korridors zu ermitteln.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91a/a84/328/91aa84328140d1414b8512843e1cd397.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Variable minCorridorLength haben wir jedoch noch nicht deklariert. </font><font style="vertical-align: inherit;">Sie müssen zu Variablendeklarationen zurückkehren und diese direkt über maxCorridorLength deklarieren.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/857/6e1/f138576e1dc1cb4a9949fd51e8c5fe47.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun zurück zu unseren bedingten switch-Anweisungen. </font><font style="vertical-align: inherit;">Was wir hier tun: Wir erhalten den Wert der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtung der</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wand, dh wohin die Wand schaut, von der aus der Korridor verläuft. </font><font style="vertical-align: inherit;">Die Richtung kann nur vier mögliche Werte haben: Süd, Nord, West und Ost. </font><font style="vertical-align: inherit;">Im Fall von Süd und Nord hat der Korridor eine Breite von 3 (zwei Wände und ein Boden in der Mitte) und eine variable Höhe (Länge). </font><font style="vertical-align: inherit;">Für West und Ost ist alles umgekehrt: Die Höhe beträgt immer 3, und die Breite hat eine variable Länge. </font><font style="vertical-align: inherit;">Also machen wir's.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e2/175/8d6/0e21758d6d2e17406ce516c3fef6ccf5.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beeindruckend. </font><font style="vertical-align: inherit;">Und hier haben wir die Größe des neuen Artikels festgelegt. </font><font style="vertical-align: inherit;">Jetzt müssen Sie entscheiden, wo Sie es platzieren möchten. </font><font style="vertical-align: inherit;">Wir haben den ersten Raum an einer zufälligen Stelle innerhalb der Schwellenwerte relativ zur Kartenmitte platziert.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fb/d53/010/6fbd5301066f6b0ba77ab90142370a5d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei allen anderen Elementen funktioniert dies jedoch nicht. Sie sollten neben dem zufälligen Punkt an der Wand beginnen, von dem aus das Element generiert wird. Ändern wir also den Code. Zuerst müssen wir prüfen, ob das Element der erste Raum ist. Wenn dies der erste Raum ist, definieren wir die Startpunkte auf die gleiche Weise wie zuvor - als die halbe Breite und Höhe der Karte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d29/44d/ff3d2944da973a48200a6c9c3066d20d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn das Element nicht der erste Raum ist, dann bekommen wir einen beliebigen Punkt an der Wand , </font><font style="vertical-align: inherit;">aus dem das Element erzeugt wird. Zuerst müssen wir überprüfen, ob die Wand eine Größe von 3 hat (dies bedeutet, dass es der Endpunkt des Korridors ist), und wenn ja, wird immer der Mittelpunkt ausgewählt, dh Index 1 des Wandarrays (mit 3 Elementen hat das Array Indizes 0, 1, 2). Wenn die Größe jedoch nicht gleich 3 ist (die Wand ist nicht der Endpunkt des Korridors), nehmen wir einen zufälligen Punkt im Intervall zwischen Punkt 1 und der Länge der Wand minus 2. Dies ist erforderlich, um Passagen in der Ecke zu vermeiden. Das heißt, an einer Wand mit einer Länge von 6 schließen wir die Indizes 0 und 5 (erste und letzte) aus und wählen einen zufälligen Punkt unter den Punkten 1, 2, 3 und 4 aus.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/4e1/703/ee24e1703c28b4cfa96e98d84a76c790.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir die Position des Punktes an der Wand, an dem ein neues Element erstellt wird. Wir können aber nicht einfach von dort aus ein Element erzeugen, da es auf diese Weise durch bereits platzierte Wände blockiert wird. Es ist auch wichtig zu beachten, dass das Element von seiner unteren linken Ecke aus erzeugt wird und dann das Inkrement nach rechts und oben ausgeführt wird. Daher müssen wir die Anfangsposition an verschiedenen Stellen festlegen, abhängig von der Richtung, in die die Wand schaut. Außerdem sind die erste Spalte x und die erste Zeile y Wände. Wenn wir ein neues Element direkt neben einem Punkt an der Wand beginnen, können wir einen Korridor erstellen, der in einer Ecke des Raums und nicht an einer geeigneten Stelle an der Wand endet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Wand nach Norden gerichtet ist, muss das Element an einer Position im Norden entlang der y-Achse beginnen, jedoch an einer zufälligen Anzahl von Positionen im Westen entlang der x-Achse im Bereich von 1 bis zur Breite des Raums 2. </font><font style="vertical-align: inherit;">In südlicher Richtung verhält sich die x-Achse gleich, aber die Startposition auf der y-Achse ist die Position des Punkts an der Wand abzüglich der Raumhöhe. </font><font style="vertical-align: inherit;">Die West- und Ostwand folgen der gleichen Logik, nur mit umgekehrten Achsen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir dies alles tun, müssen wir die Position des Wandpunkts in der Variablen Vector2Int speichern, damit wir ihn später bearbeiten können.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/129/41a/37412941a3a58f32fd2dd38c1fc2c252.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Großartig. </font><font style="vertical-align: inherit;">Lass uns das tun.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/2c7/ec0/1402c7ec0596d77f9a9b70b5eac076a9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also haben wir ein Element mit der Größe und Position generiert. Der nächste Schritt besteht darin, das Element auf der Karte zu platzieren. </font><font style="vertical-align: inherit;">Aber zuerst müssen wir herausfinden, ob auf der Karte wirklich Platz für dieses Element an dieser Position ist. </font><font style="vertical-align: inherit;">Im Moment rufen wir einfach die Funktion CheckIfHasSpace () auf. </font><font style="vertical-align: inherit;">Es wird rot hervorgehoben, da wir es noch nicht implementiert haben. </font><font style="vertical-align: inherit;">Wir werden dies direkt tun, nachdem wir fertig sind, was hier in der GenerateFeature () -Funktion getan werden muss. </font><font style="vertical-align: inherit;">Ignorieren Sie daher die rote Unterstreichung und fahren Sie fort.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/805/942/b2080594237c23cae023cabb20b2d20e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im nächsten Teil werden Wände erstellt. </font><font style="vertical-align: inherit;">Bis wir es berühren, mit Ausnahme des Fragments in der zweiten </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schleife </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/d7f/e2b/227d7fe2bf3c2eef41f423e36b4afc79.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Schreiben dieses Beitrags habe ich festgestellt, dass diese if-else-Konstrukte völlig falsch sind. Zum Beispiel erhalten einige Wände in ihnen eine Länge von 1. Dies geschieht, weil, wenn die Position beispielsweise zur Nordwand hinzugefügt werden soll, wenn sie sich an der Ecke mit der Ostwand befindet, sie nicht wie gewünscht zur Ostwand hinzugefügt wird. Dies verursachte störende Fehler im Generierungsalgorithmus. Lassen Sie uns sie beseitigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie zu reparieren ist ziemlich einfach. Es reicht aus, alles </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu löschen </font><em><font style="vertical-align: inherit;">,</font></em><font style="vertical-align: inherit;"> damit die Position alle </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstrukte durchläuft </font><font style="vertical-align: inherit;">und nicht beim ersten Mal stoppt, wenn sie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true zurückgibt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dann wird das letzte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (das, das nicht </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anders ist, wenn</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in </font><em><font style="vertical-align: inherit;">if</font></em><font style="vertical-align: inherit;"> geändert</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hiermit wird überprüft, ob die Position bereits als Wand hinzugefügt wurde. Wenn dies nicht der Fall ist, wird sie als Boden hinzugefügt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/784/834/65c784834461a2d8b05d1d39dd9ee44c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstaunlich, wir sind hier fast fertig. </font><font style="vertical-align: inherit;">Jetzt haben wir ein völlig neues Element, das an der richtigen Stelle erstellt wurde, aber es ist dasselbe wie unser erster Raum: Es ist vollständig von Wänden umgeben. </font><font style="vertical-align: inherit;">Dies bedeutet, dass der Spieler diesen neuen Ort nicht erreichen kann. </font><font style="vertical-align: inherit;">Das heißt, wir müssen einen Punkt an der Wand (der, wie wir uns erinnern, in einer Variablen vom Typ Vector2Int gespeichert ist) und den entsprechenden Punkt an der Wand eines neuen Elements in Floor konvertieren. </font><font style="vertical-align: inherit;">Aber nur wenn das Element nicht der erste Raum ist.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/350/67f/5ac/35067f5ac7db26fd304578b8dd53326c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code überprüft, ob der neue Artikel der erste Raum ist. </font><font style="vertical-align: inherit;">Wenn nicht, konvertiert es die letzte Position der Wand in den Boden und überprüft dann die Richtung, in die die Wand schaut, um zu überprüfen, welche Fliese des neuen Elements in den Boden verwandelt werden soll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den letzten Teil der Funktion GenerateFeature () erreicht. </font><font style="vertical-align: inherit;">Es enthält bereits Zeilen, die Informationen zu dem von der Funktion erstellten Element hinzufügen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/165/626/4fe165626aca42951f86568a4d6649c7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier müssen wir etwas ändern. </font><font style="vertical-align: inherit;">Erstens ist der Elementtyp nicht immer gleich Raum. </font><font style="vertical-align: inherit;">Glücklicherweise wird die erforderliche Variable als Parameter an die Funktion übergeben, nämlich als Typzeichenfolge. </font><font style="vertical-align: inherit;">Ersetzen wir hier also einfach "Raum" durch Typ.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b57/d12/f17/b57d12f17802ec40e0c609d26803f661.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gut. </font><font style="vertical-align: inherit;">Damit der Algorithmus, der alle Elemente des Spiels generiert, ordnungsgemäß funktioniert, müssen wir hier neue Daten hinzufügen. </font><font style="vertical-align: inherit;">Ein int, das die Anzahl der erstellten Elemente und eine Liste aller erstellten Elemente zählt. </font><font style="vertical-align: inherit;">Wir gehen zu der Stelle, an der wir alle Variablen deklarieren und ein int mit dem Namen countFeatures sowie eine Liste von Elementen mit dem Namen allFeatures deklarieren. </font><font style="vertical-align: inherit;">Die Liste aller Elemente muss öffentlich sein, und der int-Zähler kann privat sein.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/ebf/8dd/bcbebf8ddbc768864ba70331317cc72c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kehren Sie nun zur Funktion GenerateFeature () zurück und fügen Sie am Ende einige Zeilen hinzu: Inkrementieren der Variablen countFeatures und Hinzufügen eines neuen Elements zur Liste allFeatures.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/8a8/496/5e68a8496d7047c87650a609acb912cf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser GenerateFeature () ist also fast vollständig. </font><font style="vertical-align: inherit;">Später müssen wir darauf zurückgreifen, um die leere CheckIfHasSpace-Funktion auszufüllen, aber zuerst müssen wir sie erstellen. </font><font style="vertical-align: inherit;">Das machen wir jetzt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe 8 - Überprüfen Sie, ob es einen Platz gibt</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt erstellen wir eine neue Funktion direkt nach Abschluss der GenerateFeature () -Funktion. Sie braucht zwei Argumente: die Position, an der das Element beginnt, und die Position, an der es endet. Sie können zwei Vector2Int-Variablen als diese verwenden. Die Funktion sollte einen Bool-Wert zurückgeben, damit er verwendet werden kann, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nach Speicherplatz gesucht wird.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/998/f03/cad/998f03cad9a6bd8a05bd7d8b9658bad6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist rot unterstrichen, da es bisher nichts zurückgegeben hat. Bald werden wir es reparieren, aber im Moment werden wir nicht darauf achten. In dieser Funktion durchlaufen wir alle Positionen zwischen dem Anfang und dem Ende des Elements und prüfen, ob die aktuelle Position in MapManager.map null ist oder bereits etwas vorhanden ist. Wenn dort etwas ist, stoppen wir die Funktion und geben false zurück. Wenn nicht, fahren Sie fort. Wenn die Funktion das Ende der Schleife erreicht, ohne die gefüllten Stellen zu treffen, geben Sie true zurück. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir die Position auf Null überprüfen, benötigen wir außerdem eine Linie, um zu überprüfen, ob sich die Position innerhalb der Karte befindet. Andernfalls kann es zu einem Array-Indexfehler und einem Spielabsturz kommen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/473/582/a5b/473582a5b560d6738de08b2f6190cf6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fein. </font><font style="vertical-align: inherit;">Nun zurück zu der Stelle, an der wir diese Funktion in die GenerateFeature () -Funktion einfügen. </font><font style="vertical-align: inherit;">Wir müssen diesen Aufruf beheben, da er nicht die erforderlichen Argumente übergibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier möchten wir eine </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if-Anweisung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einfügen </font><font style="vertical-align: inherit;">, um zu überprüfen, ob genügend Platz für das Element vorhanden ist. </font><font style="vertical-align: inherit;">Wenn das Ergebnis falsch ist, beenden wir die Funktion, ohne ein neues Element in MapManager.map einzufügen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/068/661/e53/068661e533ef21536a51f17ae3de570b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir müssen die erforderlichen Argumente übergeben, dh zwei Vector2Int-Variablen. </font><font style="vertical-align: inherit;">Beim ersten ist alles einfach, dies ist die Position mit den x- und y-Koordinaten des Startpunkts des Elements.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/869/26d/0c186926d741d2423c791500adbed2cd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite ist schwieriger, aber nicht viel. </font><font style="vertical-align: inherit;">Dies ist der Startpunkt plus Höhe für y und Breite für x, wobei 1 von beiden abgezogen wird (da der Start bereits berücksichtigt wurde).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a18/f85/4a9/a18f854a9e0a0bbe5883012bf2e313ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fahren wir nun mit dem nächsten Schritt fort: Erstellen eines Algorithmus zum Aufrufen der Funktion GenerateFeature ().</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe 9 - Generierte Elemente aufrufen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zurück zur GenerateDungeon () -Funktion, die im vorherigen Teil des Artikels erstellt wurde. </font><font style="vertical-align: inherit;">Jetzt sollte es so aussehen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/57c/5e3/3e957c5e316f5329e935353e961df47b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Aufruf von FirstRoom () ist rot unterstrichen, da wir den Namen dieser Funktion geändert haben. </font><font style="vertical-align: inherit;">Nennen wir einfach die erste Raumgeneration.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d6/926/908/8d692690826997750f3bc860ae9216f0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben die erforderlichen Argumente übergeben: "Raum" als Typ, da der erste Raum immer Raum, neue Wand () sein wird, weil der erste Raum nicht aus einem anderen erstellt wird, also übergeben wir einfach null, und das ist ganz normal. Anstelle von new Wall () können Sie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ersetzen </font><font style="vertical-align: inherit;">. Dies ist eine Frage der persönlichen Präferenz. Das letzte Argument bestimmt, ob das neue Element der erste Raum ist. In unserem Fall übergeben wir also </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun kommen wir zum Hauptpunkt. Wir verwenden eine for-Schleife, die 500 Mal ausgeführt wird - ja, wir werden versuchen, Elemente 500 Mal hinzuzufügen. Wenn jedoch die Anzahl der erstellten Elemente (Variable countFeatures) der maximal angegebenen Anzahl von Elementen (Variable maxFeatures) entspricht, unterbrechen wir diesen Zyklus.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e6/410/ded/9e6410ded47210776fcda40ae2492229.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Schritt in dieser Schleife besteht darin, das Element zu deklarieren, aus dem das neue Element erstellt wird. </font><font style="vertical-align: inherit;">Wenn wir nur ein Element erstellt haben (den ersten Raum), ist es das ursprüngliche. </font><font style="vertical-align: inherit;">Andernfalls wählen wir zufällig eines der bereits erstellten Elemente aus.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddb/e84/f92/ddbe84f92cbb06f56e3ccce561dde991.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun wählen wir aus, an welcher Wand dieses Elements das neue Element erstellt werden soll.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/e7c/0e4/7ade7c0e438985098eed6f5dbdd42e6d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass wir diese ChoseWall () -Funktion noch nicht haben. </font><font style="vertical-align: inherit;">Lass es uns schnell schreiben. </font><font style="vertical-align: inherit;">Gehen Sie zum Ende der Funktion und erstellen Sie sie. </font><font style="vertical-align: inherit;">Es sollte eine Wand zurückgeben und ein Element als Argument verwenden, damit die Funktion die Wand dieses Elements auswählen kann.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aeb/631/9f1/aeb6319f1ee6f601474d0aa0e32e2c77.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe es zwischen den Funktionen CheckIfHasSpace () und DrawMap () erstellt. </font><font style="vertical-align: inherit;">Beachten Sie, dass Sie bei der Arbeit in Visual Studio, das mit Unity installiert ist, die Felder - / + links verwenden können, um Teile des Codes zu reduzieren / zu erweitern und die Arbeit zu vereinfachen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dieser Funktion finden wir die Wand, aus der das Element noch nicht erstellt wurde. </font><font style="vertical-align: inherit;">Manchmal erhalten wir Elemente mit einer oder mehreren Wänden, an denen bereits andere Elemente angebracht sind. Daher müssen wir immer wieder überprüfen, ob eine der zufälligen Wände frei ist. </font><font style="vertical-align: inherit;">Dazu verwenden wir eine zehnmal wiederholte for-Schleife. Wenn nach diesen zehnmal keine freie Wand gefunden wird, gibt die Funktion null zurück.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/44a/028/b1044a028bf9ab566a0120690311396d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kehren Sie nun zur Funktion GenerateDungeon () zurück und übergeben Sie das ursprüngliche Element als Parameter an die Funktion ChoseWall ().</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/281/8aa/0a32818aafc77ddd87f1ffac21b6981e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Zeile </font></font><code>if (wall == null) continue;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet, dass das ursprüngliche Element kein neues Element generieren kann, wenn die Wandsuchfunktion false zurückgegeben hat. Daher setzt die Funktion </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zyklus fort, dh sie konnte kein neues Element erstellen und fährt mit der nächsten Iteration des Zyklus fort. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen wir den Typ für das nächste Element auswählen. </font><font style="vertical-align: inherit;">Wenn das Quellelement ein Raum ist, muss das nächste ein Korridor sein (wir möchten nicht, dass der Raum direkt zu einem anderen Raum ohne einen Korridor zwischen ihnen führt). </font><font style="vertical-align: inherit;">Wenn dies jedoch ein Korridor ist, müssen wir die Wahrscheinlichkeit schaffen, dass ein weiterer Korridor oder Raum als nächstes kommt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b22/df0/954/b22df0954bbe21d82506d42e5118a70f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fein. </font><font style="vertical-align: inherit;">Jetzt müssen wir nur noch die GenerateFeature () -Funktion aufrufen, die Wand übergeben und als Parameter eingeben.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a07/90b/834/a0790b83479f46dc17c57fbb981aef81.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wechseln Sie schließlich zum Unity-Inspektor, wählen Sie das GameManager-Objekt aus und ändern Sie die Werte wie folgt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cc/09c/786/9cc09c786641bf85a89674cc33042ebf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie jetzt auf die Wiedergabetaste klicken, sehen Sie bereits die Ergebnisse!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie gesagt, dies ist nicht der beste Dungeon. </font><font style="vertical-align: inherit;">Wir haben viele Sackgassen. </font><font style="vertical-align: inherit;">Aber es ist voll funktionsfähig und garantiert, dass Sie keinen Raum haben, der mit keinem anderen verbunden ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, dass es Ihnen gefallen hat! </font><font style="vertical-align: inherit;">Im nächsten Beitrag erstellen wir einen Spieler, der sich durch den Dungeon bewegt, und verwandeln dann die Karte von ASCII in Sprite.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.UI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Post3</span> : <span class="hljs-title">MonoBehaviour</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapWidth;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapHeight;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMaxRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMaxRoom;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> minCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxFeatures;
    <span class="hljs-keyword">int</span> countFeatures;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isASCII;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> List&lt;Feature&gt; allFeatures;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        MapManager.map = <span class="hljs-keyword">new</span> Tile[mapWidth, mapHeight];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GenerateDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        GenerateFeature(<span class="hljs-string">"Room"</span>, <span class="hljs-keyword">new</span> Wall(), <span class="hljs-literal">true</span>);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) {<font></font>
            Feature originFeature;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (allFeatures.Count == <span class="hljs-number">1</span>) {<font></font>
                originFeature = allFeatures[<span class="hljs-number">0</span>];<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {<font></font>
                originFeature = allFeatures[Random.Range(<span class="hljs-number">0</span>, allFeatures.Count - <span class="hljs-number">1</span>)];<font></font>
            }<font></font>
<font></font>
            Wall wall = ChoseWall(originFeature);<font></font>
            <span class="hljs-keyword">if</span> (wall == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
            <span class="hljs-keyword">string</span> type;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (originFeature.type == <span class="hljs-string">"Room"</span>) {<font></font>
                type = <span class="hljs-string">"Corridor"</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) &lt; <span class="hljs-number">90</span>) {<font></font>
                    type = <span class="hljs-string">"Room"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                    type = <span class="hljs-string">"Corridor"</span>;<font></font>
                }<font></font>
            }<font></font>
<font></font>
            GenerateFeature(type, wall);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (countFeatures &gt;= maxFeatures) <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
<font></font>
        DrawMap(isASCII);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GenerateFeature</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> type, Wall wall, <span class="hljs-keyword">bool</span> isFirst = <span class="hljs-literal">false</span></span>)</span> {<font></font>
        Feature room = <span class="hljs-keyword">new</span> Feature();<font></font>
        room.positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
<font></font>
        <span class="hljs-keyword">int</span> roomWidth = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> roomHeight = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) {<font></font>
            roomWidth = Random.Range(widthMinRoom, widthMaxRoom);<font></font>
            roomHeight = Random.Range(heightMinRoom, heightMaxRoom);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">int</span> xStartingPoint;
        <span class="hljs-keyword">int</span> yStartingPoint;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint = mapWidth / <span class="hljs-number">2</span>;<font></font>
            yStartingPoint = mapHeight / <span class="hljs-number">2</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">int</span> id;
            <span class="hljs-keyword">if</span> (wall.positions.Count == <span class="hljs-number">3</span>) id = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> id = Random.Range(<span class="hljs-number">1</span>, wall.positions.Count - <span class="hljs-number">2</span>);<font></font>
<font></font>
            xStartingPoint = wall.positions[id].x;<font></font>
            yStartingPoint = wall.positions[id].y;<font></font>
        }<font></font>
<font></font>
        Vector2Int lastWallPosition = <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth);<font></font>
            yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint ++;<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    xStartingPoint -= roomWidth;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    xStartingPoint++;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
         <span class="hljs-keyword">if</span> (!CheckIfHasSpace(<span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint), <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint + roomWidth - <span class="hljs-number">1</span>, yStartingPoint + roomHeight - <span class="hljs-number">1</span>))) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        room.walls = <span class="hljs-keyword">new</span> Wall[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; room.walls.Length; i++) {<font></font>
            room.walls[i] = <span class="hljs-keyword">new</span> Wall();<font></font>
            room.walls[i].positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
            room.walls[i].length = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">switch</span> (i) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"South"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"North"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"West"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"East"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; roomHeight; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; roomWidth; x++) {<font></font>
                Vector2Int position = <span class="hljs-keyword">new</span> Vector2Int();<font></font>
                position.x = xStartingPoint + x;<font></font>
                position.y = yStartingPoint + y;<font></font>
<font></font>
                room.positions.Add(position);<font></font>
<font></font>
                MapManager.map[position.x, position.y] = <span class="hljs-keyword">new</span> Tile();<font></font>
                MapManager.map[position.x, position.y].xPosition = position.x;<font></font>
                MapManager.map[position.x, position.y].yPosition = position.y;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">0</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">0</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (y == (roomHeight - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">1</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">1</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">2</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">2</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == (roomWidth - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">3</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">3</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (MapManager.map[position.x, position.y].type != <span class="hljs-string">"Wall"</span>) {<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Floor"</span>;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!isFirst) {<font></font>
            MapManager.map[lastWallPosition.x, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y - <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y + <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    MapManager.map[lastWallPosition.x - <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    MapManager.map[lastWallPosition.x + <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        room.width = roomWidth;<font></font>
        room.height = roomHeight;<font></font>
        room.type = type;<font></font>
        allFeatures.Add(room);<font></font>
        countFeatures++;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckIfHasSpace</span>(<span class="hljs-params">Vector2Int start, Vector2Int end</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = start.y; y &lt;= end.y; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = start.x; x &lt;= end.x; x++) {
                <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= mapWidth || y &gt;= mapHeight) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (MapManager.map != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">Wall <span class="hljs-title">ChoseWall</span>(<span class="hljs-params">Feature feature</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">int</span> id = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) / <span class="hljs-number">25</span>;
            <span class="hljs-keyword">if</span> (!feature.walls[id].hasFeature) {
                <span class="hljs-keyword">return</span> feature.walls[id];<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawMap</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> isASCII</span>)</span> {
        <span class="hljs-keyword">if</span> (isASCII) {<font></font>
            Text screen = GameObject.Find(<span class="hljs-string">"ASCIITest"</span>).GetComponent&lt;Text&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">string</span> asciiMap = <span class="hljs-string">""</span>;<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = (mapHeight - <span class="hljs-number">1</span>); y &gt;= <span class="hljs-number">0</span>; y--) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; mapWidth; x++) {
                    <span class="hljs-keyword">if</span> (MapManager.map[x, y] != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">switch</span> (MapManager.map[x, y].type) {
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Wall"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"#"</span>;
                                <span class="hljs-keyword">break</span>;
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Floor"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"."</span>;
                                <span class="hljs-keyword">break</span>;<font></font>
                        }<font></font>
                    }<font></font>
                    <span class="hljs-keyword">else</span> {<font></font>
                        asciiMap += <span class="hljs-string">" "</span>;<font></font>
                    }<font></font>
<font></font>
                    <span class="hljs-keyword">if</span> (x == (mapWidth - <span class="hljs-number">1</span>)) {<font></font>
                        asciiMap += <span class="hljs-string">"\n"</span>;<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
<font></font>
            screen.text = asciiMap;<font></font>
        }<font></font>
    }<font></font>
}</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495552/index.html">Моя попытка задержать COVID-19 (автономный дыхательный аппарат)</a></li>
<li><a href="../de495554/index.html">Programm zur Suche nach gleichgesinnten VKontakte [Open Source]</a></li>
<li><a href="../de495556/index.html">Fortinet - eine Auswahl nützlicher Materialien</a></li>
<li><a href="../de495560/index.html">Trends im Internet der Dinge: KI beantwortet Anrufe, Clouds und 5G Tame Big Data, Wohnen und Versorgungsunternehmen - Innovationsführer</a></li>
<li><a href="../de495580/index.html">Gurke JVM - nicht nur BDD</a></li>
<li><a href="../de495592/index.html">Verwendung von Wörterbüchern (und nicht nur)</a></li>
<li><a href="../de495594/index.html">Verdienen Sie Geld mit Software: Erstellen Sie ein Mini-Digital-Geschäft</a></li>
<li><a href="../de495596/index.html">Fernarbeit im Büro. RDP, Port Knocking, Mikrotik: einfach und sicher</a></li>
<li><a href="../de495602/index.html">Beginnend mit Kerndaten! In einfachen Worten schwierig [Teil 2]</a></li>
<li><a href="../de495604/index.html">Temporäre Lokalisierung auf Symfony 4 + Twig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>