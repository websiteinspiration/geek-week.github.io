<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöâ üëâüèº üë®‚Äç‚öñÔ∏è Programa√ß√£o funcional √© o que voc√™ (provavelmente) foi informado. Se voc√™ ouviu üåú üî† üë©üèΩ‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu gosto de conversas sobre o t√≥pico "Eu costumava ser informado na escola / instituto / pais, mas agora descobri." Se, por um acaso, eu me achar pelo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programa√ß√£o funcional √© o que voc√™ (provavelmente) foi informado. Se voc√™ ouviu</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492460/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu gosto de conversas sobre o t√≥pico "Eu costumava ser informado na escola / instituto / pais, mas agora descobri." Se, por um acaso, eu me achar pelo menos um pouco competente no assunto em discuss√£o, essas conversas geralmente se resumem a uma das tr√™s op√ß√µes: "onde voc√™ j√° ouviu essa bobagem antes?" (se o interlocutor estiver certo), "e de onde voc√™ tirou isso?" (se ele estiver errado) e "voc√™ estiver certo, apenas isso n√£o contradiz o que lhe disseram antes" (na grande maioria dos casos). Gosto dessas conversas pelo seguinte motivo: geralmente o iniciador n√£o est√° sobrecarregado com o conhecimento preliminar excessivo da quest√£o, o que, em alguns casos, permite apontar alguns pontos que foram aceitos como √≥bvios, mas n√£o realmente. E um dos t√≥picos para essas conversas era a programa√ß√£o funcional.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, tanto se escreveu e se disse sobre o FP que parece haver todas as perguntas sobre sua aplicabilidade, frescor, desempenho etc. roeu a medula √≥ssea. No entanto, essas quest√µes s√£o levantadas repetidamente, e sempre haver√° algu√©m que queira falar sobre o que todos voc√™s entenderam mal, mas, na verdade, √© assim. Talvez hoje eu tente me assumir esse papel ingrato, uma vez que v√°rios posts sobre esse assunto de muito sofrimento recentemente me chamaram a aten√ß√£o. O </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeiro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segundo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mais uma vez dizem que a FA √© lixo e estud√°-la apenas estraga o carma do seu futuro especialista. Outros ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dois</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) s√£o muito mais adequados, neles o autor pretende explicar que todas essas suas lambdas, combinadores e categorias nada mais s√£o do que poeira em seus olhos, e o pr√≥prio FP √© uma coisa simples, compreens√≠vel e agrad√°vel da vida. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qu√£o verdadeiro √© isso?</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de abordar a ess√™ncia da quest√£o, farei uma pequena digress√£o e enfatizarei. Acho que o conte√∫do das duas primeiras postagens √© um absurdo total de um analfabeto ... especialista que, com os dedos afastados, discute coisas que ele nem gastou um pouco do seu precioso tempo estudando. Boas pessoas dentre os comentaristas j√° indicaram que isso n√£o passa de brincadeira. O problema √© que, como se viu, n√£o consigo perceber as teses apresentadas nessas tradu√ß√µes como uma brincadeira, pois tive que ouvir a maioria delas ao vivo. Aparentemente, voc√™ pode diagnosticar a presen√ßa de trauma psicol√≥gico causado por um excesso de absurdo que passou pelo c√©rebro.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os segundos dois eram mais propensos a evocar emo√ß√µes positivas, porque neles o autor aplica a pr√°tica de FP √†s tarefas que o desenvolvedor de POO entende. Apesar do desacordo com a mensagem b√°sica da primeira publica√ß√£o refletida no t√≠tulo e das d√∫vidas sobre a razoabilidade da implementa√ß√£o do conceito de m√¥nada de forma t√£o expl√≠cita na linguagem orientada para OOP, o autor n√£o pode ser criticado pela falta de elabora√ß√£o do material. Mas h√° um aspecto b√°sico, que eu n√£o poderia ignorar. Esse √© um tipo de vulgariza√ß√£o da programa√ß√£o funcional, uma tentativa de consider√°-lo um conjunto simples de ferramentas e abordagens para o design de programas. O que, na minha opini√£o, n√£o √© inteiramente verdade.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, neste artigo, √© feita uma tentativa de mostrar que as propriedades dos programas funcionais que o autor est√° tentando reproduzir em seu c√≥digo n√£o s√£o a base da programa√ß√£o funcional, n√£o s√£o estabelecidas pelos s√°bios criadores de Haskell e suas solu√ß√µes de design ilk, mas uma consequ√™ncia direta desses conceitos e modelos que realmente estabelecido em sua funda√ß√£o, ou, curiosamente, uma tentativa de compensar as defici√™ncias que essas funda√ß√µes geram.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, ao ponto</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na ci√™ncia, muitas vezes voc√™ pode observar a seguinte metamorfose. Primeiro, como parte da considera√ß√£o de um certo processo / fen√¥meno / teoria, aparece um certo objeto que possui algumas propriedades importantes e √∫teis. Mas geralmente tamb√©m acaba sendo bastante complicado em sua estrutura, o que limita sua utilidade pr√°tica. Portanto, eles geralmente agem dessa maneira: tomam as propriedades desse objeto como base e, com base nisso, constroem uma nova teoria / modelo / descri√ß√£o, dentro da qual o objeto desejado se torna simples ou at√© trivial, ou as propriedades inerentes necess√°rias aparecem em objetos muito mais simples. Algo assim est√° relacionado √† programa√ß√£o funcional "real" e aos "elementos da programa√ß√£o funcional", dispon√≠veis em linguagens modernas de alto n√≠vel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como geralmente √© √∫til familiarizar-se com a hist√≥ria de sua origem para entender um fen√¥meno, vamos relembrar os momentos da hist√≥ria da teoria da computa√ß√£o e da programa√ß√£o importantes para nossa pergunta. No final do s√©culo XIX e in√≠cio do s√©culo XX, houve uma reestrutura√ß√£o significativa dos alicerces da ci√™ncia matem√°tica. Isso n√£o apenas resolveu uma s√©rie de problemas e contradi√ß√µes identificados que surgiram no √¢mago das id√©ias na √©poca de que havia matem√°tica e provas matem√°ticas, mas tamb√©m colocou uma s√©rie de novas quest√µes. Um deles foi o seguinte: qual √© o algoritmo? Ou, o que √© o mesmo, que classe de problemas pode ser resolvida puramente mecanicamente. N√£o vou explicar por que essa pergunta acabou sendo importante; √© melhor ir direto √† resposta que Alan Turing, amplamente conhecido em c√≠rculos n√£o muito estreitos, deu a ele. Ele formulou a tese:"Somente fun√ß√µes para as quais uma m√°quina de Turing pode ser constru√≠da s√£o comput√°veis." Esta afirma√ß√£o n√£o est√° comprovada. Isso √©, de fato, Turing simplesmente deu uma defini√ß√£o formal estrita do que √© considerado uma fun√ß√£o comput√°vel, consistente com as representa√ß√µes intuitivas que geralmente est√£o embutidas nesse conceito. Essa defini√ß√£o provou ser capaz de satisfazer os solicitantes, porque eles sabem muito bem o que √© uma m√°quina, mesmo com uma fita infinita, e como ela deve funcionar. Mas para muitos matem√°ticos, essa defini√ß√£o n√£o √© muito satisfeita.que geralmente s√£o investidos nesse conceito. Essa defini√ß√£o provou ser capaz de satisfazer os solicitantes, porque eles sabem muito bem o que √© uma m√°quina, mesmo com uma fita infinita, e como ela deve funcionar. Mas para muitos matem√°ticos, essa defini√ß√£o n√£o √© muito satisfeita.que geralmente s√£o investidos nesse conceito. Essa defini√ß√£o provou ser capaz de satisfazer os solicitantes, porque eles sabem muito bem o que √© uma m√°quina, mesmo com uma fita infinita, e como ela deve funcionar. Mas para muitos matem√°ticos, essa defini√ß√£o n√£o √© muito satisfeita.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aparentemente, os conceitos que Turing operava lhes pareciam insuficientemente ... abstratos. </font><font style="vertical-align: inherit;">Nesse sentido, eles n√£o abandonaram as tentativas de dar uma defini√ß√£o diferente, que abrangeria uma classe maior de fun√ß√µes matem√°ticas e, ao mesmo tempo, ainda corresponderia √†s nossas id√©ias intuitivas. </font><font style="vertical-align: inherit;">Essas tentativas foram infrut√≠feras. </font><font style="vertical-align: inherit;">Cada defini√ß√£o alternativa que foi proposta e resistiu √† cr√≠tica acabou sendo equivalente √† defini√ß√£o de Turing, no sentido de que descrevia exatamente a mesma classe de fun√ß√µes matem√°ticas. </font><font style="vertical-align: inherit;">No entanto, esses estudos n√£o foram de forma alguma in√∫teis. </font><font style="vertical-align: inherit;">Tentativas de olhar para o objeto de estudo de um ponto de vista diferente geralmente s√£o raramente in√∫teis. </font><font style="vertical-align: inherit;">No nosso caso, isso levou ao surgimento de v√°rias teorias, uma das quais foi o c√°lculo lambda proposto pela Igreja de Alonzo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pregui√ßa √© o motor do progresso</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que √© t√£o √∫til no c√°lculo lambda e por que todos est√£o t√£o preocupados com isso? Tudo √© simples. No modelo proposto por Turing, o algoritmo √© uma sequ√™ncia de instru√ß√µes familiares para n√≥s, que novamente deve ser executada pelo executor usual. √â intuitivo. Mas a defini√ß√£o da Igreja √© diferente. O principal (e essencialmente o √∫nico) mecanismo de constru√ß√£o no quadro desta teoria s√£o os chamados termos lambda, que em nossos termos atuais podem (condicionalmente) ser chamados de fun√ß√µes an√¥nimas. O programa (algoritmo), neste caso, √© uma combina√ß√£o desses termos constru√≠dos de acordo com certas regras, os dados iniciais s√£o os valores das vari√°veis ‚Äã‚Äãlivres do termo lambda e o processo de c√°lculo nada mais √© do que uma redu√ß√£o (simplifica√ß√£o) do termo lambda (fun√ß√£o), que pode ser realizadoassim que alguma vari√°vel livre obt√©m valor. O seguinte fato acabou sendo inesperado aqui: assim que uma vari√°vel recebe um valor - ou seja, assim que apresentamos uma parte dos dados iniciais ao programa - podemos realizar a redu√ß√£o, mas n√£o de uma, mas de duas maneiras. No primeiro caso, o processo de c√°lculo √© equivalente ao reproduzido por calculadoras mec√¢nicas t√≠picas, como uma m√°quina de Turing. A regra corresponde a ela: os argumentos da fun√ß√£o devem ser calculados antes que a pr√≥pria fun√ß√£o seja calculada. Mas h√° outra op√ß√£o - o chamado c√°lculo parcial. Nesse caso, se apenas uma parte dos argumentos for calculada, ainda podemos calcular (reduzir) a parte da fun√ß√£o que usa apenas esses argumentos. Essa abordagem geralmente √© chamada de modelo "pregui√ßoso" de computa√ß√£o.Em contraste com isso, o modelo de computa√ß√£o de Turing √†s vezes √© chamado de "energ√©tico" ou "ganancioso"; as linguagens de programa√ß√£o constru√≠das com base nisso ser√£o chamadas de imperativas abaixo. Uma caracter√≠stica importante dos c√°lculos "pregui√ßosos" √© que, se uma sub-rotina √© escrita como uma fun√ß√£o de, digamos, tr√™s argumentos, mas, na realidade, usa apenas dois, n√£o √© necess√°rio calcular esse terceiro argumento para calcular o valor da fun√ß√£o.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E isso nos d√° possibilidades pr√°ticas interessantes. </font><font style="vertical-align: inherit;">Por exemplo, a capacidade de trabalhar com sequ√™ncias infinitas. </font><font style="vertical-align: inherit;">Seria f√°cil para quem come√ßou a conhecer a programa√ß√£o funcional em geral e com a linguagem Haskell em particular, entender essa maneira de obter os primeiros </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√∫meros de Fibonacci:</font></font><br>
<br>
<pre><code class="haskell">fibonacci2 a b = a : (fibonacci2 b (a+b))<font></font>
fibonacci = fibonacci2 1 1<font></font>
<font></font>
nfibonacci n = take n fibonacci</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explica√ß√£o para estranhos com Haskell</font></font></b><div class="spoiler_text"><i>fibonacci2</i>      ,       ,         fibonacci2    b   (a+b).  ( !)     :<br>
<pre><code class="python">def fibonacci2(a, b) :<font></font>
    return [a] + fibonacci2(b, a+b)<font></font>
<font></font>
def fibonacci() :<font></font>
    return fibonacci2(1, 1)<font></font>
<font></font>
def nfibonacci(n) :<font></font>
    res = []<font></font>
    data = fibonacci()<font></font>
    for i in range(n) :<font></font>
      res.append( data[i] )<font></font>
    return res<font></font>
</code></pre><br>
   nfibonacci.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (e essa √© precisamente a fun√ß√£o) gera uma lista intermin√°vel de n√∫meros. Se us√°ssemos o modelo computacional familiar, nfibonacci nunca poderia ter terminado (o que, lembro-me, √© perfeitamente aceit√°vel e n√£o contradiz as no√ß√µes de sua ‚Äúcomputabilidade‚Äù). Mas se usarmos o modelo "pregui√ßoso" de c√°lculos, √© f√°cil perceber que, assim que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> assume um valor espec√≠fico, para obter o valor da fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nfibonacci,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> precisamos apenas dos primeiros n elementos da lista que s√£o o resultado da fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nesse caso, podemos agir assim: obter o item da lista - executar a redu√ß√£o, o pr√≥ximo elemento √© outra etapa de redu√ß√£o, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-√©simo argumento - a redu√ß√£o levou √† obten√ß√£o do valor da fun√ß√£o. Ou seja, nesse caso, obtemos um resultado por um tempo finito, apesar do "loop" do procedimento para construir uma lista de n√∫meros de Fibonacci. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui, um leitor particularmente zeloso e imperativo exclama: " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas espere, apenas um idiota franco implementar√° a constru√ß√£o de uma lista de n√∫meros de Fibonacci dessa maneira! Existem solu√ß√µes √≥bvias que n√£o levam a um loop"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". E ele, √© claro, estar√° certo. A transfer√™ncia est√∫pida de uma solu√ß√£o envolvendo a implementa√ß√£o do modelo de c√°lculos" pregui√ßosos "em um programa para c√°lculos" gananciosos "n√£o √© realmente um indicador de grande intelig√™ncia. Se voc√™ oferecer essa tarefa a um programador que manteve toda a sua vida profissional Lealdade, digamos, √† linguagem C, ele provavelmente oferecer√° uma variante com um ciclo com um contador e duas vari√°veis ‚Äã‚Äãde estado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas o ponto n√£o s√£o os n√∫meros de Fibonacci. O fato √© que a regra para construir uma sequ√™ncia neste exemplo √© separada do m√©todo de processamento de seus elementos. E essa √© uma propriedade √∫til que √© desej√°vel poder reproduzir em casos mais complexos, quando os elementos da sequ√™ncia processada s√£o gerados de uma maneira bastante complicada e uma simples transfer√™ncia da solu√ß√£o "de frente" para a sequ√™ncia de Fibonacci, nesse caso, √© ineficaz no tempo, na mem√≥ria ou simplesmente leva a c√≥digo cujo entendimento n√£o √© acess√≠vel a meros mortais. Essa aspira√ß√£o √© natural e pode ser realizada, por exemplo, atrav√©s do uso de iteradores ou geradores. Em python, por exemplo, podemos fazer o seguinte:</font></font><br>
<br>
<pre><code class="python">def fibonacci() :<font></font>
    a = 1<font></font>
    b = 1<font></font>
    yield a<font></font>
    yield b<font></font>
    while True :<font></font>
      c = a + b<font></font>
      yield c<font></font>
      a = b<font></font>
      b = c<font></font>
     <font></font>
def nfibonacci(n) :<font></font>
    return [e for e in itertools.islice(fibonacci(), n)]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© um gerador que cria um elemento de sequ√™ncia por elemento. E, neste caso, em vez de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode haver uma fun√ß√£o geradora de qualquer complexidade. Se introduzirmos o c√≥digo completamente, incluindo o c√≥digo do cap√¥ do motor, obtemos um design de software muito complexo e completamente imperativo. Mas a vers√£o final √© bastante "funcional". No C ++, pode-se fazer um truque semelhante tendo uma classe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fibonachi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> especial </font><font style="vertical-align: inherit;">e iteradores para ele. A decis√£o variar√° de acordo com os recursos da linguagem de programa√ß√£o e as prefer√™ncias do programador, mas o objetivo permanecer√° o mesmo - dividir no n√≠vel da organiza√ß√£o do programa uma maneira de criar uma sequ√™ncia de comprimentos desconhecidos anteriormente e uma maneira de processar seus elementos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A diferen√ßa √© que, dentro da estrutura da abordagem funcional, essa organiza√ß√£o do programa √© natural e √© imposta pelo pr√≥prio m√©todo de sua implementa√ß√£o, enquanto na estrutura do imperativo exige trabalho criativo adicional, incluindo a cria√ß√£o de conceitos e padr√µes de design adicionais.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limpeza √© a chave para a sa√∫de</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra propriedade, na presen√ßa da qual eles falam de uma abordagem funcional da programa√ß√£o, √© a "pureza" das fun√ß√µes. </font><font style="vertical-align: inherit;">√â a aus√™ncia de efeitos colaterais. </font><font style="vertical-align: inherit;">Ou seja, uma chamada de fun√ß√£o com o mesmo conjunto de argumentos deve levar ao mesmo resultado. </font><font style="vertical-align: inherit;">O autor do </font><font style="vertical-align: inherit;">post </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">citado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> descreveu em detalhes suficientes o motivo pelo qual, em programas executados em um estilo imperativo, essa propriedade tamb√©m √© desej√°vel. </font><font style="vertical-align: inherit;">No entanto, nada mais √© do que uma consequ√™ncia do modelo de c√°lculos utilizado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A raz√£o pela qual todas as fun√ß√µes em um programa funcional devem estar limpas √© simples. Supondo a presen√ßa desses mesmos efeitos colaterais, verifica-se que a ordem na qual os argumentos da fun√ß√£o obt√™m seu valor afeta diretamente o resultado da fun√ß√£o. Podemos dizer que isso tamb√©m √© verdade no quadro da abordagem imperativa, mas no caso de ‚Äúpregui√ßa‚Äù dos c√°lculos, tudo √© muito pior. Mesmo se assumirmos que os argumentos da fun√ß√£o podem ser calculados independentemente um do outro em ordem arbitr√°ria, a ‚Äúpregui√ßa‚Äù ainda implica que (condicionalmente) nem todo o c√≥digo da fun√ß√£o ser√° executado de uma s√≥ vez. Ele ser√° executado em partes, dependendo de duas coisas - na verdade, a estrutura da fun√ß√£o que o compilador condicional nos fornecer√° gentilmente, e a ordem na qual apresentaremos seus argumentos para a fun√ß√£o.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â natural que esperemos que, se definimos pela primeira vez uma fun√ß√£o </font></font><br>
<br>
<pre><code class="python">def f(x,y) :<font></font>
  ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
e depois dela </font></font><br>
<pre><code class="python">def g(x, y) :<font></font>
  return f(y, x)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ent√£o o resultado da chamada de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g (a, b)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ser√° igual ao resultado da chamada de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f (b, a)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para quaisquer valores comput√°veis ‚Äã‚Äãindependentemente de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tem efeitos colaterais que afetam o c√°lculo dos valores dos argumentos, ent√£o nossas expectativas podem ser brutalmente enganadas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por exemplo, ao calcular </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ocorre a leitura do arquivo - e ao calcular </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tamb√©m ocorre a leitura do mesmo arquivo. </font><font style="vertical-align: inherit;">Nos c√°lculos "pregui√ßosos", n√£o sabemos antecipadamente qual parte do c√≥digo (para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) ser√° executado primeiro. Isso significa que n√£o sabemos qual resultado o programa dar√°, mesmo que conhe√ßamos o conte√∫do do arquivo que ele deve ler. Esse comportamento √©, em princ√≠pio, inaceit√°vel e, portanto, deve ser categoricamente exclu√≠do. Portanto, dentro da </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estrutura do modelo de c√°lculos ‚Äúpregui√ßosos‚Äù, efeitos colaterais descontrolados da fun√ß√£o devem ser proibidos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se a ordem gananciosa dos c√°lculos for aplicada, os efeitos colaterais s√£o muito mais previs√≠veis. Por isso e somente por esse motivo, eles s√£o permitidos na programa√ß√£o imperativa. Mas se voc√™ abusar deles, o recurso se tornar√° um bug. Portanto, voc√™ n√£o deve abusar deles. Ent√£o, novamente, o conceito de ‚Äúpureza‚Äù que √© natural na programa√ß√£o funcional est√° em demanda no mundo imperativo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consequentemente, a tese</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programa funcional - um programa que consiste em fun√ß√µes puras </font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incorreto se visto como uma defini√ß√£o. </font><font style="vertical-align: inherit;">Sim, um programa funcional consiste em fun√ß√µes "puras", mas um programa que consiste em fun√ß√µes puras n√£o precisa ser "funcional". </font><font style="vertical-align: inherit;">Esta √© sua propriedade, mas n√£o uma propriedade definidora.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, h√° um problema. A capacidade de salvar estado e at√© de entrada e sa√≠da banais s√£o coisas diretamente relacionadas aos efeitos colaterais. E a vida sem eles √© cheia de dor e sofrimento. Surge a pergunta: como casar efeitos colaterais e c√°lculos "pregui√ßosos"? A resposta em geral n√£o √© poss√≠vel. A resposta est√° correta - em cada caso espec√≠fico, uma solu√ß√£o particular satisfat√≥ria deve ser buscada. Descobriu-se que muitas maneiras de reproduzir c√°lculos com efeitos colaterais sem violar o conceito de "pureza" dos c√°lculos se encaixam no conceito geral da m√¥nada, emprestado da teoria das categorias. Eu n√£o gostaria de tentar novamente explicar o que √© e o que √© consumido, apenas porque, em qualquer caso, ele n√£o substituir√° (e, na minha experi√™ncia, nem sequer simplificar√°) uma explica√ß√£o de como as vari√°veis ‚Äã‚Äãde estado podem ser implementadas especificamente,exce√ß√µes e coisas semelhantes em linguagens funcionais "puras". A moral principal √© que a programa√ß√£o imperativa √© uma fonte de inspira√ß√£o para o funcional, assim como funcional para o imperativo. Al√©m disso, √†s vezes uma id√©ia passa por um conceito concorrente como por um filtro, retorna de forma alterada e leva ao aparecimento de uma nova ferramenta.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√¥nadas s√£o necess√°rias em um mundo imperativo? N√£o tenho opini√£o estabelecida sobre esse assunto. O autor </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deste</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jejum certo que necess√°rio. Estou inclinado a duvidar dessa afirma√ß√£o, j√° que o uso do conceito de m√¥nada em programas funcionais geralmente est√° relacionado ao fato de que um determinado algoritmo pode ser formulado, independentemente dos efeitos colaterais espec√≠ficos que essa m√¥nada oculta. Em outras palavras, se um tipo de dados definido pelo usu√°rio (hipot√©tico, ainda n√£o criado pela humanidade) atende aos requisitos de uma m√¥nada, o algoritmo escrito para ela funcionar√° corretamente. Isso √© conveniente principalmente em estudos te√≥ricos. Mas h√° algumas nuances. Em primeiro lugar, n√£o est√° muito claro por que ocultar os efeitos colaterais do inv√≥lucro s√£o eficazes em idiomas para os quais s√£o um fen√¥meno natural. Em segundo lugar,ao escrever programas espec√≠ficos com tipos de dados espec√≠ficos e uma arquitetura de destino espec√≠fica, um algoritmo generalizado √© geralmente for√ßado a passar por uma reestrutura√ß√£o para aumentar a produtividade. √â poss√≠vel escrever algoritmos generalizados usando m√¥nadas em um estilo imperativo, mas a adequa√ß√£o dessa abordagem levanta minhas d√∫vidas. O fato de que talvez um anal√≥gico do tipo std :: optional do C ++ seja declarado como m√¥nada provavelmente n√£o afetar√° de alguma forma a pr√°tica de seu uso.</font></font><br>
<br>
<h3>   ?</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fun√ß√µes de ordem superior s√£o uma ferramenta t√£o amplamente usada em programas funcionais que o fato de oferecer suporte a algo semelhante em alguma linguagem de programa√ß√£o √© suficiente para alguns indiv√≠duos estranhos reconhecerem essa linguagem como funcional. O que s√£o "fun√ß√µes de ordem superior"? Essa √© uma fun√ß√£o que opera em outras fun√ß√µes como argumentos ou retorna uma fun√ß√£o como resultado. Parece que aqui pode causar debate? Acontece muito. Para come√ßar, o que geralmente √© entendido pelo termo "fun√ß√£o". Os programadores costumam raciocinar com simplicidade: se algo pode ser chamado como uma fun√ß√£o, pode ser considerado como uma fun√ß√£o. Na estrutura da abordagem imperativa, isso faz sentido, pois intuitivamente uma fun√ß√£o √© que, para um determinado conjunto de argumentos, ela produz um certo resultado.Se admitimos a presen√ßa de efeitos colaterais, ent√£o, no sentido pr√°tico, realmente n√£o h√° diferen√ßa entre a fun√ß√£o "normal" da linguagem e, digamos, o objeto da classe que possui o operador sobrecarregado ().</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas na programa√ß√£o funcional, essa defini√ß√£o de fun√ß√£o n√£o √© construtiva o suficiente, pois n√£o permite interpretar o conceito de c√°lculo parcial dessa fun√ß√£o. Na programa√ß√£o funcional, uma fun√ß√£o n√£o √© "um dos" elementos estruturais de um programa, mas, em certo sentido, o oposto: todos os elementos do programa s√£o fun√ß√µes. Portanto, de fato, isso √© "programa√ß√£o funcional". E, novamente, se tudo √© uma fun√ß√£o, ou seja, qualquer argumento de qualquer fun√ß√£o √© uma fun√ß√£o, qualquer fun√ß√£o com argumentos √© uma fun√ß√£o de ordem superior. Portanto, fun√ß√µes de ordem superior s√£o um elemento natural de um programa funcional. Tanto √© assim que mesmo sua aloca√ß√£o em uma classe separada n√£o faz muito sentido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como uma fun√ß√£o de ordem superior, o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapa</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou a </font><i><font style="vertical-align: inherit;">dobra</font></i><font style="vertical-align: inherit;"> geralmente s√£o fornecidos.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mas vamos considerar uma forma mais trivial - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qualquer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a fun√ß√£o dos dois argumentos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de f (x, y)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dentro da estrutura do modelo de c√°lculos ‚Äúpregui√ßosos‚Äù, os argumentos dessa fun√ß√£o ser√£o calculados apenas quando forem realmente necess√°rios. Suponha que o primeiro argumento seja </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Calculamos esse argumento, fornecemos seu valor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e, al√©m disso, calculamos tudo o que podemos calcular sem usar o valor do argumento </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O restante dos c√°lculos pode ser representado como uma nova fun√ß√£o, j√° </font><font style="vertical-align: inherit;">independente </font><font style="vertical-align: inherit;">de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por exemplo, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g (y)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mas, neste caso, nada nos impede de apresentar formalmente </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o como fun√ß√£o de dois argumentos, mas como fun√ß√£o de um argumento</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cujo resultado √© outra fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g (y)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Em outras palavras, dentro da estrutura da abordagem funcional, qualquer fun√ß√£o dos </font><font style="vertical-align: inherit;">argumentos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N&gt; 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© uma fun√ß√£o de ordem superior, pois pode ser interpretada como uma fun√ß√£o de um argumento, cujo resultado √© a fun√ß√£o dos </font><font style="vertical-align: inherit;">argumentos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos implementar esse comportamento como parte de uma abordagem imperativa? Claro que podemos. Em python, escrever√≠amos algo como o seguinte:</font></font><br>
<br>
<pre><code class="python">def partial(f, x) :<font></font>
	def g(*args) :<font></font>
		return f(x, *args)<font></font>
	return g<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao chamar a fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parcial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cujo primeiro argumento √© a fun√ß√£o dos </font><font style="vertical-align: inherit;">argumentos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e o segundo √© o valor do primeiro argumento, obtemos a fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1 do</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> argumento. Agora podemos usar a nova fun√ß√£o sempre que pudermos usar a fun√ß√£o de </font><font style="vertical-align: inherit;">argumento </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ou seja, eles t√™m a mesma coisa que no programa funcional. Assim? N√£o, n√£o assim. Se estiv√©ssemos lidando com um programa verdadeiramente funcional, quando chamamos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parcial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , calcular√≠amos parte do valor do primeiro argumento. Em alguns casos, pode at√© acontecer que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seja um valor constante. O que temos em um an√°logo imperativo? O valor passado do argumento </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas lembrado (adicionado ao contexto da fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Quando chamamos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o valor de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ser√° retirado dos compartimentos e simplesmente substitu√≠do em </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ou seja, n√£o h√° diferen√ßa na forma, mas no conte√∫do - significativo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O uso de fun√ß√µes a partir de fun√ß√µes √© conveniente, pois permite descrever naturalmente muitos algoritmos importantes. Ent√£o, eles foram obrigados a aparecer em linguagens de programa√ß√£o imperativas. E eles apareceram. Mas, como eles usam um modelo de c√°lculo diferente, isso exigiria o desenvolvimento de novos conceitos. E eles foram desenvolvidos. Por exemplo, o fechamento descrito acima. Ou seja, as fun√ß√µes de ordens superiores nas linguagens imperativas correspondem ao que pode ser observado nas linguagens funcionais, apenas externamente. Mas o conte√∫do √© completamente diferente. Isso √© importante para o programador? Provavelmente n√£o, mas apenas se ele entender bem como funcionam esses mecanismos que implementam recursos semelhantes em sua linguagem de programa√ß√£o favorita. Caso contr√°rio, voc√™ pode, por exemplo, implementar "aplicativo parcial", fechar ao criar uma nova fun√ß√£o (bem ouo que, no seu caso, se parecer√° com uma fun√ß√£o) vincula em vez de valor e obt√©m um comportamento interessante do programa. E depois disso, grite sobre a abordagem funcional falha.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, quem estava traindo quem?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesta fase da apresenta√ß√£o, √© bem poss√≠vel colocar um ponto e v√≠rgula e retornar √† quest√£o principal. </font><font style="vertical-align: inherit;">Desde agora, podemos formular as seguintes declara√ß√µes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A principal diferen√ßa entre programa√ß√£o funcional e programa√ß√£o imperativa n√£o √© propriedade de pureza de fun√ß√µes, presen√ßa de fun√ß√µes an√¥nimas, fun√ß√µes de ordem superior, m√¥nadas, polimorfismo param√©trico ou qualquer outra coisa. </font><font style="vertical-align: inherit;">A principal diferen√ßa √© o uso de um modelo de c√°lculo diferente. </font><font style="vertical-align: inherit;">Tudo o resto n√£o passa de consequ√™ncias.</font></font></li>
<li>,         ,       .    .     ,      ¬´¬ª  ¬´¬ª .    ,                  .  .</li>
<li>  ,      ,        ,           .        .   ‚Äî .</li>
<li>      ,      .       ,        ¬´¬ª ;   ,       .           ,      -     ,   -      .    .</li>
<li>   ,                 .     ,        . , ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a>    ,                           .          .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Programa√ß√£o funcional √© sobre o que voc√™ (provavelmente) foi informado. S√£o redu√ß√£o beta, combinadores de ponto fixo, m√¥nadas, digita√ß√£o Hindley-Milner e muito mais. N√£o confunda o inv√≥lucro com o conte√∫do. O FP n√£o se baseia na matem√°tica mais simples; n√£o pode ser dominado por algumas noites com um copo de ch√°; √© improv√°vel que seja diretamente projetado nos seus problemas e projetos prementes; voc√™ n√£o obter√° um lucro garantido e r√°pido com esse conhecimento. Mas muitos elementos do que est√° na abordagem funcional s√£o emprestados, processados ‚Äã‚Äãe, finalmente, implementados em linguagens de programa√ß√£o orientadas para o desenvolvimento de grandes projetos. Sim, eles s√£o organizados de maneira diferente dos seus ancestrais funcionais, mas isso n√£o os torna menos √∫teis. Somente um idiota cl√≠nico transmitir√° uma mensagem s√©ria de que Haskell √© uma linguagem ruim,porque √© dif√≠cil escrever um programa para qualquer tipo de contabilidade. Uma pessoa sobrecarregada com a presen√ßa de intelig√™ncia, mesmo do ponto de vista de sua atividade profissional, sem uma imers√£o profunda nos meandros da teoria, √© capaz de entender exatamente quais pr√°ticas da programa√ß√£o funcional devem ser adotadas para melhorar seu c√≥digo. Por uma demonstra√ß√£o convincente da qual expresso gratid√£o</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Psyhast</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aprenda programa√ß√£o funcional. </font><font style="vertical-align: inherit;">Em nome de si mesmo.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt492448/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n¬∫ 406 (9 a 15 de mar√ßo de 2020)</a></li>
<li><a href="../pt492450/index.html">Atualizado 03.31. O coronav√≠rus √© transmitido pelo ar? O que se sabe no momento</a></li>
<li><a href="../pt492454/index.html">Vendemos Refatora√ß√£o de Arquitetura a um cliente ou qual √© o problema dos desenvolvedores</a></li>
<li><a href="../pt492456/index.html">Como visualizar e animar modelos (geof√≠sicos). Mostrar dados brutos</a></li>
<li><a href="../pt492458/index.html">GUI simples para M5Stack (Arduino)</a></li>
<li><a href="../pt492462/index.html">Fonte da verdade: como um analista ensina um gerente e um desenvolvedor a trabalhar juntos</a></li>
<li><a href="../pt492464/index.html">DBA: organize competentemente a sincroniza√ß√£o e as importa√ß√µes</a></li>
<li><a href="../pt492466/index.html">Como mudar de qualquer provedor de host com cPanel para Plesk em Rusonix em apenas cinco etapas</a></li>
<li><a href="../pt492468/index.html">Lenovo Thinkserver SE350: um her√≥i da periferia</a></li>
<li><a href="../pt492474/index.html">Estruturamos as informa√ß√µes nas caixas do Android e analisamos o que um prefixo normal deve ser capaz de fazer.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>