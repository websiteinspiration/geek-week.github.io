<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😾 👼🏾 👩🏻‍💼 ZeroMQとTarantoolに基づくスマートキャッシュサービス 🕶️ ☀️ 🍚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ruslan Aromatov、チーフ開発者、ICD
 
 
 
 こんにちは、Habr！私はモスクワクレジットバンクでバックエンド開発者として働いており、私の仕事の中で、コミュニティと共有したいいくつかの経験を積んでいます。今日は、MKBオンラインモバイルアプリケーションを使用して、お客様のフロン...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ZeroMQとTarantoolに基づくスマートキャッシュサービス</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mkb/blog/471740/"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruslan Aromatov、チーフ開発者、ICD</font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/ld/1c/ck/ld1cckil16z47pv5vgyjgi7kwa8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
こんにちは、Habr！</font><font style="vertical-align: inherit;">私はモスクワクレジットバンクでバックエンド開発者として働いており、私の仕事の中で、コミュニティと共有したいいくつかの経験を積んでいます。</font><font style="vertical-align: inherit;">今日は、MKBオンラインモバイルアプリケーションを使用して、お客様のフロントサーバー用に独自のキャッシュサービスを作成した方法について説明します。</font><font style="vertical-align: inherit;">この記事は、サービス設計に携わっており、マイクロサービスアーキテクチャ、Tarantoolインメモリデータベース、ZeroMQライブラリに精通しているユーザーに役立ちます。</font><font style="vertical-align: inherit;">この記事では、コードの例や基本的な説明はほとんどありませんが、サービスのロジックの説明と、2年以上に渡って私たちの戦いに取り組んできた特定の例との相互作用についてのみ説明します。</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての始まり</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
約6年前、この計画は単純でした。アウトソーシング企業からの遺産として、iOSとandroidの2つのモバイルバンキングクライアントと、それらを提供するフロントサーバーがありました。サーバー自体はJavaで記述され、さまざまな方法（主に石鹸）でバックエンドに行き、httpsを介してxmlを送信することでクライアントと通信しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントアプリケーションは、なんらかの方法で認証し、製品のリストを表示することができ、...一部の送金や支払いを行うことができたようですが、実際には、必ずしもうまくいくとは限りませんでした。したがって、フロントサーバーでは、多数のユーザーや深刻な負荷が発生しませんでした（ただし、2日ごとに約1回ドロップするのを防ぐことはできませんでした）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モバイルバンクの責任者として、私たち（およびその時点ではチームは4人で構成されていました）がこの状況に適していなかったことは明らかです。まず、現在のアプリケーションを整理しましたが、フロントサーバーは本当に悪いことが判明したため、全体をすばやく書き換え、同時にxmlをjsonに置き換え、アプリケーションサーバー</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WildFlyに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移動します</font><font style="vertical-align: inherit;">。数年にわたって広がっており、リファクタリングは別の投稿を利用していません。なぜなら、すべてが主にシステムが安定して動作することを保証するために行われたためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
徐々に、開発されたアプリケーションとサーバーはより安定して動作し始め、それらの機能は絶えず拡大し、それは報われました-より多くのユーザーがいました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、フォールトトレランス、冗長性、レプリケーション、および-怖い-高負荷などの問題が発生し始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題に対する迅速な解決策は、2つ目のWildFlyサーバーを追加することであり、アプリケーションはそれらを切り替えることを学びました。</font><font style="vertical-align: inherit;">クライアントセッションとの同時作業の問題は、WildFlyに統合された</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infinispan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュールによって解決されました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/li/xt/wx/lixtwxkd09us1bfivvdxjv-dxrk.png" alt="以前と同じように"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人生は良くなってきたようです...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたはそのように生きることはできません</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、実際にセッションを操作するこのオプションには欠点がないわけではありませんでした。</font><font style="vertical-align: inherit;">私たちに合わなかったものについて言及します。</font></font><br>
<br>
<ol>
<li> .   . ,      -1:    ,   —   .   ,  -1  .         -  ,     -2,    .     Infinispan       .  , -2     ,    ,      .     . .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーを再起動すると、セッションが失われる可能性もあります。</font><font style="vertical-align: inherit;">たとえば、更新後（これはかなり頻繁に発生します）。</font><font style="vertical-align: inherit;">server-2が起動すると、データがserver-1と同期するまで機能しません。</font><font style="vertical-align: inherit;">サーバーは起動したようですが、実際にはリクエストを受け付けません。</font><font style="vertical-align: inherit;">快適ではありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはビルトインのWildFlyモジュールであり、このアプリケーションサーバーからマイクロサービスに移動するのを防ぎます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここから、どういうわけか私たちが望んでいるもののリストが、どういうわけかそれ自体によって形成されました。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントセッションを保存して、起動直後のサーバーが（いくつあっても）アクセスできるようにします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエスト間のクライアントデータ（たとえば、支払いパラメーターなど）を保存します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的に、任意のデータを任意のキーに保存したい。</font></font></li>
<li>        ,   . ,  ,       ,   .</li>
<li>    .</li>
<li>   ,      ,   ,   …</li>
<li>, ,     .</li>
</ol><br>
<h4> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は、マイクロサービスアーキテクチャを実装していなかったため、まずはさまざまなオプションを読んで、見て、試してみました。ビジネスロジックを処理し、リポジトリへのアクセスインターフェイスである、高速なリポジトリとその上にある種のアドオンが必要であることはすぐにわかりました。さらに、サービス間の高速トランスポートを固定するとよいでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは長い間選択し、多くのことを主張し、実験しました。ここでは、すべての候補者の長所と短所を説明しません。これはこの記事のトピックには適用されません。ストレージは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tarantoolであり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Javaでサービスを記述し、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ZeroMQは</font></a><font style="vertical-align: inherit;">トランスポートとして</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能します</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">選択が非常に曖昧であると主張することはありませんが、大きくて重いフレームワーク（重量と速度が遅い）、ボックス化されたソリューション（汎用性とカスタマイズの欠如）が好きではないという事実に大きく影響されましたが、同時に私たちは、システムのすべての部分をできるだけ制御することを好みます。</font><font style="vertical-align: inherit;">また、サービスの作業を制御するために、</font><font style="vertical-align: inherit;">ほとんどすべてのコードに組み込むことができる便利なエージェントを備え</font><font style="vertical-align: inherit;">た</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prometheus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メトリックコレクションサーバーを選択しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらすべてのログはELKスタックに配置されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、すでに理論が多すぎたようです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開始して終了</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
設計の結果は、ほぼこのようなスキームでした。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/he/kw/oh/hekwohpipjcqh4ufeoykog6f8cc.png" alt="どうやって"></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストレージ</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
データとその現在の状態を保存するためだけに、それは可能な限り愚かである必要がありますが、再起動せずに常に機能する必要があります。</font><font style="vertical-align: inherit;">さまざまなバージョンのフロントサーバーに対応するように設計されています。</font><font style="vertical-align: inherit;">すべてのデータをメモリに保持し、.snapおよび.xlogファイルを介して再起動した場合の回復を行います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントセッションのテーブル（スペース）：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッションID</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顧客ID</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バージョン（サービス）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新時間（タイムスタンプ）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">寿命（ttl）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリアル化されたセッションデータ。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではすべてが単純です。クライアントが認証され、フロントサーバーがセッションを作成してストレージに保存し、時間を記憶します。</font><font style="vertical-align: inherit;">各データリクエストで時刻が更新されるため、セッションは維持されます。</font><font style="vertical-align: inherit;">要求に応じてデータが古いことが判明した場合（またはまったく存在しない場合）、特別な戻りコードを返します。その後、クライアントはセッションを終了します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純なキャッシュテーブル（セッションデータ用）：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キー;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッションID</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存されたデータのタイプ（任意の番号）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新時間（タイムスタンプ）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">寿命（ttl）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリアル化されたデータ。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ログイン前にウォームアップする必要があるクライアントデータの表：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顧客ID</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッションID</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バージョン（サービス）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存されたデータのタイプ（任意の番号）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新時間（タイムスタンプ）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリアル化されたデータ。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで重要なフィールドは状態です。</font><font style="vertical-align: inherit;">実際には、アイドルと更新の2つしかありません。</font><font style="vertical-align: inherit;">これらはクライアントデータのバックエンドに移動する上位のサービスによって設定されるため、このサービスの別のインスタンスは同じ（すでに役に立たない）作業を行わず、バックエンドをロードしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デバイステーブル：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顧客ID</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デバイスID</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新時間（タイムスタンプ）;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デバイステーブルは、クライアントがシステムで認証される前であっても、そのIDを見つけて製品の受信を開始する（キャッシュをウォームアップする）ために必要です。</font><font style="vertical-align: inherit;">ロジックは次のとおりです。最初の入り口は常に寒いです。認証前は、見慣れないデバイスからのクライアントの種類がわからないためです（モバイルクライアントは常に要求でデバイスIDを送信します）。</font><font style="vertical-align: inherit;">このデバイスからの後続のすべてのエントリには、それに関連付けられたクライアントのウォームアップキャッシュが伴います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データの処理は、サーバープロシージャによってJavaサービスから分離されています。はい、私はルアを学ぶ必要がありましたが、それほど時間はかかりませんでした。データ管理自体に加えて、luaプロシージャは、現在の状態の返却、インデックスの選択、バックグラウンドプロセス（ファイバー）の古いレコードのクリーンアップ、データへの直接サービスアクセスが実行される組み込みのWebサーバーの操作も行います。ここにあります-手ですべてを書くことの魅力-無制限の制御の可能性。しかし、マイナスは同じです-すべて自分で書く必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantool自体はDockerコンテナーで動作し、必要なすべてのluaファイルはイメージアセンブリの段階でそこに配置されます。 Gradleスクリプトによるアセンブリ全体。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マスタースレーブ複製。もう一方のホストでは、主ストレージのレプリカとまったく同じコンテナーが実行されます。これは、マスターの緊急クラッシュの場合に必要です。その後、Javaサービスがスレーブに切り替わり、マスターになります。念のため、3番目のスレーブがあります。しかし、私たちのケースでは完全なデータ損失でさえ悲しいですが、致命的ではありません。最悪のシナリオによると、ユーザーはログインして、再びキャッシュに入るすべてのデータを取得する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javaサービス</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
典型的なステートレスマイクロサービスとして設計されています。</font><font style="vertical-align: inherit;">設定はありません。すべての必要なパラメーター（6つあります）は、Dockerコンテナーの作成時に環境変数を介して転送されます。</font><font style="vertical-align: inherit;">独自のプロトコルを使用して、ZeroMQトランスポート（org.zeromq.jzmq-ネイティブlibzmq.so.5.1.1へのJavaインターフェイス）を介してフロントサーバーと連携します。</font><font style="vertical-align: inherit;">Javaコネクタ（org.tarantool.connector）を介してタランチュラで動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービスの初期化は非常に簡単です：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロガー（log4j2）を開始します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">環境変数（Docker内にあります）から、作業に必要なパラメーターを読み取ります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メトリックのサーバー（突堤）を起動します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タランチュラに接続します（非同期）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要な数のスレッドハンドラー（ワーカー）を開始します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブローカー（zmq）を開始します-無限のメッセージ処理サイクル。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のうち、興味深いのはメッセージ処理エンジンだけです。</font><font style="vertical-align: inherit;">以下はマイクロサービスの図です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/my/fd/ef/myfdef3ggy0oerhyfvec3iozvwc.png" alt="メッセージブローカーロジック"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカーのスタートから始めましょう。</font><font style="vertical-align: inherit;">私たちのブローカーは、ROUTERタイプの一連のzmqソケットであり、さまざまなクライアントからの接続を受け入れ、それらからのメッセージのディスパッチを管理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのケースでは、tcpプロトコルを使用してクライアントからメッセージを受信する外部インターフェイスに1つのリスニングソケットがあり、もう1つはインプロセスプロトコルを使用してワーカースレッドからメッセージを受け入れます（tcpよりはるかに高速です）。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">/**
//   (   ,   )
ZContext zctx&nbsp;= new ZContext();
//   
ZMQ.Socket clientServicePoint = zctx.createSocket(ZMQ.ROUTER);
//   
ZMQ.Socket workerServicePoint= zctx.createSocket(ZMQ.ROUTER);
//    
clientServicePoint.bind("tcp://*:" + Config.ZMQ_LISTEN_PORT);
//    
workerServicePoint.bind("inproc://worker-proc");
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソケットを初期化した後、無限のイベントループを開始します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">/**
&nbsp;*     
&nbsp;*/</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
 &nbsp;  <span class="hljs-keyword">int</span> status;
&nbsp; &nbsp; <span class="hljs-keyword">try</span> {<font></font>
&nbsp; &nbsp;  &nbsp;  ZMQ.Poller poller = <span class="hljs-keyword">new</span> ZMQ.Poller(<span class="hljs-number">2</span>);<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; poller.register(workerServicePoint, ZMQ.Poller.POLLIN);<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; poller.register(clientServicePoint, ZMQ.Poller.POLLIN);<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">int</span> rc;<font></font>
<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">//  </span><font></font>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc = poller.poll(POLL_INTERVAL);<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (rc == -<span class="hljs-number">1</span>) {<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = -<span class="hljs-number">1</span>;<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logger.errorInternal(<span class="hljs-string">"Broker run error rc = -1"</span>);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">break</span>; <span class="hljs-comment">//  - </span><font></font>
    &nbsp; &nbsp; &nbsp; &nbsp; }<font></font>
<font></font>
 &nbsp; &nbsp; &nbsp; &nbsp;    <span class="hljs-comment">//&nbsp;    ()</span>
 &nbsp; &nbsp; &nbsp; &nbsp;    <span class="hljs-keyword">if</span> (poller.pollin(<span class="hljs-number">0</span>)) {<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    &nbsp;processBackendMessage(ZMsg.recvMsg(workerServicePoint));<font></font>
    &nbsp; &nbsp; &nbsp; &nbsp; }<font></font>
<font></font>
    &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">//&nbsp;    </span>
 &nbsp;    &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (poller.pollin(<span class="hljs-number">1</span>)) {<font></font>
&nbsp; &nbsp; &nbsp;    &nbsp; &nbsp; &nbsp; &nbsp;processFrontendMessage(ZMsg.recvMsg(clientServicePoint));<font></font>
 &nbsp; &nbsp; &nbsp; &nbsp;    }<font></font>
<font></font>
    &nbsp; &nbsp; &nbsp; &nbsp; processQueueForBackend();<font></font>
 &nbsp;      }<font></font>
&nbsp; &nbsp; } <span class="hljs-keyword">catch</span> (Exception e) {<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; status = -<span class="hljs-number">1</span>;<font></font>
&nbsp; &nbsp; } <span class="hljs-keyword">finally</span> {<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; clientServicePoint.close();<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; workerServicePoint.close();<font></font>
&nbsp; &nbsp; }<font></font>
&nbsp; &nbsp; <span class="hljs-keyword">return</span> status;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業のロジックは非常に単純です。さまざまな場所からメッセージを受信し、それらを使用して何かを行います。重大な障害が発生した場合は、ループを終了します。これにより、プロセスがクラッシュし、Dockerデーモンによって自動的に再起動されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な考え方は、ブローカーはビジネスロジックを処理せず、メッセージヘッダーを分析して、サービスの開始時に以前に起動されたワーカースレッドにタスクを分散するだけであるということです。この場合、固定長の優先順位を持つ単一のメッセージキューが役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のスキームとコードの例を使用してアルゴリズムを分析します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開始後、ブローカーよりも後に開始したスレッドワーカーが初期化され、準備完了のメッセージがブローカーに送信されます。ブローカーはそれらを受け入れ、分析し、各ワーカーをリストに追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントソケットでイベントが発生しました-メッセージ1を受け取りました。</font><font style="vertical-align: inherit;">ブローカーは着信メッセージハンドラーを呼び出します。そのタスクは次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージヘッダーの分析。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定の優先度（ヘッダー分析に基づく）と有効期間を指定してホルダーオブジェクトにメッセージを配置する。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ホルダーをメッセージキューに配置する。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューがいっぱいでない場合、ハンドラーのタスクは終了しています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューがいっぱいの場合は、メソッドを呼び出してエラーメッセージをクライアントに送信します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ループの同じ繰り返しで、メッセージキューハンドラーを呼び出します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューから最新のメッセージを要求します（キューは、メッセージを追加する優先順位と順序に基づいてこれを決定します）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージの有効期間を確認します（有効期限が切れている場合は、メソッドを呼び出してエラーメッセージをクライアントに送信します）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">処理するメッセージに関連がある場合は、最初のフリーワーカーの作業準備を整えます。</font></font></li>
<li>  ,      (,     ,    ,      );</li>
<li>       ,           ;</li>
<li>   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
後続のすべてのメッセージについても同じです。スレッドワーカー自体は、ブローカーと同じように設計されています-エンドレスメッセージの処理サイクルは同じです。ただし、この場合、インスタント処理は不要になり、長時間のタスクを実行するように設計されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワーカーがタスクを完了すると（たとえば、クライアントの製品のバックエンドに移動したり、セッションのタランチュラに移動したり）、メッセージをブローカーに送信し、ブローカーはクライアントに送り返します。回答の送信先となるクライアントのアドレスは、保持オブジェクトでクライアントからメッセージが到着した瞬間から記憶され、わずかに異なる形式でメッセージとしてワーカーに送信されてから返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が常に言及しているメッセージの形式は、私たち自身の作品です。 ZeroMQはそのままの状態で、ZMsgクラス（メッセージ自体、およびZFrame）を提供します。これは、このメッセージの不可欠な部分であり、本質的にはバイトの配列にすぎません。必要に応じて自由に使用できます。メッセージは2つの部分（2つのZFrame）で構成され、最初の部分はバイナリヘッダー、2番目の部分はデータ（要求の本文、たとえばバイトの配列で表されるjson文字列）です。メッセージヘッダーは普遍的で、クライアントからサーバーへ、およびサーバーからクライアントへ移動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、「リクエスト」や「レスポンス」という概念はありません。メッセージだけです。ヘッダーには、プロトコルバージョン、システムタイプ（アドレス指定されるシステム）、メッセージタイプ、トランスポートレベルのエラーコード（0でない場合、メッセージ転送エンジンで何かが発生しました）、リクエストID（クライアントからのパススルー識別子-トレースに必要）、クライアントセッションID（オプション）、およびデータレベルエラーの兆候（たとえば、バックエンドの応答を解析できなかった場合、クライアント側のパーサーが応答を逆シリアル化しないようにこのフラグを設定しますが、エラーデータを受信します）別の方法）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのマイクロサービスとそのようなヘッダー間の単一のプロトコルのおかげで、サービスのコンポーネントを非常に簡単に操作できます。</font><font style="vertical-align: inherit;">たとえば、ブローカーを個別のプロセスに取り込み、マイクロサービスシステム全体のレベルで単一のメッセージブローカーにすることができます。</font><font style="vertical-align: inherit;">または、たとえば、ワーカーをプロセス内のスレッドの形式ではなく、独立した独立したプロセスとして実行します。</font><font style="vertical-align: inherit;">そして、それらの中のコードは変わりませんが。</font><font style="vertical-align: inherit;">一般的に、創造性の余地があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスとリソースについて少し</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカー自体は迅速に動作し、サービスの合計スループットはバックエンドの速度とワーカーの数によって制限されます。便利なことに、必要なメモリ量はすべてサービスの開始時にすぐに割り当てられ、すべてのスレッドもすぐに開始されます。キューのサイズも固定されています。実行時には、メッセージのみが処理されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、現在の戦闘キャッシュサービスは、メインスレッドに加えて、さらに100のワーカースレッドを開始し、キューサイズは3000メッセージに制限されています。通常の操作では、各インスタンスは1秒あたり最大200メッセージを処理し、約250 MBのメモリと約2〜3％のCPUを消費します。ときどきピーク負荷で7-8％にジャンプします。それはすべて、ある種のデュアルコア仮想xeonで動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービスの通常の操作は、キュー内のメッセージ数が0である3つから5つのワーカー（100のうち）の同時雇用を意味します（つまり、すぐに処理に移ります）。突然バックエンドの速度が低下し始めると、ビジーワーカーの数はその応答時間に比例して増加します。事故が発生してバックエンドが上昇した場合、すべてのワーカーが最初に終了し、その後メッセージキューが詰まり始めます。完全に目詰まりすると、処理を拒否されたお客様への対応を開始します。同時に、メモリやCPUリソースを消費し始めず、メトリックを安定して提供し、何が起こっているかを顧客に明確に対応します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のスクリーンショットは、サービスの通常の操作を示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ji/ek/ap/jiekapcj1vylguqgijeheydw7nu.png" alt="サービスの定期的な仕事"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして2番目のイベントで事故が発生しました-何らかの理由でバックエンドが30秒以内に応答しませんでした。</font><font style="vertical-align: inherit;">最初にすべてのワーカーが不足し、その後メッセージキューが詰まり始めたことがわかります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/4v/he/h8/4vheh8hrqsinriaelyow6bgp9wu.png" alt="クラッシュ"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性能試験</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の作業マシン（CentOS 7、Core i5、16Gb RAM）の模擬テストでは、次のことが示されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リポジトリの操作（タランチュラに書き込み、サイズが100バイトのこのレコードをすぐに読み取る-セッションでの作業をシミュレート）-12000 rps。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じこと、速度だけがサービス間で測定されなくなりました-タランチュラポイントではなく、クライアントとサービス間。</font><font style="vertical-align: inherit;">もちろん、自分でストレステストを行うためのクライアントを作成する必要がありました。</font><font style="vertical-align: inherit;">1台のマシン内で7000 rpsを得ることができました。</font><font style="vertical-align: inherit;">ローカルネットワークでは（物理的にどのように接続されているか不明な多くの仮想マシンが存在します）、結果は異なりますが、1つのインスタンスで最大5000 rpsが可能です。</font><font style="vertical-align: inherit;">神はどのようなパフォーマンスを知っていますが、それは私たちのピーク負荷を10回以上カバーしています。</font><font style="vertical-align: inherit;">そして、これはサービスの1つのインスタンスが機能している場合に限られますが、いくつかのインスタンスがあり、いつでも必要な数だけ実行できます。</font><font style="vertical-align: inherit;">サービスがストレージの速度とオーバーラップする場合、タランチュラを水平にスケーリングすることが可能になります（たとえば、クライアントIDに基づくシャード）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスインテリジェンス</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
気配りのある読者はおそらくすでに質問をしています-タイトルに記載されているこのサービスの「スマートさ」は何ですか。</font><font style="vertical-align: inherit;">これについては先ほど触れましたが、もう少し詳しく説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このサービスの主なタスクの1つは、タランチュラでのキャッシュによるバックエンドの負荷を軽減しながら（大規模で重いOracleでのリクエスト数を削減しながら）、ユーザー（アカウント、カード、預金、ローン、サービスパッケージなどのリスト）に製品を発行するのにかかる時間を短縮することでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして彼はそれをかなりうまくやった。</font><font style="vertical-align: inherit;">クライアントキャッシュをウォームアップするロジックは次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーがモバイルアプリケーションを起動します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デバイスIDを含むAppStartリクエストがフロントサーバーに送信されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロントサーバーはこのIDのメッセージをキャッシュサービスに送信します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスは、デバイステーブルでこのデバイスのクライアントIDを探します。</font></font></li>
<li>   ,    (   ,&nbsp;    );</li>
<li> ID  ,          ,             ;</li>
<li>          ,       «updating» (        ,       );</li>
<li>      ;</li>
<li>   ,        ,          -;</li>
<li>    ,      ;</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データが受信中（「更新中」のステータス）の場合、ワーカー内でデータ待機サイクルが開始されます（これはバックエンドへのリクエストタイムアウトと同じです）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データが受信されると（つまり、テーブル内のこのレコード（タプル）のステータスが「アイドル」になると、サービスはそれをクライアントに提供します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データが一定の時間内に受信されない場合、クライアントにエラーが返されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、実際には、フロントサーバーの製品を受信する平均時間を200ミリ秒から20ミリ秒に、つまり約10倍に、バックエンドへの要求数を約4倍に減らすことができました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャッシュサービスは、約2年間戦い続けており、現在、私たちのニーズを満たしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、まだ未解決の問題があり、時々問題が発生します。戦闘中のJavaサービスはまだ落ちていません。タランチュラはSIGSEGVで数回落ちましたが、それはいくつかの古いバージョンであり、更新後は再び起こりませんでした。ストレステスト中に、レプリケーションが低下し、マスターでパイプの破損が発生しました。その後、マスターは動作し続けましたが、スレーブが脱落しました。スレーブを再起動して決定しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かつてデータセンターで何らかの事故が発生し、オペレーティングシステム（CentOS 7）がハードドライブを認識できなくなったことが判明しました。ファイルシステムは読み取り専用モードになりました。最も驚くべきことは、すべてのデータをメモリに保持しているため、サービスが引き続き機能することです。タランチュラは.xlogファイルを書き込むことができず、誰も何も記録しませんでしたが、どういうわけかすべてが機能しました。しかし、再起動の試みは失敗しました-誰も開始できませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
未解決の大きな問題が1つあります。この問題に関するコミュニティの意見を聞きたいと思います。マスタータランチュラの崩壊により、Javaサービスはスレーブに切り替えられ、マスターとして機能し続けます。ただし、これはマスターがクラッシュして機能しない場合にのみ発生します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/e6/pu/wh/e6puwh26kmnngnrxkvyelgvvite.png" alt="未解決の問題"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マスタータランチュラのデータを処理するサービスの3つのインスタンスがあるとします。サービス自体が落ちることはなく、データベースの複製が行われています。すべてが正常です。しかし、突然、ノード1とノード4の間にネットワークが分散し、ウィザードが動作します。数回失敗したService-1は、バックアップデータベースへの切り替えを決定し、そこに要求の送信を開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この直後に、タランチュラスレーブがデータ変更要求の受け入れを開始し、その結果、マスターからのレプリケーションがバラバラになり、一貫性のないデータが取得されます。</font><font style="vertical-align: inherit;">同時に、services-2と3はマスターと完全に連携し、service-1は以前のスレーブとうまく通信します。</font><font style="vertical-align: inherit;">この場合、すべてが技術的な側面からは機能しますが、クライアントセッションやその他のデータが失われ始めることは明らかです。</font><font style="vertical-align: inherit;">そのような潜在的な問題はまだ解決していません。</font><font style="vertical-align: inherit;">幸いにも、これは2年間で発生していませんが、状況はかなり現実的です。</font><font style="vertical-align: inherit;">これで、各サービスはそれが行くストアの数を認識し、マスターからスレーブに切り替えるときに機能するこのメトリックに関するアラートがあります。</font><font style="vertical-align: inherit;">そして、あなたはあなたの手ですべてを修理しなければなりません。</font><font style="vertical-align: inherit;">そのような問題をどのように解決しますか？</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予定</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の問題に取り組み、1つのタイプの要求に同時に従事する労働者の数を制限し、安全に（現在の要求を失うことなく）サービスを停止し、さらに洗練する予定です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく表面的なことではありますが、それですべてですが、作業の一般的なロジックは明確であるはずです。</font><font style="vertical-align: inherit;">したがって、可能であれば、コメントで返信する準備ができています。</font><font style="vertical-align: inherit;">銀行のフロントサーバーの1つの小さな補助サブシステムがモバイルクライアントにサービスを提供するためにどのように機能するかを簡単に説明しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トピックがコミュニティにとって興味深いものである場合は、銀行の顧客サービスの質の向上に貢献するいくつかのソリューションについてお話しします。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja471724/index.html">アジャイルと脳のニーズ：ストレス管理</a></li>
<li><a href="../ja471726/index.html">インパルス応答と非線形歪みを測定するための最新の方法</a></li>
<li><a href="../ja471728/index.html">アバロニア私の長所と短所</a></li>
<li><a href="../ja471736/index.html">非接触イーサネットセンサー</a></li>
<li><a href="../ja471738/index.html">便利さが時々膝を撃つ方法についての短編小説</a></li>
<li><a href="../ja471742/index.html">Sberbank AIジャーニー。ニューラルネットワークで試験を受ける方法を教えた方法</a></li>
<li><a href="../ja471746/index.html">セキュリティのためのHTTPヘッダー構成の完全ガイド</a></li>
<li><a href="../ja471748/index.html">薬局の最適化：数学で行ったこと</a></li>
<li><a href="../ja471750/index.html">情報セキュリティの優先タスクとしての特権アクセス管理（Fudo PAMなど）</a></li>
<li><a href="../ja471756/index.html">サーバーの起動方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>