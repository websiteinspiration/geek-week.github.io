<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛅️ 🌴 🤲🏾 Cortex M0 +マイクロコントローラーでポータブルプラットフォームゲームを作成します 🏣 💔 🍃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前書き
 （ソースコードとKiCADプロジェクトへのリンクは記事の最後にあります。）
 
 私たちは8ビット時代に生まれましたが、最初のコンピューターはAmiga 500でした。これは素晴らしいグラフィックスとサウンドを備えた素晴らしい16ビットマシンで、ゲームに最適です。 。このコンピュータでは、...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Cortex M0 +マイクロコントローラーでポータブルプラットフォームゲームを作成します</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466323/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mg/8v/j_/mg8vj_mlkkh99th0jwxuun5mudk.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ソースコードとKiCADプロジェクトへのリンクは記事の最後にあります。）</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
私たちは8ビット時代に生まれましたが、最初のコンピューターはAmiga 500でした。これは素晴らしいグラフィックスとサウンドを備えた素晴らしい16ビットマシンで、ゲームに最適です。 。このコンピュータでは、プラットフォームが非常に人気のあるゲームのジャンルになっています。それらの多くは非常にカラフルで、非常にスムーズな視差スクロールがありました。これは、Amigaコプロセッサーを巧みに使用して画面の色数を増やす才能のあるプログラマーのおかげで可能になりました。たとえば、LionHeartをご覧ください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/567/0f4/c54/5670f4c541f76158b62e57d951a0f83f.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AmigaのLionheart。この静止画像はグラフィックの美しさを伝えていません。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
90年代以降、エレクトロニクスは大きく変化し、今では素晴らしいものを作成できる小さなマイクロコントローラーがたくさんあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは常にプラットフォームゲームを愛してきました。今日、ほんの数ドルでRaspberry Zeroを購入し、Linuxをインストールして、カラフルなプラットフォーマーを「かなり簡単に」書くことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、このタスクは私たちのためではありません-大砲からスズメを撃ちたくありません！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPUが統合されたチップ上の強力なシステムではなく、メモリが限られているマイクロコントローラーを使用したいのです。言い換えれば、私たちは困難を求めています！</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、ビデオ機能について：一部の人々は、プロジェクト（たとえば、ft開発者のUzeboxプロジェクトまたはCraftプロジェクト）でAVRマイクロコントローラーからすべてのジュースを絞り出すことに成功しています。ただし、これを実現するために、AVRマイクロコントローラーはアセンブラーでの書き込みを強制します。一部のゲームは非常に優れていますが、16ビットスタイルでゲームを作成できない深刻な制限に直面します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、コードを完全にCで記述できる、よりバランスのとれたマイクロコントローラー/ボードを使用することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼はArduino Dueほど強力ではありませんが、Arduino Unoほどではありません。興味深いことに、「デュー」は「2つ」を意味し、「ウノ」は「1つ」を意味します。マイクロソフトは正しくカウントするように教えてくれ（1、2、3、95、98、ME、2000、XP、Vista、7、8、10）、Arduinoもこのように進みました！ 1と2の中間にあるArduino Zeroを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ええ、Arduinoによると、1 &lt;0 &lt;2。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に、ボード自体ではなく、その一連のプロセッサに興味があります。 Arduino Zeroには、Cortex M0 +（48 MHz）、256 KBのフラッシュメモリ、32 KBのRAMを備えたATSAMD21シリーズマイクロコントローラーがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
48 MHz Cortex M0 +のパフォーマンスは古い7 MHz MC68000を大幅に上回っていますが、Amiga 500には512 KBのRAM、ハードウェアスプライト、統合されたデュアルゲームボード、Blitter（ピクセル精度の衝突認識システムが組み込まれたDMAベースの画像ブロック転送エンジン）がありました。と透明度）と銅線（スイープ位置に基づいてレジスターを使用して操作を実行し、非常に美しい効果を作成できるラスターコプロセッサー）。</font><font style="vertical-align: inherit;">SAMD21にはこれらすべてのハードウェアが搭載されているわけではないため（Blitter DMAと比較してかなり単純なものを除いて）、プログラムで多くのものがレンダリングされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のパラメータを実現したいと考えています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.8インチSPIディスプレイの解像度160 x 128ピクセル。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピクセルあたり16ビットのグラフィック。</font></font></li>
<li>   .   25 fps    SPI 12 ,  40 fps  24 ;</li>
<li>     ;</li>
<li>   C.   ;</li>
<li>-  ;</li>
<li> .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの目標を達成することは非常に難しいようです。特に、asmのコードを拒否した場合です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、16ビットカラーの場合、画面サイズが160×128ピクセルの場合、画面バッファに40 KBが必要ですが、RAMは32 KBしかありません。また、少なくとも25/40 fpsの周波数で、ダブルプレイングフィールドなどの視差スクロールが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私たちにとって不可能はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ATSAMD21のトリックや組み込み関数を使用しています！ 「ハードウェア」として、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">イタカストアで</font></a><font style="vertical-align: inherit;">購入できる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uChip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">採用</font></a><font style="vertical-align: inherit;">しています</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/e77/4aa/9ffe774aac84e2df3534d9ac2f16724b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uChip：私たちのプロジェクトの中心！</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
それはArduino Zeroと同じ特徴を持っていますが、はるかに少なく、元のArduino Zeroよりも安いです（そうです、あなたはAliExpressで10ドルで偽のArduino Zeroを買うことができます...しかし、私たちはオリジナルで構築したいと思っています）。これにより、小さなポータブルコンソールを作成できます。このプロジェクトをArduino Zeroにほぼ苦労せずに適合させることができますが、その結果、サイズが非常に扱いにくくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、貧しい人々のためのポータブルコンソールを実装する小さなテストボードも作成しました。詳細は以下！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8a/c34/04e/a8ac3404e35351c6e02368763ef985a5.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arduinoフレームワークは使用しません。</font><font style="vertical-align: inherit;">設備の最適化と管理に関しては、あまり適していません。</font><font style="vertical-align: inherit;">（そしてIDEについては話さないで</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ください</font><font style="vertical-align: inherit;">！）</font><font style="vertical-align: inherit;">この記事では、ゲームの最終バージョンにたどり着いた方法を説明し、使用されたすべての最適化と基準について説明します。</font><font style="vertical-align: inherit;">ゲーム自体はまだ完全ではなく、サウンドやレベルなどが欠けています。</font><font style="vertical-align: inherit;">ただし、さまざまな種類のゲームの開始点として使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、アセンブラーがなくても、さらに多くの最適化オプションがあります！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、旅を始めましょう！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">困難</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、プロジェクトには、タイミングとメモリ（RAMとストレージの両方）の2つの複雑な側面があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記憶</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記憶から始めましょう。まず、大きなレベルの画像を保存する代わりに、タイルを使用します。実際、ほとんどのプラットフォーマーを注意深く分析すると、何度も繰り返される少数のグラフィック要素（タイル）から作成されていることがわかります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f36/950/80a/f3695080a0bfe4d7f1ce6809c8efe275.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AmigaのTurrican 2。</font><font style="vertical-align: inherit;">史上最高のプラットフォームゲームの1つ。</font><font style="vertical-align: inherit;">タイルが簡単に見えます！</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイルのさまざまな組み合わせのおかげで、世界/レベルは多様に見えます。</font><font style="vertical-align: inherit;">これにより、ドライブのメモリが大幅に節約されますが、巨大なフレームバッファの問題は解決されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが使用する2番目のトリックは、uCのかなり大きな計算能力とDMAの存在により可能です。</font><font style="vertical-align: inherit;">すべてのフレームデータをRAMに保存する代わりに（なぜこれが必要なのですか？）すべてのフレームにシーンを最初から作成します。</font><font style="vertical-align: inherit;">特に、バッファは引き続き使用しますが、バッファは高さが16ピクセルのデータグラフィックの1つの水平ブロックに収まります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイミング-CPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンジニアが何かを作成する必要がある場合、彼はまずこれが可能かどうかを確認します。もちろん、最初にこのテストを実行しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、160×128ピクセルの画面では少なくとも25 fpsが必要です。つまり、512,000ピクセル/秒です。マイクロコントローラは48 MHzの周波数で動作するため、ピクセルあたり少なくとも93クロックサイクルがあります。 40 fpsを目指すと、この値は58サイクルに下がります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、マイクロコントローラーは一度に最大2ピクセルを処理できます。これは、各ピクセルが16ビットを消費し、ATSAMD21は32ビットの内部バスを備えているため、パフォーマンスがさらに向上します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
93クロックサイクルの値は、タスクが完全に実行可能であることを示しています。</font><font style="vertical-align: inherit;">実際、CPUだけでDMAなしですべてのレンダリングタスクを処理できると結論付けることができます。</font><font style="vertical-align: inherit;">特にアセンブラーを使用している場合は特にそうです。</font><font style="vertical-align: inherit;">ただし、コードの処理は非常に困難になります。</font><font style="vertical-align: inherit;">そしてCではそれは非常に最適化されなければなりません！</font><font style="vertical-align: inherit;">実際、Cortex M0 +は、Cortex M3ほどCとの親和性が低く、2つ以上の単純な命令で実装する必要がある多くの命令がありません（後続の/事前のインクリメント/デクリメントでロード/保存すらされていません！）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの競技場を描画するために何をする必要があるかを見てみましょう（x座標とy座標などがすでにわかっている場合）。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラッシュメモリ内の前景ピクセルの位置を計算します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピクセル値を取得します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">透明な場合は、フラッシュメモリ内の背景ピクセルの位置を計算します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピクセル値を取得します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ターゲットの場所を計算します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピクセルをバッファに保存します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、バッファに入ることができる各スプライトについて、次の操作を実行する必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラッシュメモリ内のスプライトピクセルの位置を計算します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピクセル値を取得します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">透過的でない場合は、宛先バッファの場所を計算します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピクセルをバッファに保存します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべての操作は、単一のASM命令として実装されるだけでなく、RAM /フラッシュメモリにアクセスするときに、各ASM命令に2サイクル必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、ゲームプレイロジック（幸いにも、フレームごとに1回計算されるため、少し時間がかかります）、衝突認識、バッファー処理、およびSPI経由でデータを送信するために必要な命令がまだありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、これは私たちがしなければならないことの疑似コードです（今のところ、ゲームにはスクロールがなく、競技場には一定の色の背景があると仮定します！）前景のみ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cameraYとcameraXを、ゲームワールドのディスプレイの左上隅の座標とします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
xTileposとyTileposをマップ上の現在のタイルの位置とします。</font></font><br>
<br>
<pre><code class="cpp hljs">xTilepos = cameraX / <span class="hljs-number">16</span>;       <span class="hljs-comment">// this is  a rightward shift of 4 bits.</span>
yTilepos = cameraY / <span class="hljs-number">16</span>;<font></font>
destBufferAddress = &amp;buffer[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
<span class="hljs-keyword">for</span> tile = <span class="hljs-number">0.</span>.<span class="hljs-number">.9</span> <font></font>
    nTile = gameMap[yTilepos][xTilepos];<font></font>
    tileDataAddress = &amp;tileData[nTile];<font></font>
    xTilepos = xTilepos + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> y = <span class="hljs-number">0</span>…<span class="hljs-number">15</span>
        <span class="hljs-keyword">for</span> x = <span class="hljs-number">0</span>…<span class="hljs-number">15</span><font></font>
            pixel = *tileDataAddress;<font></font>
            tileDataAddress  = tileDataAddress  + <span class="hljs-number">1</span>;<font></font>
            *destBufferAddress = pixel;<font></font>
            destBufferAddress = destBufferAddress + <span class="hljs-number">1</span>; <font></font>
        next<font></font>
        destBufferAddress = destBufferAddress + <span class="hljs-number">144</span>;     <span class="hljs-comment">// point to next row </span><font></font>
    next<font></font>
    destBufferAddress = destBufferAddress – ( <span class="hljs-number">160</span> * <span class="hljs-number">16</span>  - <span class="hljs-number">16</span>);  <span class="hljs-comment">// now point to the position where the next tile will be saved.</span>
next</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2560ピクセル（160 x 16）の命令数は約16kです。ピクセルあたり6。実際には、一度に2つのピクセルを描画できます。これにより、ピクセルあたりの実際の命令数は半分になります。つまり、ピクセルあたりの高レベル命令の数は約3です。ただし、これらの高レベル命令の一部は、2つ以上のアセンブラー命令に分割されるか、アクセスするため、完了するために少なくとも2サイクルを必要とします。メモリに。また、フラッシュメモリのジャンプと待機状態が原因でCPUパイプラインをリセットすることも考慮していません。はい、私たちはまだ58〜93サイクルを自由に使えるとは言えませんが、それでもプレイグラウンドとスプライトの背景を考慮する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は1つのCPUでも解決できることがわかりますが、DMAの方がはるかに高速です。メモリに直接アクセスすると、スクリーンスプライトや改善されたグラフィック効果（たとえば、アルファブレンディングを実装できる）の機会がさらに増えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各タイルのDMAを構成するには、100 C未満の命令、つまりピクセルあたり0.5未満が必要であることがわかります。もちろん、DMAはメモリ内で同じ数の転送を実行する必要がありますが、アドレスのインクリメントと送信は、CPUの介入なしに実行されます。CPUは他のことを実行できます（たとえば、スプライトの計算とレンダリング）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SysTickタイマーを使用して、ブロック全体のDMAを準備してからDMAを完了するのに必要な時間は、約12kクロックサイクルであることがわかりました。</font><font style="vertical-align: inherit;">注：クロックサイクル！</font><font style="vertical-align: inherit;">高レベルの指示ではありません！</font><font style="vertical-align: inherit;">サイクル数は、2560ピクセル、つまり </font><font style="vertical-align: inherit;">1,280 32ビットワード。</font><font style="vertical-align: inherit;">実際、32ビットワードあたり約10サイクルを取得します。</font><font style="vertical-align: inherit;">ただし、DMAの準備にかかる時間と、DMAがRAMから転送記述子をロードするのにかかる時間（基本的にはポインターと転送されたバイト数を含む）を考慮する必要があります。</font><font style="vertical-align: inherit;">さらに、常に何らかの種類のメモリバスの変更があり（データなしでCPUがアイドル状態にならないようにするため）、フラッシュメモリには少なくとも1つの待機状態が必要です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイミング-SPI</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つのボトルネックはSPIです。 25 fpsに対して12 MHzで十分ですか？答えは「はい」です。12MHzは、毎秒約36フレームに相当します。 24 MHzを使用すると、制限が2倍になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、ディスプレイとマイクロコントローラーの仕様によると、最大SPI速度はそれぞれ15 MHzと12 MHzです。私たちはテストして、少なくとも必要な「方向」（マイクロコントローラーがディスプレイに書き込む）で、問題なく24 MHzに増加できることを確認しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人気のある1.8インチSPIディスプレイを使用します。</font><font style="vertical-align: inherit;">ILI9163とST7735の両方が12 MHzの周波数で正常に動作することを確認しました（少なくとも12 MHzで。ST7735が最大24 MHzの周波数で動作することが確認されています）。</font><font style="vertical-align: inherit;">チュートリアル「Arduino Unoでビデオを再生する方法」と同じディスプレイを使用する場合は、将来SDサポートを追加する場合に備えて変更することをお勧めします。</font><font style="vertical-align: inherit;">SDカード付きのバージョンを使用しているため、サウンドや追加レベルなどの他の要素のために多くのスペースを確保しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラフィックアート</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに述べたように、ゲームはタイルを使用します。各レベルは、「gameMap」と呼ばれるテーブルに従って繰り返されるタイルで構成されます。各タイルの大きさはどれくらいですか？各タイルのサイズは、メモリの消費、詳細、および柔軟性に大きく影響します（後で説明しますが、速度にも影響します）。タイルが大きすぎると、必要な小さなバリエーションごとに新しいタイルを作成する必要があります。これは、ドライブの多くのスペースを占有します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/a66/32a/a96a6632abfec9bef7341e42bed6cf45.png" width="580" height="165"></div><br>
<i>   32×32  (  ),     (     16×16).         32×32 .      16×16  (),        16×16 (     ).     16×16    4  .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、画面ごとに必要なタイル数が少ないため、速度が向上し（以下を参照）、各レベルのマップのサイズ（つまり、テーブルの行と列の数）が減少します。タイルが小さすぎると、反対の問題が発生します。マップテーブルが大きくなり、速度が遅くなります。もちろん、私たちは愚かな決定はしません。たとえば、サイズが17×31ピクセルのタイルを選択します。私たちの忠実な友人-2度！サイズ16×16はほぼ「黄金律」で、多くのゲームで使用されており、私たちはそれを選択します！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面のサイズは160×128です。つまり、画面あたり10×8のタイルが必要です。テーブルの80エントリ。 10×10画面（または100×1画面）の大きなレベルの場合、必要なレコードは8,000レコードのみです（記録に16ビットを使用する場合は16 KB。後で記録に16ビットを選択することにした理由を示します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを、画面全体の大きな画像が占める可能性が高いメモリ量と比較してください。40KB * 100 = 4 MB！</font><font style="vertical-align: inherit;">これは狂気です！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レンダリングシステムについて話しましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各フレームには（描画順で）次のものが含まれている必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景グラフィックス（バックプレーイングフィールド）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベルグラフ自体（前景）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スプライト</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テキスト/上部オーバーレイ。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に、次の操作を順次実行します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景+前景（タイル）の描画</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">半透明のタイル+スプライト+上部オーバーレイの描画</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPIによるデータの送信。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
背景と完全に不透明なタイルはDMAによって描画されます。</font><font style="vertical-align: inherit;">完全に不透明なタイルは、透明なピクセルがないタイルです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/1dd/417/2da1dd41756746a4b387988c191ca673.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分的に透明なタイル（左）と完全に不透明なタイル（右）。</font><font style="vertical-align: inherit;">部分的に透明なタイルでは、一部のピクセル（左下）が透明であるため、この領域を通して背景が表示されます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
部分的に透明なタイル、スプライト、およびオーバーレイは、DMAで効果的にレンダリングできません。</font><font style="vertical-align: inherit;">実際、ATSAMD21チップDMAシステムはデータをコピーするだけで、Amiga Blitterとは異なり、透明度（カラー値で設定）をチェックしません。</font><font style="vertical-align: inherit;">部分的に透明な要素はすべてCPUによって描画されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/8a2/950/7bb8a29500f57268d62dae5b1de2a9ea.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、DMAを使用してデータがディスプレイに送信されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パイプラインを作成する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、これらの操作を1つのバッファーで順次実行すると、非常に時間がかかります。実際、DMAの実行中は、DMAが完了するまでCPUがビジーになることはありません。これはグラフィックエンジンを実装するための悪い方法です。さらに、DMAがSPIデバイスにデータを送信するとき、DMAはその全帯域幅を使用しません。実際、SPIが24 MHzの周波数で動作している場合でも、データは非常に小さい3 MHzの周波数でのみ送信されます。言い換えると、DMAはその潜在能力を最大限に活用できていません。DMAは、パフォーマンスを実際に失うことなく他のタスクを実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、パイプラインを実装しました。これは、ダブルバッファリング（3つのバッファーを使用します！）のアイデアを発展させたものです。</font><font style="vertical-align: inherit;">もちろん、最終的には、操作は常に順次実行されます。</font><font style="vertical-align: inherit;">しかし、CPUとDMAは、（特に）互いに影響を与えることなく、同時に異なるタスクを実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に何が起こるかは次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファは、DMA 1チャネルを使用してバックグラウンドデータを描画するために使用されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別のバッファー（以前はバックグラウンドデータで満たされていた）で、CPUはスプライトと部分的に透明なタイルを描画します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、DMAチャネル0を使用してSPI経由でディスプレイにデータを送信するために、別のバッファー（水平方向のデータブロック全体が含まれます）が使用されます。タイルでいっぱい。</font></font></li>
</ul><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a75/56e/a95/a7556ea9572df04f967fae2035275c01.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DMA</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ATSAMD21チップDMAシステムはBlitterに匹敵しませんが、それでも独自の便利な機能があります。</font><font style="vertical-align: inherit;">DMAのおかげで、デュアルプレイの分野にもかかわらず、非常に高いリフレッシュレートを提供できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DMA送信の構成はRAMの「DMA記述子」に保存され、現在の送信を実行する方法と場所をDMAに通知します。</font><font style="vertical-align: inherit;">これらの記述子は結合できます。接続がある場合（つまり、nullポインターがない場合）、転送が完了した後、DMAは自動的に次の記述子を受信します。</font><font style="vertical-align: inherit;">複数の記述子を使用することにより、DMAは「複雑な転送」を実行できます。これは、たとえば、ソースバッファーが連続したバイトの非連続なセグメントのシーケンスである場合に役立ちます。</font><font style="vertical-align: inherit;">ただし、RAMから16バイトの記述子を保存/ロードする必要があるため、記述子の取得と書き込みには時間がかかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DMAは、バイト、ハーフワード（16ビット）、ワード（32ビット）のさまざまな長さのデータを処理できます。仕様では、この長さを「ビートサイズ」と呼びます。 SPIの場合、バイト転送を使用する必要があります（現在のREVD仕様では、ATSAMD21 SERCOMチップにはFIFOがあり、Microchipによると、32ビットデータを受け入れることができるとされていますが、実際にはFIFOがないようです。REVD仕様には、 SERCOM CTRLCレジスタ。これは、ヘッダーファイルとレジスタの説明セクションの両方にありません。幸い、AVRとは異なり、ATSAMD21には少なくともバッファされた転送データレジスタがあるため、送信が一時停止することはありません！）。タイルを描画するには、もちろん32ビットを使用します。これにより、ビートごとに2ピクセルをコピーできます。ATSAMD21 DMAチップでは、各ソースビートで、ソースまたは宛先のアドレスを一定数のビートサイズだけ増やすこともできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの2つの側面は非常に重要であり、タイルの描画方法を決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、1ビート（16ビット）ごとに1ピクセルをレンダリングすると、システムのスループットが半分になります。全帯域幅を拒否することはできません！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ビートごとに2ピクセルを描画する場合、プレイフィールドは偶数のピクセルしかスクロールできないため、動きの滑らかさが損なわれます。これを処理するには、2ピクセル以上大きいバッファを使用できます。データをディスプレイに送信するとき、「カメラ」を偶数または奇数のピクセルで移動する必要があるかどうかに応じて、正しいオフセット（0または1ピクセル）を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、簡単にするために、160 + 2ピクセルではなく、11タイル全体（160 + 16ピクセル）のスペースを予約しています。このアプローチには大きな利点が1つあります。各DMA記述子の受信者アドレスを計算して更新する必要がないためです（これにはいくつかの指示が必要であり、タイルごとの計算が多すぎる可能性があります）。もちろん、描画するのは最小ピクセル数、つまり162以下です。はい、結局のところ、スピードとシンプルさのために、少し余分なメモリを使用します（3つのバッファーを考慮すると、これは約1500バイトです）。さらに最適化を実行することもできます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/061/899/2ee/0618992eedba5d01c4d00da2aceec886.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての16行ブロックバッファー（記述子なし）は、このGIFアニメーションで表示されます。</font><font style="vertical-align: inherit;">右側には実際に表示されているものが表示されます。</font><font style="vertical-align: inherit;">最初の32フレームはGIFで表示され、各フレームで1ピクセルずつ右に移動します。</font><font style="vertical-align: inherit;">バッファーの黒い領域は更新されない部分であり、その内容は単に前の操作から残っています。</font><font style="vertical-align: inherit;">画面が奇数のフレームをスクロールすると、幅162ピクセルの領域がバッファに描画されます。</font><font style="vertical-align: inherit;">ただし、それらの最初と最後の列（アニメーションで強調表示されている）は破棄されます。</font><font style="vertical-align: inherit;">スクロール値が16ピクセルの倍数である場合、バッファー内の描画操作は最初の列（x = 0）から始まります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
垂直スクロールはどうですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイルをフラッシュメモリに保存する方法を示した後、それを扱います。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイルの保管方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純なアプローチ（CPUを介してのみレンダリングする場合に適しています）は、タイルを一連のピクセルカラーとしてフラッシュメモリに格納することです。最初の行の最初のピクセル、2番目のピクセル、というように、16番目まで。次に、2番目の行の最初のピクセル、2番目のピクセルを保存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜそのような決定は素朴なのですか？この場合、DMAはDMA記述子ごとに16ピクセルしかレンダリングできないためです。したがって、16個の記述子が必要であり、それぞれに4 + 4のメモリアクセス操作が必要です（つまり、32バイトを転送するには、8回のメモリ読み取り操作+ 8回のメモリ書き込み操作-DMAは、さらに4回の読み取り+ 4回の書き込みを実行する必要があります）。これはかなり非効率です！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、DMAは記述子ごとに、送信元アドレスと宛先アドレスを一定のワード数だけインクリメントできます。タイルの最初の行をバッファーにコピーした後、受信者のアドレスを1ワードずつ増やすのではなく、バッファーの次の行を指すような値にする必要があります。これは不可能です。各伝送記述子は、ビート伝送の増分のみを示し、これは変更できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各タイルラインの最初の2ピクセル、つまりライン0のピクセル0と1、ライン1のピクセル0と1などを、ライン15のピクセル0と1まで順次送信すると、よりスマートになります。次に、ラインのピクセル2と3を送信します。 0など。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fee/f1a/2ee/feef1a2eea76233cd37000f8643f098f.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイルはどのように保存されますか？</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の図では、各番号は16ビットピクセルがタイルアレイに格納される順序を示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは記述子で実行できますが、次の2つが必要です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースを1ワードずつインクリメントするときに常に正しいピクセル位置を指すように、タイルを保存する必要があります。</font><font style="vertical-align: inherit;">つまり、（r、c）が行rと列cのピクセルである場合、ピクセル（0,0）（0,1）（1,0）（1,1）（2,0）を順番に保存する必要があります（2.1）...（15.0）（15.1）（0.2）（0.3）（1.2）（1.3）...</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファの幅は256ピクセルにする必要があります（160ではありません）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の目標は非常に簡単に達成できます。データの順序を変更するだけで、グラフィックをファイルcにエクスポートするときに行うことができます（上の画像を参照）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DMAを使用すると、各ビート後に512バイトずつ受信者アドレスを増やすことができるため、2番目の問題を解決できます。</font><font style="vertical-align: inherit;">これには2つの結果があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPIブロックを介して単一の記述子を使用してデータを送信することはできません。</font><font style="vertical-align: inherit;">結局、1つの記述子を160ピクセルで読み取ったので、これはそれほど深刻な問題ではありません。</font><font style="vertical-align: inherit;">パフォーマンスへの影響は最小限です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロックのサイズは256 * 2 * 16バイト= 8 KBである必要があり、その中に多くの「未使用スペース」があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、このスペースは、たとえば記述子に引き続き使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、各記述子のサイズは16バイトです。</font><font style="vertical-align: inherit;">タイルには少なくとも10 * 8（実際には11 * 8！）の記述子とSPIには16個の記述子が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイルが多いほど、速度が速くなるのはそのためです。</font><font style="vertical-align: inherit;">実際、たとえば、32 x 32タイルを使用した場合、画面ごとに必要な記述子は少なくなります（640ではなく320）。</font><font style="vertical-align: inherit;">これにより、リソースの浪費が削減されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データブロックの表示</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロックバッファー、記述子、およびその他のデータは、displayBlock_tと呼ばれる構造体型に格納されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
displayBlockは、16個のdisplayLineData_t要素の配列です。 DisplayLineデータには、176ピクセルと80ワードが含まれています。これらの80ワードで、表示記述子またはその他の有用な表示データ（ユニオンを使用）を格納します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/817/4cc/f0b/8174ccf0b746674367693a5c6bcd47a5.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/539/677/0a2539677818cc593c80aba690af6679.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16本のラインがあるため、位置Xの各タイルはXラインの最初の8個のDMA記述子（0〜7）を使用します。最大11個のタイル（表示ラインの幅は176ピクセル）があるため、タイルは最初のDMA記述子のみを使用します11行のデータ。</font><font style="vertical-align: inherit;">すべての行の記述子8〜9および行11〜15の記述子0〜9は無料です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのうち、0..7行の記述子8および9がSPIに使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスクリプター0..9の11から15行目（最大50のディスクリプターですが、使用するディスクリプターは48のみです）は、バックグラウンドのプレイフィールドに使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の図は、それらの構造を示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e38/017/7c0/e380177c03a9a6ca50538e438bb0552f.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景の遊び場</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックグラウンドのプレイフィールドの扱いは異なります。</font><font style="vertical-align: inherit;">まず、スムーズなスクロールが必要な場合は、前景と背景が異なる速度でスクロールするため、2ピクセル形式に戻す必要があります。</font><font style="vertical-align: inherit;">したがって、ビートは途中までになります。</font><font style="vertical-align: inherit;">これは速度の点で不利であるという事実にもかかわらず、このアプローチは統合を容易にします。</font><font style="vertical-align: inherit;">残っている記述子の数は少ないため、小さなタイルは使用できません。</font><font style="vertical-align: inherit;">さらに、作業を簡略化し、視差をすばやく追加するために、長い「セクター」を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
背景は、少なくとも部分的に透明なピクセルがある場合にのみ描画されます。</font><font style="vertical-align: inherit;">つまり、透明なタイルが1つしかない場合は、背景が描画されます。</font><font style="vertical-align: inherit;">もちろん、これは帯域幅の余分な無駄ですが、すべてを簡素化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
背景と前部の競技場を比較します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックグラウンドでは、「単純」な方法で格納された長いタイルであるセクターが使用されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景には独自のマップがありますが、水平方向に繰り返されます。</font><font style="vertical-align: inherit;">これのおかげで、より少ないメモリが使用されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景には、セクターごとに視差があります。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロント競技場</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言われたように、各ブロックには最大11のタイル（10の完全なタイル、または9の完全なタイルと2つの部分ファイル）があります。</font><font style="vertical-align: inherit;">これらの各タイルは、透明としてマークされていない場合、DMAが描画されます。</font><font style="vertical-align: inherit;">完全に不透明でない場合は、スプライトのレンダリング時に後で分析されるリストに追加されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ふたつの運動場をつなぐ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックグラウンドの競技場の記述子（常に計算されます）とフロントの競技場は、非常に長いリンクリストを形成します。</font><font style="vertical-align: inherit;">最初の部分は、背景の競技場を描画します。</font><font style="vertical-align: inherit;">2番目の部分は、背景の上にタイルを描画します。</font><font style="vertical-align: inherit;">部分的に透明なタイルのDMA記述子はリストから除外されるため、2番目の部分の長さは可変である可能性があります。</font><font style="vertical-align: inherit;">ブロックに不透明なタイルのみが含まれている場合、DMAは次のように構成されます。</font><font style="vertical-align: inherit;">最初のタイルの最初の記述子から直接開始します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">透明なスプライトとタイル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
透明なタイルとスプライトはほとんど同じように処理されます。</font><font style="vertical-align: inherit;">タイル/スプライトピクセル分析が実行されます。</font><font style="vertical-align: inherit;">黒の場合は透明なので、背景のタイルは変わりません。</font><font style="vertical-align: inherit;">黒でない場合、背景ピクセルはスプライト/タイルピクセルに置き換えられます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">縦スクロール</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
水平スクロールを使用する場合、11タイルまで描画します。11タイルを描画する場合、最初と最後のタイルは部分的にしか描画されません。</font><font style="vertical-align: inherit;">このような部分的なレンダリングは、各記述子がタイルの2つの列を描画するため、リンクリストの開始と終了を簡単に設定できるため、可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
垂直スクロールを使用する場合、レシーバーレジスタと送信ボリュームの両方を計算する必要があります。</font><font style="vertical-align: inherit;">フレームごとに数回設定する必要があります。</font><font style="vertical-align: inherit;">この煩わしさを回避するために、フレームごとに最大9つの完全なブロックを描画できます（スクロールが16の倍数の場合は8）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">装置</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述したように、システムの中心はuChipです。</font><font style="vertical-align: inherit;">残りはどうですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが図です！</font><font style="vertical-align: inherit;">そのいくつかの側面に言及する価値があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb1/b94/910/bb1b94910b94dc1289cc67f4f3e0022d.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I / Oの使用を最適化するために、少しトリックを使用します。 4つのセンサーバスL1〜L4と1つの共通LCワイヤーがあります。 1と0は共通線に交互に適用されるため、センサーバスは内部プルアップ抵抗を使用して交互にプルダウンまたはプルアップされます。各キーバスと共通バスの間に2つのキーが接続されています。これら2つのキーと直列にダイオードが挿入されています。これらのダイオードはそれぞれ逆方向に切り替えられるため、キーが1つだけ「読み取られる」ようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
組み込みのキーボードコントローラーがないため（およびこの興味深い方法を使用する組み込みのキーボードコントローラーがないため）、8つのキーが各フレームの先頭ですばやくポーリングされます。入力をプルアップおよびプルダウンする必要があるため、外部抵抗を使用することはできません（使用したくない）ので、かなり高い抵抗（60 kOhm）が可能な統合抵抗を使用する必要があります。これは、共通バスの状態が変化し、データバスのアップ/ダウンプル状態が変化したときに、組み込みのアップ/ダウンプルアップ抵抗がコントラクトを変更し、浮遊容量を目的のレベルに設定するように、遅延を挿入する必要があることを意味します。でも待ってたくない！したがって、共通バスを高インピーダンス状態にして（不一致がないようにし）、最初にセンサーバスを論理値1または0に変更します。それらを出力として一時的に構成します。その後、プルアップまたはプルダウンすることで入力として構成されます。出力抵抗は数十オームのオーダーであるため、状態は数ナノ秒で変化します。つまり、センサーバスが入力に戻ったときに、すでに望ましい状態になっています。その後、コモンバスは反対極性の出力に切り替わります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、スキャン速度が大幅に向上し、nop遅延/指示の必要がなくなります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI接続</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDとディスプレイを接続して、ATSAMD21にデータを転送せずに相互に通信できるようにしました。</font><font style="vertical-align: inherit;">これは、ビデオを再生する場合に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MISOとMOSIを接続する抵抗は低くする必要があります。</font><font style="vertical-align: inherit;">それらが大きすぎる場合、信号が弱すぎるため、SPIは機能しません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化とさらなる開発</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最大の問題の1つは、RAMの使用です。 3つのブロックがそれぞれ8 KBを占有し、スタックおよびその他の変数ごとに8 KBのみを残します。現時点では、空きRAMは1.3 KB +スタックは4 KBしかありません（スタックごとに4 KB-これは大きいので、おそらく減らす予定です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、16ではなく8ピクセルの高さのブロックを使用できます。これにより、DMA記述子のリソースの浪費が増加しますが、ブロックバッファーが占有するメモリの量はほぼ半分になります（16×16タイルを使用し続けても記述子の数は変化しないため、ブロック構造を変更する必要があります）。これにより、約7.5 KBのRAMを解放できます。これは、シークレット付きの変更可能なカードやサウンドの追加などの機能を実装するのに非常に役立ちます（1 KBのRAMでもサウンドを追加できます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの問題はスプライトですが、この変更ははるかに簡単に実行でき、必要なのはcreateNextFrameScene（）関数だけです。実際、すべてのスプライトの状態を含む巨大な配列をRAMに作成しています。次に、各スプライトについて、その位置が画面の領域内にあるかどうかを計算し、アニメーション化してレンダリングリストに追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代わりに、最適化を実行できます。たとえば、gameMapでは、タイルの値だけでなく、エディターで設定されたタイルの透明度を示すフラグも保存できます。これにより、タイルをレンダリングする必要があるかどうか（DMAまたはCPU）をすばやく確認できます。そのため、タイルカードに16ビットレコードを使用しました。 256タイルのセットがあると仮定すると（現時点では128タイル未満ですが、フラッシュメモリに新しいタイルを追加するための十分なスペースがあります）、他の目的に使用できる7つの空きビットがあります。これらの7ビットのうち3つを使用して、スプライト/オブジェクトが格納されているかどうかを示すことができます。例えば：</font></font><br>
<br>
<code>0b000 =   <br>
0b001 = <br>
0b010 = <br>
0b011 = <br>
0b100 = <br>
0b101 = <br>
0b110 = <br>
0b111 =    , ,   .</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、RAMにビットテーブルを作成できます。各ビットは、（たとえば、敵が）検出されるかどうか（たとえば、ボーナス）が拾われるかどうか、特定のオブジェクトがアクティブ化されるかどうか（スイッチ）を意味します。</font><font style="vertical-align: inherit;">10×10画面のレベルでは、これは8000ビットを必要とします。</font><font style="vertical-align: inherit;">1 KBのRAM。</font><font style="vertical-align: inherit;">敵を発見したときやボーナスを拾ったときにビットがリセットされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
createNextFrameScene（）では、現在表示されている領域のタイルに対応するビットを確認する必要があります。</font><font style="vertical-align: inherit;">値が1の場合：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これがおまけの場合は、レンダリングするスプライトのリストに追加するだけです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これが敵である場合は、ダイナミックスプライトを作成してフラグをリセットします。</font><font style="vertical-align: inherit;">次のフレームでは、敵が画面を離れるか殺されるまで、シーンには動的なスプライトが含まれます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチには欠点があります。</font></font><br>
<br>
<ol>
<li>-,           (       ).      .</li>
<li>-,       80  ,  ,    .      ,            32 .          ,   «/» (      «», ..        0!).           «»,          «» (           ).</li>
<li>-,      .       (    ),     .  ,      .</li>
<li>-,   ,   ,    ,     .     ,       ,     .          ,     ,   ,     ,   !</li>
<li>    ,          (,    Unreal Tournament   ,        ).</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それにもかかわらず、この方法では、スプライトをはるかに効率的なレベルで保存および処理できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、この手法は、ゲームのグラフィックエンジンよりも「ゲームロジック」に関連しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく将来的には、この機能を実装する予定です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要約する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この紹介記事をお楽しみいただけましたでしょうか。</font><font style="vertical-align: inherit;">今後の記事のトピックとなる多くの側面を説明する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それまでの間、ゲームの完全なソースコードをダウンロードできます。</font><font style="vertical-align: inherit;">気に入った場合は、</font><font style="vertical-align: inherit;">すべてのグラフィックを描き、無料で世界に提供し</font><font style="vertical-align: inherit;">たアーティスト</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ansimuzを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">経済的にサポートできます</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">寄付も受け付けてい</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームはまだ終わっていません。</font><font style="vertical-align: inherit;">サウンド、多くのレベル、相互作用できるオブジェクトなどを追加したいと考えています。</font><font style="vertical-align: inherit;">独自の変更を作成できます！</font><font style="vertical-align: inherit;">新しいグラフィックスとレベルを備えた新しいゲームを期待しています！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まもなく地図エディタをリリースしますが、現時点ではコミュニティに表示するには初歩的すぎます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（注：照明が不十分なため、ビデオははるかに低いフレームレートで記録されました！すぐにビデオを更新して、40 fpsで最高速度を推定できるようにします！）</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/1ekTeCCWKNI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ありがとう</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームのグラフィック（および一部の画像に表示されているタイル）は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ansimuzによって作成され</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">無料のアセット「Sunny Land」から取得されました</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダウンロード可能な資料</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトのソースコードはパブリックドメインにあります。つまり、無料で提供されます。</font><font style="vertical-align: inherit;">誰かのお役に立てば幸いです。</font><font style="vertical-align: inherit;">コードのバグ/エラーが原因で問題が発生することは保証されません！</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回路図</font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KiCad </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトAtmel Studio 7プロジェクト（ソース）</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja466305/index.html">国分隆史：Rubyアプリケーションの実行速度を上げる方法</a></li>
<li><a href="../ja466307/index.html">SCSの設計方法</a></li>
<li><a href="../ja466311/index.html">SLSワークショップ9月6日</a></li>
<li><a href="../ja466315/index.html">@Pythonetcコンパイル、2019年8月</a></li>
<li><a href="../ja466319/index.html">ディール：VMwareがクラウドベースのスタートアップを買収</a></li>
<li><a href="../ja466329/index.html">ロシアのワイン造りの電子地図。デザインとコンテンツ</a></li>
<li><a href="../ja466333/index.html">自分で職場を整える方法</a></li>
<li><a href="../ja466335/index.html">8base機能を使用したSlackアプリケーションの作成</a></li>
<li><a href="../ja466337/index.html">あなたの機能は何色ですか？</a></li>
<li><a href="../ja466339/index.html">Microsoft SQL ServerでRを使用してGoogleアナリティクスからデータを取得する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>