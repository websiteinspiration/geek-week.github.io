<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏻 ⏫ 🥇 Redis最佳做法，第3部分 ⚾️ 🏇 ◾️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Redis Labs官方网站上Redis Best Practices部分的最终翻译。今天最不寻常，最有趣的部分就切入了！
 
 
 第一部分在这里。
 第二个在这里。
 
 本文包含以下主题：
 
 

- 排序集合上的时间序列；
- 按字典顺序排序的时间序列；
- 位域上的时间顺序；
- 基本带...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Redis最佳做法，第3部分</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506594/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Labs官方网站</font><font style="vertical-align: inherit;">上</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Best Practices</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分的最终翻译</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">今天最不寻常，最有趣的部分就切入了！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hr/6y/f5/hr6yf5w1hp0fh-i5vfa0p1pxeuy.png" width="15%"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一部分在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文包含以下主题：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排序集合上的时间序列；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按字典顺序排序的时间序列；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位域上的时间顺序；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本带宽限制模式；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">布隆过滤器</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计数器;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位计数模式；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperLogLog;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lua脚本。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间序列数据</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以使用多种方式在Redis中对时序数据或具有自然时间顺序的数据进行建模，具体取决于数据本身以及您要访问的方式。</font><font style="vertical-align: inherit;">我们将研究以下几种模式：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排序集合上的时间序列；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按字典顺序排序的时间序列；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位域上的时间顺序；</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排序集合上的时间序列</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
排序集合（zset）上的时间序列是在Redis中建模时间序列的一种典型方法。</font><font style="vertical-align: inherit;">排序集由唯一对象组成，其得分存储在一个键下。</font><font style="vertical-align: inherit;">对排序集使用此数据类型意味着，计数的行为就像一种时间指示符（通常是精确到毫秒的时间戳），并且元素已记录数据。</font><font style="vertical-align: inherit;">唯一的好处是，由于这是集合的一种形式，因此仅允许使用唯一的元素，并且尝试记录具有相同值的时间序列只会刷新分数。</font><font style="vertical-align: inherit;">为了说明此问题，我们采用以下定期记录温度的示例：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间戳记</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">温度，℃</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697976001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697977001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697978001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果仅使用ZADD将它们添加到排序集中，则可能会丢失一些值：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ANTI-PATTERN</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD temperature 1586697976001 21<font></font>
(integer) 1<font></font>
&gt; ZADD temperature 1586697977001 22<font></font>
(integer) 1<font></font>
&gt; ZADD temperature 1586697978001 21<font></font>
(integer) 0<font></font>
&gt; ZRANGEBYSCORE temperature -inf +inf WITHSCORES<font></font>
1) "22"<font></font>
2) "1586697977001"<font></font>
3) "21"<font></font>
4) "1586697978001"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，对ZADD的第三次调用返回0，这表明新项目尚未添加到集合中。然后在ZRANGEBYSCORE中，我们看到排序集中只有两个记录。为什么？因为第一个和第三个共享相同的对象，所以我们刚刚更新了该对象的帐户。有几种方法可以解决此问题。其中之一是包括一些具有足够变化的随机数据，从而确保唯一性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，创建一个从0到1（含）的伪随机实数，然后将其添加到我们的时间戳中。在我们的示例中，为了便于阅读，我们将其保留为十进制形式（实际上，将其转换为8字节的字符串以节省空间是更明智的选择）。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD temperature2 1586697976001 21:1586697976001.2583<font></font>
(integer) 1<font></font>
&gt; ZADD temperature2 1586697977001 22:1586697977001.941678<font></font>
(integer) 1<font></font>
&gt; ZADD temperature2 1586697978001 21:1586697978001.732015<font></font>
(integer) 1<font></font>
&gt; ZRANGEBYSCORE temperature2 -inf +inf WITHSCORES<font></font>
1) "21:1586697976001.2583"<font></font>
2) "1511533205001"<font></font>
3) "22:1586697977001.941678"<font></font>
4) "1586697977001"<font></font>
5) "21:1586697978001.732015"<font></font>
6) "1586697978001"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，所有ZADD都返回1，表示添加成功，而ZRANGEBYSCORE返回了所有值。</font><font style="vertical-align: inherit;">这是一种有效的方法，但是由于浪费字节以确保唯一性，因此效率不是很高，这会增加存储开销。</font><font style="vertical-align: inherit;">在大多数情况下，唯一性只会被您的应用程序清除掉。</font><font style="vertical-align: inherit;">应该注意的是，如果您的数据已经是唯一的（例如，包含UUID的数据），则不需要添加唯一性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用此方法，您可以访问所有排序集的方法以进行分析和控制：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZRANGEBYSCORE允许您在两个时间戳之间获取特定切片（ZREVRANGEBYSCORE将按降序返回切片）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZREMRANGEBYSCORE允许您删除特定范围的时间戳；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZCOUNT-时间戳范围之间的元素数；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZINTERSTORE-允许您获取两个数据的交集并将其保存在新密钥下；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZUNIONSTORE-允许您获取两个数据的并集，并将其保存在新密钥下。</font><font style="vertical-align: inherit;">您还可以使用它来复制已排序的集合。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用多个键的ZINTERSTORE和ZUNIONSTORE操作。</font><font style="vertical-align: inherit;">在共享环境中工作时，需要小心检查新密钥是否在同一段中，否则这些命令将导致错误。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字典排序集上的时间序列</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
处理时间序列的另一种方法是使用排序集的词典属性来存储时间戳和值。如果您还不熟悉这一点，那么该阅读</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本节了</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用此方法，我们以相同的计数存储所有内容，然后首先对时间戳进行编码，然后将该值添加为元素。举个例子：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD lex-temperature 0 1589392163001:21<font></font>
(integer) 1<font></font>
&gt; ZADD lex-temperature 0 1589392164001:22<font></font>
(integer) 1<font></font>
&gt; ZADD lex-temperature 0 1589392165001:21<font></font>
(integer) 1<font></font>
&gt; ZRANGE lex-temperature 0 -1<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这三个ZADD调用中，时间戳记与值之间用冒号隔开，我们可以看到每次都返回1，这意味着所有三个都已添加。在ZRANGE中，我们看到已保存的订单。为什么？在排序集中，如果分数相同，则按二进制排序对具有相同分数的结果进行排序。由于此期间的时间戳具有相同的数字位数，因此所有内容都会正确排序（如果您的时间戳是2002年之前或2285年之后的，则需要更多数字来填充）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要从此类型获取值的范围，请使用ZRANGEBYLEX命令：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature (1511533200001 +<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个参数有一个前缀（表示值的排他性（包含性用[表示。）。在实践中，此格式使包含性和排他性无关紧要，因为时间戳总是跟在附加数据之后。第三个参数+表示上限的无边界。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尝试获取两者之间的日期） 1589392160001和1589392165001（含）：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature [1589392160001 [1589392165001<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管包含前缀，为什么时间戳数据1589392165001仍未进入样本？</font><font style="vertical-align: inherit;">我想相信Redis可以理解这是一个时间戳。</font><font style="vertical-align: inherit;">实际上，Redis只是看到二进制排序。</font><font style="vertical-align: inherit;">在二进制排序中，1589392165001：21大于1589392165001（包括或排除）。</font><font style="vertical-align: inherit;">将其包括在上限中的正确方法是将1毫秒添加到所需的上限并使用排他性：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature [1589392160001 (1589392165002<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
具有按字典顺序排序的集合的临时序列具有一组有用的命令，例如具有具有简单排序的集合的临时序列：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZRANGEBYLEX / ZREVRANGEBYLEX-以升序或降序获取一系列值;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZREMRANGEBYLEX-删除值的特定排序范围；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZLEXCOUNT-获取值的排序范围内的元素数。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZINTERSTORE和ZUNIONSTORE可以用于按字典顺序排序的集合，但存在数据丢失的风险，因为时间戳和值的重复组合不会在返回的结果中重复。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能想知道为什么选择带时间戳的排序集而不是按字典顺序排序的集进行编码。</font><font style="vertical-align: inherit;">通常，最好使用按时间顺序排列的字典集-如果值不总是唯一的，则时间戳会更有效。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位域时间序列</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis可以有效地将时间序列存储在位字段中。</font><font style="vertical-align: inherit;">为此，必须首先选择任意参考点和数字格式。</font><font style="vertical-align: inherit;">以温度测量为例。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设我们想每分钟进行一次温度测量，我们将每天的午夜设置为起点。</font><font style="vertical-align: inherit;">我们以摄氏度为单位测量室温。</font><font style="vertical-align: inherit;">您可以按以下方式组织数据：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0分钟=字节0;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">温度以8位无符号数字（0-255）写入。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一天的数据输入速度约为1.44 kb。</font><font style="vertical-align: inherit;">您可以使用BITFIELD命令记录温度：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #0 22<font></font>
1) (integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，使用bit-ts键将温度值22写入午夜（＃0）的无符号8位数字（u8），</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
位字段不限于无符号8位值。</font><font style="vertical-align: inherit;">注意偏移量之前的英镑符号。</font><font style="vertical-align: inherit;">这意味着将在所选类型上进行对齐。</font><font style="vertical-align: inherit;">例如，如果您指定“＃79”-这意味着第79个字节，“ 79”-第79位（请参阅BITFIELD帮助）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
偏移量可以根据存储的数字的类型（从0开始）进行对齐。例如，如果我们要写入凌晨1点，考虑零时隙，则在中午使用偏移量＃59或偏移量＃719。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #59 23 SET u8 #719 25<font></font>
1) (integer) 0<font></font>
2) (integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该示例还显示BITFIELD是可变的，即 </font><font style="vertical-align: inherit;">您可以在一个呼叫中使用多个值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
添加更多值：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #60 21 SET u8 #61 20<font></font>
1) (integer) 0<font></font>
2) (integer) 0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们将提取：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts GET u8 #59 GET u8 #60 GET u8 #61<font></font>
1) (integer) 23<font></font>
2) (integer) 21<font></font>
3) (integer) 20</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GET位子命令的签名与SET签名相似，唯一的区别是它不接受值作为第三个参数。</font><font style="vertical-align: inherit;">当我们知道需要获取的所有索引时，这是正常的，但是有时我们需要一个值范围，并且每个字节单独承受压力。</font><font style="vertical-align: inherit;">我们可以使用GETRANGE命令。</font><font style="vertical-align: inherit;">在正常情况下，它用于从字符串获取字节，但是BITFIELD只是寻址相同数据的另一种方法。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; GETRANGE bit-ts 59 61<font></font>
"\x17\x15\x14"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该命令以十六进制返回字节59到61（十进制分别为23、21和20.客户端语言比redis-cli更好地处理二进制数据，并且通常可以获得特定于语言的字节数组。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的示例中，我们使用字节0 ，59-61和719。如果我们请求尚未设置的字节会怎样？</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts GET u8 #40<font></font>
1) (integer) 0<font></font>
&gt; BITFIELD bit-ts GET u8 #750<font></font>
1) (integer) 0<font></font>
&gt; GETRANGE bit-ts 30 50<font></font>
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis将未指定的字节返回为0。这在处理时序数据时会造成困难-应用程序逻辑需要区分0和未定义的值。</font><font style="vertical-align: inherit;">舍入和丢失值为0是可能的，尤其是在使用带符号整数时，因为这可能是范围中间的有效值。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
时间序列的实际长度实际上取决于最后一个字节。</font><font style="vertical-align: inherit;">在该示例中，最后存储的字节为719，因此数据长度为720字节。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; STRLEN bit-ts<font></font>
(integer) 720</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基于BITFIELD的时间序列是用于存储数字或二进制数据的强大而紧凑的模式。</font><font style="vertical-align: inherit;">但是，此解决方案无法涵盖所有​​用例，因此应仔细考虑其使用以适应您的需求。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本带宽限制模式</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
借助INCR和EXPIRE命令，使用Redis创建带宽限制器很容易。</font><font style="vertical-align: inherit;">这个想法是，您希望在给定的时间内限制对特定服务的请求。</font><font style="vertical-align: inherit;">假设我们有一个通过API密钥标识用户的服务。</font><font style="vertical-align: inherit;">该服务每分钟最多只能请求20个请求。</font><font style="vertical-align: inherit;">为了实现这一点，我们希望每分钟在API密钥上创建一个Redis密钥。</font><font style="vertical-align: inherit;">为了不打乱数据库，密钥有效期也设置为1分钟。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
API密钥-zA21X31，粗体-已达到限制：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis密钥</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31：0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31：1</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31：2</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31：3</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31：4</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二十</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二十</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过期日期在</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:05</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:06</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:01</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></b></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
密钥由API密钥和冒号组成的分钟数组成。</font><font style="vertical-align: inherit;">由于密钥始终会过期，因此仅使用分钟数就足够了-随着新小时的开始，我们可以确定没有其他59个密钥（它们在59分钟前过期了）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看它是如何工作的：</font></font><br>
<br>
<ol>
<li><pre><code class="plaintext hljs">&gt; GET [ API]:[ ]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果结果小于或小于20，则执行步骤4，否则执行步骤3；否则，执行步骤3。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示错误信息，关闭连接并结束；</font></font></li>
<li><pre><code class="plaintext hljs">&gt; MULTI<font></font>
OK<font></font>
&gt; INCR [user-api-key]:[current minute number]<font></font>
QUEUED<font></font>
&gt; EXPIRE [user-api-key]:[current minute number] 59<font></font>
QUEUED<font></font>
&gt; EXEC<font></font>
OK</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">继续执行程序。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
两个要点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不存在的密钥上的INCR将始终为1；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPIRE与INCR一起位于MULTI事务中，这意味着它将是一个原子操作。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最坏的情况是，由于某种非常奇怪且不太可能的原因，Redis服务器在INCR和EXPIRE之间死亡。</font><font style="vertical-align: inherit;">从AOF或内存中的副本中恢复数据时，由于事务未完成，因此无法恢复INCR。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用此模式时，一个用户可能有两个键：一个正在使用中，另一个则在此刻到期。</font><font style="vertical-align: inherit;">但是，该模式非常有效。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">布隆过滤器</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
布隆过滤器是一个有趣的概率数据结构，可用于检查之前是否已添加项目。这是故意的措辞。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可能只有一个错误的肯定回应，而没有错误的否定回应。与将所有元素保存到集合中并调用SISMEMBER相比，Bloom Filter提供了一种更紧凑，更快捷的检查可用性的方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
布隆过滤器的工作原理是使元素通过快速哈希函数，从元素中选择位，并在位字段中以特定间隔将其设置为1和0。为了检查过滤器的存在，选择了相同的位。许多元素可能具有重叠的位，但是由于哈希函数会创建唯一的标识符，因此如果哈希中的一位仍然为0，那么我们知道它之前从未添加过。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis多年来一直作为客户端库使用过滤器，该客户端库使用GETBIT和SETBIT来处理位字段。幸运的是，Redis 4.0模块可从Redis 4.0中获得，从而无需创建自己的Bloom过滤器实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此过滤器的一个好用例是检查用户名是否已被使用。</font><font style="vertical-align: inherit;">小数据量没有问题，但是随着服务的增长，数据库查询可能会很昂贵。</font><font style="vertical-align: inherit;">使用ReBloom可以轻松解决此问题。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为测试添加一些名称：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BF.ADD usernames funnyfred<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames fredisfunny<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames fred<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames funfred<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在测试Bloom过滤器：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BF.EXISTS usernames fred<font></font>
(integer) 1<font></font>
&gt; BF.EXISTS usernames fred_is_funny<font></font>
(integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如预期的那样，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fred_is_funny</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回0。这意味着未使用该名称。</font><font style="vertical-align: inherit;">尽管无法确定地说，因为位可以简单地在几个元素之间重叠。</font><font style="vertical-align: inherit;">基本上，误报的可能性很小，但不是0。随着布隆过滤器填充，机会增加，但是您可以调整错误率和初始大小（分别默认为0.01和100）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计数器</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis中的计数器可以通过多种方式实现。</font><font style="vertical-align: inherit;">最明显的是INCR等人（INCRBY，INCRBYFLOAT，HINCRBY，HINCRBYFLOAT，ZINCRBY），只需阅读文档即可找到。</font><font style="vertical-align: inherit;">BITCOUNT和PFADD的使用不太明显。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位计数模式</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BITCOUNT通过键计算在位字段中设置为1的位数。</font><font style="vertical-align: inherit;">这可用于计算任意时间段内的一系列活动（类似于位字段上的时间序列模式）。</font><font style="vertical-align: inherit;">该过程是选择一个时间点，每个位代表一个周期单位。</font><font style="vertical-align: inherit;">在此期间内每次执行操作时，请与最后一点保持1个单位的距离运行SETBIT。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:00</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></th>
</tr>
<tr>
<td></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 2 1</code></pre></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 3 1</code></pre></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 4 1</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[初始点]</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">法案</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">法案</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">法案</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要计算从12:00到12:30的活动发生在什么时间，您可以执行以下操作：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITCOUNT btct 0 30<font></font>
(integer) 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，此模式回答了“多少次？”而不是“多少次？”的问题。</font><font style="vertical-align: inherit;">例如，用户可能在一分钟内处于活动状态20次，但这将被计为1。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此模板</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">真正优势在于，由于位是最基本的存储构造块，因此它在特定时间段内可提供最低的得分。</font><font style="vertical-align: inherit;">从字面上看，这是最小的（未压缩的）存储库。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超级日志</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
计算唯一项可能很棘手。这通常意味着存储每个唯一元素，然后以某种方式调用此信息。在Redis中，可以使用多个团队来完成此操作，但是，占用的时间量和时间都非常大。 HyperLogLog提供了一种概率选择。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HyperLogLog在内部类似于Bloom过滤器，它还通过非加密哈希函数提供元素，并在位字段中设置位。但是，与Bloom筛选器不同，HyperLogLog存储元素计数器，当添加以前从未添加的新元素时，该计数器会增加。当计算集合中的唯一元素时，这会降低错误率。 HyperLogLog内置在Redis中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis中有3个HyperLogLog命令：PFADD，PFCOUNT和PFMERGE。</font><font style="vertical-align: inherit;">假设我们创建了一个网络扫描仪，并希望计算当天所浏览页面的唯一URL数量。</font><font style="vertical-align: inherit;">对于每个页面，运行以下命令：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFADD crawled:20200613 "http://www.google.com/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200613 "http://www.redislabs.com/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200613 "http://www.redis.io/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200614 "http://www.redisearch.io/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200614 "http://www.redis.io/"<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上面的每个键均按天编制索引。</font><font style="vertical-align: inherit;">要查看在06/13/2020上查看了多少页，可以执行以下操作：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFCOUNT crawled:20200613<font></font>
(integer) 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要查看06/13/2020和06/14/2020的页数，请使用PFMERGE命令创建一个新密钥，该密钥的值将两个计数器结合在一起。</font><font style="vertical-align: inherit;">请注意，由于</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.redis.io</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都存储在两个集中，因此将只计算一次：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFMERGE crawled:20200613-14 crawled:20200613 crawled:20200614<font></font>
OK<font></font>
&gt; PFCOUNT crawled:20200613-14<font></font>
(integer) 4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此操作可以使用多个键，因此请在分开的环境中小心操作，以使键位于同一分片上。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lua脚本</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis可以通过“ redis-cli”完成惊人的工作，甚至可以在Redis和您的编程语言之间做更多的事情。但是有时由于效率或安全性问题，您可能需要在客户端-服务器体系结构中无法获得的行为-逻辑需要在数据库层中执行。在这种情况下，Lua进行了救援。 Lua在Redis中作为脚本语言工作。有了它，您可以在Redis中执行代码，而无需花费往返客户端的成本。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个测试用例正在向哈希字段添加一个值。</font><font style="vertical-align: inherit;">虽然Redis可以使用APPEND轻松地将值添加到字符串键，但是没有命令将值添加到哈希字段。</font><font style="vertical-align: inherit;">您可以尝试通过从客户端提取值，在值中添加新行并删除哈希字段来获取此值，但这不是一个好主意。</font><font style="vertical-align: inherit;">由于这是非原子性的，因此很可能在添加值时，另一个客户端可能会更早更改它，然后您将覆盖新值。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户1</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户2</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HGET myhash myfield</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[你好回报]</font></font></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[将“世界”添加到“你好”]</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HSET myhash myfield "goodbye"</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HSET myhash myfield "hello world"</code></pre></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; HGET myhash myfield</code></pre></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如您在第2行看到的那样，更新将丢失。</font><font style="vertical-align: inherit;">您可以使用Lua脚本解决此问题并消除从客户端发送/接收值的成本。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在任何文本编辑器中，创建一个脚本并调用它</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生了</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">local</span> original = redis.call(<span class="hljs-string">'HGET'</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>])
<span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">'HSET'</span>,KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], original .. ARGV[<span class="hljs-number">2</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一行中，创建一个局部变量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">original</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在其中保存传递的第一个参数中哈希键的当前值，而该字段是第一个非键参数。重要的是要了解运行时Lua脚本区分键和非键参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第二行中，为相同的键和字段调用HSET，然后将原始值与第二个非键参数组合在一起。这返回到Redis，因此我们将保留原始的HSET返回值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用EVAL命令直接执行Lua脚本可能会造成混乱并且效率低下。</font><font style="vertical-align: inherit;">Redis具有内置脚本缓存，可让您预加载脚本，然后使用主脚本中的SHA1哈希对其进行访问。</font><font style="vertical-align: inherit;">您可以使用“ cat”和“ redis-cli”从命令行下载此脚本。</font><font style="vertical-align: inherit;">请注意，如果您的脚本至少相差一个字符，则其哈希值将完全不同。</font></font><br>
<br>
<pre><code class="bash hljs">$ redis-cli -a yourRedisPassword SCRIPT LOAD <span class="hljs-string">"<span class="hljs-subst">$(cat ./happend.lua)</span>"</span>
<span class="hljs-string">"d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，您可以使用EVALSHA调用脚本并添加：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; HSET mynewhash greeting "Hello"<font></font>
(integer) 1<font></font>
&gt; EVALSHA d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099 1 mynewhash greeting " world"<font></font>
(integer) 0<font></font>
&gt; HGET mynewhash greeting<font></font>
"Hello world"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EVALSHA命令的第一个参数是SCRIPT LOAD生成的脚本的哈希。第二个参数是键的数量。在我们的案例中，关键是一个。第三个参数是执行操作的关键。最后，第四点是我们添加到字段中的值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于添加是在Lua脚本内部进行的，因此上述脚本将中止，因为Lua脚本是同步且原子地执行的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管Lua在解决问题上非常有帮助，但是您需要谨慎使用它。该脚本阻止了服务器，并可能导致数据库无响应。在分片情况下，脚本会尝试将所有操作保存在单个服务器上，以避免交叉错误。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是“ Redis最佳实践”部分的结尾。</font><font style="vertical-align: inherit;">不要害怕尝试和尝试，Redis功能非常丰富。</font><font style="vertical-align: inherit;">在注释中保留您有趣的用例。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我希望所描述的技术（如果不能直接帮助您）至少可以通过指出解决问题的正确方法来为您提供帮助！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN506574/index.html">使用Vue，WebGL和three.js可视化3d晶体形式的诺贝尔奖获得者女性名单</a></li>
<li><a href="../zh-CN506578/index.html">潜在客户数量</a></li>
<li><a href="../zh-CN506586/index.html">逻辑FizzBu​​zz</a></li>
<li><a href="../zh-CN506588/index.html">什么是算法！（第2部分）</a></li>
<li><a href="../zh-CN506590/index.html">英国DEVOXX会议。选择一个框架：Docker Swarm，Kubernetes或Mesos。第2部分</a></li>
<li><a href="../zh-CN506598/index.html">微软：Rust是安全系统编程行业中的“最佳机会”</a></li>
<li><a href="../zh-CN506600/index.html">在项目管理方面进行站点开发的合同（理论+样本）</a></li>
<li><a href="../zh-CN506604/index.html">并发和效率：Python与FSM</a></li>
<li><a href="../zh-CN506606/index.html">PIXI.js答题器的创建</a></li>
<li><a href="../zh-CN506610/index.html">WAL-G：PostgreSQL数据库备份和恢复</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>