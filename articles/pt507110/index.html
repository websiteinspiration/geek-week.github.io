<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏿 🍒 💡 Como encontrar erros em um projeto C #, trabalhando no Linux e macOS 🤙🏼 👍🏻 👨🏾‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O PVS-Studio é um analisador de código estático bem conhecido que permite encontrar muitos erros complicados ocultos na fonte. O teste beta da nova ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Como encontrar erros em um projeto C #, trabalhando no Linux e macOS</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/507110/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a2/607/d60/6a2607d60720993d5834a2c2e83a6bb1.png" alt="Quadro 8"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O PVS-Studio é um analisador de código estático bem conhecido que permite encontrar muitos erros complicados ocultos na fonte. </font><font style="vertical-align: inherit;">O teste beta da nova versão foi concluído recentemente, no qual é possível analisar projetos C # para Linux e macOS. </font><font style="vertical-align: inherit;">Além disso, o analisador agora pode ser integrado ao JetBrains Cross-Platform IDE - Rider. </font><font style="vertical-align: inherit;">Este artigo permitirá que você se familiarize com esses recursos no exemplo de verificação do projeto de código aberto RavenDB.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introdução</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há algum tempo, meu colega </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Vasiliev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escreveu uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nota</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre a abertura de um teste beta de uma nova versão do analisador estático PVS-Studio que estamos desenvolvendo. </font><font style="vertical-align: inherit;">Agora o teste beta está concluído e a nova versão pode ser baixada clicando no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">No mesmo artigo, examinaremos como analisar projetos C # no Linux / macOS usando a interface do console e o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Depois disso, conduziremos uma análise tradicional de algumas operações interessantes do analisador.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ravendb</font></font></h2><br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ec/dca/148/5ecdca148f1673576dcd824058b19e63.png" alt="Quadro 5"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para verificação, foi escolhido um projeto aberto do RavenDB, cujo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositório</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> totaliza quase 5 mil arquivos de código-fonte. </font><font style="vertical-align: inherit;">É um banco de dados NoSQL bastante popular. </font><font style="vertical-align: inherit;">Detalhes podem ser encontrados no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">É fácil adivinhar que fiquei atraído pelo tamanho, porque em um projeto tão grande e, sem dúvida, sério, provavelmente haverá algo interessante.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface da Linha de comando</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para começar, considere como analisar através do console. </font><font style="vertical-align: inherit;">Esta seção, na minha opinião, será especialmente interessante para aqueles que desejam integrar o analisador ao sistema de IC. </font><font style="vertical-align: inherit;">A equipe que inicia a análise tem várias opções interessantes, mas, no caso geral, tudo é bastante trivial. </font><font style="vertical-align: inherit;">Para analisar o RavenDB, vou para a pasta do projeto e insiro o seguinte no console:</font></font><br>
<br>
<pre><code class="cs hljs">pvs-studio-dotnet -t ./RavenDB.sln </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O sinalizador -t (abreviação de destino) é usado para especificar uma solução ou arquivo de projeto para verificação. </font><font style="vertical-align: inherit;">A linha apresentada acima inicia a análise e, como resultado do trabalho, forma um arquivo contendo os erros encontrados. </font><font style="vertical-align: inherit;">É simples, não é?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cavaleiro</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trabalhar com o analisador no Rider é praticamente o mesmo que no Visual Studio. </font><font style="vertical-align: inherit;">A interface simples e intuitiva do plugin permite que você verifique o projeto em apenas alguns cliques. </font><font style="vertical-align: inherit;">Isso não é um exagero - para realizar a análise do RavenDB, basta clicar no menu superior Ferramentas, apontar para “PVS-Studio” e clicar em “Verificar solução / projeto atual”.</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2c/105/bd4/a2c105bd4e20693c064b6c1a4f0dc9f5.png" alt="Quadro 2"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os resultados da análise serão exibidos na parte inferior da janela na guia PVS-Studio (bem, qual mais? :))</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a4/8d2/477/7a48d2477e60a0038e89c97dbd991406.png" alt="Quadro 3"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como no plug-in do Visual Studio, clicar duas vezes em um aviso exibirá o local ao qual está associado. Tudo é conveniente e compreensível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais importante, a ferramenta PVS-Studio não indica apenas erros, mas possui uma infraestrutura que facilita a implementação da metodologia de análise estática, mesmo em um grande projeto antigo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A ideia geral é a seguinte. O usuário iniciou o analisador e recebeu muitos avisos. Como um projeto desenvolvido por muitos anos está vivo, desenvolve e ganha dinheiro, provavelmente não haverá muitos avisos no relatório indicando defeitos críticos. Em outras palavras, os bugs críticos já foram corrigidos de uma maneira ou de outra de maneiras mais caras ou graças ao feedback dos clientes. Assim, tudo o que o analisador encontra agora pode ser considerado uma dívida técnica, o que é impraticável tentar eliminar imediatamente. É racional ignorar esses avisos por enquanto, mas escrever um novo código já executando análises regulares.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode dizer ao PVS-Studio para considerar esses avisos irrelevantes (adiar a dívida técnica para mais tarde) e não mostrá-los novamente. O analisador cria um arquivo especial onde armazena informações sobre erros desinteressantes até o momento. E agora o PVS-Studio emitirá avisos apenas em código novo ou alterado. Além disso, tudo isso é implementado de maneira inteligente. Se, por exemplo, uma linha vazia for adicionada ao início de um arquivo, o analisador entenderá que, de fato, nada mudou e permanecerá silencioso. Esse arquivo de marcação pode ser incorporado no sistema de controle de versão. O arquivo é grande, mas não é assustador, porque geralmente não faz sentido colocá-lo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora todos os programadores verão avisos relacionados apenas ao código novo ou alterado. Assim, o analisador pode começar a usar o que é chamado no dia seguinte. E será possível retornar à dívida técnica posteriormente, corrigir gradualmente os erros e configurar o analisador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para suprimir avisos sobre o código existente no Rider, basta ir ao menu superior em Ferramentas-&gt; PVS-Studio e clicar em "Suprimir todas as mensagens".</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/860/1eb/1d38601ebc120fa0c03d91df2237a8df.png" alt="Imagem 1"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na janela que aparece, avisando que todas as operações atuais se enquadram na lista de supressão, clique em "Ok". </font><font style="vertical-align: inherit;">Como resultado, um arquivo de supressão será criado na pasta do projeto, que será levada em consideração pelo analisador durante os trabalhos futuros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note-se que o Rider já possui um analisador que destaca com êxito alguns erros. </font><font style="vertical-align: inherit;">Assim, uma série de avisos do PVS-Studio aponta para um código que parece suspeito do ponto de vista do editor. </font><font style="vertical-align: inherit;">No entanto, o PVS-Studio frequentemente encontra erros que podem afastar os olhos sensíveis do analisador do JetBrains. </font><font style="vertical-align: inherit;">É por isso que a solução mais eficaz é permitir que eles trabalhem em equipe.</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/401/c23/d47/401c23d47c7f813c25acd347e7517482.png" alt="Quadro 10"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E para sobremesa</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, como prometido, consideraremos os avisos interessantes que o analisador exibiu de acordo com os resultados da verificação. O projeto contém um grande número de arquivos de código-fonte, portanto, não foi surpreendente encontrar muitos momentos suspeitos nele. Não há nada a ser feito - todos cometem erros, mas é importante fazer todos os esforços para detectá-los e corrigi-los em tempo hábil. A análise estática pode simplificar bastante essa tarefa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado da verificação, foram exibidos cerca de mil avisos:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a6/3d4/124/2a63d41242fd337aaff1753454f8a79c.png" alt="Quadro 11"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode ler mais sobre os níveis de aviso clicando no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, nem todos os gatilhos indicam erros super assustadores. </font><font style="vertical-align: inherit;">Se assim fosse, seria improvável que pelo menos algo funcionasse no projeto :). </font><font style="vertical-align: inherit;">Mas é importante entender que, se o analisador "xingar", o código parece estranho e deve ser cuidadosamente estudado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, o projeto encontrou muitos pontos positivos interessantes. </font><font style="vertical-align: inherit;">No entanto, eu não gostaria que o artigo fosse muito grande, portanto consideraremos apenas alguns deles.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apenas um cheque extra?</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EnsurePathExists</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> file</span>)</span><font></font>
{<font></font>
  <span class="hljs-keyword">var</span> dirpath = Path.GetDirectoryName(file);<font></font>
  List&lt;<span class="hljs-keyword">string</span>&gt; dirsToCreate = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;();
  <span class="hljs-keyword">while</span> (Directory.Exists(dirpath) == <span class="hljs-literal">false</span>)<font></font>
  {<font></font>
    dirsToCreate.Add(dirpath);<font></font>
    dirpath = Directory.GetParent(dirpath).ToString();<font></font>
    <span class="hljs-keyword">if</span> (dirpath == <span class="hljs-literal">null</span>)                                  <span class="hljs-comment">// &lt;=</span>
      <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
  dirsToCreate.ForEach(x =&gt; Directory.CreateDirectory(x));<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expressão </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">V3022</font></a><font style="vertical-align: inherit;"> 'dirpath == null' é sempre falsa. PosixHelper.cs (124) Voron </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta operação pode ser considerada de diferentes maneiras. Por um lado, é claro que um cheque extra não é muito bom, mas por si só não é um erro. Por outro lado, vale a pena considerar: esse código realmente funciona da maneira que o programador pretendia? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Talvez o desenvolvedor realmente não soubesse que o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nunca retornaria </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se não for assim, podemos fazer uma suposição sobre o que ele queria alcançar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Talvez a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interrupção</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deva ser chamada quando não for possível obter um pai para o diretório em questão. Nesse caso, verifique se há </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faz sentido. </font><font style="vertical-align: inherit;">No entanto, precisamos considerar não o resultado de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas o valor retornado pelo método </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetParent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cs hljs">dirsToCreate.Add(dirpath);
<span class="hljs-keyword">var</span> dir = Directory.GetParent(dirpath);    
<span class="hljs-keyword">if</span> (dir == <span class="hljs-literal">null</span>)
  <span class="hljs-keyword">break</span>;<font></font>
<font></font>
dirpath = dir.ToString();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caso contrário, retornar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com o método </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetParent lança</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uma exceção ao chamar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nulo típico</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">ScanOldest</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
  ....<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; copy.Length; i++)<font></font>
  {<font></font>
    <span class="hljs-keyword">var</span> item = copy[i].Value;
    <span class="hljs-keyword">if</span> (item != <span class="hljs-literal">null</span> || item == InvalidLowLevelTransaction) <span class="hljs-comment">// &lt;=</span><font></font>
    {<font></font>
      <span class="hljs-keyword">if</span> (val &gt; item.Id)                                    <span class="hljs-comment">// &lt;=</span><font></font>
        val = item.Id;<font></font>
    }<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3125</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O objeto 'item' foi usado após a verificação contra nulo. Verifique as linhas: 249, 247. ActiveTransactions.cs (249), ActiveTransactions.cs (247) Voron </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O código parece estranho devido ao que acontece quando o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">item é</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> realmente </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . De fato, se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InvalidLowLevelTransaction</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> também </font><i><font style="vertical-align: inherit;">for </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a condição será verdadeira e uma tentativa de obter </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">item.Id</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lançará uma exceção. E se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InvalidLowLevelTransaction</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não puder ser </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a condição " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">item == InvalidLowLevelTransaction</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"é simplesmente supérfluo. Isso ocorre porque ele é verificado apenas quando o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">item == null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Bem, se de repente o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">item</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não puder ser </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , toda a condição perde seu significado e adiciona aninhamento desnecessário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acho que aqui, talvez o operador lógico errado está selecionado. Se você substituir "||" por "&amp;&amp;" na condição, o código imediatamente começará a parecer lógico. Bem, nenhum problema pode surgir nesse caso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse plano é típico dos erros muito perigosos na teoria detectada pelo analisador Para ser justo, deve-se notar que o analisador incorporado no Rider também marca esse fragmento como potencialmente perigoso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro cheque de novo?</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteObjectEnd</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
  ....<font></font>
  <span class="hljs-keyword">if</span> (_continuationState.Count &gt; <span class="hljs-number">1</span>)<font></font>
  {<font></font>
    <span class="hljs-keyword">var</span> outerState = <font></font>
      _continuationState.Count &gt; <span class="hljs-number">0</span> ? _continuationState.Pop() : currentState<font></font>
    ;<font></font>
    <span class="hljs-keyword">if</span> (outerState.FirstWrite == <span class="hljs-number">-1</span>)<font></font>
      outerState.FirstWrite = start;<font></font>
    _continuationState.Push(outerState);<font></font>
  }  <font></font>
   ....<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expressão </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">V3022</font></a><font style="vertical-align: inherit;"> '_continuationState.Count&gt; 0' sempre é verdadeira. </font><font style="vertical-align: inherit;">ManualBlittableJsonDocumentBuilder.cs (152) Sparrow </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, na condição externa, verifica-se que o número de elementos na coleção é maior que 1 e, na próxima linha, o operador ternário verifica se o número é maior que 0. Parece que uma das verificações deve parecer diferente. </font><font style="vertical-align: inherit;">De uma forma ou de outra, esse código parece muito suspeito e deve ser cuidadosamente estudado e processado, se necessário.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Possível NRE</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitIndex</span>(<span class="hljs-params">IndexExpression node</span>)</span><font></font>
{<font></font>
  <span class="hljs-keyword">if</span> (node.Object != <span class="hljs-literal">null</span>)<font></font>
  {<font></font>
    Visit(node.Object);<font></font>
  }<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
    Out(node.Indexer.DeclaringType.Name); <span class="hljs-comment">// &lt;=</span><font></font>
  }<font></font>
  <span class="hljs-keyword">if</span> (node.Indexer != <span class="hljs-literal">null</span>)               <span class="hljs-comment">// &lt;=</span><font></font>
  {<font></font>
    Out(<span class="hljs-string">"."</span>);<font></font>
    Out(node.Indexer.Name);<font></font>
  }<font></font>
  VisitExpressions(<span class="hljs-string">'['</span>, node.Arguments, <span class="hljs-string">']'</span>);
  <span class="hljs-keyword">return</span> node;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3095</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O objeto 'node.Indexer' foi usado antes de ser verificado como nulo. Verifique as linhas: 1180, 1182. ExpressionStringBuilder.cs (1180), ExpressionStringBuilder.cs (1182) Raven.Client </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na verdade, esse é outro local que o PVS-Studio e o Rider consideram suspeitos. É verdade que a redação é um pouco diferente: o analisador do JetBrains apenas destaca o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node.Indexer.DeclaringType</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com o comentário “Possible NullReferenceException”. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambos os revisores afirmam que uma exceção pode realmente ser lançada nesse fragmento. Devo dizer que o aviso do PVS-Studio não apenas diz que um erro é possível aqui, mas também explica por que ele tinha essa opinião. Parece um pouco, mas legal.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na verdade, não é fato que realmente haja um erro. </font><font style="vertical-align: inherit;">É possível que, se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node.Object == null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node.Indexer esteja</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exatamente especificado. </font><font style="vertical-align: inherit;">Nesse caso, uma situação é permitida quando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node.Object</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node.Indexer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não </font><i><font style="vertical-align: inherit;">são </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Somente nesse caso a operação especificada de ambos os analisadores pode ser considerada falsa. </font><font style="vertical-align: inherit;">Portanto, vale a pena analisar cuidadosamente todas as opções possíveis.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E se você cavar mais fundo?</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">LoadStartingWithInternal</span>(<span class="hljs-params">....</span>)</span><font></font>
{<font></font>
  ....<font></font>
  <span class="hljs-keyword">var</span> command = operation.CreateRequest();
  <span class="hljs-keyword">if</span> (command != <span class="hljs-literal">null</span>)                       <span class="hljs-comment">// &lt;=</span><font></font>
  {<font></font>
    <span class="hljs-keyword">await</span> RequestExecutor<font></font>
      .ExecuteAsync(command, Context, SessionInfo, token)<font></font>
      .ConfigureAwait(<span class="hljs-literal">false</span>)<font></font>
    ;<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (stream != <span class="hljs-literal">null</span>)<font></font>
      Context.Write(stream, command.Result.Results.Parent);<font></font>
    <span class="hljs-keyword">else</span><font></font>
      operation.SetResult(command.Result);<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expressão </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">V3022</font></a><font style="vertical-align: inherit;"> 'command! = Null' sempre é verdadeira. AsyncDocumentSession.Load.cs (175) Raven.Client Um </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aviso é emitido porque o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método CreateRequest</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nunca retorna </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . De fato, basta olhar para o código para ver isso:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> GetDocumentsCommand <span class="hljs-title">CreateRequest</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
  _session.IncrementRequestCount();<font></font>
  <span class="hljs-keyword">if</span> (Logger.IsInfoEnabled)<font></font>
    Logger.Info(....);<font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GetDocumentsCommand(....);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, essa verificação não é um problema, embora possa ser que o método usado para retornar nulo em determinadas circunstâncias, mas agora emita uma exceção. </font><font style="vertical-align: inherit;">Quem sabe, é possível que, em vez dessa verificação de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , agora haja uma tentativa de captura. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode ter uma pergunta muito razoável: onde está a exceção lançada aqui? </font><font style="vertical-align: inherit;">Caso contrário, ainda temos uma verificação extra e não há erro aqui. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Porém, quando o método é executado, uma exceção pode ser lançada, além disso, duas vezes. </font><font style="vertical-align: inherit;">Primeiro no método </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IncrementRequestCount</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">IncrementRequestCount</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
  <span class="hljs-keyword">if</span> (++NumberOfRequests &gt; MaxNumberOfRequestsPerSession)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(....);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, no construtor de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetDocumentsCommand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GetDocumentsCommand</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> startWith, ....</span>)</span><font></font>
{<font></font>
  _startWith = startWith ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(startWith));<font></font>
  ....<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copiar e colar tradicional</font></font></h3><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteTo</span>(<span class="hljs-params">StringBuilder writer</span>)</span><font></font>
{<font></font>
  ....<font></font>
  <span class="hljs-keyword">if</span> (SqlConnectionStringsUpdated)<font></font>
    json[<span class="hljs-keyword">nameof</span>(SqlConnectionStringsUpdated)] = SqlConnectionStringsUpdated;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (ClientConfigurationUpdated)<font></font>
    json[<span class="hljs-keyword">nameof</span>(ClientConfigurationUpdated)] = ClientConfigurationUpdated;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (ConflictSolverConfigUpdated)<font></font>
    json[<span class="hljs-keyword">nameof</span>(ConflictSolverConfigUpdated)] = ClientConfigurationUpdated;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (PeriodicBackupsUpdated)<font></font>
    json[<span class="hljs-keyword">nameof</span>(PeriodicBackupsUpdated)] = PeriodicBackupsUpdated;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (ExternalReplicationsUpdated)<font></font>
    json[<span class="hljs-keyword">nameof</span>(ExternalReplicationsUpdated)] = ExternalReplicationsUpdated;<font></font>
  ....<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3127</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dois fragmentos de código semelhantes foram encontrados. Talvez seja um erro de digitação. SmugglerResult.cs (256), SmugglerResult.cs (253) Raven.Client </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Duvido muito que pelo menos alguém veja estranheza aqui, olhando o código. A função consiste em 14 condições semelhantes e todas as variáveis ​​terminam em Atualizado. Mesmo quando uma pequena parte é fornecida aqui, o erro não é imediatamente visível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O cérebro humano literalmente se recusa a procurar qualquer coisa nesse código. Ao mesmo tempo, o PVS-Studio descobriu facilmente que está atribuído, provavelmente, está completamente errado, deveria:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">if</span> (ClientConfigurationUpdated)<font></font>
    json[<span class="hljs-keyword">nameof</span>(ClientConfigurationUpdated)] = ClientConfigurationUpdated;<font></font>
<font></font>
<span class="hljs-keyword">if</span> (ConflictSolverConfigUpdated)<font></font>
    json[<span class="hljs-keyword">nameof</span>(ConflictSolverConfigUpdated)] = ClientConfigurationUpdated;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É lógico que a linha inferior à direita do operador de atribuição seja </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConflictSolverConfigUpdated</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Estou certo de que, sem a análise estática, essa singularidade seria encontrada apenas se algo sério o suficiente tivesse quebrado por causa disso. </font><font style="vertical-align: inherit;">O programador poderá perceber que um problema está oculto nessa função, a menos que ele saiba com antecedência.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oh aquilo "??"</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Count =&gt; <font></font>
  _documentsByEntity.Count + _onBeforeStoreDocumentsByEntity?.Count ?? <span class="hljs-number">0</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3123</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Talvez o '??' O operador trabalha de uma maneira diferente da esperada. Sua prioridade é menor que a prioridade de outros operadores na parte esquerda. InMemoryDocumentSessionOperations.cs (1952) Raven.Client </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, resta a possibilidade de que isso não seja um erro, é assim que ele foi planejado. E, no entanto, este lugar parece muito suspeito. Afinal, é lógico supor que a idéia da função não seja retornar 0 com </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_onBeforeStoreDocumentsByEntity == null.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Eu acho que realmente existe um erro relacionado às prioridades dos operadores. Nesse caso, você deve colocar os colchetes:</font></font><br>
<br>
<pre><code class="cs hljs">_documentsByEntity.Count + (_onBeforeStoreDocumentsByEntity?.Count ?? <span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, se de repente tudo estiver realmente planejado, talvez você deva apontar explicitamente - o analisador e os programadores que lêem o código não terão perguntas:</font></font><br>
<br>
<pre><code class="cs hljs">(_documentsByEntity.Count + _onBeforeStoreDocumentsByEntity?.Count) ?? <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas isso é uma questão de gosto, é claro.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passando parâmetros</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateEnvironmentVariableLicenseString</span>(<span class="hljs-params">....</span>)</span><font></font>
{<font></font>
  ....<font></font>
  <span class="hljs-keyword">if</span> (ValidateLicense(newLicense, rsaParameters, oldLicense) == <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">return</span>;<font></font>
  ....<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3066</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Possível ordem incorreta de argumentos transmitida para o método 'ValidateLicense': 'newLicense' e 'oldLicense'. </font><font style="vertical-align: inherit;">LicenseHelper.cs (177) Raven.Server Os </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
argumentos foram passados ​​para o método em ordem suspeita. </font><font style="vertical-align: inherit;">De fato, dê uma olhada no anúncio:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ValidateLicense</span>(<span class="hljs-params">
  License oldLicense, 
  RSAParameters rsaParameters, 
  License newLicense
</span>)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É muito agradável que o PVS-Studio seja capaz de encontrar até esses erros. </font><font style="vertical-align: inherit;">Este é um ótimo exemplo da questão dos benefícios da análise estática sobre a análise dinâmica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não obstante o exposto, sugeri inicialmente que não importa em que ordem esses argumentos são passados. </font><font style="vertical-align: inherit;">Obviamente, nesse caso, os nomes não teriam sido escolhidos corretamente, mas o que você pode fazer. </font><font style="vertical-align: inherit;">No entanto, a estrutura interna do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValidateLicense</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sugere que esses parâmetros ainda tenham significados diferentes. </font><font style="vertical-align: inherit;">O código desta função pode ser visualizado clicando no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nunca continuar</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;CounterOperation&gt; <span class="hljs-title">GetCounterOperationsFor</span>(<span class="hljs-params">RavenEtlItem item</span>)</span><font></font>
{<font></font>
  ....<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; counters.Count; i++)<font></font>
  {<font></font>
    counters.GetPropertyByIndex(i, <span class="hljs-keyword">ref</span> prop);<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (<font></font>
      GetCounterValueAndCheckIfShouldSkip(<font></font>
        item.DocumentId, <font></font>
        <span class="hljs-literal">null</span>, <font></font>
        prop, <font></font>
        <span class="hljs-keyword">out</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">value</span>, 
        <span class="hljs-keyword">out</span> <span class="hljs-keyword">bool</span> delete<font></font>
      )<font></font>
    ) <span class="hljs-keyword">continue</span>;<font></font>
    ....<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expressão </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">V3022</font></a><font style="vertical-align: inherit;"> 'GetCounterValueAndCheckIfShouldSkip (item.DocumentId, null, prop, valor longo, valor bool out)' é sempre falsa. RavenEtlDocumentTransformer.cs (362) Raven.Server </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse método pode ser totalmente considerado ao clicar no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um aviso indica que uma chamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contínua</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nesse loop é inacessível. E se sim, então o fragmento é realmente estranho. Mas talvez seja apenas um falso positivo? No entanto, Rider não jura sobre isso. </font><i><font style="vertical-align: inherit;">Dê uma</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
olhada no método </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetCounterValueAndCheckIfShouldSkip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GetCounterValueAndCheckIfShouldSkip</span>(<span class="hljs-params">
  LazyStringValue docId, 
  <span class="hljs-keyword">string</span> function, 
  BlittableJsonReaderObject.PropertyDetails prop, 
  <span class="hljs-keyword">out</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">value</span>, 
  <span class="hljs-keyword">out</span> <span class="hljs-keyword">bool</span> delete
</span>)</span><font></font>
{<font></font>
  <span class="hljs-keyword">value</span> = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (prop.Value <span class="hljs-keyword">is</span> LazyStringValue)<font></font>
  {<font></font>
    delete = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
    delete = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">value</span> = CountersStorage.InternalGetCounterValue(<font></font>
      prop.Value <span class="hljs-keyword">as</span> BlittableJsonReaderObject.RawBlob, <font></font>
      docId, <font></font>
      prop.Name<font></font>
    );<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (function != <span class="hljs-literal">null</span>)<font></font>
    {<font></font>
      <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> result = BehaviorsScript.Run(<font></font>
        Context, <font></font>
        Context, <font></font>
        function, <font></font>
        <span class="hljs-keyword">new</span> <span class="hljs-keyword">object</span>[] { docId, prop.Name }<font></font>
      ))<font></font>
      {<font></font>
        <span class="hljs-keyword">if</span> (result.BooleanValue != <span class="hljs-literal">true</span>)
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, esse método pode retornar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> somente se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">function</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">No código considerado anteriormente, exatamente o ponteiro nulo é passado para o local desse parâmetro. </font><font style="vertical-align: inherit;">Portanto, a chamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é </font><font style="vertical-align: inherit;">realmente inacessível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse momento pode ser uma omissão inofensiva e um problema associado a algum erro na condição. </font><font style="vertical-align: inherit;">De uma forma ou de outra, você deve prestar atenção a isso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Confie mas verifique</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> LicenseType Type<font></font>
{<font></font>
  <span class="hljs-keyword">get</span><font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (ErrorMessage != <span class="hljs-literal">null</span>)
      <span class="hljs-keyword">return</span> LicenseType.Invalid;<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (Attributes == <span class="hljs-literal">null</span>)
      <span class="hljs-keyword">return</span> LicenseType.None;<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (Attributes != <span class="hljs-literal">null</span> &amp;&amp;                             <span class="hljs-comment">// &lt;=</span>
        Attributes.TryGetValue(<span class="hljs-string">"type"</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">object</span> type) &amp;&amp;<font></font>
        type <span class="hljs-keyword">is</span> <span class="hljs-keyword">int</span><font></font>
    )<font></font>
    {<font></font>
      <span class="hljs-keyword">var</span> typeAsInt = (<span class="hljs-keyword">int</span>)type;
      <span class="hljs-keyword">if</span> (Enum.IsDefined(<span class="hljs-keyword">typeof</span>(LicenseType), typeAsInt))
        <span class="hljs-keyword">return</span> (LicenseType)typeAsInt;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> LicenseType.Community;<font></font>
  }<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3063</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma parte da expressão condicional sempre é verdadeira se for avaliada: Atributos! = Nulo. </font><font style="vertical-align: inherit;">LicenseStatus.cs (28) Raven.Server </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um fragmento extremamente estranho. </font><font style="vertical-align: inherit;">Normalmente, as verificações supérfluas são pelo menos de alguma forma separadas - aqui a correspondência da variável com o ponteiro nulo é verificada diretamente nas próximas linhas. </font><font style="vertical-align: inherit;">Parece que o código, muito provavelmente, não é exatamente o que o programador queria.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anulável que nunca é nulo</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">SuspendObserver</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
  <span class="hljs-keyword">if</span> (ServerStore.IsLeader())<font></font>
  {<font></font>
    <span class="hljs-keyword">var</span> suspend = GetBoolValueQueryString(<span class="hljs-string">"value"</span>);
    <span class="hljs-keyword">if</span> (suspend.HasValue)                                  <span class="hljs-comment">// &lt;=</span><font></font>
    {<font></font>
      Server.ServerStore.Observer.Suspended = suspend.Value;<font></font>
    }<font></font>
<font></font>
    NoContentStatus();<font></font>
    <span class="hljs-keyword">return</span> Task.CompletedTask;<font></font>
  }<font></font>
<font></font>
  RedirectToLeader();<font></font>
<font></font>
  <span class="hljs-keyword">return</span> Task.CompletedTask;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expressão V3022 'suspend.HasValue' sempre é verdadeira. </font><font style="vertical-align: inherit;">RachisAdminHandler.cs (116) Raven.Server </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra verificação "extra" aparentemente inofensiva. </font><font style="vertical-align: inherit;">Embora ainda não esteja claro por que o analisador considera isso. </font><i><font style="vertical-align: inherit;">Vá</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetBoolValueQueryString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">bool</span>? GetBoolValueQueryString(<span class="hljs-keyword">string</span> name, <span class="hljs-keyword">bool</span> required = <span class="hljs-literal">true</span>)<font></font>
{<font></font>
  <span class="hljs-keyword">var</span> boolAsString = GetStringQueryString(name, required);
  <span class="hljs-keyword">if</span> (boolAsString == <span class="hljs-literal">null</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">bool</span>.TryParse(boolAsString, <span class="hljs-keyword">out</span> <span class="hljs-keyword">bool</span> result) == <span class="hljs-literal">false</span>)<font></font>
    ThrowInvalidBoolean(name, boolAsString);<font></font>
<font></font>
  <span class="hljs-keyword">return</span> result;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, algumas vezes essa função retorna </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sim, e Rider não considerou essa verificação desnecessária. </font><font style="vertical-align: inherit;">O unicórnio falhou?</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/99d/ab6/34999dab64459aebc38561a25b2bad72.png" alt="Quadro 15"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas e se você olhar para o método </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetStringQueryString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ?</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">string</span> <span class="hljs-title">GetStringQueryString</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> name, <span class="hljs-keyword">bool</span> required = <span class="hljs-literal">true</span></span>)</span><font></font>
{<font></font>
  <span class="hljs-keyword">var</span> val = HttpContext.Request.Query[name];
  <span class="hljs-keyword">if</span> (val.Count == <span class="hljs-number">0</span> || <span class="hljs-keyword">string</span>.IsNullOrWhiteSpace(val[<span class="hljs-number">0</span>]))<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (required)<font></font>
      ThrowRequiredMember(name);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> val[<span class="hljs-number">0</span>];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hmm, se o parâmetro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necessário</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> == </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o método </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThrowRequiredMember</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> será chamado </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eu me pergunto o que ele faz? </font><font style="vertical-align: inherit;">:) Bem, de modo que certamente não resta dúvida:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ThrowRequiredMember</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> name</span>)</span><font></font>
{<font></font>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(
    <span class="hljs-string">$"Query string <span class="hljs-subst">{name}</span> is mandatory, but wasn't specified."</span><font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então, resumimos. O desenvolvedor chama o método </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetBoolValueQueryString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ele provavelmente acredita que potencialmente o método não obterá o valor necessário. Bem, como resultado, ele retorna </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dentro, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetStringQueryString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é </font><i><font style="vertical-align: inherit;">chamado</font></i><font style="vertical-align: inherit;"> . Em caso de problemas, ele retornará nulo ou lançará uma exceção. O segundo ocorre se o parâmetro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necessário</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estiver </font><font style="vertical-align: inherit;">definido como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Além disso, este é o seu valor padrão. Ao mesmo tempo, ao chamar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetBoolValueQueryString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , se você observar o código acima, não será transmitido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos mais uma vez o código do método </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SuspendObserver</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cujo fragmento foi jurado pelo analisador:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">SuspendObserver</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
  <span class="hljs-keyword">if</span> (ServerStore.IsLeader())<font></font>
  {<font></font>
    <span class="hljs-keyword">var</span> suspend = GetBoolValueQueryString(<span class="hljs-string">"value"</span>);
    <span class="hljs-keyword">if</span> (suspend.HasValue)<font></font>
    {<font></font>
      Server.ServerStore.Observer.Suspended = suspend.Value;<font></font>
    }<font></font>
<font></font>
    NoContentStatus();<font></font>
    <span class="hljs-keyword">return</span> Task.CompletedTask;<font></font>
  }<font></font>
<font></font>
  RedirectToLeader();<font></font>
<font></font>
  <span class="hljs-keyword">return</span> Task.CompletedTask;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que, por design, o segmento não deve ser interrompido aqui se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetBoolValueQueryString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não puder obter o valor. De fato, após um bloco com uma verificação de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , várias ações são executadas e um valor é retornado. Acredito que, por design, essas ações são executadas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">independentemente do</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sucesso do método </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetBoolValueQueryString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O que realmente vai acontecer? Um encadeamento de execução será interrompido por uma exceção. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para esse ponto correto, você precisa de uma chamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetBoolValueQueryString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pass como o segundo parâmetro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exigido</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> valor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Então tudo realmente funcionará como esperado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como eu disse anteriormente, às vezes parece que o analisador está errado (que pecado esconder, às vezes acontece). </font><font style="vertical-align: inherit;">Também com bastante frequência, o aviso parece insignificante. </font><font style="vertical-align: inherit;">Parece que há uma verificação extra aqui, e tudo bem. </font><font style="vertical-align: inherit;">Bem, ou melhor ainda - nós a removemos e sem problemas - o aviso desaparecerá! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mesmo nos casos em que a operação parece estranha e incompreensível, não a marque apressadamente como falsa. </font><font style="vertical-align: inherit;">Você precisa entender por que o analisador considera o local problemático e tomar uma decisão depois disso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extravagâncias</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">WriteDocumentsJsonAsync</span>(<span class="hljs-params">...., <span class="hljs-keyword">int</span> numberOfResults</span>) <span class="hljs-comment">// &lt;=</span></span><font></font>
{<font></font>
  <span class="hljs-keyword">using</span> (
    <span class="hljs-keyword">var</span> writer = <span class="hljs-keyword">new</span> AsyncBlittableJsonTextWriter(<font></font>
      context, <font></font>
      ResponseBodyStream(), <font></font>
      Database.DatabaseShutdown<font></font>
    )<font></font>
  )<font></font>
  {<font></font>
    writer.WriteStartObject();<font></font>
    writer.WritePropertyName(<span class="hljs-keyword">nameof</span>(GetDocumentsResult.Results));<font></font>
    numberOfResults = <span class="hljs-keyword">await</span> writer.WriteDocumentsAsync(                    <span class="hljs-comment">// &lt;=</span><font></font>
      context, <font></font>
      documentsToWrite, <font></font>
      metadataOnly<font></font>
    );<font></font>
<font></font>
    ....<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> numberOfResults;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3061 O</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parâmetro 'numberOfResults' sempre é reescrito no corpo do método antes de ser usado. </font><font style="vertical-align: inherit;">DocumentHandler.cs (273), DocumentHandler.cs (267) Raven.Server </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O parâmetro passado para a função não é usado, mas é imediatamente substituído. </font><font style="vertical-align: inherit;">Por que é necessário aqui? </font><font style="vertical-align: inherit;">Eles queriam passar por ref? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fiquei curioso para ver como esse método é usado no código existente. </font><font style="vertical-align: inherit;">Eu esperava que, uma vez que é privado, não deveria haver muitos deles. </font><font style="vertical-align: inherit;">Graças a Rider, encontrei facilmente onde a ligação é feita. </font><font style="vertical-align: inherit;">Este era o único lugar:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">GetDocumentsByIdAsync</span>(<span class="hljs-params">....</span>)</span><font></font>
{<font></font>
  ....            <font></font>
  <span class="hljs-keyword">int</span> numberOfResults = <span class="hljs-number">0</span>;<font></font>
<font></font>
  numberOfResults = <span class="hljs-keyword">await</span> WriteDocumentsJsonAsync(<font></font>
    context, <font></font>
    metadataOnly, <font></font>
    documents, <font></font>
    includes, <font></font>
    includeCounters?.Results, <font></font>
    numberOfResults<font></font>
  );<font></font>
<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A variável é atribuída 0 e, em seguida, é passada para o método, cujo resultado é atribuído a ela. </font><font style="vertical-align: inherit;">E dentro do método, este parâmetro não é usado de forma alguma. </font><font style="vertical-align: inherit;">Em. </font><font style="vertical-align: inherit;">Por que tudo isso?</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74a/e29/1cf/74ae291cf3c642aafc84c5bfce7ed18e.png" alt="Quadro 6"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operador lógico errado</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> OrderByField <span class="hljs-title">ExtractOrderByFromMethod</span>(<span class="hljs-params">....</span>)</span><font></font>
{<font></font>
  ....<font></font>
  <span class="hljs-keyword">if</span> (me.Arguments.Count &lt; <span class="hljs-number">2</span> &amp;&amp; me.Arguments.Count &gt; <span class="hljs-number">3</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidQueryException(....);<font></font>
  ....<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expressão </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">V3022</font></a><font style="vertical-align: inherit;"> 'me.Arguments.Count &lt;2 &amp;&amp; me.Arguments.Count&gt; 3' é sempre falsa. </font><font style="vertical-align: inherit;">Provavelmente o '||' </font><font style="vertical-align: inherit;">operador deve ser usado aqui. </font><font style="vertical-align: inherit;">QueryMetadata.cs (861) Raven.Server O </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
método completo pode ser visualizado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desta vez, temos um erro óbvio, que consiste em usar o operador lógico errado. </font><font style="vertical-align: inherit;">Em sua forma atual, verificar o número de argumentos simplesmente não funciona, porque não há valor menor que 2 e maior que 3. As verdadeiras intenções do desenvolvedor são facilmente reveladas pelo primeiro argumento passado ao construtor de exceção:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-string">"Invalid ORDER BY 'spatial.distance(from, to, roundFactor)' call, 
expected 2-3 arguments, got "</span> + me.Arguments.Count<font></font>
   ,    <span class="hljs-string">"&amp;&amp;"</span>  <span class="hljs-string">"||"</span>.</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Método de tentativa estranho</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Operator</span>(<span class="hljs-params">OperatorField fieldOption, <span class="hljs-keyword">out</span> QueryExpression op</span>)</span><font></font>
{ <font></font>
  ....<font></font>
  <span class="hljs-keyword">switch</span> (match)<font></font>
  {<font></font>
    ....<font></font>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"("</span>:
      <span class="hljs-keyword">var</span> isMethod = Method(field, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> method); <span class="hljs-comment">// &lt;=</span><font></font>
      op = method;<font></font>
<font></font>
      <span class="hljs-keyword">if</span> (isMethod &amp;&amp; Operator(OperatorField.Optional, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> methodOperator))<font></font>
      {<font></font>
        ....<font></font>
      }<font></font>
<font></font>
      <span class="hljs-keyword">return</span> isMethod;<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3063</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma parte da expressão condicional sempre é verdadeira se for avaliada: isMethod. QueryParser.cs (1797) Raven.Server O </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
método completo pode ser visto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A construção </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var isMethod = Method (campo, out var method)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> me lembrou métodos padrão como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Int.TryParse</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esses métodos tentam obter o resultado e gravá-lo na variável out, e o sinalizador do sucesso da operação é o valor de retorno. O código que utiliza essas funções geralmente verifica o valor de retorno e executa determinadas operações com base nele. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na minha opinião, a função </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Method</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usado aqui dessa maneira. O resultado do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , além disso, é o valor de retorno do método </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que o chama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O analisador indica que a variável </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isMethod</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sempre será </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verdadeira</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e sua verificação na condição não faz sentido. Isso significa que a função </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Método</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nunca retorna </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falso</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Qual é então o uso de tal construção? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para começar, verifique se o analisador não se enganou:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Method</span>(<span class="hljs-params">FieldExpression field, <span class="hljs-keyword">out</span> MethodExpression op</span>)</span><font></font>
{<font></font>
  <span class="hljs-keyword">var</span> args = ReadMethodArguments();<font></font>
<font></font>
  op = <span class="hljs-keyword">new</span> MethodExpression(field.FieldValue, args);
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, o valor de retorno desse método é sempre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verdadeiro</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . E se tudo foi planejado como era, então isso é estranho, mas não importa, em princípio. Mas e se não? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A função </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReadMethodArguments</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cujo código pode ser exibido </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lança exceções em alguns casos. Isso acontece quando um método não pode executar corretamente sua tarefa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que o código que chama a função </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Method</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não foi projetado para gerar exceções. Provavelmente, assume-se que, quando não for possível obter corretamente o valor da variável out, a função </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Method</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retornará </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . No entanto, com a implementação atual, uma exceção será lançada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seja como for, vale a pena prestar atenção a esse fragmento.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null! = null?</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> Address <span class="hljs-title">GetNextEdge</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
  <span class="hljs-keyword">if</span> (m_curEdgeBlock == <span class="hljs-literal">null</span> || m_curEdgeBlock.Count &lt;= m_curEdgeIdx)<font></font>
  {<font></font>
    m_curEdgeBlock = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (m_edgeBlocks.Count == <span class="hljs-number">0</span>)<font></font>
    {<font></font>
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationException(
        <span class="hljs-string">"Error not enough edge data.  Giving up on heap dump."</span><font></font>
      );<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">var</span> nextEdgeBlock = m_edgeBlocks.Dequeue();
    <span class="hljs-keyword">if</span> (<font></font>
      m_curEdgeBlock != <span class="hljs-literal">null</span> &amp;&amp;                       <span class="hljs-comment">// &lt;=</span>
      nextEdgeBlock.Index != m_curEdgeBlock.Index + <span class="hljs-number">1</span><font></font>
    )<font></font>
    {<font></font>
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationException(
        <span class="hljs-string">"Error expected Node Index "</span> + (m_curEdgeBlock.Index + <span class="hljs-number">1</span>) + 
        <span class="hljs-string">" Got "</span> + nextEdgeBlock.Index + <span class="hljs-string">" Giving up on heap dump."</span><font></font>
      );<font></font>
    }<font></font>
<font></font>
    m_curEdgeBlock = nextEdgeBlock;<font></font>
    m_curEdgeIdx = <span class="hljs-number">0</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> m_curEdgeBlock.Values(m_curEdgeIdx++).Target;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3063</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma parte da expressão condicional é sempre falsa se for avaliada: m_curEdgeBlock! = Null. </font><font style="vertical-align: inherit;">DotNetHeapDumpGraphReader.cs (803) Raven.Debug A </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
variável recebe um ponteiro nulo e, depois de algumas linhas, é verificada sua desigualdade </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nula</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nesse caso, o código que verifica </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nextEdgeBlock.Index! = M_curEdgeBlock.Index + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se torna sem sentido </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Além disso, uma exceção nunca será lançada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É lógico supor que algo não está funcionando como deveria, porque o fragmento parece muito estranho. </font><font style="vertical-align: inherit;">Ou a verificação não é necessária aqui, ou de alguma forma é implementada incorretamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode considerar o disparo e, por outro lado, seguir o oposto. </font><font style="vertical-align: inherit;">Vamos tentar imaginar uma situação em que essa resposta é falsa. </font><font style="vertical-align: inherit;">Eu acho que isso só é possível se o valor da variável puder ser alterado chamando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deque</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">No entanto, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_curEdgeBlock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é um campo privado e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_edgeBlocks</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é uma fila padrão que é inicializada na mesma classe. </font><font style="vertical-align: inherit;">Portanto, é altamente duvidoso que uma chamada para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desenfileirar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> possa de alguma forma afetar o valor de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_curEdgeBlock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Portanto, o gatilho provavelmente não é falso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro ou nulo</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> HashSet&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">FindSpecialColumns</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> tableSchema, <span class="hljs-keyword">string</span> tableName</span>)</span><font></font>
{<font></font>
  <span class="hljs-keyword">var</span> mainSchema = GetTable(tableSchema, tableName);<font></font>
<font></font>
  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-keyword">string</span>&gt;();<font></font>
  mainSchema.PrimaryKeyColumns.ForEach(x =&gt; result.Add(x)); <span class="hljs-comment">// &lt;=</span><font></font>
<font></font>
  <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fkCandidate <span class="hljs-keyword">in</span> Tables)
    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> tableReference <span class="hljs-keyword">in</span> fkCandidate.References.Where(<font></font>
        x =&gt; x.Table == tableName &amp;&amp; x.Schema == tableSchema<font></font>
      )<font></font>
    )<font></font>
    {<font></font>
      tableReference.Columns.ForEach(x =&gt; result.Add(x));<font></font>
    }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> result;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3146</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Possível desreferência nula de 'mainSchema'. O 'Tables.FirstOrDefault' pode retornar o valor nulo padrão. DatabaseSchema.cs (31) Raven.Server </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A </font><font style="vertical-align: inherit;">operação </font><font style="vertical-align: inherit;">, à primeira vista, pode parecer incompreensível. De fato, o que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FirstOrDefault</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tem a ver com </font><i><font style="vertical-align: inherit;">isso</font></i><font style="vertical-align: inherit;"> ? Para esclarecer por que o analisador jura, você precisa observar a função </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetTable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> TableSchema <span class="hljs-title">GetTable</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> schema, <span class="hljs-keyword">string</span> tableName</span>)</span><font></font>
{<font></font>
  <span class="hljs-keyword">return</span> Tables.FirstOrDefault(<font></font>
    x =&gt; x.Schema == schema &amp;&amp; x.TableName == tableName<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma chamada para o método </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FirstOrDefault em</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vez de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode ser devido ao fato de a coleção não conter elementos que correspondam à condição especificada. Nesse caso, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FirstOrDefault</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e, portanto, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetTable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retornará </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pois </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TableSchema</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é um tipo de referência. É por isso que o PVS-Studio diz que nesse código uma tentativa de desreferenciar um ponteiro nulo pode ocorrer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainda pode valer a pena verificar esse caso, para que a execução não seja interrompida com uma </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se a opção na qual </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables.FirstOrDefault</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retornar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null for</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> impossível, não há sentido em usar</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FirstOrDefault em</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vez de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sempre verdade</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VerifyCanExecuteCommand</span>(<span class="hljs-params">
  ServerStore store, TransactionOperationContext context, <span class="hljs-keyword">bool</span> isClusterAdmin
</span>)</span><font></font>
{<font></font>
  <span class="hljs-keyword">using</span> (context.OpenReadTransaction())<font></font>
  {<font></font>
    <span class="hljs-keyword">var</span> read = store.Cluster.GetCertificateByThumbprint(context, Name);
    <span class="hljs-keyword">if</span> (read == <span class="hljs-literal">null</span>)
      <span class="hljs-keyword">return</span>;<font></font>
<font></font>
    <span class="hljs-keyword">var</span> definition = JsonDeserializationServer.CertificateDefinition(read);
    <span class="hljs-keyword">if</span> (<font></font>
      definition.SecurityClearance != SecurityClearance.ClusterAdmin || <span class="hljs-comment">// &lt;=</span>
      definition.SecurityClearance != SecurityClearance.ClusterNode     <span class="hljs-comment">// &lt;=</span><font></font>
    )<font></font>
      <span class="hljs-keyword">return</span>;<font></font>
  }<font></font>
<font></font>
  AssertClusterAdmin(isClusterAdmin);<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso do analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expressão </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">V3022</font></a><font style="vertical-align: inherit;"> é sempre verdadeira. </font><font style="vertical-align: inherit;">Provavelmente o operador '&amp;&amp;' deve ser usado aqui. </font><font style="vertical-align: inherit;">DeleteCertificateFromClusterCommand.cs (21) Raven.Server </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro exemplo de situação em que o operador lógico errado provavelmente está selecionado. </font><font style="vertical-align: inherit;">Nesse caso, a condição é sempre verdadeira, porque a variável definitivamente não é igual a pelo menos um dos valores com os quais é comparada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu acredito que "||" </font><font style="vertical-align: inherit;">deve ser substituído por "&amp;&amp;". </font><font style="vertical-align: inherit;">Então os escritos farão sentido. </font><font style="vertical-align: inherit;">Se o operador lógico for escolhido corretamente, provavelmente uma das condições deve ser uma comparação de outras variáveis. </font><font style="vertical-align: inherit;">De um jeito ou de outro, esse fragmento parece muito suspeito e deve ser analisado.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de tudo, quero agradecer a todos que chegaram a este lugar. O artigo foi bastante longo, mas espero que você esteja interessado em trabalhar comigo para entender a nova versão do analisador PVS-Studio e estudar os erros encontrados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É importante lembrar que o desenvolvedor deve definir como seu principal objetivo não reduzir o número de operações. Não para obter um log de erros vazio, é necessário usar o PVS-Studio. Lutar contra os positivos é como combater os sintomas de uma doença da qual o código-fonte sofre.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao examinar as mensagens do analisador, você deve sempre tentar entender por que esse ou aquele aviso é emitido. </font><font style="vertical-align: inherit;">Somente realizando a lógica pela qual o analisador emitiu um aviso, podemos concluir se ele indica um erro ou não. </font><font style="vertical-align: inherit;">É neste caso que você não lutará com o sintoma, mas com a doença. </font><font style="vertical-align: inherit;">E é assim que seu código se tornará mais limpo e saudável. </font><font style="vertical-align: inherit;">E, é claro, haverá muito menos problemas com uma fonte tão boa. </font><font style="vertical-align: inherit;">Embora seja melhor eu desejo que você não os tenha :)</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/843/ca9/91e/843ca991e0e2688c6dc6a299fe3af231.png" alt="Quadro 16"></div><br>
<p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a></p><div style="text-align:center;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/eb2/f9c/3bb/eb2f9c3bb5f32f39239298d36431961c.png"></a></div><p></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você deseja compartilhar este artigo com um público que fala inglês, use o link para a tradução: Nikita Lipilin. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como encontrar erros em um projeto C # trabalhando no Linux e macOS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt507086/index.html">Converter script Bash em código C # para enviar SMS via modem usb HUAWEI E3372</a></li>
<li><a href="../pt507090/index.html">Como uma equipe de tecnologia pode construir sua startup ou o caminho do monitoramento funcional para a plataforma AIOps</a></li>
<li><a href="../pt507092/index.html">Convidamos você para o segundo Zapbix mitap on-line</a></li>
<li><a href="../pt507104/index.html">A grande divisão na importação: esclarecendo as incertezas com a importação no TypeScript</a></li>
<li><a href="../pt507106/index.html">Como é a implementação do DNS sobre HTTPS</a></li>
<li><a href="../pt507112/index.html">PayOnline | Aquisição de empresas pela Internet</a></li>
<li><a href="../pt507114/index.html">Ode Excel: 34 Anos de Magia</a></li>
<li><a href="../pt507116/index.html">"Udalenka". Notas do desenvolvedor do escritório de ontem. Parte 2</a></li>
<li><a href="../pt507124/index.html">O APO não é apenas pele valiosa</a></li>
<li><a href="../pt507132/index.html">Vladimir Kitov: "É impossível entender como os cientistas pioneiros previram a informatização universal nos anos 50!"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>