<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱🏼 ⚗️ ⛪️ pythonist的宏。Yandex报告 🙋 👷🏼 👠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="如何扩展Python语法并为其添加必要的功能？去年夏天，我在PyCon上试图阐明这个话题。从该报告中，您可以了解pytest，macropy，模式库的排列方式以及它们如何获得如此有趣的结果。最后，有一个使用HyLang（一种在Python之上运行的类似Lisp的语言）中的宏使用宏生成代码的示例。
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>pythonist的宏。Yandex报告</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/495294/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何扩展Python语法并为其添加必要的功能？</font><font style="vertical-align: inherit;">去年夏天，我在PyCon上试图阐明这个话题。</font><font style="vertical-align: inherit;">从该报告中，您可以了解pytest，macropy，模式库的排列方式以及它们如何获得如此有趣的结果。</font><font style="vertical-align: inherit;">最后，有一个使用HyLang（一种在Python之上运行的类似Lisp的语言）中的宏使用宏生成代码的示例。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/IMkvg45Vw70" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
- 嗨，大家好。</font><font style="vertical-align: inherit;">首先，我要感谢PyCon的组织者。</font><font style="vertical-align: inherit;">我是Yandex的开发人员。</font><font style="vertical-align: inherit;">该报告根本不是关于工作，而是关于实验性的事情。</font><font style="vertical-align: inherit;">也许他们会让你们中的一个人想到，在Python中您可以做一些您以前从未知道过，没朝这个方向思考的很棒的事情。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于那些不知道宏是什么的人来说，这有点：当这种语言中的某些表达式扩展为更复杂的代码时，这就是这种代码生成方法。</font><font style="vertical-align: inherit;">对您有什么好处？</font><font style="vertical-align: inherit;">对您来说，宏记录是简洁的，它表达了一些抽象，但是它为您做了很多工作，并且您不需要用手编写所有这些代码。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pytest</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您很有可能遇到了pytest测试框架，几乎可以肯定这里使用了它。我不知道你是否曾经注意到，但是在幕后，他也做了一些魔术。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/al/o6/qv/alo6qvpzofmabtejvqqojenx31a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，您有一个简单的测试。如果您在没有pytest的情况下运行它，那么它将简单地引发AssertionError。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ih/an/ck/ihanckzzqzelb5o87nfx9olt2vw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，我的例子有点退化，在这里很明显len是从三个元素的列表中获取的。但是，如果调用了某个函数，那么您将永远不会从这样的AssertionError中知道该函数返回了。她退还的东西不等于一百。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cu/ko/sa/cukosarqifegg5uvzo14xneczkc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果此程序在pytest下运行，则它将显示其他调试信息。他在里面怎么做？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6h/g9/vr/6hg9vr5nedvvkvzxlsupjqor71a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个魔术非常简单。 Pytest创建了自己的特殊钩子，当带有测试的模块加载时会触发。此后，pytest独立地解析此Python文件，并且作为解析的结果，获得了其中间表示形式，称为AST树。 AST树是一个基本概念，可让您即时更改Python代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接收到这样的树后，pytest对其进行强制转换，以查找所有称为assert的表达式。他以某种方式对其进行了更改，他编译了新的AST树，并获得了带有测试的模块，该模块随后在常规的Python虚拟机上运行。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t3/fj/x-/t3fjx-trld3abinbaqxioiizptg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是未转换为pytest的原始AST树的样子。</font><font style="vertical-align: inherit;">突出显示的红色区域是我们的断言。</font><font style="vertical-align: inherit;">如果仔细观察，您将看到它的左右部分，即列表本身。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当pytest转换并生成新的一年时，树开始看起来像这样。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yv/xh/qb/yvxhqbjsokha_vdwfn9-ksm0isi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pytest为您生成了大约一百行代码。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cu/fc/zi/cufczioilng0zfzx05nbrtwgl8g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果将此AST树转换回Python，它将看起来像这样。</font><font style="vertical-align: inherit;">pytest在此处以红色突出显示的区域是pytest计算表达式左右部分，生成错误消息并在此错误消息出问题的情况下引发AssertionError的地方。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式匹配</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样的事情你还能做什么？您可以转换任何Python代码。而且我在PyPI上偶然发现了一个很棒的库，在那儿挖掘很有趣。她进行模式匹配。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3k/yb/eq/3kybeqrilpfpqnvj4bmeon62ibm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也许这段代码是某人熟悉的。他递归地考虑阶乘。让我们看看如何使用模式匹配将其记录下来。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/cv/as/xycvassi6jwpp9getvm4sy4bbmm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，只需将装饰器挂在函数上即可。请注意：在体内，功能已经有所不同。这些if中的每一个都是用于模式匹配的规则，该规则解析输入到函数的表达式并以某种方式对其进行转换。而且，结果甚至没有明确的返回。因为模式库在转换函数主体时首先会检查它是否包含，其次才添加结果的隐式返回，从而改变语言的语义。也就是说，她制作了一个新的DSL，其工作方式略有不同。有了这个，您可以声明性地写下一些东西。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3k/yb/eq/3kybeqrilpfpqnvj4bmeon62ibm.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前一个功能好像写成三行。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/cv/as/xycvassi6jwpp9getvm4sy4bbmm.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/pj/fm/ux/pjfmuxf4zsl_zpppzidv9oirkim.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并且其余各行添加了其他功能，例如，允许从值列表中读取阶乘或将其传递给任意函数。 </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何自己编写转化？</font><font style="vertical-align: inherit;">宏！</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在您可能想知道，但是如何自己应用呢？因为这样做很麻烦，例如pytest：手动解析文件，所以需要查找需要转换的代码。在pytest中，一千个或更多行的单独模块执行此操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了不自己做，一些聪明的人已经为我们想出了一个名为macropy的模块。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该模块的版本适用于第二个Python和第三个Python。他们在第二个Python时代将其写回。然后，这两个家伙开了个玩笑，以弄清楚Python可以做什么，并且库中包含各种示例。让我们看一下它们，它们将使您了解使用此技术可以做什么。他们在本教程中描述的第一个很酷的东西是一个宏，该宏为第二个Python实现格式字符串，如第三个一样。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/er/3h/vv/er3hvvz7g-0edq1spxz5bukrk3q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用红色突出显示的表达式只是宏调用的语法。字母S是宏的名称，然后在方括号中是它转换的表达式。结果，变量在这里被替换。这在第二个Python中有效，但是在这样的宏中不再需要第三个。因此，例如，您可以制作自己的宏，该宏实现比标准格式字符串更复杂的语义和更有趣的事情。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jw/bf/hx/jwbfhxtuxzzrbjd-vvu3rhdsok8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当宏扩展时，并且这种情况发生在加载模块时，它只是转换为该代码。将占位符插入格式字符串，并对其应用替换过程。进一步的Python已经以一种标准的方式来编译所有这些。在运行时，不会发生宏扩展。所有这些都在模块加载时发生。因此，在这种情况下，您甚至可以进行优化或计算，这些优化或计算将在加载模块时进行，并生成更理想的字节码。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2i/gz/9t/2igz9tsitqjebyuxpln51mhknra.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个例子也很有趣。这是编写lambda的简写形式。宏f接受一系列参数，并返回一个函数。每个以宏名“ f”开头的表达式，方括号，然后绝对将任何表达式转换为lambda。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/l5/vq/ym/l5vqym-i-69vtjohomf2nsxfsj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我看来，这也很酷，特别是对于那些喜欢以功能风格开发和编写代码并使用MapReduce的人而言。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0j/fx/xc/0jfxxcdmblyze8e4bcxqrqrgaoy.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是另一个熟悉的示例。此功能认为是阶乘，代码以红色突出显示。她接到电话后会怎样？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ov/gj/v0/ovgjv0vqgcbzx0wxy5q-kuvozzg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它将在Python中引发错误，因为它将遇到堆栈限制，并且将出现难看的RecursionError。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wi/zz/1h/wizz1haarmzw9is0q0k3n_r6mji.jpeg" width="600"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何解决？使用宏，解决问题非常简单。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wc/ej/-n/wcej-na40treik2p0hkdp1jfbns.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您挂起装饰器，它将获取函数的主体并以某种神奇的方式对其进行转换。您不需要更改函数本身的任何内容，macropy会为您做所有事情。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xc/c8/ld/xcc8ldcmcykmbaxjceek4xsgrka.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并且该功能将返回到很正常的结果，并深入到地下。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ek/uq/mi/ekuqmigu-x5hhmdyyy8q04wob5c.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它的宏观表现如何？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fz/1r/5f/fz1r5ff8_v-egywcvufzvw-zsec.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它用一个特殊的TailCall对象替换了对该函数本身的所有调用，然后由TCO装饰器在循环中调用该对象。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dg/25/5b/dg255bb2t_mzo9ku4ucwq-uz31o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
电路看起来像这样。循环中的装饰器将调用该函数，直到返回正常结果而不是TailCall为止。如果她回来了，那就把它退回来。就这样。这些很酷的事情可以用宏来完成！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Macropy还包括其他示例。我希望那些对您感到好奇的人自己去看看。假设有些东西对调试有用。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/hg/rq/wdhgrqonz6lfdcicgdynvnfipfs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我会告诉你另一件事。这个查询宏就是一个例子。他在做什么？在其中编写常规的Python代码，然后将其用作执行此表达式的常规结果。但是在内部，macropy会将此代码转换为Alchemy SQL查询语言代码。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/qb/jk/agqbjkyzfbun_tbdnjxww5lutms.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他为您重写了它，使这个可怕的表情。可以用手重写它，然后它会更短。我做的。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4k/ts/5w/4kts5wogftqmpcceukufkib56be.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是原始表达。扩展宏后，它具有类似的功能。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/du/i0/uv/dui0uvfpouzuuioj2tmirtfyg5c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也许有人对编写更类似于Python的代码感兴趣，而不是强迫其开发人员在DSL SQL Alchemy上编写查询。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以相同的方式，您可以从Python生成任何东西-纯SQL，JavaScript-并将其保存在文件旁边的某个位置，然后在前端使用它。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kk/s3/j3/kks3j3s2wwep0vejhof8-3fw-oq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们看看如何制作自己的宏。使用macropy，这非常简单。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
宏是一种将AST树作为输入的函数，并通过某种方式对其进行转换，从而返回一个新的树。这是一个宏示例，该示例向包含源表达式的assert调用添加了描述，以便我们可以理解为何发生AssertionError错误。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，内部replace_assert函数是帮助器。她为您在树上进行递归下降。在replace_assert内部，传递了子树元素。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3u/qn/wa/3uqnwavrca79l0wumgmnfxfcm58.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，您可以在内部检查其类型以及？如果是Assert调用，请对其进行处理。在这里，我将给出一个简单的综合示例，该示例采用左侧部分，右侧部分，从它们中产生错误消息，并将所有内容写入msg属性。这是需要返回的消息。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/re/hn/rfrehnypphthxdzqbjwehtj3fas.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/va/ak/jm/vaakjmq4tpgqjwttqmi8nepgtym.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/x7/hq/cs/x7hqcswjuj59uhp5thatiojofja.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用它时，您可以使用with上下文管理器将这样的宏附加到代码块上，并且进入上下文管理器的所有代码都将经过此转换。从下面可以看出，我们的错误消息已添加到AssertionError中，该错误消息是由len表达式（[1,2,3]）形成的。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yo/zo/zc/yozozclanvtdlinutuvnl58puve.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，这种方法有一个局限性，使我个人感到难过。</font><font style="vertical-align: inherit;">我尝试做一个实验，以设计出适用于该语言的新设计。</font><font style="vertical-align: inherit;">例如，有些人喜欢开关或条件构造，除非。</font><font style="vertical-align: inherit;">但是不幸的是，这是不可能的：当已经读取源代码并将其分解为令牌时，将使用macropy和其他与AST树配合使用的工具。</font><font style="vertical-align: inherit;">该代码由Python解析器读取，其语法在解释器中固定。</font><font style="vertical-align: inherit;">要更改它，您需要重新编译Python。</font><font style="vertical-align: inherit;">当然，您可以执行此操作，但是它已经是Python的分支，而不是可以在PyPI上进行布局的库。</font><font style="vertical-align: inherit;">因此，不可能使用宏来进行这种构造。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">海朗</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸运的是，在我的一生中，我不仅用Python编写，而且对其他各种替代语言也很感兴趣。有许多人不喜欢的语法，但是更简单灵活。这些是s表达式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对我们来说幸运的是，有一个名为HyLang的Python插件。这个东西有点让人想起Clojure，只有Clojure运行在JVM之上，而HyLang运行在Python虚拟机之上。也就是说，它为您提供了用于编写代码的新语法。但是同时，您编写的所有代码将与现有的Python库完全兼容，并且可以在Python库中使用。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/54/sc/rr/54scrrucaeden67utnbyx3jva0i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看起来像这样。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qo/vr/w7/qovrw7a-mivofegxjhx61jtlky0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左边的部分用Python写，右边的部分-HyLang。从底部到底部都是字节码，这就是结果。您可能已经注意到它是完全一样的，只是语法有所变化。 HyLang s表达式，很多人都不喜欢。反对者不理解这种语法赋予了语言巨大的力量，因为它使语言结构统一。统一性使您可以使用宏来实现任何设计。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
之所以能够做到这一点，是因为在每个表达式中第一个元素始终是某种动作。然后他的论点去了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而且所有代码都是由嵌套表达式组成的，这些表达式易于转换并在其中打开宏。因此，绝对可以在HyLang中进行任何新的构造，并且与代码中的标准语言功能没有任何区别。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/o5/-u/rw/o5-urwww9tzewkt4ufq7krycxj8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看一个简单的宏如何在HyLang上工作。要执行与使用Macropy的Assert相同的操作，只需此代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的HyLang宏接收输入，即代码。此外，宏可以轻松使用此代码的任何部分来创建新代码。宏和函数之间的主要区别：表达式是输入，而不是值。如果我们将宏称为（is（= 1 2）），则它将收到一个表达式（= 1 2）而不是False。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/5b/az/uc5bazq37xtwjlsbaf54_kpe8zu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们可以生成错误消息，说明出现了问题。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hn/a9/cm/hna9cmzwxvf87k5e4i0py87cs84.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后只需返回新代码。反引号和波浪号语法的含义类似于以下内容。反引号说：将此表达式照原样返回原样。波浪号表示：在此替换变量的值。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pi/qn/en/piqnenjm28v8jm0i-hfsdx3ib18.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，当我们编写此代码时，宏在扩展时将返回给我们一个新的表达式，从而将其与其他错误消息一起声明。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HyLang很酷。</font><font style="vertical-align: inherit;">是的，虽然我们不使用它。</font><font style="vertical-align: inherit;">也许我们永远不会。</font><font style="vertical-align: inherit;">所有这些项目都是实验性的。</font><font style="vertical-align: inherit;">我希望您离开这里，感觉是在Python中您可以做一些您以前可能没有想到的事情。</font><font style="vertical-align: inherit;">也许其中一些会在您正在进行的工作中找到实际的应用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是我的全部。</font><font style="vertical-align: inherit;">您可以看到以下链接：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MacroPy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyLang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本书OnLisp-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对宏功能的高级研究。</font><font style="vertical-align: inherit;">这是针对那些特别感兴趣的人。</font><font style="vertical-align: inherit;">是的，这本书并不完全基于Python，而是基于Common Lisp。</font><font style="vertical-align: inherit;">但是对于更深入的研究，这甚至会很有趣。</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN495278/index.html">数据库，卡片，清单或业务知识管理员的原因</a></li>
<li><a href="../zh-CN495280/index.html">Max Patrol SIEM。信息安全事件管理系统概述</a></li>
<li><a href="../zh-CN495282/index.html">使用XSD，JAXB和Spring框架进行XML验证</a></li>
<li><a href="../zh-CN495290/index.html">探索Zephyr操作系统的代码质量</a></li>
<li><a href="../zh-CN495292/index.html">InterSystems IRIS 2020.1版本</a></li>
<li><a href="../zh-CN495296/index.html">取证，SQL注入和长期苦难：在线阶段NeoQUEST-2020的任务3的分析</a></li>
<li><a href="../zh-CN495298/index.html">评估Monte Carlo Clojure选项</a></li>
<li><a href="../zh-CN495302/index.html">如何在在线商店中在4个月内提高销售2.5倍-SEO推广案例</a></li>
<li><a href="../zh-CN495304/index.html">由于人类细胞的重编程而使其年轻化</a></li>
<li><a href="../zh-CN495308/index.html">踏上保持活力的道路</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>