<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèΩ ‚èπÔ∏è ‚òîÔ∏è C√≥mo se implementan las tuber√≠as de Unix üï† ‚òùüèø üìö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo describe la implementaci√≥n de tuber√≠as en el n√∫cleo de Unix. Estaba un poco decepcionado con un art√≠culo reciente titulado " ¬øC√≥mo funci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C√≥mo se implementan las tuber√≠as de Unix</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/495484/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/sl/9i/gesl9iqjuhatlmgyrdps28zgje0.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este art√≠culo describe la implementaci√≥n de tuber√≠as en el n√∫cleo de Unix. </font><font style="vertical-align: inherit;">Estaba un poco decepcionado con un art√≠culo reciente titulado " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo funcionan las tuber√≠as en Unix?" </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trataba del dispositivo interno. </font><font style="vertical-align: inherit;">Me interes√© y me enterr√© en las viejas fuentes para encontrar la respuesta.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øDe qu√© estamos hablando?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las tuber√≠as, "probablemente la invenci√≥n m√°s importante en Unix", es la caracter√≠stica definitoria de la filosof√≠a subyacente de Unix de combinar peque√±os programas, as√≠ como la l√≠nea de comandos familiar:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ echo hello | wc -c<font></font>
6<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta funcionalidad depende de la llamada al sistema proporcionada por el kernel </font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que se describe en las p√°ginas de documentaci√≥n de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pipe (7)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pipe (2)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los transportadores proporcionan un canal de comunicaci√≥n unidireccional entre procesos. </font><font style="vertical-align: inherit;">La canalizaci√≥n tiene una entrada (final de escritura) y una salida (final de lectura). </font><font style="vertical-align: inherit;">Los datos escritos en la entrada de la tuber√≠a se pueden leer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La canalizaci√≥n se crea mediante una llamada </font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que devuelve dos descriptores de archivo: uno se refiere a la entrada de la canalizaci√≥n, el segundo a la salida.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los resultados de seguimiento del comando anterior demuestran la creaci√≥n de una tuber√≠a y el flujo de datos a trav√©s de ella de un proceso a otro:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ strace -qf -e execve,pipe,dup2,read,write \<font></font>
    sh -c 'echo hello | wc -c'<font></font>
<font></font>
execve("/bin/sh", ["sh", "-c", "echo hello | wc -c"], ‚Ä¶)<font></font>
pipe([3, 4])                            = 0<font></font>
[pid 2604795] dup2(4, 1)                = 1<font></font>
[pid 2604795] write(1, "hello\n", 6)    = 6<font></font>
[pid 2604796] dup2(3, 0)                = 0<font></font>
[pid 2604796] execve("/usr/bin/wc", ["wc", "-c"], ‚Ä¶)<font></font>
[pid 2604796] read(0, "hello\n", 16384) = 6<font></font>
[pid 2604796] write(1, "6\n", 2)        = 2<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El proceso padre llama </font></font><code>pipe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para obtener los descriptores de archivo adjuntos. </font><font style="vertical-align: inherit;">Un proceso secundario escribe en un descriptor y otro proceso lee los mismos datos de otro descriptor. </font><font style="vertical-align: inherit;">El contenedor que usa dup2 "renombra" los descriptores 3 y 4 para que coincidan con stdin y stdout. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin tuber√≠as, el shell tendr√≠a que escribir el resultado de un proceso en un archivo y transferirlo a otro proceso para que lea los datos del archivo. </font><font style="vertical-align: inherit;">Como resultado, gastar√≠amos m√°s recursos y espacio en disco. </font><font style="vertical-align: inherit;">Sin embargo, las canalizaciones son buenas no solo porque evitan el uso de archivos temporales:</font></font><br>
<br>
<blockquote>      ,  <code>read(2)</code>    ,     .       ,  <code>write(2)</code>    ,           .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al igual que el requisito POSIX, esta es una propiedad importante: la escritura en la tuber√≠a de hasta </font></font><code>PIPE_BUF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytes (al menos 512) debe ser at√≥mica para que los procesos puedan interactuar entre s√≠ a trav√©s de la tuber√≠a de la misma manera que los archivos normales (que no ofrecen tales garant√≠as). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando se utiliza un archivo normal, un proceso puede escribirle todos sus datos de salida y transferirlo a otro proceso. </font><font style="vertical-align: inherit;">O los procesos pueden funcionar en modo de paralelizaci√≥n r√≠gida, utilizando un mecanismo de se√±alizaci√≥n externo (como un sem√°foro) para informarse mutuamente sobre la finalizaci√≥n de la escritura o la lectura. </font><font style="vertical-align: inherit;">Los transportadores nos salvan todos estos problemas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© estamos buscando?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo explicar√© con mis dedos para que te resulte m√°s f√°cil imaginar c√≥mo puede funcionar el transportador. </font><font style="vertical-align: inherit;">Necesitar√° asignar un b√∫fer y alg√∫n estado en la memoria. </font><font style="vertical-align: inherit;">Necesitar√° funciones para agregar y eliminar datos del b√∫fer. </font><font style="vertical-align: inherit;">Tomar√° algunos medios para llamar a las funciones durante las operaciones de lectura y escritura en los descriptores de archivo. </font><font style="vertical-align: inherit;">Y se necesitan bloqueos para implementar el comportamiento especial descrito anteriormente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora estamos listos para interrogar a la luz brillante de las l√°mparas el c√≥digo fuente del n√∫cleo para confirmar o refutar nuestro vago modelo mental. </font><font style="vertical-align: inherit;">Pero siempre prep√°rate para lo inesperado.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donde estamos buscando</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No s√© d√≥nde se encuentra mi copia del famoso libro " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lions book</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " con el c√≥digo fuente de Unix 6, pero gracias a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Unix Heritage Society</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puedes buscar en l√≠nea </font><font style="vertical-align: inherit;">incluso versiones anteriores de Unix </font><font style="vertical-align: inherit;">en el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√≥digo fuente</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recorrer los archivos de TUHS es similar a visitar un museo. </font><font style="vertical-align: inherit;">Podemos echar un vistazo a nuestra historia com√∫n, y respeto los muchos a√±os de esfuerzos por recuperar todos estos materiales poco a poco de casetes e impresiones antiguas. </font><font style="vertical-align: inherit;">Y soy muy consciente de esos fragmentos que a√∫n faltan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Habiendo satisfecho nuestra curiosidad con respecto a la historia antigua de los transportadores, podemos comparar los n√∫cleos modernos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, </font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es un n√∫mero de llamada del sistema 42 en la tabla </font></font><code>sysent[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">¬øCoincidencia?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Granos tradicionales de Unix (1970‚Äì1974)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No encontr√© rastro </font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDP-7 Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (enero de 1970), ni en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primera edici√≥n de Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (noviembre de 1971), ni en el c√≥digo fuente incompleto de la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segunda edici√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (junio de 1972). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TUHS afirma que la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tercera edici√≥n de Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (febrero de 1973) fue la primera versi√≥n con ductos:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tercera edici√≥n de Unix fue la √∫ltima versi√≥n con un n√∫cleo escrito en lenguaje ensamblador, pero la primera versi√≥n con canalizaciones. </font><font style="vertical-align: inherit;">Durante 1973, se trabaj√≥ para mejorar la tercera edici√≥n, el n√∫cleo se reescribi√≥ en C, por lo que apareci√≥ la cuarta edici√≥n de Unix.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uno de los lectores encontr√≥ un escaneo de un documento en el que Doug McIlroy propuso la idea de "conectar programas por el principio de una manguera de jard√≠n".</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6c/8c2/c8c/c6c8c2c8c5720d79227246af98c9b8d5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el libro de Brian Kernighan " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unix: una historia y una memoria</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", en la historia de la aparici√≥n de transportadores, este documento tambi√©n se menciona: "... colg√≥ en la pared de mi oficina en Bell Labs durante 30 a√±os". Aqu√≠ hay </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una entrevista con McIlroy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y otra historia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">del trabajo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">McIlroy escrito en 2014</font></a><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote>  Unix,        ,  ,  ,   - ,     ,       .  ,   . ,  ,  ,       .                ?           ¬´¬ª     , , -, : ¬´  !¬ª.<br>
<br>
 .        ,    ,       (    ),     .          .              .      API          ,      .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desafortunadamente, el c√≥digo fuente del kernel para la tercera edici√≥n de Unix se pierde. Y aunque tenemos el c√≥digo fuente para el n√∫cleo de la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuarta edici√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escrito en C </font><font style="vertical-align: inherit;">, lanzado en noviembre de 1973, fue lanzado unos meses antes del lanzamiento oficial y no contiene implementaciones de canalizaci√≥n. Es una pena que el c√≥digo fuente de la legendaria funci√≥n de Unix se pierda, posiblemente para siempre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos el texto de la documentaci√≥n </font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de ambas versiones, por lo que puede comenzar buscando en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tercera edici√≥n de la</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> documentaci√≥n </font><font style="vertical-align: inherit;">(para ciertas palabras, subrayadas "manualmente", una cadena de literales ^ H, ¬°seguido de guiones bajos!). Este protocolo est√° </font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escrito en ensamblador y devuelve solo un descriptor de archivo, pero ya proporciona la funcionalidad b√°sica esperada:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La llamada al sistema de </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tuber√≠as</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> crea un mecanismo de entrada de salida llamado tuber√≠a. </font><font style="vertical-align: inherit;">El descriptor de archivo devuelto se puede usar para operaciones de lectura y escritura. </font><font style="vertical-align: inherit;">Cuando se escribe algo en la tuber√≠a, se almacenan hasta 504 bytes de datos, despu√©s de lo cual se detiene el proceso de escritura. </font><font style="vertical-align: inherit;">Al leer desde una tuber√≠a, se toman datos almacenados en el b√∫fer.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al a√±o siguiente, el n√∫cleo se reescribi√≥ en C, y la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tuber√≠a (2) en la cuarta edici√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> encontr√≥ su aspecto moderno con el prototipo " </font></font><code>pipe(fildes)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">":</font></font><br>
<br>
<blockquote>  <i>pipe</i>    ,   .          .  -   ,   ,   r1 (. fildes[1]),    4096  ,     .     ,   r0 (. fildes[0]),  .<br>
<br>
,      ( )   (   <i>fork</i>)         <i>read</i>  <i>write</i>.<br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El shell tiene una sintaxis para definir una matriz lineal de procesos conectados a trav√©s de una tuber√≠a. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las llamadas de lectura de una tuber√≠a vac√≠a (que no contiene datos almacenados en el b√∫fer) que tiene un solo extremo (todos los descriptores de archivo de escritura est√°n cerrados) devuelven "fin de archivo". </font><font style="vertical-align: inherit;">La grabaci√≥n de llamadas en una situaci√≥n similar se ignora.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementaci√≥n de la tuber√≠a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√°s antigua que se </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">conserva</font></a><font style="vertical-align: inherit;"> data </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de la quinta edici√≥n de Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (junio de 1974), pero es casi id√©ntica a la que apareci√≥ en el pr√≥ximo lanzamiento. </font><font style="vertical-align: inherit;">Solo se agregaron comentarios, por lo que se puede omitir la quinta edici√≥n.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sexta edici√≥n de Unix (1975)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comenzamos a leer el c√≥digo fuente de la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sexta edici√≥n de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unix </font><font style="vertical-align: inherit;">(mayo de 1975). </font><font style="vertical-align: inherit;">En gran parte gracias a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lions,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> encontrarlo es mucho m√°s f√°cil que el c√≥digo fuente de versiones anteriores:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante muchos a√±os, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lions ha</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sido el √∫nico documento central de Unix disponible fuera de los muros de Bell Labs. </font><font style="vertical-align: inherit;">Aunque la licencia de la sexta edici√≥n permiti√≥ a los maestros usar su c√≥digo fuente, la licencia de la s√©ptima edici√≥n excluy√≥ esta posibilidad, por lo que el libro se distribuy√≥ en forma de copias ilegales escritas a m√°quina.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoy puede comprar una copia de reimpresi√≥n del libro, en cuya portada se muestran a los estudiantes en la fotocopiadora. Y gracias a Warren Tumi (quien lanz√≥ el proyecto TUHS), puede descargar el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archivo PDF con el c√≥digo fuente de la sexta edici√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Quiero darte una idea de cu√°nto esfuerzo tom√≥ crear el archivo:</font></font><br>
<br>
<blockquote> 15       ,   <i>Lions</i>,             . TUHS   ,         .   1988-      9 ,        PDP11.   ,   ,      /usr/src/,       1979- ,     .        PWB,   .<br>
<br>
            .     ,    ,    +=   =+. -  ,  -   ,    .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y hoy podemos leer en l√≠nea en TUHS el c√≥digo fuente de la sexta edici√≥n del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archivo, al que Dennis Ritchie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ech√≥ </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">una mano</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, a primera vista, la caracter√≠stica principal del c√≥digo C antes del per√≠odo Kernigan y Richie es su </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">brevedad</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . No tan a menudo, me las arreglo para incrustar fragmentos de c√≥digo sin una edici√≥n extensa para ajustar un √°rea de visualizaci√≥n relativamente estrecha en mi sitio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al comienzo de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/usr/sys/ken/pipe.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hay un comentario explicativo (y s√≠, tambi√©n hay </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ usr / sys / dmr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Max allowable buffering per pipe.<font></font>
 * This is also the max size of the<font></font>
 * file created to implement the pipe.<font></font>
 * If this size is bigger than 4096,<font></font>
 * pipes will be implemented in LARG<font></font>
 * files, which is probably not good.<font></font>
 */<font></font>
#define    PIPSIZ    4096<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tama√±o del b√∫fer no ha cambiado desde la cuarta edici√≥n. Pero aqu√≠, sin ninguna documentaci√≥n p√∫blica, ¬°vemos que una vez que las tuber√≠as utilizaron los archivos como almacenamiento de respaldo! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cuanto a los archivos LARG, corresponden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al indicador de inodo LARG</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que es utilizado por el "algoritmo de alto direccionamiento" para procesar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloques indirectos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para soportar sistemas de archivos m√°s grandes. Como Ken dijo que es mejor no usarlos, con mucho gusto aceptar√© su palabra. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ est√° la llamada real del sistema </font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * The sys-pipe entry.<font></font>
 * Allocate an inode on the root device.<font></font>
 * Allocate 2 file structures.<font></font>
 * Put it all together with flags.<font></font>
 */<font></font>
pipe()<font></font>
{<font></font>
    register *ip, *rf, *wf;<font></font>
    int r;<font></font>
<font></font>
    ip = ialloc(rootdev);<font></font>
    if(ip == NULL)<font></font>
        return;<font></font>
    rf = falloc();<font></font>
    if(rf == NULL) {<font></font>
        iput(ip);<font></font>
        return;<font></font>
    }<font></font>
    r = u.u_ar0[R0];<font></font>
    wf = falloc();<font></font>
    if(wf == NULL) {<font></font>
        rf-&gt;f_count = 0;<font></font>
        u.u_ofile[r] = NULL;<font></font>
        iput(ip);<font></font>
        return;<font></font>
    }<font></font>
    u.u_ar0[R1] = u.u_ar0[R0]; /* wf's fd */<font></font>
    u.u_ar0[R0] = r;           /* rf's fd */<font></font>
    wf-&gt;f_flag = FWRITE|FPIPE;<font></font>
    wf-&gt;f_inode = ip;<font></font>
    rf-&gt;f_flag = FREAD|FPIPE;<font></font>
    rf-&gt;f_inode = ip;<font></font>
    ip-&gt;i_count = 2;<font></font>
    ip-&gt;i_flag = IACC|IUPD;<font></font>
    ip-&gt;i_mode = IALLOC;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El comentario describe claramente lo que est√° sucediendo aqu√≠. Pero comprender el c√≥digo no es f√°cil, en parte debido a la forma con la ayuda de ¬´ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un usuario de estructura u</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª y registra </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>R1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transfiere par√°metros de llamadas al sistema y valores de retorno. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intentemos usar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ialloc () para</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> colocar el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inodo (inode </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">)</font></a><font style="vertical-align: inherit;"> en el disco </font><font style="vertical-align: inherit;">, y usar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fallo ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para colocar dos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archivos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la memoria </font><font style="vertical-align: inherit;">. Si todo va bien, estableceremos banderas para definir estos archivos como los dos extremos de la tuber√≠a, los se√±alaremos al mismo inodo (cuyo recuento de referencia ser√° 2) y marcaremos el inodo como modificado y utilizado. Presta atenci√≥n a las llamadas a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iput ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en rutas de error para disminuir el recuento de referencia en el nuevo inodo. </font></font><br>
<br>
<code>pipe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe completar </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>R1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devolver los n√∫meros de descriptor de archivo para leer y escribir. </font></font><code>falloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devuelve un puntero a la estructura del archivo, pero tambi√©n "devuelve" a trav√©s del </font></font><code>u.u_ar0[R0]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descriptor de archivo. Es decir, el c√≥digo se guarda en un </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descriptor de archivo para leer y asigna un descriptor para escribir directamente </font></font><code>u.u_ar0[R0]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">despu√©s de la segunda llamada </font></font><code>falloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El indicador </font></font><code>FPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que establecemos al crear la canalizaci√≥n controla el comportamiento de la funci√≥n </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rdwr () en sys2.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que llama a rutinas espec√≠ficas de E / S de E / S:</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * common code for read and write calls:<font></font>
 * check permissions, set base, count, and offset,<font></font>
 * and switch out to readi, writei, or pipe code.<font></font>
 */<font></font>
rdwr(mode)<font></font>
{<font></font>
    register *fp, m;<font></font>
<font></font>
    m = mode;<font></font>
    fp = getf(u.u_ar0[R0]);<font></font>
        /* ‚Ä¶ */<font></font>
<font></font>
    if(fp-&gt;f_flag&amp;FPIPE) {<font></font>
        if(m==FREAD)<font></font>
            readp(fp); else<font></font>
            writep(fp);<font></font>
    }<font></font>
        /* ‚Ä¶ */<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, la funci√≥n </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lee los datos de la tuber√≠a. </font><font style="vertical-align: inherit;">Pero es mejor comenzar con el seguimiento de la implementaci√≥n </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Una vez m√°s, el c√≥digo se volvi√≥ m√°s complicado debido a los detalles del acuerdo de transferencia de argumentos, pero se pueden omitir algunos detalles.</font></font><br>
<br>
<pre><code class="plaintext hljs">writep(fp)<font></font>
{<font></font>
    register *rp, *ip, c;<font></font>
<font></font>
    rp = fp;<font></font>
    ip = rp-&gt;f_inode;<font></font>
    c = u.u_count;<font></font>
<font></font>
loop:<font></font>
    /* If all done, return. */<font></font>
<font></font>
    plock(ip);<font></font>
    if(c == 0) {<font></font>
        prele(ip);<font></font>
        u.u_count = 0;<font></font>
        return;<font></font>
    }<font></font>
<font></font>
    /*<font></font>
     * If there are not both read and write sides of the<font></font>
     * pipe active, return error and signal too.<font></font>
     */<font></font>
<font></font>
    if(ip-&gt;i_count &lt; 2) {<font></font>
        prele(ip);<font></font>
        u.u_error = EPIPE;<font></font>
        psignal(u.u_procp, SIGPIPE);<font></font>
        return;<font></font>
    }<font></font>
<font></font>
    /*<font></font>
     * If the pipe is full, wait for reads to deplete<font></font>
     * and truncate it.<font></font>
     */<font></font>
<font></font>
    if(ip-&gt;i_size1 == PIPSIZ) {<font></font>
        ip-&gt;i_mode =| IWRITE;<font></font>
        prele(ip);<font></font>
        sleep(ip+1, PPIPE);<font></font>
        goto loop;<font></font>
    }<font></font>
<font></font>
    /* Write what is possible and loop back. */<font></font>
<font></font>
    u.u_offset[0] = 0;<font></font>
    u.u_offset[1] = ip-&gt;i_size1;<font></font>
    u.u_count = min(c, PIPSIZ-u.u_offset[1]);<font></font>
    c =- u.u_count;<font></font>
    writei(ip);<font></font>
    prele(ip);<font></font>
    if(ip-&gt;i_mode&amp;IREAD) {<font></font>
        ip-&gt;i_mode =&amp; ~IREAD;<font></font>
        wakeup(ip+2);<font></font>
    }<font></font>
    goto loop;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Queremos escribir bytes en la entrada de la tuber√≠a </font></font><code>u.u_count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primero necesitamos bloquear el inodo (ver abajo </font></font><code>plock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>prele</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego verifique el recuento de referencia de inodo. </font><font style="vertical-align: inherit;">Si bien ambos extremos de la tuber√≠a permanecen abiertos, el contador debe ser 2. Mantenemos un enlace (fuera </font></font><code>rp-&gt;f_inode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), por lo que si el contador es menor que 2, esto deber√≠a significar que el proceso de lectura ha cerrado su final de la tuber√≠a. </font><font style="vertical-align: inherit;">En otras palabras, estamos tratando de escribir en una tuber√≠a cerrada, y esto es un error. </font><font style="vertical-align: inherit;">El c√≥digo de error </font></font><code>EPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la se√±al </font></font><code>SIGPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aparecieron por </font><font style="vertical-align: inherit;">primera </font><font style="vertical-align: inherit;">vez en la sexta edici√≥n de Unix.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero incluso si el transportador est√° abierto, puede estar lleno. En este caso, retiramos el bloqueo y nos vamos a dormir con la esperanza de que otro proceso se lea desde la tuber√≠a y libere suficiente espacio en √©l. Habiendo despertado, volvemos al principio, nuevamente bloqueamos el bloqueo y comenzamos un nuevo ciclo de grabaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si hay suficiente espacio libre en la tuber√≠a, entonces le escribimos datos usando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">writei ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El par√°metro </font></font><code>i_size1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en inodo (con una tuber√≠a vac√≠a puede ser 0) indica el final de los datos que ya contiene. Si hay suficiente espacio de grabaci√≥n, podemos llenar el transportador desde </font></font><code>i_size1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasta</font></font><code>PIPESIZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Luego retiramos el bloqueo e intentamos despertar cualquier proceso que est√© esperando la oportunidad de leer desde la tuber√≠a. Volvemos al principio para ver si logramos escribir tantos bytes como sea necesario. Si falla, entonces comenzamos un nuevo ciclo de grabaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo general </font></font><code>i_mode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">se </font><font style="vertical-align: inherit;">usa un </font><font style="vertical-align: inherit;">par√°metro de </font><font style="vertical-align: inherit;">inodo para almacenar permisos </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pero en el caso de las tuber√≠as, indicamos que alg√∫n proceso est√° esperando escribir o leer usando bits </font></font><code>IREAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y, </font></font><code>IWRITE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">respectivamente. Un proceso establece una bandera y llama </font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y se espera que alg√∫n otro proceso llame en el futuro </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La verdadera magia ocurre en </font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se implementan en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slp.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la fuente del famoso comentario, "No se espera que entiendas esto". </font><font style="vertical-align: inherit;">Afortunadamente, no estamos obligados a comprender el c√≥digo, solo vea algunos comentarios:</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Give up the processor till a wakeup occurs<font></font>
 * on chan, at which time the process<font></font>
 * enters the scheduling queue at priority pri.<font></font>
 * The most important effect of pri is that when<font></font>
 * pri&lt;0 a signal cannot disturb the sleep;<font></font>
 * if pri&gt;=0 signals will be processed.<font></font>
 * Callers of this routine must be prepared for<font></font>
 * premature return, and check that the reason for<font></font>
 * sleeping has gone away.<font></font>
 */<font></font>
sleep(chan, pri) /* ‚Ä¶ */<font></font>
<font></font>
/*<font></font>
 * Wake up all processes sleeping on chan.<font></font>
 */<font></font>
wakeup(chan) /* ‚Ä¶ */<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un proceso que invoca </font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para un canal en particular puede ser despertado por otro proceso que invocar√° </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para el mismo canal. </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coordinar sus acciones a trav√©s de tales llamadas emparejadas. </font><font style="vertical-align: inherit;">Tenga en cuenta que </font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siempre se da prioridad </font></font><code>PPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al llamar </font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para que todos </font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puedan interrumpir la se√±al. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora tenemos todo para entender la funci√≥n </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">readp(fp)<font></font>
int *fp;<font></font>
{<font></font>
    register *rp, *ip;<font></font>
<font></font>
    rp = fp;<font></font>
    ip = rp-&gt;f_inode;<font></font>
<font></font>
loop:<font></font>
    /* Very conservative locking. */<font></font>
<font></font>
    plock(ip);<font></font>
<font></font>
    /*<font></font>
     * If the head (read) has caught up with<font></font>
     * the tail (write), reset both to 0.<font></font>
     */<font></font>
<font></font>
    if(rp-&gt;f_offset[1] == ip-&gt;i_size1) {<font></font>
        if(rp-&gt;f_offset[1] != 0) {<font></font>
            rp-&gt;f_offset[1] = 0;<font></font>
            ip-&gt;i_size1 = 0;<font></font>
            if(ip-&gt;i_mode&amp;IWRITE) {<font></font>
                ip-&gt;i_mode =&amp; ~IWRITE;<font></font>
                wakeup(ip+1);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        /*<font></font>
         * If there are not both reader and<font></font>
         * writer active, return without<font></font>
         * satisfying read.<font></font>
         */<font></font>
<font></font>
        prele(ip);<font></font>
        if(ip-&gt;i_count &lt; 2)<font></font>
            return;<font></font>
        ip-&gt;i_mode =| IREAD;<font></font>
        sleep(ip+2, PPIPE);<font></font>
        goto loop;<font></font>
    }<font></font>
<font></font>
    /* Read and return */<font></font>
<font></font>
    u.u_offset[0] = 0;<font></font>
    u.u_offset[1] = rp-&gt;f_offset[1];<font></font>
    readi(ip);<font></font>
    rp-&gt;f_offset[1] = u.u_offset[1];<font></font>
    prele(ip);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede que le resulte m√°s f√°cil leer esta funci√≥n de abajo hacia arriba. La rama "leer y volver" generalmente se usa cuando hay algunos datos en la tuber√≠a. En este caso, usamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readi () para</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> leer la mayor cantidad de datos disponibles a partir de la </font></font><code>f_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lectura </font><font style="vertical-align: inherit;">actual </font><font style="vertical-align: inherit;">, y luego actualizar el valor del desplazamiento correspondiente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En lecturas posteriores, la tuber√≠a estar√° vac√≠a si el desplazamiento de lectura ha alcanzado el valor del </font></font><code>i_size1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inodo. Restablecemos la posici√≥n a 0 e intentamos despertar cualquier proceso que quiera escribir en la tuber√≠a. Sabemos que cuando el transportador est√© lleno, se </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quedar√° dormido </font></font><code>ip+1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Y ahora que la tuber√≠a est√° vac√≠a, podemos despertarla para que reanude su ciclo de grabaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si no hay nada que leer, </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede establecer una bandera </font></font><code>IREAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y quedarse dormido</font></font><code>ip+2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sabemos lo que lo despertar√° </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando escriba algunos datos en la tuber√≠a. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los comentarios sobre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readi () y writei ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ayudar√°n a comprender que, en lugar de pasar par√°metros a trav√©s de " </font></font><code>u</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">", podemos tratarlos como funciones de E / S habituales que toman un archivo, posici√≥n, buffer en la memoria y cuentan la cantidad de bytes para leer o escribir .</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Read the file corresponding to<font></font>
 * the inode pointed at by the argument.<font></font>
 * The actual read arguments are found<font></font>
 * in the variables:<font></font>
 *    u_base        core address for destination<font></font>
 *    u_offset    byte offset in file<font></font>
 *    u_count        number of bytes to read<font></font>
 *    u_segflg    read to kernel/user<font></font>
 */<font></font>
readi(aip)<font></font>
struct inode *aip;<font></font>
/* ‚Ä¶ */<font></font>
<font></font>
/*<font></font>
 * Write the file corresponding to<font></font>
 * the inode pointed at by the argument.<font></font>
 * The actual write arguments are found<font></font>
 * in the variables:<font></font>
 *    u_base        core address for source<font></font>
 *    u_offset    byte offset in file<font></font>
 *    u_count        number of bytes to write<font></font>
 *    u_segflg    write to kernel/user<font></font>
 */<font></font>
writei(aip)<font></font>
struct inode *aip;<font></font>
/* ‚Ä¶ */<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cuanto a la cerradura "conservadora", a continuaci√≥n, </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloque de nodo-i durante el tiempo que terminan un trabajo o no consiguen el resultado (es decir, la causa </font></font><code>wakeup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><code>plock()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>prele()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funcionan de manera simple: utilizan un conjunto diferente de llamadas </font></font><code>sleep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>wakeup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nos permiten activar cualquier proceso que necesite un bloqueo que acabamos de eliminar:</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Lock a pipe.<font></font>
 * If its already locked, set the WANT bit and sleep.<font></font>
 */<font></font>
plock(ip)<font></font>
int *ip;<font></font>
{<font></font>
    register *rp;<font></font>
<font></font>
    rp = ip;<font></font>
    while(rp-&gt;i_flag&amp;ILOCK) {<font></font>
        rp-&gt;i_flag =| IWANT;<font></font>
        sleep(rp, PPIPE);<font></font>
    }<font></font>
    rp-&gt;i_flag =| ILOCK;<font></font>
}<font></font>
<font></font>
/*<font></font>
 * Unlock a pipe.<font></font>
 * If WANT bit is on, wakeup.<font></font>
 * This routine is also used to unlock inodes in general.<font></font>
 */<font></font>
prele(ip)<font></font>
int *ip;<font></font>
{<font></font>
    register *rp;<font></font>
<font></font>
    rp = ip;<font></font>
    rp-&gt;i_flag =&amp; ~ILOCK;<font></font>
    if(rp-&gt;i_flag&amp;IWANT) {<font></font>
        rp-&gt;i_flag =&amp; ~IWANT;<font></font>
        wakeup(rp);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al principio no pude entender por qu√© </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no llam√≥ </font></font><code>prele(ip)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antes de la llamada </font></font><code>wakeup(ip+1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lo primero que </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">causa en su bucle es que </font></font><code>plock(ip)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conduce a un punto muerto si </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a√∫n no ha eliminado su bloqueo, por lo que el c√≥digo debe funcionar de alguna manera correctamente. Si lo miras </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, queda claro que solo marca el proceso de suspensi√≥n como listo para la ejecuci√≥n, de modo que en el futuro </font></font><code>sched()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente lo inicie. Entonces </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">causa </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, desbloquea, establece </font></font><code>IREAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y llama </font></font><code>sleep(ip+2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, todo esto antes de </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reanudar el ciclo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto completa la descripci√≥n de los transportadores en la sexta edici√≥n. C√≥digo simple, consecuencias de largo alcance. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S√©ptima Edici√≥n de Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Enero de 1979) fue la nueva versi√≥n principal (cuatro a√±os despu√©s), en la que aparecieron muchas aplicaciones nuevas y propiedades del n√∫cleo. </font><font style="vertical-align: inherit;">Adem√°s, se han producido cambios significativos en relaci√≥n con el uso de fundici√≥n de tipos, union'ov y punteros mecanografiados a las estructuras. </font><font style="vertical-align: inherit;">Sin embargo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el c√≥digo de la tuber√≠a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no ha cambiado mucho. </font><font style="vertical-align: inherit;">Podemos omitir esta edici√≥n.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xv6, un n√∫cleo simple en forma de Unix</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La </font><font style="vertical-align: inherit;">sexta edici√≥n de Unix influy√≥ en la </font><font style="vertical-align: inherit;">creaci√≥n del n√∫cleo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xv6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero est√° escrito en C moderno para ejecutarse en procesadores x86. El c√≥digo es f√°cil de leer, est√° claro. Adem√°s, a diferencia de las fuentes Unix con TUHS, puede compilarlo, modificarlo y ejecutarlo en otra cosa adem√°s de PDP 11/70. Por lo tanto, este n√∫cleo es ampliamente utilizado en las universidades como material educativo sobre sistemas operativos. Las fuentes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est√°n en Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El c√≥digo contiene una implementaci√≥n clara y bien pensada de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pipe.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , respaldada por un b√∫fer en la memoria en lugar de un inodo en el disco. Aqu√≠ solo doy la definici√≥n de "tuber√≠a estructural" y funci√≥n </font></font><code>pipealloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">#define PIPESIZE 512<font></font>
<font></font>
struct pipe {<font></font>
  struct spinlock lock;<font></font>
  char data[PIPESIZE];<font></font>
  uint nread;     // number of bytes read<font></font>
  uint nwrite;    // number of bytes written<font></font>
  int readopen;   // read fd is still open<font></font>
  int writeopen;  // write fd is still open<font></font>
};<font></font>
<font></font>
int<font></font>
pipealloc(struct file **f0, struct file **f1)<font></font>
{<font></font>
  struct pipe *p;<font></font>
<font></font>
  p = 0;<font></font>
  *f0 = *f1 = 0;<font></font>
  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)<font></font>
    goto bad;<font></font>
  if((p = (struct pipe*)kalloc()) == 0)<font></font>
    goto bad;<font></font>
  p-&gt;readopen = 1;<font></font>
  p-&gt;writeopen = 1;<font></font>
  p-&gt;nwrite = 0;<font></font>
  p-&gt;nread = 0;<font></font>
  initlock(&amp;p-&gt;lock, "pipe");<font></font>
  (*f0)-&gt;type = FD_PIPE;<font></font>
  (*f0)-&gt;readable = 1;<font></font>
  (*f0)-&gt;writable = 0;<font></font>
  (*f0)-&gt;pipe = p;<font></font>
  (*f1)-&gt;type = FD_PIPE;<font></font>
  (*f1)-&gt;readable = 0;<font></font>
  (*f1)-&gt;writable = 1;<font></font>
  (*f1)-&gt;pipe = p;<font></font>
  return 0;<font></font>
<font></font>
 bad:<font></font>
  if(p)<font></font>
    kfree((char*)p);<font></font>
  if(*f0)<font></font>
    fileclose(*f0);<font></font>
  if(*f1)<font></font>
    fileclose(*f1);<font></font>
  return -1;<font></font>
}<font></font>
</code></pre><br>
<code>pipealloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">establece el estado del resto de la implementaci√≥n, que incluye funciones </font></font><code>piperead()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>pipewrite()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>pipeclose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La llamada real del sistema </font></font><code>sys_pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es un contenedor implementado en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sysfile.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Recomiendo leer todo su c√≥digo. </font><font style="vertical-align: inherit;">La complejidad est√° en el nivel de origen de la sexta edici√≥n, pero es mucho m√°s f√°cil y m√°s agradable de leer.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 0.01</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede encontrar el c√≥digo fuente para Linux 0.01. </font><font style="vertical-align: inherit;">Ser√° instructivo estudiar la implementaci√≥n de tuber√≠as en su </font></font><code>fs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aqu√≠, el inodo se usa para representar la tuber√≠a, pero la tuber√≠a en s√≠ est√° escrita en C. moderna. Si superaste el c√≥digo de la sexta edici√≥n, no experimentar√°s dificultades. </font><font style="vertical-align: inherit;">As√≠ es como se ve la funci√≥n </font></font><code>write_pipe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">int write_pipe(struct m_inode * inode, char * buf, int count)<font></font>
{<font></font>
    char * b=buf;<font></font>
<font></font>
    wake_up(&amp;inode-&gt;i_wait);<font></font>
    if (inode-&gt;i_count != 2) { /* no readers */<font></font>
        current-&gt;signal |= (1&lt;&lt;(SIGPIPE-1));<font></font>
        return -1;<font></font>
    }<font></font>
    while (count--&gt;0) {<font></font>
        while (PIPE_FULL(*inode)) {<font></font>
            wake_up(&amp;inode-&gt;i_wait);<font></font>
            if (inode-&gt;i_count != 2) {<font></font>
                current-&gt;signal |= (1&lt;&lt;(SIGPIPE-1));<font></font>
                return b-buf;<font></font>
            }<font></font>
            sleep_on(&amp;inode-&gt;i_wait);<font></font>
        }<font></font>
        ((char *)inode-&gt;i_size)[PIPE_HEAD(*inode)] =<font></font>
            get_fs_byte(b++);<font></font>
        INC_PIPE( PIPE_HEAD(*inode) );<font></font>
        wake_up(&amp;inode-&gt;i_wait);<font></font>
    }<font></font>
    wake_up(&amp;inode-&gt;i_wait);<font></font>
    return b-buf;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incluso sin mirar las definiciones de estructuras, puede descubrir c√≥mo se usa el contador de referencia de inodo para verificar si la operaci√≥n de escritura conduce </font></font><code>SIGPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Adem√°s del trabajo de bytes, esta funci√≥n se correlaciona f√°cilmente con las ideas anteriores. </font><font style="vertical-align: inherit;">Incluso la l√≥gica </font></font><code>sleep_on</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>wake_up</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se ve tan extra√±a.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√∫cleos modernos de Linux, FreeBSD, NetBSD, OpenBSD</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R√°pidamente revis√© algunos n√∫cleos modernos. Ninguno de ellos ya tiene una implementaci√≥n de disco (no es sorprendente). Linux tiene su propia implementaci√≥n. Aunque los tres n√∫cleos BSD modernos contienen implementaciones basadas en c√≥digo escrito por John Dyson, a lo largo de los a√±os se han vuelto demasiado diferentes entre s√≠. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para leer </font></font><code>fs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(en Linux) o </font></font><code>sys</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>kern</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>sys_pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(en * BSD), se requiere una verdadera dedicaci√≥n. El rendimiento y el soporte para funciones como vector y E / S as√≠ncrona son importantes en el c√≥digo actual. Y los detalles de asignaci√≥n de memoria, bloqueos y configuraci√≥n del kernel: todo esto es muy diferente. Esto no es lo que las universidades necesitan para un curso introductorio sobre sistemas operativos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cualquier caso, fue interesante para m√≠ descubrir varios patrones antiguos (por ejemplo, generar </font></font><code>SIGPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y volver </font></font><code>EPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al escribir en una tuber√≠a cerrada) en todos estos n√∫cleos modernos tan diferentes. </font><font style="vertical-align: inherit;">Probablemente nunca ver√© una computadora PDP-11 en vivo, pero todav√≠a hay mucho que aprender del c√≥digo que fue escrito unos a√±os antes de mi nacimiento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escrito por Divi Kapoor en 2011, el art√≠culo " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La implementaci√≥n del kernel de Linux de tuber√≠as y FIFOs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " proporciona una visi√≥n general de c√≥mo funcionan (hasta ahora) las tuber√≠as en Linux. </font><font style="vertical-align: inherit;">Y la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reciente confirmaci√≥n de Linux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ilustra un modelo de interacci√≥n canalizado cuyas capacidades exceden las capacidades de los archivos temporales; </font><font style="vertical-align: inherit;">y tambi√©n muestra cu√°n lejos han ido las tuber√≠as del "bloqueo muy conservador" en la sexta edici√≥n del kernel de Unix.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es495472/index.html">Cambiar al vegetarianismo no evitar√° que las personas se infecten por enfermedades como COVID-19</a></li>
<li><a href="../es495474/index.html">DataGrip 2020.1: iniciar configuraciones, exportar a Excel, resultados en el editor y m√°s</a></li>
<li><a href="../es495476/index.html">¬øPor qu√© el √©xito de Atari DeepMind AI es decepcionante?</a></li>
<li><a href="../es495478/index.html">Probador de datos grandes y peque√±os: tendencias, teor√≠a, mi historia</a></li>
<li><a href="../es495480/index.html">Crear enlaces de Python para bibliotecas C / C ++ usando SIP. Parte 1</a></li>
<li><a href="../es495486/index.html">Nuevas amenazas a los datos confidenciales: resultados de la encuesta global de Acronis</a></li>
<li><a href="../es495490/index.html">Secci√≥n de pruebas y control de calidad en la conferencia DUMP 2020. ¬øQu√© esperar este a√±o? Spoiler: un par de analg√©sicos y cerezas</a></li>
<li><a href="../es495492/index.html">Caracter√≠sticas del lanzamiento del juego Unreal Engine 4 para iOS</a></li>
<li><a href="../es495494/index.html">Crear un programador de kube adicional con un conjunto personalizado de reglas de planificaci√≥n</a></li>
<li><a href="../es495500/index.html">Alexey Klyanin: "Hasta 2018, us√© OSM solo como sustrato en mi blog"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>