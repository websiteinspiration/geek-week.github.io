<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÄ ‚òëÔ∏è üßîüèº 3D mach es selbst. Teil 1: Pixel und Linien üò≤ üòê üë≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich m√∂chte diese Artikelserie Lesern widmen, die die Welt der 3D-Programmierung von Grund auf neu erkunden m√∂chten, sowie Menschen, die die Grundlagen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>3D mach es selbst. Teil 1: Pixel und Linien</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/494094/"><img src="https://habrastorage.org/webt/-u/-n/6a/-u-n6axbw6fowganklzotzai0sk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich m√∂chte diese Artikelserie Lesern widmen, die die Welt der 3D-Programmierung von Grund auf neu erkunden m√∂chten, sowie Menschen, die die Grundlagen der Erstellung der 3D-Komponente von Spielen und Anwendungen erlernen m√∂chten. </font><font style="vertical-align: inherit;">Wir werden jede Operation von Grund auf neu implementieren, um jeden Aspekt zu verstehen, auch wenn es bereits eine vorgefertigte Funktion gibt, die sie schneller macht. </font><font style="vertical-align: inherit;">Nachdem wir gelernt haben, werden wir zu den integrierten Werkzeugen f√ºr die Arbeit mit 3D wechseln. </font><font style="vertical-align: inherit;">Nachdem Sie die Artikelserie gelesen haben, werden Sie verstehen, wie Sie komplexe dreidimensionale Szenen mit Licht, Schatten, Texturen und Effekten erstellen, wie Sie dies alles ohne fundierte mathematische Kenntnisse tun und vieles mehr. </font><font style="vertical-align: inherit;">Sie k√∂nnen dies alles unabh√§ngig und mit Hilfe von vorgefertigten Werkzeugen tun.</font></font><br>
<a name="habracut"></a><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im ersten Teil werden wir betrachten:</font></font><br>
</b><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering-Konzepte (Software, Hardware)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist ein Pixel / eine Oberfl√§che?</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detaillierte Analyse der Zeilenausgabe</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Ihre kostbare Zeit nicht mit dem Lesen von Artikeln zu verschwenden, die f√ºr eine unvorbereitete Person m√∂glicherweise unverst√§ndlich sind, werde ich mich sofort den Anforderungen zuwenden. Sie k√∂nnen sicher mit dem Lesen von Artikeln in 3D beginnen, wenn Sie die Grundlagen der Programmierung in einer beliebigen Sprache kennen, weil Ich werde mich nur auf das Studium der 3D-Programmierung konzentrieren und nicht auf das Studium der Merkmale der Sprache und der Grundlagen der Programmierung. Was die mathematische Vorbereitung betrifft, sollten Sie sich hier keine Sorgen machen, obwohl viele keine Lust haben, 3D zu studieren, weil Sie haben Angst vor komplexen Berechnungen und w√ºtenden Formeln, von denen Albtr√§ume sp√§ter tr√§umen, aber tats√§chlich gibt es keinen Grund zur Sorge. Ich werde versuchen, alles, was f√ºr 3D notwendig ist, so klar wie m√∂glich zu erkl√§ren. Man muss nur multiplizieren, dividieren, addieren und subtrahieren k√∂nnen. Wenn Sie die Auswahlkriterien erf√ºllt haben, k√∂nnen Sie mit dem Lesen beginnen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir uns mit der interessanten Welt von 3D befassen, w√§hlen wir als Beispiel eine Programmiersprache sowie eine Entwicklungsumgebung. Welche Sprache soll ich f√ºr die Programmierung von 3D-Grafiken w√§hlen? Jeder, Sie k√∂nnen dort arbeiten, wo Sie sich am wohlsten f√ºhlen, die Mathematik wird √ºberall gleich sein. In diesem Artikel werden alle Beispiele im Kontext von JS gezeigt (hier fliegen Tomaten in mich hinein). Warum js? Es ist einfach - in letzter Zeit habe ich haupts√§chlich mit ihm gearbeitet, und deshalb kann ich Ihnen die Essenz effektiver vermitteln. Ich werde alle Funktionen von JS in den Beispielen umgehen, weil Wir brauchen nur die grundlegendsten Funktionen, die eine Sprache hat, daher werden wir speziell auf 3D achten. Aber du w√§hlst, was du liebst, weil In den Artikeln werden nicht alle Formeln an die Funktionen einer Programmiersprache gebunden. Welche Umgebung soll ich w√§hlen? Es spielt keine Rolle,Im Fall von JS ist jeder Texteditor geeignet. Sie k√∂nnen den n√§chstgelegenen verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In allen Beispielen wird Leinwand zum Malen verwendet, z Damit k√∂nnen Sie sehr schnell und ohne detaillierte Analyse mit dem Zeichnen beginnen. Canvas ist ein leistungsstarkes Werkzeug mit vielen vorgefertigten Methoden zum Zeichnen, aber von all seinen Funktionen werden wir zum ersten Mal nur die Pixelausgabe verwenden!&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle dreidimensionalen Anzeigen auf dem Bildschirm mit Pixeln. Sp√§ter in den Artikeln werden Sie sehen, wie dies geschieht. Wird es langsamer? Ohne Hardwarebeschleunigung (zB Beschleunigung durch eine Grafikkarte) - wird. Im ersten Artikel werden wir keine Beschleunigungen verwenden, sondern alles von Grund auf neu schreiben, um die grundlegenden Aspekte von 3D zu verstehen. Schauen wir uns einige Begriffe an, die in zuk√ºnftigen Artikeln erw√§hnt werden:</font></font><br>
<br>
<ul>
<li><i> (Rendering)</i> ‚Äî    3D-    . ,     3D-     ,        ,        .</li>
<li><i>  (Software Rendering) </i> ‚Äî     .  ,  , ,    -  .       ,     .       3D-   ,    ‚Äî  .</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hardware-Rendering</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ein hardwareunterst√ºtzter Rendering-Prozess. </font><font style="vertical-align: inherit;">Ich benutze es Spiele und Anwendungen. </font><font style="vertical-align: inherit;">Alles funktioniert sehr schnell, weil </font><font style="vertical-align: inherit;">Viel Routine-Computing √ºbernimmt die daf√ºr vorgesehene Grafikkarte.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich strebe nicht den Titel "Definition des Jahres" an und versuche, alle Begriffsbeschreibungen so klar wie m√∂glich zu formulieren. </font><font style="vertical-align: inherit;">Die Hauptsache ist, die Idee zu verstehen, die dann unabh√§ngig entwickelt werden kann. </font><font style="vertical-align: inherit;">Ich m√∂chte auch darauf hinweisen, dass alle Codebeispiele, die in den Artikeln gezeigt werden, h√§ufig nicht auf Geschwindigkeit optimiert sind, um das Verst√§ndnis zu erleichtern. </font><font style="vertical-align: inherit;">Wenn Sie die Hauptsache verstehen - wie 3D-Grafiken funktionieren, k√∂nnen Sie alles selbst optimieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie zun√§chst ein Projekt. F√ºr mich ist es nur eine Textdatei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index.html</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit folgendem Inhalt:</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>3D it‚Äôs easy. Part 1<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">&lt;!--         --&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"surface"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"800"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"600"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//    </span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde mich jetzt nicht zu sehr auf JS und Canvas konzentrieren - dies sind nicht die Hauptfiguren dieses Artikels. </font><font style="vertical-align: inherit;">Zum allgemeinen Verst√§ndnis werde ich jedoch klarstellen, dass &lt;canvas ...&gt; ein Rechteck (in meinem Fall 800 x 600 Pixel gro√ü) ist, auf dem alle Grafiken angezeigt werden. </font><font style="vertical-align: inherit;">Ich habe Canvas einmal registriert und werde es nicht mehr √§ndern.</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span> ‚Ä¶ <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&nbsp;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skript - ein Element, in das wir die gesamte Logik zum Rendern von 3D-Grafiken mit unseren eigenen H√§nden (in JavaScript) schreiben.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir gerade die Struktur der Datei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index.html</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des </font><font style="vertical-align: inherit;">neu erstellten Projekts </font><font style="vertical-align: inherit;">√ºberpr√ºft haben </font><font style="vertical-align: inherit;">, werden wir uns mit 3D-Grafiken befassen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir etwas in das Fenster zeichnen, wird dies in der endg√ºltigen Z√§hlung zu Pixeln, da diese auf dem Monitor angezeigt werden. Je mehr Pixel, desto sch√§rfer das Bild, aber der Computer l√§dt auch mehr. Wie wird gespeichert, was wir im Fenster zeichnen? Die Grafiken in jedem Fenster k√∂nnen als Pixelarray dargestellt werden, und das Pixel selbst ist nur eine Farbe. Das hei√üt, eine Bildschirmaufl√∂sung von 800 x 600 bedeutet, dass unser Fenster 600 Zeilen mit jeweils 800 Pixeln enth√§lt, n√§mlich 800 * 600 = 480000 Pixel, nicht wahr? Pixel werden in einem Array gespeichert. √úberlegen wir uns, in welchem ‚Äã‚ÄãArray wir die Pixel speichern w√ºrden. Wenn wir 800 mal 600 Pixel haben sollten, dann ist die naheliegendste Option ein zweidimensionales Array von 800 mal 600 Pixel. Und dies ist fast die richtige Option oder vielmehr die v√∂llig richtige Option. Bei den Pixeln des Fensters ist es jedoch besser, in einem eindimensionalen Array von 480.000 Elementen zu speichern (wenn die Aufl√∂sung 800 x 600 betr√§gt).nur weil es schneller ist, mit einem eindimensionalen Array zu arbeiten, weil es wird in einer fortlaufenden Folge von Bytes im Speicher gespeichert (alles liegt in der N√§he und ist daher leicht zu bekommen). In einem zweidimensionalen Array (zum Beispiel im Fall von JS) kann jede Zeile an verschiedenen Stellen im Speicher verstreut sein, so dass der Zugriff auf die Elemente eines solchen Arrays l√§nger dauert. Um √ºber ein eindimensionales Array zu iterieren, ist nur 1 Zyklus erforderlich, und f√ºr zweidimensionale ganze Zahlen 2 ist hier die Geschwindigkeit wichtig, da Zehntausende von Iterationen des Zyklus durchgef√ºhrt werden m√ºssen. Was ist ein Pixel in einem solchen Array? Wie oben erw√§hnt - dies ist nur eine Farbe oder vielmehr 3 ihrer Komponenten (rot, gr√ºn, blau). Jedes selbst das farbenfrohste Bild besteht nur aus einer Reihe von Pixeln in verschiedenen Farben. Ein Pixel im Speicher kann beliebig gespeichert werden, entweder als Array mit 3 Elementen oder in einer Struktur, in der Rot, Gr√ºn,Blau; oder etwas anderes. Ein Bild, das aus einer Reihe von Pixeln besteht, die wir gerade analysieren, werde ich weiterhin als Oberfl√§che bezeichnen. Es stellt sich heraus, dass, da alles, was auf dem Bildschirm angezeigt wird, in einem Array von Pixeln gespeichert ist und dann Elemente (Pixel) in diesem Array ge√§ndert werden, das Bild auf dem Bildschirm Pixel f√ºr Pixel ge√§ndert wird. Genau das werden wir in diesem Artikel tun.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt keine Pixelzeichnungsfunktion in der Leinwand, aber es ist m√∂glich, auf ein eindimensionales Array von Pixeln zuzugreifen, das wir oben besprochen haben. </font><font style="vertical-align: inherit;">Wie das geht, sehen Sie im folgenden Beispiel (dieses und alle zuk√ºnftigen Beispiele befinden sich nur noch im Skriptelement):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     ()    </span>
<span class="hljs-keyword">const</span> ctx = <span class="hljs-built_in">document</span>
.getElementById(<span class="hljs-string">'surface'</span>)<font></font>
.getContext(<span class="hljs-string">'2d'</span>)<font></font>
<font></font>
<span class="hljs-comment">//     ,   &nbsp;</span>
<span class="hljs-comment">// +       </span>
<span class="hljs-keyword">const</span> imageData = ctx.createImageData(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Beispiel ist imageData ein Objekt mit drei Eigenschaften:</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√∂he und Breite</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ganzzahlen, die die H√∂he und Breite des Fensters zum Zeichnen speichern</font></font><br>
</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 8-Bit-Ganzzahl-Array ohne Vorzeichen (Sie k√∂nnen Zahlen im Bereich von 0 bis 255 darin speichern)</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Datenarray hat eine einfache, aber erkl√§rende Struktur. </font><font style="vertical-align: inherit;">Dieses eindimensionale Array speichert Daten jedes Pixels, die auf dem Bildschirm im folgenden Format angezeigt werden:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten 4 Elemente des Arrays (Indizes 0,1,2,3) sind die Daten des ersten Pixels in der ersten Zeile. Die zweiten 4 Elemente (Indizes 4, 5, 6, 7) sind die Daten des zweiten Pixels der ersten Zeile. Wenn wir zum 800. Pixel der ersten Zeile gelangen, vorausgesetzt, das Fenster ist 800 Pixel breit, geh√∂rt das 801. Pixel bereits zur zweiten Zeile. Wenn wir es √§ndern, sehen wir auf dem Bildschirm, dass sich das 1. Pixel der 2. Zeile ge√§ndert hat (obwohl es nach der Anzahl im Array das 801. Pixel ist). Warum gibt es 4 Elemente f√ºr jedes Pixel im Array? Dies liegt daran, dass auf Leinwand zus√§tzlich zu jeder Farbe 1 Element zugewiesen wird - Rot, Gr√ºn, Blau (dies sind 3 Elemente), 1 weiteres Element f√ºr Transparenz (sie sagen auch den Alphakanal oder die Deckkraft). Der Alphakanal wird wie die Farbe im Bereich von 0 (transparent) bis 255 (undurchsichtig) eingestellt. Mit dieser Struktur erhalten wir ein 32-Bit-Bild,weil jedes Pixel aus 4 Elementen mit 8 Bits besteht. Zusammenfassend: Jedes Pixel enth√§lt: rote, gr√ºne, blaue Farben und Alphakanal (Transparenz). Dieses Farbschema hei√üt ARGB (Alpha Red Green Blue). Und die Tatsache, dass jedes Pixel 32 Bit belegt, besagt, dass wir ein 32-Bit-Bild haben (sie sagen auch ein Bild mit einer Farbtiefe von 32 Bit).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standardm√§√üig wird das gesamte Array von Pixeln imageData.data (Daten sind eine Eigenschaft, in der das Array von Pixeln und imageData nur ein Objekt ist) mit den Werten 0 gef√ºllt. Wenn wir versuchen w√ºrden, ein solches Array auszugeben, wird auf dem Bildschirm nichts Interessantes angezeigt, da 0 , 0, 0 ist schwarz, aber da die Transparenz hier auch 0 ist und dies eine vollst√§ndig transparente Farbe ist, sehen wir nicht einmal Schwarz auf dem Bildschirm!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist unpraktisch, direkt mit einem solchen eindimensionalen Array zu arbeiten, daher schreiben wir eine Klasse daf√ºr, in der wir Methoden zum Zeichnen erstellen. Ich werde die Klasse benennen - Schublade. Diese Klasse speichert nur die erforderlichen Daten und f√ºhrt die erforderlichen Berechnungen durch, wobei so viel wie m√∂glich von dem zum Rendern verwendeten Tool abstrahiert wird. Deshalb werden wir alle Berechnungen platzieren und mit dem Array darin arbeiten. Und genau den Aufruf der Anzeigemethode auf Leinwand werden wir au√üerhalb der Klasse platzieren, weil Es k√∂nnte etwas anderes als Leinwand geben. In diesem Fall muss unsere Klasse nicht ge√§ndert werden. Um mit einem Array von Pixeln (Oberfl√§che) zu arbeiten, ist es f√ºr uns bequemer, es in der Drawer-Klasse sowie in der Breite und H√∂he des Bildes zu speichern, damit wir korrekt auf das gew√ºnschte Pixel zugreifen k√∂nnen. Die Drawer-Klasse sieht f√ºr mich so aus, w√§hrend die f√ºr das Zeichnen erforderlichen Mindestdaten beibehalten werden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Drawer</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;surface = <span class="hljs-literal">null</span>
&nbsp;&nbsp;&nbsp;&nbsp;width = <span class="hljs-number">0</span>
&nbsp;&nbsp;&nbsp;&nbsp;height = <span class="hljs-number">0</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(surface, width, height) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface = surface
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.width = width
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.height = height<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie im Konstruktor sehen k√∂nnen, nimmt die Drawer-Klasse alle erforderlichen Daten und speichert sie. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen Sie eine Instanz dieser Klasse erstellen und ein Array aus Pixeln, Breite und H√∂he √ºbergeben (wir haben bereits alle diese Daten, da wir sie oben erstellt und in imageData gespeichert haben):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> drawer = <span class="hljs-keyword">new</span> Drawer(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.data,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.width,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.height<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Drawer-Klasse werden wir verschiedene Zeichenfunktionen schreiben, um die Arbeit in Zukunft zu vereinfachen. </font><font style="vertical-align: inherit;">Wir werden eine Funktion zum Zeichnen eines Pixels, eine Funktion zum Zeichnen einer Linie und in weiteren Artikeln Funktionen zum Zeichnen eines Dreiecks und anderer Formen haben. </font><font style="vertical-align: inherit;">Beginnen wir jedoch mit der Pixelzeichnungsmethode. </font><font style="vertical-align: inherit;">Ich werde ihn drawPixel nennen. </font><font style="vertical-align: inherit;">Wenn wir ein Pixel zeichnen, sollte es neben der Farbe auch Koordinaten haben:</font></font><br>
<br>
<pre><code class="javascript hljs">drawPixel(x, y, r, g, b)&nbsp; { }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass die drawPixel-Funktion den Alpha-Parameter (Transparenz) nicht akzeptiert. Oben haben wir herausgefunden, dass das Pixel-Array aus 3 Farbparametern und 1 Transparenzparameter besteht. Ich habe nicht ausdr√ºcklich auf Transparenz hingewiesen, da wir sie f√ºr Beispiele absolut nicht ben√∂tigen. Standardm√§√üig setzen wir 255 (d. H. Alles ist undurchsichtig). Lassen Sie uns nun dar√ºber nachdenken, wie Sie die gew√ºnschte Farbe in ein Array von Pixeln in x, y-Koordinaten schreiben. Da wir alle Informationen √ºber das Bild in einem eindimensionalen Array gespeichert haben, in dem 1 Pixel f√ºr jedes Pixel (8 Bit) zugeordnet ist. Um auf das gew√ºnschte Pixel im Array zuzugreifen, m√ºssen wir zuerst den roten Positionsindex bestimmen, da jedes Pixel damit beginnt (z. B. [r, g, b, a]). Eine kleine Erkl√§rung der Struktur des Arrays:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uz/4j/8o/uz4j8olujyuhzo3z1anuexucnoc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die gr√ºne Tabelle zeigt an, wie Farbkomponenten in einem eindimensionalen Oberfl√§chenarray gespeichert werden. Ihre Indizes im selben Array sind blau angegeben, und die Koordinaten des Pixels, das die drawPixel-Funktionen akzeptiert, die wir in Indizes im eindimensionalen Array konvertieren m√ºssen, geben r, g, b, a f√ºr das Pixel in blau an. Aus der Tabelle ist also ersichtlich, dass f√ºr jedes Pixel die rote Komponente der Farbe an erster Stelle steht. Beginnen wir damit. Angenommen, wir m√∂chten die rote Komponente der Pixelfarbe in den Koordinaten X1Y1 mit einer Bildgr√∂√üe von 2 x 2 Pixel √§ndern. In der Tabelle sehen wir, dass dies Index 12 ist, aber wie berechnet man ihn? Zuerst finden wir den Index der Zeile, die wir ben√∂tigen, daf√ºr multiplizieren wir die Bildbreite mit Y und mit 4 (die Anzahl der Werte pro Pixel) - dies ist:</font></font><br>
<br>
<pre><code class="plaintext hljs">width * y * 4 <font></font>
//  :<font></font>
2 * 1 * 4 = 8</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen, dass die 2. Zeile mit Index 8 beginnt. Wenn wir mit der Platte vergleichen, konvergiert das Ergebnis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt m√ºssen Sie dem gefundenen Zeilenindex einen Spaltenversatz hinzuf√ºgen, um den gew√ºnschten roten Index zu erhalten. </font><font style="vertical-align: inherit;">F√ºgen Sie dazu dem Zeilenindex X mal 4 hinzu. Die vollst√§ndige Formel lautet:</font></font><br>
<br>
<pre><code class="plaintext hljs">width * y * 4 + x * 4 <font></font>
//     :<font></font>
(width * y + x) * 4<font></font>
//  :<font></font>
(2 * 1 + 1) * 4 = 12</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt vergleichen wir 12 mit der Tabelle und sehen, dass das Pixel X1Y1 wirklich mit Index 12 beginnt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Indizes anderer Farbkomponenten zu finden, m√ºssen Sie dem roten Index einen Farbversatz hinzuf√ºgen: +1 (gr√ºn), +2 (blau), +3 (alpha) . </font><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die drawPixel-Methode in der Drawer-Klasse mithilfe der obigen Formel implementieren:</font></font><br>
<br>
<pre><code class="javascript hljs">drawPixel(x, y, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> offset = (<span class="hljs-keyword">this</span>.width * y + x) * <span class="hljs-number">4</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset] = r
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">1</span>] = g
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">2</span>] = b
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">3</span>] = <span class="hljs-number">255</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei dieser drawPixel-Methode habe ich den sich wiederholenden Teil der Formel auf die Offset-Konstante gerendert. Es ist auch zu sehen, dass ich in Alpha nur 255 schreibe, weil es ist in der Struktur, aber jetzt m√ºssen wir keine Pixel mehr ausgeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist Zeit, den Code zu testen und endlich das erste Pixel auf dem Bildschirm zu sehen. Hier ist ein Beispiel mit der Pixel-Render-Methode:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     Drawer</span>
drawer.drawPixel(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
drawer.drawPixel(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
<font></font>
<span class="hljs-comment">//         canvas</span>
ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im obigen Beispiel zeichne ich 2 Pixel, eines rot 255, 0, 0, das andere blau 0, 0, 255. Die √Ñnderungen im Array imageData.data (es ist auch die Oberfl√§che innerhalb der Drawer-Klasse) werden jedoch nicht auf dem Bildschirm angezeigt. Zum Zeichnen m√ºssen Sie ctx.putImageData (imageData, 0, 0) aufrufen, wobei imageData das Objekt ist, in dem das Pixelarray und die Breite / H√∂he des Zeichenbereichs angezeigt werden, und 0, 0 der Punkt ist, relativ zu dem das Pixelarray angezeigt wird (lassen Sie immer 0, 0 ) Wenn Sie alles richtig gemacht haben, wird oben links im Canvas-Element im Browserfenster das folgende Bild angezeigt: Haben Sie die </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d8/xn/cz/d8xnczchpgfg-9amhgdlyrpvzma.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pixel gesehen? Sie sind so klein und wie viel Arbeit wurde geleistet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir nun, dem Beispiel ein wenig Dynamik hinzuzuf√ºgen, sodass sich unser Pixel alle 10 Millisekunden nach rechts verschiebt (wir √§ndern X Pixel alle 10 Millisekunden um +1). Wir korrigieren den Pixelzeichnungscode in Intervallen um eins:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>
setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.drawPixel(x++, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
<font></font>
}, <span class="hljs-number">10</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel habe ich nur die Ausgabe des blauen Pixels belassen und die Funktion setInterval mit dem Parameter 10 in JavaScript umbrochen. Dies bedeutet, dass der Code ungef√§hr alle 10 Millisekunden aufgerufen wird. Wenn Sie ein solches Beispiel ausf√ºhren, werden Sie feststellen, dass anstelle eines nach rechts verschobenen Pixels etwa Folgendes angezeigt wird: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8o/0v/uu/8o0vuuurtmmqgu8uy7sufdka16o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein so langer Streifen (oder eine so lange Spur) bleibt erhalten, da die Farbe des vorherigen Pixels im Oberfl√§chenarray nicht gel√∂scht wird. Bei jedem Aufruf des Intervalls, das wir hinzuf√ºgen ein Pixel. Schreiben wir eine Methode, mit der die Oberfl√§che in ihren urspr√ºnglichen Zustand versetzt wird. Mit anderen Worten, f√ºllen Sie das Array mit Nullen. F√ºgen Sie der Klasse Drawer die Methode clearSurface hinzu:</font></font><br>
<br>
<pre><code class="javascript hljs">clearSurface() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> surfaceSize = <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height * <span class="hljs-number">4</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; surfaceSize; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[i] = <span class="hljs-number">0</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Array gibt es keine Logik, nur das Auff√ºllen mit Nullen. </font><font style="vertical-align: inherit;">Es wird empfohlen, diese Methode jedes Mal aufzurufen, bevor Sie ein neues Bild zeichnen. </font><font style="vertical-align: inherit;">Im Fall einer Pixelanimation vor dem Zeichnen dieses Pixels:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>
setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.clearSurface()<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.drawPixel(x++, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
}, <span class="hljs-number">10</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie nun dieses Beispiel ausf√ºhren, wird das Pixel nacheinander nach rechts verschoben - ohne unn√∂tige Spuren von vorherigen Koordinaten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Letzte, was wir im ersten Artikel implementieren, ist die Strichzeichnungsmethode. </font><font style="vertical-align: inherit;">F√ºgen Sie es nat√ºrlich der Drawer-Klasse hinzu. </font><font style="vertical-align: inherit;">Die Methode, die ich drawLine nennen werde. </font><font style="vertical-align: inherit;">Was wird er nehmen? </font><font style="vertical-align: inherit;">Im Gegensatz zu einem Punkt hat die Linie immer noch die Koordinaten, an denen sie endet. </font><font style="vertical-align: inherit;">Mit anderen Worten, die Linie hat einen Anfang, ein Ende und eine Farbe, die wir an die Methode √ºbergeben werden:</font></font><br>
<br>
<pre><code class="javascript hljs">drawLine(x1, y1, x2, y2, r, g, b) { }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede Zeile besteht aus Pixeln, es bleibt nur, um sie korrekt mit Pixeln von x1, y1 bis x2, y2 zu f√ºllen. Da die Zeile aus Pixeln besteht, geben wir sie zun√§chst Pixel f√ºr Pixel in der Schleife aus. Wie berechnet man jedoch, wie viele Pixel ausgegeben werden sollen? Um beispielsweise eine Linie von [0, 0] nach [3, 0] zu zeichnen, ist intuitiv klar, dass Sie 4 Pixel ben√∂tigen ([0, 0], [1, 0], [2, 0], [3, 0],). . Von [12, 6] bis [43, 14] ist jedoch bereits nicht klar, wie lang die Linie sein wird (wie viele Pixel angezeigt werden sollen) und welche Koordinaten sie haben werden. Erinnern Sie sich dazu an eine kleine Geometrie. Wir haben also eine Linie, die bei x1, y1 beginnt und bei x2, y2 endet.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/z7/ip/ouz7ipd2uiokmmijlro7wldayzw.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeichnen wir eine gepunktete Linie vom Anfang und vom Ende, so dass wir ein Dreieck erhalten (Bild oben). </font><font style="vertical-align: inherit;">Wir werden sehen, dass sich an der Verbindungsstelle der gezeichneten Linien ein Winkel von 90 Grad gebildet hat. </font><font style="vertical-align: inherit;">Wenn das Dreieck einen solchen Winkel hat, wird das Dreieck als rechteckig bezeichnet, und seine Seiten, zwischen denen der Winkel 90 Grad betr√§gt, werden als Beine bezeichnet. </font><font style="vertical-align: inherit;">Die dritte durchgezogene Linie (die wir zu zeichnen versuchen) hei√üt Hypotenuse in einem Dreieck. </font><font style="vertical-align: inherit;">Mit diesen beiden eingef√ºhrten Beinen (c1 und c2 in der Abbildung) k√∂nnen wir die L√§nge der Hypotenuse mit dem Satz von Pythagoras berechnen. </font><font style="vertical-align: inherit;">Mal sehen, wie es geht. </font><font style="vertical-align: inherit;">Die Formel f√ºr die L√§nge der Hypotenuse (oder Linienl√§nge) lautet wie folgt:&nbsp;</font></font><br>
<p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x433;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x438;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43F;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43E;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43D;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x443;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x437;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mo>=</mo><msqrt><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43A;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43A;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><msup><mn>2</mn><mn>2</mn></msup></msqrt></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="31.778ex" height="4.759ex" viewBox="0 -1401.3 13682.2 2049.1" role="img" focusable="false" style="vertical-align: -1.505ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text><g transform="translate(376,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(861,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1345,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1776,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(2152,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(2535,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3019,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3450,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3790,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhhFiTeWnGKPrJj5pPY1fMRplbjlPA#MJMAIN-3D" x="4499" y="0"></use><g transform="translate(5555,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhhFiTeWnGKPrJj5pPY1fMRplbjlPA#MJSZ2-221A" x="0" y="87"></use><rect stroke="none" width="7126" height="60" x="1000" y="1178"></rect><g transform="translate(1000,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text><g transform="translate(430,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(861,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1237,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1620,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1997,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhhFiTeWnGKPrJj5pPY1fMRplbjlPA#MJMAIN-31" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhhFiTeWnGKPrJj5pPY1fMRplbjlPA#MJMAIN-32" x="707" y="583"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhhFiTeWnGKPrJj5pPY1fMRplbjlPA#MJMAIN-2B" x="3173" y="0"></use><g transform="translate(4174,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(4605,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5035,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5412,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5795,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(6171,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhhFiTeWnGKPrJj5pPY1fMRplbjlPA#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhhFiTeWnGKPrJj5pPY1fMRplbjlPA#MJMAIN-32" x="707" y="583"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mo>=</mo><msqrt><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><msup><mn>2</mn><mn>2</mn></msup></msqrt></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> = \sqrt{1^2 + 2^2}</script></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie man beide Beine bekommt, sieht man auch aus dem Dreieck. </font><font style="vertical-align: inherit;">Unter Verwendung der obigen Formel finden wir nun die Hypotenuse, die die lange Zeile (die Anzahl der Pixel) sein wird:</font></font><br>
<br>
<pre><code class="javascript hljs">&nbsp;drawLine(x1, y1, x2, y2, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c1 = y2 - y1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wissen bereits, wie viele Pixel gezeichnet werden m√ºssen, um eine Linie zu zeichnen. Wir wissen jedoch noch nicht, wie Pixel verschoben werden. Das hei√üt, wir m√ºssen eine Linie von x1, y1 bis x2, y2 zeichnen. Wir wissen, dass die Linienl√§nge beispielsweise 20 Pixel betr√§gt. Wir k√∂nnen das 1. Pixel in x1, y1 und das letzte in x2, y2 zeichnen, aber wie findet man die Koordinaten der Zwischenpixel? Dazu m√ºssen wir herausfinden, wie jedes n√§chste Pixel in Bezug auf x1, y1 verschoben wird, um die gew√ºnschte Linie zu erhalten. Ich werde noch ein Beispiel geben, um besser zu verstehen, um welche Art von Verschiebung es sich handelt. Wir haben Punkte [0, 0] und [0, 3], wir m√ºssen eine Linie auf sie ziehen. Aus dem Beispiel ist klar ersichtlich, dass der n√§chste Punkt nach [0, 0] [0, 1] und dann [0, 2] und schlie√ülich [0, 3] sein wird. Das hei√üt, X von jedem Punkt wurde nicht verschoben, oder wir k√∂nnen sagen, dass es um 0 Pixel verschoben wurde, und Y wurde um 1 Pixel verschoben, dies ist der Versatz.es kann als [0, 1] geschrieben werden. Ein weiteres Beispiel: Wir haben einen Punkt [0, 0] und einen Punkt [3, 6]. Versuchen wir in unserem Kopf zu berechnen, wie sie sich verschieben. Der erste ist [0, 0], dann [0,5, 1], dann [1, 2]. dann [1.5, 3] usw. zu [3, 6], in diesem Beispiel betr√§gt der Versatz [0.5, 1]. Wie berechnet man das?&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen die folgende Formel verwenden:</font></font><br>
<br>
<pre><code class="javascript hljs">   = <span class="hljs-number">2</span> /  <font></font>
  Y = <span class="hljs-number">1</span> /  &nbsp;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Programmcode haben wir Folgendes:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> xStep = c2 / length
<span class="hljs-keyword">const</span> yStep = c1 / length</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Daten sind bereits vorhanden: die L√§nge der Linie, der Versatz der Pixel entlang X und Y. Wir beginnen im Zyklus mit dem Zeichnen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.drawPixel(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r, g, b,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als X-Koordinate der Pixelfunktion √ºbertragen wir den Anfang der X-Linie + Versatz X * i. Um die Koordinate des i-ten Pixels zu erhalten, berechnen wir auch die Y-Koordinate. Math.trunc ist eine Methode in JS, mit der Sie den Bruchteil einer Zahl verwerfen k√∂nnen. </font><font style="vertical-align: inherit;">Der gesamte Methodencode sieht folgenderma√üen aus:</font></font><br>
<br>
<pre><code class="javascript hljs">drawLine(x1, y1, x2, y2, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c1 = y2 - y1
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> xStep = c2 / length
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> yStep = c1 / length<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.drawPixel(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r, g, b,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Teil ist zu Ende gegangen, ein langer, aber aufregender Weg, um die 3D-Welt zu verstehen. </font><font style="vertical-align: inherit;">Es gab noch nichts Dreidimensionales, aber wir haben vorbereitende Operationen zum Zeichnen durchgef√ºhrt: Wir haben die Funktionen zum Zeichnen eines Pixels, einer Linie, zum L√∂schen eines Fensters implementiert und einige Begriffe gelernt. </font><font style="vertical-align: inherit;">Der gesamte Code der Drawer-Klasse kann unter dem Spoiler angezeigt werden:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schubladenklassencode</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Drawer</span> </span>{<font></font>
  surface = <span class="hljs-literal">null</span>
  width = <span class="hljs-number">0</span>
  height = <span class="hljs-number">0</span><font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(surface, width, height) {
    <span class="hljs-keyword">this</span>.surface = surface
    <span class="hljs-keyword">this</span>.width = width
    <span class="hljs-keyword">this</span>.height = height<font></font>
  }<font></font>
<font></font>
  drawPixel(x, y, r, g, b)  {<font></font>
    <span class="hljs-keyword">const</span> offset = (<span class="hljs-keyword">this</span>.width * y + x) * <span class="hljs-number">4</span><font></font>
<font></font>
    <span class="hljs-keyword">this</span>.surface[offset] = r
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">1</span>] = g
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">2</span>] = b
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">3</span>] = <span class="hljs-number">255</span><font></font>
  }<font></font>
<font></font>
  drawLine(x1, y1, x2, y2, r, g, b) {<font></font>
    <span class="hljs-keyword">const</span> c1 = y2 - y1
    <span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
    <span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)<font></font>
<font></font>
    <span class="hljs-keyword">const</span> xStep = c2 / length
    <span class="hljs-keyword">const</span> yStep = c1 / length<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; length ; i++) {
        <span class="hljs-keyword">this</span>.drawPixel(
          <span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
          <span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
          r, g, b,<font></font>
        )<font></font>
    }<font></font>
  }<font></font>
<font></font>
  clearSurface() {<font></font>
    <span class="hljs-keyword">const</span> surfaceSize = <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height * <span class="hljs-number">4</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; surfaceSize; i++) {
      <span class="hljs-keyword">this</span>.surface[i] = <span class="hljs-number">0</span><font></font>
    }<font></font>
  }<font></font>
}<font></font>
</code></pre></div></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was weiter?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im n√§chsten Artikel werden wir untersuchen, wie eine so einfache Operation wie die Ausgabe eines Pixels und einer Linie zu interessanten 3D-Objekten werden kann. </font><font style="vertical-align: inherit;">Wir werden uns mit Matrizen und Operationen an ihnen vertraut machen, ein dreidimensionales Objekt in einem Fenster anzeigen und sogar Animationen hinzuf√ºgen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de494076/index.html">Analyse: Anlegerverhaltensstrategien bei B√∂rsencrashs</a></li>
<li><a href="../de494082/index.html">Dalenka: die n√ºtzlichsten Artikel √ºber effektive Arbeit von zu Hause aus</a></li>
<li><a href="../de494084/index.html">Coronavirus: Online-Informationsdienste</a></li>
<li><a href="../de494090/index.html">Sellerie-Drosselung - Festlegen des Ratenlimits f√ºr Warteschlangen</a></li>
<li><a href="../de494092/index.html">Abbau der verbundenen Struktur</a></li>
<li><a href="../de494096/index.html">Intranet-Bereitstellung. Erfahrung, Fehler, Empfehlungen</a></li>
<li><a href="../de494098/index.html">Imperativer Ansatz f√ºr reaktive Daten am Beispiel von Jetbrains KTor und R2DBC</a></li>
<li><a href="../de494100/index.html">Was Sie brauchen, um das ideale Modell eines Bildungszentrums f√ºr die Ausbildung von IT-Spezialisten zu schaffen</a></li>
<li><a href="../de494114/index.html">Wie man die Anzahl reduziert und die Lesbarkeit von Code in React-Redux, Redux-Saga erh√∂ht</a></li>
<li><a href="../de494118/index.html">COVID-19 Telegramm-Bot // Wir beantworten FAQ-Fragen automatisch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>