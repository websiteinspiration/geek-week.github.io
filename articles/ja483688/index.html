<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕧 🍈 📏 Node.jsの同時実行性が約30倍に増加 🌃 👩🏾‍🤝‍👩🏼 ⛲️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本番環境で使用されるNode.jsサービスの並行性をシームレスに向上させる最良の方法は何ですか？これは、数か月前に私のチームが回答する必要があった質問です。
 
 銀行との統合サービスの運用を保証する4000ノードコンテナー（または「ワーカー」）をリリースしました。このサービスは当初、各ワーカーが一...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Node.jsの同時実行性が約30倍に増加</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/483688/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本番環境で使用されるNode.jsサービスの並行性をシームレスに向上させる最良の方法は何ですか？これは、数か月前に私のチームが回答する必要があった質問です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
銀行との統合サービスの運用を保証する4000ノードコンテナー（または「ワーカー」）をリリースしました。このサービスは当初、各ワーカーが一度に1つの要求のみを処理するように設計されていました。これにより、予期せず</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ブロック</font></a><font style="vertical-align: inherit;">する可能性がある操作のシステムへの影響が軽減されました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントのサイクルにより、さまざまな同様の操作によるリソースの使用の違いを無視することができました。しかし、キャパシティは4,000リクエストの同時実行に制限されていたため、システムを適切にスケーリングできませんでした。ほとんどの要求への応答速度は、機器の容量ではなく、ネットワークの機能に依存していました。したがって、要求を並列で確実に処理する方法を見つけることができれば、システムを改善し、それをサポートするコストを削減できます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/dq/pm/0q/dqpm0qid51wd9njshhwhr-mi_ic.jpeg"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を調査した結果、Node.jsサービスの「並列性の欠如」から「高レベルの並列性」への移行について説明する適切なガイドを見つけることができませんでした。</font><font style="vertical-align: inherit;">その結果、慎重な計画、優れたツール、監視ツール、および適切な量のデバッグに基づく独自の移行戦略を開発しました。</font><font style="vertical-align: inherit;">その結果、システムの並列処理のレベルを30倍に上げることができました。</font><font style="vertical-align: inherit;">これは、システムの維持コストを年間約30万ドル削減することに相当します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この資料は、Node.jsワーカーの生産性と有効性をどのように向上させたか、そしてこの方法で学んだことについてのストーリーに特化しています。</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜ並列処理に投資することにしたのですか？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並列処理を使用せずにこのようなサイズに成長したのは驚くべきことかもしれません。どうやってそれが起こったのですか？ Plaidツールによって実行されるデータ処理操作の10％のみが、コンピューターの前にいて、アカウントをアプリケーションに接続しているユーザーによって開始されます。残りはすべて、ユーザーの存在なしで実行されるトランザクションを定期的に更新するためのトランザクションです。私たちが使用している負荷分散システムにロジックが追加されました。これにより、トランザクションの更新要求よりもユーザーからの要求の優先順位が保証されます。これにより、APIアクセス操作のアクティビティのバーストを1000％以上で処理できました。これは、データの更新を目的としたトランザクションを通じて行われました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この妥協案は長い間機能してきましたが、その中でいくつかの不愉快な瞬間を見分けることができました。</font><font style="vertical-align: inherit;">最終的には、サービスの信頼性に悪影響を与える可能性があることはわかっていました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントからのAPIリクエストのピークはますます高くなっています。</font><font style="vertical-align: inherit;">アクティビティの急増により、クエリ処理機能が使い果たされる可能性があることを心配しました。</font></font></li>
<li>             . - ,        ,     -   .             .    ,            ,  ,      ,  .</li>
<li>  ECS   ,        ,       .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションのボトルネックに対処してシステムの信頼性を向上させる最善の方法は、リクエストの処理における並列処理のレベルを上げることであると判断しました。</font><font style="vertical-align: inherit;">さらに、副作用として、インフラストラクチャコストを削減し、システムを監視するための優れたツールの実装に役立つことを期待していました。</font><font style="vertical-align: inherit;">それも将来的にも実を結ぶでしょう。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信頼性を考慮したアップデートの導入方法</font></font></font></h2><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ツールとモニタリング</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Node.jsワーカーにリクエストをリダイレクトする独自のロードバランサーがあります。各ワーカーは、リクエストの処理に使用されるgRPCサーバーを実行します。ワーカーはRedisを使用して、使用可能であることをロードバランサーに通知します。これは、システムに並列処理を追加することは、単に数行のコードを変更することに帰着することを意味します。つまり、ワーカーは、リクエストが出された後にアクセスできなくなるのではなく、自分に届いたN個のリクエストの処理でビジーであることが判明するまで、それぞれが利用可能であることを通知する必要があります。独自のPromiseオブジェクトで表されます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、すべてがそれほど単純なわけではありません。システムアップデートを展開するときは、常にその信頼性を維持することが私たちの主な目標であると考えています。したがって、YOLOの原則などに基づいて、システムを並列クエリ処理モードにするだけでは不十分です。そのようなシステムのアップグレードは特に危険であると予想しました。実際には、これはプロセッサの使用、メモリ、およびタスクの実行における遅延に予測できない影響を与えることになります。</font><font style="vertical-align: inherit;">Node.jsで使用される</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V8エンジン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はイベントループでタスクを処理する</font><font style="vertical-align: inherit;">ので、</font><font style="vertical-align: inherit;">主な懸念は、イベントループで実行している作業が多すぎてシステムスループットが低下することが判明する可能性があることでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのリスクを軽減するために、最初のパラレルワーカーが本番環境に入る前であっても、システムに次の監視ツールとツールが存在することを確認しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たち</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">すでに使用している</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ELKスタック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、システムで何が行われているかをすばやく理解するのに役立つ十分な量のログ情報を提供してくれました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムにいくつかの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prometheus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メトリックを追加しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以下を含みます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で取得したV8ヒープサイズ</font></font><code>process.memoryUsage()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gc-stats</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージを使用して取得したガベージコレクションオペレーションに関する情報</font><font style="vertical-align: inherit;">。</font></font></li>
<li>    ,    ,    ,    .        ,       .</li>
</ul></li>
<li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Grafana</a>,        .</li>
<li>             .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">LaunchDarkly</a>,     .      ,   ,       ,         ,     .</li>
<li>     ,      ,    -   ,      .<br>
<br>
<ul>
<li>   0x - ,   Node.js      ,  - ,   HTML-         .</li>
<li>     ,       0x        S3.         S3    ,    <code>0x --visualize-only ./flamegraph</code>.</li>
<li>,    ,      .       ,          .</li>
</ul></li>
</ul><br>
<h3><font color="#3AC1EF">▍ </font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事前準備が完了したら、「並列ワーカー」用の新しいECSクラスターを作成しました。これらは、LaunchDarklyフラグを使用して、並列処理の最大レベルを動的に設定するワーカーでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのシステム導入計画には、古いクラスターから新しいクラスターへのトラフィック量の段階的なリダイレクトが含まれていました。この間、新しいクラスターのパフォーマンスを注意深く監視していました。各負荷レベルで、各ワーカーの並列処理のレベルを上げて、タスクの継続時間の増加や他の指標の悪化が発生しない最大値にすることを計画しました。問題が発生した場合は、数秒以内に動的にトラフィックを古いクラスターにリダイレクトできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予想通り、トリッキーな問題が発生しました。</font><font style="vertical-align: inherit;">更新されたシステムが正しく動作するようにするには、それらを調査して排除する必要がありました。</font><font style="vertical-align: inherit;">これが楽しみの始まりです。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">展開、探索、繰り返し</font></font></font></h2><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NodeNode.jsの最大ヒープサイズを増やす</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいシステムの展開を開始したとき、ゼロ以外の終了コードでタスクの完了通知を受け取り始めました。</font><font style="vertical-align: inherit;">まあ私は何を言うことができます-有望な始まり。</font><font style="vertical-align: inherit;">次に、Kibanaに埋葬し、必要なログを見つけました。</font></font><br>
<br>
<pre><code class="javascript hljs">FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - Javascript heap out <span class="hljs-keyword">of</span> memory
&nbsp;<span class="hljs-number">1</span>: node::Abort()
&nbsp;<span class="hljs-number">2</span>: node::FatalException(v8::Isolate*, v8::Local, <span class="hljs-attr">v8</span>::Local)
&nbsp;<span class="hljs-number">3</span>: v8::internal::V8::FatalProcessOutOfMemory(char <span class="hljs-keyword">const</span>*, bool)
&nbsp;<span class="hljs-number">4</span>: v8::internal::Factory::NewFixedArray(int, <span class="hljs-attr">v8</span>::internal::PretenureFlag)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、プロセスが予期せず終了し、同様のエラーメッセージが表示されたときに発生したメモリリークの影響を連想させます。</font><font style="vertical-align: inherit;">これは非常に予想されたように見えました。並列処理のレベルを上げると、メモリ使用のレベルも上がります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Node.jsの最大ヒープサイズ（デフォルトで1.7 GBに設定）を増やすと、この問題の解決に役立つことを提案しました。</font><font style="vertical-align: inherit;">次に、Node.jsの実行を開始し、最大ヒープサイズを6 GBに設定しました（コマンドラインフラグを使用</font></font><code>--max-old-space-size=6144</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">これは、EC2インスタンスに適した最大の値でした。</font><font style="vertical-align: inherit;">嬉しいことに、このような動きにより、本番環境で発生する上記のエラーに対処することができました。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍メモリのボトルネックの特定</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリ割り当ての問題を解決した後、並列ワーカーでのタスクのスループットが低下するようになりました。同時に、コントロールパネルのグラフの1つがすぐに注目を集めました。これは、並列ワーカープロセスがどのように束を使用するかについてのレポートでした。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/598/944/d59/598944d592326d9ac7b4027e686de3bd.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒープ使用量</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このグラフの一部の曲線は、最大ヒープサイズでほぼ水平の線になるまで、連続的に増加しました。</font><font style="vertical-align: inherit;">本当に気に入らなかった。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなシステム動作の原因からファイル記述子またはネットワークソケットのリークを排除するために、Prometheusでシステムメトリックを使用しました。</font><font style="vertical-align: inherit;">最も適切な仮定は、古いオブジェクトに対してガベージコレクションが頻繁に実行されないことでした。</font><font style="vertical-align: inherit;">これにより、タスクが処理されると、ワーカーはすでに不要なオブジェクトに割り当てられたメモリをどんどん蓄積する可能性があります。</font><font style="vertical-align: inherit;">スループットが低下するシステムの動作は次のようになると想定しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワーカーは新しいタスクを受け取り、特定のアクションを実行します。</font></font></li>
<li>          .</li>
<li>- ,   ,      «  » (     —  )  ,        .</li>
<li>   - ,  V8        .</li>
<li>   V8    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">stop-the-world</a> (      ),       ,     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「完了して忘れた」という原則に基づいて実行される操作をコードで検索し始めました。それらは「変動約束」（「変動約束」）とも呼ばれます。それは簡単でした-no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-floating-promises</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンタールールが無効になっている行を見つけるだけ</font><font style="vertical-align: inherit;">です。一つの方法が私たちの注目を集めました。彼は</font></font><code>compressAndUploadDebuggingPayload</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果を期待せず</font><font style="vertical-align: inherit;">に電話をかけた</font><font style="vertical-align: inherit;">。そのような呼び出しは、タスクの処理が完了した後でも、簡単に長期間継続できるように思われました。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> postTaskDebugging = <span class="hljs-keyword">async</span> (data: TypedData) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> payload = <span class="hljs-keyword">await</span> generateDebuggingPayload(data);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//       ,</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//        .</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// tslint:disable-next-line:no-floating-promises</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;compressAndUploadDebuggingPayload(payload)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> logger.error(<span class="hljs-string">'failed to upload data'</span>, err));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような変動する約束が問題の主な原因であるという仮説を検証したかったのです。システムの正しい動作に影響を与えなかったこれらの課題を満たさない場合、タスクの速度を改善できますか？呼び出しを一時的に取り除いた後のヒープ使用量情報は次のとおりです</font></font><code>postTaskDebugging</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/899/652/9b5899652c40d7b349bcfe108b9f721c.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">postTaskDebuggingを無効にした後のヒープの使用</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これは</font><i><font color="#999999"><font style="vertical-align: inherit;">機能し</font></font></i><font style="vertical-align: inherit;">ます！現在、並列ワーカーのヒープ使用率レベルは長期間にわたって安定しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムでは、タスクが完了するにつれて、呼び出しの「借金」が徐々に蓄積されていくような感じがしました</font></font><code>compressAndUploadDebuggingPayload</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ワーカーがこれらの「負債」を「支払う」よりも早くタスクを受け取った場合、メモリが割り当てられているオブジェクトはガベージコレクション操作の対象ではありませんでした。これにより、ヒープを最上部まで埋めることができました。これは、前のチャートを分析して、上記で検討しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはこれらの変動する約束が何故そんなに遅くなったのか疑問に思い始めました。コードから完全に削除したくなかった</font></font><code>compressAndUploadDebuggingPayload</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この課題は非常に重要だったため、エンジニアはローカルマシンで生産タスクをデバッグできました。</font><font style="vertical-align: inherit;">技術的な観点から見ると、この呼び出しの結果を待ち、その後タスクを完了することで問題を解決することができ、フローティングプロミスを取り除くことができます。</font><font style="vertical-align: inherit;">ただし、これにより、処理中の各タスクの実行時間が大幅に増加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような解決策を最後の手段としてのみ使用することを決定したので、コードの最適化について考え始めました。</font><font style="vertical-align: inherit;">この操作をスピードアップするには？</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bottleボトルネックの修正S3</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仕事のロジックは</font></font><code>compressAndUploadDebuggingPayload</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理解しやすいです。</font><font style="vertical-align: inherit;">ここでは、デバッグデータを圧縮していますが、ネットワークトラフィックが含まれているため、非常に大きくなる可能性があります。</font><font style="vertical-align: inherit;">次に、圧縮データをS3にアップロードします。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> compressAndUploadDebuggingPayload = <span class="hljs-keyword">async</span> (<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;logger: Logger,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">data</span>: any,<font></font>
) =&gt; {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> compressionStart = <span class="hljs-built_in">Date</span>.now();
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> base64CompressedData = <span class="hljs-keyword">await</span> streamToString(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfj.streamify(data)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.pipe(zlib.createDeflate())<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.pipe(<span class="hljs-keyword">new</span> b64.Encoder()),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;logger.trace(<span class="hljs-string">'finished compressing data'</span>, {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">compression_time_ms</span>: <span class="hljs-built_in">Date</span>.now() - compressionStart,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> uploadStart = <span class="hljs-built_in">Date</span>.now();<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;s3Client.upload({<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">Body</span>: base64CompressedData,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">Bucket</span>: bucket,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">Key</span>: key,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;logger.trace(<span class="hljs-string">'finished uploading data'</span>, {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">upload_time_ms</span>: <span class="hljs-built_in">Date</span>.now() - uploadStart,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kibanaログから、S3へのデータのダウンロードは、そのボリュームが小さい場合でも、時間がかかることが明らかでした。標準のNode.js HTTPSエージェントが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://nodejs.org/api/http.html&amp;usg=ALkJrhhzvmyL05mIh0pDIM9YOU_x6ydFYg#"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxSockets</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータ</font><font style="vertical-align: inherit;">を値に</font><font style="vertical-align: inherit;">設定するため、当初はソケットがシステムのボトルネックになる可能性があるとは考えていませんでした</font></font><code>Infinity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ただし、結局、Node.jsのAWSドキュメントを読んだところ、S3クライアントがパラメーターの値をに減らすという驚くべきことがわかり</font></font><code>maxSockets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました</font></font><code>50</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。言うまでもなく、この動作は直感的とは言えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワーカーを競合モードで50を超えるタスクが実行される状態にしたため、ダウンロードステップがボトルネックになりました。これには、ソケットが解放されてS3にデータをアップロードするのを待つことが含まれていました。</font><font style="vertical-align: inherit;">S3クライアントの初期化コードに次の変更を加えることにより、データの読み込み時間を改善しました。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> s3Client = <span class="hljs-keyword">new</span> AWS.S3({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">httpOptions</span>: {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">agent</span>: <span class="hljs-keyword">new</span> https.Agent({
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//     </span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//          S3.</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">maxSockets</span>: <span class="hljs-number">1024</span> * <span class="hljs-number">20</span>,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;},<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;region,<font></font>
});</code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSON JSONシリアル化の高速化</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S3コードの改善により、ヒープサイズの増加が鈍化しましたが、問題の完全な解決には至っていません。もう1つの明らかな迷惑がありました。私たちの測定基準によると、上記のコードのデータ圧縮ステップは4分間続きました。これは、通常のタスク完了時間である4秒よりもはるかに長かった。目を疑い、4分かかるかもしれないことを理解せずに、ローカルベンチマークを使用して低速コードブロックを最適化することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ圧縮は3つの段階で構成されます（ここでは、メモリ使用量を制限するために</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">スレッド</font></a><font style="vertical-align: inherit;">が使用されます）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node.js）。つまり、最初の段階では文字列JSONデータが生成され、2番目の段階ではzlibを使用してデータが圧縮され、3番目の段階ではbase64エンコーディングに変換されます。問題の原因は、JSON文字列を生成するために使用するサードパーティのライブラリである可能性があると考えました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-bfj</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ストリームを使用してJSON文字列データを生成するためのさまざまなライブラリのパフォーマンスを調べるスクリプトを作成しました（対応するコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。私たちが使用していたBig Friendly JSONパッケージはまったく友好的ではないことがわかりました。実験中に得られた一対の測定結果を見てください。</font></font><br>
<br>
<pre><code class="javascript hljs">benchBFJ*<span class="hljs-number">100</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">67652.616</span>ms<font></font>
benchJSONStream*<span class="hljs-number">100</span>: <span class="hljs-number">14094.825</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
素晴らしい結果。</font><font style="vertical-align: inherit;">簡単なテストでさえ、bfjパッケージは他のパッケージであるJSONStreamよりも5倍遅いことがわかりました。</font><font style="vertical-align: inherit;">気づいた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ので</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すぐに</font><font style="vertical-align: inherit;">bfjを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">JSONStream</font></a><font style="vertical-align: inherit;">に変更し</font><font style="vertical-align: inherit;">、すぐにパフォーマンスが大幅に向上しました。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガベージコレクションに必要な時間を短縮</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリの問題を解決した後、同じタイプのタスクを処理するために必要な時間の通常のワーカーとパラレルワーカーの違いに注意を払い始めました。この比較は完全に正当であり、その結果によると、新しいシステムの有効性を判断できました。したがって、通常のワーカーと並列ワーカーの比率が約1になる場合、これらのワーカーにトラフィックを安全にリダイレクトできるという確信が得られます。しかし、最初のシステムの起動中、Grafanaコントロールパネルの対応するグラフは、次の図のようになりました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ed/110/a81/2ed110a812b69096ee0bc33f5733895e.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常のワーカーと並列ワーカーによるタスク実行時間の相関。</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
インジケーターが8：1の領域にある場合があることに注意してください</font><i><font color="#999999"><font style="vertical-align: inherit;">。</font></font></i><font style="vertical-align: inherit;">これは、タスクの並列化の平均レベルが比較的低く、30の領域にあるにもかかわらずです。私たちが解決していたタスクは銀行との相互作用については、プロセッサに大きな負荷をかけないでください。また、「並列」コンテナには制限がないことも知っていました。問題の原因を探す場所がわからないため、Node.jsプロジェクトの最適化に関する資料を読みました。そのような記事は少数です</font><font style="vertical-align: inherit;">が、Node.jsで60万の競争力のあるWebソケット接続の達成を扱った</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">資料に</font><font style="vertical-align: inherit;">出くわし</font><font style="vertical-align: inherit;">ました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に、旗の使用は私たちの注意を引いた。</font></font><code>--nouse-idle-notification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Node.jsプロセスは、ガベージコレクションに多くの時間を費やすことができますか？ちなみに、gc-statsパッケージは、ガベージコレクションに費やされた平均時間を確認する機会を与えてくれました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc8/f49/cd5/fc8f49cd59c3dd896a332f85f49b7946.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガベージコレクションに費やされた時間の分析</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
プロセスがScavengeアルゴリズムを使用して、ガベージコレクションに費やした時間の約30％を費やしたようです。ここでは、Node.jsのさまざまなタイプのガベージコレクションに関する技術的な詳細については説明しません。このトピックに興味がある場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">資料を</font><font style="vertical-align: inherit;">ご覧ください</font><font style="vertical-align: inherit;">。 Scavengeアルゴリズムの本質は、ガベージコレクションが「新しいスペース」と呼ばれるNode.jsヒープ内の小さなオブジェクトによって占有されているメモリをクリアするために開始されることが多いことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Node.jsプロセスではガベージコレクションが頻繁に開始されることがわかりました。 V8ガベージコレクションを無効にして自分で実行できますか？</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">頻度</font></a><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">減らす</font></a><font style="vertical-align: inherit;">方法はあり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ますか</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガベージコレクションを呼び出しますか？</font><font style="vertical-align: inherit;">上記の最初のことはできないことがわかりましたが、最後の-それは可能です！</font><font style="vertical-align: inherit;">コマンドラインフラグを使用してNode.jsの「セミスペース」領域の制限を増やすことで、「新しいスペース」領域のサイズを増やすことができ</font></font><code>--max-semi-space-size=1024</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これにより、V8がガベージコレクションを開始するまで、存続期間の短いオブジェクトに対してより多くのメモリ割り当て操作を実行できます。</font><font style="vertical-align: inherit;">その結果、そのような操作を起動する頻度が減少します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07e/54b/243/07e54b243db9dc18bed7bc5bdd235d74.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガベージコレクション手順を最適化した結果</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
もう1つの勝利です！</font><font style="vertical-align: inherit;">「新しいスペース」領域の増加により、スカベンジアルゴリズムを使用したガベージコレクションに費やされる時間が30％から2％に大幅に削減されました。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">processorプロセッサー使用率を最適化</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この作業がすべて完了した後、結果は私たちに合いました。並列ワーカーで実行されたタスクは、作業が20倍に並列化され、別々のワーカーで個別に実行されたタスクとほぼ同じ速さで機能しました。私たちはすべてのボトルネックを克服したように見えましたが、まだどの操作が本番システムの速度を低下させているのか正確にはわかりませんでした。システムに明らかに最適化が必要な場所がなくなったため、ワーカーがプロセッサリソースをどのように使用するかを調査することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラレルワーカーの1人で収集されたデータに基づいて、激しいスケジュールが作成されました。ローカルマシンで作業できる、きちんとした視覚化がありました。はい、ここに興味深い詳細があります。このデータのサイズは60 MBでした。これ</font></font><code>logger</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、激しい0xチャートで</font><font style="vertical-align: inherit;">単語</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">検索して見たもの</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/358/973/efc/358973efca61adf8a654ab855029daea.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xによるデータ分析</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
列で強調表示されている青緑色の領域は、プロセッサ時間の少なくとも15％がワーカーログの生成に費やされたことを示しています。</font><font style="vertical-align: inherit;">その結果、この時間を75％削減することができました。</font><font style="vertical-align: inherit;">確かに、これをどのように行ったかという話は、別の記事に引き寄せられます。</font><font style="vertical-align: inherit;">（ヒント：正規表現を使用し、プロパティで多くの作業を行いました）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この最適化の後、システムパフォーマンスを損なうことなく、1人のワーカーで最大30のタスクを同時に処理することができました。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並列ワーカーに切り替えると、EC2の年間コストが約30万ドル削減され、システムアーキテクチャが大幅に簡素化されました。</font><font style="vertical-align: inherit;">今では、以前よりも約30分の1の数のコンテナを生産で使用しています。</font><font style="vertical-align: inherit;">私たちのシステムは、発信リクエストの処理の遅延や、ユーザーからのピークAPIリクエストに対してより耐性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
銀行との統合サービスを並列化しながら、多くの新しいことを学びました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低レベルのシステムメトリックを持つことの重要性を過小評価しないでください。</font><font style="vertical-align: inherit;">ガベージコレクションとメモリ使用量に関連するデータを監視する機能は、システムの展開と最終化に多大な支援を提供してくれました。</font></font></li>
<li>  —   . ,     ,         « »  .</li>
<li>    Node.js      . ,   ,  V8    ,   ,    ,     ,         .   ,      ,     V8       Node.js.</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムを構成するすべてのメカニズムのドキュメントを注意深く読むことが非常に重要です。</font></font><code>maxSocket</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node.jsのドキュメントに</font><font style="vertical-align: inherit;">あるデータを信頼し</font><font style="vertical-align: inherit;">ましたが、多くの調査の結果、AWSではNode.jsの標準的な動作が変化していることがわかりました。</font><font style="vertical-align: inherit;">おそらく、他の誰かのインフラストラクチャに基づいた各プロジェクトで、同様のことが発生する可能性があります。</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読者の皆様！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node.jsプロジェクトをどのように最適化しますか？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja483678/index.html">非常に高速なPythonプログラムの開発</a></li>
<li><a href="../ja483680/index.html">避けるべき一般的なプログラミングの欠陥</a></li>
<li><a href="../ja483682/index.html">JavaScriptのバンドルとパフォーマンス：ベストプラクティス</a></li>
<li><a href="../ja483684/index.html">PHPダイジェストNo. 171（2020年1月1〜13日）</a></li>
<li><a href="../ja483686/index.html">2020年に自分より上に成長したいWeb開発者のための32のヒント</a></li>
<li><a href="../ja483698/index.html">LoRaWANが現代のモノのインターネットの構築にどのように役立つか</a></li>
<li><a href="../ja483700/index.html">今年の物理的な結果-2019</a></li>
<li><a href="../ja483704/index.html">1月13日から19日までのモスクワでのデジタルイベント</a></li>
<li><a href="../ja483708/index.html">ドップラー効果、または交通警察レーダーによる速度決定の正確さの問題</a></li>
<li><a href="../ja483712/index.html">HighLoad ++、Yuri Nasretdinov（VK）：VKが数万台のサーバーからClickHouseにデータを挿入する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>