<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏿 🍎 ❣️ 使用SSR（服务器端渲染）的Nuxt服务器端内存泄漏 🌏 👼🏽 🥗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！对于使用Vue SSR（尤其是Nuxt）的任何人来说，本文都是必读的。这是关于使用axios时的内存泄漏。
 
 背景
 半年前，我进入了一个带有VueJS + Nuxt堆栈的项目，其独特之处在于Nod服务器（Nuxt）一直死在产品中，而新的服务器正在取代它们。根据图形和日志，很明显，节点进...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>使用SSR（服务器端渲染）的Nuxt服务器端内存泄漏</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489838/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈Ha！</font><font style="vertical-align: inherit;">对于使用Vue SSR（尤其是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuxt）的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任何人来说，本文都是</font><b><font style="vertical-align: inherit;">必读的</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是关于使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">axios</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时的内存泄漏</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
半年前，我进入了一个带有VueJS + Nuxt堆栈的项目，其独特之处在于Nod服务器（Nuxt）一直死在产品中，而新的服务器正在取代它们。</font><font style="vertical-align: inherit;">根据图形和日志，很明显，节点进程可操作性达到100％，并且由于内存不足错误而失败。</font><font style="vertical-align: inherit;">这时，一个新的上升到了终止进程的位置，大约花费了30秒，这足以使用户收到502错误。</font><font style="vertical-align: inherit;">显然，在代码中的某处需要发现内存泄漏。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想立即强调要点，因为仅阅读本文的一部分可能无法回答您的所有问题：</font></font><br>
<br>
<ol>
<li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主题的相关性 </font></font></b> </li>
<li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Axios拦截器</font></font></b> </li>
<li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">runInNewContext</font></font></b> </li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.主题的相关性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们许多人会做，我开始寻找互联网上的解决方案，我的查询看起来是这样的：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的NodeJS内存泄漏</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuxt内存泄漏</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在生产nuxt内存泄漏</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，关于stackoverflow的二十个问题都没有帮助我，但是我学会了如何通过chrome跟踪内存使用情况：//检查。</font><font style="vertical-align: inherit;">令我失望的是，我发现由于某种原因而未清除的所有内存中有90％是某些Vue的函数，例如renderComponent，renderElement等。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fa/oo/gn/faoognc9ndcq9h5lw7omfenjq78.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Axios拦截器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们迅速经历了折磨，寻找问题，并立即发现</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">axios.interceptor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应当为</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">所有事情负责</font></a><font style="vertical-align: inherit;">（对不起，Habr，发现有罪）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
立即预订创建axios的方法，如下所示：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> baseAxios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> axios = baseAxios.create({
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span>,<font></font>
});<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> axios;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并附加到应用程序上下文中，如下所示： </font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'./index'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(!context.axios) {<font></font>
    context.axios = axios;<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">长时间搜索泄漏后，我发现如果禁用所有axios.interceptors，则内存将开始被清理。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有什么事？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拦截器是一种代理，可以拦截所有响应或请求，并允许您执行带有答案的任何代码（例如，处理错误）或在对所有请求全局发送请求之前添加某些内容，并且方便吗？</font><font style="vertical-align: inherit;">这是外观的示例（文件“ plugins / axios /拦截器.js”）</font></font></li>
</ul><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">{ axios }</span>) </span>{<font></font>
<font></font>
  <span class="hljs-keyword">const</span> interceptor = axios.interceptors.response.use( <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> response;<font></font>
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-comment">//-   ,  </span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);<font></font>
  });<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从这里开始乐趣。</font><font style="vertical-align: inherit;">我们在nuxt.config.js中添加了通过插件添加拦截器的功能</font></font><br>
<br>
<pre><code class="javascript hljs">  plugins: [<font></font>
    { <span class="hljs-attr">src</span>: <span class="hljs-string">'~/plugins/axios/bindContext'</span> },<font></font>
    { <span class="hljs-attr">src</span>: <span class="hljs-string">'~/plugins/axios/interceptor'</span> },<font></font>
  ]</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，对于每个新请求，nuxt自动执行所有插件功能，然后执行nuxtServerInit，然后一切正常。也就是说，对于第一个用户，我们在服务器端创建一个拦截器，在asyncData或获取的组件中的某个位置发出请求，然后拦截器按预期工作，然后第二个用户进入并创建第二个拦截器，并且函数内的代码将工作2次！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了更好地理解我的话，我将绘制一个计数器，该计数器在每次调用该函数时递增，并在索引上敲5次。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ly/en/uu/lyenuuid32whlgsdqja6nz8z6s8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以注意到发生了15次调用，这是1 + 2 + 3 + 4 + 5，我还花了一些时间来创建下一个拦截器以确保挑战是以前创造的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从学校开始，我们都很好地记住了算术级数的公式，从1到n的总和可以写成n *（n +1）/2。事实证明，当第1000个用户进入时，我们的函数将被调用1000次，总共这已经是500万次呼叫，因此，如果负载是中等或很高，那么如果服务器崩溃，也不要感到惊讶。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 解决问题 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UPD。</font><font style="vertical-align: inherit;">解决方案＃0-注释描述了此问题的好的解决方案。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解决方案1-不要使用axios.interceptors。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解决方案2-一切都很简单，您需要在axios文档的指导下自行清理拦截器</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">{ axios }</span>) </span>{<font></font>
<font></font>
  <span class="hljs-keyword">const</span> interceptor = axios.interceptors.response.use( <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(process.server) {<font></font>
      axios.interceptors.response.eject(interceptor);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> response;<font></font>
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-keyword">if</span>(process.server) {<font></font>
      axios.interceptors.response.eject(interceptor);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);<font></font>
  });<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这仅需要在服务器端完成，因为否则，在客户端，成功完成任何第一个请求后，此拦截器将停止执行。</font><font style="vertical-align: inherit;">在我们仍在服务器上并处理下一个用户的请求时，还有一个细微差别：在这种情况下，可能有几个（但几个）请求，然后弹出此拦截器，除第一个拦截器之外的所有请求都不会通过要独立考虑需要执行弹出操作的那一刻，最简单的方法是通过setTimeout，例如，在10秒后，然后我们可以假定在服务器端，我们将设法完成对当前用户的所有请求，并且所有这些请求将在此期间执行。拦截器仍将处于活动状态。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> runInNewContext </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个非常有趣的选项，因此无法在本地复制该错误，但是很容易在构建中复制该错误。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当我准备撰写本文时，我创建了starter-template nuxt项目来重现此问题，以及让我为每个普通用户感到惊讶的原因-拦截器执行了1次，而不是n次。</font><font style="vertical-align: inherit;">问题是，当我们编写npm run dev时-默认情况下此选项为true，并且每次我们从服务器端的插件执行功能时，上下文都是新的（显然来自标志名），并且在构建时自动完成为在产品中获得更好的性能，返回false，因此我不得不在nuxt.config.js中禁用此选项</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-attr">render</span>: {
    <span class="hljs-attr">bundleRenderer</span>: {
      <span class="hljs-attr">runInNewContext</span>: <span class="hljs-literal">false</span>,<font></font>
    },<font></font>
  },<font></font>
</code></pre> <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 结论 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对我来说，这个问题非常严重，值得特别注意。</font><font style="vertical-align: inherit;">也许这个问题不仅涉及Vue ssr，还涉及其他问题，不仅涉及axios，还涉及具有类似于拦截器的代理的任何其他HTTP客户端。</font><font style="vertical-align: inherit;">如果您有任何疑问，可以通过Telegram </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@alexander_proydenko</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给我</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">写信</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">本文中使用的所有代码都可以在github上</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN489826/index.html">关于JavaScript中Math对象的可变方法</a></li>
<li><a href="../zh-CN489828/index.html">在Node.js中使用GeoJSON：实用介绍</a></li>
<li><a href="../zh-CN489832/index.html">人造原子珠：大环操纵</a></li>
<li><a href="../zh-CN489834/index.html">将您的智能家居设备嵌入到SmartThings生态系统中</a></li>
<li><a href="../zh-CN489836/index.html">未来的激光雷达：11,000台激光器，而不是128台激光器</a></li>
<li><a href="../zh-CN489840/index.html">驱动器解剖：硬盘驱动器</a></li>
<li><a href="../zh-CN489844/index.html">一些Java反编译器的比较分析</a></li>
<li><a href="../zh-CN489848/index.html">为什么我的同事/员工的行为像@％§？</a></li>
<li><a href="../zh-CN489850/index.html">安全周09：谁负责Android安全？</a></li>
<li><a href="../zh-CN489852/index.html">Linux上的ASP.Net Core中的透明身份验证</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>