<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏼 👨🏾‍🔬 🐪 当布隆过滤器不合适时 💆🏾 🤘🏾 👧🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我从大学得知Bloom过滤器，这是一种以Burton Bloom命名的概率数据结构。但是我没有机会使用它。上个月，这样的机会出现了-这种结构使我着迷。但是，我很快发现了她的一些缺陷。本文是关于我与Bloom过滤器的短暂恋情的故事。
 
 在研究IP欺骗的过程中，有必要检查传入数据包中的IP地址，并将...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>当布隆过滤器不合适时</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491132/"><img src="https://habrastorage.org/webt/7x/rh/8w/7xrh8wafuzqnbs-o1jpgzjxtruw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我从大学得知</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom过滤器</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是一种以Burton Bloom命名的概率数据结构。但是我没有机会使用它。上个月，这样的机会出现了-这种结构使我着迷。但是，我很快发现了她的一些缺陷。本文是关于我与Bloom过滤器的短暂恋情的故事。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在研究</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP欺骗</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的过程中</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">，</font></a><font style="vertical-align: inherit;">有必要检查传入数据包中的IP地址，并将其与我们数据中心的地理位置进行比较。例如，来自意大利的包裹不应送到巴西的数据中心。这个问题看似简单，但是在不断变化的Internet环境中，它远非简单易行。可以说，最后我积累了很多大的文本文件，它们的内容大致如下：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7cf/4b4/f67/7cf4b4f67fdf8b4d8a88c2685051c15f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着来自解析的IP地址192.0.2.1的请求记录在Cloudflare数据中心编号107中。这些数据来自许多来源，包括我们的主动和被动样本，我们拥有的某些域的日志（例如，</font></font><code>cloudflare.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），开放源代码（例如BGP表）等。同一行通常在几个文件中重复。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我得到了一个巨大的此类数据集。</font><font style="vertical-align: inherit;">在某个时候，在所有收集的资源中，我计算了10亿行。</font><font style="vertical-align: inherit;">通常，我编写bash脚本来预处理输入数据，但是在这种规模下，这种方法不起作用。</font><font style="vertical-align: inherit;">例如，从600 MIB和40万行的这个小文件删除重复发生...永恒：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfa/dc1/9c0/bfadc19c083b6a31bc34b568cdc81d74.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我只想说，与该类型的普通命令是重复数据删除线</font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在各种配置（见</font></font><code>--parallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>--buffer-size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>--unique</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）不是最好的这样一个大的数据集。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">布隆过滤器</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/3a6/110/0e6/3a61100e64277b6a515666b8bf0293f9.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大卫·爱泼斯坦</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">（</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">David Epstein）</font></a><font style="vertical-align: inherit;">在公共领域的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">插图</font></a></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
然后，我突然意识到：不要对台词进行排序！您需要删除重复项，因此某种“设置”数据结构会更快地工作。另外，我大致知道输入文件的大小（唯一行数），并且某些数据的丢失并不重要，也就是说，概率数据结构非常合适。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这非常适合Bloom过滤器！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在阅读</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关Bloom过滤器的Wikipedia时</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这就是我看待此数据结构的方式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您将如何实现</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多元化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？给定理想的哈希函数和无限内存，我们可以简单地创建无限位图并为每个元素设置位数</font></font><code>hash(item)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这为“众多”提供了理想的数据结构。</font><font style="vertical-align: inherit;">对？</font><font style="vertical-align: inherit;">琐碎的。</font><font style="vertical-align: inherit;">不幸的是，哈希函数相撞，并且无限内存不存在，因此在我们的现实中我们必须妥协。</font><font style="vertical-align: inherit;">但是我们可以计算碰撞的可能性并管理该值。</font><font style="vertical-align: inherit;">例如，我们有一个很好的哈希函数和128 GB的内存。</font><font style="vertical-align: inherit;">我们可以计算出每个新元素的碰撞概率为1到1099511627776。当您添加更多元素时，该概率随着位图的填充而增加。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，我们可以应用多个哈希函数并获得更密集的位图。</font><font style="vertical-align: inherit;">这是Bloom过滤器运作良好的地方，它是一组具有四个变量的数学数据：</font></font><br>
<br>
<ul>
<li><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -插入的元素数（基数）</font></font><br>
</li>
<li><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -位图使用的内存</font></font><br>
</li>
<li><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -为每个输入计算的哈希函数数</font></font><br>
</li>
<li><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -误报的可能性</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
给定基数</font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和所需的误报率</font></font><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，Bloom过滤器返回所需的内存</font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和所需的哈希函数数量</font></font><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
查看一下</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出色的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thomas Hurst </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">可视化，</font></a><font style="vertical-align: inherit;">了解参数如何相互影响。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在直觉的指导下，我将概率工具mmuniq-bloom添加到我的武器库中，该工具使用输入STDIN并仅在STDOUT中返回唯一行。</font><font style="vertical-align: inherit;">它应该比</font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font><font style="vertical-align: inherit;">的组合要快得多</font></font><code>uniq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他在那：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了简化和提高速度，我最初设置了一些参数。首先，除非另有说明，否则mmuniq-bloom使用八个哈希函数k = 8。对于我们的数据大小，这似乎接近最佳数目，并且散列函数可以快速产生八个像样的散列。然后，我们将</font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位图中</font><font style="vertical-align: inherit;">的内存对齐</font><font style="vertical-align: inherit;">到2的幂，以免进行昂贵的操作</font></font><code>%modulo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而该</font><font style="vertical-align: inherit;">操作</font><font style="vertical-align: inherit;">在汇编器中会变慢</font></font><code>div</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果数组等于2的幂，我们可以简单地使用按位与（有趣的是，阅读</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编译器如何通过乘以魔术常数来优化某些除法运算</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们可以在之前使用的同一数据文件上运行它：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3fa/019/d05/3fa019d05b8d6a72ad1ea3bde9c15a19.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哦，那好多了！ 12秒而不是2分钟。该程序使用优化的数据结构，相对有限的内存，优化的行解析和良好的输出缓冲...而且，与工具相比，这12秒钟似乎是永恒</font></font><code>wc -l</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/953/ede/adb/953edeadb5701d03f92c7717f159f20d.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
发生了什么？我知道算入字符串</font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比计算唯一字符串</font><font style="vertical-align: inherit;">要</font><font style="vertical-align: inherit;">容易，但是26倍的时差真的合理吗？ CPU需要</font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必须用于计算哈希。该实用程序</font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会花费处理器，而是为4000万行中的每行执行所有这些奇怪的数学运算。我使用了一个相当平凡的哈希函数</font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可以肯定它会烧坏处理器，对吗？让我们通过仅运行哈希函数而</font><i><font style="vertical-align: inherit;">不是</font></i><font style="vertical-align: inherit;">哈希来进行验证</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不使用Bloom过滤器执行任何操作：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f5e/7a0/e0f/f5e7a0e0f26a3136ca3d0a9b362e0fe3.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这很奇怪。</font><font style="vertical-align: inherit;">尽管上一次运行的整个程序执行了12秒，但哈希函数的计算仅花费了大约2秒钟。</font><font style="vertical-align: inherit;">一个Bloom过滤器能否工作10秒钟？</font><font style="vertical-align: inherit;">这怎么可能？</font><font style="vertical-align: inherit;">这是如此简单的数据结构...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">秘密武器-探查器</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在是时候为该任务应用正确的工具了-让我们运行分析器，看看处理器在做什么。首先，让我们运行</font></font><code>strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以验证没有意外的系统调用：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7bc/29b/87c/7bc29b87cdeadac9a11ce78aa61129f6.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切看起来不错。十个调用</font></font><code>mmap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个4 ms（3971μs）都很有趣，但这很好。我们使用来预填充内存</font></font><code>MAP_POPULATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以防止由于缺少页面而导致的错误。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
你下一步怎么做？当然是</font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/1da/aa8/acc/1daaa8acc9e3a84d1f591ad94cd84387.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后让我们看一下结果：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/637/38f/3e2/63738f3e2a4bb1207927ecbc45b0cf3b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们实际上在主代码中消耗了87.2％的周期。让我们看看确切的位置。团队</font></font><code>perf annotate process_line --source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">立即显示出意外情况。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/17f/f6f/cc8/17ff6fcc833def72269a07f7fd54d9f0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们看到26.90％的处理器在</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但这还不是全部！编译器正确插入函数并扩展循环。事实证明，大多数循环都转到此行</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或行</font></font><code>uint64_t v = *p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5c0/a3e/59c/5c0a3e59c8f954146bed3b2f1478e0ba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
显然perf是错误的，如此简单的字符串如何占用这么多资源？但是，使用其他任何探查器重复测试都会显示相同的问题。例如，由于彩色图表，我喜欢将google-perftools与kcachegrind一起使用：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8af/fbd/e9e/8affbde9e2b92d4da89d445314ec4654.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可视化的结果如下：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/130/ea3/9f9/130ea39f9a8c6a22c252381c3af88045.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我总结一下到目前为止已经发现的内容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
标准实用</font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序在0.45 s的处理器时间内处理600 MiB文件。我们优化的工具</font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以运行12秒。处理器在一条指令上烧毁</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，从而取消了对内存的引用...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6aa/3dd/e6a/6aa3dde6a6562dad5d0b3b2fa94c4565.jpg"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jose Nicdao的</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">图像</font></a><font style="vertical-align: inherit;">，CC BY / 2.0</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
哦！我怎么会忘记随机访问内存</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真的很</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">慢！非常非常非常慢！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个程序员应该知道</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">数字</font></a><font style="vertical-align: inherit;">，一次访问RAM大约需要100 ns。让我们数一下：4000万行，每行8个散列。由于我们的Bloom过滤器的大小为128 MiB，因此在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的旧硬件上，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它不适合L3缓存！散列均匀分布在广泛的内存中-每个散列都会产生高速缓存未命中。全部放在一起，结果...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b54/7e8/2e6/b547e82e6368f26843834121b1765103.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实证明，仅在访问内存时32秒就会耗尽。真正的程序仅用了12秒，因为Bloom筛选器仍然受益于缓存。这很容易看到</font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2b8/199/785/2b8199785c666437f37b9d96c209670f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的，我们应该至少有3.2亿个高速缓存未命中（LLC-load-misses），但是只有2.8亿个发生：这仍然不能解释为什么程序在短短的12秒钟内就能工作。但是这没关系。重要的是，缓存未命中的数量是一个实际问题，我们只能通过减少内存访问的数量来解决它。让我们尝试配置布隆过滤器只使用一个哈希函数：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/052/bec/d4f/052becd4ffe91553d1d3b01bfa53755b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好哦！真的很痛！为了使每10,000条线发生碰撞的可能性为1，Bloom过滤器需要64 GB的内存。这太糟糕了！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，似乎速度没有显着提高。</font><font style="vertical-align: inherit;">操作系统为我们准备内存需要22秒，但是我们仍然在用户空间上花了11秒。</font><font style="vertical-align: inherit;">我认为，由于显着增加的内存大小，现在访问缓存的可能性较低，从而弥补了对内存进行罕见访问的所有优势。</font><font style="vertical-align: inherit;">早期，对于Bloom过滤器，128 MiB就足够了！</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拒绝布隆过滤器</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这太荒谬了。</font><font style="vertical-align: inherit;">为了减少误报的可能性，您必须在Bloom过滤器中使用大量的哈希（例如，八个）并进行大量的内存访问，或者保留一个哈希函数，但要使用大量的内存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们实际上没有内存限制，我们想最大程度地减少对其的调用。</font><font style="vertical-align: inherit;">我们需要一个数据结构，该数据结构每个元素最多损失一个高速缓存未命中，并使用少于64 GB的RAM。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，您可以实现复杂的数据结构，例如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">布谷鸟过滤器</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是肯定有一个更简单的选择。</font><font style="vertical-align: inherit;">好的老式线性探测哈希表又如何呢？</font><i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Vadims Podans的</font></a></font></i></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c29/a0d/136/c29a0d136e80e5fc0a6f90f1cab1378e.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插图</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">认识mmuniq哈希</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是使用哈希表的mmuniq-bloom的新版本：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-hash.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们将存储来自</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'siphash24'函数的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 64位哈希值，而不是Bloom过滤器的位</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这样可以更好地防止哈希冲突：比每10,000行一个更好。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们来数数。</font><font style="vertical-align: inherit;">将一个新项目添加到一个哈希表中，比如说有4000万个条目，则有可能发生哈希冲突</font></font><code>40 000 000/2^64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这大约是4610亿中的1-可能性很小。</font><font style="vertical-align: inherit;">但是，我们不会在预填充集中添加一个元素！</font><font style="vertical-align: inherit;">相反，我们将4,000万行添加到最初为空的集合中。</font><font style="vertical-align: inherit;">根据</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生日悖论</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这大大增加了碰撞的可能性。</font><font style="vertical-align: inherit;">一个合理的近似值是一个估计值</font></font><code>'~n^2/2m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在我们的例子中是</font></font><code>~(40M^2)/(2*(2^64))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。原来，在23,000个元素中有一个机会，换句话说，有了良好的哈希函数，我们期望在4000万个元素的23,000个随机集合之一中发生碰撞。这是一个非零的概率，但仍然比Bloom过滤器中的概率要好，并且对于我们的用例来说是完全可以容忍的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
带有哈希表的代码比Bloom过滤器中的工作更快，具有更好的内存访问模式和更低的误报率。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0ea/5c5/817/0ea5c5817289f136355f452748da0f86.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不必担心“哈希冲突”这一行，它仅显示哈希表的填充量。</font><font style="vertical-align: inherit;">我们使用线性感应，因此当我们进入全套时，我们只取下一个空的。</font><font style="vertical-align: inherit;">在我们的例子中，我们必须平均跳过0.7组才能在表中找到一个空白点。</font><font style="vertical-align: inherit;">这个是正常的。</font><font style="vertical-align: inherit;">由于我们以线性顺序遍历集合，因此存储器必须在质量上已满。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从前面的示例中，我们知道哈希函数大约需要两秒钟。</font><font style="vertical-align: inherit;">我们得出的结论是，4000万次内存访问大约需要四秒钟。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">得到教训</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当可以预测采样模式时，现代处理器确实擅长顺序访问内存（请参阅</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缓存预取</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。另一方面，随机访问内存非常昂贵。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高级数据结构非常有趣，但是要小心。现代计算机要求使用缓存优化算法。当使用不适用于L3的大型数据集时，优先选择命中数，而不是优化所使用的内存量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以公平地说，布隆过滤器放在L3缓存中时表现出色。但是，如果没有，那么它们将是可怕的。这不是新闻：Bloom筛选器针对内存量（而不是对其的调用次数）进行了优化。例如，请参阅</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于杜鹃过滤器的科学文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一件事是关于哈希函数的无休止的讨论。老实说，在大多数情况下，这并不重要。</font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与随机访问内存的成本相比</font><font style="vertical-align: inherit;">，计算甚至复杂的哈希函数</font><font style="vertical-align: inherit;">的成本</font><font style="vertical-align: inherit;">似乎也</font><font style="vertical-align: inherit;">很小。在我们的案例中，简化哈希函数只会带来很小的好处。 CPU时间只是浪费在其他地方-等待内存！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一位同事经常说：“可以假设现代处理器是无限快的。它们以无限的速度工作，直到它们紧贴</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记忆墙</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为止</font><font style="vertical-align: inherit;">。” </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，不要重复我的错误。您总是需要首先使用</font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并查看IPC计数器（每个周期的指令）。</font><font style="vertical-align: inherit;">如果小于1，通常意味着程序在等待内存时被卡住。</font><font style="vertical-align: inherit;">最佳值在两个以上。</font><font style="vertical-align: inherit;">这意味着工作负载主要在CPU上。</font><font style="vertical-align: inherit;">不幸的是，在我的任务中，IPC仍然很低...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高级mmuniq</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在同事的帮助下，我基于哈希表编写了mmuniq工具的改进版本。</font><font style="vertical-align: inherit;">这是代码：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它可以动态更改哈希表的大小，支持带有任意基数的输入。</font><font style="vertical-align: inherit;">然后，它有效地利用</font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU中</font><font style="vertical-align: inherit;">的提示来处理数据包中的数据</font><font style="vertical-align: inherit;">，从而使程序速度提高了35-40％。</font><font style="vertical-align: inherit;">请注意，</font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在代码中</font><font style="vertical-align: inherit;">大量使用</font><font style="vertical-align: inherit;">很少能发挥作用。</font><font style="vertical-align: inherit;">为了使用此功能，我专门对算法进行了重新排序。</font><font style="vertical-align: inherit;">经过所有改进，执行时间减少到2.1秒：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e40/4df/9c4/e404df9c42a97be2f1051a69f98116e6.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结束</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
试图超越“ sort / uniq”组合的基本工具的创建揭示了现代计算的一些隐藏功能。</font><font style="vertical-align: inherit;">经过一番汗水，我们将程序从两分钟多缩短到了两秒。</font><font style="vertical-align: inherit;">在开发过程中，我们了解了对内存的随机访问的延迟以及缓存友好型数据结构的功能。</font><font style="vertical-align: inherit;">奇异的数据结构吸引了人们的注意，但是在实践中，减少对内存的随机访问次数通常更为有效。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN491116/index.html">现代识别标准：OAuth 2.0，OpenID Connect，WebAuthn</a></li>
<li><a href="../zh-CN491118/index.html">开发人员心：第五代控制台的Devkit（第1部分）</a></li>
<li><a href="../zh-CN491120/index.html">$ mol：4年后</a></li>
<li><a href="../zh-CN491122/index.html">HiSuite备份的取证分析</a></li>
<li><a href="../zh-CN491130/index.html">要记住的Vue功能</a></li>
<li><a href="../zh-CN491134/index.html">不可避免地要通过ISO / IEC 27001认证的5个阶段。否定</a></li>
<li><a href="../zh-CN491136/index.html">在Angular或丢失的ng-content文档中投影内容</a></li>
<li><a href="../zh-CN491138/index.html">卫星与反塔融合</a></li>
<li><a href="../zh-CN491146/index.html">针对开发人员的UML</a></li>
<li><a href="../zh-CN491150/index.html">我是如何欺骗诈骗者的，或者仅是网上诱骗面板的内部的黑客</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>