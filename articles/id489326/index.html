<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™‹ ğŸ© ğŸ§œğŸ½ Refleksi Pengujian Perusahaan yang Efektif ğŸ‘©ğŸ¼â€ğŸ’» â› ğŸ™ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 
 
 Baru-baru ini, kami telah kembali ke studi menyeluruh tentang topik pengujian, dan dalam rencana yang akan datang kami bahkan memiliki...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Refleksi Pengujian Perusahaan yang Efektif</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489326/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baru-baru ini, kami telah kembali ke studi menyeluruh tentang topik pengujian, dan dalam rencana yang akan datang kami bahkan memiliki buku yang sangat bagus tentang Unit Testing. </font><font style="vertical-align: inherit;">Pada saat yang sama, kami percaya bahwa konteks penting dalam topik ini karena tidak ada tempat lain, oleh karena itu hari ini kami menawarkan terjemahan dua publikasi (digabung menjadi satu) yang diterbitkan di blog spesialis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java EE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terkemuka </font><font style="vertical-align: inherit;">Sebastian Dashner - yaitu, 1/6 dan 2/6 dari seri â€œ Pikiran tentang pengujian perusahaan yang efisien. "</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengujian perusahaan adalah topik yang belum diperiksa sedetail yang kami inginkan. </font><font style="vertical-align: inherit;">Dibutuhkan banyak waktu dan upaya untuk menulis dan terutama untuk mendukung tes, namun, mencoba menghemat waktu dengan meninggalkan tes bukanlah pilihan. </font><font style="vertical-align: inherit;">Berapa volume tugas, pendekatan, dan teknologi pengujian yang perlu ditelusuri untuk meningkatkan efektivitas pengujian?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengantar</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terlepas dari berbagai jenis tes dan ruang lingkupnya, tujuan mempersiapkan serangkaian tes adalah untuk memastikan pada bahan ini bahwa dalam produksi aplikasi kita akan bekerja persis seperti yang diharapkan. </font><font style="vertical-align: inherit;">Motivasi seperti itu harus menjadi yang utama ketika memeriksa apakah sistem memenuhi tugas, jika kita mempertimbangkan sistem ini dari sudut pandang pengguna. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena rentang perhatian dan pengalihan konteks adalah hal yang harus diperhitungkan, kita harus memastikan bahwa pengujian kami tidak berjalan dan diuji dalam waktu yang lama dan bahwa hasil pengujian dapat diprediksi. </font><font style="vertical-align: inherit;">Saat menulis kode, verifikasi kode yang cepat (layak dalam satu detik) sangat penting - ini memastikan produktivitas tinggi dan fokus selama bekerja.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sisi lain, kita harus memastikan dukungan pengujian. Perubahan perangkat lunak sangat sering, dan dengan cakupan kode yang substansial dengan uji fungsional, setiap perubahan fungsional pada kode produksi akan memerlukan perubahan pada tingkat pengujian. Idealnya, kode pengujian harus berubah hanya ketika fungsionalitas, mis., Logika bisnis, berubah, dan tidak ketika membersihkan kode yang tidak perlu dan refactoring. Secara umum, skenario pengujian harus mencakup kemungkinan perubahan struktural yang tidak fungsional.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kami mempertimbangkan berbagai bidang penerapan tes, muncul pertanyaan: mana dari bidang ini yang sepadan dengan waktu dan upaya? </font><font style="vertical-align: inherit;">Misalnya, dalam aplikasi layanan mikro, serta dalam sistem apa pun yang menyediakan pekerjaan signifikan pada distribusi dan integrasi kode, tes integrasi sangat penting, membantu untuk meraba-raba batas-batas sistem. </font><font style="vertical-align: inherit;">Oleh karena itu, kita memerlukan cara yang efektif untuk menguji seluruh aplikasi secara keseluruhan selama pengembangan lokal, sambil menjaga lingkungan dan struktur aplikasi ini dalam bentuk yang sedekat mungkin dengan produksi.</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinsip dan Keterbatasan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terlepas dari solusi yang akan dipilih, mari kita mendefinisikan prinsip dan batasan berikut untuk rangkaian uji kami:</font></font><br>
<br>
<ul>
<li>     ,      .          ,           .    ,      ,       .</li>
<li>        ,   ,    .   ,     ,   ,    . ,       ,           .</li>
<li>     -       .    ,      ,        .</li>
<li>   ,      ,         . : Â«     HTTP-  gRPC,   JSON  -      enterprise-, ..?â€.</li>
<li>           ,     ,   -.        API,   DSL    .</li>
<li>    Â« Â»,  ,    ,          , , ,  â€œdevâ€  debug ()  ,  dev  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quarkus'</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Telepresence</a>,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">watch-and-deploy</a> (Â«  Â»)  .</li>
<li>              .  ,             , ,    ,          .                .</li>
<li>        , ,   -,        ,  ,         .     ,          , ,       .</li>
</ul><br>
<h4> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tes unit memeriksa perilaku modul tunggal, biasanya kelas, sementara semua faktor eksternal yang tidak terkait dengan struktur modul diabaikan atau disimulasikan. Tes unit harus memverifikasi logika bisnis masing-masing modul, tanpa memeriksa integrasi atau konfigurasinya lebih lanjut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam pengalaman saya, sebagian besar pengembang perusahaan memiliki ide yang cukup bagus tentang bagaimana tes unit dikompilasi. Untuk membuat kesan tentang ini, Anda dapat melihat contoh ini di proyek </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">pengujian kopi</font></a><font style="vertical-align: inherit;"> saya.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dalam sebagian besar proyek, JUnit digunakan bersama Mockito untuk mensimulasikan dependensi, dan idealnya dengan AssertJ untuk mendefinisikan pernyataan yang dapat dibaca secara efisien. Saya selalu menekankan bahwa unit test dapat dilakukan tanpa ekstensi atau permulaan khusus, yaitu untuk melakukan ini dengan JUnit yang biasa. Penjelasannya sederhana: ini semua tentang runtime, karena kita memerlukan kemampuan untuk menjalankan ratusan tes dalam hitungan milidetik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai aturan, unit test berjalan sangat cepat, dan mudah untuk mengumpulkan suite tes yang kompleks atau alur kerja khusus dari mereka, karena mereka mudah dijalankan dan tidak memaksakan batasan pada siklus hidup tes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, ketika Anda memiliki banyak unit test yang mensimulasikan dependensi dari kelas yang diuji, ada satu kelemahan: mereka terkait erat dengan implementasi (ini terutama berlaku untuk kelas dan metode), itulah sebabnya kode kami sulit untuk diperbaiki. Dengan kata lain, untuk setiap tindakan refactoring dalam kode produksi, itu juga memerlukan perubahan pada kode pengujian. Dalam kasus terburuk, pengembang bahkan mulai menolak sebagian refactoring, hanya karena terlalu memberatkan, dan kualitas kode dalam proyek menurun dengan cepat. Idealnya, pengembang harus dapat memperbaiki dan mengatur ulang elemen-elemen, asalkan karena ini tidak ada perubahan dalam aplikasi yang terlihat oleh pengguna. Tes unit tidak selalu menyederhanakan kode produksi refactoring.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi pengalaman menunjukkan bahwa tes unit sangat efektif dalam memeriksa kode yang padat diisi dengan logika singkat atau menggambarkan implementasi fungsi tertentu, misalnya, suatu algoritma, dan, pada saat yang sama, tidak berinteraksi sangat aktif dengan komponen lain. Semakin kurang kompleks atau padatnya kode dalam kelas tertentu, semakin sedikit kompleksitas siklomatiknya, atau semakin aktif berinteraksi dengan komponen lain, maka tes unit akan kurang efektif ketika menguji kelas ini. Terutama dalam kasus dengan layanan microser, di mana logika bisnis relatif sedikit terkandung, tetapi integrasi yang luas dengan sistem eksternal disediakan, mungkin ada sedikit kebutuhan untuk menggunakan tes unit dalam banyak. Dalam sistem seperti itu, modul individual (dengan pengecualian langka) biasanya mengandung sedikit logika khusus. Ini harus dipertimbangkan ketika memutuskanapa yang lebih tepat untuk menghabiskan waktu dan usaha.</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menguji situasi aplikasi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengatasi masalah yang menghubungkan tes dengan implementasi, Anda dapat mencoba pendekatan yang sedikit berbeda untuk memperluas cakupan tes. </font><font style="vertical-align: inherit;">Dalam buku saya, saya menulis tentang tes komponen, karena saya tidak dapat menemukan istilah yang lebih baik; </font><font style="vertical-align: inherit;">tetapi, pada dasarnya, dalam hal ini kita berbicara tentang pengujian situasi yang diterapkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tes situasi aplikasi adalah tes integrasi yang beroperasi pada level kode, yang tidak menggunakan wadah bawaan - mereka ditinggalkan demi mempercepat peluncuran. </font><font style="vertical-align: inherit;">Mereka menguji logika bisnis komponen yang terkoordinasi dengan baik, yang biasanya digunakan dalam kasus praktis tertentu, dari metode batas - dan kemudian turun ke semua komponen yang terkait dengannya. </font><font style="vertical-align: inherit;">Integrasi dengan sistem eksternal, misalnya, dengan basis data, ditiru menggunakan tiruan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Membangun skenario seperti itu tanpa menggunakan teknologi yang lebih maju yang secara otomatis akan menghubungkan komponen tampak seperti pekerjaan besar. Namun, kami mendefinisikan komponen uji yang dapat digunakan kembali, mereka juga merupakan mitra pengujian yang memperluas komponen dengan mensimulasikan, menghubungkan, dan juga menambahkan konfigurasi pengujian; semua ini dilakukan untuk meminimalkan jumlah upaya yang diperlukan untuk refactoring. Tujuannya adalah untuk menciptakan satu-satunya tanggung jawab yang membatasi tingkat pengaruh perubahan pada satu kelas (atau beberapa kelas) di bidang pengujian. Melakukan pekerjaan tersebut dengan tujuan untuk digunakan kembali, kami mengurangi jumlah total pekerjaan yang diperlukan, dan strategi seperti itu dibenarkan ketika proyek tumbuh, tetapi setiap komponen hanya membutuhkan perbaikan kecil, dan pekerjaan ini dengan cepat diamortisasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk lebih membayangkan semua ini, anggaplah kita sedang menguji kelas yang menjelaskan urutan kopi. Kelas ini mencakup dua kelas lainnya: </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>OrderProcessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gp/xj/tb/gpxjtb-txbhrd0hzssooxzh1lw0.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas tes berlipat ganda, </font></font><code>CoffeeShopTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>OrderProcessorTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mereka </font></font><code>*TD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berada di area uji proyek, di mana mereka mewarisi komponen </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>OrderProcessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terletak di area utama program. Rekan uji dapat mengatur simulasi dan logika koneksi yang diperlukan dan berpotensi memperluas antarmuka publik kelas menggunakan metode simulasi yang diperlukan dalam aplikasi ini, atau metode verifikasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut ini menunjukkan kelas uji ganda untuk komponen </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeShopTestDouble</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CoffeeShop</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CoffeeShopTestDouble</span><span class="hljs-params">(OrderProcessorTestDouble orderProcessorTestDouble)</span> </span>{<font></font>
        entityManager = mock(EntityManager.class);<font></font>
        orderProcessor = orderProcessorTestDouble;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyCreateOrder</span><span class="hljs-params">(Order order)</span> </span>{<font></font>
        verify(entityManager).merge(order);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyProcessUnfinishedOrders</span><span class="hljs-params">()</span> </span>{<font></font>
        verify(entityManager).createNamedQuery(Order.FIND_UNFINISHED, Order.class);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">answerForUnfinishedOrders</span><span class="hljs-params">(List&lt;Order&gt; orders)</span> </span>{
        <span class="hljs-comment">//     </span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas uji ganda dapat mengakses bidang dan konstruktor dari kelas dasar CoffeeShop untuk membangun dependensi. Di sini, dalam bentuk kembar uji, varian komponen lain juga digunakan, khususnya, </font></font><code> OrderProcessorTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mereka diperlukan untuk memanggil simulasi tambahan atau metode verifikasi, yang merupakan bagian dari kasus praktis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas uji ganda adalah komponen yang dapat digunakan kembali, yang masing-masing ditulis satu kali per ruang lingkup setiap proyek, dan kemudian digunakan dalam banyak kasus praktis:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeShopTest</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">private</span> CoffeeShopTestDouble coffeeShop;
    <span class="hljs-keyword">private</span> OrderProcessorTestDouble orderProcessor;<font></font>
<font></font>
    <span class="hljs-meta">@BeforeEach</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{<font></font>
        orderProcessor = <span class="hljs-keyword">new</span> OrderProcessorTestDouble();<font></font>
        coffeeShop = <span class="hljs-keyword">new</span> CoffeeShopTestDouble(orderProcessor);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testCreateOrder</span><span class="hljs-params">()</span> </span>{<font></font>
        Order order = <span class="hljs-keyword">new</span> Order();<font></font>
        coffeeShop.createOrder(order);<font></font>
        coffeeShop.verifyCreateOrder(order);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testProcessUnfinishedOrders</span><span class="hljs-params">()</span> </span>{<font></font>
        List&lt;Order&gt; orders = Arrays.asList(...);<font></font>
        coffeeShop.answerForUnfinishedOrders(orders);<font></font>
<font></font>
        coffeeShop.processUnfinishedOrders();<font></font>
<font></font>
        coffeeShop.verifyProcessUnfinishedOrders();<font></font>
        orderProcessor.verifyProcessOrders(orders);<font></font>
    }<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uji komponen memverifikasi kasus spesifik dari logika bisnis yang dipanggil pada titik masuk, dalam kasus ini </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tes tersebut diperoleh secara ringkas dan mudah dibaca, karena semua koneksi dan simulasi dilakukan pada kembar uji yang terpisah, dan kemudian mereka dapat menggunakan teknik penyaringan yang sangat khusus, seperti </font></font><code>verifyProcessOrders()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, kelas uji memperluas cakupan kelas produksi, memungkinkan Anda untuk menginstal mokee dan menggunakan metode yang memverifikasi perilaku. Terlepas dari kenyataan bahwa tampaknya membuat sistem seperti itu membutuhkan banyak upaya, biaya ini dengan cepat diamortisasi jika, dalam kerangka kerja seluruh proyek, kami memiliki banyak kasus praktis di mana komponen dapat digunakan kembali. Semakin banyak proyek kami tumbuh, semakin berguna pendekatan ini menjadi - terutama jika Anda memperhatikan waktu yang dibutuhkan untuk menyelesaikan tes. Semua test case kami masih berjalan menggunakan JUnit, dan dalam waktu sesingkat mungkin, semuanya dieksekusi dalam ratusan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah manfaat utama dari pendekatan ini: tes komponen berjalan secepat tes unit biasa, namun, mereka merangsang refactoring kode produksi, karena perubahan perlu dilakukan pada satu komponen atau hanya beberapa komponen. </font><font style="vertical-align: inherit;">Selain itu, meningkatkan rekan uji dengan penyetelan ekspresif dan metode pengujian khusus untuk area subjek kami, kami meningkatkan keterbacaan kode kami, memfasilitasi penggunaannya, dan menyingkirkan kode stereotip dalam skrip uji.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id489298/index.html">Wawancara informal dengan Maria Dolgusheva (HR dari Silicon Valley)</a></li>
<li><a href="../id489302/index.html">Edisi # 31: Pelatihan TI - masalah saat ini dan tantangan dari perusahaan terkemuka</a></li>
<li><a href="../id489304/index.html">Analisis data ChIP-seq: dari histones ke tugas komputer</a></li>
<li><a href="../id489306/index.html">[Habr]: Donat</a></li>
<li><a href="../id489310/index.html">Top 10: laporan terbaik dari Heisenbug 2019 Moskow</a></li>
<li><a href="../id489328/index.html">Null menyelinap: melanggar Opsi Scala menggunakan Java</a></li>
<li><a href="../id489332/index.html">Asisten Esensial dalam Kecerdasan Badan Intelijen Paling Efektif di Dunia (Bagian 3)</a></li>
<li><a href="../id489336/index.html">Kakek Antarmuka Sepeda Beracun. â€œBelajar, belajar, dan belajar lagiâ€ (s1 e3)</a></li>
<li><a href="../id489340/index.html">Sebagai unit maksimum untuk mengirimkan informasi di Internet menjadi 1500 byte</a></li>
<li><a href="../id489342/index.html">Pembuatan infrastruktur TI yang toleran terhadap kesalahan. Bagian 4. Menyebarkan Switch Cisco 3850 untuk Gateway Routing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>