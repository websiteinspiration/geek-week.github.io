<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßîüèø üë©üèΩ‚Äçü§ù‚Äçüë©üèº ü§¥üèæ In a Nutshell: Async / Await Best Practices in .NET ‚óæÔ∏è üï∫üèæ ‚ôüÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In anticipation of the start of the course, "C # Developer" prepared a translation of interesting material.
 
 
 
 Async / Await - Introduction
 The A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>In a Nutshell: Async / Await Best Practices in .NET</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/488082/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In anticipation of the start of the course, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"C # Developer"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> prepared a translation of interesting material.</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/6f/io/l8/6fiol8vwkg-r8ja-3zurutnz-ci.png"><br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async / Await - Introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Async / Await language construct has existed since C # version 5.0 (2012) and quickly became one of the pillars of modern .NET programming - any self-respecting C # developer should use it to improve application performance, overall responsiveness, and code readability. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / Await makes introducing asynchronous code deceptively simple and eliminates the need for the programmer to understand the details of its processing, but how many of us really know how it works and what are the advantages and disadvantages of this method? </font><font style="vertical-align: inherit;">There is a lot of useful information, but it is fragmented, so I decided to write this article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well then, let's delve into the topic.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State Machine (IAsyncStateMachine)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first thing to know is that under the hood, every time you have a method or function with Async / Await, the compiler actually turns your method into a generated class that implements the IAsyncStateMachine interface. This class is responsible for maintaining the state of your method during the life cycle of an asynchronous operation - it encapsulates all the variables of your method in the form of fields and breaks your code into sections that are executed during state machine transitions between states, so that the thread can leave the method and when it will return, the state will not change. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As an example, here is a very simple class definition with two asynchronous methods: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
using System.Threading.Tasks;</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Diagnostics;<font></font>
<font></font>
<span class="hljs-keyword">namespace</span> <span class="hljs-title">AsyncAwait</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncAwait</span><font></font>
    {<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncAwaitExample</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">int</span> myVariable = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">await</span> DummyAsyncMethod();<font></font>
            Debug.WriteLine(<span class="hljs-string">"Continuation - After First Await"</span>);<font></font>
            myVariable = <span class="hljs-number">1</span>;<font></font>
<font></font>
            <span class="hljs-keyword">await</span> DummyAsyncMethod();<font></font>
            Debug.WriteLine(<span class="hljs-string">"Continuation - After Second Await"</span>);<font></font>
            myVariable = <span class="hljs-number">2</span>;<font></font>
<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">DummyAsyncMethod</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A class with two asynchronous methods</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
If we look at the code generated during the assembly, we will see something like this: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qo/xe/63/qoxe63foidhmllsdwfi78tdhrsm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note that we have 2 new inner classes generated for us, one for each asynchronous method. These classes contain a state machine for each of our asynchronous methods. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further, having studied the decompiled code for </font></font><code><code>&lt;AsyncAwaitExample&gt;</code></code><code> d__0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we will notice that our internal variable is </font></font><code>¬´myVariable¬ª</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">now a class field: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/_m/qj/gd_mqjxvsjfw9-_zfd7740n42ua.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can also see other class fields used internally to maintain state </font></font><code>IAsyncStateMachine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The state machine goes through states using the method</font></font><code>MoveNext()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in fact, a large switch. </font><font style="vertical-align: inherit;">Notice how the method continues in different sections after each of the asynchronous calls (with the previous continuation label). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/km/li/ea/kmlieahswg0ebqn3db5nctfzsti.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That means async / await elegance comes at a price. </font><font style="vertical-align: inherit;">Using async / await actually adds some complexity (which you may not be aware of). </font><font style="vertical-align: inherit;">In server-side logic, this may not be critical, but in particular when programming mobile applications that take into account each CPU and KB memory cycle, you should keep this in mind, since the amount of overhead can quickly increase. </font><font style="vertical-align: inherit;">Later in this article, we will discuss best practices for using Async / Await only where necessary. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a pretty instructive explanation of the state machine, watch this </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video on YouTube</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When to Use Async / Await</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are generally two scenarios where Async / Await is the right solution.</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I / O related work</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Your code will expect something, such as data from a database, reading a file, calling a web service. </font><font style="vertical-align: inherit;">In this case, you should use Async / Await, not the Task Parallel Library.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU related work</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : your code will perform complex calculations. </font><font style="vertical-align: inherit;">In this case, you should use Async / Await, but you need to start work in another thread using Task.Run. </font><font style="vertical-align: inherit;">You may also consider using </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task Parallel Library</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
</ul><br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async all the way</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When you start working with asynchronous methods, you will quickly notice that the asynchronous nature of the code begins to spread up and down your hierarchy of calls - this means that you must also make your calling code asynchronous, and so on. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You might be tempted to ‚Äústop‚Äù this by blocking the code using Task.Result or Task.Wait, converting a small part of the application and wrapping it in a synchronous API so that the rest of the application is isolated from changes. Unfortunately, this is a recipe for creating hard to track deadlocks.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The best solution to this problem is to allow asynchronous code to grow in the codebase naturally. </font><font style="vertical-align: inherit;">If you follow this decision, you will see the extension of the asynchronous code to its entry point, usually an event handler or controller action. </font><font style="vertical-align: inherit;">Surrender to asynchrony without a trace! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
More information in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MSDN </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">article</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the method is declared as async, make sure there is await!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As we discussed, when the compiler finds an async method, it turns this method into a state machine. </font><font style="vertical-align: inherit;">If your code does not have await in its body, the compiler will generate a warning, but the state machine will nevertheless be created, adding unnecessary overhead for an operation that will never actually complete.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avoid async void</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async void is something that should really be avoided. </font><font style="vertical-align: inherit;">Make it a rule to use async Task instead of async void.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncVoidMethod</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//!</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncTaskMethod</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//!</span>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The async void and async Task methods</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
There are several reasons for this, including:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exceptions thrown in the async void method cannot be caught outside this method</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font></li>
</ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when an exception is thrown from the async Task or async Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method, this exception is caught and placed in the Task object. </font><font style="vertical-align: inherit;">When using async void methods, there is no Task object, so any exceptions thrown from the async void method will be called directly in the SynchronizationContext, which was active when the async void method was run. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider the example below. </font><font style="vertical-align: inherit;">The capture block will never be reached.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncVoidMethodThrowsException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"Hmmm, something went wrong!"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ThisWillNotCatchTheException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">try</span><font></font>
    {<font></font>
        AsyncVoidMethodThrowsException();<font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span>(Exception ex)<font></font>
    {<font></font>
        <span class="hljs-comment">//     </span><font></font>
        Debug.WriteLine(ex.Message);<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exceptions thrown in the async void method cannot be caught outside this method.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Compare with this code, where instead of async void we have async Task. </font><font style="vertical-align: inherit;">In this case, catch will be reachable.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncTaskMethodThrowsException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"Hmmm, something went wrong!"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ThisWillCatchTheException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">try</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> AsyncTaskMethodThrowsException();<font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (Exception ex)<font></font>
    {<font></font>
        <span class="hljs-comment">//    </span><font></font>
        Debug.WriteLine(ex.Message);<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The exception is caught and placed in the Task object.</font></font></i><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async void methods can cause unwanted side effects if the caller does not expect them to be asynchronous</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : if your asynchronous method returns nothing, use async Task (without a ‚Äú </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äù for Task) as the return type.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async void methods are very difficult to test</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : due to differences in error handling and layout, it is difficult to write unit tests that call async void methods. </font><font style="vertical-align: inherit;">Asynchronous MSTest test only works for asynchronous methods that return a Task or Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An exception to this practice are asynchronous event handlers. </font><font style="vertical-align: inherit;">But even in this case, it is recommended to minimize the code written in the handler itself - expect an async Task method that contains logic. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
More information in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MSDN </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">article</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefer return Task instead of return await</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As already discussed, every time you declare a method as asynchronous, the compiler creates a state machine class that actually wraps the logic of your method. This adds certain overhead that can accumulate, especially for mobile devices, where we have more stringent resource limits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sometimes a method does not have to be asynchronous, but it returns Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and allows the other side to handle it accordingly. If the last sentence of your code is an await return, you should consider refactoring it so that the return type of the method is Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(instead of async T). </font><font style="vertical-align: inherit;">Because of this, you avoid generating a state machine, which makes your code more flexible. </font><font style="vertical-align: inherit;">The only case we really want to wait is when we do something with the async Task result in the continuation of the method.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">AsyncTask</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//  !</span>
   <span class="hljs-comment">//...  -  </span>
   <span class="hljs-comment">//await -   ,  await  </span><font></font>
<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> GetData();<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">JustTask</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//!</span>
   <span class="hljs-comment">//...  -  </span>
   <span class="hljs-comment">// Task</span><font></font>
<font></font>
   <span class="hljs-keyword">return</span> GetData();<font></font>
<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefer return Task instead of return await</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Note that if we do not have await and instead return Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the return occurs immediately, so if the code is inside a try / catch block, the exception will not be caught. </font><font style="vertical-align: inherit;">Similarly, if the code is inside the using block, it will immediately delete the object. </font><font style="vertical-align: inherit;">See the next tip.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not wrap the return Task inside try..catch {} or using {} blocks</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Return Task can cause undefined behavior when used inside a try..catch block (an exception thrown by the asynchronous method will never be caught) or inside a using block, because the task will be returned immediately. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you need to wrap your asynchronous code in a try..catch or using block, use return await instead.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">ReturnTaskExceptionNotCaught</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-keyword">try</span><font></font>
   {<font></font>
       <span class="hljs-comment">// ...</span><font></font>
<font></font>
       <span class="hljs-keyword">return</span> GetData();<font></font>
<font></font>
   }<font></font>
   <span class="hljs-keyword">catch</span> (Exception ex)<font></font>
<font></font>
   {<font></font>
       <span class="hljs-comment">//     </span><font></font>
<font></font>
       Debug.WriteLine(ex.Message);<font></font>
       <span class="hljs-keyword">throw</span>;<font></font>
   }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">ReturnTaskUsingProblem</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> resource = GetResource())<font></font>
   {<font></font>
<font></font>
       <span class="hljs-comment">// ...  ,     , ,    </span><font></font>
<font></font>
       <span class="hljs-keyword">return</span> GetData(resource);<font></font>
   }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not wrap the return task inside blocks </font></font><code>try..catch{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or</font></font><code>using{}</code></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
More information in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> thread on stack overflow.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avoid using </font></font><code>.Wait()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>.Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- use instead</font></font><code>GetAwaiter().GetResult()</code></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">need to block</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> waiting for Async Task to complete, use </font></font><code>GetAwaiter().GetResult().</code> <code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wrap any exceptions in </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which complicates error handling. </font><font style="vertical-align: inherit;">The advantage </font></font><code>GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is that it returns the usual exception instead </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetAwaiterGetResultExample</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">// ,    ,     AggregateException  </span><font></font>
<font></font>
   <span class="hljs-keyword">string</span> data = GetData().Result;<font></font>
<font></font>
   <span class="hljs-comment">// ,   ,      </span><font></font>
<font></font>
   data = GetData().GetAwaiter().GetResult();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you need to block waiting for Async Task to complete, use the </font></font><code>GetAwaiter().GetResult().</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
More information at this </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the method is asynchronous, add the Async suffix to its name</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is the convention used in .NET to more easily distinguish between synchronous and asynchronous methods (with the exception of event handlers or web controller methods, but they still should not be explicitly called by your code).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous library methods should use Task.ConfigureAwait (false) to improve performance</font></font></h3><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The .NET Framework has the concept of a ‚Äúsynchronization context," which is a way to "get back to where you were before." Whenever a Task is waiting, it captures the current synchronization context before waiting. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the Task is completed </font></font><code>.Post()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the synchronization context </font><font style="vertical-align: inherit;">method is called </font><font style="vertical-align: inherit;">, which resumes work from where it was before. This is useful for returning to the user interface thread or for returning to the same ASP.NET context, etc.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When writing library code, you rarely need to go back to the context you were in before. When Task.ConfigureAwait (false) is used, the code no longer tries to resume from where it was before, instead, if possible, the code exits in the thread that completed the task, which avoids context switching. This improves performance slightly and can help avoid deadlocks.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ConfigureAwaitExample</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//   ConfigureAwait(false)   .</span><font></font>
<font></font>
   <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">await</span> GetData().ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typically, use ConfigureAwait (false) for server processes and library code. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is especially important when the library method is called a large number of times, for better responsiveness. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typically, use ConfigureAwait (false) for server processes in general. We don‚Äôt care which thread is used to continue, unlike applications in which we need to return to the user interface thread. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now ... In ASP.NET Core, Microsoft has done away with SynchronizationContext, so theoretically you don't need that. But if you write library code that could potentially be reused in other applications (e.g. UI App, Legacy ASP.NET, Xamarin Forms), this </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remains best practice</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a good explanation of this concept, watch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this video</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous task progress report</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A fairly common use case for asynchronous methods is to work in the background, free up the user interface thread for other tasks, and maintain responsiveness. In this scenario, you might want to report the progress back to the user interface so that the user can monitor the progress of the process and interact with the operation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To solve this common problem, .NET provides the IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font><font style="vertical-align: inherit;">interface </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which provides the Report </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font><font style="vertical-align: inherit;">method </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is invoked by an asynchronous task to report the progress to the caller. This interface is accepted as a parameter of the asynchronous method - the caller must provide an object that implements this interface.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET provides Progress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the default implementation of IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is actually recommended, as it handles all the low-level logic associated with saving and restoring the synchronization context. Progress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also provides an Action </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font><font style="vertical-align: inherit;">event and callback </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äî both called when a task reports progress. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Together, IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and Progress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">provide an easy way to transfer progress information from a background task to a user interface thread. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Please note that </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it can be a simple value, such as an int, or an object that provides contextual progress information, such as percentage of completion, a string description of the current operation, ETA, and so on. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider how often you report progress. </font><font style="vertical-align: inherit;">Depending on the operation you are performing, you may find that your code reports progress several times per second, which may result in the user interface becoming less responsive. </font><font style="vertical-align: inherit;">In such a scenario, it is recommended that progress be reported at larger intervals. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
More information in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the official Microsoft .NET blog.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancel Asynchronous Tasks</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another common use case for background tasks is the ability to cancel execution. </font><font style="vertical-align: inherit;">.NET provides the class CancellationToken. </font><font style="vertical-align: inherit;">The asynchronous method receives the CancellationToken object, which is then shared by the calling party code and the asynchronous method, thus providing a mechanism for signaling cancellation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the most common case, cancellation occurs as follows:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The caller creates a CancellationTokenSource object.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The caller calls the canceled asynchronous API and passes the CancellationToken from the CancellationTokenSource (CancellationTokenSource.Token).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The caller requests a cancellation using the CancellationTokenSource (CancellationTokenSource.Cancel ()) object.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The task confirms the cancellation and cancels itself, usually using the CancellationToken.ThrowIfCancellationRequested method.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note that in order for this mechanism to work, you will need to write code to check for cancellations requested at regular intervals (i.e. at each iteration of your code or at a natural breakpoint in the logic). </font><font style="vertical-align: inherit;">Ideally, after a cancel request, the asynchronous task should be canceled as quickly as possible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You should consider using undo for all methods that can take a long time to complete. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
More information in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the official Microsoft .NET blog.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Progress and Cancellation Report - Example</font></font></h4><br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Threading.Tasks;
<span class="hljs-keyword">using</span> System.Windows.Forms;
<span class="hljs-keyword">using</span> System.Threading;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">TestAsyncAwait</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncProgressCancelExampleForm</span> : <span class="hljs-title">Form</span><font></font>
   {<font></font>
       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncProgressCancelExampleForm</span>(<span class="hljs-params"></span>)</span><font></font>
       {<font></font>
           InitializeComponent();<font></font>
       }<font></font>
<font></font>
       CancellationTokenSource _cts = <span class="hljs-keyword">new</span> CancellationTokenSource();<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnRunAsync_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, EventArgs e</span>)</span><font></font>
<font></font>
       {<font></font>
<font></font>
           <span class="hljs-comment">//   .</span><font></font>
<font></font>
            &lt;<span class="hljs-keyword">int</span>&gt;   ,          ,   ,    , ETA  . .<font></font>
<font></font>
           <span class="hljs-keyword">var</span> progressIndicator = <span class="hljs-keyword">new</span> Progress&lt;<span class="hljs-keyword">int</span>&gt;(ReportProgress);<font></font>
<font></font>
           <span class="hljs-keyword">try</span><font></font>
<font></font>
           {<font></font>
               <span class="hljs-comment">//   ,         </span><font></font>
<font></font>
               <span class="hljs-keyword">await</span> AsyncMethod(progressIndicator, _cts.Token);<font></font>
<font></font>
           }<font></font>
<font></font>
           <span class="hljs-keyword">catch</span> (OperationCanceledException ex)<font></font>
<font></font>
           {<font></font>
               <span class="hljs-comment">// </span><font></font>
<font></font>
               lblProgress.Text = <span class="hljs-string">"Cancelled"</span>;<font></font>
           }<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnCancel_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, EventArgs e</span>)</span><font></font>
<font></font>
       {<font></font>
          <span class="hljs-comment">// </span><font></font>
           _cts.Cancel();<font></font>
<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReportProgress</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span></span>)</span><font></font>
<font></font>
       {<font></font>
           <span class="hljs-comment">//    </span><font></font>
<font></font>
           lblProgress.Text = <span class="hljs-keyword">value</span>.ToString();<font></font>
<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncMethod</span>(<span class="hljs-params">IProgress&lt;<span class="hljs-keyword">int</span>&gt; progress, CancellationToken ct</span>)</span><font></font>
<font></font>
       {<font></font>
<font></font>
           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<font></font>
<font></font>
           {<font></font>
              <span class="hljs-comment">//   ,     </span><font></font>
<font></font>
               <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<font></font>
<font></font>
               <span class="hljs-comment">//   </span><font></font>
<font></font>
               <span class="hljs-keyword">if</span> (ct != <span class="hljs-literal">null</span>)<font></font>
<font></font>
               {<font></font>
<font></font>
                   ct.ThrowIfCancellationRequested();<font></font>
<font></font>
               }<font></font>
<font></font>
               <span class="hljs-comment">//   </span><font></font>
<font></font>
               <span class="hljs-keyword">if</span> (progress != <span class="hljs-literal">null</span>)<font></font>
<font></font>
               {<font></font>
<font></font>
                   progress.Report(i);<font></font>
               }<font></font>
           }<font></font>
       }<font></font>
   }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waiting for a period of time</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you need to wait a while (for example, try again to check the availability of the resource), be sure to use Task.Delay - never use Thread.Sleep in this scenario.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waiting for several asynchronous tasks to complete</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Use Task.WaitAny to wait for the completion of any task. </font><font style="vertical-align: inherit;">Use Task.WaitAll to wait for all tasks to complete. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do I have to rush to switch to C # 7 or 8? </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sign up for a free webinar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to discuss this topic.</font></font></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en488060/index.html">Backblaze - 2019 hard drive statistics</a></li>
<li><a href="../en488062/index.html">Dynamics 365 & Power Platform Meetup at Lamoda - Report</a></li>
<li><a href="../en488064/index.html">Seven Reasons Why Linux</a></li>
<li><a href="../en488072/index.html">Is Koin Dependency Injection or Service Locator?</a></li>
<li><a href="../en488078/index.html">My bot for Russian AI Cup 2019</a></li>
<li><a href="../en488088/index.html">How Habr interacts with state bodies and other applicants. Transparency report for all years</a></li>
<li><a href="../en488092/index.html">Hackathons. How to get the most out and survive</a></li>
<li><a href="../en488096/index.html">400g. View from the side of Transmission. ZR / ZR +</a></li>
<li><a href="../en488098/index.html">How to create a Django project from a template</a></li>
<li><a href="../en488102/index.html">The relationship between C # and C #: REST, gRPC and everything in between</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>