<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ù üò´ üö¶ Fast routing and NAT on Linux üë®‚Äçüëß‚Äçüë¶ üíÜüèº ü¶â</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As IPv4 addresses are exhausted, many telecom operators are faced with the need to organize their clients' access to the network using address transla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Fast routing and NAT on Linux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501234/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As IPv4 addresses are exhausted, many telecom operators are faced with the need to organize their clients' access to the network using address translation. </font><font style="vertical-align: inherit;">In this article I will tell you how to get Carrier Grade NAT level performance on commodity servers.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A bit of history</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The topic of running out of IPv4 address space is no longer new. At some point, waiting lists appeared in RIPE, then there were exchanges on which they traded blocks of addresses and concluded transactions for their rent. Gradually, telecom operators began to provide Internet access services through the translation of addresses and ports. Someone did not manage to get enough addresses to give a ‚Äúwhite‚Äù address to each subscriber, while someone started saving money by refusing to buy addresses in the secondary market. Network equipment manufacturers supported this idea, as this functionality usually requires additional expansion modules or licenses. For example, with Juniper in the MX router lineup (except for the latest MX104 and MX204), NAPT can be performed on a separate MS-MIC service card, Cisco ASR1k requires a GN license,on Cisco ASR9k, a separate A9K-ISM-100 module and an A9K-CGN-LIC license to it. In general, pleasure costs a lot of money.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iptables</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The task of performing NAT does not require specialized computing resources; general-purpose processors that are installed, for example, in any home router, can solve it. </font><font style="vertical-align: inherit;">On a carrier scale, this problem can be solved using commodity servers running FreeBSD (ipfw / pf) or GNU / Linux (iptables). </font><font style="vertical-align: inherit;">We will not consider FreeBSD, because </font><font style="vertical-align: inherit;">I refused to use this OS for a long time, so let's focus on GNU / Linux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Turning address translation on is not at all difficult. </font><font style="vertical-align: inherit;">First you need to write the rule in iptables in the nat table:</font></font><br>
<br>
<pre><code class="bash hljs">iptables -t nat -A POSTROUTING -s 100.64.0.0/10 -j SNAT --to &lt;pool_start_addr&gt;-&lt;pool_end_addr&gt; --persistent
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The operating system will load the nf_conntrack module, which will monitor all active connections and perform the necessary conversions. </font><font style="vertical-align: inherit;">There are several subtleties. </font><font style="vertical-align: inherit;">Firstly, since we are talking about NAT at the scale of the carrier, it is necessary to tighten the timeouts, because with the default values, the size of the translation table will quickly grow to catastrophic values. </font><font style="vertical-align: inherit;">Below is an example of the settings that I used on my servers:</font></font><br>
<br>
<pre><code class="bash hljs">net.ipv4.ip_forward = 1<font></font>
net.ipv4.ip_local_port_range = 8192 65535<font></font>
<font></font>
net.netfilter.nf_conntrack_generic_timeout = 300<font></font>
net.netfilter.nf_conntrack_tcp_timeout_syn_sent = 60<font></font>
net.netfilter.nf_conntrack_tcp_timeout_syn_recv = 60<font></font>
net.netfilter.nf_conntrack_tcp_timeout_established = 600<font></font>
net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 60<font></font>
net.netfilter.nf_conntrack_tcp_timeout_close_wait = 45<font></font>
net.netfilter.nf_conntrack_tcp_timeout_last_ack = 30<font></font>
net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120<font></font>
net.netfilter.nf_conntrack_tcp_timeout_close = 10<font></font>
net.netfilter.nf_conntrack_tcp_timeout_max_retrans = 300<font></font>
net.netfilter.nf_conntrack_tcp_timeout_unacknowledged = 300<font></font>
net.netfilter.nf_conntrack_udp_timeout = 30<font></font>
net.netfilter.nf_conntrack_udp_timeout_stream = 60<font></font>
net.netfilter.nf_conntrack_icmpv6_timeout = 30<font></font>
net.netfilter.nf_conntrack_icmp_timeout = 30<font></font>
net.netfilter.nf_conntrack_events_retry_timeout = 15<font></font>
net.netfilter.nf_conntrack_checksum=0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And secondly, since the default size of the translation table is not designed to work in the conditions of a telecom operator, it must be increased:</font></font><br>
<br>
<pre><code class="plaintext hljs">net.netfilter.nf_conntrack_max = 3145728
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 It is also necessary to increase the number of buckets for a hash table that stores all translations (this is an option of the nf_conntrack module): </font></font><br>
<br>
<pre><code class="plaintext hljs">options nf_conntrack hashsize=1572864
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After these simple manipulations, a completely working construction is obtained, which can translate a large number of client addresses into an external pool. However, the performance of this solution is poor. In my first attempts to use GNU / Linux for NAT (approximately 2013), I was able to get about 7Gbit / s performance at 0.8Mpps per server (Xeon E5-1650v2). Since that time, many different optimizations have been made in the GNU / Linux kernel network stack, the performance of one server on the same hardware has grown almost to 18-19 Gbit / s at 1.8-1.9 Mpps (these were the limit values), but the need for traffic volume, processed by a single server, grew much faster. As a result, load balancing schemes for different servers were developed, but all this increased the complexity of the setup,servicing and maintaining the quality of the services provided.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nftables</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nowadays, the use of DPDK and XDP is a fashionable direction in software ‚Äúpacket transfer‚Äù. </font><font style="vertical-align: inherit;">A lot of articles have been written on this subject, many different presentations have been made, commercial products appear (for example, SKAT from VasExperts). </font><font style="vertical-align: inherit;">But in the conditions of limited resources of programmers from telecom operators, it‚Äôs quite problematic to cut some kind of ‚Äúshare‚Äù on the basis of these frameworks. </font><font style="vertical-align: inherit;">To operate such a solution in the future will be much more difficult, in particular, it will be necessary to develop diagnostic tools. </font><font style="vertical-align: inherit;">For example, a regular tcpdump with DPDK just doesn‚Äôt work, and it won‚Äôt ‚Äúsee‚Äù packets sent back to the wires using XDP. </font><font style="vertical-align: inherit;">Amid all the talk about new technologies for outputting packet forwarding to user-space, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reports</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">articles</font></a><font style="vertical-align: inherit;"> went unnoticed</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pablo Neira Ayuso, iptables maintainer, on developing flow offloading in nftables. Let's look at this mechanism in more detail.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main idea is that if the router passed packets of one session on both sides of the stream (the TCP session went into the ESTABLISHED state), then there is no need to pass subsequent packets of this session through all firewall rules, because all these checks will all the same end by transferring the packet further to routing. Yes, and actually the choice of the route does not need to be performed - we already know which interface and which host should forward the packets within this session. It remains only to save this information and use it for routing at an early stage of packet processing. When performing NAT, it is necessary to additionally save information on changes in addresses and ports converted by the nf_conntrack module. Yes, of course, in this case various polysers and other information-statistical rules in iptables stop working,but as part of the task of a separate standing NAT or, for example, a border, this is not so important, because the services are distributed across devices.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To use this function we need:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use a fresh kernel. </font><font style="vertical-align: inherit;">Despite the fact that the functionality itself appeared in the 4.16 kernel, for quite a while it was very "raw" and regularly called kernel panic. </font><font style="vertical-align: inherit;">Everything stabilized around December 2019, when the LTS kernels 4.19.90 and 5.4.5 were released.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rewrite iptables rules in nftables format using a fairly recent version of nftables. </font><font style="vertical-align: inherit;">Works fine in version 0.9.0</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If everything is clear in principle with the first paragraph, the main thing is not to forget to include the module in the configuration during assembly (CONFIG_NFT_FLOW_OFFLOAD = m), then the second paragraph requires explanation. </font><font style="vertical-align: inherit;">The nftables rules are described quite differently than in iptables. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reveals almost all the points, there are also special </font><font style="vertical-align: inherit;">rule </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">converters</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from iptables to nftables. </font><font style="vertical-align: inherit;">Therefore, I will give only an example of setting up NAT and flow offload. </font><font style="vertical-align: inherit;">A small legend for an example: &lt;i_if&gt;, &lt;o_if&gt; are the network interfaces through which traffic passes, in reality there can be more than two. </font><font style="vertical-align: inherit;">&lt;pool_addr_start&gt;, &lt;pool_addr_end&gt; - the start and end address of the range of "white" addresses. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NAT configuration is very simple:</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-comment">#! /usr/sbin/nft -f</span><font></font>
<font></font>
table nat {<font></font>
        chain postrouting {<font></font>
                <span class="hljs-built_in">type</span> nat hook postrouting priority 100;<font></font>
                oif &lt;o_if&gt; snat to &lt;pool_addr_start&gt;-&lt;pool_addr_end&gt; persistent<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flow offload is a bit more complicated, but understandable:</font></font><br>
<pre><code class="bash hljs"><span class="hljs-comment">#! /usr/sbin/nft -f</span><font></font>
<font></font>
table inet filter {<font></font>
        flowtable fastnat {<font></font>
                hook ingress priority 0<font></font>
                devices = { &lt;i_if&gt;, &lt;o_if&gt; }<font></font>
        }<font></font>
<font></font>
        chain forward {<font></font>
                <span class="hljs-built_in">type</span> filter hook forward priority 0; policy accept;<font></font>
                ip protocol { tcp , udp } flow offload @fastnat;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That, in fact, is the whole setup. </font><font style="vertical-align: inherit;">Now all TCP / UDP traffic will go to the fastnat table and will be processed much faster.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">results</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To make it clear how ‚Äúmuch faster‚Äù this is, I will attach a screenshot of the load on two real servers with the same hardware (Xeon E5-1650v2), equally configured, using the same Linux kernel, but running NAT in iptables (NAT4) and in nftables (NAT5). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y7/ov/c7/y7ovc7nkxxoply2apwjtur9tj-m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is no packet graph per second in the screenshot, but in the load profile of these servers the average packet size is around 800 bytes, so the values ‚Äã‚Äãgo up to 1.5Mpps. </font><font style="vertical-align: inherit;">As you can see, the performance margin of the server with nftables is huge. </font><font style="vertical-align: inherit;">Currently, this server processes up to 30Gbit / s at 3Mpps and is clearly able to run into the physical limitation of the 40Gbps network, while having free CPU resources. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I hope this material will be useful to network engineers trying to improve the performance of their servers.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en501220/index.html">Parsing: can a company have too much money?</a></li>
<li><a href="../en501222/index.html">Application of COBIT when developing an IT strategy</a></li>
<li><a href="../en501224/index.html">What neural networks can ‚Äúsing‚Äù and perform death metal</a></li>
<li><a href="../en501226/index.html">Quick file search</a></li>
<li><a href="../en501232/index.html">How can an IT expert earn extra on his knowledge</a></li>
<li><a href="../en501236/index.html">So what is this all about, ‚Äúprotein folding‚Äù?</a></li>
<li><a href="../en501240/index.html">Site Security Audit</a></li>
<li><a href="../en501244/index.html">The programmer does not have to solve business problems</a></li>
<li><a href="../en501246/index.html">Correct Covid-19 Graphics</a></li>
<li><a href="../en501248/index.html">JavaScript Workplace Hall of Fame, Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>