<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🚒 ☂️ 🔛 フラッター。BlOC、プロバイダー、非同期-シェルフアーキテクチャ 🈳 ☮️ 👈🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前書き
 アプリケーションを作成しようとするときに最初に遭遇するのは、アプリケーションのアーキテクチャーをどのように編成するかです。そして、Flutterに関しては、頭はグーグルが与えるものを完全に回ることができます-バニラ、スコープモデル、BLoC、MVP、MVC、MVVM、MVIなど。最もファッ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>フラッター。BlOC、プロバイダー、非同期-シェルフアーキテクチャ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489512/"><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションを作成しようとするときに最初に遭遇するのは、アプリケーションのアーキテクチャーをどのように編成するかです。</font><font style="vertical-align: inherit;">そして、Flutterに関しては、頭はグーグルが与えるものを完全に回ることができます-バニラ、スコープモデル、BLoC、MVP、MVC、MVVM、MVIなど。</font><font style="vertical-align: inherit;">最もファッショナブルな方法（Googleが2018年に助言した方法）でBLOCを使用するとします。</font><font style="vertical-align: inherit;">それは何ですか？</font><font style="vertical-align: inherit;">それの使い方？</font><font style="vertical-align: inherit;">それともReduxかRxDartか？</font><font style="vertical-align: inherit;">-停止は「その他」についてですが...それでも、次は何ですか？</font><font style="vertical-align: inherit;">接続するライブラリは何ですか？</font><font style="vertical-align: inherit;">Bloc、Flutter_bloc、bloc_patternなど？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装のためのこのような多数のアーキテクチャオプションとツールは、実際に選択段階を長時間遅らせる可能性があります。</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誰のための記事</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、Flutterの学習を始めたばかりで、どこから始めればよいかわからないユーザーにとって主に役立ちます。</font><font style="vertical-align: inherit;">Flutterにアプリケーションを実装するためのオプションの1つを紹介します。</font><font style="vertical-align: inherit;">これにより、Flutterを「感じる」ことができ、アプリケーションの記述方法と使用方法を自分で決めることができます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターンとツール。</font><font style="vertical-align: inherit;">簡潔でシンプル</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは始めましょう。最初に注目する価値があるのは、アプリケーションアーキテクチャ（パターン、テンプレート、いくつかの構築コンセプト）があることです。これはまったく同じです：BLoC、MVP、MVC、MVVM、MVIなど。これらのアーキテクチャの多くはFlutterだけでなく、他のプログラミング言語でも使用されています。質問-何から選ぶべきですか？私の意見では、あなた自身がよく知っているものを選択する必要がありますが、これは反応性とビジネスロジックのインターフェースからの厳密な分離を意味する場合にのみです（はい、はい-「車は黒ならどんな色でもかまいません」）。インターフェースとビジネスロジックの分離については、説明する必要はないと思いますが、反応性については、試していない場合は試してみてください-最終的には非常に便利で「美しい」です。自分で選択できない場合は、Googleの最も愚かな人ではないBLOCが私たちのためにそれを行うことを許可しましょう。アーキテクチャを理解しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、ツール-既成のライブラリがあります-Bloc、Flutter_bloc、bloc_pattern-どちらが良いですか？わかりません-みんな元気です長い間選択して比較できますが、ここでも軍と同様に、何もしないよりは、今のところ間違った決定をする方が良いです。そして今のところ、私はMODをきっかけに戻ってプロバイダーを使用することをお勧めします（同じ人が2019で使用を推奨しているもの）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、必要に応じて、グローバルブロックとローカルブロックの両方を作成できます。</font><font style="vertical-align: inherit;">BLoCのアーキテクチャー（つまり、ライブラリーではなくパターン）については多くのことが書かれていますが、これについて詳しく説明しないでください。</font><font style="vertical-align: inherit;">この記事では、クラシックBLOCではなく、1点だけが使用されますが、少し変更されています。BLoCでは、アクション（イベント）はシンクを通じて送信されませんが、BLoC関数が呼び出されます。</font><font style="vertical-align: inherit;">単純に、現時点では、シンクを使用するメリットはわかりません。シンクがないため、なぜ生活が複雑になるのでしょうか。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dartでの非同期および並列コンピューティング</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、反応性について話しているので、ダートの非同期性の概念を少し明確にする価値もあります。多くの場合、Dartを知っている最初の段階では、非同期関数（async）の意味が正しく理解されていません。 「デフォルトでは」プログラムは1つのスレッドで実行され、非同期では、コマンドを並行して実行するのではなく、コマンドのシーケンスのみを変更できることを常に覚えておく必要があります。つまり、関数に非同期のマークを付けるだけで大​​規模な計算を実行すると、インターフェイスがブロックされます。非同期は新しいスレッドを開始しません。非同期と待機がどのように機能するかについては、インターネット上に多くの情報があるため、これについても詳しく説明しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの大きな計算を行う必要があり、同時にインターフェイスをブロックしない必要がある場合は、compute関数を使用する必要があります（特別なハードコアの場合は分離を使用できます）。</font><font style="vertical-align: inherit;">これにより、実際には個別の実行スレッドが開始され、独自の個別のメモリ領域（非常に悲しい）も存在します。</font><font style="vertical-align: inherit;">そのようなストリームと通信できるのは、単純なデータ型とそのリストを含むことができるメッセージを介してのみです。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">練習に取り掛かりましょう</font></font></h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の定式化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純なアプリケーションを書いてみましょう。電話帳のようなものにします。</font><font style="vertical-align: inherit;">ストレージとしてFirebaseを使用します。これにより、「クラウド」アプリケーションを作成できます。</font><font style="vertical-align: inherit;">Firebaseをプロジェクトに接続する方法はスキップします（このトピックには複数の記事が書かれており、繰り返しのポイントはわかりません。注：このプロジェクトではCloud Firestoreを使用しています）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/yj/js/xyyjjsknqbe1owqlc1vnbnec-pu.gif"><br>
<br>
<h1> <br>
</h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションの説明</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのアプリケーションは外部的に含まれます：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firebase認証ウィンドウ（このウィンドウのロジックはMainBlocに含まれます）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情報ウィンドウ-プログラムが許可されているユーザーに関する情報が表示されます（このウィンドウのロジックもMainBlocに含まれます）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電話のリスト形式のディレクトリウィンドウ（このウィンドウのロジックは別のPhonebookBlocに含まれます）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面を切り替えるアプリケーションメニュー。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部アプリケーションは次のように構築されます。各画面には、画面ウィジェットを含むファイル、ブロックファイル（対応するブロッククラスを含む）、アクションファイル（ブロック状態に影響を与えるイベントを記述する単純なクラスが含まれます）、状態ファイル（ブロック状態を反映する単純なクラスが含まれます） ）、リポジトリクラス（データの受信を担当）およびデータクラス（ブロックビジネスロジックデータを格納）を含むdata_modelファイル。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションはこのように機能します。画面が開かれると、対応するブロックが初期状態値で初期化され、必要に応じて、ブロックコンストラクターで初期アクションが呼び出されます。</font><font style="vertical-align: inherit;">画面は状態に基づいて構築/再構築され、ブロックを返します。</font><font style="vertical-align: inherit;">ユーザーは、対応するアクションを持ついくつかのアクションをアプリケーションで実行します。</font><font style="vertical-align: inherit;">アクションはblocクラスに渡され、そこでmapEventToState関数で処理されます。ブロックは、画面の再構築に基づいて、新しい状態を画面に返します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル構造</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、空のFlutterプロジェクトを作成して、この種のプロジェクト構造を作成します（デモプロジェクトでは、一部のファイルは最終的に空のままになることに注意してください）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/r5/5j/h8r55j-7shyieywjwqkpkj-lwxi.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">承認ウィンドウ。</font><font style="vertical-align: inherit;">メインブロック</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Firebaseに承認を実装する必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントクラス（ブロック内のイベントを介してデータを転送するのが便利です）とメインブロックの状態を作成することから始めましょう：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルMainBloc \アクション</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocAction</span></span>{<font></font>
  String get password =&gt; <span class="hljs-keyword">null</span>;<font></font>
  String get email =&gt; <span class="hljs-keyword">null</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルMainBloc \ states</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocState</span></span>{<font></font>
  bool busy;<font></font>
  MainBlocState({<span class="hljs-keyword">this</span>.busy = <span class="hljs-keyword">false</span>});<font></font>
  copy(bool busy) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状態クラスのビジーフラグは、インターフェイスにprogress_hudを表示し、リストをスクロールするときにデータベースからの不要なデータ読み取りを除外するために使用されます。</font><font style="vertical-align: inherit;">ブロック内のすべての操作が開始する前に、ビジーフラグが出力ストリームに設定された古いタイプの新しい状態が発行されます。これにより、インターフェイスは操作が開始されたという通知を受け取ります。</font><font style="vertical-align: inherit;">操作の最後に、ビジーフラグがクリアされた新しい状態がストリームに送信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MainBlocStateクラスの継承者は、メインアプリケーションBlocの状態を記述します。</font><font style="vertical-align: inherit;">MainBlocActionの継承者は、その中で発生するイベントを記述します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MainBlocクラスには4つの主要な要素が含まれます-イベントを状態に「変換」する機能（Future mapEventToState）、Bloc状態は_blocState、bloc状態リポジトリはリポジトリ、そして（出力）状態ストリーム（インターフェイス要素が追跡する）はblocStreamです。基本的に、これらはすべてbloc-a機能を提供する要素です。 1つのブロックで2つの出力ストリームを使用することをお勧めします-そのような例は低くなります。ここには記載しません。プロジェクトをダウンロードすると表示できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
blocリポジトリクラスには、Firebaseを操作するためのロジックと、このblocが実装するビジネスロジックに必要なデータを格納するオブジェクト（データ）が含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルMainBloc \ data_model</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainRepo</span></span>{<font></font>
<font></font>
  <span class="hljs-keyword">final</span> MainData data = MainData();<font></font>
<font></font>
  FirebaseAuth get firebaseInst =&gt; MainData.firebaseInst;<font></font>
<font></font>
  FirebaseUser _currentUser;<font></font>
<font></font>
  <span class="hljs-function">Future&lt;bool&gt; <span class="hljs-title">createUserWithEmailAndPassword</span><span class="hljs-params">(
      String email, String password)</span> async </span>{
    <span class="hljs-keyword">var</span> dataUser;
      <span class="hljs-keyword">try</span> {<font></font>
        dataUser =<font></font>
            (await firebaseInst.createUserWithEmailAndPassword(<font></font>
                email: email, password: password))<font></font>
                .user;<font></font>
      } <span class="hljs-keyword">catch</span> (e) {<font></font>
        print(Error.safeToString(e));<font></font>
        print(e.code);<font></font>
        print(e.message);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span> (dataUser == <span class="hljs-keyword">null</span>){<font></font>
        data.setState(IsNotLogged());<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
      }<font></font>
<font></font>
      _currentUser = dataUser;<font></font>
      data.setState(IsLogged(),<font></font>
          uid: _currentUser.uid,<font></font>
          email: _currentUser.email);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<font></font>
  }<font></font>
<font></font>
  ...}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainData</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> firebaseInst = FirebaseAuth.instance;
  <span class="hljs-keyword">static</span> MainBlocState _authState = IsNotLogged();
  <span class="hljs-keyword">static</span> MainBlocState get authState =&gt; _authState;
  <span class="hljs-keyword">static</span> String _uid;
  <span class="hljs-keyword">static</span> String get uid =&gt; _uid;
  <span class="hljs-keyword">static</span> String _email;
  <span class="hljs-keyword">static</span> String get email =&gt; _email;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(MainBlocState newState,
      {String uid = <span class="hljs-string">''</span>, String email = <span class="hljs-string">''</span>})</span> </span>{<font></font>
    _authState = newState;<font></font>
    _uid = uid;<font></font>
    _email = email;<font></font>
  }<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MainDataクラスも状態を格納しますが、Bloc状態ではなく、Firebaseの承認状態を格納します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインブロックのロジックを記述しました。これで、承認/登録画面の実装を開始できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MainBlocはメインファイルで初期化されます：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインファイル</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-comment">// This widget is the root of your application.</span>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Provider(<font></font>
        create: (context) =&gt; MainBloc(),<font></font>
        dispose: (context, value) =&gt; value.dispose(),<font></font>
        child: MaterialApp(<font></font>
          routes: menuRoutes,<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
StreamBuilder、Provider、StreamProvider、Consumer、およびSelectorについて少し説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロバイダーについての撤退</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロバイダー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -格納された値のみをツリーの下に転送します。そして、あなたは子がビルドした後にのみアクセスできます。サブウィジェットを作成する必要があります。ウィジェットの更新は行いません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamBuilder-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームを監視し、ストリームから新しいオブジェクト</font><b><font style="vertical-align: inherit;">を受け取った</font></b><font style="vertical-align: inherit;">ときに完全に再構築されるウィジェット。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームを監視するウィジェット。新しいオブジェクトが受信されると、子ウィジェット（buildメソッドで個別のクラスとして宣言されているもの）を再構築する必要があることを通知します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンシューマー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セレクター</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は「構文上の砂糖」です。これは実際にはビルドを含み、ウィジェットをその下に隠す「ラッパー」です。 Selector-eでは、更新の追加フィルタリングを行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、各イベントでほとんどの画面を再構築する必要がある場合は、ProviderおよびStreamBuilderでこのオプションを使用できます。</font><font style="vertical-align: inherit;">ウィジェットツリーの一部を葉の近くに再構築する必要がある場合は、StreamProviderをConsumerおよびSelectorと組み合わせて使用​​して、ツリーの不要な再構築を除外することをお勧めします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">認可 </font><font style="vertical-align: inherit;">継続</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションを入力するとき、ユーザーは承認/登録ウィンドウにアクセスする必要がありますが、その時点ではまだアプリケーションメニューを使用できません。 2番目のポイント-この画面を部分的に更新することはあまり意味がありません。そのため、StreamBuilderを使用してインターフェイスを構築できます。プロジェクトの3番目のポイントは、ナビゲーターを使用して画面間を移動することです。承認に成功したイベントを受け取ったら、情報画面への遷移を呼び出す必要があります。ただし、ビルドStreamBuilderの内部では、これは機能しません-エラーが発生します。これを回避するには、補助ラッパークラスStreamBuilderWithListener（ -ユージンBrusov使用することができます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stackoverflow.comを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、この画面のリストはauth_screen自体になります（ここで一部</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
紹介します</font><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
  <span class="hljs-keyword">var</span> bloc = Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
  <span class="hljs-keyword">return</span> StreamBuilderWithListener&lt;MainBlocState&gt;(<font></font>
      stream: bloc.blocStream.stream,<font></font>
      listener: (value) {<font></font>
        <span class="hljs-comment">//not allowed call navigator push in build</span>
        <span class="hljs-keyword">if</span> (value is IsLogged) {<font></font>
          Navigator.of(context).pushReplacementNamed(InfoScreen.nameMenuItem);<font></font>
        }<font></font>
      },<font></font>
      initialData: bloc.state,<font></font>
      builder: (context, snappShot) {<font></font>
        <span class="hljs-keyword">if</span> (snappShot.data is IsLoggedOnStart) {
          <span class="hljs-keyword">return</span> LoggedWidget();<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsLogged) {
          <span class="hljs-comment">//not allowed call navigator push in build</span>
          <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
              inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
          child: Text(<span class="hljs-string">''</span>),);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsNotLogged) {
          <span class="hljs-keyword">return</span> SignInAndSignUpWidget();<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> Scaffold(body: Text(<span class="hljs-string">"                Unknown event"</span>));<font></font>
      });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、StreamBuilderWithListenerが作成され、ブロックからのストリームをリッスンします。</font><font style="vertical-align: inherit;">また、現在の状態に基づいて、LoggedWidgetウィジェット（ユーザーが既にログインしている場合）またはSignInAndSignUpWidget（ユーザーがまだログインしていない場合）が呼び出されます。</font><font style="vertical-align: inherit;">blocがIsLogged状態を返す場合、ナビゲーターを使用した新しい画面への切り替えはビルダーでは発生せず（エラーが発生します）、リスナーで発生します。</font><font style="vertical-align: inherit;">基になるウィジェットでは、インターフェースはここで返されるデータに基づいて構築されます。</font><font style="vertical-align: inherit;">ここでは、Provider + StreamBuilderバンドルが実際に使用されています。</font><font style="vertical-align: inherit;">ブロックの状態が変化すると、実質的にインターフェイス全体が変化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データをblocに転送するには、TextEditingControllerおよびアクションパラメーターを使用し</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます</font><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">auth_screenファイル</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SignUpWidgetWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>{<font></font>
  String _email, _password;<font></font>
<font></font>
  <span class="hljs-keyword">final</span> TextEditingController _emailController = TextEditingController();
  <span class="hljs-keyword">final</span> TextEditingController _passwordController = TextEditingController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _emailController.addListener(_onEmailChanged);<font></font>
    _passwordController.addListener(_onPasswordChanged);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Column(<font></font>
      children: &lt;Widget&gt;[<font></font>
        TextFormField(<font></font>
          controller: _emailController,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'email'</span>),<font></font>
        ),<font></font>
        TextFormField(<font></font>
          controller: _passwordController,<font></font>
          obscureText: <span class="hljs-keyword">true</span>,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'password'</span>),<font></font>
        ),<font></font>
        RaisedButton(<font></font>
            child: Text(<span class="hljs-string">'sign up'</span>),<font></font>
            onPressed: () {<font></font>
              Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>).mapEventToState(<font></font>
                  Registration(_email, _password));<font></font>
            })<font></font>
      ],<font></font>
    );<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _emailController.dispose();<font></font>
    _passwordController.dispose();<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onEmailChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _email = _emailController.text;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onPasswordChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _password = _passwordController.text;<font></font>
  }<font></font>
}<font></font>
 <font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PhoneBookScreenウィンドウ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、PhoneBookScreenウィンドウについて少し説明します。これは最も興味深いウィンドウです。ここでは、インターフェイスはblocからの2つのストリームに基づいて構築されており、スクロールとページネーション（ページネーション）のリストもあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PhonebookScreen \ screenファイル</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhonebookTopPart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{<font></font>
<font></font>
  <span class="hljs-function">StatefulWidget <span class="hljs-title">caseWidget</span><span class="hljs-params">(PhonebookState state)</span> </span>{
    <span class="hljs-keyword">if</span> (state is PhonebookListOpened) {
      <span class="hljs-keyword">return</span> PhonebookList();
    <span class="hljs-comment">//} else if (data is PhonebookCardToViewOpened) {</span>
    }<span class="hljs-keyword">else</span> ModalProgressHUD(<font></font>
      inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
      child: Text(<span class="hljs-string">''</span>),);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">return</span> StreamProvider&lt;PhonebookState&gt;(<font></font>
        create: (context) =&gt; bloc.blocStream.stream,<font></font>
        initialData: bloc.state,<font></font>
        child: Selector&lt;PhonebookState,PhonebookState&gt;(<font></font>
            selector: (_,state)=&gt;state,<font></font>
            shouldRebuild: (previous, next){<span class="hljs-keyword">return</span> (previous.runtimeType!=next.runtimeType);},<font></font>
            builder: (_, state, __) { <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
                inAsyncCall: state.busy,<font></font>
                child: Scaffold(<font></font>
                  appBar: AppBar(<font></font>
                    title: Text(<span class="hljs-string">"Phones list"</span>),<font></font>
                  ),<font></font>
                  drawer: MenuWidget(),<font></font>
                  body: caseWidget(state),<font></font>
                ));}<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のStreamProviderは、ディレクトリのさまざまな画面（リスト、連絡先カード、編集用連絡先カードなど）を切り替えるために必要です。画面のウィジェットは、caseWidget関数で選択されます（ただし、この例では、リストのビューのみが実装されています-連絡先カードのビューを実装してみることができます-これは非常に簡単で、悪いスタートではありません。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この画面では、一連のStreamProvider + Selector / Consumerがすでに使用されています。リストのスクロールがあり、それを使用して画面全体を再構築することはお勧めできません（つまり、ウィジェットの再構築は、対応するセレクター/コンシューマーおよびツリーの下にあります）。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてここにリスト自体の実装があります：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PhonebookScreen \ screen file</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_PhonebookListState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">PhonebookList</span>&gt; </span>{<font></font>
  ScrollController _scrollController = ScrollController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _scrollController.addListener(_scrollListener);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">var</span> list = bloc.repo.data.list;
    <span class="hljs-keyword">return</span> Container(<font></font>
        child: StreamProvider&lt;PhonebookState&gt;(<font></font>
            create: (context) =&gt; bloc.scrollStream.stream,<font></font>
            initialData: bloc.scrollState,<font></font>
            child: Consumer&lt;PhonebookState&gt;(<font></font>
              builder: (_, state, __) {<font></font>
                <span class="hljs-keyword">return</span> ListView.builder(<font></font>
                    controller: _scrollController,<font></font>
                    itemCount: list.length,<font></font>
                    itemBuilder: (BuildContext context, <span class="hljs-keyword">int</span> index) {
                      <span class="hljs-keyword">return</span> ListTile(<font></font>
                        title: Text(list[index].data[<span class="hljs-string">'name'</span>]),<font></font>
                        subtitle: Text(list[index].data[<span class="hljs-string">'phone'</span>]),<font></font>
                      );<font></font>
                    });<font></font>
              },<font></font>
            )));<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_scrollListener</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">double</span> delta = MediaQuery<font></font>
        .of(context)<font></font>
        .size<font></font>
        .height * <span class="hljs-number">3</span>;
    <span class="hljs-keyword">double</span> maxScroll = _scrollController.position.maxScrollExtent;
    <span class="hljs-keyword">double</span> currentScroll = _scrollController.position.pixels;
    <span class="hljs-keyword">if</span> (maxScroll - currentScroll &lt;= delta) {<font></font>
      Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>)<font></font>
          .mapEventToState(ScrollPhonebook());<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _scrollController.removeListener(_scrollListener);<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、スクロールを担当するブロックの2番目のストリームを監視する2番目のStreamProviderが表示されます。ページネーションは、_scrollListener（コントローラー：_scrollController）を介して標準として編成されます。ウィンドウは興味深いですが、最初のウィンドウの詳細な説明を考えると、ここでこれ以上言うことはありません。したがって、今日はこれですべてです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の目的は、完璧なコードを示すことではありませんでした。つまり、ファイル、インスタンス、ミックスインなどを適切に「分割」することで、最適化のための多くのポイントを見つけることができます。</font><font style="vertical-align: inherit;">また、次のステップを「頼む」もの-あなたは連絡先カードを作ることができます。</font><font style="vertical-align: inherit;">主なタスクは、知識を構築し、アプリケーションを構築するための特定のベクトルを設定し、知り合いの最初の段階ではそれほど明白ではなかった、Flutterでアプリケーションを設計する瞬間のいくつかについて説明することでした。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトはからダウンロードできます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（登録には、6文字以上のパスワードを持つ任意のメールを使用できます。再認証時には、パスワードは登録時に使用したものと同じである必要があります）。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja489496/index.html">従業員の検索と仕事の検索：内と外からの私の見解</a></li>
<li><a href="../ja489500/index.html">ストーリーポイントでのタスクの評価</a></li>
<li><a href="../ja489502/index.html">Selenium + AutoIT。Windowsテストオートメーションウィンドウ</a></li>
<li><a href="../ja489504/index.html">UE4でマップの作成を開始する方法</a></li>
<li><a href="../ja489510/index.html">休暇前にチケットを選択する問題を解決しよう＃2</a></li>
<li><a href="../ja489514/index.html">Googleドライブに任意のサイズのファイルを無料でダウンロードして保存します。バグか機能か？</a></li>
<li><a href="../ja489516/index.html">友達はネイティブとファーストレーンに反応します</a></li>
<li><a href="../ja489518/index.html">会員交換低価格交換が米国で登場</a></li>
<li><a href="../ja489526/index.html">ゼロサムゲームとKarush-Kun-Takker条件</a></li>
<li><a href="../ja489528/index.html">開発中に広告を見ていませんか？無秩序</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>