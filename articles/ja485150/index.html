<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍵 👩🏼‍🏭 🤾🏿 モバイルPvPシューターの物理、または2次元のゲームを3次元にリメイクする方法 👩🏿‍🤝‍👨🏽 ⚫️ 👨🏾‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="では前の記事、私の同僚は、私たちは、モバイルマルチプレイヤーシューティングゲームで2次元物理エンジンを使用する方法について話しました。そして今、私たちが以前にやったすべてを投げてゼロから始めた方法、つまり、ゲームを2Dの世界から3Dに移行した方法を共有したいと思います。
 
 プロデューサーと一流の...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>モバイルPvPシューターの物理、または2次元のゲームを3次元にリメイクする方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/485150/"><img src="https://habrastorage.org/webt/fo/if/az/foifazxdmxh_smqsswnkxhn0ww4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前の記事、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の同僚は、私たちは、モバイルマルチプレイヤーシューティングゲームで2次元物理エンジンを使用する方法について話しました。</font><font style="vertical-align: inherit;">そして今、私たちが以前にやったすべてを投げてゼロから始めた方法、つまり、ゲームを2Dの世界から3Dに移行した方法を共有したいと思います。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロデューサーと一流のゲームデザイナーがプログラマー部門にやって来て私たちに課題を突きつけたという事実から始まりました。限られたスペースでの射撃を行うモバイルPvPトップダウンシューティングゲームは、オープンエリアでの射撃を伴うサードパーソンシューティングゲームに変換する必要がありました。</font><font style="vertical-align: inherit;">この場合、カードが次のようになっていないことが望ましいです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/j3/2p/hej32pvogui5sukjz842wjpyqry.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、</font></font><br>
<br>
<img src="https://habrastorage.org/webt/n8/25/xw/n825xwkx_jsgqgoemkcor-r4ti0.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
技術要件は次のようになっています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マップサイズ-100×100メートル;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標高差-40メートル;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トンネル、ブリッジのサポート。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なる高さのターゲットを撃つ;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的なジオメトリとの衝突（ゲーム内の他のキャラクターとの衝突はありません）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自由落下の物理学;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物理手榴弾を投げます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先を見れば、私たちのゲームは最後のスクリーンショットのように見えなかったと言えます。それは、最初のオプションと2番目のオプションの間のクロスであることが判明しました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプション1：階層構造</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のアイデアは、物理エンジンを変更するのではなく、単に「階層の数」レベルのいくつかの層を追加することを提案しました。</font><font style="vertical-align: inherit;">建物のフロアプランのようなものが</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lz/dy/oq/lzdyoquthw76ajisyvgqcn7zc_i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
わかりました。このアプローチでは、クライアントアプリケーションもサーバーアプリケーションも根本的にやり直す必要はなく、一般に、この方法でタスクは非常に簡単に解決されたように見えました。</font><font style="vertical-align: inherit;">しかし、それを実装しようとしたときに、いくつかの重大な問題が発生しました。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベルデザイナーと詳細を明確にした後、そのようなスキームの「フロア」の数は印象的であるという結論に達しました。一部のマップは、緩やかな傾斜と丘のあるオープンエリアにあります。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あるレイヤーから別のレイヤーに射撃するときのヒットの計算は、重要なタスクになりました。</font><font style="vertical-align: inherit;">問題の状況の例を次の図に示します。ここでは、プレーヤー2とプレーヤー3の両方が同じレイヤーにいるにもかかわらず、ショットパスがレイヤー2をブロックしているため、プレーヤー1はプレーヤー3に入ることができますが、プレーヤー2には入りません。</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/be/rg/be/bergbenv9gtcjzpkci26w_jmsik.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、空間を2Dレイヤーに分割するという考えをすぐに放棄し、物理エンジンを完全に置き換えることで行動することを決定しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、この非常にエンジンを選択して、既存のクライアントおよびサーバーアプリケーションに組み込む必要がありました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプション2：使用可能なライブラリを選択する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームクライアントはUnityで記述されているため、デフォルトでUnityに組み込まれている物理エンジンPhysXを使用する可能性を検討することにしました。</font><font style="vertical-align: inherit;">一般的に、彼はゲームの3D物理をサポートするというゲームデザイナーの要件を完全に満たしていましたが、それでも重大な問題がありました。</font><font style="vertical-align: inherit;">それは、私たちのサーバーアプリケーションがUnityを使用せずにC＃で記述されているという事実にありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーでC ++ライブラリを使用するオプションがありました（たとえば、同じPhysX）。ただし、真剣に検討していません。ネイティブコードを使用しているため、このアプローチではサーバーがクラッシュする可能性が高くなりました。</font><font style="vertical-align: inherit;">また、Interop操作の生産性の低さと、他の環境での使用を除いて、純粋にUnityでのPhysXアセンブリの独自性にも困惑しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、このアイデアを実装する試みで、他の問題が発見されました。</font></font><br>
<br>
<ul>
<li>    Unity  IL2CPP  Linux,    ,             .Net Core 2.1       Linux;</li>
<li>       Unity;</li>
<li>    Unity:     ,       Unity.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、このプロジェクトと並行して、同社はマルチプレイヤーPvPゲームの別のプロトタイプを開発していました。その開発者はUnityサーバーを使用しており、提案されたアプローチに関して多くの否定的なフィードバックを得ました。特に、不満の1つは、Unityサーバーが非常に「ストリーミング」しており、数時間ごとに再起動する必要があったことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの問題の組み合わせにより、私たちはこの考えも放棄しました。次に、ゲームサーバーを.Net Core 2.1に残し、以前に使用したVolatilePhysicsの代わりに、C＃で記述された別のオープンな物理エンジンを選択することにしました。つまり、C ++で記述されたエンジンを使用すると予期しないクラッシュが発生することを恐れていたため、C＃エンジンが必要でした。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、次のエンジンがテスト用に選択されました。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bepu Physic v1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bepu Physic v2;</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジッタ物理;</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BulletSharp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの主な基準は、エンジンのパフォーマンス、Unityへの統合の可能性、およびそのサポートでした。バグが見つかった場合に備えて、エンジンを放棄すべきではありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、Bepu Physics v1、Bepu Physics v2、Jitter Physicsエンジンのパフォーマンスをテストしたところ、Bepu Physics v2が最も生産的であることが判明しました。</font><font style="vertical-align: inherit;">さらに、彼は積極的に成長し続けているこの3人のうちの1人だけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、Bepu Physics v2はUnityとの最後の統合基準を満たしていませんでした。このライブラリはSIMD操作とSystem.Numericsを使用します。IL2CPPを使用するモバイルデバイスのアセンブリにはSIMDサポートがないため、Bepu最適化のすべての利点が失われました。 iPhone 5SのiOSでのビルドのデモシーンは非常に低速でした。このソリューションをモバイルデバイスで使用することはできませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、物理エンジンを使用することに一般的に関心があった理由を説明する必要があります。前の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームのネットワーク部分を実装する方法と、プレーヤーのアクションのローカル予測がどのように機能するかについて話しました。つまり、同じコードがクライアントとサーバーで実行されます-ECSシステム。クライアントは、サーバーからの応答を待たずに、プレーヤーのアクションに即座に応答します。いわゆる予測が発生します。サーバーからの応答が返されると、クライアントは予測された世界の状態と受信された状態をチェックし、一致しない場合（予測ミス）、サーバーからの応答に基づいて、プレーヤーに表示される内容の調整を実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主なアイデアは、クライアントとサーバーの両方で同じコードを実行することであり、予測が誤っている状況は非常にまれです。</font><font style="vertical-align: inherit;">ただし、モバイルデバイスで作業するときに、要件を満たす物理C＃エンジンの1つではありませんでした。たとえば、iPhone 5Sで30 fpsの安定した動作を保証できませんでした。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプション3、最終：2つの異なるエンジン</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、実験することにしました。クライアントとサーバーで2つの異なる物理エンジンを使用します。</font><font style="vertical-align: inherit;">私たちの場合、これはうまくいくと考えました：ゲームにはかなり単純な衝突物理学があり、さらに、それは別個のECSシステムとして実装されており、物理エンジンの一部ではありませんでした。</font><font style="vertical-align: inherit;">物理エンジンから必要なのは、レイキャストやスイープキャストを3D空間で作成する機能だけでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、クライアントでは組み込みの物理Unity-PhysX-を使用し、サーバーではBepu Physics v2を使用することにしました。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、物理エンジンを使用するためのインターフェースを強調しました。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを表示</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> System.Numerics;<font></font>
<font></font>
<span class="hljs-keyword">namespace</span> <span class="hljs-title">Prototype.Common.Physics</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPhysicsWorld</span> : <span class="hljs-title">IDisposable</span><font></font>
    {<font></font>
        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">HasBody</span>(<span class="hljs-params"><span class="hljs-keyword">uint</span> id</span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetCurrentSimulationTick</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> tick</span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>;<font></font>
<font></font>
        <span class="hljs-function">RayCastHit <span class="hljs-title">RayCast</span>(<span class="hljs-params">Vector3 origin, Vector3 direction, <span class="hljs-keyword">float</span> distance, CollisionLayer layer, 
            <span class="hljs-keyword">int</span> ticksBehind = <span class="hljs-number">0</span>, List&lt;<span class="hljs-keyword">uint</span>&gt; ignoreIds = <span class="hljs-literal">null</span></span>)</span>;<font></font>
<font></font>
        <span class="hljs-function">RayCastHit <span class="hljs-title">SphereCast</span>(<span class="hljs-params">Vector3 origin, Vector3 direction, <span class="hljs-keyword">float</span> distance, <span class="hljs-keyword">float</span> radius, CollisionLayer layer, <span class="hljs-keyword">int</span> ticksBehind = <span class="hljs-number">0</span>,
            List&lt;<span class="hljs-keyword">uint</span>&gt; ignoreIds = <span class="hljs-literal">null</span></span>)</span>;<font></font>
        <font></font>
        <span class="hljs-function">RayCastHit <span class="hljs-title">CapsuleCast</span>(<span class="hljs-params">Vector3 origin, Vector3 direction, <span class="hljs-keyword">float</span> distance, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> height, CollisionLayer layer, <span class="hljs-keyword">int</span> ticksBehind = <span class="hljs-number">0</span>,
            List&lt;<span class="hljs-keyword">uint</span>&gt; ignoreIds = <span class="hljs-literal">null</span></span>)</span>;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CapsuleOverlap</span>(<span class="hljs-params">Vector3 origin, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> height, BodyMobilityField bodyMobilityField, CollisionLayer layer, List&lt;Overlap&gt; overlaps, <span class="hljs-keyword">int</span> ticksBehind = <span class="hljs-number">0</span></span>)</span>;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RemoveOrphanedDynamicBodies</span>(<span class="hljs-params">WorldState.TableSet currentWorld</span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UpdateBody</span>(<span class="hljs-params"><span class="hljs-keyword">uint</span> id, Vector3 position, <span class="hljs-keyword">float</span> angle</span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateStaticCapsule</span>(<span class="hljs-params">Vector3 origin, Quaternion rotation, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">uint</span> id, CollisionLayer layer</span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateDynamicCapsule</span>(<span class="hljs-params">Vector3 origin, Quaternion rotation, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">uint</span> id, CollisionLayer layer</span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateStaticBox</span>(<span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, <span class="hljs-keyword">uint</span> id, CollisionLayer layer</span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateDynamicBox</span>(<span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, <span class="hljs-keyword">uint</span> id, CollisionLayer layer</span>)</span>;<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このインターフェースの実装は、クライアントとサーバーで異なりました。すでに述べたように、サーバーではBepuを使用して実装し、クライアントではUnityを使用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、サーバー上で物理学を操作するニュアンスに言及する価値があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントがサーバーから世界の更新を遅延（遅延）して受信するという事実により、プレーヤーは、サーバー上で見るものとは少し異なる世界を見ることができます。彼は現在に自分自身を表示し、過去の残りの世界を表示します。このため、サーバー上の別の場所にあるターゲットにローカルで発砲することがわかりました。そのため、ローカルプレーヤーのアクション予測システムを使用するため、サーバーでの撮影時の遅延を補正する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h5/gy/k3/h5gyk3svohmmd61k-xll9wq8zps.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらを補うために、過去Nミリ秒の世界の履歴をサーバーに保存し、物理を含む履歴のオブジェクトを操作できるようにする必要があります。つまり、私たちのシステムは、衝突、ラカスタ、スイープキャストを「過去」に計算できなければなりません。原則として、物理エンジンはこれを行う方法を知りません。PhysXを使用したBepuも例外ではありません。したがって、このような機能を自分で実装する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1秒あたり30ティックの固定頻度でゲームをシミュレートするため、ティックごとに物理世界のデータを保存する必要がありました。アイデアは、物理エンジンでシミュレーションのインスタンスを1つ作成するのではなく、N-履歴に保存された各ティックに対して-を作成し、これらのシミュレーションの循環バッファーを使用してそれらを履歴に保存することでした。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> SimulationSlice[] _simulationHistory = <span class="hljs-keyword">new</span> SimulationSlice[PhysicsConfigs.HistoryLength];<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BepupPhysicsWorld</span>(<span class="hljs-params"></span>)</span><font></font>
       {<font></font>
           _currentSimulationTick = <span class="hljs-number">1</span>;
           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; PhysicsConfigs.HistoryLength; i++)<font></font>
           {<font></font>
               _simulationHistory[i] = <span class="hljs-keyword">new</span> SimulationSlice(_bufferPool);<font></font>
           }<font></font>
       }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 私たちのECSには、物理​​学で機能する読み書きシステムがいくつかあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitPhysicsWorldSystem;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SpawnPhysicsDynamicsBodiesSystem;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DestroyPhysicsDynamicsBodiesSystem;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePhysicsTransformsSystem;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MovePhysicsSystem、</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ショットからのヒット、手榴弾からの爆発などを計算するためのシステムなど、いくつかの読み取り専用システムも同様です</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。InitPhysicsWorldSystemは、現在のティック数（SimulationSlice）を物理エンジンに設定する、ワールドシミュレーションの各ティックで最初に実行されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetCurrentSimulationTick</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> tick</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> oldTick = tick - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> newSlice = _simulationHistory[tick % PhysicsConfigs.HistoryLength];
    <span class="hljs-keyword">var</span> oldSlice = _simulationHistory[oldTick % PhysicsConfigs.HistoryLength];<font></font>
    newSlice.RestoreBodiesFromPreviousTick(oldSlice);<font></font>
    _currentSimulationTick = tick;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RestoreBodiesFromPreviousTickメソッドは、履歴に保存されているデータから、前のティック時の物理エンジン内のオブジェクトの位置を復元します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを表示</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RestoreBodiesFromPreviousTick</span>(<span class="hljs-params">SimulationSlice previous</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> oldStaticCount = previous._staticIds.Count;
    <span class="hljs-comment">// add created static objects</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; oldStaticCount; i++)<font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> oldId = previous._staticIds[i];
        <span class="hljs-keyword">if</span> (!_staticIds.Contains(oldId))<font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> oldHandler = previous._staticIdToHandler[oldId];
            <span class="hljs-keyword">var</span> oldBody = previous._staticHandlerToBody[oldHandler];<font></font>
            <font></font>
            <span class="hljs-keyword">if</span> (oldBody.IsCapsule)<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> handler = CreateStatic(oldBody.Capsule, oldBody.Description.Pose, <span class="hljs-literal">true</span>, oldId, oldBody.CollisionLayer);
                <span class="hljs-keyword">var</span> body = _staticHandlerToBody[handler];<font></font>
                body.Capsule = oldBody.Capsule;<font></font>
                _staticHandlerToBody[handler] = body;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> handler = CreateStatic(oldBody.Box, oldBody.Description.Pose, <span class="hljs-literal">false</span>, oldId, oldBody.CollisionLayer);
                <span class="hljs-keyword">var</span> body = _staticHandlerToBody[handler];<font></font>
                body.Box = oldBody.Box;<font></font>
                _staticHandlerToBody[handler] = body;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// delete not existing dynamic objects</span>
    <span class="hljs-keyword">var</span> newDynamicCount = _dynamicIds.Count;
    <span class="hljs-keyword">var</span> idsToDel = <span class="hljs-keyword">stackalloc</span> <span class="hljs-keyword">uint</span>[_dynamicIds.Count];
    <span class="hljs-keyword">int</span> delIndex = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; newDynamicCount; i++)<font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> newId = _dynamicIds[i];
        <span class="hljs-keyword">if</span> (!previous._dynamicIds.Contains(newId))<font></font>
        {<font></font>
            idsToDel[delIndex] = newId;<font></font>
            delIndex++;<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; delIndex; i++)<font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> id = idsToDel[i];
        <span class="hljs-keyword">var</span> handler = _dynamicIdToHandler[id];<font></font>
        _simulation.Bodies.Remove(handler);<font></font>
        _dynamicHandlerToBody.Remove(handler);<font></font>
        _dynamicIds.Remove(id);<font></font>
        _dynamicIdToHandler.Remove(id);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// add created dynamic objects</span>
    <span class="hljs-keyword">var</span> oldDynamicCount = previous._dynamicIds.Count;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; oldDynamicCount; i++)<font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> oldId = previous._dynamicIds[i];
        <span class="hljs-keyword">if</span> (!_dynamicIds.Contains(oldId))<font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> oldHandler = previous._dynamicIdToHandler[oldId];
            <span class="hljs-keyword">var</span> oldBody = previous._dynamicHandlerToBody[oldHandler];<font></font>
            <font></font>
            <span class="hljs-keyword">if</span> (oldBody.IsCapsule)<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> handler = CreateDynamic(oldBody.Capsule, oldBody.BodyReference.Pose, <span class="hljs-literal">true</span>, oldId, oldBody.CollisionLayer);
                <span class="hljs-keyword">var</span> body = _dynamicHandlerToBody[handler];<font></font>
                body.Capsule = oldBody.Capsule;<font></font>
                _dynamicHandlerToBody[handler] = body;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> handler = CreateDynamic(oldBody.Box, oldBody.BodyReference.Pose, <span class="hljs-literal">false</span>, oldId, oldBody.CollisionLayer);
                <span class="hljs-keyword">var</span> body = _dynamicHandlerToBody[handler];<font></font>
                body.Box = oldBody.Box;<font></font>
                _dynamicHandlerToBody[handler] = body;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、SpawnPhysicsDynamicsBodiesSystemシステムとDestroyPhysicsDynamicsBodiesSystemシステムは、最後のECSティックでの変更方法に従って、物理エンジンでオブジェクトを作成または削除します。</font><font style="vertical-align: inherit;">次に、UpdatePhysicsTransformsSystemは、ECSのデータに従ってすべての動的ボディの位置を更新します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ECSと物理エンジンのデータが同期されるとすぐに、オブジェクトの動きを計算します。</font><font style="vertical-align: inherit;">すべての読み書き操作が完了すると、ゲームロジック（ショット、爆発、霧の戦いなど）を計算するための読み取り専用システムが機能します</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。BepuPhysics用のSimulationSlice </font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">完全な実装コード：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを表示</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> System.Numerics;
<span class="hljs-keyword">using</span> BepuPhysics;
<span class="hljs-keyword">using</span> BepuPhysics.Collidables;
<span class="hljs-keyword">using</span> BepuUtilities.Memory;
<span class="hljs-keyword">using</span> Quaternion = BepuUtilities.Quaternion;<font></font>
<font></font>
<span class="hljs-keyword">namespace</span> <span class="hljs-title">Prototype.Physics</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BepupPhysicsWorld</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimulationSlice</span> : <span class="hljs-title">IDisposable</span><font></font>
        {<font></font>
            <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Dictionary&lt;<span class="hljs-keyword">int</span>, StaticBody&gt; _staticHandlerToBody = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">int</span>, StaticBody&gt;();
            <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Dictionary&lt;<span class="hljs-keyword">int</span>, DynamicBody&gt; _dynamicHandlerToBody = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">int</span>, DynamicBody&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Dictionary&lt;<span class="hljs-keyword">uint</span>, <span class="hljs-keyword">int</span>&gt; _staticIdToHandler = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">uint</span>, <span class="hljs-keyword">int</span>&gt;();
            <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Dictionary&lt;<span class="hljs-keyword">uint</span>, <span class="hljs-keyword">int</span>&gt; _dynamicIdToHandler = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">uint</span>, <span class="hljs-keyword">int</span>&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> List&lt;<span class="hljs-keyword">uint</span>&gt; _staticIds = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">uint</span>&gt;();
            <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> List&lt;<span class="hljs-keyword">uint</span>&gt; _dynamicIds = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">uint</span>&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> BufferPool _bufferPool;
            <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Simulation _simulation;<font></font>
<font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimulationSlice</span>(<span class="hljs-params">BufferPool bufferPool</span>)</span><font></font>
            {<font></font>
                _bufferPool = bufferPool;<font></font>
                _simulation = Simulation.Create(_bufferPool, <span class="hljs-keyword">new</span> NarrowPhaseCallbacks(),
                    <span class="hljs-keyword">new</span> PoseIntegratorCallbacks(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">-9.81f</span>, <span class="hljs-number">0</span>)));<font></font>
            }<font></font>
<font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> RayCastHit <span class="hljs-title">RayCast</span>(<span class="hljs-params">Vector3 origin, Vector3 direction, <span class="hljs-keyword">float</span> distance, CollisionLayer layer, List&lt;<span class="hljs-keyword">uint</span>&gt; ignoreIds=<span class="hljs-literal">null</span></span>)</span><font></font>
            {<font></font>
                direction = direction.Normalized();    <font></font>
                BepupRayCastHitHandler handler = <span class="hljs-keyword">new</span> BepupRayCastHitHandler(_staticHandlerToBody, _dynamicHandlerToBody, layer, ignoreIds);<font></font>
                _simulation.RayCast(origin, direction, distance, <span class="hljs-keyword">ref</span> handler);
                <span class="hljs-keyword">var</span> result = handler.RayCastHit;
                <span class="hljs-keyword">if</span> (result.IsValid)<font></font>
                {<font></font>
                    <span class="hljs-keyword">var</span> collidableReference = handler.CollidableReference;
                    <span class="hljs-keyword">if</span> (handler.CollidableReference.Mobility == CollidableMobility.Static)<font></font>
                    {<font></font>
                        _simulation.Statics.GetDescription(collidableReference.Handle, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> description);<font></font>
                        result.HitEntityId = _staticHandlerToBody[collidableReference.Handle].Id;<font></font>
                        result.CollidableCenter = description.Pose.Position;<font></font>
                    }<font></font>
                    <span class="hljs-keyword">else</span><font></font>
                    {<font></font>
                        _simulation.Bodies.GetDescription(collidableReference.Handle, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> description);<font></font>
                        result.HitEntityId = _dynamicHandlerToBody[collidableReference.Handle].Id;<font></font>
                        result.CollidableCenter = description.Pose.Position;<font></font>
                    }<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span> result;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> RayCastHit <span class="hljs-title">SphereCast</span>(<span class="hljs-params">Vector3 origin, Vector3 direction, <span class="hljs-keyword">float</span> distance, <span class="hljs-keyword">float</span> radius, CollisionLayer layer,  List&lt;<span class="hljs-keyword">uint</span>&gt; ignoreIds = <span class="hljs-literal">null</span></span>)</span><font></font>
            {<font></font>
                direction = direction.Normalized();<font></font>
                SweepCastHitHandler handler = <span class="hljs-keyword">new</span> SweepCastHitHandler(_staticHandlerToBody, _dynamicHandlerToBody, layer, ignoreIds);<font></font>
                _simulation.Sweep(<span class="hljs-keyword">new</span> Sphere(radius), <span class="hljs-keyword">new</span> RigidPose(origin, Quaternion.Identity),
                    <span class="hljs-keyword">new</span> BodyVelocity(direction.Normalized()),<font></font>
                    distance, _bufferPool, <span class="hljs-keyword">ref</span> handler);<font></font>
<font></font>
                <span class="hljs-keyword">var</span> result = handler.RayCastHit;
                <span class="hljs-keyword">if</span> (result.IsValid)<font></font>
                {<font></font>
                    <span class="hljs-keyword">var</span> collidableReference = handler.CollidableReference;
                    <span class="hljs-keyword">if</span> (handler.CollidableReference.Mobility == CollidableMobility.Static)<font></font>
                    {<font></font>
                        _simulation.Statics.GetDescription(collidableReference.Handle, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> description);<font></font>
                        result.HitEntityId = _staticHandlerToBody[collidableReference.Handle].Id;<font></font>
                        result.CollidableCenter = description.Pose.Position;<font></font>
                    }<font></font>
                    <span class="hljs-keyword">else</span><font></font>
                    {<font></font>
                        <span class="hljs-keyword">var</span> reference = <span class="hljs-keyword">new</span> BodyReference(collidableReference.Handle, _simulation.Bodies);<font></font>
                        result.HitEntityId = _dynamicHandlerToBody[collidableReference.Handle].Id;<font></font>
                        result.CollidableCenter = reference.Pose.Position;<font></font>
                    }<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span> result;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> RayCastHit <span class="hljs-title">CapsuleCast</span>(<span class="hljs-params">Vector3 origin, Vector3 direction, <span class="hljs-keyword">float</span> distance, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> height, CollisionLayer layer,  List&lt;<span class="hljs-keyword">uint</span>&gt; ignoreIds = <span class="hljs-literal">null</span></span>)</span><font></font>
            {<font></font>
                direction = direction.Normalized();<font></font>
                <span class="hljs-keyword">var</span> length = height - <span class="hljs-number">2</span> * radius;<font></font>
                SweepCastHitHandler handler = <span class="hljs-keyword">new</span> SweepCastHitHandler(_staticHandlerToBody, _dynamicHandlerToBody, layer, ignoreIds);<font></font>
                _simulation.Sweep(<span class="hljs-keyword">new</span> Capsule(radius, length), <span class="hljs-keyword">new</span> RigidPose(origin, Quaternion.Identity),
                    <span class="hljs-keyword">new</span> BodyVelocity(direction.Normalized()),<font></font>
                    distance, _bufferPool, <span class="hljs-keyword">ref</span> handler);<font></font>
<font></font>
                <span class="hljs-keyword">var</span> result = handler.RayCastHit;
                <span class="hljs-keyword">if</span> (result.IsValid)<font></font>
                {<font></font>
                    <span class="hljs-keyword">var</span> collidableReference = handler.CollidableReference;
                    <span class="hljs-keyword">if</span> (handler.CollidableReference.Mobility == CollidableMobility.Static)<font></font>
                    {<font></font>
                        _simulation.Statics.GetDescription(collidableReference.Handle, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> description);<font></font>
                        result.HitEntityId = _staticHandlerToBody[collidableReference.Handle].Id;<font></font>
                        result.CollidableCenter = description.Pose.Position;<font></font>
                    }<font></font>
                    <span class="hljs-keyword">else</span><font></font>
                    {<font></font>
                        <span class="hljs-keyword">var</span> reference = <span class="hljs-keyword">new</span> BodyReference(collidableReference.Handle, _simulation.Bodies);<font></font>
                        result.HitEntityId = _dynamicHandlerToBody[collidableReference.Handle].Id;<font></font>
                        result.CollidableCenter = reference.Pose.Position;<font></font>
                    }<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span> result;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CapsuleOverlap</span>(<span class="hljs-params">Vector3 origin, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> height, BodyMobilityField bodyMobilityField, CollisionLayer layer, List&lt;Overlap&gt; overlaps</span>)</span><font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> length = height - <span class="hljs-number">2</span> * radius;
                <span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">new</span> BepupOverlapHitHandler(<font></font>
                    bodyMobilityField,<font></font>
                    layer,<font></font>
                    _staticHandlerToBody,<font></font>
                    _dynamicHandlerToBody,<font></font>
                    overlaps);<font></font>
                _simulation.Sweep(<font></font>
                    <span class="hljs-keyword">new</span> Capsule(radius, length),
                    <span class="hljs-keyword">new</span> RigidPose(origin, Quaternion.Identity),
                    <span class="hljs-keyword">new</span> BodyVelocity(Vector3.Zero),
                    <span class="hljs-number">0</span>,<font></font>
                    _bufferPool,<font></font>
                    <span class="hljs-keyword">ref</span> handler);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateDynamicBox</span>(<span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, <span class="hljs-keyword">uint</span> id, CollisionLayer layer</span>)</span><font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> shape = <span class="hljs-keyword">new</span> Box(size.X, size.Y, size.Z);
                <span class="hljs-keyword">var</span> pose = <span class="hljs-keyword">new</span> RigidPose()<font></font>
                {<font></font>
                    Position = origin,<font></font>
                    Orientation = rotation<font></font>
                };<font></font>
                <span class="hljs-keyword">var</span> handler = CreateDynamic(shape, pose, <span class="hljs-literal">false</span>, id, layer);
                <span class="hljs-keyword">var</span> body = _dynamicHandlerToBody[handler];<font></font>
                body.Box = shape;<font></font>
                _dynamicHandlerToBody[handler] = body;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateStaticBox</span>(<span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, <span class="hljs-keyword">uint</span> id, CollisionLayer layer</span>)</span><font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> shape = <span class="hljs-keyword">new</span> Box(size.X, size.Y, size.Z);
                <span class="hljs-keyword">var</span> pose = <span class="hljs-keyword">new</span> RigidPose()<font></font>
                {<font></font>
                    Position = origin,<font></font>
                    Orientation = rotation<font></font>
                };<font></font>
                <font></font>
                <font></font>
                <span class="hljs-keyword">var</span> handler =CreateStatic(shape, pose, <span class="hljs-literal">false</span>, id, layer);
                <span class="hljs-keyword">var</span> body = _staticHandlerToBody[handler];<font></font>
                body.Box = shape;<font></font>
                _staticHandlerToBody[handler] = body;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateStaticCapsule</span>(<span class="hljs-params">Vector3 origin, Quaternion rotation, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">uint</span> id, CollisionLayer layer</span>)</span><font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> length = height - <span class="hljs-number">2</span> * radius;
                <span class="hljs-keyword">var</span> shape = <span class="hljs-keyword">new</span> Capsule(radius, length);
                <span class="hljs-keyword">var</span> pose = <span class="hljs-keyword">new</span> RigidPose()<font></font>
                {<font></font>
                    Position = origin,<font></font>
                    Orientation = rotation<font></font>
                };<font></font>
<font></font>
                <span class="hljs-keyword">var</span> handler =CreateStatic(shape, pose, <span class="hljs-literal">true</span>, id, layer);
                <span class="hljs-keyword">var</span> body = _staticHandlerToBody[handler];<font></font>
                body.Capsule = shape;<font></font>
                _staticHandlerToBody[handler] = body;<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateDynamicCapsule</span>(<span class="hljs-params">Vector3 origin, Quaternion rotation, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">uint</span> id, CollisionLayer layer</span>)</span><font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> length = height - <span class="hljs-number">2</span> * radius;
                <span class="hljs-keyword">var</span> shape = <span class="hljs-keyword">new</span> Capsule(radius, length);
                <span class="hljs-keyword">var</span> pose = <span class="hljs-keyword">new</span> RigidPose()<font></font>
                {<font></font>
                    Position = origin,<font></font>
                    Orientation = rotation<font></font>
                };<font></font>
                <span class="hljs-keyword">var</span> handler = CreateDynamic(shape, pose, <span class="hljs-literal">true</span>, id, layer);
                <span class="hljs-keyword">var</span> body = _dynamicHandlerToBody[handler];<font></font>
                body.Capsule = shape;<font></font>
                _dynamicHandlerToBody[handler] = body;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> CreateDynamic&lt;TShape&gt;(TShape shape, RigidPose pose, <span class="hljs-keyword">bool</span> isCapsule, <span class="hljs-keyword">uint</span> id, CollisionLayer collisionLayer) <span class="hljs-keyword">where</span> TShape : <span class="hljs-keyword">struct</span>, IShape<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> activity = <span class="hljs-keyword">new</span> BodyActivityDescription()<font></font>
                {<font></font>
                    SleepThreshold = <span class="hljs-number">-1</span><font></font>
                };<font></font>
                <span class="hljs-keyword">var</span> collidable = <span class="hljs-keyword">new</span> CollidableDescription()<font></font>
                {<font></font>
                    Shape = _simulation.Shapes.Add(shape),<font></font>
                    SpeculativeMargin = <span class="hljs-number">0.1f</span>,<font></font>
                };<font></font>
                <span class="hljs-keyword">var</span> capsuleDescription = BodyDescription.CreateKinematic(pose, collidable, activity);
                <span class="hljs-keyword">var</span> handler = _simulation.Bodies.Add(capsuleDescription);<font></font>
                _dynamicIds.Add(id);<font></font>
                _dynamicIdToHandler.Add(id, handler);<font></font>
                _dynamicHandlerToBody.Add(handler, <span class="hljs-keyword">new</span> DynamicBody<font></font>
                {<font></font>
                    BodyReference = <span class="hljs-keyword">new</span> BodyReference(handler, _simulation.Bodies),<font></font>
                    Id = id,<font></font>
                    IsCapsule = isCapsule,<font></font>
                    CollisionLayer = collisionLayer<font></font>
                });<font></font>
                <span class="hljs-keyword">return</span> handler;<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> CreateStatic&lt;TShape&gt;(TShape shape, RigidPose pose, <span class="hljs-keyword">bool</span> isCapsule, <span class="hljs-keyword">uint</span> id, CollisionLayer collisionLayer) <span class="hljs-keyword">where</span> TShape : <span class="hljs-keyword">struct</span>, IShape <font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> capsuleDescription = <span class="hljs-keyword">new</span> StaticDescription()<font></font>
                {<font></font>
                    Pose = pose,<font></font>
                    Collidable = <span class="hljs-keyword">new</span> CollidableDescription()<font></font>
                    {<font></font>
                        Shape = _simulation.Shapes.Add(shape),<font></font>
                        SpeculativeMargin = <span class="hljs-number">0.1f</span>,<font></font>
                    }<font></font>
                };<font></font>
                <span class="hljs-keyword">var</span> handler = _simulation.Statics.Add(capsuleDescription);<font></font>
                _staticIds.Add(id);<font></font>
                _staticIdToHandler.Add(id, handler);<font></font>
                _staticHandlerToBody.Add(handler, <span class="hljs-keyword">new</span> StaticBody<font></font>
                {<font></font>
                    Description = capsuleDescription,<font></font>
                    Id = id,<font></font>
                    IsCapsule = isCapsule,<font></font>
                    CollisionLayer = collisionLayer<font></font>
                });<font></font>
                <span class="hljs-keyword">return</span> handler;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveOrphanedDynamicBodies</span>(<span class="hljs-params">TableSet currentWorld</span>)</span><font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> toDel = <span class="hljs-keyword">stackalloc</span> <span class="hljs-keyword">uint</span>[_dynamicIds.Count];
                <span class="hljs-keyword">var</span> toDelIndex = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> _dynamicIdToHandler)<font></font>
                {<font></font>
                    <span class="hljs-keyword">if</span> (currentWorld.DynamicPhysicsBody.HasCmp(i.Key))<font></font>
                    {<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                    }<font></font>
<font></font>
                    toDel[toDelIndex] = i.Key;<font></font>
                    toDelIndex++;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; toDelIndex; i++)<font></font>
                {<font></font>
                    <span class="hljs-keyword">var</span> id = toDel[i];
                    <span class="hljs-keyword">var</span> handler = _dynamicIdToHandler[id];<font></font>
                    _simulation.Bodies.Remove(handler);<font></font>
                    _dynamicHandlerToBody.Remove(handler);<font></font>
                    _dynamicIds.Remove(id);<font></font>
                    _dynamicIdToHandler.Remove(id);<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">HasBody</span>(<span class="hljs-params"><span class="hljs-keyword">uint</span> id</span>)</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> _staticIdToHandler.ContainsKey(id) || _dynamicIdToHandler.ContainsKey(id);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RestoreBodiesFromPreviousTick</span>(<span class="hljs-params">SimulationSlice previous</span>)</span><font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> oldStaticCount = previous._staticIds.Count;
                <span class="hljs-comment">// add created static objects</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; oldStaticCount; i++)<font></font>
                {<font></font>
                    <span class="hljs-keyword">var</span> oldId = previous._staticIds[i];
                    <span class="hljs-keyword">if</span> (!_staticIds.Contains(oldId))<font></font>
                    {<font></font>
                        <span class="hljs-keyword">var</span> oldHandler = previous._staticIdToHandler[oldId];
                        <span class="hljs-keyword">var</span> oldBody = previous._staticHandlerToBody[oldHandler];<font></font>
                        <font></font>
                        <span class="hljs-keyword">if</span> (oldBody.IsCapsule)<font></font>
                        {<font></font>
                            <span class="hljs-keyword">var</span> handler = CreateStatic(oldBody.Capsule, oldBody.Description.Pose, <span class="hljs-literal">true</span>, oldId, oldBody.CollisionLayer);
                            <span class="hljs-keyword">var</span> body = _staticHandlerToBody[handler];<font></font>
                            body.Capsule = oldBody.Capsule;<font></font>
                            _staticHandlerToBody[handler] = body;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">else</span><font></font>
                        {<font></font>
                            <span class="hljs-keyword">var</span> handler = CreateStatic(oldBody.Box, oldBody.Description.Pose, <span class="hljs-literal">false</span>, oldId, oldBody.CollisionLayer);
                            <span class="hljs-keyword">var</span> body = _staticHandlerToBody[handler];<font></font>
                            body.Box = oldBody.Box;<font></font>
                            _staticHandlerToBody[handler] = body;<font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
                <font></font>
                <span class="hljs-comment">// delete not existing dynamic objects</span>
                <span class="hljs-keyword">var</span> newDynamicCount = _dynamicIds.Count;
                <span class="hljs-keyword">var</span> idsToDel = <span class="hljs-keyword">stackalloc</span> <span class="hljs-keyword">uint</span>[_dynamicIds.Count];
                <span class="hljs-keyword">int</span> delIndex = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; newDynamicCount; i++)<font></font>
                {<font></font>
                    <span class="hljs-keyword">var</span> newId = _dynamicIds[i];
                    <span class="hljs-keyword">if</span> (!previous._dynamicIds.Contains(newId))<font></font>
                    {<font></font>
                        idsToDel[delIndex] = newId;<font></font>
                        delIndex++;<font></font>
                    }<font></font>
                }<font></font>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; delIndex; i++)<font></font>
                {<font></font>
                    <span class="hljs-keyword">var</span> id = idsToDel[i];
                    <span class="hljs-keyword">var</span> handler = _dynamicIdToHandler[id];<font></font>
                    _simulation.Bodies.Remove(handler);<font></font>
                    _dynamicHandlerToBody.Remove(handler);<font></font>
                    _dynamicIds.Remove(id);<font></font>
                    _dynamicIdToHandler.Remove(id);<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">// add created dynamic objects</span>
                <span class="hljs-keyword">var</span> oldDynamicCount = previous._dynamicIds.Count;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; oldDynamicCount; i++)<font></font>
                {<font></font>
                    <span class="hljs-keyword">var</span> oldId = previous._dynamicIds[i];
                    <span class="hljs-keyword">if</span> (!_dynamicIds.Contains(oldId))<font></font>
                    {<font></font>
                        <span class="hljs-keyword">var</span> oldHandler = previous._dynamicIdToHandler[oldId];
                        <span class="hljs-keyword">var</span> oldBody = previous._dynamicHandlerToBody[oldHandler];<font></font>
                        <font></font>
                        <span class="hljs-keyword">if</span> (oldBody.IsCapsule)<font></font>
                        {<font></font>
                            <span class="hljs-keyword">var</span> handler = CreateDynamic(oldBody.Capsule, oldBody.BodyReference.Pose, <span class="hljs-literal">true</span>, oldId, oldBody.CollisionLayer);
                            <span class="hljs-keyword">var</span> body = _dynamicHandlerToBody[handler];<font></font>
                            body.Capsule = oldBody.Capsule;<font></font>
                            _dynamicHandlerToBody[handler] = body;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">else</span><font></font>
                        {<font></font>
                            <span class="hljs-keyword">var</span> handler = CreateDynamic(oldBody.Box, oldBody.BodyReference.Pose, <span class="hljs-literal">false</span>, oldId, oldBody.CollisionLayer);
                            <span class="hljs-keyword">var</span> body = _dynamicHandlerToBody[handler];<font></font>
                            body.Box = oldBody.Box;<font></font>
                            _dynamicHandlerToBody[handler] = body;<font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
<font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
            {<font></font>
                _simulation.Timestep(GameState.TickDurationSec);<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateBody</span>(<span class="hljs-params"><span class="hljs-keyword">uint</span> id, Vector3 position, <span class="hljs-keyword">float</span> angle</span>)</span><font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (_staticIdToHandler.TryGetValue(id, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> handler))<font></font>
                {<font></font>
                    _simulation.Statics.GetDescription(handler, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> staticDescription);<font></font>
                    staticDescription.Pose.Position = position;<font></font>
                    staticDescription.Pose.Orientation = Quaternion.CreateFromAxisAngle(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), angle);<font></font>
                    _simulation.Statics.ApplyDescription(handler, staticDescription);<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(_dynamicIdToHandler.TryGetValue(id, <span class="hljs-keyword">out</span> handler))<font></font>
                {<font></font>
                    BodyReference reference = <span class="hljs-keyword">new</span> BodyReference(handler, _simulation.Bodies);<font></font>
                    reference.Pose.Position = position;<font></font>
                    reference.Pose.Orientation = Quaternion.CreateFromAxisAngle(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), angle);<font></font>
                }<font></font>
            }<font></font>
<font></font>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"></span>)</span><font></font>
            {<font></font>
                _simulation.Clear();<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            _bufferPool.Clear();<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、サーバーに履歴を実装するだけでなく、クライアントにも物理履歴を実装する必要がありました。 Unityクライアントにはサーバーエミュレーションモード（ローカルシミュレーションと呼びます）があり、サーバーコードがクライアントで実行されます。このモードは、ゲーム機能のラピッドプロトタイピングに使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bepuと同様に、PhysXは履歴をサポートしていません。ここでは、サーバー上と同じように、履歴の各ティックに対していくつかの物理シミュレーションを使用して同じアイデアを使用しました。ただし、Unityは物理エンジンでの作業に独自性を課しています。ただし、私たちのプロジェクトはUnity 2018.4（LTS）で開発されたものであり、一部のAPIは新しいバージョンで変更される可能性があるため、このような問題は発生しないことに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、Unityが個別の物理シミュレーション（またはPhysX用語では、シーン）の作成を許可していなかったため、Unityの物理学の履歴の各ティックを個別のシーンとして実装しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラッパークラスは、このようなシーンで作成されました-UnityPhysicsHistorySlice：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnityPhysicsHistorySlice</span>(<span class="hljs-params">SphereCastDelegate sphereCastDelegate, OverlapSphereNonAlloc overlapSphere, CapsuleCastDelegate capsuleCast, 
            OverlapCapsuleNonAlloc overlapCapsule, <span class="hljs-keyword">string</span> name</span>)</span><font></font>
{<font></font>
    _scene = SceneManager.CreateScene(name, <span class="hljs-keyword">new</span> CreateSceneParameters()<font></font>
    {<font></font>
        localPhysicsMode = LocalPhysicsMode.Physics3D<font></font>
    });<font></font>
    _physicsScene = _scene.GetPhysicsScene();<font></font>
    _sphereCast = sphereCastDelegate;<font></font>
    _capsuleCast = capsuleCast;<font></font>
    _overlapSphere = overlapSphere;<font></font>
    _overlapCapsule = overlapCapsule;<font></font>
    _boxPool = <span class="hljs-keyword">new</span> PhysicsSceneObjectsPool&lt;BoxCollider&gt;(_scene, <span class="hljs-string">"box"</span>, <span class="hljs-number">0</span>);<font></font>
    _capsulePool = <span class="hljs-keyword">new</span> PhysicsSceneObjectsPool&lt;UnityEngine.CapsuleCollider&gt;(_scene, <span class="hljs-string">"sphere"</span>, <span class="hljs-number">0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityの2番目の問題は、物理のすべての作業がPhysics静的クラスを通じて行われることです。そのAPIでは、特定のシーンでレーキキャストとスイープキャストを実行できません。</font><font style="vertical-align: inherit;">このAPIは、1つのアクティブなシーンでのみ機能します。</font><font style="vertical-align: inherit;">ただし、PhysXエンジン自体を使用すると、同時に複数のシーンを操作できます。必要なのは正しいメソッドを呼び出すことだけです。</font><font style="vertical-align: inherit;">幸いにも、UnityはそのようなメソッドをPhysics.csクラスインターフェイスの背後に隠していました。</font><font style="vertical-align: inherit;">次のようにしました。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを表示</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">MethodInfo raycastMethod = <span class="hljs-keyword">typeof</span>(Physics).GetMethod(<span class="hljs-string">"Internal_SphereCast"</span>,<font></font>
    BindingFlags.NonPublic | BindingFlags.Static);<font></font>
<span class="hljs-keyword">var</span> sphereCast = (SphereCastDelegate) Delegate.CreateDelegate(<span class="hljs-keyword">typeof</span>(SphereCastDelegate), raycastMethod);<font></font>
<font></font>
MethodInfo overlapSphereMethod = <span class="hljs-keyword">typeof</span>(Physics).GetMethod(<span class="hljs-string">"OverlapSphereNonAlloc_Internal"</span>,<font></font>
    BindingFlags.NonPublic | BindingFlags.Static);<font></font>
<span class="hljs-keyword">var</span> overlapSphere = (OverlapSphereNonAlloc) Delegate.CreateDelegate(<span class="hljs-keyword">typeof</span>(OverlapSphereNonAlloc), overlapSphereMethod);<font></font>
<font></font>
MethodInfo capsuleCastMethod = <span class="hljs-keyword">typeof</span>(Physics).GetMethod(<span class="hljs-string">"Internal_CapsuleCast"</span>,<font></font>
    BindingFlags.NonPublic | BindingFlags.Static);<font></font>
<span class="hljs-keyword">var</span> capsuleCast = (CapsuleCastDelegate) Delegate.CreateDelegate(<span class="hljs-keyword">typeof</span>(CapsuleCastDelegate), capsuleCastMethod);<font></font>
<font></font>
MethodInfo overlapCapsuleMethod = <span class="hljs-keyword">typeof</span>(Physics).GetMethod(<span class="hljs-string">"OverlapCapsuleNonAlloc_Internal"</span>,<font></font>
    BindingFlags.NonPublic | BindingFlags.Static);<font></font>
<span class="hljs-keyword">var</span> overlapCapsule = (OverlapCapsuleNonAlloc) Delegate.CreateDelegate(<span class="hljs-keyword">typeof</span>(OverlapCapsuleNonAlloc), overlapCapsuleMethod);</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それ以外の場合、UnityPhysicsHistorySliceの実装コードは、BepuSimulationSliceにあったものと大差ありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ゲーム物理の2つの実装が得られました。クライアント上とサーバー上です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップはテストです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントの「健康」の最も重要な指標の1つは、サーバーの予測ミスの数のパラメーターです。別の物理エンジンに切り替える前に、このインジケーターは1〜2％の範囲で変化しました。つまり、9000ティック（または5分間）続く戦闘中に、90〜180シミュレーションティックで誤っていました。ソフトラウンジのゲームのいくつかのリリースでこれらの結果を得ました。異なるエンジンに切り替えた後、おそらくこの指標が大幅に成長すると予想しました-おそらく数回ですが-結局のところ、クライアントとサーバーで異なるコードを実行しており、異なるアルゴリズムによる計算のエラーがすぐに蓄積するのは論理的であるように思われました。実際には、不一致パラメータは0.2〜0.5％しか増加せず、1バトルあたり平均2〜2.5％増加することがわかりました。これは完全に適しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
調査したほとんどのエンジンとテクノロジーは、クライアントとサーバーの両方で同じコードを使用していました。</font><font style="vertical-align: inherit;">しかし、異なる物理エンジンを使用する可能性があるという私たちの仮説は確認されました。</font><font style="vertical-align: inherit;">不一致率がわずかに大きくなった主な理由は、私たちのECSシステムの1つによって空間内の物体の動きと衝突を計算したためです。</font><font style="vertical-align: inherit;">このコードは、クライアントとサーバーの両方で同じです。</font><font style="vertical-align: inherit;">物理エンジンからは、レーキキャストとスイープキャストをすばやく計算する必要があり、2つのエンジンの実際のこれらの操作の結果には大きな違いはありませんでした。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何を読むか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論として、いつものように、ここにいくつかの関連リンクがあります：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モバイルPvPシューターの物理、パート1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モバイルPvPシューターのネットワークコード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">    ,      </a>;</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">       For Honor</a>.</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja485136/index.html">Istioのトレースとモニタリング：マイクロサービスと不確実性の原理</a></li>
<li><a href="../ja485138/index.html">アプリケーションのローカリゼーション：友人の翻訳と開発の方法</a></li>
<li><a href="../ja485144/index.html">壊れたベースをどのように修正したか</a></li>
<li><a href="../ja485146/index.html">2019年後半のITの給与：ハーバーキャリアの計算によると</a></li>
<li><a href="../ja485148/index.html">この愛らしいユニコード</a></li>
<li><a href="../ja485152/index.html">Redmadrobotのモバイルデベロッパー向けの春のインターンシップ</a></li>
<li><a href="../ja485154/index.html">開発者からブランドオタクを作る方法：プログラマの動機付けシステム</a></li>
<li><a href="../ja485156/index.html">国内クラウドファンダーになる方法（パート1）</a></li>
<li><a href="../ja485158/index.html">ニコライ・バビロフ。全世界を養おうとして刑務所の独房で飢餓で亡くなった男</a></li>
<li><a href="../ja485160/index.html">ACIDまたは別の視点で私は何ですか</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>