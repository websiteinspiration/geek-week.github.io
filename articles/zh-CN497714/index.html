<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏛️ 🧗🏿 😨 如何在macOS上保护进程和内核扩展 👩🏾‍🏭 🖱️ 🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！今天，我想谈一谈如何保护进程免受macOS中入侵者的侵害。例如，它对于防病毒或备份系统很有用，尤其是考虑到在macOS下有多种“杀死”进程的方法。阅读有关它以及猫的保护方法的信息。
 
 
 
 杀死进程的经典方法
 众所周知的“杀死”进程的方法是发送有关SIGKILL进程的信号。通过bas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>如何在macOS上保护进程和内核扩展</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/497714/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈Ha！</font><font style="vertical-align: inherit;">今天，我想谈一谈如何保护进程免受macOS中入侵者的侵害。</font><font style="vertical-align: inherit;">例如，它对于防病毒或备份系统很有用，尤其是考虑到在macOS下有多种“杀死”进程的方法。</font><font style="vertical-align: inherit;">阅读有关它以及猫的保护方法的信息。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/403/e5f/065/403e5f065b7426d384f3c71e8cb3c8a5.jpg" alt="图片"></a><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">杀死进程的经典方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
众所周知的“杀死”进程的方法是发送有关SIGKILL进程的信号。</font><font style="vertical-align: inherit;">通过bash，您可以调用标准的“ kill -SIGKILL PID”或“ pkill -9 NAME”进行杀死。</font><font style="vertical-align: inherit;">从UNIX开始，kill命令就为人所知，不仅在macOS上可用，而且在其他类似UNIX的系统上也可用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与在类似UNIX的系统中一样，macOS允许您拦截除两个信号SIGKILL和SIGSTOP之外的任何到进程的信号。</font><font style="vertical-align: inherit;">在本文中，SIGKILL信号将主要被视为导致进程终止的信号。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MacOS的细节</font></font><br>
</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在macOS上，XNU内核中的kill系统调用将调用psignal函数（SIGKILL，...）。让我们尝试看看用户空间中还有哪些其他用户操作可以调用psignal函数。我们消除了内核内部机制中对psignal函数的调用（尽管它们可能很简单，让我们留给其他文章：）-签名验证，内存错误，退出/终止处理，违反文件保护等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们从函数和相应的系统调用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Terminate_with_payload</font></a><font style="vertical-align: inherit;">开始概述</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">可以看出，除了经典的kill调用之外，还有另一种方法专用于macOS操作系统，而在BSD中找不到。</font><font style="vertical-align: inherit;">两个系统调用的操作原理也很接近。</font><font style="vertical-align: inherit;">它们是对psignal内核函数的直接调用。</font><font style="vertical-align: inherit;">还要注意，在终止进程之前，会执行“信号分配”检查-进程是否可以向另一个进程发送信号，例如，系统不允许任何应用程序终止系统进程。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>
<span class="hljs-title">terminate_with_payload_internal</span><span class="hljs-params">(struct proc *cur_proc, <span class="hljs-keyword">int</span> target_pid, <span class="hljs-keyword">uint32_t</span> reason_namespace,
				<span class="hljs-keyword">uint64_t</span> reason_code, <span class="hljs-keyword">user_addr_t</span> payload, <span class="hljs-keyword">uint32_t</span> payload_size,
				<span class="hljs-keyword">user_addr_t</span> reason_string, <span class="hljs-keyword">uint64_t</span> reason_flags)</span>
</span>{<font></font>
...<font></font>
	target_proc = proc_find(target_pid);<font></font>
...<font></font>
	<span class="hljs-keyword">if</span> (!cansignal(cur_proc, cur_cred, target_proc, SIGKILL)) {<font></font>
		proc_rele(target_proc);<font></font>
		<span class="hljs-keyword">return</span> EPERM;<font></font>
	}<font></font>
...<font></font>
	<span class="hljs-keyword">if</span> (target_pid == cur_proc-&gt;p_pid) {
		<span class="hljs-comment">/*
		 * psignal_thread_with_reason() will pend a SIGKILL on the specified thread or
		 * return if the thread and/or task are already terminating. Either way, the
		 * current thread won't return to userspace.
		 */</span><font></font>
		psignal_thread_with_reason(target_proc, current_thread(), SIGKILL, signal_reason);<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		psignal_with_reason(target_proc, SIGKILL, signal_reason);<font></font>
	}<font></font>
...<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发射</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
启动了在系统启动时创建守护程序并控制其生存期的标准方法。</font><font style="vertical-align: inherit;">我将提请注意以下事实：源代码适用于macOS 10.10之前的旧版本的launchctl，下面给出了代码示例作为说明。</font><font style="vertical-align: inherit;">现代的launchctl通过XPC发送启动的信号，launchctl的逻辑被传递给它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们考虑一下如何停止应用程序。</font><font style="vertical-align: inherit;">在发送SIGTERM信号之前，他们尝试使用proc_terminate系统调用停止应用程序。</font></font><br>
<br>
<pre><code class="cpp hljs">&lt;launchctl src/core.c&gt;<font></font>
...<font></font>
	error = proc_terminate(j-&gt;p, &amp;sig);<font></font>
	<span class="hljs-keyword">if</span> (error) {<font></font>
		job_log(j, LOG_ERR | LOG_CONSOLE, <span class="hljs-string">"Could not terminate job: %d: %s"</span>, error, strerror(error));<font></font>
		job_log(j, LOG_NOTICE | LOG_CONSOLE, <span class="hljs-string">"Using fallback option to terminate job..."</span>);<font></font>
		error = kill2(j-&gt;p, SIGTERM);<font></font>
		<span class="hljs-keyword">if</span> (error) {<font></font>
			job_log(j, LOG_ERR, <span class="hljs-string">"Could not signal job: %d: %s"</span>, error, strerror(error));<font></font>
		} <font></font>
...<font></font>
&lt;&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管其名称为proc_terminate，但它不仅可以发送带有SIGTERM的信号，而且还可以发送SIGKILL。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接杀死-资源限制</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在另一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">process_policy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统调用中可以看到更有趣的情况</font><font style="vertical-align: inherit;">。此系统调用的标准用法是应用程序资源限制，例如，对于索引器，处理器时间和内存配额受到限制，因此系统不会因文件缓存操作而明显变慢。从proc_apply_resource_actions函数可以看出，如果应用程序已达到资源限制，则SIGKILL信号将发送到该进程。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管此系统调用可能会杀死进程，但系统并未充分检查引起系统调用的进程的权限。实际上，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存在</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查</font><font style="vertical-align: inherit;">，但是使用替代标志PROC_POLICY_ACTION_SET绕过此条件就足够了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，如果您通过应用程序“限制” CPU使用量配额（例如，仅允许执行1 ns），则可以终止系统中的任何进程。</font><font style="vertical-align: inherit;">因此，恶意软件可以杀死系统上的任何进程，包括防病毒进程。</font><font style="vertical-align: inherit;">同样有趣的是，使用pid 1（launchctl）杀死进程时发生的效果-尝试处理SIGKILL信号时内核出现恐慌:)</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/91e/fea/a49/91efeaa490ffd57580d2e5f4a59b4988.png" alt="图片"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何解决问题？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
防止进程被杀死的最直接方法是替换系统调用表中的函数指针。不幸的是，由于许多原因，该方法并不简单：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，负责系统在内存中位置的符号不仅是XNU内核的专用符号，而且在内核符号中也找不到。您将不得不使用启发式搜索方法，例如，动态反汇编函数并在其中搜索指针。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其次，表中条目的结构取决于构建内核的标志。如果声明了标志CONFIG_REQUIRES_U32_MUNGING，则结构的大小将被更改-附加字段</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sy_arg_munge32</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">有必要对编译内核的标志进行附加检查，作为一种选择，将指向已知函数的指针进行比较。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysent</span> {</span>         <span class="hljs-comment">/* system call table */</span>
        <span class="hljs-keyword">sy_call_t</span>       *sy_call;       <span class="hljs-comment">/* implementing function */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> CONFIG_REQUIRES_U32_MUNGING || (__arm__ &amp;&amp; (__BIGGEST_ALIGNMENT__ &gt; 4))</span>
        <span class="hljs-keyword">sy_munge_t</span>      *sy_arg_munge32; <span class="hljs-comment">/* system call arguments munger for 32-bit process */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        <span class="hljs-keyword">int32_t</span>         sy_return_type; <span class="hljs-comment">/* system call return types */</span>
        <span class="hljs-keyword">int16_t</span>         sy_narg;        <span class="hljs-comment">/* number of args */</span>
        <span class="hljs-keyword">uint16_t</span>        sy_arg_bytes;   <span class="hljs-comment">/* Total size of arguments in bytes for
                                         * 32-bit system calls
                                         */</span><font></font>
};<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸运的是，在现代版本的macOS中，Apple提供了用于处理进程的新API。</font><font style="vertical-align: inherit;">Endpoint Security API允许客户端授权许多对其他进程的请求。</font><font style="vertical-align: inherit;">因此，您可以使用上述API阻止任何信号到进程，包括SIGKILL信号。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bsm/libbsm.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;EndpointSecurity/EndpointSecurity.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>{
    <span class="hljs-keyword">es_client_t</span>* cli = <span class="hljs-literal">nullptr</span>;<font></font>
    {<font></font>
        <span class="hljs-keyword">auto</span> res = es_new_client(&amp;cli, ^(<span class="hljs-keyword">es_client_t</span> * client, <span class="hljs-keyword">const</span> <span class="hljs-keyword">es_message_t</span> * message) {
            <span class="hljs-keyword">switch</span> (message-&gt;event_type) {
                <span class="hljs-keyword">case</span> ES_EVENT_TYPE_AUTH_SIGNAL:<font></font>
                {<font></font>
                    <span class="hljs-keyword">auto</span>&amp; msg = message-&gt;event.signal;
                    <span class="hljs-keyword">auto</span> target = msg.target;
                    <span class="hljs-keyword">auto</span>&amp; token = target-&gt;audit_token;
                    <span class="hljs-keyword">auto</span> pid = audit_token_to_pid(token);
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"signal '%d' sent to pid '%d'\n"</span>, msg.sig, pid);<font></font>
                    es_respond_auth_result(client, message, pid == getpid() ? ES_AUTH_RESULT_DENY : ES_AUTH_RESULT_ALLOW, <span class="hljs-literal">false</span>);<font></font>
                }<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        });<font></font>
    }<font></font>
<font></font>
    {<font></font>
        <span class="hljs-keyword">es_event_type_t</span> evs[] = { ES_EVENT_TYPE_AUTH_SIGNAL };<font></font>
        es_subscribe(cli, evs, <span class="hljs-keyword">sizeof</span>(evs) / <span class="hljs-keyword">sizeof</span>(*evs));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, getpid());<font></font>
    sleep(<span class="hljs-number">60</span>); <span class="hljs-comment">// could be replaced with other waiting primitive</span><font></font>
<font></font>
    es_unsubscribe_all(cli);<font></font>
    es_delete_client(cli);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同样，您可以在内核中注册MAC策略，该策略提供了一种信号保护方法（策略proc_check_signal），但是该API并未得到正式支持。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内核扩展保护</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了保护系统中的进程外，还必须保护内核扩展本身（kext）。 macOS为开发人员提供了一个方便地开发IOKit设备驱动程序的框架。除了提供用于处理设备的工具之外，IOKit还提供了使用C ++类实例的驱动程序堆栈方法。用户空间中的应用程序将能够“找到”该类的注册实例，以建立内核-用户空间连接。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要检测系统中类实例的数量，可以使用ioclasscount实用程序。</font></font><br>
<br>
<pre><code class="cpp hljs">my_kext_ioservice = <span class="hljs-number">1</span>
my_kext_iouserclient = <span class="hljs-number">1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任何希望在驱动程序堆栈上注册的内核扩展都必须声明一个继承自IOService的类，例如my_kext_ioservice。连接用户应用程序将创建一个继承自IOUserClient的类的新实例，例如my_kext_iouserclient。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尝试从系统中卸载驱动程序时（kextunload命令），将调用虚拟函数“布尔终止（IOOptionBits选项）”。</font><font style="vertical-align: inherit;">尝试卸载以禁用kextunload时，在调用终止函数时返回false就足够了。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Kext::terminate</span><span class="hljs-params">(IOOptionBits options)</span>
</span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!IsUnloadAllowed)<font></font>
  {<font></font>
    <span class="hljs-comment">// Unload is not allowed, returning false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> super::<span class="hljs-built_in">terminate</span>(options);<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以由IOUserClient在启动时设置IsUnloadAllowed标志。</font><font style="vertical-align: inherit;">当限制加载时，kextunload命令将返回以下输出：</font></font><br>
<br>
<pre><code class="cpp hljs">admin@admins-Mac drivermanager % sudo kextunload ./test.kext<font></font>
Password:<font></font>
(kernel) Can<span class="hljs-number">'</span>t remove kext my.kext.test; services failed to <span class="hljs-built_in">terminate</span> - <span class="hljs-number">0xe00002c7</span>.<font></font>
Failed to unload my.kext.test - (iokit/common) unsupported function.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必须对IOUserClient做类似的保护。</font><font style="vertical-align: inherit;">可以使用用户空间函数IOKitLib“ IOCatalogueTerminate（mach_port_t，uint32_t标志，io_name_t描述）；”来卸载类实例。</font><font style="vertical-align: inherit;">您可以在调用“终止”命令之前返回false，直到应用程序死亡的用户空间消失为止，也就是说，没有对clientDied函数的调用。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件保护</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要保护文件，使用Kauth API就足够了，该API允许您限制对文件的访问。 Apple为开发人员提供了有关范围内各种事件的通知，操作KAUTH_VNODE_DELETE，KAUTH_VNODE_WRITE_DATA和KAUTH_VNODE_DELETE_CHILD对我们很重要。限制访问文件是最简单的方法-我们使用API​​“ vn_getpath”来获取文件的路径并比较路径前缀。请注意，为了优化带有文件的文件夹路径的重命名，系统不会授权访问每个文件，而只授权对已重命名的文件夹本身的访问。有必要比较父路径并为其限制KAUTH_VNODE_DELETE。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6e2/ab5/2fb/6e2ab52fb8c17ea8adfe8b63bcf8f611.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方法的缺点可能是前缀数量增加，性能低下。为了使比较不等于O（prefix * length），其中prefix是前缀的数量，length是字符串的长度，可以使用由前缀构造的确定性有限状态机（DFA）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑一种为给定的前缀集构建DFA的方法。我们在每个前缀的开头初始化游标。如果所有光标都指向同一字符，则我们将每个光标增加一个字符，并记住同一行的长度要增加一个。如果下面有两个光标带有不同的符号，则我们将光标按其指向的符号分成几组，并为每组重复该算法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一种情况下（光标下的所有字符都相同），我们得到DFA状态，该状态在同一行上只有一个过渡。</font><font style="vertical-align: inherit;">在第二种情况下，我们通过递归调用该函数获得了后续状态下大小为256（字符数和组的最大数目）的转换表。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑一个例子。</font><font style="vertical-align: inherit;">对于一组前缀（“ / foo / bar / tmp /”，“ / var / db / foo /”，“ / foo / bar / aba /”，“ foo / bar / aac /”），您可以获取以下DFA。</font><font style="vertical-align: inherit;">该图仅显示导致其他状态的转换，其他转换将不是最终的。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/190/d0f/5ec/190d0f5ec1fdd8c03df23387d83db44a.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过DKA状态时，可能有3种情况。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到达最终状态-路径受保护，我们限制了操作KAUTH_VNODE_DELETE，KAUTH_VNODE_WRITE_DATA和KAUTH_VNODE_DELETE_CHILD</font></font></li>
<li>    ,   “” (  -) —   ,   KAUTH_VNODE_DELETE. ,   vnode  ,     ‘/’,         “/foor/bar/t”,  .</li>
<li>    ,   .       ,   .</li>
</ol><br>
<h3></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
开发的安全解决方案的目的是提高用户及其数据的安全级别。一方面，这一目标是通过开发Acronis软件产品来确保的，该产品涵盖了操作系统本身“弱”的漏洞。另一方面，我们不应忽略可以在OS方面改进的那些安全方面，尤其是因为消除此类漏洞可以提高我们作为产品的稳定性。该漏洞由Apple产品安全团队报告，已在macOS 10.14.5（https://support.apple.com/zh-CN/HT210119）中修复。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e27/604/c24/e27604c248d5405276235cf613319754.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅当您的实用程序已正式安装在内核中时，所有这些操作才能完成。</font><font style="vertical-align: inherit;">也就是说，对于外部和不需要的软件，没有这样的漏洞。</font><font style="vertical-align: inherit;">但是，正如您所看到的，即使要保护诸如防病毒和备份系统之类的合法程序，也必须努力工作。</font><font style="vertical-align: inherit;">但是现在，用于macOS的新Acronis产品将具有防止从系统中卸载的附加保护。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN497688/index.html">Kubernetes夜校如何运作</a></li>
<li><a href="../zh-CN497696/index.html">Ryuk勒索软件如何攻击企业</a></li>
<li><a href="../zh-CN497700/index.html">从4月17日开始，每周在线备份，开发人员，安全和机器人</a></li>
<li><a href="../zh-CN497702/index.html">2020年您应注意的五个数据存储趋势</a></li>
<li><a href="../zh-CN497708/index.html">我们邀请您参加4月和5月的一系列Fujitsu网络研讨会</a></li>
<li><a href="../zh-CN497724/index.html">准备服务器以用Python发布Web应用程序</a></li>
<li><a href="../zh-CN497726/index.html">在Odnoklassniki扩展Android测试</a></li>
<li><a href="../zh-CN497728/index.html">“燃烧”碎屑的危险</a></li>
<li><a href="../zh-CN497730/index.html">方便的BDD：SpecFlow + TFS</a></li>
<li><a href="../zh-CN497736/index.html">审查10台新内燃机</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>