<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿 😑 👰🏼 Testen der Linux-Codeleistung anhand von Beispielen 👶🏿 ⛱️ 👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich anfing, Java zu lernen, bestand eine der ersten Aufgaben, die ich zu lösen versuchte, darin, gerade / ungerade Zahlen zu bestimmen. Ich kannte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Testen der Linux-Codeleistung anhand von Beispielen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489210/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als ich anfing, Java zu lernen, bestand eine der ersten Aufgaben, die ich zu lösen versuchte, darin, gerade / ungerade Zahlen zu bestimmen. Ich kannte verschiedene Möglichkeiten, um dies zu tun, entschied mich jedoch, im Internet nach dem „richtigen“ Weg zu suchen. Die Informationen auf allen gefundenen Links sagten mir über die einzig richtige Lösung der Form x% 2, um den Rest der Division zu erhalten. Wenn der Rest 0 ist, ist die Zahl gerade, wenn der Rest 1 ist, ist es ungerade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seit der Zeit von ZX Spectrum habe ich mich an einen anderen Weg erinnert, der mit der Darstellung von Zahlen im Binärsystem verbunden ist. Jede Zahl im Dezimalsystem kann als Summe der Zweierpotenzen geschrieben werden. Beispielsweise kann für ein Byte, und dies sind 8 Bits, eine beliebige Zahl im Dezimalsystem als die Summe der Zahlen 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 dargestellt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist nur eine Folge von Zweierpotenzen. Wenn wir eine Zahl in das Binärsystem übersetzen und die Zahl berücksichtigen müssen, ist sie in der Binärdarstellung eins, wenn nicht erforderlich, ist sie 0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 = 1010 (8 + 0 + 2 + 0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 = 1101 (8 + 4) + 0 + 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
200 = 11001000 (128 + 64 + 0 + 0 + 8 + 0 + 0 + 0)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können sofort darauf achten, dass eine ungerade Zahl nur eine Zweierpotenz von Null mit einem Wert von 1 ergeben kann, alle anderen Zweierpotenzen sind per Definition gerade. </font><font style="vertical-align: inherit;">Dies bedeutet automatisch, dass wir aus Sicht des Binärzahlensystems, wenn wir eine Zahl auf Parität prüfen möchten, nicht die ganze Zahl prüfen müssen, egal wie groß sie ist. </font><font style="vertical-align: inherit;">Wir müssen nur das erste Bit (ganz rechts) überprüfen. </font><font style="vertical-align: inherit;">Wenn es 0 ist, ist die Zahl gerade, da alle anderen Bits eine gerade Zahl ergeben, und umgekehrt, wenn es eine ganz rechts ist, ist die Zahl garantiert ungerade, da alle anderen Bits nur einen geraden Wert ergeben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um nur das richtige Bit in einer Zahl zu überprüfen, können Sie verschiedene Methoden verwenden. </font><font style="vertical-align: inherit;">Eines davon ist binäres UND.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UND</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Binäres UND (UND) funktioniert nach der folgenden Regel. Wenn Sie eine beliebige Zahl anwenden, nennen wir sie original, logisch UND mit der Zahl 0, dann ist das Ergebnis einer solchen Operation immer 0. Auf diese Weise können Sie die nicht benötigten Bits auf Null setzen. Wenn Sie sich für das Original 1 bewerben, erhalten Sie das Original. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem binären System ist es einfach, Folgendes zu schreiben: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 UND 0 = 0 (Null das Original) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 UND 0 = 0 (Null das Original) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 UND 1 = 0 (Original nicht ändern) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 UND 1 = 1 (Original nicht ändern) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von hier aus einige einfache Regeln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir die UND-Verknüpfung aller Einheiten auf alle Zahlen anwenden (alle Bits sind eingeschaltet), erhalten wir dieselbe Anfangsnummer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir UND aller Nullen auf eine beliebige Zahl anwenden (alle Bits sind ausgeschaltet), erhalten wir 0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir AND 0 auf Byte 13 anwenden, erhalten wir 0. In Dezimalzahlen sieht es so aus, als ob 13 AND 0 = 0 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir AND 0 auf Byte 200 anwenden, erhalten wir 0 oder schreiben 200 AND 0 = 0 kurz auf. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Gleiche ist das Gegenteil. Wenden Sie auf 13 alle enthaltenen Bits an, für ein Byte sind es acht Einheiten, und wir erhalten das Original. </font><font style="vertical-align: inherit;">Im binären System 00001101 UND 11111111 = 00001101 oder im Dezimalsystem 13 UND 255 = 13 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für 200 gibt es 11001000 UND 11111111 = 11001000 bzw. im Dezimalsystem 200 UND 255 = 200</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binäre Überprüfung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Zahl auf Parität zu überprüfen, müssen wir nur das Bit ganz rechts überprüfen. Wenn es 0 ist, ist die Zahl gerade, wenn 1, dann ist es nicht gerade. Wenn wir wissen, dass wir mit AND einige Bits original lassen können und einige zurücksetzen können, können wir einfach alle Bits außer dem am weitesten rechts liegenden zurücksetzen. Zum Beispiel: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 im Binärsystem ist 1101. Wenden wir AND 0001 darauf an (wir setzen alle Bits zurück, das letzte bleibt das Original). Im Jahr 1101 ändern wir alle Bits bis auf das letzte auf 0 und erhalten 0001. Wir haben nur das letzte Bit von unserer ursprünglichen Nummer erhalten. Im Dezimalsystem sieht es aus wie 13 UND 1 = 1.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Gleiche gilt für die Zahl 200 in binärer Form 11001000. Wir wenden AND 00000001 an, indem wir nach demselben Schema alle Bits auf Null setzen, das letzte so lassen, wie es ist, 00000000 erhalten und die linken 7 Nullen mit AND zurücksetzen und die letzte 0 zurücksetzen von der ursprünglichen Nummer. Im Dezimalsystem sieht es so aus, als ob 200 UND 1 = 0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir also den Befehl UND 1 auf eine beliebige Zahl anwenden, erhalten wir entweder 0 oder 1. Wenn das Ergebnis 0 ist, ist die Zahl gerade. Bei 1 ist die Zahl ungerade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Java wird das binäre UND als &amp; geschrieben. Dementsprechend ist 200 &amp; 1 = 0 (gerade) und 13 &amp; 1 = 1 (ungerade). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies impliziert mindestens zwei Methoden zur Bestimmung gerader Zahlen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X% 2 - durch den Rest der Division durch zwei </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X &amp; 1 - durch binäres UND</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Binäroperationen wie OR, AND, XOR werden vom Prozessor in kürzester Zeit verarbeitet. </font><font style="vertical-align: inherit;">Die Teilungsoperation ist jedoch eine nicht triviale Aufgabe, und um sie auszuführen, muss der Prozessor viele Anweisungen verarbeiten und im Wesentlichen das gesamte Programm ausführen. </font><font style="vertical-align: inherit;">Es gibt jedoch binäre Links- und Rechtsverschiebungsoperationen, mit denen beispielsweise eine Zahl schnell durch 2 geteilt werden kann. Die Frage ist, ob Compiler diese Optimierung verwenden und ob es einen Unterschied zwischen diesen beiden Vergleichen gibt, die tatsächlich dasselbe tun.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codierung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden ein Programm schreiben, das 9.000.000.000 Zahlen in einem Zyklus der Reihe nach verarbeitet und ihre Zugehörigkeit zu gerade / ungerade bestimmt, indem wir den Rest der Division bestimmen.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddEvenViaMod</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
                <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> odds=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> evens=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) {<font></font>
                        evens++;<font></font>
                        }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                        odds++;<font></font>
                        }<font></font>
                i++;<font></font>
                } <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">9000000000L</span>);<font></font>
                System.out.println(<span class="hljs-string">"Odd "</span> + odds);<font></font>
                System.out.println(<span class="hljs-string">"Even "</span> + evens);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wir werden genau das Gleiche schreiben, aber buchstäblich zwei Zeichen ändern und dasselbe durch binäres UND überprüfen.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddEvenViaAnd</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
                <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> odds=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> evens=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) {<font></font>
                        evens++;<font></font>
                        }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                        odds++;<font></font>
                        }<font></font>
                i++;<font></font>
                } <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">9000000000L</span>);<font></font>
                System.out.println(<span class="hljs-string">"Odd "</span> + odds);<font></font>
                System.out.println(<span class="hljs-string">"Even "</span> + evens);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen wir diese beiden Programme irgendwie vergleichen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ressourcen unter Linux. </font><font style="vertical-align: inherit;">Zentralprozessor</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurde sehr viel Zeit für die Erstellung eines Betriebssystems aufgewendet, insbesondere für die gerechte Verteilung der Ressourcen zwischen den Programmen. </font><font style="vertical-align: inherit;">Dies ist einerseits gut, da Sie sicher sein können, dass zwei Programme parallel ausgeführt werden. Wenn Sie jedoch die Leistung eines Programms überprüfen müssen, ist es äußerst wichtig, den externen Einfluss anderer auf das Programm zu begrenzen oder zumindest zu verringern Programme und Betriebssystem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste, was herauszufinden ist, ist der Prozessor. </font><font style="vertical-align: inherit;">Das Linux-Betriebssystem speichert für jeden Prozess eine Bitmaske, die angibt, welche Kernel von der Anwendung verwendet werden können und welche nicht. </font><font style="vertical-align: inherit;">Sie können diese Maske mit dem Task-Set-Befehl anzeigen und ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehen wir uns zum Beispiel die Anzahl der Kerne in meinem Prozessor an:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# grep -c processor /proc/cpuinfo<font></font>
4<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mein Computer hat einen Prozessor mit 4 Kernen. </font><font style="vertical-align: inherit;">Das ist gut, weil ich einen von ihnen meinen Bedürfnissen zuordnen werde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, ob alle derzeit mit dem Befehl top verwendet werden:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# top
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Drücken Sie "1", um Informationen zu jedem Kern separat anzuzeigen:</font></font><br>
<br>
<pre><code class="plaintext hljs">top - 13:44:11 up 1 day, 23:26,  7 users,  load average: 1.48, 2.21, 2.02<font></font>
Tasks: 321 total,   1 running, 320 sleeping,   0 stopped,   0 zombie<font></font>
%Cpu0  :  7.7 us,  6.8 sy,  0.0 ni, 85.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :  9.2 us,  4.2 sy,  0.0 ni, 86.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  7.6 us,  3.4 sy,  0.0 ni, 89.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  :  8.4 us,  4.2 sy,  0.0 ni, 87.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
KiB Mem : 16210820 total,   296972 free, 10072092 used,  5841756 buff/cache<font></font>
KiB Swap: 16777212 total, 16777212 free,        0 used.  5480568 avail Mem<font></font>
....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sehen wir, dass alle Kerne ungefähr gleich verwendet werden. </font><font style="vertical-align: inherit;">(us- und sy- und id-Indikatoren sind für jeden Kern ungefähr gleich). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir nun, dasselbe mit dem Task-Befehl zu sehen.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -p 1<font></font>
pid 1's current affinity mask: f<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Bitmaske "F" im Hexadezimalsystem bedeutet 15 in Dezimalzahl oder 1111 in Binär (8 + 4 + 2 + 1). </font><font style="vertical-align: inherit;">Alle Bits sind aktiviert, was bedeutet, dass alle Kerne von einem Prozess mit PID 1 verwendet werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter Linux wird die Bitmaske zum Zeitpunkt des Klonens vom übergeordneten Prozess kopiert, wenn ein Prozess einen anderen mit einem Klonsystemaufruf erzeugt. </font><font style="vertical-align: inherit;">Das heißt, wenn wir diese Maske für unseren Init-Prozess ändern (in meinem Fall ist es systemd), wird dieser neue Prozess beim Starten eines neuen Prozesses über systemd bereits mit einer neuen Maske gestartet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können die Maske für den Prozess mit demselben Befehl ändern und die Anzahl der CPU-Kerne auflisten, die für den Prozess verwendet werden sollen. </font><font style="vertical-align: inherit;">Angenommen, wir möchten den Kernel 0.2.3 für unseren Prozess belassen und Kernel 1 für unseren systemd-Prozess deaktivieren. </font><font style="vertical-align: inherit;">Dazu müssen wir den folgenden Befehl ausführen:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]#  taskset -pc 0,2,3 1<font></font>
pid 1's current affinity list: 0-3<font></font>
pid 1's new affinity list: 0,2,3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir überprüfen:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -p 1<font></font>
pid 1's current affinity mask: d<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Maske wurde in der hexadezimalen Notation in "D" geändert, dh 13 in Dezimal und 1101 in Binär (8 + 4 + 0 + 1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von nun an hat jeder Prozess, der vom systemd-Prozess geklont wird, automatisch eine Maske 1101 der CPU-Auslastung, was bedeutet, dass Kernel Nummer 1 nicht verwendet wird.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verbieten die Verwendung des Kernels für alle Prozesse</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verhindern, dass der Linux-Hauptprozess einen einzelnen Kernel verwendet, wirkt sich nur auf neue Prozesse aus, die durch diesen Prozess erstellt wurden. </font><font style="vertical-align: inherit;">Aber in meinem System gibt es bereits nicht einen Prozess, sondern eine ganze Menge, wie z. B. crond, sshd, bash und andere. </font><font style="vertical-align: inherit;">Wenn ich verhindern möchte, dass alle Prozesse einen Kern verwenden, muss ich den Task-Set-Befehl für jeden ausgeführten Prozess ausführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um eine Liste aller Prozesse zu erhalten, verwenden wir die vom Kernel bereitgestellte API, nämlich das Dateisystem / proc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weiter in der Schleife sehen wir uns die PID jedes laufenden Prozesses an und ändern die Maske für ihn und alle Threads:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# cd /proc; for i in `ls -d [0-9]*`; do taskset -a -pc 0,2,3 $i; done<font></font>
pid 1's current affinity list: 0,2,3<font></font>
pid 1's new affinity list: 0,2,3<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da einige Prozesse während der Ausführung des Programms Zeit haben könnten, andere Prozesse zu erzeugen, ist es besser, diesen Befehl mehrmals auszuführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überprüfen Sie das Ergebnis unserer Arbeit mit dem Befehl top:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# top<font></font>
top - 14:20:46 up 2 days, 3 min,  7 users,  load average: 0.19, 0.27, 0.57<font></font>
Tasks: 324 total,   4 running, 320 sleeping,   0 stopped,   0 zombie<font></font>
%Cpu0  :  8.9 us,  7.7 sy,  0.0 ni, 83.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  9.5 us,  6.0 sy,  0.0 ni, 84.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  :  8.4 us,  6.6 sy,  0.0 ni, 85.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
KiB Mem : 16210820 total,   285724 free, 10142548 used,  5782548 buff/cache<font></font>
KiB Swap: 16777212 total, 16777212 free,        0 used.  5399648 avail Mem<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, hat sich das Bild ein wenig geändert. Jetzt sind für den Kernel 0.2.3 die durchschnittlichen Parameter us, sy, id für uns gleich, und für Kernel 1 beträgt unser Kernverbrauch in Userspace und sys 0, und der Kernel ist zu 100% im Leerlauf (Leerlauf 100) ) </font><font style="vertical-align: inherit;">Kernel 1 wird von unseren Anwendungen nicht mehr verwendet, und ein sehr kleiner Prozentsatz wird derzeit vom Kernel verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist das Testen der Leistung darauf beschränkt, unseren Prozess auf einem freien Kern zu starten.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erinnerung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der einem Prozess zugewiesene physische Speicher kann problemlos aus jedem Prozess entnommen werden. </font><font style="vertical-align: inherit;">Dieser Mechanismus wird als Swap bezeichnet. </font><font style="vertical-align: inherit;">Wenn Linux einen Platz zum Tauschen hat, wird es es trotzdem tun. </font><font style="vertical-align: inherit;">Die einzige Möglichkeit, das Betriebssystem daran zu hindern, wie bei jedem anderen Prozess Speicher aus unserem Prozess zu entnehmen, besteht darin, den Swap-Abschnitt vollständig zu deaktivieren.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo swapoff -a<font></font>
[user@localhost]$ free -m<font></font>
              total        used        free      shared  buff/cache   available<font></font>
Mem:          15830        7294        1894         360        6641        7746<font></font>
Swap:             0           0           0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben 1 Prozessorkern zugewiesen, der nicht verwendet wird, und die Möglichkeit zum Austauschen von Speicher aus dem Linux-Kernel entfernt. </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platte</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Auswirkungen der Festplatte auf den Start unseres Prozesses zu verringern, erstellen Sie eine Festplatte im Speicher und kopieren Sie alle erforderlichen Dateien auf diese Festplatte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie ein Verzeichnis und hängen Sie das Dateisystem ein:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo mkdir /mnt/ramdisk;<font></font>
[user@localhost]$ mount -t tmpfs -o size=512m tmpfs /mnt/ramdisk<font></font>
[user@localhost]$ chown user: /mnt/ramdisk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen wir herausfinden, was und wie wir es starten wollen. </font><font style="vertical-align: inherit;">Um unser Programm auszuführen, müssen wir zuerst unseren Code kompilieren:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ javac OddEvenViaMod.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann müssen Sie es ausführen:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall möchten wir den Prozess jedoch auf dem Prozessorkern ausführen, der von keinem anderen Prozess verwendet wird. </font><font style="vertical-align: inherit;">Führen Sie es daher über das Task-Set aus:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -c 1 time java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unseren Tests müssen wir die Zeit messen, damit aus unserer Startlinie wird</font></font><br>
<br>
<pre><code class="plaintext hljs">taskset -c 1 time java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Linux-Betriebssystem unterstützt verschiedene Formate ausführbarer Dateien, von denen das ELF-Format am häufigsten verwendet wird. Mit diesem Dateiformat können Sie das Betriebssystem anweisen, Ihre Datei nicht auszuführen, sondern eine andere Datei auszuführen. Auf den ersten Blick klingt es nicht sehr logisch und verständlich. Stellen Sie sich vor, ich starte das Minesweeper-Spiel und das Mario-Spiel startet für mich - es sieht aus wie ein Virus. Aber das ist die Logik. Wenn für mein Programm eine dynamische Bibliothek erforderlich ist, z. B. libc oder eine andere, bedeutet dies, dass das Betriebssystem diese Bibliothek zuerst in den Speicher laden und anschließend mein Programm laden und ausführen muss. Und es scheint logisch, solche Funktionen im Betriebssystem selbst zu platzieren, aber das Betriebssystem arbeitet in einem geschützten Speicherbereich und sollte so wenig Funktionen wie möglich und notwendig enthalten.Daher bietet das ELF-Format die Möglichkeit, dem Betriebssystem mitzuteilen, dass wir ein anderes Programm herunterladen möchten, und dieses "andere" Programm lädt alle erforderlichen Bibliotheken und unser Programm herunter und startet das Ganze.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir müssen also 3 Dateien ausführen, dies ist Task-Set, Zeit, Java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überprüfen Sie die erste von ihnen:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ whereis taskset<font></font>
taskset: /usr/bin/taskset /usr/share/man/man1/taskset.1.gz<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bash führt die Datei / usr / bin / Task-Set aus und überprüft, was sich darin befindet:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ file /usr/bin/taskset<font></font>
/usr/bin/taskset: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=7a2fd0779f64aa9047faa00f498042f0f0c5dc60, stripped<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die ELF-Datei, über die ich oben geschrieben habe. </font><font style="vertical-align: inherit;">In der ELF-Datei gibt es neben dem Programm selbst verschiedene Header. </font><font style="vertical-align: inherit;">Durch das Starten dieser Datei überprüft das Betriebssystem seine Header. Wenn der Header "Requesting Program Interpreter" in der Datei vorhanden ist, startet das Betriebssystem die Datei über diesen Header und übergibt die ursprünglich gestartete Datei als Argument. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überprüfen Sie, ob dieser Header in unserer ELF-Datei vorhanden ist:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ readelf -a /usr/bin/taskset  | grep -i interpreter<font></font>
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Header ist vorhanden, was bedeutet, dass wir durch Starten der Datei / usr / bin / Task-Set tatsächlich /lib64/ld-linux-x86-64.so.2 ausführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überprüfen Sie, was diese Datei ist:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ ls -lah /lib64/ld-linux-x86-64.so.2<font></font>
lrwxrwxrwx 1 root root 10 May 21  2019 /lib64/ld-linux-x86-64.so.2 -&gt; ld-2.17.so<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein Sim-Link zur Datei /lib64/ld-2.17.so. </font><font style="vertical-align: inherit;">Hör zu:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ file /lib64/ld-2.17.so<font></font>
/lib64/ld-2.17.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=a527fe72908703c5972ae384e78d1850d1881ee7, not stripped<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, ist dies eine weitere ELF-Datei, die vom Betriebssystem ausgeführt wird. </font><font style="vertical-align: inherit;">Wir schauen uns die Überschriften an:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ readelf -a /lib64/ld-2.17.so  | grep -i interpreter<font></font>
[user@localhost]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen, dass diese ELF-Datei keinen solchen Header hat, daher wird das Betriebssystem diese Datei ausführen und die Kontrolle darauf übertragen. </font><font style="vertical-align: inherit;">Und schon öffnet diese Datei unsere Datei / usr / bin / Task-Set und liest von dort Informationen zu allen notwendigen Bibliotheken. </font><font style="vertical-align: inherit;">Die Liste der erforderlichen Bibliotheken befindet sich auch in den Headern der ELF-Datei. </font><font style="vertical-align: inherit;">Wir können diese Liste mit dem Befehl ldd oder readelf betrachten, was dasselbe ist:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ ldd /usr/bin/taskset<font></font>
	linux-vdso.so.1 =&gt;  (0x00007ffc4c1df000)<font></font>
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f4a24c4e000)<font></font>
	/lib64/ld-linux-x86-64.so.2 (0x00007f4a2501b000)<font></font>
<font></font>
[user@localhost]$ readelf -a /usr/bin/taskset  | grep NEEDED<font></font>
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VDSO ist ein verknüpfter Speicher, der nicht mit Bibliotheken verknüpft ist. Daher fehlt er in der ELF-Datei als erforderliche Bibliothek. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies macht deutlich, dass das Programm /lib64/ld-2.17.so für die Ausführung aller Programme verantwortlich ist, die dies erfordern, und dies sind alles Programme mit dynamisch verknüpften Bibliotheken. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir / usr / bin / Task-Set ausführen, ist dies genau das gleiche wie wir /lib64/ld-2.17.so mit dem Argument / usr / bin / Task-Set ausführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir kehren zum Problem des Einflusses der Festplatte auf unsere Tests zurück. </font><font style="vertical-align: inherit;">Jetzt wissen wir, dass wir, wenn wir unser Programm aus dem Speicher laden möchten, nicht eine Datei, sondern mehrere kopieren müssen:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp /lib64/libc-2.17.so /mnt/ramdisk/<font></font>
[user@localhost]$ cp /lib64/ld-2.17.so /mnt/ramdisk/<font></font>
[user@localhost]$ cp /usr/bin/taskset /mnt/ramdisk/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir machen das gleiche für die Zeit, deren Bibliotheksanforderungen genau gleich sind (wir haben bereits ld und libc kopiert).</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp /usr/bin/time /mnt/ramdisk/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für Java sind die Dinge etwas komplizierter, da Java viele verschiedene Bibliotheken benötigt, die für eine lange Zeit kopiert werden können. </font><font style="vertical-align: inherit;">Um mein Leben ein wenig zu vereinfachen, kopiere ich das gesamte Verzeichnis von meinem Java OpenJDK auf eine Festplatte im Speicher und erstelle einen Sim-Link. </font><font style="vertical-align: inherit;">Natürlich bleiben in diesem Fall Festplattenzugriffe erhalten, aber es wird weniger geben.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp -R /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64 /mnt/ramdisk/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Benennen Sie das alte Verzeichnis um und fügen Sie die Endung .default hinzu</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo mv /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64{,.default}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und erstellen Sie einen Symlink:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo ln -s /mnt/ramdisk/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64 /usr/lib/jvm/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wissen bereits, wie eine Binärdatei über das Argument zur Datei /lib64/ld-2.17.so ausgeführt wird, die tatsächlich gestartet wird. </font><font style="vertical-align: inherit;">Aber wie kann das Programm /lib64/ld-2.17.so geladene Bibliotheken aus dem von uns angegebenen Verzeichnis laden? </font><font style="vertical-align: inherit;">man ld hilft uns, woraus wir erfahren, dass das ld-Programm die Bibliotheken aus den von uns angegebenen Verzeichnissen lädt, wenn Sie die Umgebungsvariable LD_LIBRARY_PATH deklarieren. </font><font style="vertical-align: inherit;">Jetzt haben wir alle Daten, um die Startlinie der Java-Anwendung vorzubereiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir beginnen mehrmals hintereinander und prüfen:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.66user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20344maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.65user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.66user 0.01system 0:10.68elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.65user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+96outputs (0major+5234minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während der Ausführung des Programms können wir top ausführen und sicherstellen, dass das Programm auf dem richtigen CPU-Kern ausgeführt wird.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ top<font></font>
...<font></font>
%Cpu0  : 19.7 us, 11.7 sy,  0.0 ni, 68.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  9.8 us,  9.1 sy,  0.0 ni, 81.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  : 14.0 us,  9.0 sy,  0.0 ni, 77.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 s<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, sind die Ergebnisse in den meisten Fällen ähnlich. </font><font style="vertical-align: inherit;">Leider können wir den Einfluss des Betriebssystems auf den CPU-Kern nicht vollständig beseitigen, sodass das Ergebnis immer noch von den spezifischen Aufgaben im Linux-Kernel zum Zeitpunkt des Starts abhängt. </font><font style="vertical-align: inherit;">Daher ist es besser, den Median der Werte mehrerer Starts zu verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall sehen wir, dass das Java-Programm 9.000.000.000 mit Parität durch den Rest der Division in 10,65 Sekunden auf einem CPU-Kern verarbeitet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Machen wir den gleichen Test mit unserem zweiten Programm, das dasselbe durch binäres UND macht.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.02user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5197minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.01user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20228maxresident)k<font></font>
0inputs+64outputs (0major+5199minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.01user 0.01system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5198minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.02user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5198minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können wir mit Zuversicht sagen, dass der Vergleich für die Parität durch binäres UND 4,02 Sekunden dauert, was bedeutet, dass er im Vergleich zum Überprüfen des Restes der Division zumindest bei openjdk Version 1.8.0 2,6-mal schneller funktioniert.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oracle Java gegen Openjdk</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe Java JDK von der Oracle-Website in das Verzeichnis /mnt/ramdisk/jdk-13.0.2 heruntergeladen und entpackt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompilieren:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ /mnt/ramdisk/jdk-13.0.2/bin/javac OddEvenViaAnd.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir starten:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.39user 0.01system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 24260maxresident)k<font></font>
0inputs+64outputs (0major+6979minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.40user 0.01system 0:10.42elapsed 99%CPU (0avgtext+0avgdata 24268maxresident)k<font></font>
0inputs+64outputs (0major+6985minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir kompilieren das zweite Programm:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ /mnt/ramdisk/jdk-13.0.2/bin/javac OddEvenViaMod.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir starten:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.39user 0.01system 0:10.40elapsed 99%CPU (0avgtext+0avgdata 24324maxresident)k<font></font>
0inputs+96outputs (0major+7003minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.40user 0.00system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 24316maxresident)k<font></font>
0inputs+64outputs (0major+6992minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ausführungszeit derselben Quellen in oracle jdk ist für den Rest der Division und das binäre AND gleich, was normal aussieht, aber diese Zeit ist ebenso schlecht, was in openjdk für den Rest der Division gezeigt wurde.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir, dasselbe in Python zu vergleichen. </font><font style="vertical-align: inherit;">Erstens die Option mit dem Rest der Division durch 2:</font></font><br>
<br>
<pre><code class="python hljs">odd=<span class="hljs-number">0</span>
even=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
	<span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<font></font>
		even += <span class="hljs-number">1</span>
	<span class="hljs-keyword">else</span>:<font></font>
		odd += <span class="hljs-number">1</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir starten:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.69user 0.00system 0:11.69elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.67user 0.00system 0:11.67elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.66user 0.00system 0:11.66elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun das gleiche mit binärem UND:</font></font><br>
<br>
<pre><code class="python hljs">odd=<span class="hljs-number">0</span>
even=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
	<span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<font></font>
		even += <span class="hljs-number">1</span>
	<span class="hljs-keyword">else</span>:<font></font>
		odd += <span class="hljs-number">1</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir starten:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.41user 0.00system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 4588maxresident)k<font></font>
0inputs+0outputs (0major+1221minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.43user 0.00system 0:10.43elapsed 99%CPU (0avgtext+0avgdata 4588maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.43user 0.00system 0:10.43elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ergebnisse zeigen, dass AND schneller ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Internet wurde oft geschrieben, dass globale Variablen in Python langsamer sind. </font><font style="vertical-align: inherit;">Ich habe beschlossen, die Ausführungszeit des letzten Programms mit AND zu vergleichen und genau dieselbe, aber in eine Funktion eingeschlossen:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
	odd=<span class="hljs-number">0</span>
	even=<span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
		<span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<font></font>
			even += <span class="hljs-number">1</span>
		<span class="hljs-keyword">else</span>:<font></font>
			odd += <span class="hljs-number">1</span>
	<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
	<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd<font></font>
<font></font>
main()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Führen Sie die folgende Funktion aus:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and_func.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
5.08user 0.00system 0:05.08elapsed 99%CPU (0avgtext+0avgdata 4592maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and_func.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
5.08user 0.00system 0:05.09elapsed 99%CPU (0avgtext+0avgdata 4592maxresident)k<font></font>
0inputs+0outputs (0major+1223minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, verarbeitet der gleiche Paritätsvergleich in Python über binäres UND in einer Funktion 100000000 Zahlen auf einem einzelnen CPU-Kern in ~ 5 Sekunden, der gleiche Vergleich über UND ohne Funktion dauert ~ 10 Sekunden und der Vergleich ohne Funktion durch den Rest der Division dauert ~ 11 Sekunden </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ein Python-Programm in einer Funktion schneller als ohne funktioniert, wurde bereits mehrmals beschrieben und hängt mit dem Umfang der Variablen zusammen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python hat die Möglichkeit, ein Programm in interne Funktionen zu zerlegen, die Python bei der Interpretation eines Programms verwendet. </font><font style="vertical-align: inherit;">Mal sehen, welche Funktionen Python für die Variante mit der Funktion odd_and_func.py verwendet:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]# python<font></font>
Python 2.7.5 (default, Jun 20 2019, 20:27:34)<font></font>
[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux2<font></font>
Type "help", "copyright", "credits" or "license" for more information.<font></font>
&gt;&gt;&gt; def main():<font></font>
...     odd=0<font></font>
...     even=0<font></font>
...     for i in xrange(100000000):<font></font>
...             if i &amp; 1 == 0:<font></font>
...                     even += 1<font></font>
...             else:<font></font>
...                     odd += 1<font></font>
...     print "even", even<font></font>
...     print "odd", odd<font></font>
...<font></font>
&gt;&gt;&gt; import dis<font></font>
&gt;&gt;&gt; dis.dis(main)<font></font>
  2           0 LOAD_CONST               1 (0)<font></font>
              3 STORE_FAST               0 (odd)<font></font>
<font></font>
  3           6 LOAD_CONST               1 (0)<font></font>
              9 STORE_FAST               1 (even)<font></font>
<font></font>
  4          12 SETUP_LOOP              59 (to 74)<font></font>
             15 LOAD_GLOBAL              0 (xrange)<font></font>
             18 LOAD_CONST               2 (100000000)<font></font>
             21 CALL_FUNCTION            1<font></font>
             24 GET_ITER<font></font>
        &gt;&gt;   25 FOR_ITER                45 (to 73)<font></font>
             28 STORE_FAST               2 (i)<font></font>
<font></font>
  5          31 LOAD_FAST                2 (i)<font></font>
             34 LOAD_CONST               3 (1)<font></font>
             37 BINARY_AND<font></font>
             38 LOAD_CONST               1 (0)<font></font>
             41 COMPARE_OP               2 (==)<font></font>
             44 POP_JUMP_IF_FALSE       60<font></font>
<font></font>
  6          47 LOAD_FAST                1 (even)<font></font>
             50 LOAD_CONST               3 (1)<font></font>
             53 INPLACE_ADD<font></font>
             54 STORE_FAST               1 (even)<font></font>
             57 JUMP_ABSOLUTE           25<font></font>
<font></font>
  8     &gt;&gt;   60 LOAD_FAST                0 (odd)<font></font>
             63 LOAD_CONST               3 (1)<font></font>
             66 INPLACE_ADD<font></font>
             67 STORE_FAST               0 (odd)<font></font>
             70 JUMP_ABSOLUTE           25<font></font>
        &gt;&gt;   73 POP_BLOCK<font></font>
<font></font>
  9     &gt;&gt;   74 LOAD_CONST               4 ('even')<font></font>
             77 PRINT_ITEM<font></font>
             78 LOAD_FAST                1 (even)<font></font>
             81 PRINT_ITEM<font></font>
             82 PRINT_NEWLINE<font></font>
<font></font>
 10          83 LOAD_CONST               5 ('odd')<font></font>
             86 PRINT_ITEM<font></font>
             87 LOAD_FAST                0 (odd)<font></font>
             90 PRINT_ITEM<font></font>
             91 PRINT_NEWLINE<font></font>
             92 LOAD_CONST               0 (None)<font></font>
             95 RETURN_VALUE<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und überprüfen Sie dasselbe, ohne die Funktion in unserem Code zu verwenden:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt;&gt;&gt; f=open("odd_and.py","r")<font></font>
&gt;&gt;&gt; l=f.read()<font></font>
&gt;&gt;&gt;<font></font>
&gt;&gt;&gt; l<font></font>
'odd=0\neven=0\nfor i in xrange(100000000):\n\tif i &amp; 1 == 0:\n\t\teven += 1\n\telse:\n\t\todd += 1\nprint "even", even\nprint "odd", odd\n'<font></font>
&gt;&gt;&gt; k=compile(l,'l','exec')<font></font>
&gt;&gt;&gt; k<font></font>
&lt;code object &lt;module&gt; at 0x7f2bdf39ecb0, file "l", line 1&gt;<font></font>
&gt;&gt;&gt; dis.dis(k)<font></font>
  1           0 LOAD_CONST               0 (0)<font></font>
              3 STORE_NAME               0 (odd)<font></font>
<font></font>
  2           6 LOAD_CONST               0 (0)<font></font>
              9 STORE_NAME               1 (even)<font></font>
<font></font>
  3          12 SETUP_LOOP              59 (to 74)<font></font>
             15 LOAD_NAME                2 (xrange)<font></font>
             18 LOAD_CONST               1 (100000000)<font></font>
             21 CALL_FUNCTION            1<font></font>
             24 GET_ITER<font></font>
        &gt;&gt;   25 FOR_ITER                45 (to 73)<font></font>
             28 STORE_NAME               3 (i)<font></font>
<font></font>
  4          31 LOAD_NAME                3 (i)<font></font>
             34 LOAD_CONST               2 (1)<font></font>
             37 BINARY_AND<font></font>
             38 LOAD_CONST               0 (0)<font></font>
             41 COMPARE_OP               2 (==)<font></font>
             44 POP_JUMP_IF_FALSE       60<font></font>
<font></font>
  5          47 LOAD_NAME                1 (even)<font></font>
             50 LOAD_CONST               2 (1)<font></font>
             53 INPLACE_ADD<font></font>
             54 STORE_NAME               1 (even)<font></font>
             57 JUMP_ABSOLUTE           25<font></font>
<font></font>
  7     &gt;&gt;   60 LOAD_NAME                0 (odd)<font></font>
             63 LOAD_CONST               2 (1)<font></font>
             66 INPLACE_ADD<font></font>
             67 STORE_NAME               0 (odd)<font></font>
             70 JUMP_ABSOLUTE           25<font></font>
        &gt;&gt;   73 POP_BLOCK<font></font>
<font></font>
  8     &gt;&gt;   74 LOAD_CONST               3 ('even')<font></font>
             77 PRINT_ITEM<font></font>
             78 LOAD_NAME                1 (even)<font></font>
             81 PRINT_ITEM<font></font>
             82 PRINT_NEWLINE<font></font>
<font></font>
  9          83 LOAD_CONST               4 ('odd')<font></font>
             86 PRINT_ITEM<font></font>
             87 LOAD_NAME                0 (odd)<font></font>
             90 PRINT_ITEM<font></font>
             91 PRINT_NEWLINE<font></font>
             92 LOAD_CONST               5 (None)<font></font>
             95 RETURN_VALUE<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, verwendet Python in der Variante mit der deklarierten Funktion interne Funktionen mit dem FAST-Postfix, z. B. STORE_FAST, LOAD_FAST, und in der Variante ohne Deklaration der Funktion verwendet Python die internen Funktionen STORE_NAME und LOAD_NAME. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel hat wenig praktische Bedeutung und zielt eher darauf ab, einige der Funktionen von Linux und Compilern zu verstehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gut zu allen!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de489194/index.html">Wie OpenShift die Organisationsstruktur einer IT-Organisation verändert. Die Entwicklung von Organisationsmodellen beim Wechsel zu PaaS</a></li>
<li><a href="../de489196/index.html">Magic Smoke: Mikrocontroller vs. Linearregler</a></li>
<li><a href="../de489198/index.html">Wie Sie sich mit Liquibase nicht in den Fuß schießen</a></li>
<li><a href="../de489200/index.html">Was Startups für Y Combinator im Jahr 2020 suchen</a></li>
<li><a href="../de489204/index.html">Ein Einblick in die Zuverlässigkeit von Facebook-Diensten</a></li>
<li><a href="../de489212/index.html">1C-Bitrix verhindert das Abbestellen des Newsletters durch die Verpflichtung zur Übermittlung ihrer persönlichen Daten</a></li>
<li><a href="../de489214/index.html">Moderner Ansatz zum Testen der Lokalisierung unter iOS</a></li>
<li><a href="../de489218/index.html">Es ist naiv. Super: Code und Architektur eines einfachen Spiels</a></li>
<li><a href="../de489226/index.html">Methoden zum Optimieren von LINQ-Abfragen in C # .NET</a></li>
<li><a href="../de489228/index.html">Sprachbot in der Bank - die schlechteste UX aller Zeiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>