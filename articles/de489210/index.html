<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø üòë üë∞üèº Testen der Linux-Codeleistung anhand von Beispielen üë∂üèø ‚õ±Ô∏è üë©üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich anfing, Java zu lernen, bestand eine der ersten Aufgaben, die ich zu l√∂sen versuchte, darin, gerade / ungerade Zahlen zu bestimmen. Ich kannte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Testen der Linux-Codeleistung anhand von Beispielen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489210/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als ich anfing, Java zu lernen, bestand eine der ersten Aufgaben, die ich zu l√∂sen versuchte, darin, gerade / ungerade Zahlen zu bestimmen. Ich kannte verschiedene M√∂glichkeiten, um dies zu tun, entschied mich jedoch, im Internet nach dem ‚Äûrichtigen‚Äú Weg zu suchen. Die Informationen auf allen gefundenen Links sagten mir √ºber die einzig richtige L√∂sung der Form x% 2, um den Rest der Division zu erhalten. Wenn der Rest 0 ist, ist die Zahl gerade, wenn der Rest 1 ist, ist es ungerade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seit der Zeit von ZX Spectrum habe ich mich an einen anderen Weg erinnert, der mit der Darstellung von Zahlen im Bin√§rsystem verbunden ist. Jede Zahl im Dezimalsystem kann als Summe der Zweierpotenzen geschrieben werden. Beispielsweise kann f√ºr ein Byte, und dies sind 8 Bits, eine beliebige Zahl im Dezimalsystem als die Summe der Zahlen 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 dargestellt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist nur eine Folge von Zweierpotenzen. Wenn wir eine Zahl in das Bin√§rsystem √ºbersetzen und die Zahl ber√ºcksichtigen m√ºssen, ist sie in der Bin√§rdarstellung eins, wenn nicht erforderlich, ist sie 0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 = 1010 (8 + 0 + 2 + 0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 = 1101 (8 + 4) + 0 + 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
200 = 11001000 (128 + 64 + 0 + 0 + 8 + 0 + 0 + 0)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen sofort darauf achten, dass eine ungerade Zahl nur eine Zweierpotenz von Null mit einem Wert von 1 ergeben kann, alle anderen Zweierpotenzen sind per Definition gerade. </font><font style="vertical-align: inherit;">Dies bedeutet automatisch, dass wir aus Sicht des Bin√§rzahlensystems, wenn wir eine Zahl auf Parit√§t pr√ºfen m√∂chten, nicht die ganze Zahl pr√ºfen m√ºssen, egal wie gro√ü sie ist. </font><font style="vertical-align: inherit;">Wir m√ºssen nur das erste Bit (ganz rechts) √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Wenn es 0 ist, ist die Zahl gerade, da alle anderen Bits eine gerade Zahl ergeben, und umgekehrt, wenn es eine ganz rechts ist, ist die Zahl garantiert ungerade, da alle anderen Bits nur einen geraden Wert ergeben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um nur das richtige Bit in einer Zahl zu √ºberpr√ºfen, k√∂nnen Sie verschiedene Methoden verwenden. </font><font style="vertical-align: inherit;">Eines davon ist bin√§res UND.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UND</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bin√§res UND (UND) funktioniert nach der folgenden Regel. Wenn Sie eine beliebige Zahl anwenden, nennen wir sie original, logisch UND mit der Zahl 0, dann ist das Ergebnis einer solchen Operation immer 0. Auf diese Weise k√∂nnen Sie die nicht ben√∂tigten Bits auf Null setzen. Wenn Sie sich f√ºr das Original 1 bewerben, erhalten Sie das Original. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem bin√§ren System ist es einfach, Folgendes zu schreiben: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 UND 0 = 0 (Null das Original) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 UND 0 = 0 (Null das Original) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 UND 1 = 0 (Original nicht √§ndern) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 UND 1 = 1 (Original nicht √§ndern) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von hier aus einige einfache Regeln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir die UND-Verkn√ºpfung aller Einheiten auf alle Zahlen anwenden (alle Bits sind eingeschaltet), erhalten wir dieselbe Anfangsnummer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir UND aller Nullen auf eine beliebige Zahl anwenden (alle Bits sind ausgeschaltet), erhalten wir 0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir AND 0 auf Byte 13 anwenden, erhalten wir 0. In Dezimalzahlen sieht es so aus, als ob 13 AND 0 = 0 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir AND 0 auf Byte 200 anwenden, erhalten wir 0 oder schreiben 200 AND 0 = 0 kurz auf. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Gleiche ist das Gegenteil. Wenden Sie auf 13 alle enthaltenen Bits an, f√ºr ein Byte sind es acht Einheiten, und wir erhalten das Original. </font><font style="vertical-align: inherit;">Im bin√§ren System 00001101 UND 11111111 = 00001101 oder im Dezimalsystem 13 UND 255 = 13 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr 200 gibt es 11001000 UND 11111111 = 11001000 bzw. im Dezimalsystem 200 UND 255 = 200</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bin√§re √úberpr√ºfung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Zahl auf Parit√§t zu √ºberpr√ºfen, m√ºssen wir nur das Bit ganz rechts √ºberpr√ºfen. Wenn es 0 ist, ist die Zahl gerade, wenn 1, dann ist es nicht gerade. Wenn wir wissen, dass wir mit AND einige Bits original lassen k√∂nnen und einige zur√ºcksetzen k√∂nnen, k√∂nnen wir einfach alle Bits au√üer dem am weitesten rechts liegenden zur√ºcksetzen. Zum Beispiel: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 im Bin√§rsystem ist 1101. Wenden wir AND 0001 darauf an (wir setzen alle Bits zur√ºck, das letzte bleibt das Original). Im Jahr 1101 √§ndern wir alle Bits bis auf das letzte auf 0 und erhalten 0001. Wir haben nur das letzte Bit von unserer urspr√ºnglichen Nummer erhalten. Im Dezimalsystem sieht es aus wie 13 UND 1 = 1.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Gleiche gilt f√ºr die Zahl 200 in bin√§rer Form 11001000. Wir wenden AND 00000001 an, indem wir nach demselben Schema alle Bits auf Null setzen, das letzte so lassen, wie es ist, 00000000 erhalten und die linken 7 Nullen mit AND zur√ºcksetzen und die letzte 0 zur√ºcksetzen von der urspr√ºnglichen Nummer. Im Dezimalsystem sieht es so aus, als ob 200 UND 1 = 0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir also den Befehl UND 1 auf eine beliebige Zahl anwenden, erhalten wir entweder 0 oder 1. Wenn das Ergebnis 0 ist, ist die Zahl gerade. Bei 1 ist die Zahl ungerade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Java wird das bin√§re UND als &amp; geschrieben. Dementsprechend ist 200 &amp; 1 = 0 (gerade) und 13 &amp; 1 = 1 (ungerade). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies impliziert mindestens zwei Methoden zur Bestimmung gerader Zahlen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X% 2 - durch den Rest der Division durch zwei </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X &amp; 1 - durch bin√§res UND</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bin√§roperationen wie OR, AND, XOR werden vom Prozessor in k√ºrzester Zeit verarbeitet. </font><font style="vertical-align: inherit;">Die Teilungsoperation ist jedoch eine nicht triviale Aufgabe, und um sie auszuf√ºhren, muss der Prozessor viele Anweisungen verarbeiten und im Wesentlichen das gesamte Programm ausf√ºhren. </font><font style="vertical-align: inherit;">Es gibt jedoch bin√§re Links- und Rechtsverschiebungsoperationen, mit denen beispielsweise eine Zahl schnell durch 2 geteilt werden kann. Die Frage ist, ob Compiler diese Optimierung verwenden und ob es einen Unterschied zwischen diesen beiden Vergleichen gibt, die tats√§chlich dasselbe tun.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codierung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden ein Programm schreiben, das 9.000.000.000 Zahlen in einem Zyklus der Reihe nach verarbeitet und ihre Zugeh√∂rigkeit zu gerade / ungerade bestimmt, indem wir den Rest der Division bestimmen.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddEvenViaMod</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
                <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> odds=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> evens=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) {<font></font>
                        evens++;<font></font>
                        }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                        odds++;<font></font>
                        }<font></font>
                i++;<font></font>
                } <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">9000000000L</span>);<font></font>
                System.out.println(<span class="hljs-string">"Odd "</span> + odds);<font></font>
                System.out.println(<span class="hljs-string">"Even "</span> + evens);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wir werden genau das Gleiche schreiben, aber buchst√§blich zwei Zeichen √§ndern und dasselbe durch bin√§res UND √ºberpr√ºfen.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddEvenViaAnd</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
                <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> odds=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> evens=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) {<font></font>
                        evens++;<font></font>
                        }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                        odds++;<font></font>
                        }<font></font>
                i++;<font></font>
                } <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">9000000000L</span>);<font></font>
                System.out.println(<span class="hljs-string">"Odd "</span> + odds);<font></font>
                System.out.println(<span class="hljs-string">"Even "</span> + evens);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt m√ºssen wir diese beiden Programme irgendwie vergleichen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ressourcen unter Linux. </font><font style="vertical-align: inherit;">Zentralprozessor</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurde sehr viel Zeit f√ºr die Erstellung eines Betriebssystems aufgewendet, insbesondere f√ºr die gerechte Verteilung der Ressourcen zwischen den Programmen. </font><font style="vertical-align: inherit;">Dies ist einerseits gut, da Sie sicher sein k√∂nnen, dass zwei Programme parallel ausgef√ºhrt werden. Wenn Sie jedoch die Leistung eines Programms √ºberpr√ºfen m√ºssen, ist es √§u√üerst wichtig, den externen Einfluss anderer auf das Programm zu begrenzen oder zumindest zu verringern Programme und Betriebssystem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste, was herauszufinden ist, ist der Prozessor. </font><font style="vertical-align: inherit;">Das Linux-Betriebssystem speichert f√ºr jeden Prozess eine Bitmaske, die angibt, welche Kernel von der Anwendung verwendet werden k√∂nnen und welche nicht. </font><font style="vertical-align: inherit;">Sie k√∂nnen diese Maske mit dem Task-Set-Befehl anzeigen und √§ndern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehen wir uns zum Beispiel die Anzahl der Kerne in meinem Prozessor an:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# grep -c processor /proc/cpuinfo<font></font>
4<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mein Computer hat einen Prozessor mit 4 Kernen. </font><font style="vertical-align: inherit;">Das ist gut, weil ich einen von ihnen meinen Bed√ºrfnissen zuordnen werde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, ob alle derzeit mit dem Befehl top verwendet werden:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# top
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dr√ºcken Sie "1", um Informationen zu jedem Kern separat anzuzeigen:</font></font><br>
<br>
<pre><code class="plaintext hljs">top - 13:44:11 up 1 day, 23:26,  7 users,  load average: 1.48, 2.21, 2.02<font></font>
Tasks: 321 total,   1 running, 320 sleeping,   0 stopped,   0 zombie<font></font>
%Cpu0  :  7.7 us,  6.8 sy,  0.0 ni, 85.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :  9.2 us,  4.2 sy,  0.0 ni, 86.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  7.6 us,  3.4 sy,  0.0 ni, 89.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  :  8.4 us,  4.2 sy,  0.0 ni, 87.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
KiB Mem : 16210820 total,   296972 free, 10072092 used,  5841756 buff/cache<font></font>
KiB Swap: 16777212 total, 16777212 free,        0 used.  5480568 avail Mem<font></font>
....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sehen wir, dass alle Kerne ungef√§hr gleich verwendet werden. </font><font style="vertical-align: inherit;">(us- und sy- und id-Indikatoren sind f√ºr jeden Kern ungef√§hr gleich). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir nun, dasselbe mit dem Task-Befehl zu sehen.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -p 1<font></font>
pid 1's current affinity mask: f<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Bitmaske "F" im Hexadezimalsystem bedeutet 15 in Dezimalzahl oder 1111 in Bin√§r (8 + 4 + 2 + 1). </font><font style="vertical-align: inherit;">Alle Bits sind aktiviert, was bedeutet, dass alle Kerne von einem Prozess mit PID 1 verwendet werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter Linux wird die Bitmaske zum Zeitpunkt des Klonens vom √ºbergeordneten Prozess kopiert, wenn ein Prozess einen anderen mit einem Klonsystemaufruf erzeugt. </font><font style="vertical-align: inherit;">Das hei√üt, wenn wir diese Maske f√ºr unseren Init-Prozess √§ndern (in meinem Fall ist es systemd), wird dieser neue Prozess beim Starten eines neuen Prozesses √ºber systemd bereits mit einer neuen Maske gestartet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen die Maske f√ºr den Prozess mit demselben Befehl √§ndern und die Anzahl der CPU-Kerne auflisten, die f√ºr den Prozess verwendet werden sollen. </font><font style="vertical-align: inherit;">Angenommen, wir m√∂chten den Kernel 0.2.3 f√ºr unseren Prozess belassen und Kernel 1 f√ºr unseren systemd-Prozess deaktivieren. </font><font style="vertical-align: inherit;">Dazu m√ºssen wir den folgenden Befehl ausf√ºhren:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]#  taskset -pc 0,2,3 1<font></font>
pid 1's current affinity list: 0-3<font></font>
pid 1's new affinity list: 0,2,3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir √ºberpr√ºfen:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -p 1<font></font>
pid 1's current affinity mask: d<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Maske wurde in der hexadezimalen Notation in "D" ge√§ndert, dh 13 in Dezimal und 1101 in Bin√§r (8 + 4 + 0 + 1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von nun an hat jeder Prozess, der vom systemd-Prozess geklont wird, automatisch eine Maske 1101 der CPU-Auslastung, was bedeutet, dass Kernel Nummer 1 nicht verwendet wird.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verbieten die Verwendung des Kernels f√ºr alle Prozesse</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verhindern, dass der Linux-Hauptprozess einen einzelnen Kernel verwendet, wirkt sich nur auf neue Prozesse aus, die durch diesen Prozess erstellt wurden. </font><font style="vertical-align: inherit;">Aber in meinem System gibt es bereits nicht einen Prozess, sondern eine ganze Menge, wie z. B. crond, sshd, bash und andere. </font><font style="vertical-align: inherit;">Wenn ich verhindern m√∂chte, dass alle Prozesse einen Kern verwenden, muss ich den Task-Set-Befehl f√ºr jeden ausgef√ºhrten Prozess ausf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um eine Liste aller Prozesse zu erhalten, verwenden wir die vom Kernel bereitgestellte API, n√§mlich das Dateisystem / proc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weiter in der Schleife sehen wir uns die PID jedes laufenden Prozesses an und √§ndern die Maske f√ºr ihn und alle Threads:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# cd /proc; for i in `ls -d [0-9]*`; do taskset -a -pc 0,2,3 $i; done<font></font>
pid 1's current affinity list: 0,2,3<font></font>
pid 1's new affinity list: 0,2,3<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da einige Prozesse w√§hrend der Ausf√ºhrung des Programms Zeit haben k√∂nnten, andere Prozesse zu erzeugen, ist es besser, diesen Befehl mehrmals auszuf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úberpr√ºfen Sie das Ergebnis unserer Arbeit mit dem Befehl top:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# top<font></font>
top - 14:20:46 up 2 days, 3 min,  7 users,  load average: 0.19, 0.27, 0.57<font></font>
Tasks: 324 total,   4 running, 320 sleeping,   0 stopped,   0 zombie<font></font>
%Cpu0  :  8.9 us,  7.7 sy,  0.0 ni, 83.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  9.5 us,  6.0 sy,  0.0 ni, 84.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  :  8.4 us,  6.6 sy,  0.0 ni, 85.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
KiB Mem : 16210820 total,   285724 free, 10142548 used,  5782548 buff/cache<font></font>
KiB Swap: 16777212 total, 16777212 free,        0 used.  5399648 avail Mem<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, hat sich das Bild ein wenig ge√§ndert. Jetzt sind f√ºr den Kernel 0.2.3 die durchschnittlichen Parameter us, sy, id f√ºr uns gleich, und f√ºr Kernel 1 betr√§gt unser Kernverbrauch in Userspace und sys 0, und der Kernel ist zu 100% im Leerlauf (Leerlauf 100) ) </font><font style="vertical-align: inherit;">Kernel 1 wird von unseren Anwendungen nicht mehr verwendet, und ein sehr kleiner Prozentsatz wird derzeit vom Kernel verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist das Testen der Leistung darauf beschr√§nkt, unseren Prozess auf einem freien Kern zu starten.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erinnerung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der einem Prozess zugewiesene physische Speicher kann problemlos aus jedem Prozess entnommen werden. </font><font style="vertical-align: inherit;">Dieser Mechanismus wird als Swap bezeichnet. </font><font style="vertical-align: inherit;">Wenn Linux einen Platz zum Tauschen hat, wird es es trotzdem tun. </font><font style="vertical-align: inherit;">Die einzige M√∂glichkeit, das Betriebssystem daran zu hindern, wie bei jedem anderen Prozess Speicher aus unserem Prozess zu entnehmen, besteht darin, den Swap-Abschnitt vollst√§ndig zu deaktivieren.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo swapoff -a<font></font>
[user@localhost]$ free -m<font></font>
              total        used        free      shared  buff/cache   available<font></font>
Mem:          15830        7294        1894         360        6641        7746<font></font>
Swap:             0           0           0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben 1 Prozessorkern zugewiesen, der nicht verwendet wird, und die M√∂glichkeit zum Austauschen von Speicher aus dem Linux-Kernel entfernt. </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platte</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Auswirkungen der Festplatte auf den Start unseres Prozesses zu verringern, erstellen Sie eine Festplatte im Speicher und kopieren Sie alle erforderlichen Dateien auf diese Festplatte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie ein Verzeichnis und h√§ngen Sie das Dateisystem ein:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo mkdir /mnt/ramdisk;<font></font>
[user@localhost]$ mount -t tmpfs -o size=512m tmpfs /mnt/ramdisk<font></font>
[user@localhost]$ chown user: /mnt/ramdisk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt m√ºssen wir herausfinden, was und wie wir es starten wollen. </font><font style="vertical-align: inherit;">Um unser Programm auszuf√ºhren, m√ºssen wir zuerst unseren Code kompilieren:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ javac OddEvenViaMod.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann m√ºssen Sie es ausf√ºhren:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall m√∂chten wir den Prozess jedoch auf dem Prozessorkern ausf√ºhren, der von keinem anderen Prozess verwendet wird. </font><font style="vertical-align: inherit;">F√ºhren Sie es daher √ºber das Task-Set aus:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -c 1 time java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unseren Tests m√ºssen wir die Zeit messen, damit aus unserer Startlinie wird</font></font><br>
<br>
<pre><code class="plaintext hljs">taskset -c 1 time java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Linux-Betriebssystem unterst√ºtzt verschiedene Formate ausf√ºhrbarer Dateien, von denen das ELF-Format am h√§ufigsten verwendet wird. Mit diesem Dateiformat k√∂nnen Sie das Betriebssystem anweisen, Ihre Datei nicht auszuf√ºhren, sondern eine andere Datei auszuf√ºhren. Auf den ersten Blick klingt es nicht sehr logisch und verst√§ndlich. Stellen Sie sich vor, ich starte das Minesweeper-Spiel und das Mario-Spiel startet f√ºr mich - es sieht aus wie ein Virus. Aber das ist die Logik. Wenn f√ºr mein Programm eine dynamische Bibliothek erforderlich ist, z. B. libc oder eine andere, bedeutet dies, dass das Betriebssystem diese Bibliothek zuerst in den Speicher laden und anschlie√üend mein Programm laden und ausf√ºhren muss. Und es scheint logisch, solche Funktionen im Betriebssystem selbst zu platzieren, aber das Betriebssystem arbeitet in einem gesch√ºtzten Speicherbereich und sollte so wenig Funktionen wie m√∂glich und notwendig enthalten.Daher bietet das ELF-Format die M√∂glichkeit, dem Betriebssystem mitzuteilen, dass wir ein anderes Programm herunterladen m√∂chten, und dieses "andere" Programm l√§dt alle erforderlichen Bibliotheken und unser Programm herunter und startet das Ganze.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir m√ºssen also 3 Dateien ausf√ºhren, dies ist Task-Set, Zeit, Java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úberpr√ºfen Sie die erste von ihnen:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ whereis taskset<font></font>
taskset: /usr/bin/taskset /usr/share/man/man1/taskset.1.gz<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bash f√ºhrt die Datei / usr / bin / Task-Set aus und √ºberpr√ºft, was sich darin befindet:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ file /usr/bin/taskset<font></font>
/usr/bin/taskset: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=7a2fd0779f64aa9047faa00f498042f0f0c5dc60, stripped<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die ELF-Datei, √ºber die ich oben geschrieben habe. </font><font style="vertical-align: inherit;">In der ELF-Datei gibt es neben dem Programm selbst verschiedene Header. </font><font style="vertical-align: inherit;">Durch das Starten dieser Datei √ºberpr√ºft das Betriebssystem seine Header. Wenn der Header "Requesting Program Interpreter" in der Datei vorhanden ist, startet das Betriebssystem die Datei √ºber diesen Header und √ºbergibt die urspr√ºnglich gestartete Datei als Argument. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úberpr√ºfen Sie, ob dieser Header in unserer ELF-Datei vorhanden ist:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ readelf -a /usr/bin/taskset  | grep -i interpreter<font></font>
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Header ist vorhanden, was bedeutet, dass wir durch Starten der Datei / usr / bin / Task-Set tats√§chlich /lib64/ld-linux-x86-64.so.2 ausf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úberpr√ºfen Sie, was diese Datei ist:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ ls -lah /lib64/ld-linux-x86-64.so.2<font></font>
lrwxrwxrwx 1 root root 10 May 21  2019 /lib64/ld-linux-x86-64.so.2 -&gt; ld-2.17.so<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein Sim-Link zur Datei /lib64/ld-2.17.so. </font><font style="vertical-align: inherit;">H√∂r zu:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ file /lib64/ld-2.17.so<font></font>
/lib64/ld-2.17.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=a527fe72908703c5972ae384e78d1850d1881ee7, not stripped<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, ist dies eine weitere ELF-Datei, die vom Betriebssystem ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">Wir schauen uns die √úberschriften an:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ readelf -a /lib64/ld-2.17.so  | grep -i interpreter<font></font>
[user@localhost]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen, dass diese ELF-Datei keinen solchen Header hat, daher wird das Betriebssystem diese Datei ausf√ºhren und die Kontrolle darauf √ºbertragen. </font><font style="vertical-align: inherit;">Und schon √∂ffnet diese Datei unsere Datei / usr / bin / Task-Set und liest von dort Informationen zu allen notwendigen Bibliotheken. </font><font style="vertical-align: inherit;">Die Liste der erforderlichen Bibliotheken befindet sich auch in den Headern der ELF-Datei. </font><font style="vertical-align: inherit;">Wir k√∂nnen diese Liste mit dem Befehl ldd oder readelf betrachten, was dasselbe ist:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ ldd /usr/bin/taskset<font></font>
	linux-vdso.so.1 =&gt;  (0x00007ffc4c1df000)<font></font>
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f4a24c4e000)<font></font>
	/lib64/ld-linux-x86-64.so.2 (0x00007f4a2501b000)<font></font>
<font></font>
[user@localhost]$ readelf -a /usr/bin/taskset  | grep NEEDED<font></font>
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VDSO ist ein verkn√ºpfter Speicher, der nicht mit Bibliotheken verkn√ºpft ist. Daher fehlt er in der ELF-Datei als erforderliche Bibliothek. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies macht deutlich, dass das Programm /lib64/ld-2.17.so f√ºr die Ausf√ºhrung aller Programme verantwortlich ist, die dies erfordern, und dies sind alles Programme mit dynamisch verkn√ºpften Bibliotheken. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir / usr / bin / Task-Set ausf√ºhren, ist dies genau das gleiche wie wir /lib64/ld-2.17.so mit dem Argument / usr / bin / Task-Set ausf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir kehren zum Problem des Einflusses der Festplatte auf unsere Tests zur√ºck. </font><font style="vertical-align: inherit;">Jetzt wissen wir, dass wir, wenn wir unser Programm aus dem Speicher laden m√∂chten, nicht eine Datei, sondern mehrere kopieren m√ºssen:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp /lib64/libc-2.17.so /mnt/ramdisk/<font></font>
[user@localhost]$ cp /lib64/ld-2.17.so /mnt/ramdisk/<font></font>
[user@localhost]$ cp /usr/bin/taskset /mnt/ramdisk/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir machen das gleiche f√ºr die Zeit, deren Bibliotheksanforderungen genau gleich sind (wir haben bereits ld und libc kopiert).</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp /usr/bin/time /mnt/ramdisk/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr Java sind die Dinge etwas komplizierter, da Java viele verschiedene Bibliotheken ben√∂tigt, die f√ºr eine lange Zeit kopiert werden k√∂nnen. </font><font style="vertical-align: inherit;">Um mein Leben ein wenig zu vereinfachen, kopiere ich das gesamte Verzeichnis von meinem Java OpenJDK auf eine Festplatte im Speicher und erstelle einen Sim-Link. </font><font style="vertical-align: inherit;">Nat√ºrlich bleiben in diesem Fall Festplattenzugriffe erhalten, aber es wird weniger geben.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp -R /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64 /mnt/ramdisk/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Benennen Sie das alte Verzeichnis um und f√ºgen Sie die Endung .default hinzu</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo mv /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64{,.default}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und erstellen Sie einen Symlink:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo ln -s /mnt/ramdisk/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64 /usr/lib/jvm/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wissen bereits, wie eine Bin√§rdatei √ºber das Argument zur Datei /lib64/ld-2.17.so ausgef√ºhrt wird, die tats√§chlich gestartet wird. </font><font style="vertical-align: inherit;">Aber wie kann das Programm /lib64/ld-2.17.so geladene Bibliotheken aus dem von uns angegebenen Verzeichnis laden? </font><font style="vertical-align: inherit;">man ld hilft uns, woraus wir erfahren, dass das ld-Programm die Bibliotheken aus den von uns angegebenen Verzeichnissen l√§dt, wenn Sie die Umgebungsvariable LD_LIBRARY_PATH deklarieren. </font><font style="vertical-align: inherit;">Jetzt haben wir alle Daten, um die Startlinie der Java-Anwendung vorzubereiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir beginnen mehrmals hintereinander und pr√ºfen:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.66user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20344maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.65user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.66user 0.01system 0:10.68elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.65user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+96outputs (0major+5234minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend der Ausf√ºhrung des Programms k√∂nnen wir top ausf√ºhren und sicherstellen, dass das Programm auf dem richtigen CPU-Kern ausgef√ºhrt wird.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ top<font></font>
...<font></font>
%Cpu0  : 19.7 us, 11.7 sy,  0.0 ni, 68.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  9.8 us,  9.1 sy,  0.0 ni, 81.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  : 14.0 us,  9.0 sy,  0.0 ni, 77.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 s<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, sind die Ergebnisse in den meisten F√§llen √§hnlich. </font><font style="vertical-align: inherit;">Leider k√∂nnen wir den Einfluss des Betriebssystems auf den CPU-Kern nicht vollst√§ndig beseitigen, sodass das Ergebnis immer noch von den spezifischen Aufgaben im Linux-Kernel zum Zeitpunkt des Starts abh√§ngt. </font><font style="vertical-align: inherit;">Daher ist es besser, den Median der Werte mehrerer Starts zu verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall sehen wir, dass das Java-Programm 9.000.000.000 mit Parit√§t durch den Rest der Division in 10,65 Sekunden auf einem CPU-Kern verarbeitet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Machen wir den gleichen Test mit unserem zweiten Programm, das dasselbe durch bin√§res UND macht.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.02user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5197minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.01user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20228maxresident)k<font></font>
0inputs+64outputs (0major+5199minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.01user 0.01system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5198minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.02user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5198minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt k√∂nnen wir mit Zuversicht sagen, dass der Vergleich f√ºr die Parit√§t durch bin√§res UND 4,02 Sekunden dauert, was bedeutet, dass er im Vergleich zum √úberpr√ºfen des Restes der Division zumindest bei openjdk Version 1.8.0 2,6-mal schneller funktioniert.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oracle Java gegen Openjdk</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe Java JDK von der Oracle-Website in das Verzeichnis /mnt/ramdisk/jdk-13.0.2 heruntergeladen und entpackt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompilieren:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ /mnt/ramdisk/jdk-13.0.2/bin/javac OddEvenViaAnd.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir starten:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.39user 0.01system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 24260maxresident)k<font></font>
0inputs+64outputs (0major+6979minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.40user 0.01system 0:10.42elapsed 99%CPU (0avgtext+0avgdata 24268maxresident)k<font></font>
0inputs+64outputs (0major+6985minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir kompilieren das zweite Programm:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ /mnt/ramdisk/jdk-13.0.2/bin/javac OddEvenViaMod.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir starten:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.39user 0.01system 0:10.40elapsed 99%CPU (0avgtext+0avgdata 24324maxresident)k<font></font>
0inputs+96outputs (0major+7003minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.40user 0.00system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 24316maxresident)k<font></font>
0inputs+64outputs (0major+6992minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ausf√ºhrungszeit derselben Quellen in oracle jdk ist f√ºr den Rest der Division und das bin√§re AND gleich, was normal aussieht, aber diese Zeit ist ebenso schlecht, was in openjdk f√ºr den Rest der Division gezeigt wurde.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir, dasselbe in Python zu vergleichen. </font><font style="vertical-align: inherit;">Erstens die Option mit dem Rest der Division durch 2:</font></font><br>
<br>
<pre><code class="python hljs">odd=<span class="hljs-number">0</span>
even=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
	<span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<font></font>
		even += <span class="hljs-number">1</span>
	<span class="hljs-keyword">else</span>:<font></font>
		odd += <span class="hljs-number">1</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir starten:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.69user 0.00system 0:11.69elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.67user 0.00system 0:11.67elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.66user 0.00system 0:11.66elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun das gleiche mit bin√§rem UND:</font></font><br>
<br>
<pre><code class="python hljs">odd=<span class="hljs-number">0</span>
even=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
	<span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<font></font>
		even += <span class="hljs-number">1</span>
	<span class="hljs-keyword">else</span>:<font></font>
		odd += <span class="hljs-number">1</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir starten:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.41user 0.00system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 4588maxresident)k<font></font>
0inputs+0outputs (0major+1221minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.43user 0.00system 0:10.43elapsed 99%CPU (0avgtext+0avgdata 4588maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.43user 0.00system 0:10.43elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ergebnisse zeigen, dass AND schneller ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Internet wurde oft geschrieben, dass globale Variablen in Python langsamer sind. </font><font style="vertical-align: inherit;">Ich habe beschlossen, die Ausf√ºhrungszeit des letzten Programms mit AND zu vergleichen und genau dieselbe, aber in eine Funktion eingeschlossen:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
	odd=<span class="hljs-number">0</span>
	even=<span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
		<span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<font></font>
			even += <span class="hljs-number">1</span>
		<span class="hljs-keyword">else</span>:<font></font>
			odd += <span class="hljs-number">1</span>
	<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
	<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd<font></font>
<font></font>
main()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºhren Sie die folgende Funktion aus:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and_func.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
5.08user 0.00system 0:05.08elapsed 99%CPU (0avgtext+0avgdata 4592maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and_func.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
5.08user 0.00system 0:05.09elapsed 99%CPU (0avgtext+0avgdata 4592maxresident)k<font></font>
0inputs+0outputs (0major+1223minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, verarbeitet der gleiche Parit√§tsvergleich in Python √ºber bin√§res UND in einer Funktion 100000000 Zahlen auf einem einzelnen CPU-Kern in ~ 5 Sekunden, der gleiche Vergleich √ºber UND ohne Funktion dauert ~ 10 Sekunden und der Vergleich ohne Funktion durch den Rest der Division dauert ~ 11 Sekunden </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ein Python-Programm in einer Funktion schneller als ohne funktioniert, wurde bereits mehrmals beschrieben und h√§ngt mit dem Umfang der Variablen zusammen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python hat die M√∂glichkeit, ein Programm in interne Funktionen zu zerlegen, die Python bei der Interpretation eines Programms verwendet. </font><font style="vertical-align: inherit;">Mal sehen, welche Funktionen Python f√ºr die Variante mit der Funktion odd_and_func.py verwendet:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]# python<font></font>
Python 2.7.5 (default, Jun 20 2019, 20:27:34)<font></font>
[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux2<font></font>
Type "help", "copyright", "credits" or "license" for more information.<font></font>
&gt;&gt;&gt; def main():<font></font>
...     odd=0<font></font>
...     even=0<font></font>
...     for i in xrange(100000000):<font></font>
...             if i &amp; 1 == 0:<font></font>
...                     even += 1<font></font>
...             else:<font></font>
...                     odd += 1<font></font>
...     print "even", even<font></font>
...     print "odd", odd<font></font>
...<font></font>
&gt;&gt;&gt; import dis<font></font>
&gt;&gt;&gt; dis.dis(main)<font></font>
  2           0 LOAD_CONST               1 (0)<font></font>
              3 STORE_FAST               0 (odd)<font></font>
<font></font>
  3           6 LOAD_CONST               1 (0)<font></font>
              9 STORE_FAST               1 (even)<font></font>
<font></font>
  4          12 SETUP_LOOP              59 (to 74)<font></font>
             15 LOAD_GLOBAL              0 (xrange)<font></font>
             18 LOAD_CONST               2 (100000000)<font></font>
             21 CALL_FUNCTION            1<font></font>
             24 GET_ITER<font></font>
        &gt;&gt;   25 FOR_ITER                45 (to 73)<font></font>
             28 STORE_FAST               2 (i)<font></font>
<font></font>
  5          31 LOAD_FAST                2 (i)<font></font>
             34 LOAD_CONST               3 (1)<font></font>
             37 BINARY_AND<font></font>
             38 LOAD_CONST               1 (0)<font></font>
             41 COMPARE_OP               2 (==)<font></font>
             44 POP_JUMP_IF_FALSE       60<font></font>
<font></font>
  6          47 LOAD_FAST                1 (even)<font></font>
             50 LOAD_CONST               3 (1)<font></font>
             53 INPLACE_ADD<font></font>
             54 STORE_FAST               1 (even)<font></font>
             57 JUMP_ABSOLUTE           25<font></font>
<font></font>
  8     &gt;&gt;   60 LOAD_FAST                0 (odd)<font></font>
             63 LOAD_CONST               3 (1)<font></font>
             66 INPLACE_ADD<font></font>
             67 STORE_FAST               0 (odd)<font></font>
             70 JUMP_ABSOLUTE           25<font></font>
        &gt;&gt;   73 POP_BLOCK<font></font>
<font></font>
  9     &gt;&gt;   74 LOAD_CONST               4 ('even')<font></font>
             77 PRINT_ITEM<font></font>
             78 LOAD_FAST                1 (even)<font></font>
             81 PRINT_ITEM<font></font>
             82 PRINT_NEWLINE<font></font>
<font></font>
 10          83 LOAD_CONST               5 ('odd')<font></font>
             86 PRINT_ITEM<font></font>
             87 LOAD_FAST                0 (odd)<font></font>
             90 PRINT_ITEM<font></font>
             91 PRINT_NEWLINE<font></font>
             92 LOAD_CONST               0 (None)<font></font>
             95 RETURN_VALUE<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und √ºberpr√ºfen Sie dasselbe, ohne die Funktion in unserem Code zu verwenden:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt;&gt;&gt; f=open("odd_and.py","r")<font></font>
&gt;&gt;&gt; l=f.read()<font></font>
&gt;&gt;&gt;<font></font>
&gt;&gt;&gt; l<font></font>
'odd=0\neven=0\nfor i in xrange(100000000):\n\tif i &amp; 1 == 0:\n\t\teven += 1\n\telse:\n\t\todd += 1\nprint "even", even\nprint "odd", odd\n'<font></font>
&gt;&gt;&gt; k=compile(l,'l','exec')<font></font>
&gt;&gt;&gt; k<font></font>
&lt;code object &lt;module&gt; at 0x7f2bdf39ecb0, file "l", line 1&gt;<font></font>
&gt;&gt;&gt; dis.dis(k)<font></font>
  1           0 LOAD_CONST               0 (0)<font></font>
              3 STORE_NAME               0 (odd)<font></font>
<font></font>
  2           6 LOAD_CONST               0 (0)<font></font>
              9 STORE_NAME               1 (even)<font></font>
<font></font>
  3          12 SETUP_LOOP              59 (to 74)<font></font>
             15 LOAD_NAME                2 (xrange)<font></font>
             18 LOAD_CONST               1 (100000000)<font></font>
             21 CALL_FUNCTION            1<font></font>
             24 GET_ITER<font></font>
        &gt;&gt;   25 FOR_ITER                45 (to 73)<font></font>
             28 STORE_NAME               3 (i)<font></font>
<font></font>
  4          31 LOAD_NAME                3 (i)<font></font>
             34 LOAD_CONST               2 (1)<font></font>
             37 BINARY_AND<font></font>
             38 LOAD_CONST               0 (0)<font></font>
             41 COMPARE_OP               2 (==)<font></font>
             44 POP_JUMP_IF_FALSE       60<font></font>
<font></font>
  5          47 LOAD_NAME                1 (even)<font></font>
             50 LOAD_CONST               2 (1)<font></font>
             53 INPLACE_ADD<font></font>
             54 STORE_NAME               1 (even)<font></font>
             57 JUMP_ABSOLUTE           25<font></font>
<font></font>
  7     &gt;&gt;   60 LOAD_NAME                0 (odd)<font></font>
             63 LOAD_CONST               2 (1)<font></font>
             66 INPLACE_ADD<font></font>
             67 STORE_NAME               0 (odd)<font></font>
             70 JUMP_ABSOLUTE           25<font></font>
        &gt;&gt;   73 POP_BLOCK<font></font>
<font></font>
  8     &gt;&gt;   74 LOAD_CONST               3 ('even')<font></font>
             77 PRINT_ITEM<font></font>
             78 LOAD_NAME                1 (even)<font></font>
             81 PRINT_ITEM<font></font>
             82 PRINT_NEWLINE<font></font>
<font></font>
  9          83 LOAD_CONST               4 ('odd')<font></font>
             86 PRINT_ITEM<font></font>
             87 LOAD_NAME                0 (odd)<font></font>
             90 PRINT_ITEM<font></font>
             91 PRINT_NEWLINE<font></font>
             92 LOAD_CONST               5 (None)<font></font>
             95 RETURN_VALUE<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, verwendet Python in der Variante mit der deklarierten Funktion interne Funktionen mit dem FAST-Postfix, z. B. STORE_FAST, LOAD_FAST, und in der Variante ohne Deklaration der Funktion verwendet Python die internen Funktionen STORE_NAME und LOAD_NAME. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel hat wenig praktische Bedeutung und zielt eher darauf ab, einige der Funktionen von Linux und Compilern zu verstehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gut zu allen!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de489194/index.html">Wie OpenShift die Organisationsstruktur einer IT-Organisation ver√§ndert. Die Entwicklung von Organisationsmodellen beim Wechsel zu PaaS</a></li>
<li><a href="../de489196/index.html">Magic Smoke: Mikrocontroller vs. Linearregler</a></li>
<li><a href="../de489198/index.html">Wie Sie sich mit Liquibase nicht in den Fu√ü schie√üen</a></li>
<li><a href="../de489200/index.html">Was Startups f√ºr Y Combinator im Jahr 2020 suchen</a></li>
<li><a href="../de489204/index.html">Ein Einblick in die Zuverl√§ssigkeit von Facebook-Diensten</a></li>
<li><a href="../de489212/index.html">1C-Bitrix verhindert das Abbestellen des Newsletters durch die Verpflichtung zur √úbermittlung ihrer pers√∂nlichen Daten</a></li>
<li><a href="../de489214/index.html">Moderner Ansatz zum Testen der Lokalisierung unter iOS</a></li>
<li><a href="../de489218/index.html">Es ist naiv. Super: Code und Architektur eines einfachen Spiels</a></li>
<li><a href="../de489226/index.html">Methoden zum Optimieren von LINQ-Abfragen in C # .NET</a></li>
<li><a href="../de489228/index.html">Sprachbot in der Bank - die schlechteste UX aller Zeiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>