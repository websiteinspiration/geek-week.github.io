<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⌛️ 🛎️ 👊🏻 Funktionsweise von TCP Reset Attack 👩🏽‍🏫 ™️ 🍮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein TCP-Reset-Angriff wird mit einem einzelnen Datenpaket ausgeführt, das nicht größer als einige Bytes ist. Das durch Angreifer ersetzte und übertrag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Funktionsweise von TCP Reset Attack</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499902/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein TCP-Reset-Angriff wird mit einem einzelnen Datenpaket ausgeführt, das nicht größer als einige Bytes ist. </font><font style="vertical-align: inherit;">Das durch Angreifer ersetzte und übertragene TCP-Segment täuscht die beiden Opfer vor, die TCP-Verbindung zu beenden, und unterbricht die Verbindung zwischen ihnen, was kritisch sein kann.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0e/768/854/d0e7688544d90ce84fd01f7aae77b348.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Angriff hatte Konsequenzen in der realen Welt. </font><font style="vertical-align: inherit;">Befürchtungen hinsichtlich seiner Verwendung wurden durch die Einführung von Änderungen am TCP-Protokoll selbst verursacht. </font><font style="vertical-align: inherit;">Es wird angenommen, dass der Angriff ein wesentlicher Bestandteil der Great Chinese Firewall (Golden Shield) ist, mit der die chinesische Regierung das Internet außerhalb Chinas zensiert. </font><font style="vertical-align: inherit;">Trotz ihres beeindruckenden Hintergrunds erfordert das Verständnis der Mechanismen hinter diesem Angriff nicht unbedingt gründliche Kenntnisse über TCP. </font><font style="vertical-align: inherit;">Natürlich kann Ihnen ein Verständnis der Feinheiten viel über die Funktionen der Implementierung des TCP-Protokolls beibringen, und wie wir gleich sehen werden, können Sie diesen Angriff sogar mit nur einem Laptop gegen sich selbst ausführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beitrag haben wir:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lernen Sie die Grundlagen von TCP</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfahren Sie, wie der Angriff funktioniert.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns mit einem einfachen Python-Skript einen Angriff gegen uns selbst durchführen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir beginnen, die Mechanik des Angriffs zu analysieren, wollen wir zunächst sehen, wie er in der realen Welt verwendet wird.</font></font><a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie wird ein TCP-Reset-Angriff in der Great Firewall verwendet?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Great Firewall (GFW) ist eine Reihe von Systemen und Techniken, mit denen die chinesische Regierung das Internet für interne chinesische Benutzer zensiert. </font><font style="vertical-align: inherit;">GFW blockiert und unterbricht aktiv Verbindungen mit Servern innerhalb und außerhalb des Landes und überwacht passiv den Internetverkehr mit verbotenen Inhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu verhindern, dass Benutzer überhaupt eine Verbindung zu gesperrten Servern herstellen, verwendet GFW Techniken wie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DNS-Verschmutzung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP-Blockierung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(beide kosten separate Artikel). </font><font style="vertical-align: inherit;">Manchmal muss es der GFW-Firewall jedoch gestattet sein, eine Verbindung herzustellen, diese jedoch in der Mitte zu unterbrechen. </font><font style="vertical-align: inherit;">Dies ist beispielsweise erforderlich, wenn Sie eine langsame, ausstehende Analyse der Verbindung durchführen möchten, z. B. ihre Korrelation mit anderen Aktionen. </font><font style="vertical-align: inherit;">Oder es wird verwendet, wenn die Firewall die während des Verbindungsprozesses ausgetauschten Daten analysieren und anhand dieser Informationen entscheiden muss, ob sie fortgesetzt oder blockiert werden sollen. </font><font style="vertical-align: inherit;">Beispielsweise kann der Verkehr zu einer Nachrichtenwebsite zugelassen werden, Videos mit verbotenen Schlüsselwörtern werden jedoch zensiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dafür benötigt GFW Tools, mit denen bereits bestehende Verbindungen unterbrochen werden können. </font><font style="vertical-align: inherit;">Ein solches Tool ist ein TCP-Reset-Angriff.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktioniert ein TCP-Reset-Angriff?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einem TCP-Reset-Angriff unterbricht der Angreifer die Verbindung zwischen den beiden Opfern und sendet eine oder beide gefälschte Nachrichten, in denen er sie auffordert, die Verbindung sofort zu trennen. Diese Nachrichten werden als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP-Rücksetzsegmente bezeichnet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Im normalen Betrieb ohne Beteiligung eines Angreifers senden Computer TCP-Drop-Segmente, wenn sie unerwarteten TCP-Verkehr empfangen und möchten, dass der Absender den Versand beendet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der TCP-Reset-Angriff nutzt diesen Mechanismus böswillig aus und bringt die Opfer dazu, TCP-Verbindungen vorzeitig zu beenden, und sendet ihnen gefälschte Reset-Segmente. Wenn das falsche Rücksetzsegment korrekt ausgeführt wird, nimmt der Empfänger es für das reale Segment und schließt die Verbindung seinerseits, wodurch die weitere Übertragung von Informationen über diese Verbindung unterbrochen wird. Um den Datenaustausch fortzusetzen, versuchen die Opfer möglicherweise, eine neue TCP-Verbindung herzustellen. Der Angreifer hat jedoch möglicherweise die Möglichkeit, diese neue Verbindung zurückzusetzen. Da ein Angreifer Zeit benötigt, um ein gefälschtes Paket zu erstellen und zu senden, ist das Ablegen von Angriffen glücklicherweise nur gegen langfristige Verbindungen wirklich effektiv. Kurzfristige Verbindungen. Wenn Sie beispielsweise kleine Webseiten übertragen, haben Sie normalerweise Zeit, um Ihre Mission zu erfüllenwenn der Angreifer sie zurücksetzen kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Senden gefälschter TCP-Segmente ist in gewissem Sinne ein einfacher Vorgang, da weder TCP noch IP über eigene Methoden zur Überprüfung der Identität des Absenders verfügen. Es gibt eine IP-Erweiterung namens IPSec, die Authentifizierung bietet, aber nicht so weit verbreitet ist. Internetdienstanbieter müssen sich weigern, IP-Pakete zu übertragen, die von einer offensichtlich falschen IP-Adresse stammen. Es wird jedoch behauptet, dass diese Überprüfung sehr mittelmäßig ist. Der Empfänger kann lediglich die Quell-IP-Adresse und den Port innerhalb des Pakets oder Segments zum Nennwert verwenden und, wenn möglich, übergeordnete Protokolle wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/2014/03/27/how-does-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLS verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um den Absender zu identifizieren </font><font style="vertical-align: inherit;">. Da TCP-Dump-Pakete jedoch Teil des TCP-Protokolls selbst sind, können sie mit diesen Protokollen auf hoher Ebene nicht überprüft werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Einfachheit, gefälschte Segmente zu senden, kann das Erstellen eines gefälschten Segments und das Ausführen eines erfolgreichen TCP-Reset-Angriffs immer noch eine entmutigende Aufgabe sein. </font><font style="vertical-align: inherit;">Um zu verstehen, warum dies geschieht, müssen wir die Funktionsweise des TCP-Protokolls verstehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktioniert TCP?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zweck des TCP-Protokolls besteht darin, dem Empfänger eine genaue Kopie des Datenblocks zu senden. </font><font style="vertical-align: inherit;">Wenn mein Server beispielsweise HTML über TCP an Ihren Computer sendet, sollte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der TCP-Stapel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ihres Computers (der Teil seines Betriebssystems, der TCP verarbeitet) mein HTML in genau der Form und Reihenfolge ausgeben, in der mein Server es gesendet hat.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54d/bf5/d64/54dbf5d644d0a3d8ece1cff6cde7b790.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mein HTML wird jedoch nicht so perfekt geordnet über das Internet übertragen. Es ist in viele kleine Fragmente (sogenannte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP-Segmente</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) unterteilt, von denen jedes einzeln über das Internet übertragen und in der vom TCP-Stapel Ihres Computers übertragenen Reihenfolge neu erstellt wird. Diese wiederhergestellte Ausgabe wird als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP-Stream bezeichnet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jedes TCP-Segment wird in einem eigenen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP-Paket</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> übertragen. </font><font style="vertical-align: inherit;">Um den Angriff zu verstehen, müssen wir jedoch keine Details zu IP kennen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/904/175/4689041752b8fa9f66c57c696c4be2ef.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Konvertieren von Segmenten in einen Stream erfordert Sorgfalt, da das Internet unzuverlässig ist. </font><font style="vertical-align: inherit;">TCP-Segmente können verloren gehen. </font><font style="vertical-align: inherit;">Sie können außer Betrieb geraten, zweimal verschickt werden, beschädigt werden und viele andere Missgeschicke erleiden. </font><font style="vertical-align: inherit;">Daher besteht der Zweck des TCP-Protokolls darin, eine zuverlässige Datenübertragung über ein unzuverlässiges Netzwerk sicherzustellen. </font><font style="vertical-align: inherit;">TCP führt diese Aufgabe aus, wobei beide Seiten der Verbindung einen engen Kontakt untereinander aufrechterhalten und ständig Informationen darüber übertragen müssen, welche Datenblöcke empfangen wurden. </font><font style="vertical-align: inherit;">Auf diese Weise können Absender nachvollziehen, welche Daten der Empfänger noch nicht empfangen hat, und die verlorenen Daten erneut übertragen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu verstehen, wie der Prozess funktioniert, müssen wir verstehen, wie Sender und Empfänger </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP-Sequenznummern verwenden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zum Markieren und Verfolgen von Daten, die über TCP übertragen werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP-Sequenznummern</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedem über eine TCP-Verbindung übertragenen Byte wird vom Absender eine Sequenznummer zugewiesen. </font><font style="vertical-align: inherit;">Empfangsmaschinen verwenden Seriennummern, um die empfangenen Daten in die ursprüngliche Reihenfolge zu verschieben.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/402/fbc/144/402fbc144a2864f986debfb2ea9b6412.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn zwei Computer eine TCP-Verbindung aushandeln, sendet jeder Computer eine andere zufällige </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startsequenznummer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies ist die Sequenznummer, die das Gerät dem ersten gesendeten Byte zuweist. Jedem nachfolgenden Byte wird die Sequenznummer des vorherigen Bytes plus 1 zugewiesen. TCP-Segmente enthalten </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP-Header</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die Metadaten sind, die an den Anfang des Segments angehängt sind. Die Sequenznummer des ersten Bytes im Segmentkörper ist im TCP-Header dieses Segments enthalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist zu beachten, dass TCP-Verbindungen bidirektional sind, dh Daten können in beide Richtungen übertragen werden, und jeder Computer in einer TCP-Verbindung fungiert sowohl als Sender als auch als Empfänger. Aus diesem Grund muss jede Maschine ihren eigenen unabhängigen Satz von Sequenznummern zuweisen und verarbeiten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bestätigung des Datenempfangs</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Computer ein TCP-Segment empfängt, teilt er dem Absender des Segments mit, dass es empfangen wurde. </font><font style="vertical-align: inherit;">Der Empfänger sendet dazu ein Segment </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(kurz für "Bestätigen"), das die Sequenznummer des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nächsten</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bytes enthält, das er vom Absender erwartet. </font><font style="vertical-align: inherit;">Der Absender verwendet diese Informationen, um zu verstehen, dass der Empfänger alle anderen Bytes bis zu dieser Nummer erfolgreich empfangen hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Segment wird </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch das Vorhandensein eines Flags </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und der entsprechenden Bestätigungsnummer im TCP-Header des Segments </font><font style="vertical-align: inherit;">angezeigt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das TCP-Protokoll enthält nur 6 Flags, einschließlich (wie wir in Kürze sehen werden) eines Flags </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(kurz für "Reset" - "Reset"), das das Reset-Segment angibt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/242/452/e35/242452e35d360faf406441ab93f8c383.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis: TCP ermöglicht auch die Verwendung </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selektiver ACKs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die gesendet werden, wenn der Empfänger einige, aber nicht alle Segmente im Zahlenbereich empfangen hat. Beispiel: "Ich habe die Bytes 1000-3000 und 4000-5000 empfangen, aber nicht 3001-3999." Der Einfachheit halber werde ich in unserer Diskussion über TCP-Reset-Angriffe keine selektiven ACKs berücksichtigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Absender Daten sendet, aber nicht empfängt</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für sie während eines bestimmten Zeitintervalls geht er davon aus, dass die Daten verloren gegangen sind, und sendet sie erneut, wobei sie dieselben Seriennummern erhalten. Dies bedeutet, dass wenn der Empfänger dieselben Bytes zweimal akzeptiert, er trivial Folgenummern verwendet, um Duplikate zu entfernen, ohne den Stream zu unterbrechen. Der Empfänger kann doppelte Daten akzeptieren, weil das ursprüngliche Segment später empfangen wurde, nachdem es erneut gesendet wurde, oder weil das ursprüngliche Segment erfolgreich empfangen wurde, das entsprechende </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jedoch auf dem Weg zum Absender verloren ging.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6d/22f/a09/e6d22fa098d7375dab30e6c8341ff358.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während solche doppelten Daten selten genug sind, führt die dadurch verursachte übermäßige Verschwendung von Ressourcen nicht zu Problemen. </font><font style="vertical-align: inherit;">Wenn alle Daten früher oder später den Empfänger erreichen und die entsprechenden Daten </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Absender erreichen, erledigt die TCP-Verbindung ihre Aufgabe.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auswahl einer Seriennummer für ein gefälschtes Segment</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Erstellen eines falschen Segments muss der </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angreifer ihm eine Seriennummer geben. </font><font style="vertical-align: inherit;">Die Empfänger sind sehr froh, dass Sie Segmente mit inkonsistenten Seriennummern akzeptieren und unabhängig voneinander in der richtigen Reihenfolge verbinden müssen. </font><font style="vertical-align: inherit;">Ihre Fähigkeiten sind jedoch begrenzt. </font><font style="vertical-align: inherit;">Wenn der Empfänger ein Segment mit einer Sequenznummer erhält, die "zu" nicht in der richtigen Reihenfolge ist, verwirft er ein solches Segment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für einen erfolgreichen TCP-Reset-Angriff ist daher eine plausible Sequenznummer erforderlich. </font><font style="vertical-align: inherit;">Aber was ist eine solche Zahl? </font><font style="vertical-align: inherit;">Für die meisten Segmente (obwohl, wie wir später sehen werden, nicht für </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) wird die Antwort durch die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Größe des TCP-Fensters bestimmt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP-Fenstergröße</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich einen alten Computer aus den frühen neunziger Jahren vor, der an ein modernes Gigabit-Glasfasernetz angeschlossen ist. Ein ultraschnelles Netzwerk kann Daten mit einer erstaunlichen Geschwindigkeit auf diesen älteren Computer übertragen, schneller als das Gerät sie verarbeiten kann. Dies wird uns stören, da das TCP-Segment erst dann als empfangen betrachtet werden kann, wenn der Empfänger es verarbeiten kann.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/299/76a/8a529976a3acd7a28babb9e8220bcb7d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Computer verfügen über einen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP-Puffer,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in dem neu ankommende Daten auf ihre Verarbeitung warten, während der Computer an Daten arbeitet, die vor ihm eintreffen. Dieser Puffer hat jedoch eine begrenzte Größe. Wenn der Empfänger die vom Netzwerk an ihn übertragene Datenmenge nicht bewältigen kann, läuft der Puffer über. Wenn der Puffer voll ist, hat der Empfänger keine andere Wahl, als die redundanten Daten zu entfernen. Der Empfänger sendet keine </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verworfenen Daten, daher muss der Absender sie erneut senden, wenn im Puffer des Empfängers freier Speicherplatz vorhanden ist. Es spielt keine Rolle, wie schnell das Netzwerk Daten übertragen kann, wenn der Empfänger keine Zeit hat, mit ihnen umzugehen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich einen übermäßig eifrigen Freund vor, der Ihnen einen ganzen Strom von Briefen schneller an Ihre Post sendet, als Sie sie lesen können. Es gibt einen bestimmten Pufferraum in Ihrem Postfach, aber nachdem es voll ist, fallen alle nicht platzierten Buchstaben zu Boden, wo Füchse und andere Kreaturen sie fressen. Ein Freund muss die Briefe, die er gegessen hat, erneut senden, aber jetzt haben Sie Zeit, seine vorherigen Nachrichten zu erhalten. Das Senden zu vieler Briefe oder Datenmengen, die der Empfänger nicht verarbeiten kann, ist eine Verschwendung von Energie und Übertragungskanal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Zu viel" - wie viele Daten sind das? Wie versteht der Absender, wann weitere Daten gesendet werden sollen und wann sich das Warten lohnt? Hier bietet sich die </font><em><font style="vertical-align: inherit;">Größe</font></em><font style="vertical-align: inherit;"> des </font><em><font style="vertical-align: inherit;">TCP-Fensters</font></em><font style="vertical-align: inherit;"> an.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Größe des Empfängerfensters gibt die maximale Anzahl nicht bestätigter Bytes an, die der Absender jederzeit an ihn übertragen kann. Angenommen, der Empfänger meldet, dass seine Fenstergröße 100.000 beträgt (wir werden bald herausfinden, wie er diesen Wert übergibt), sodass der Absender 100.000 Bytes sendet. Angenommen, bis der Sender ein hunderttausendstes Byte gesendet hat, hat der Empfänger die Segmente </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für die ersten 10.000 dieser Bytes </font><font style="vertical-align: inherit;">gesendet </font><font style="vertical-align: inherit;">. Dies bedeutet, dass 90.000 Bytes noch nicht bestätigt wurden. Da die Fenstergröße 100.000 beträgt, kann der Absender weitere 10.000 Bytes übertragen, bevor er auf neue warten muss </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn nach dem Senden dieser 10.000 zusätzlichen Bytes weiter</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es nicht empfangen wurde, stößt der Absender auf sein Limit von 100.000 nicht bestätigten Bytes. Folglich muss der Absender warten und das Senden von Daten beenden (mit Ausnahme der erneuten Übertragung von Daten, die er als verloren betrachtet), bis er neue Daten erhält </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afa/5df/46f/afa5df46f3304b04abbf629ca6ef34a0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede Seite der TCP-Verbindung benachrichtigt die andere Seite über die Größe ihres Fensters während des Handshake-Vorgangs, der beim Öffnen der Verbindung ausgeführt wird. Darüber hinaus können Fenstergrößen während des Verbindungsvorgangs dynamisch geändert werden. Ein Computer mit einem großen TCP-Puffer kann eine große Fenstergröße ankündigen, um den Durchsatz zu maximieren. Auf diese Weise kann die mit ihr kommunizierende Maschine kontinuierlich Daten über eine TCP-Verbindung übertragen, ohne anzuhalten oder auf eine Bestätigung zu warten. Ein Computer mit einem kleinen TCP-Puffer kann gezwungen sein, eine kleine Fenstergröße zu melden. Manchmal füllen Absender das Fenster vollständig aus und müssen warten, bis einige der Segmente bestätigt sind. Die Bandbreite leidet darunter, aber es ist erforderlich, dass die TCP-Puffer nicht überlaufen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e3/d5e/5e0/8e3d5e5e0e4b574c6896e6ef7adc94bc.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Größe des TCP-Fensters ist eine strikte Begrenzung der Menge der übertragenen unbestätigten Daten. </font><font style="vertical-align: inherit;">Wir können es verwenden, um die maximal mögliche Sequenznummer (die ich in der folgenden Gleichung als bezeichnet habe </font></font><code>max_seq_no</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">zu berechnen </font><font style="vertical-align: inherit;">, die der Absender zum aktuellen Zeitpunkt senden kann:</font></font><br>
<br>
<blockquote><code>max_seq_no = max_acked_seq_no + window_size</code></blockquote><br>
<code>max_acked_seq_no</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist die maximale Sequenznummer, für die der Empfänger gesendet hat </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist die maximale Sequenznummer, von der der Absender weiß, dass der Empfänger sie genau erhalten hat. </font><font style="vertical-align: inherit;">Da der Absender nur </font></font><code>window_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unbestätigte Bytes senden kann, kann er maximal eine Sequenznummer senden </font></font><code>max_acked_seq_no + window_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus diesem Grund gibt die TCP-Spezifikation an, dass der Empfänger alle empfangenen Daten ignorieren soll, deren Seriennummern außerhalb des gültigen Fensters liegen. Wenn der Empfänger beispielsweise alle Bytes bis zu 15.000 bestätigt hat und seine Fenstergröße 30.000 beträgt, erhält er alle Daten mit einer Seriennummer im Bereich von 15.000 bis (15.000 + 30.000 = 45.000). Darüber hinaus ignoriert der Empfänger Daten mit Seriennummern außerhalb dieses Intervalls vollständig. Wenn das Segment Daten enthält, von denen sich einige innerhalb dieses Fensters und einige außerhalb befinden, werden die Daten innerhalb des Fensters akzeptiert und bestätigt, aber die Daten außerhalb des Fensters werden verworfen. Beachten Sie, dass wir die Möglichkeit der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selektiven,</font></font><code>ACK</code></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die zu Beginn des Beitrags kurz angesprochen wurden </font><font style="vertical-align: inherit;">, immer noch ignorieren </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei den meisten TCP-Segmenten gibt diese Regel ein Intervall akzeptabler Sequenznummern an. </font><font style="vertical-align: inherit;">Wie bereits erwähnt, sind die </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschränkungen </font><font style="vertical-align: inherit;">für Segmente </font><font style="vertical-align: inherit;">jedoch noch strenger als die Beschränkungen für gewöhnliche Datenübertragungssegmente. </font><font style="vertical-align: inherit;">Wie wir gleich sehen werden, wurde dies durchgeführt, um die Durchführung einer Variante eines TCP-Reset- </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angriffs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu erschweren, der als </font><em><font style="vertical-align: inherit;">"blinder TCP-Reset-Angriff" bezeichnet wird</font></em><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akzeptable Sequenznummern für RST-Segmente</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reguläre Segmente werden akzeptiert, wenn ihre Sequenznummer zwischen der nächsten erwarteten Sequenznummer und dieser Nummer plus der Fenstergröße liegt. Pakete </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden jedoch nur empfangen, wenn ihre Sequenznummer </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genau der</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nächsten erwarteten Sequenznummer entspricht. Kehren wir zum vorherigen Beispiel zurück, in dem der Empfänger die Bestätigungsnummer 15.000 gesendet hat. Damit das Paket </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empfangen werden kann, muss seine Sequenznummer genau 15.000 sein. Wenn der Empfänger ein Segment </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einer Sequenznummer ungleich 15.000 </font><font style="vertical-align: inherit;">empfängt </font><font style="vertical-align: inherit;">, akzeptiert er es nicht.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/596/b55/1d9596b55bb0ac4946ed16ff6b878dff.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Sequenznummer außerhalb des Intervalls liegt, ignoriert der Empfänger sie vollständig. </font><font style="vertical-align: inherit;">Befindet es sich jedoch innerhalb des Fensters der erwarteten Sequenznummern, sendet der Empfänger eine "Herausforderung </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" ("ACK-Anruf"). </font><font style="vertical-align: inherit;">Dies ist ein Segment, das dem Absender mitteilt, dass das Segment </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine ungültige Sequenznummer hat. </font><font style="vertical-align: inherit;">Er teilt dem Absender auch die Sequenznummer mit, die der Empfänger erwartet. </font><font style="vertical-align: inherit;">Der Absender kann diese Informationen aus dem </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anruf verwenden, um seine </font><font style="vertical-align: inherit;">Informationen </font><font style="vertical-align: inherit;">neu zu erstellen und erneut zu senden </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bis 2010 hat TCP diese zusätzlichen Segmentbeschränkungen nicht eingeführt </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Segmente wurden </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach den gleichen Regeln wie alle anderen angenommen oder abgelehnt. </font><font style="vertical-align: inherit;">Dies vereinfachte jedoch auch die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blind-Blind-TCP-Reset-Angriffe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blinde TCP-Angriffe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Angreifer den zwischen seinen Opfern ausgetauschten Datenverkehr abfangen kann, kann er die Serien- und Bestätigungsnummern der TCP-Pakete der Opfer lesen. Er kann diese Informationen verwenden, um auszuwählen, welche Seriennummern er seinen gefälschten Segmenten geben soll </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn der Angreifer jedoch den Verkehr der Opfer nicht abfangen kann, weiß er nicht, welche Sequenznummern er einfügen soll. Er kann jedoch immer noch eine beliebige Anzahl von Segmenten </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einer beliebigen Anzahl unterschiedlicher Seriennummern übertragen, in der Hoffnung, dass sich eines davon als richtig herausstellt. Ein solcher Angriff wird als blinder TCP-Reset-Angriff bezeichnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erwähnt, musste der Angreifer in der ersten Version des TCP-Protokolls nur die Seriennummer abrufen</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">innerhalb des TCP-Fensters des Empfängers. </font><font style="vertical-align: inherit;">Ein Artikel mit dem Titel „Slipping in the Window“ zeigte, dass dies die blinden Angriffe zu einfach machte, da ein Angreifer für einen fast garantierten Erfolg nur Zehntausende von Segmenten senden musste. </font><font style="vertical-align: inherit;">Um dem entgegenzuwirken, wurde die Regel, die den Empfänger zur Annahme des Segments zwang, </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch das oben beschriebene strengere Kriterium ersetzt. </font><font style="vertical-align: inherit;">Dank der neuen Regeln für die Durchführung von TCP-Reset-Angriffen müssen Millionen von Segmenten blind gesendet werden, was sie praktisch nicht realisierbar macht. </font><font style="vertical-align: inherit;">Siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC-5963 für</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Details </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Führen Sie einen TCP-Reset-Angriff gegen uns selbst durch</font></font></h2><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Ich habe diesen Prozess unter OSX getestet, aber einige Kommentare erhalten, dass er unter Linux nicht ordnungsgemäß funktioniert. </font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt wissen wir alles über die Ausführung eines TCP-Reset-Angriffs. </font><font style="vertical-align: inherit;">Der Angreifer muss:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verkehrswacht - </font><font style="vertical-align: inherit;">Netzwerk ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Schnüffeln“</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it) zwischen zwei Opfer</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schnüffeln Sie am TCP-Segment mit aktiviertem Flag </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und lesen Sie die bestätigte Nummer</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie ein falsches TCP-Segment mit aktiviertem Flag </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und einer Sequenznummer, die der bestätigten Nummer des abgefangenen Segments entspricht (beachten Sie, dass dies eine langsame Übertragung impliziert, da sonst die ausgewählte Sequenznummer schnell veraltet ist.) Um die Erfolgschancen zu erhöhen, können Sie mehrere Segmente </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem großen Intervall von Sequenznummern übertragen .)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Senden Sie gefälschte Segmente an ein oder beide Opfer, in der Hoffnung, dass dadurch die TCP-Verbindung unterbrochen wird</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns zum Üben einen TCP-Angriff auf uns selbst auf demselben Computer durchführen und über uns selbst kommunizieren </font></font><code>localhost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dafür brauchen wir:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurieren Sie die TCP-Verbindung zwischen zwei Terminalfenstern</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreiben Sie ein Angriffsprogramm, das sich mit Verkehrsschnüffeln befasst</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie das Programm so, dass es gefälschte Segmente erzeugt und sendet </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lass uns anfangen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Herstellen einer TCP-Verbindung zwischen zwei Terminalfenstern</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden die TCP-Verbindung mit dem Tool konfigurieren </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><code>netcat</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das standardmäßig auf vielen Betriebssystemen verfügbar ist. </font><font style="vertical-align: inherit;">Jeder andere </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP-Client reicht aus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Im ersten Terminalfenster führen wir den folgenden Befehl aus:</font></font><br>
<br>
<blockquote><code>nc -nvl 8000</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Befehl startet einen TCP-Server, der einen Port auf unserem lokalen Computer überwacht </font></font><code>8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Führen Sie im zweiten Terminalfenster den folgenden Befehl aus:</font></font><br>
<br>
<blockquote><code>nc 127.0.0.1 8000</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Befehl versucht, über die IP-Adresse des </font></font><code>127.0.0.1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ports </font><font style="vertical-align: inherit;">eine TCP-Verbindung zum Computer herzustellen </font></font><code>8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nun sollte zwischen den beiden Fenstern des Terminals eine TCP-Verbindung hergestellt werden. </font><font style="vertical-align: inherit;">Versuchen Sie, etwas in ein Fenster einzugeben - die Daten müssen über die TCP-Verbindung übertragen werden und in einem anderen Fenster angezeigt werden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/911/301/786/911301786c4f56287f80d38f67ef73f6.gif"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Verkehrsschnüffeln</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden ein Angriffsprogramm schreiben, das mithilfe der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><code>scapy</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beliebten Python-Netzwerkbibliothek </font><font style="vertical-align: inherit;">Traffic-Sniffing durchführt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dieses Programm verwendet scapy, um Daten zu lesen, die zwischen zwei Fenstern des Terminals übertragen wurden, obwohl sie nicht Teil der Verbindung sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Programmcode wird in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meinem Repository auf GitHub veröffentlicht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Das Programm überwacht den Verbindungsverkehr und zeigt ihn auf dem Terminal an. </font><font style="vertical-align: inherit;">Der Hauptkern des Codes ist der Methodenaufruf </font></font><code>sniff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus der Bibliothek </font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Ende der Datei:</font></font><br>
<br>
<pre><code class="python hljs">t = sniff(<font></font>
        iface=<span class="hljs-string">'lo0'</span>,<font></font>
        lfilter=is_packet_tcp_client_to_server(localhost_ip, localhost_server_port, localhost_ip),<font></font>
        prn=log_packet,<font></font>
        count=<span class="hljs-number">50</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code weist uns </font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an, Pakete auf der Schnittstelle zu schnüffeln </font></font><code>lo0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und Details aller Pakete als Teil unserer TCP-Verbindung zu erfassen. </font><font style="vertical-align: inherit;">Der Aufruf hat folgende Parameter:</font></font><br>
<br>
<ul>
<li><code>iface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Befehle </font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Abhören der Netzwerkschnittstelle </font></font><code>lo0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder des lokalen Hosts</font></font></li>
<li><code>lfilter</code> —  ,  <code>scapy</code>   ,      IP- localhost   .   ,        ,   <code>lo0</code>.     ,     .</li>
<li><code>prn</code> — ,  <code>scapy</code>     ,    <code>lfilter</code>.          .       ,      <code>RST</code>.</li>
<li><code>count</code> —  ,  <code>scapy</code>    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dieses Programm zu testen, konfigurieren Sie die TCP-Verbindung ab Schritt 1. Klonen Sie mein GitHub-Repository, befolgen Sie die Konfigurationsanweisungen und führen Sie das Programm im dritten Fenster des Terminals aus. </font><font style="vertical-align: inherit;">Geben Sie Text in eines der Terminals der TCP-Verbindung ein. </font><font style="vertical-align: inherit;">Sie sollten sehen, dass das Programm beginnt, Informationen über die Verbindungssegmente aufzuzeichnen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Senden gefälschter Pakete </font></font><code>RST</code></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eine Verbindung hergestellt, und das Programm kann alle durchlaufenden TCP-Segmente abhören. Das einzige, was uns noch bleibt, ist, das Programm so zu ändern, dass es einen TCP-Reset-Angriff durch Übertragen gefälschter Segmente ausführt </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Zu diesem Zweck ändern wir die Funktion </font></font><code>prn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(siehe Liste der Parameter oben), die </font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für Pakete </font><font style="vertical-align: inherit;">aufgerufen wird </font><font style="vertical-align: inherit;">, die die Anforderungen der Funktion erfüllen </font></font><code>lfilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In der modifizierten Version der Funktion wird das entsprechende Paket nicht einfach repariert, sondern untersucht, die erforderlichen Parameter extrahiert und mit diesen Parametern das Segment erstellt und gesendet </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben ein Segment ab </font></font><code>(src_ip, src_port)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k </font><font style="vertical-align: inherit;">abgefangen </font></font><code>(dst_ip, dst_port)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Er hat eine Flagge gesetzt </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Bestätigungsnummer ist 100.000. Um ein Segment herzustellen und zu versenden, haben wir:</font></font><br>
<br>
<ul>
<li>  IP-   ,    .  ,         .          ,  .</li>
<li>  <code>RST</code> ,     ,    <code>RST</code></li>
<li>        ,      ,    </li>
<li>  <code>send</code>  <code>scapy</code>     —   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um unser vorheriges Programm nach Bedarf zu ändern, </font><font style="vertical-align: inherit;">kommentieren Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese Zeile aus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und kommentieren Sie die Zeile darüber aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt sind wir bereit für einen umfassenden Angriff. </font><font style="vertical-align: inherit;">Konfigurieren Sie die TCP-Verbindung gemäß Schritt 1. Führen Sie das Angriffsprogramm ab Schritt 2 im dritten Fenster des Terminals aus. </font><font style="vertical-align: inherit;">Geben Sie dann einen Text in eines der Terminals der TCP-Verbindung ein. </font><font style="vertical-align: inherit;">In dem Terminal, in dem Sie den Text eingegeben haben, wird die TCP-Verbindung plötzlich und auf mysteriöse Weise unterbrochen. </font><font style="vertical-align: inherit;">Der Angriff ist beendet!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad9/2a2/b18/ad92a2b18c1533c47d88ab4ff10dedf7.gif"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Arbeit</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Experimentieren Sie weiter mit dem Angriffstool. </font><font style="vertical-align: inherit;">Verfolgen Sie, was passiert, wenn Sie 1 zur Sequenznummer des Pakets addieren oder von dieser subtrahieren </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stellen Sie sicher, dass es </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genau</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dem Wert des </font></font><code>ack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abgefangenen Pakets entspricht.</font></font></li>
<li> Wireshark       <code>lo0</code>    .            TCP-,       <code>RST</code>.   <code>ip.src == 127.0.0.1 &amp;&amp; ip.dst == 127.0.0.1 &amp;&amp; tcp.port == 8000</code>       .</li>
<li>  ,      .           <code>RST</code>,       <code>RST</code>         ,      .   ,      <code>RST</code>,       .</li>
</ol><br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der TCP-Reset-Angriff ist gleichzeitig tiefgreifend und einfach. </font><font style="vertical-align: inherit;">Viel Glück bei Ihren Experimenten und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lassen Sie mich wissen,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn Sie Fragen oder Kommentare haben.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499884/index.html">11 Dinge, die ich über CustDev verstanden habe</a></li>
<li><a href="../de499894/index.html">Haus der singenden Dinge. Chipolo ONE Smart Keychain Tracker Bewertung</a></li>
<li><a href="../de499896/index.html">Wir gehen korrekt zum entfernten Standort: Wie organisieren wir unsere Arbeit und die Arbeit des Projekts in Telegram?</a></li>
<li><a href="../de499898/index.html">Wie IT-Mitarbeiter mit Quarantäne umgehen, was sie in Selbstisolation tun und was sie verwenden</a></li>
<li><a href="../de499900/index.html">Produktanalyse mitap: kostenlos, kontaktlos, online</a></li>
<li><a href="../de499904/index.html">"Ich habe Angst". Was zu tun ist?</a></li>
<li><a href="../de499906/index.html">Beispiele für die Verwendung von AR in der Spielwarenindustrie</a></li>
<li><a href="../de499910/index.html">Ausgewogenheit bei der Entscheidungsfindung. Gabel "zufällige Erfahrung"</a></li>
<li><a href="../de499920/index.html">SSH kleine Tricks</a></li>
<li><a href="../de499922/index.html">Schließlich beschäftigen wir uns mit der Modbus-Baudrate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>