<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏸️ ✌🏼 🎂 Sparen Sie viel Geld bei großen Mengen in PostgreSQL 🧑🏿‍🤝‍🧑🏾 〽️ 🛳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie das Thema der Aufzeichnung großer Datenströme fortsetzen, das im vorherigen Artikel zur Partitionierung angesprochen wurde , betrachten wir h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sparen Sie viel Geld bei großen Mengen in PostgreSQL</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/498292/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie das Thema der Aufzeichnung großer Datenströme fortsetzen, das im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Artikel zur Partitionierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angesprochen wurde </font><font style="vertical-align: inherit;">, betrachten wir hier die Möglichkeiten, wie Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in PostgreSQL </font><b><font style="vertical-align: inherit;">gespeicherte "physische" Größe reduzieren</font></b><font style="vertical-align: inherit;"> können </font><font style="vertical-align: inherit;">, und deren Auswirkungen auf die Serverleistung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es geht um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TOAST-Einstellungen und Datenausrichtung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">"Im Durchschnitt" sparen diese Methoden nicht zu viele Ressourcen, ohne jedoch den Anwendungscode zu ändern.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/cj/c-/lx/cjc-lxht8brbyy9xif_sicdwk70.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Erfahrung hat sich in dieser Hinsicht jedoch als sehr produktiv erwiesen, da das Repository für fast jede Überwachung naturgemäß </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Bezug auf aufgezeichnete Daten </font><b><font style="vertical-align: inherit;">nur angehängt wird</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Und wenn Sie daran interessiert sind, wie Sie einer Datenbank beibringen können, auf eine Festplatte zu schreiben, anstatt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200 MB / s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> halb so viel - ich bitte um einen Schnitt.</font></font><br>
<a name="habracut"></a><br>
<font color="#4060a0"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kleine Geheimnisse von Big Data</font></font></h2></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entsprechend dem Profil </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unseres Dienstes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erhält er regelmäßig </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textpakete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus den Protokollen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und da </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der VLSI-Komplex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dessen Datenbanken wir überwachen, ein Mehrkomponentenprodukt mit komplexen Datenstrukturen ist, werden die Abfragen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zur Erzielung maximaler Leistung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von solchen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Multi-Volumes“ mit komplexer algorithmischer Logik erhalten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Das Volumen jeder einzelnen Instanz der Anforderung oder des daraus resultierenden Ausführungsplans im Protokoll, das zu uns kommt, ist also ziemlich "durchschnittlich". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns die Struktur einer der Tabellen an, in die wir die "Rohdaten" schreiben - das heißt, hier ist der Originaltext aus dem Protokolleintrag:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> rawdata_orig(<font></font>
  pack <span class="hljs-comment">-- PK</span>
    <span class="hljs-keyword">uuid</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
, recno <span class="hljs-comment">-- PK</span>
    <span class="hljs-built_in">smallint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
, dt <span class="hljs-comment">--  </span>
    <span class="hljs-built_in">date</span>
, <span class="hljs-keyword">data</span> <span class="hljs-comment">--  </span>
    <span class="hljs-built_in">text</span>
, PRIMARY <span class="hljs-keyword">KEY</span>(pack, recno)<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solch eine typische Platte (natürlich bereits unterteilt, daher handelt es sich um eine Abschnittsvorlage), bei der der Text am wichtigsten ist. Manchmal ziemlich voluminös. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie daran, dass die „physische“ Größe eines Datensatzes in PG nicht mehr als eine Datenseite belegen kann, die „logische“ Größe jedoch eine ganz andere Sache ist. Um einen Volumenwert (varchar / text / bytea) in das Feld zu schreiben, wird die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TOAST-Technologie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet </font><font style="vertical-align: inherit;">:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQL verwendet eine feste Seitengröße (normalerweise 8 KB) und erlaubt nicht, dass Tupel mehrere Seiten umfassen. </font><font style="vertical-align: inherit;">Daher ist es unmöglich, sehr große Feldwerte direkt zu speichern. </font><font style="vertical-align: inherit;">Um diese Einschränkung zu überwinden, werden große Feldwerte komprimiert und / oder in mehrere physikalische Zeilen aufgeteilt. </font><font style="vertical-align: inherit;">Dies geschieht vom Benutzer unbemerkt und wirkt sich geringfügig auf den größten Teil des Servercodes aus. </font><font style="vertical-align: inherit;">Diese Methode ist als TOAST bekannt ...</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich wird für jede Tabelle mit "potenziell großen" Feldern automatisch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine gepaarte Tabelle mit dem "Slicing"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedes "großen" Datensatzes in 2-KB-Segmenten erstellt:</font></font><br>
<br>
<pre><code class="sql hljs">TOAST(<font></font>
  chunk_id<font></font>
    integer<font></font>
, chunk_seq<font></font>
    integer<font></font>
, chunk_data<font></font>
    bytea<font></font>
, PRIMARY KEY(chunk_id, chunk_seq)<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, wenn wir eine Zeile mit einem "großen" Wert schreiben müssen </font></font><code>data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird der reale Datensatz </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht nur in der Haupttabelle und ihrer PK, sondern auch in TOAST und seiner PK auftreten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reduzieren Sie den TOAST-Effekt</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber die meisten Datensätze hier sind immer noch nicht so groß, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie sollten in 8 KB passen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - wie würden Sie das sparen? .. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier </font><b><font style="vertical-align: inherit;">hilft</font></b><font style="vertical-align: inherit;"> uns </font><font style="vertical-align: inherit;">das Attribut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>STORAGE</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Tabellenspalte:</font></font><br>
<blockquote><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXTENDED</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ermöglicht sowohl Komprimierung als auch separate Speicherung. </font><font style="vertical-align: inherit;">Dies ist die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardoption</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für die meisten TOAST-kompatiblen Datentypen. </font><font style="vertical-align: inherit;">Zuerst wird versucht, eine Komprimierung durchzuführen, dann wird sie außerhalb der Tabelle gespeichert, wenn die Zeile noch zu groß ist.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MAIN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ermöglicht die Komprimierung, jedoch keine separate Speicherung. </font><font style="vertical-align: inherit;">(Tatsächlich wird für solche Spalten jedoch </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> separate Speicherung durchgeführt, jedoch nur </font><b><font style="vertical-align: inherit;">als letztes Mittel</font></b><font style="vertical-align: inherit;"> , wenn es keine andere Möglichkeit gibt, die Zeile so zu verkleinern, dass sie auf die Seite passt.)</font></font></li>
</ul></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genau das brauchen wir für den Text - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drücken Sie ihn so weit wie möglich zusammen und setzen Sie ihn in TOAST, auch wenn er überhaupt nicht passt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie können dies direkt "on the fly" mit einem Befehl tun:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> rawdata_orig <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">STORAGE</span> <span class="hljs-keyword">MAIN</span>;</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie man den Effekt bewertet</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da sich der Datenfluss jeden Tag ändert, können wir keine absoluten Zahlen vergleichen. Relativ gesehen ist es jedoch </font><font style="vertical-align: inherit;">umso besser </font><font style="vertical-align: inherit;">, je </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kleiner der Anteil ist, den</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir in TOAST aufgezeichnet haben. </font><font style="vertical-align: inherit;">Es besteht jedoch die Gefahr, dass der Index umso „breiter“ wird, je mehr wir das „physische“ Volumen jedes einzelnen Datensatzes haben, da wir mehr Datenseiten abdecken müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abschnitt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vor Änderungen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<pre><code class="plaintext hljs">heap  = 37GB (39%)<font></font>
TOAST = 54GB (57%)<font></font>
PK    =  4GB ( 4%)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abschnitt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach Änderungen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<pre><code class="plaintext hljs">heap  = 37GB (67%)<font></font>
TOAST = 16GB (29%)<font></font>
PK    =  2GB ( 4%)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich haben wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 Mal seltener mit dem Schreiben in TOAST begonnen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wodurch nicht nur die Festplatte, sondern auch die CPU entladen wurde:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jc/te/dr/jctedr4gcninasuw54qer9qu_8u.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/bp/lj/wr/bpljwrysoy42rtnu3ds0btue7ka.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich stelle fest, dass wir die Festplatte auch weniger "lesen", nicht nur "schreiben" - denn wenn Sie einen Datensatz in eine Tabelle einfügen, müssen Sie auch einen Teil des Baums jedes der Indizes "subtrahieren", um seine zukünftige Position in ihnen zu bestimmen.</font></font><br>
<br>
<font color="#4060a0"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wer auf PostgreSQL 11 lebt gut</font></font></h2></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Upgrade auf PG11 haben wir beschlossen, TOAST weiter zu optimieren, und festgestellt, dass ab dieser Version der Parameter für die Konfiguration verfügbar wurde </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>toast_tuple_target</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der TOAST-Verarbeitungscode wird nur ausgelöst, wenn der in der Tabelle zu speichernde Zeilenwert größer als die Bytes TOAST_TUPLE_THRESHOLD ist (normalerweise 2 KB). </font><font style="vertical-align: inherit;">TOAST-Code komprimiert und / oder verschiebt Feldwerte aus der Tabelle, bis der Zeilenwert kleiner als TOAST_TUPLE_TARGET-Bytes ist (variabel, normalerweise auch 2 KB) oder es unmöglich wird, die Größe zu reduzieren.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben entschieden, dass die Daten, die wir normalerweise haben, entweder "sehr kurz" oder sofort "sehr lang" sind, und haben uns daher entschlossen, uns auf den niedrigstmöglichen Wert zu beschränken:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> rawplan_orig <span class="hljs-keyword">SET</span> (toast_tuple_target = <span class="hljs-number">128</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie sich die neuen Einstellungen auf das Laden der Festplatte nach der Migration auswirken:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/pp/cz/k7/ppczk7f8qj9cu_hixtltdk_wvo4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nicht schlecht! </font><font style="vertical-align: inherit;">Die durchschnittliche </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warteschlange für eine Festplatte wurde</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um das 1,5-fache und die Festplattenbelegung um 20 Prozent </font><b><font style="vertical-align: inherit;">reduziert</font></b><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Aber vielleicht hat das irgendwie die CPU beeinflusst?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/xa/vj/sq/xavjsqger1hmawiiidzngvzcff0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zumindest wurde es definitiv nicht schlimmer. </font><font style="vertical-align: inherit;">Es ist jedoch schwierig zu beurteilen, ob selbst solche Volumes die durchschnittliche CPU-Auslastung nicht über </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5%</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erhöhen können </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<font color="#4060a0"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei einem Positionswechsel ändert sich die Summe ...!</font></font></h2></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie wissen, spart ein Penny einen Rubel, und bei einem Speichervolumen von etwa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 TB / Monat kann</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bereits eine kleine Optimierung einen guten Gewinn bringen. Aus diesem Grund haben wir auf die physikalische Struktur unserer Daten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hingewiesen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - wie genau </font><b><font style="vertical-align: inherit;">die „Felder“ im Datensatz</font></b><font style="vertical-align: inherit;"> jeder Tabelle angeordnet sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenausrichtung </font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wirkt sich</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dies direkt </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">auf das resultierende Volume aus</font></a><font style="vertical-align: inherit;"> :</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele Architekturen bieten Datenausrichtung über Maschinenwortgrenzen hinweg. </font><font style="vertical-align: inherit;">Beispielsweise werden auf einem x86-32-Bit-System Ganzzahlen (Integer-Typ, belegt 4 Byte) an der Grenze von 4-Byte-Wörtern sowie Gleitkommazahlen mit doppelter Genauigkeit (Typ mit doppelter Genauigkeit, 8 Byte) ausgerichtet. </font><font style="vertical-align: inherit;">Bei einem 64-Bit-System werden Doppelwerte am Rand von 8-Byte-Wörtern ausgerichtet. </font><font style="vertical-align: inherit;">Dies ist ein weiterer Grund für die Inkompatibilität. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund der Ausrichtung hängt die Größe der Tabellenzeile von der Reihenfolge der Felder ab. </font><font style="vertical-align: inherit;">Normalerweise ist dieser Effekt nicht sehr auffällig, kann aber in einigen Fällen zu einer signifikanten Vergrößerung führen. </font><font style="vertical-align: inherit;">Wenn Sie beispielsweise Felder vom Typ char (1) und Integer gemischt platzieren, werden in der Regel 3 Bytes umsonst verschwendet.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit synthetischen Modellen:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> pg_column_size(<span class="hljs-keyword">ROW</span>(
  <span class="hljs-string">'0000-0000-0000-0000-0000-0000-0000-0000'</span>::<span class="hljs-keyword">uuid</span>
, <span class="hljs-number">0</span>::<span class="hljs-built_in">smallint</span>
, <span class="hljs-string">'2019-01-01'</span>::<span class="hljs-built_in">date</span><font></font>
));<font></font>
<span class="hljs-comment">-- 48 </span><font></font>
<font></font>
<span class="hljs-keyword">SELECT</span> pg_column_size(<span class="hljs-keyword">ROW</span>(
  <span class="hljs-string">'2019-01-01'</span>::<span class="hljs-built_in">date</span>
, <span class="hljs-string">'0000-0000-0000-0000-0000-0000-0000-0000'</span>::<span class="hljs-keyword">uuid</span>
, <span class="hljs-number">0</span>::<span class="hljs-built_in">smallint</span><font></font>
));<font></font>
<span class="hljs-comment">-- 46 </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Woher kam das zusätzliche Bytepaar im ersten Fall? </font><font style="vertical-align: inherit;">Alles ist einfach - ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2-Byte-Smallint wird an einer 4-Byte-Grenze</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vor dem nächsten Feld ausgerichtet, und wenn es das letzte ist, gibt es nichts und es besteht keine Notwendigkeit, es auszurichten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Theoretisch ist alles in Ordnung und Sie können die Felder nach Belieben neu anordnen. </font><font style="vertical-align: inherit;">Lassen Sie uns am Beispiel einer der Tabellen, deren täglicher Abschnitt 10-15 GB benötigt, die realen Daten überprüfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quellstruktur:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> public.plan_20190220<font></font>
(<font></font>
<span class="hljs-comment">--  from table plan:  pack uuid NOT NULL,</span>
<span class="hljs-comment">--  from table plan:  recno smallint NOT NULL,</span>
<span class="hljs-comment">--  from table plan:  host uuid,</span>
<span class="hljs-comment">--  from table plan:  ts timestamp with time zone,</span>
<span class="hljs-comment">--  from table plan:  exectime numeric(32,3),</span>
<span class="hljs-comment">--  from table plan:  duration numeric(32,3),</span>
<span class="hljs-comment">--  from table plan:  bufint bigint,</span>
<span class="hljs-comment">--  from table plan:  bufmem bigint,</span>
<span class="hljs-comment">--  from table plan:  bufdsk bigint,</span>
<span class="hljs-comment">--  from table plan:  apn uuid,</span>
<span class="hljs-comment">--  from table plan:  ptr uuid,</span>
<span class="hljs-comment">--  from table plan:  dt date,</span>
  <span class="hljs-keyword">CONSTRAINT</span> plan_20190220_pkey PRIMARY <span class="hljs-keyword">KEY</span> (pack, recno),
  <span class="hljs-keyword">CONSTRAINT</span> chck_ptr <span class="hljs-keyword">CHECK</span> (ptr <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>),
  <span class="hljs-keyword">CONSTRAINT</span> plan_20190220_dt_check <span class="hljs-keyword">CHECK</span> (dt = <span class="hljs-string">'2019-02-20'</span>::<span class="hljs-built_in">date</span>)<font></font>
)<font></font>
INHERITS (public.plan)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Abschnitt nach dem Ändern der Reihenfolge der Spalten ist genau </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das gleiche Feld, nur die Reihenfolge ist unterschiedlich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> public.plan_20190221<font></font>
(<font></font>
<span class="hljs-comment">--  from table plan:  dt date NOT NULL,</span>
<span class="hljs-comment">--  from table plan:  ts timestamp with time zone,</span>
<span class="hljs-comment">--  from table plan:  pack uuid NOT NULL,</span>
<span class="hljs-comment">--  from table plan:  recno smallint NOT NULL,</span>
<span class="hljs-comment">--  from table plan:  host uuid,</span>
<span class="hljs-comment">--  from table plan:  apn uuid,</span>
<span class="hljs-comment">--  from table plan:  ptr uuid,</span>
<span class="hljs-comment">--  from table plan:  bufint bigint,</span>
<span class="hljs-comment">--  from table plan:  bufmem bigint,</span>
<span class="hljs-comment">--  from table plan:  bufdsk bigint,</span>
<span class="hljs-comment">--  from table plan:  exectime numeric(32,3),</span>
<span class="hljs-comment">--  from table plan:  duration numeric(32,3),</span>
  <span class="hljs-keyword">CONSTRAINT</span> plan_20190221_pkey PRIMARY <span class="hljs-keyword">KEY</span> (pack, recno),
  <span class="hljs-keyword">CONSTRAINT</span> chck_ptr <span class="hljs-keyword">CHECK</span> (ptr <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>),
  <span class="hljs-keyword">CONSTRAINT</span> plan_20190221_dt_check <span class="hljs-keyword">CHECK</span> (dt = <span class="hljs-string">'2019-02-21'</span>::<span class="hljs-built_in">date</span>)<font></font>
)<font></font>
INHERITS (public.plan)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Gesamtvolumen des Abschnitts wird durch die Anzahl der „Fakten“ bestimmt und hängt nur von externen Prozessen ab. Daher teilen wir die Größe von heap ( </font></font><code>pg_relation_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) durch die Anzahl der darin enthaltenen Datensätze - das heißt, wir erhalten die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durchschnittliche Größe des tatsächlich gespeicherten Datensatzes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jx/6e/im/jx6eimznnvdqtrzp6aohdvxluzs.png"></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minus 6% des Volumens</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ausgezeichnet! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber natürlich ist nicht alles so rosig - weil </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir in den Indizes die Reihenfolge der Felder nicht ändern können</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und daher "im Allgemeinen" ( </font></font><code>pg_total_relation_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) ...</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/az/3m/6z/az3m6zsyv47wtawrbk_tdmwdpfg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... schließlich haben sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier 1,5% gespart</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ohne eine einzige Codezeile zu ändern. </font><font style="vertical-align: inherit;">Ja ja!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gb/dr/ps/gbdrpsonli0eclk4ozdjjtofnda.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich stelle fest, dass die obige Anordnung der Felder nicht die optimale ist. </font><font style="vertical-align: inherit;">Weil einige Feldblöcke aus ästhetischen Gründen nicht schon „auseinandergerissen“ werden möchten - zum Beispiel ein Paar </font></font><code>(pack, recno)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das für diese Tabelle PK ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen ist die Definition der "minimalen" Feldanordnung eine ziemlich einfache "erschöpfende" Aufgabe. </font><font style="vertical-align: inherit;">Daher können Sie mit Ihren Daten noch bessere Ergebnisse erzielen als mit unseren - probieren Sie es aus!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de498280/index.html">Die Geschichte des Dodo-Vogels aus der Gattung Phoenix. Der große Fall von Dodo IS</a></li>
<li><a href="../de498282/index.html">[Anweisung] Erstellen eines Kontos und einer Website auf der Google Site-Plattform</a></li>
<li><a href="../de498284/index.html">So optimieren Sie das Englischlernen</a></li>
<li><a href="../de498288/index.html">Ihre Stadt braucht einen U-Bahn-Bus</a></li>
<li><a href="../de498290/index.html">Prozedurale Hydrologie: Dynamische Simulation von Flüssen und Seen</a></li>
<li><a href="../de498294/index.html">Objekterkennung Erkennen und regieren. Teil 1</a></li>
<li><a href="../de498296/index.html">Design auf Systemebene. Teil 1. Von der Idee zum System</a></li>
<li><a href="../de498298/index.html">Firmen verwenden Bug Bounties, um Hacker-Stille zu kaufen</a></li>
<li><a href="../de498300/index.html">Blitz.Engine: Asset System</a></li>
<li><a href="../de498302/index.html">ILO Advanced License. Warum wird es gerade jetzt benötigt?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>