<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåñ üß§ üîô Widgets on Android. A rare feature to figure out üìç üç£ üê©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! My name is Alexander Khakimov, I am an android developer at FINCH. 
 
 Did it happen that your design was for iOS, and you have to adapt ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Widgets on Android. A rare feature to figure out</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492166/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr! </font><font style="vertical-align: inherit;">My name is Alexander Khakimov, I am an android developer at FINCH. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Did it happen that your design was for iOS, and you have to adapt it for android? </font><font style="vertical-align: inherit;">If so, do your designers often use widgets? </font><font style="vertical-align: inherit;">Unfortunately, a widget is a rare case for many developers, because rarely does anyone work with it. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the article I will tell you in detail how to create a widget, which is worth paying attention to and will share my case.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget creation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To create a widget you need to know:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Features of widget components.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Features of displaying the widget in the screen grid.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Features widget updates.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will analyze each item separately.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Features of widget components</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Any developer who has worked with RemoteViews at least once is familiar with this item. </font><font style="vertical-align: inherit;">If you are one of these, feel free to move on to the next point. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RemoteViews is designed to describe and manage Views hierarchies that belong to a process in another application. </font><font style="vertical-align: inherit;">Using hierarchy management, you can change properties or call methods that belong to the View, which is part of another application. </font><font style="vertical-align: inherit;">RemoteViews includes a limited set of components from the standard android.widget component library. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
View inside widgets works in a separate process (usually this is the home screen), therefore, to change the widget's UI, use the BroadcastReceiver extension - AppWidgetProvider, which works in our application.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Features of displaying the widget in the "grid" of the screen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, this point is not so complicated, if you look at the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">official guidelines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
 <blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each widget must define a minWidth and minHeight, indicating the minimum amount of space it should consume by default. </font><font style="vertical-align: inherit;">When users add a widget to their Home screen, it will generally occupy more than the minimum width and height you specify. </font><font style="vertical-align: inherit;">Android Home screens offer users a grid of available spaces into which they can place widgets and icons. </font><font style="vertical-align: inherit;">This grid can vary by a device; </font><font style="vertical-align: inherit;">for example, many handsets offer a 4x4 grid, and tablets can offer a larger, 8x7 grid.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Translating into Russian: each widget must set its own minimum width and height to indicate the minimum space that it will occupy by default. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6r/p-/ux/6rp-uxyfekjzwlpantqmxkdfaio.png" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example of widget settings when creating in Android Studio A</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
widget that was added to the Home screen will usually take up more space than the minimum width and height of the screen that you set. Android Home screens provides users with a grid of available spaces in which widgets and icons can be located. This grid may vary by device; for example, many phones offer 4x4 grids, and tablets can offer large 8x4 grids.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From this it becomes clear that the device‚Äôs grid can be anything, and the cell size may vary, depending on the size of the grid. </font><font style="vertical-align: inherit;">Accordingly, the content of the widget should be designed with these features in mind. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The minimum width and height of the widget for a given number of columns and rows can be calculated using the formula: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
minSideSizeDp = 70 √ó n - 30, where n is the number of rows or columns. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the moment, the maximum minimum grid you can set is 4x4. </font><font style="vertical-align: inherit;">This ensures that your widget will be displayed on all devices.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Features widget updates</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since AppWidgetProvider is essentially an extension of BroadcastReceiver, you can do the same with it as with a regular BroadcastReceiver. AppWidgetProvider simply parses the corresponding fields from the Intent received in onReceive and calls the interception methods with the received extras. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The difficulty arose with the frequency of updating the content - the whole point is the difference in the internal operation of widgets on iOS and Android. The fact is that data on iOS widgets is updated when the widget becomes visible to the user. In Android, such an event does not exist. We cannot find out when the user sees the widget.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For widgets on Android, the recommended update method is a timer update. </font><font style="vertical-align: inherit;">The timer settings are set by the widget parameter updatePeriodMillis. </font><font style="vertical-align: inherit;">Unfortunately, this setting does not allow updating the widget more than once every 30 minutes. </font><font style="vertical-align: inherit;">Below I will talk about this in more detail.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget case</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further we will talk about the case that we had at FINCH in a large lottery application with the Stoloto application for participation in state lotteries. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The task of the application is to simplify and make transparent for the user the choice of a lottery and the purchase of a ticket. </font><font style="vertical-align: inherit;">Therefore, the required functionality of the widget is quite simple: show the user recommended games for purchase and tap to go to the corresponding one. </font><font style="vertical-align: inherit;">The list of games is determined on the server and updated regularly. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our case, the widget design included two states:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For authorized user</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For an unauthorized user</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An authorized user needs to show his profile data: the status of the internal wallet, the number of tickets awaiting the draw and the amount of lost wins. </font><font style="vertical-align: inherit;">For each of these elements, a transition to the screen inside the application is provided, different from the others. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rp/d2/6i/rpd26ixtdxfjopibvmgaaczfkco.png" alt="image"><br>
<br>
<img src="https://habrastorage.org/webt/dk/yy/qx/dkyyqxqcnopxezwhknrmqbuedgu.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you may have noticed, another feature for an authorized user is the ‚Äúrefresh‚Äù button, but more on that later. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To implement the display of two states, taking into account the design, I used the RemoteAdapter as an implementation of RemoteViewsService to generate content cards. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now a little code and how everything works inside. </font><font style="vertical-align: inherit;">If you already had experience with the widget, then you know that any update of widget data starts with the onUpdate method:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onUpdate</span><span class="hljs-params">(
        context: <span class="hljs-type">Context</span>,
        appWidgetManager: <span class="hljs-type">AppWidgetManager</span>,
        appWidgetIds: <span class="hljs-type">IntArray</span>
    )</span></span> {<font></font>
        injector.openScope(<span class="hljs-keyword">this</span>, *arrayOf(<span class="hljs-keyword">this</span>))
        <span class="hljs-comment">// update each of the widgets with the remote adapter</span><font></font>
        appWidgetIds<font></font>
            .forEach {<font></font>
                updateWidget(context, appWidgetManager, it)<font></font>
          }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We are writing an update for each instance of our widget.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateWidget</span><span class="hljs-params">(
        context: <span class="hljs-type">Context</span>,
        appWidgetManager: <span class="hljs-type">AppWidgetManager</span>,
        appWidgetId: <span class="hljs-type">Int</span>
    )</span></span> {
<span class="hljs-comment">// remoteViews   widgetId</span>
        <span class="hljs-keyword">val</span> remoteViews = RemoteViews(<font></font>
            context.packageName,<font></font>
            R.layout.app_widget_layout<font></font>
...<font></font>
<span class="hljs-comment">//        </span><font></font>
...<font></font>
<span class="hljs-comment">//    remoteViews</span><font></font>
updateRemoteAdapter(context, remoteViews, appWidgetId)<font></font>
 <font></font>
<span class="hljs-comment">//   remoteViews </span><font></font>
appWidgetManager.updateAppWidget(appWidgetId, remoteViews)<font></font>
<span class="hljs-comment">// collection view  </span><font></font>
appWidgetManager.notifyAppWidgetViewDataChanged(<font></font>
            appWidgetId,<font></font>
            R.id.lvWidgetItems<font></font>
        )<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Updating the adapter.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateRemoteAdapter</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, remoteViews: <span class="hljs-type">RemoteViews</span>, appWidgetId: <span class="hljs-type">Int</span>)</span></span> {
<span class="hljs-comment">//   RemoteViewsService   RemoteAdapter   </span>
        <span class="hljs-keyword">val</span> adapterIntent = Intent(context, StolotoAppWidgetRemoteViewsService::<span class="hljs-keyword">class</span>.java).apply {<font></font>
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)<font></font>
        }<font></font>
        remoteViews.setRemoteAdapter(R.id.lvWidgetItems, adapterIntent)<font></font>
// actionIntent  pendingIntent      <font></font>
        <span class="hljs-keyword">val</span> actionIntent = Intent(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java).apply {<font></font>
            action = WIDGET_CLICK_ACTION<font></font>
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)<font></font>
        }<font></font>
        <span class="hljs-keyword">val</span> pendingIntent = PendingIntent.getBroadcast(<font></font>
            context, <span class="hljs-number">0</span>, actionIntent,<font></font>
            PendingIntent.FLAG_UPDATE_CURRENT<font></font>
        )<font></font>
<span class="hljs-comment">// pendingIntent      </span><font></font>
        remoteViews.setPendingIntentTemplate(R.id.lvWidgetItems, pendingIntent)<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We are writing the implementation of our service. </font><font style="vertical-align: inherit;">In it, it‚Äôs important for us to indicate which implementation of the RemoteViewsService.RemoteViewsFactory interface to use to generate content.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StolotoAppWidgetRemoteViewsService</span> : <span class="hljs-type">RemoteViewsService</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onGetViewFactory</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>)</span></span>: RemoteViewsFactory =<font></font>
        StolotoAppWidgetRemoteViewsFactory(<font></font>
            <span class="hljs-keyword">this</span>.applicationContext,<font></font>
            intent<font></font>
        )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is actually a thin wrapper over the Adapter. </font><font style="vertical-align: inherit;">Thanks to him, we can associate our data with remote collection view. </font><font style="vertical-align: inherit;">RemoteViewsFactory provides methods for generating RemoteViews for each item in the dataset. </font><font style="vertical-align: inherit;">The constructor has no requirements - all I do is pass the context in it. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, a few words about the main methods:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onCreate - creating an adapter.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getLoadingView - the method suggests returning the View, which the system will display instead of the list items while they are being created. </font><font style="vertical-align: inherit;">If you do not create anything here, then the system uses some default View.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getViewAt - the method suggests creating list items. </font><font style="vertical-align: inherit;">Here comes the standard use of RemoteViews.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onDataSetChanged is called when a request is received to update the data in the list. </font><font style="vertical-align: inherit;">Those. </font><font style="vertical-align: inherit;">In this method, we prepare the data for the list. </font><font style="vertical-align: inherit;">The method is sharpened by the execution of heavy, long code.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onDestroy is called when the last list that the adapter used is deleted (one adapter can be used by several lists).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RemoteViewsFactory lives while all instances of the list are alive, so we can store current data in it, for example, a list of current items.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Define a list of data that we will show:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> widgetItems = ArrayList&lt;WidgetItem&gt;()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When creating the adapter, we begin to load the data. </font><font style="vertical-align: inherit;">Here you can safely perform any difficult tasks, including walking quietly into the network blocking the flow.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
        updateDataSync()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When calling the command to update data, we also call updateDataSync ()</font></font><br>
<br>
<pre><code class="kotlin hljs">   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDataSetChanged</span><span class="hljs-params">()</span></span> {<font></font>
        updateDataSync()<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inside updateDataSync, everything is simple too. </font><font style="vertical-align: inherit;">We clear the current list of items. </font><font style="vertical-align: inherit;">Download profile and game data.</font></font><br>
<br>
<pre><code class="kotlin hljs"> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateDataSync</span><span class="hljs-params">()</span></span> {<font></font>
        widgetItems.clear()<font></font>
        updateProfileSync()<font></font>
        updateGamesSync()<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It‚Äôs more interesting here</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateProfileSync</span><span class="hljs-params">()</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since it is important for us to show the profile only to an authorized user, we need to download the profile information only in this case:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> isUserFullAuth = isUserFullAuthInteractor<font></font>
            .execute()<font></font>
            .blockingGet()<font></font>
        <span class="hljs-keyword">if</span> (isUserFullAuth) {
            <span class="hljs-keyword">val</span> profile = getWidgetProfileInteractor<font></font>
                .execute()<font></font>
                .onErrorReturn {<font></font>
                    WidgetProfile()<font></font>
<span class="hljs-comment">//           </span><font></font>
                }<font></font>
                .blockingGet()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The WidgetProfile model is assembled from different sources, so the logic of their receipt and its default values ‚Äã‚Äãare arranged in such a way that a negative wallet value indicates incorrect data or problems with their receipt. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For business logic, the lack of wallet data is critical, therefore, in the case of an incorrect wallet, a profile model will not be created and added to the list of items.</font></font><br>
<br>
<pre><code class="kotlin hljs">  <span class="hljs-keyword">if</span> (profile.walletAmount &gt;= <span class="hljs-number">0L</span>) {<font></font>
                widgetItems.add(<font></font>
                    WidgetItem.Profile(<font></font>
                        wallet = profile.walletAmount.toMoneyFormat(),<font></font>
                        waitingTickets = <span class="hljs-keyword">if</span> (profile.waitingTicketsCount &gt;= <span class="hljs-number">0</span>) profile.waitingTicketsCount.toString() <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>,<font></font>
                        unpaidPrizeAmount = <span class="hljs-keyword">if</span> (profile.unpaidPrizeAmount &gt;= <span class="hljs-number">0</span>) profile.unpaidPrizeAmoount.toMoneyFormat() <span class="hljs-keyword">else</span> <span class="hljs-string">""</span><font></font>
                    )<font></font>
                )<font></font>
            }<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The updateGamesSync () method uses getWidgetGamesInteractor and adds a set of games relevant to the widget to the widgetItems list. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before proceeding to the generation of cards, consider the WidgetItem model in more detail. </font><font style="vertical-align: inherit;">It is implemented through the kotlin sealed class, which makes the model more flexible, and working with it is more convenient.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetItem</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Profile</span></span>(
        <span class="hljs-keyword">val</span> wallet: String,
        <span class="hljs-keyword">val</span> waitingTickets: String,
        <span class="hljs-keyword">val</span> unpaidPrizeAmount: String<font></font>
    ) : WidgetItem()<font></font>
 <font></font>
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span></span>(
        <span class="hljs-keyword">val</span> id: String,
        <span class="hljs-keyword">val</span> iconId: <span class="hljs-built_in">Int</span>,
        <span class="hljs-keyword">val</span> prizeValue: String,
        <span class="hljs-keyword">val</span> date: String<font></font>
    ) : WidgetItem()<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Create RemoteViews and determine their response through FillInIntent</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getViewAt</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: RemoteViews {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> item = widgetItems[position]) {
            <span class="hljs-keyword">is</span> WidgetItem.Profile -&gt; {<font></font>
              RemoteViews(<font></font>
                        context.packageName,<font></font>
                        R.layout.item_widget_user_profile<font></font>
                    ).apply {<font></font>
                        setTextViewText(R.id.tvWidgetWalletMoney, item.wallet)<font></font>
                        setTextViewText(R.id.tvWidgetUnpaidCount, item.unpaidPrizeAmount)<font></font>
                        setTextViewText(R.id.tvWidgetWaitingCount, item.waitingTickets)<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileWallet, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_USER_WALLET<font></font>
                            )<font></font>
                        )<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileUnpaid, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_UNPAID_PRIZE<font></font>
                            )<font></font>
                        )<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileWaiting, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_WAITING_TICKETS<font></font>
                            )<font></font>
                        )<font></font>
                    }<font></font>
 <font></font>
            <span class="hljs-keyword">is</span> WidgetItem.Game -&gt; {<font></font>
                RemoteViews(<font></font>
                    context.packageName,<font></font>
                    R.layout.item_widget_game<font></font>
                ).apply {<font></font>
                    setImageViewResource(R.id.ivWidgetGame, item.iconId)<font></font>
                    setTextViewText(R.id.tvWidgetGamePrize, item.prizeValue)<font></font>
                    setTextViewText(R.id.tvWidgetGameDate, item.date)<font></font>
                    setOnClickFillInIntent(<font></font>
                        R.id.llWidgetGame, Intent().putExtra(<font></font>
                            StolotoAppWidgetProvider.KEY_GAME_CLICK, item.id<font></font>
                        )<font></font>
                    )<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The setOnClickFillInIntent method assigns the specified viewId intent, which will be combined with the parent PendingIntent to determine the behavior when clicking on the view with this viewId. </font><font style="vertical-align: inherit;">This way we can respond to user clicks in our WidgetProvider.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manual widget update</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An update time of half an hour was set for our widget. You can update it more often, for example, through dancing with WorkManager, but why load your network and battery? Such behavior in the early stages of development seemed adequate. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything changed when the ‚Äúbusiness‚Äù noticed that when the user looks at the widget, the irrelevant data is displayed on it: ‚ÄúHere on my iPhone, I open the widget and there is the MOST fresh data of my profile.‚Äù </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The situation is commonplace: iOS generates new cards for EVERY widget display, because for this they have a special screen, and Android does not have such events for the widget in principle. I had to take into account that some lotteries are held once every 15 minutes, so the widget should give up-to-date information - you want to participate in some kind of draw, but it has already passed.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to get out of this unpleasant situation and somehow solve the problem with updating data, I proposed and implemented a time-tested solution - the ‚Äúupdate‚Äù button. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Add this button to the layout layout with the list and initialize its behavior when updateWidget is called.</font></font><br>
<br>
<pre><code class="kotlin hljs">...
<span class="hljs-comment">// Intent   AppWidgetManager.ACTION_APPWIDGET_UPDATE</span>
<span class="hljs-keyword">val</span> intentUpdate = Intent(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java)<font></font>
intentUpdate.action = AppWidgetManager.ACTION_APPWIDGET_UPDATE<font></font>
<font></font>
//    <font></font>
<span class="hljs-keyword">val</span> ids = AppWidgetManager.getInstance(context)<font></font>
   .getAppWidgetIds(ComponentName(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java))<font></font>
intentUpdate.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, ids)<font></font>
<font></font>
//  intent  PendingIntent,  PendingIntent.getBroadcast()<font></font>
<span class="hljs-keyword">val</span> pendingUpdate = PendingIntent.getBroadcast(<font></font>
   context,<font></font>
   appWidgetId,<font></font>
   intentUpdate,<font></font>
   PendingIntent.FLAG_UPDATE_CURRENT<font></font>
)<font></font>
//  pendingIntent      ‚Äò‚Äô<font></font>
remoteViews.setOnClickPendingIntent(R.id.ivWidgetRefresh, pendingUpdate)<font></font>
‚Ä¶</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first developments showed a sad picture: from pressing the "update" button to the actual update, several seconds could pass. </font><font style="vertical-align: inherit;">Although the widget is generated by our application, it is actually under the control of the system and communicates with our application through broadcasts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Those. </font><font style="vertical-align: inherit;">when you click on the "update" button of our widget, the chain starts:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get the Intent in the onReceive provider 'action'.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppWidgetManager.ACTION_APPWIDGET_UPDATE. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call onUpdate for all widgetsIds specified in intent-e.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go online for new data.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refresh local data and display new list cards.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, updating the widget did not look very nice, because by clicking on the button we looked at the same widget for a couple of seconds. </font><font style="vertical-align: inherit;">It was unclear whether the data was updated. </font><font style="vertical-align: inherit;">How to solve the problem of visual response? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firstly, I added the isWidgetLoading flag with global access through the interactor. </font><font style="vertical-align: inherit;">The role of this parameter is quite simple - do not show the refresh button while the widget data is loading. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secondly, I divided the data loading process in the factory into three stages:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadingStep</span> </span>{<font></font>
   START,<font></font>
   MIDDLE,<font></font>
   END<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
START - start of download. </font><font style="vertical-align: inherit;">At this stage, the state of all adapter views and the global download flag changes to ‚Äúloading‚Äù. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MIDDLE - the stage of the main data loading. </font><font style="vertical-align: inherit;">After they are downloaded, the global download flag is put in the ‚Äúloaded‚Äù state, and the downloaded data is displayed in the adapter. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
END - end of download. </font><font style="vertical-align: inherit;">The adapter does not need to change adapter data in this step. </font><font style="vertical-align: inherit;">This step is needed to correctly process the update stage of the views in WidgetProvider. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see in more detail what the button update looks like in the provider:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">if</span> (isFullAuthorized &amp;&amp; !widgetLoadingStateInteractor.isWidgetLoading) {<font></font>
   remoteViews.setViewVisibility(R.id.ivWidgetRefresh, View.VISIBLE)<font></font>
...<font></font>
<span class="hljs-comment">//     ,    </span><font></font>
...   <font></font>
} <span class="hljs-keyword">else</span> {<font></font>
   remoteViews.setViewVisibility(<font></font>
       R.id.ivWidgetRefresh,<font></font>
       <span class="hljs-keyword">if</span> (isFullAuthorized) View.INVISIBLE <span class="hljs-keyword">else</span> View.GONE <span class="hljs-comment">//       .</span><font></font>
   )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's look at what happens in the adapter:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateDataSync</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">when</span> (loadingStep) {<font></font>
       START -&gt; {<font></font>
           widgetItems.forEach { it.isLoading = <span class="hljs-literal">true</span> }<font></font>
           widgetLoadingStateInteractor.isWidgetLoading = <span class="hljs-literal">true</span><font></font>
           loadingStep = MIDDLE<font></font>
           widgetManager.updateWidgets()<font></font>
       }<font></font>
       MIDDLE -&gt; {<font></font>
           widgetItems.clear()<font></font>
           updateProfileSync()<font></font>
           updateGamesSync()<font></font>
           widgetLoadingStateInteractor.isWidgetLoading = <span class="hljs-literal">false</span><font></font>
           loadingStep = END<font></font>
           widgetManager.updateWidgets()<font></font>
       }<font></font>
       END -&gt; {<font></font>
           loadingStep = START<font></font>
       }<font></font>
   }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/bq/ah/hg/bqahhgnwugy10345-bcegnupxo8.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Logic of work: </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the end of the START and MIDDLE steps, I call the updateWidgets method to update the view state managed by the provider.</font></font></li>
<li>   START     ¬´¬ª   ,    MIDDLE.</li>
<li>         MIDDLE,    ¬´¬ª.</li>
<li>   MIDDLE,          END. </li>
<li>      ,   END,    ¬´¬ª.        ,    END   loadingStep  START.</li>
</ol><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With the help of such an implementation, I reached a compromise between the requirement of the "business" to see relevant data on the widget and the need to "pull" the update too often. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I hope the article was useful to you. </font><font style="vertical-align: inherit;">If you had experience creating widgets for Android, then tell us about it in the comments. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Good luck</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en492150/index.html">Implement it completely. Di-in-js</a></li>
<li><a href="../en492154/index.html">Launch of ExoMars delayed to the next launch window in 2022</a></li>
<li><a href="../en492156/index.html">Subtracted. Want. Do</a></li>
<li><a href="../en492162/index.html">Eye Interfaces. Report in Yandex</a></li>
<li><a href="../en492164/index.html">Gateway to the sky, or the city of the future</a></li>
<li><a href="../en492168/index.html">Front work on the backend development of the largest portals on open source software: sharing experience</a></li>
<li><a href="../en492172/index.html">Thin backup of Linux file systems. How to create working copies of a three-terabyte MySQL DBMS in 20 seconds</a></li>
<li><a href="../en492174/index.html">Wireless DIY Soil Moisture Monitor</a></li>
<li><a href="../en492178/index.html">A seven-thousand-pixel path: evolution of monitor resolutions and our requirements</a></li>
<li><a href="../en492182/index.html">Information Security Fundamentals at Microsoft Teams</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>