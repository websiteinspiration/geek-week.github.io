<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßìüèø ü§πüèº ‚òØÔ∏è SHISHUA: der schnellste Pseudozufallszahlengenerator der Welt üéûÔ∏è üèõÔ∏è üçü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor sechs Monaten wollte ich den besten Pseudozufallszahlengenerator (PRNG) mit einer ungew√∂hnlichen Architektur erstellen. Ich dachte, der Anfang w√§r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SHISHUA: der schnellste Pseudozufallszahlengenerator der Welt</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/498352/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/ex/bl/5pexblhd_seedlgm8iidkfktef4.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor sechs Monaten wollte ich den besten Pseudozufallszahlengenerator (PRNG) mit einer ungew√∂hnlichen Architektur erstellen. Ich dachte, der Anfang w√§re einfach, und w√§hrend Sie arbeiten, wird die Aufgabe langsam komplexer. Und ich dachte, ich k√∂nnte alles schnell genug lernen, um mit den schwierigsten fertig zu werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu meiner √úberraschung nahm die Komplexit√§t nicht linear zu. Das Testen von Chi-Quadrat-Bytes erwies sich als sehr schwierig! Sp√§ter war es genauso schwierig, eingefleischte Tests zu bestehen. Ich habe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die aktuellen Ergebnisse ver√∂ffentlicht, um</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu verstehen, welche anderen Schwierigkeiten auf mich warten. Der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PractRand-Test schlug jedoch zu diesem Zeitpunkt fehl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann war es sehr schwierig, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den BigCrush-Test zu bestehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann war es sehr schwierig, 32 Terabyte Daten zu √ºbertragen, wenn PractRand √ºbergeben wurde. </font><font style="vertical-align: inherit;">Geschwindigkeit ist ein Problem geworden. </font><font style="vertical-align: inherit;">Es reichte nicht aus, ein Design zu erstellen, das zehn Megabyte pro Sekunde generiert, da das Bestehen von PractRand einen Monat dauern w√ºrde. </font><font style="vertical-align: inherit;">Aber ich muss zugeben, dass es </font><font style="vertical-align: inherit;">sehr schwierig war, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesen Test mit einer Geschwindigkeit von Gigabyte pro Sekunde zu bestehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich zu einer solchen H√∂he erheben ... m√∂chten Sie wissen, ob Sie die Grenze zu Pareto erreichen k√∂nnen. </font><font style="vertical-align: inherit;">Sie m√∂chten das schnellste PRNG der Welt erstellen, das die komplexesten statistischen Tests besteht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hatte Erfolg. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fr√ºheren Artikel habe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ich dar√ºber gesprochen, was ich gelernt habe, um mein Ziel zu erreichen. </font><font style="vertical-align: inherit;">Und hier werde ich Ihnen erz√§hlen, wie die endg√ºltige Architektur funktioniert.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweck</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit dem Offensichtlichen: Die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschwindigkeit h√§ngt von der Plattform ab</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich habe mich auf die Optimierung f√ºr die moderne x86-64-Architektur (Intel- und AMD-Prozessoren) konzentriert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Leistung zu vergleichen, wird die klassische </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cpb-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Metrik verwendet </font><font style="vertical-align: inherit;">: Dies ist die Anzahl der Prozessorzyklen, die zum Generieren eines Bytes aufgewendet werden. </font><font style="vertical-align: inherit;">Diese Metrik wird </font><font style="vertical-align: inherit;">in allen kryptografischen Werken </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berechnet und verglichen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ein etwas niedrigeres cpb in der Welt der Software oder Hardware kann den Sieg im Wettbewerb oder die Verwendung auf Websites auf der ganzen Welt sicherstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um cpb zu verbessern, k√∂nnen Sie:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generieren Sie mehr Bytes mit dem gleichen Arbeitsaufwand.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oder machen Sie weniger Arbeit, um die gleiche Anzahl von Bytes zu generieren.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oder parallelisieren Sie die Arbeit.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden all das tun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem ersten Punkt m√ºssen wir bei jeder Iteration mehr Bits erzeugen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hatte Angst, dass sie mir sagen w√ºrden: "Wenn es keine 32-Bit-Zahlen ausgibt, dann ist dies nicht das PRSP" oder dasselbe mit 64-Bit-Zahlen. Oder: "Das PRNG sollte nur f√ºr die x86-64-Architektur gelten", als ob Anweisungen wie POPCNT oder Register wie% xmm7 verboten w√§ren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das PRNG ist jedoch ein Engineering: Generatoren versuchen seit mehreren Jahrzehnten, alles M√∂gliche aus den Prozessoren herauszuholen! Als ROL auftauchte, begannen sie sich auf ihn zu verlassen. Mit dem Aufkommen von 64-Bit-Prozessoren begannen sie, sich auf% rax zu verlassen. Nat√ºrlich k√∂nnen solche Algorithmen auf ARM langsamer arbeiten (obwohl dies noch abzuwarten ist), jedoch wurden 64-Bit-PRNs aktiv verwendet, noch bevor Android 2019 Unterst√ºtzung f√ºr 64-Bit ben√∂tigte! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt, dieser Bereich entwickelt sich zusammen mit der Hardware. Und heute unterst√ºtzen Intel- und AMD-Prozessoren aufgrund von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bereits 256-Bit-Operationen. RC4 produzierte 1 Byte, drand48 konnte 4 Bytes gleichzeitig produzieren, pcg64 - 8 Bytes, und jetzt k√∂nnen wir sofort 32 Bytes erzeugen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8 Bytes k√∂nnen eine 64-Bit-Zahl sein, und die meisten Programmiersprachen verf√ºgen √ºber integrierte Typen. </font><font style="vertical-align: inherit;">Nur wenige Sprachen bieten Typen f√ºr 16 Byte (eine bemerkenswerte Ausnahme ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__uint128_t</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in C). </font><font style="vertical-align: inherit;">Noch weniger Sprachen haben einen Typ f√ºr 32 Bytes (au√üer intern). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen uns also vom √ºblichen Prototyp der PRNG-Funktion verabschieden (Beispiel aus dem Vigny </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HWD-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark </font><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="plaintext hljs">static uint64_t next(void);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen k√∂nnen Sie einen Generator erstellen, der den Puffer f√ºllt (Beispiel aus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meinem Benchmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was sind die Nachteile dieser L√∂sung? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihr Generator jeweils 32 Bytes erzeugt, muss der Consumer ein Array bereitstellen, das ein Vielfaches von 32 ist (idealerweise auf 32 Bytes ausgerichtet). </font><font style="vertical-align: inherit;">Obwohl Sie darauf verzichten k√∂nnen, f√ºllen wir nur den Puffer. </font><font style="vertical-align: inherit;">Wir werden nicht verwendete Daten daraus entfernen und bei Bedarf erneut ausf√ºllen. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verz√∂gerung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird unvorhersehbar: Einige Aufrufe lesen nur den Puffer. </font><font style="vertical-align: inherit;">Aber im Durchschnitt wird alles gleich sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt generieren wir mehr Bytes und erledigen den gleichen Arbeitsaufwand. </font><font style="vertical-align: inherit;">Wie parallelisieren wir es?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallelit√§t</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prozessoren bieten eine unglaubliche Reihe von Parallelisierungswerkzeugen auf allen Ebenen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens sind dies SIMD-Anweisungen (Einzelanweisung, mehrere Daten). Beispielsweise f√ºhrt AVX2 gleichzeitig vier 64-Bit-Erg√§nzungen oder acht 32-Bit-Erg√§nzungen usw. durch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird seit etwa f√ºnfzehn Jahren in der Kryptographie verwendet. Parallelit√§t lieferte die unglaubliche Leistung des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha20</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es wird von den wichtigsten Grundelementen verwendet, die kein AESNI verwenden. Zum Beispiel sind </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NORX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gimli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf Parallelit√§t ausgelegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In letzter Zeit hat das Interesse an diesem Thema auch in der nicht kryptografischen PRNG-Community zugenommen. Insbesondere vorhandene Grundelemente, die nicht f√ºr SIMD entwickelt wurden, k√∂nnen die Grundlage f√ºr die Erstellung sehr schneller PRNs sein.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Sebastiano Vigna seine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 ++ -</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Architektur </font><font style="vertical-align: inherit;">in der Julia-Standardbibliothek </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">bewarb</font></a><font style="vertical-align: inherit;"> , stellte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">er fest,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dass die Ergebnisse von acht wettbewerbsf√§higen, unterschiedlich initialisierten PRNG-Instanzen sehr schnell verkettet werden k√∂nnen, wenn jede Operation gleichzeitig in allen PRNRs ausgef√ºhrt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD ist nur eine der Parallelisierungsebenen im Prozessor. Ich empfehle, den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Artikel zu diesem Thema zu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><font style="vertical-align: inherit;">, um eine bessere Vorstellung zu haben, aber ich werde einige Erkl√§rungen geben. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prozessor-Pipelines</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erm√∂glichen die Verarbeitung mehrerer Anweisungen in verschiedenen Phasen. Wenn die Reihenfolge ihrer Ausf√ºhrung gut organisiert ist, um die Abh√§ngigkeiten zwischen den Stufen zu verringern, kann die Verarbeitung von Anweisungen beschleunigt werden.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der superskalaren Ausf√ºhrung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k√∂nnen Sie die Computerteile der Anweisungen gleichzeitig verarbeiten. </font><font style="vertical-align: inherit;">Daf√ºr sollten sie jedoch keine Lese- / Schreibabh√§ngigkeiten haben. </font><font style="vertical-align: inherit;">Sie k√∂nnen die Architektur anpassen, um das Risiko von Ausfallzeiten zu verringern, indem Sie lange vor dem Lesen aufzeichnen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die au√üergew√∂hnliche Ausf√ºhrung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erm√∂glicht es dem Prozessor, Anweisungen nicht in der Reihenfolge ihrer Reihenfolge auszuf√ºhren, sondern sobald sie bereit sind, selbst wenn die vorherigen Anweisungen noch nicht bereit sind. </font><font style="vertical-align: inherit;">Daf√ºr sollte es jedoch keine Lese- / Schreibabh√§ngigkeit geben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt gehen wir zur Umsetzung √ºber!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Architektur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein Schema namens Semi-SHISHUA. </font><font style="vertical-align: inherit;">Woher ein solcher Name kommt, wird beim Lesen allm√§hlich deutlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Schema sieht folgenderma√üen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd8/df1/b8f/bd8df1b8fcfae4897eb4b74f2c6e856f.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie seine Zeile f√ºr Zeile.</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct prng_state {<font></font>
  __m256i state[2];<font></font>
  __m256i output;<font></font>
  __m256i counter;<font></font>
} prng_state;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zustand ist in zwei Teile unterteilt, die im AVX2-Register abgelegt sind (256 Bit). Um die Geschwindigkeit zu erh√∂hen, halten wir das Ergebnis nahe am Staat selbst, aber es ist nicht Teil des Staates. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben auch einen 64-Bit-Z√§hler. Um die Berechnung zu vereinfachen, handelt es sich auch um ein AVX2-Register. Tatsache ist, dass AVX2 eine kleine Funktion hat: Normale Register (% rax und dergleichen) k√∂nnen nicht direkt √ºber MOV auf SIMD √ºbertragen werden, sie m√ºssen durch RAM (meistens durch den Stapel) geleitet werden, was die Verz√∂gerung erh√∂ht und zwei Prozessoranweisungen kostet (MOV auf dem Stapel, VMOV vom Stapel). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun schauen wir uns die Generation an. Beginnen wir mit dem Laden, gehen wir dann durch den Puffer und f√ºllen ihn bei jeder Iteration mit 32 Bytes.</font></font><br>
<br>
<pre><code class="plaintext hljs">inline void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size) {<font></font>
  __m256i s0 = s-&gt;state[0], counter = s-&gt;counter,<font></font>
          s1 = s-&gt;state[1],       o = s-&gt;output;<font></font>
  for (__uint64_t i = 0; i &lt; size; i += 4) {<font></font>
    _mm256_storeu_si256((__m256i*)&amp;buf[i], o);<font></font>
    // ‚Ä¶<font></font>
  }<font></font>
  s-&gt;state[0] = s0; s-&gt;counter = counter;<font></font>
  s-&gt;state[1] = s1; s-&gt;output  = o;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Funktion inline ist, kann der Prozessor durch sofortiges F√ºllen des Puffers beim Start die Anweisungen in Abh√§ngigkeit davon durch einen au√üergew√∂hnlichen Ausf√ºhrungsmechanismus sofort ausf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Innerhalb der Schleife f√ºhren wir schnell drei Zustandsoperationen aus:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ft</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ffle</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dd</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher der Name SHISHUA!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erste Schicht</font></font></h3><br>
<pre><code class="plaintext hljs">u0 = _mm256_srli_epi64(s0, 1);              u1 = _mm256_srli_epi64(s1, 3);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider unterst√ºtzt der AVX2 keine Drehzahl. </font><font style="vertical-align: inherit;">Aber ich m√∂chte die Bits einer Position in einer 64-Bit-Zahl mit den Bits einer anderen Position mischen! </font><font style="vertical-align: inherit;">Und Verschiebung ist der beste Weg, dies zu realisieren. </font><font style="vertical-align: inherit;">Wir werden um eine ungerade Zahl verschieben, so dass jedes Bit alle 64-Bit-Positionen besucht und nicht die H√§lfte davon. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend der Verschiebung gehen Bits verloren, was zur Entfernung von Informationen aus unserem Zustand f√ºhrt. </font><font style="vertical-align: inherit;">Das ist schlecht, Sie m√ºssen Verluste minimieren. </font><font style="vertical-align: inherit;">Die kleinsten ungeraden Zahlen sind 1 und 3. Wir werden unterschiedliche Verschiebungswerte verwenden, um die Diskrepanz zwischen den beiden Teilen zu erh√∂hen. </font><font style="vertical-align: inherit;">Dies wird dazu beitragen, die √Ñhnlichkeit ihrer Selbstkorrelation zu verringern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden nach rechts verschieben, da die am weitesten rechts liegenden Bits w√§hrend der Addition die geringste Diffusion aufweisen: Beispielsweise ist das niedrigstwertige Bit in A + B nur das XOR der niedrigstwertigen Bits A und B.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºhren</font></font></h3><br>
<pre><code class="plaintext hljs">t0 = _mm256_permutevar8x32_epi32(s0, shu0); t1 = _mm256_permutevar8x32_epi32(s1, shu1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden 32-Bit-Mixing verwenden, da es eine andere Granularit√§t bietet als die 64-Bit-Operationen, die wir √ºberall verwenden (die 64-Bit-Ausrichtung wird verletzt). Es kann sich auch um eine spur√ºbergreifende Operation handeln: Andere Mischvorg√§nge k√∂nnen Bits innerhalb der linken 128 Bits verschieben, wenn sie links beginnen, oder innerhalb der rechten 128 Bits, wenn sie rechts beginnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mischkonstanten:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i shu0 = _mm256_set_epi32(4, 3, 2, 1, 0, 7, 6, 5),<font></font>
        shu1 = _mm256_set_epi32(2, 1, 0, 7, 6, 5, 4, 3);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit das Mischen das Ergebnis wirklich verbessert, verschieben wir die schwachen 32-Bit-Teile (mit geringer Streuung) von 64-Bit-Additionen an starke Positionen, damit die n√§chsten Additionen sie bereichern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Low-End-32-Bit-Teil des 64-Bit-Blocks bewegt sich niemals zum gleichen 64-Bit-Block wie der h√∂herwertige Teil. </font><font style="vertical-align: inherit;">Somit bleiben beide Teile nicht im selben Block, was das Mischen verbessert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende durchl√§uft jeder 32-Bit-Teil alle Positionen in einem Kreis: von A nach B, von B nach C, ... von H nach A. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie haben vielleicht bemerkt, dass das einfachste Mischen, das all diese Anforderungen ber√ºcksichtigt, zwei 256-Bit-Teile sind Umsatz (Umdrehungen von 96 Bit bzw. 160 Bit nach rechts).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusatz</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen wir 64-Bit-Chunks aus zwei tempor√§ren Variablen hinzu - Shift und Mixing.</font></font><br>
<br>
<pre><code class="plaintext hljs">s0 = _mm256_add_epi64(t0, u0);              s1 = _mm256_add_epi64(t1, u1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Addition ist die Hauptquelle der Dispersion: Bei dieser Operation werden Bits zu irreduziblen Kombinationen von XOR- und AND-Ausdr√ºcken kombiniert, die √ºber 64-Bit-Positionen verteilt sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Speichern des Additionsergebnisses in einem Zustand bleibt diese Dispersion dauerhaft erhalten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgabefunktion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Woher bekommen wir die Ausgabe? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist ganz einfach: Die von uns erstellte Struktur erm√∂glicht es uns, zwei unabh√§ngige Teile des Zustands s0 und s1 zu generieren, die sich in keiner Weise gegenseitig beeinflussen. </font><font style="vertical-align: inherit;">Wenden Sie XOR auf sie an und erhalten Sie ein v√∂llig zuf√§lliges Ergebnis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Unabh√§ngigkeit zwischen den Daten zu st√§rken, auf die wir XOR anwenden, nehmen wir ein Teilergebnis: den verschobenen Teil eines Zustands und den gemischten Teil eines anderen.</font></font><br>
<br>
<pre><code class="plaintext hljs">o = _mm256_xor_si256(u0, t1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies √§hnelt dem Reduzieren der Lese- / Schreibabh√§ngigkeiten zwischen Befehlen in einem superskalaren Prozessor, als ob u0 und t1 bereit w√§ren, in s0 und s1 zu lesen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Besprechen Sie nun den Z√§hler. Wir verarbeiten es zu Beginn des Zyklus. √Ñndern Sie zuerst den Status und erh√∂hen Sie dann den Z√§hlerwert:</font></font><br>
<br>
<pre><code class="plaintext hljs">s1 = _mm256_add_epi64(s1, counter);<font></font>
counter = _mm256_add_epi64(counter, increment);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum √§ndern wir zuerst den Status und aktualisieren dann den Z√§hler? Wenn s1 fr√ºher verf√ºgbar wird, verringert sich die Wahrscheinlichkeit, dass nachfolgende Anweisungen, die es lesen, in der Prozessor-Pipeline gestoppt werden. Diese Sequenz hilft auch, die direkte Abh√§ngigkeit des Lese- / Schreibz√§hlers zu vermeiden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wenden den Z√§hler auf s1 und nicht auf s0 an, da beide ohnehin die Ausgabe beeinflussen. S1 verliert jedoch aufgrund der Verschiebung mehr Bits, so dass es ihm hilft, nach der Verschiebung ‚Äûauf die Beine zu kommen‚Äú. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Z√§hler zeichnet den PractRand-Test m√∂glicherweise nicht auf. Ihr einziger Zweck besteht darin, eine Untergrenze von 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69 festzulegen</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bytes = 512 Exbibytes f√ºr die PRNG-Periode: Wir beginnen den Zyklus erst nach einem Jahrtausend Arbeit mit einer Geschwindigkeit von 10 Gibytes pro Sekunde zu wiederholen. Es ist unwahrscheinlich, dass es in den kommenden Jahrhunderten f√ºr den praktischen Gebrauch zu langsam sein wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuwachs:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i increment = _mm256_set_epi64x(1, 3, 5, 7);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ungeraden Zahlen werden als Inkremente gew√§hlt, da nur die grundlegenden Coprime-Zahlen den gesamten Zyklus des endlichen Feldes GF (2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">abdecken </font><font style="vertical-align: inherit;">und alle ungeraden Zahlen Coprime f√ºr 2 sind. Mit anderen Worten, wenn Sie um eine gerade ganze Zahl im Bereich von 0 bis inkrementieren 4, die nach 4 auf 0 zur√ºckkehrt, ergibt die Sequenz 0-2-0-2- ..., die niemals zu 1 oder 3 f√ºhrt. Und das ungerade Inkrement durchl√§uft alle ganzen Zahlen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr alle 64-Bit-Zahlen im Status werden unterschiedliche ungerade Zahlen verwendet, wodurch sie weiter voneinander getrennt werden und die Mischung leicht erh√∂ht wird. </font><font style="vertical-align: inherit;">Ich habe die kleinsten ungeraden Zahlen gew√§hlt, damit sie nicht magisch aussehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So funktionieren Zustands√ºbergang und Ausgabefunktion. </font><font style="vertical-align: inherit;">Wie initialisiere ich sie?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir initialisieren den Zustand mit den hexadezimalen Ziffern Œ¶, der irrationalen Zahl, die durch den Bruch am wenigsten angen√§hert wird.</font></font><br>
<br>
<pre><code class="plaintext hljs">static __uint64_t phi[8] = {<font></font>
  0x9E3779B97F4A7C15, 0xF39CC0605CEDC834, 0x1082276BF3A27251, 0xF86C6A11D0C18E95,<font></font>
  0x2767F0B153D27B7F, 0x0347045B5BF1827F, 0x01886F0928403002, 0xC1D64BA40F335E36,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen Sie einen 256-Bit-Startwert. </font><font style="vertical-align: inherit;">Dies geschieht h√§ufig in der Kryptographie und schadet der Arbeit nicht kryptografischer PRNGs nicht:</font></font><br>
<br>
<pre><code class="plaintext hljs">prng_state prng_init(SEEDTYPE seed[4]) {<font></font>
  prng_state s;<font></font>
  // ‚Ä¶<font></font>
  return s;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wollen nicht den gesamten Teil des Staates (s0 oder s1) mit dieser Anfangszahl neu definieren, wir m√ºssen nur die H√§lfte beeinflussen. </font><font style="vertical-align: inherit;">Auf diese Weise vermeiden wir die Verwendung der D√§mpfung von Anfangszahlen, die versehentlich oder absichtlich zu einem bekannten schwachen Anfangszustand f√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da wir nicht die H√§lfte jedes Zustands √§ndern, behalten wir die Kontrolle √ºber 128 Statusbits. </font><font style="vertical-align: inherit;">Eine solche Entropie reicht aus, um eine starke Position einzunehmen und aufrechtzuerhalten.</font></font><br>
<br>
<pre><code class="plaintext hljs">s.state[0] = _mm256_set_epi64x(phi[3], phi[2] ^ seed[1], phi[1], phi[0] ^ seed[0]);<font></font>
s.state[1] = _mm256_set_epi64x(phi[7], phi[6] ^ seed[3], phi[5], phi[4] ^ seed[2]);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann wiederholen wir ( </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">mehrmals die </font><font style="vertical-align: inherit;">folgende Sequenz:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºhren Sie die Schritte ( </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) der SHISHUA-Iterationen aus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir weisen einen Teil des Zustands einem anderen Zustand und den anderen Teil der Ausgabe zu.</font></font></li>
</ol><br>
<pre><code class="plaintext hljs">for (char i = 0; i &lt; ROUNDS; i++) {<font></font>
  prng_gen(&amp;s, buf, 4 * STEPS);<font></font>
  s.state[0] = s.state[1];<font></font>
  s.state[1] = s.output;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Zuweisen eines Ausgabeergebnisses erh√∂ht die Zustandsstreuung. </font><font style="vertical-align: inherit;">W√§hrend der Initialisierung spielt die zus√§tzliche Arbeit und Korrelation von Zust√§nden keine Rolle, da diese Reihe von Operationen einmal ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">Wir sind nur an der Dispersion w√§hrend der Initialisierung interessiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich die Auswirkung auf die Korrelation der Anfangswerte bewertet hatte, w√§hlte ich </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font><font style="vertical-align: inherit;">f√ºr den </font><font style="vertical-align: inherit;">Wert und </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font><font style="vertical-align: inherit;">f√ºr </font><font style="vertical-align: inherit;">10. Ich berechnete die Korrelation durch Berechnung der ‚Äûungew√∂hnlichen‚Äú und ‚Äûverd√§chtigen‚Äú Anomalien, die sich aus dem PRNG-Qualit√§tskontrollwerkzeug in PractRand ergeben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist aus mehreren Gr√ºnden schwierig, die Geschwindigkeit zu messen:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Taktmessung ist</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√∂glicherweise nicht genau genug.</font></font></li>
<li>    <strong></strong>,      , -  ,  -,       .</li>
<li>,        .        <strong></strong>   .</li>
<li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>  </strong></a>:        ,       .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich verwende den RDTSC-Prozessorbefehl, der die Anzahl der Zyklen berechnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit jeder meine Ergebnisse reproduzieren kann, verwende ich eine Cloud-basierte virtuelle Maschine. Dies √§ndert nichts an der H√∂he der Benchmark-Ergebnisse im Vergleich zu lokalen Tests. Au√üerdem m√ºssen Sie nicht denselben Computer wie meinen kaufen. Schlie√ülich gibt es viele Situationen, in denen das PRNG in den Clouds gestartet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe mich f√ºr Google Cloud Platform N2 (Intel-Prozessor) und N2D (AMD-Prozessor) entschieden. Der Vorteil von GCP ist, dass sie Server mit Prozessoren beider Hersteller anbieten. In diesem Artikel konzentrieren wir uns auf Intel, aber f√ºr AMD werden die Ergebnisse in derselben Reihenfolge angezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um tiefer in das Thema einzutauchen, entfernen wir zun√§chst den alten kryptografischen RC4-Generator. Ich konnte die Arbeit nicht parallelisieren</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7,5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Zyklen pro erzeugtem Byte). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun ein sehr beliebtes und schnelles MCG </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ausf√ºhren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Das </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">einfachste Lehmer128 PRNG</font></a><font style="vertical-align: inherit;"> , das den BigCrush-Test besteht, zeigte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wow gro√üartig! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann werden wir die neueste Entwicklung ausf√ºhren, die f√ºr schnelle Hash-Tabellen verwendet wird - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wyrand</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,41 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etwas besser! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige PRSPs bestehen den 32-Terabyte-PractRand-Test nicht, arbeiten jedoch sehr schnell. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erreichte nur 512 Mebibyte, zeigte jedoch eine sehr hohe Geschwindigkeit: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,34 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere Neuentwicklung von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie behauptet, das schnellste PRNG der Welt zu sein - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,31 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Okay, das ist genug. </font><font style="vertical-align: inherit;">Was hat Semi-SHISHUA gezeigt? </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,14 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Zweimal so schnell wie RomuTrio.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/f7a/c9f/c84f7ac9fcbc4d4a7b2400ae552522a4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cool. </font><font style="vertical-align: inherit;">Testen Sie nun den kryptografischen Generator ChaCha8. </font><font style="vertical-align: inherit;">Er erreichte ... </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,12 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD ist echte Magie! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr die kryptografische Gemeinschaft war </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dies keine besondere √úberraschung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">ChaCha8 ist extrem einfach zu parallelisieren. </font><font style="vertical-align: inherit;">Dies ist nur ein gut gehashter Z√§hler in einem diffusen Zustand. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und erinnern Sie sich, wie das Julia-Sprachteam versucht hat, mehrere Instanzen der Vigny-Architektur zu kombinieren, um einen schnellen SIMD-basierten PRCH zu erstellen? </font><font style="vertical-align: inherit;">Schauen wir uns das Ergebnis mit dieser Technik an ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 Teile Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,09 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Technisch k√∂nnte mein Laptop die Ergebnisse beeinflussen. Ich bin mir nicht sicher, warum die Teamentwicklung von Julia in GCP schneller als ChaCha8 ist, aber langsamer, wenn sie lokal getestet wird. Auf meiner Maschine l√§uft semi-SHISHUA schneller als die Julia-Teamentwicklung, aber langsamer als ChaCha8. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist notwendig, alle Konkurrenten zu besiegen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie fragen sich wahrscheinlich schon, warum wir die vorherige Version des Semi-SHISHUA-Generators aufgerufen haben? Weil es sich als einfach herausstellte, die Geschwindigkeit zu verdoppeln, wenn Sie zwei Kopien von Semi-SHISHUA ausf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ñhnlich wie bei der Idee des Julia-Befehls initialisieren wir zwei PRNGs (vier Bl√∂cke mit einem 256-Bit-Zustand) separat und liefern abwechselnd die Ausgabe ihrer Arbeit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir jedoch mehr Zust√§nde erstellen, k√∂nnen wir noch mehr Daten erzeugen, indem wir vier Zust√§nde paarweise kombinieren:</font></font><br>
<br>
<pre><code class="plaintext hljs">o0 = _mm256_xor_si256(u0, t1);<font></font>
o1 = _mm256_xor_si256(u2, t3);<font></font>
o2 = _mm256_xor_si256(s0, s3);<font></font>
o3 = _mm256_xor_si256(s2, s1);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also haben wir SHISHUA bekommen, das eine Geschwindigkeit von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,06 cpb zeigte</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist doppelt so schnell wie der bisher schnellste Konkurrent der Welt, der den 32-Terabyte-PractRand-Test bestanden hat. </font><font style="vertical-align: inherit;">Das Ergebnis ist in der Grafik dargestellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich glaube, dass sich die Entwicklung als wettbewerbsf√§hig herausgestellt hat. </font><font style="vertical-align: inherit;">Auf meinem Laptop funktioniert es sogar noch schneller - 0,03 cpb, aber ich werde meine Grunds√§tze bez√ºglich des Benchmarks einhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoffentlich bleibt mein Generator noch ein paar Wochen auf dem Podium der schnellsten der Welt (bitte tun Sie dies).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualit√§t</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Generator besteht ehrlich BigCrush und den 32-Terabyte-PractRand-Test. Und das alles dank vier Ausgangsstr√∂men. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu den Nachteilen der Architektur geh√∂rt ihre </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Irreversibilit√§t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies kann durch Reduzieren auf einen 4-Bit-Zustand mit </font></font><code>s0 = [a, b]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und gesehen werden </font></font><code>s1 = [c, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mit einer Schicht bekommen wir </font></font><code>[0, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>[0, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und mit R√ºhren </font></font><code>[b, c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>[d, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Neu </font></font><code>s0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleich </font></font><code>[b, c] + [0, a] = [b‚äï(a‚àßc), a‚äïc]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber </font></font><code>s1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleich </font></font><code>[d, a] + [0, c] = [d‚äï(a‚àßc), a‚äïc]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn </font></font><code>a = ¬¨c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dann </font></font><code>a‚äïc = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>a‚àßc = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deshalb </font></font><code>s0 = [b, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>s1 = [d, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Das hei√üt, wir erhalten zwei Kombinationen von </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die uns den gleichen Endzustand geben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall ist dies kein Problem, da der 64-Bit-Z√§hler ebenfalls Teil des Status ist. Es ergibt sich der Mindestzyklus von 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">71</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bytes (128 Bytes pro Zustands√ºbergang) mit einer Geschwindigkeit von 10 Gibytes / Sek. </font><font style="vertical-align: inherit;">wird siebentausend Jahre dauern. </font><font style="vertical-align: inherit;">Dies gleicht die verlorenen Zust√§nde aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zus√§tzlich betr√§gt die durchschnittliche √úbergangszeit zwischen Zust√§nden trotz Irreversibilit√§t 2 ^ ((256 + 1) √∑ 2). </font><font style="vertical-align: inherit;">Dies ergibt einen durchschnittlichen Zyklus von </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.135</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bytes (mit einer Geschwindigkeit von 10 Gibytes / Sek. Es wird mehr als eine Billion Mal l√§nger dauern, als das Universum existiert). </font><font style="vertical-align: inherit;">Obwohl ich glaube, dass mittlere Zyklen √ºbersch√§tzt werden, weil sie uns nichts √ºber die Qualit√§t des Generators sagen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind die Benchmark-Ergebnisse:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generator</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualit√§t</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Samenkorrelation</font></font></strong></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHISHUA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,06</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 256 GiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 + x8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,09</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,31</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 +</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,34</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">512 MiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wyrand</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,41</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lehmer128</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,44</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RC4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.48</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
</tbody></table></div><br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leistung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die Anzahl der Prozessorzyklen, die f√ºr ein generiertes Byte aufgewendet wurden. </font><font style="vertical-align: inherit;">Auf den Cloud-Maschinen N2 GCP und N2D (AMD) empfangen, ist die Reihenfolge dieselbe.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualit√§t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die Stufe, bei der der Generator den PractRand-Test nicht besteht. </font><font style="vertical-align: inherit;">Wenn dies nicht fehlschl√§gt, gibt es ein&gt; -Zeichen. </font><font style="vertical-align: inherit;">Wenn das Ergebnis nicht bewiesen ist, gibt es ein Fragezeichen.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Korrelation der</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Startnummern: PractRand-Durchquerung mit abwechselnden Bytes von acht Streams mit den Startnummern 0, 1, 2, 4, 8, 16, 32, 64. Wir verwenden PractRand mit doppelter Faltung und erweiterten Tests.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3f6/f1d/ea73f6f1db25664622785ba127764dbc.png"></div><br>
</li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des Weiteren</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl es in unserem Fall keine Probleme mit der Irreversibilit√§t gibt, k√∂nnen wir SHISHUA dennoch verbessern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meiner Meinung nach hat das ideale PRNG die folgenden Eigenschaften:</font></font><br>
<br>
<ol>
<li><strong>      </strong>,     2<sup>1024</sup>.      10 /.    10<sup>282</sup>  ,   .    ¬´¬ª (  ).              ,       .  ,      128-  NEON   ARM?  ,      ,     .</li>
<li><strong>    </strong>.      ,   SHISHUA  XOR    .     ,     .</li>
<li><strong>  ,</strong>      2<sup>128</sup>    (     ).        SHISHUA,  ,  .  ,      ( )    (, , .  2).</li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zustandsinitialisierung ist perfekt verteilt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Alle Bits der Anfangszahl wirken sich mit derselben Wahrscheinlichkeit auf alle Bits des Zustands aus. </font><font style="vertical-align: inherit;">Ich m√∂chte es in Bezug auf SHISHUA herausfinden.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eines der Probleme, die die Entwicklung von PRNGs und der Kryptographie insgesamt behindern, ist das Fehlen besserer Allzweckwerkzeuge. </font><font style="vertical-align: inherit;">Ich ben√∂tige ein Tool, mit dem ich sofort das genaue Messergebnis erhalten kann, damit ich verschiedene Architekturen im laufenden Betrieb vergleichen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PractRand ist jedoch gro√üartig im Vergleich zu fr√ºher:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es erlaubt keine Bewertung hochwertiger Generatoren, so dass es unm√∂glich ist, sie miteinander zu vergleichen. </font><font style="vertical-align: inherit;">Wir m√ºssen sagen: "Nun, nach 32 Terabyte haben sie keine Anomalien ..."</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es dauert Wochen, um es auszuf√ºhren ...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, dass sich die Situation bald erheblich verbessern wird.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de498332/index.html">Implementierung einer vertrauensw√ºrdigen Sicherheitsarchitektur: Zweite Ausgabe</a></li>
<li><a href="../de498334/index.html">So organisieren Sie den Planungsprozess in der SAP Analytics Cloud</a></li>
<li><a href="../de498340/index.html">√úber das neue IDA Home (Bewertung)</a></li>
<li><a href="../de498346/index.html">GoLand 2020.1 - Verbesserte Unterst√ºtzung f√ºr Go-Module, viel automatische Vervollst√§ndigung und vieles mehr</a></li>
<li><a href="../de498350/index.html">Die besten Materialien f√ºr Vorstellungsgespr√§che und Jobsuche</a></li>
<li><a href="../de498354/index.html">Wie man "Wunschliste" in "Hardware" oder halbidealen halbmobilen Semi-Desktop √ºbersetzt</a></li>
<li><a href="../de498358/index.html">Lernen Sie Franz√∂sisch oder wie Sie einen Universaladapter von einem PSA-Diagnosescanner erhalten</a></li>
<li><a href="../de498360/index.html">Auswertung der integrierten Serverlastmetriken</a></li>
<li><a href="../de498362/index.html">Kingston ist weiterhin f√ºhrend bei SSD-Sendungen: Wie machen wir das?</a></li>
<li><a href="../de498366/index.html">Welche Algorithmen implementieren Yandex-Entwickler t√§glich?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>