<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏿 🤹🏼 ☯️ SHISHUA: der schnellste Pseudozufallszahlengenerator der Welt 🎞️ 🏛️ 🍟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor sechs Monaten wollte ich den besten Pseudozufallszahlengenerator (PRNG) mit einer ungewöhnlichen Architektur erstellen. Ich dachte, der Anfang wär...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SHISHUA: der schnellste Pseudozufallszahlengenerator der Welt</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/498352/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/ex/bl/5pexblhd_seedlgm8iidkfktef4.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor sechs Monaten wollte ich den besten Pseudozufallszahlengenerator (PRNG) mit einer ungewöhnlichen Architektur erstellen. Ich dachte, der Anfang wäre einfach, und während Sie arbeiten, wird die Aufgabe langsam komplexer. Und ich dachte, ich könnte alles schnell genug lernen, um mit den schwierigsten fertig zu werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu meiner Überraschung nahm die Komplexität nicht linear zu. Das Testen von Chi-Quadrat-Bytes erwies sich als sehr schwierig! Später war es genauso schwierig, eingefleischte Tests zu bestehen. Ich habe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die aktuellen Ergebnisse veröffentlicht, um</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu verstehen, welche anderen Schwierigkeiten auf mich warten. Der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PractRand-Test schlug jedoch zu diesem Zeitpunkt fehl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann war es sehr schwierig, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den BigCrush-Test zu bestehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann war es sehr schwierig, 32 Terabyte Daten zu übertragen, wenn PractRand übergeben wurde. </font><font style="vertical-align: inherit;">Geschwindigkeit ist ein Problem geworden. </font><font style="vertical-align: inherit;">Es reichte nicht aus, ein Design zu erstellen, das zehn Megabyte pro Sekunde generiert, da das Bestehen von PractRand einen Monat dauern würde. </font><font style="vertical-align: inherit;">Aber ich muss zugeben, dass es </font><font style="vertical-align: inherit;">sehr schwierig war, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesen Test mit einer Geschwindigkeit von Gigabyte pro Sekunde zu bestehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich zu einer solchen Höhe erheben ... möchten Sie wissen, ob Sie die Grenze zu Pareto erreichen können. </font><font style="vertical-align: inherit;">Sie möchten das schnellste PRNG der Welt erstellen, das die komplexesten statistischen Tests besteht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hatte Erfolg. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">früheren Artikel habe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ich darüber gesprochen, was ich gelernt habe, um mein Ziel zu erreichen. </font><font style="vertical-align: inherit;">Und hier werde ich Ihnen erzählen, wie die endgültige Architektur funktioniert.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweck</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit dem Offensichtlichen: Die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschwindigkeit hängt von der Plattform ab</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich habe mich auf die Optimierung für die moderne x86-64-Architektur (Intel- und AMD-Prozessoren) konzentriert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Leistung zu vergleichen, wird die klassische </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cpb-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Metrik verwendet </font><font style="vertical-align: inherit;">: Dies ist die Anzahl der Prozessorzyklen, die zum Generieren eines Bytes aufgewendet werden. </font><font style="vertical-align: inherit;">Diese Metrik wird </font><font style="vertical-align: inherit;">in allen kryptografischen Werken </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berechnet und verglichen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ein etwas niedrigeres cpb in der Welt der Software oder Hardware kann den Sieg im Wettbewerb oder die Verwendung auf Websites auf der ganzen Welt sicherstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um cpb zu verbessern, können Sie:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generieren Sie mehr Bytes mit dem gleichen Arbeitsaufwand.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oder machen Sie weniger Arbeit, um die gleiche Anzahl von Bytes zu generieren.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oder parallelisieren Sie die Arbeit.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden all das tun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem ersten Punkt müssen wir bei jeder Iteration mehr Bits erzeugen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hatte Angst, dass sie mir sagen würden: "Wenn es keine 32-Bit-Zahlen ausgibt, dann ist dies nicht das PRSP" oder dasselbe mit 64-Bit-Zahlen. Oder: "Das PRNG sollte nur für die x86-64-Architektur gelten", als ob Anweisungen wie POPCNT oder Register wie% xmm7 verboten wären.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das PRNG ist jedoch ein Engineering: Generatoren versuchen seit mehreren Jahrzehnten, alles Mögliche aus den Prozessoren herauszuholen! Als ROL auftauchte, begannen sie sich auf ihn zu verlassen. Mit dem Aufkommen von 64-Bit-Prozessoren begannen sie, sich auf% rax zu verlassen. Natürlich können solche Algorithmen auf ARM langsamer arbeiten (obwohl dies noch abzuwarten ist), jedoch wurden 64-Bit-PRNs aktiv verwendet, noch bevor Android 2019 Unterstützung für 64-Bit benötigte! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, dieser Bereich entwickelt sich zusammen mit der Hardware. Und heute unterstützen Intel- und AMD-Prozessoren aufgrund von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bereits 256-Bit-Operationen. RC4 produzierte 1 Byte, drand48 konnte 4 Bytes gleichzeitig produzieren, pcg64 - 8 Bytes, und jetzt können wir sofort 32 Bytes erzeugen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8 Bytes können eine 64-Bit-Zahl sein, und die meisten Programmiersprachen verfügen über integrierte Typen. </font><font style="vertical-align: inherit;">Nur wenige Sprachen bieten Typen für 16 Byte (eine bemerkenswerte Ausnahme ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__uint128_t</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in C). </font><font style="vertical-align: inherit;">Noch weniger Sprachen haben einen Typ für 32 Bytes (außer intern). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können uns also vom üblichen Prototyp der PRNG-Funktion verabschieden (Beispiel aus dem Vigny </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HWD-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark </font><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="plaintext hljs">static uint64_t next(void);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen können Sie einen Generator erstellen, der den Puffer füllt (Beispiel aus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meinem Benchmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was sind die Nachteile dieser Lösung? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihr Generator jeweils 32 Bytes erzeugt, muss der Consumer ein Array bereitstellen, das ein Vielfaches von 32 ist (idealerweise auf 32 Bytes ausgerichtet). </font><font style="vertical-align: inherit;">Obwohl Sie darauf verzichten können, füllen wir nur den Puffer. </font><font style="vertical-align: inherit;">Wir werden nicht verwendete Daten daraus entfernen und bei Bedarf erneut ausfüllen. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verzögerung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird unvorhersehbar: Einige Aufrufe lesen nur den Puffer. </font><font style="vertical-align: inherit;">Aber im Durchschnitt wird alles gleich sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt generieren wir mehr Bytes und erledigen den gleichen Arbeitsaufwand. </font><font style="vertical-align: inherit;">Wie parallelisieren wir es?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallelität</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prozessoren bieten eine unglaubliche Reihe von Parallelisierungswerkzeugen auf allen Ebenen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens sind dies SIMD-Anweisungen (Einzelanweisung, mehrere Daten). Beispielsweise führt AVX2 gleichzeitig vier 64-Bit-Ergänzungen oder acht 32-Bit-Ergänzungen usw. durch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird seit etwa fünfzehn Jahren in der Kryptographie verwendet. Parallelität lieferte die unglaubliche Leistung des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha20</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es wird von den wichtigsten Grundelementen verwendet, die kein AESNI verwenden. Zum Beispiel sind </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NORX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gimli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf Parallelität ausgelegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In letzter Zeit hat das Interesse an diesem Thema auch in der nicht kryptografischen PRNG-Community zugenommen. Insbesondere vorhandene Grundelemente, die nicht für SIMD entwickelt wurden, können die Grundlage für die Erstellung sehr schneller PRNs sein.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Sebastiano Vigna seine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 ++ -</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Architektur </font><font style="vertical-align: inherit;">in der Julia-Standardbibliothek </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">bewarb</font></a><font style="vertical-align: inherit;"> , stellte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">er fest,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dass die Ergebnisse von acht wettbewerbsfähigen, unterschiedlich initialisierten PRNG-Instanzen sehr schnell verkettet werden können, wenn jede Operation gleichzeitig in allen PRNRs ausgeführt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD ist nur eine der Parallelisierungsebenen im Prozessor. Ich empfehle, den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Artikel zu diesem Thema zu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><font style="vertical-align: inherit;">, um eine bessere Vorstellung zu haben, aber ich werde einige Erklärungen geben. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prozessor-Pipelines</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ermöglichen die Verarbeitung mehrerer Anweisungen in verschiedenen Phasen. Wenn die Reihenfolge ihrer Ausführung gut organisiert ist, um die Abhängigkeiten zwischen den Stufen zu verringern, kann die Verarbeitung von Anweisungen beschleunigt werden.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der superskalaren Ausführung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können Sie die Computerteile der Anweisungen gleichzeitig verarbeiten. </font><font style="vertical-align: inherit;">Dafür sollten sie jedoch keine Lese- / Schreibabhängigkeiten haben. </font><font style="vertical-align: inherit;">Sie können die Architektur anpassen, um das Risiko von Ausfallzeiten zu verringern, indem Sie lange vor dem Lesen aufzeichnen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die außergewöhnliche Ausführung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ermöglicht es dem Prozessor, Anweisungen nicht in der Reihenfolge ihrer Reihenfolge auszuführen, sondern sobald sie bereit sind, selbst wenn die vorherigen Anweisungen noch nicht bereit sind. </font><font style="vertical-align: inherit;">Dafür sollte es jedoch keine Lese- / Schreibabhängigkeit geben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt gehen wir zur Umsetzung über!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Architektur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein Schema namens Semi-SHISHUA. </font><font style="vertical-align: inherit;">Woher ein solcher Name kommt, wird beim Lesen allmählich deutlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Schema sieht folgendermaßen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd8/df1/b8f/bd8df1b8fcfae4897eb4b74f2c6e856f.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie seine Zeile für Zeile.</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct prng_state {<font></font>
  __m256i state[2];<font></font>
  __m256i output;<font></font>
  __m256i counter;<font></font>
} prng_state;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zustand ist in zwei Teile unterteilt, die im AVX2-Register abgelegt sind (256 Bit). Um die Geschwindigkeit zu erhöhen, halten wir das Ergebnis nahe am Staat selbst, aber es ist nicht Teil des Staates. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben auch einen 64-Bit-Zähler. Um die Berechnung zu vereinfachen, handelt es sich auch um ein AVX2-Register. Tatsache ist, dass AVX2 eine kleine Funktion hat: Normale Register (% rax und dergleichen) können nicht direkt über MOV auf SIMD übertragen werden, sie müssen durch RAM (meistens durch den Stapel) geleitet werden, was die Verzögerung erhöht und zwei Prozessoranweisungen kostet (MOV auf dem Stapel, VMOV vom Stapel). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun schauen wir uns die Generation an. Beginnen wir mit dem Laden, gehen wir dann durch den Puffer und füllen ihn bei jeder Iteration mit 32 Bytes.</font></font><br>
<br>
<pre><code class="plaintext hljs">inline void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size) {<font></font>
  __m256i s0 = s-&gt;state[0], counter = s-&gt;counter,<font></font>
          s1 = s-&gt;state[1],       o = s-&gt;output;<font></font>
  for (__uint64_t i = 0; i &lt; size; i += 4) {<font></font>
    _mm256_storeu_si256((__m256i*)&amp;buf[i], o);<font></font>
    // …<font></font>
  }<font></font>
  s-&gt;state[0] = s0; s-&gt;counter = counter;<font></font>
  s-&gt;state[1] = s1; s-&gt;output  = o;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Funktion inline ist, kann der Prozessor durch sofortiges Füllen des Puffers beim Start die Anweisungen in Abhängigkeit davon durch einen außergewöhnlichen Ausführungsmechanismus sofort ausführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Innerhalb der Schleife führen wir schnell drei Zustandsoperationen aus:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ft</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ffle</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dd</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher der Name SHISHUA!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erste Schicht</font></font></h3><br>
<pre><code class="plaintext hljs">u0 = _mm256_srli_epi64(s0, 1);              u1 = _mm256_srli_epi64(s1, 3);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider unterstützt der AVX2 keine Drehzahl. </font><font style="vertical-align: inherit;">Aber ich möchte die Bits einer Position in einer 64-Bit-Zahl mit den Bits einer anderen Position mischen! </font><font style="vertical-align: inherit;">Und Verschiebung ist der beste Weg, dies zu realisieren. </font><font style="vertical-align: inherit;">Wir werden um eine ungerade Zahl verschieben, so dass jedes Bit alle 64-Bit-Positionen besucht und nicht die Hälfte davon. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während der Verschiebung gehen Bits verloren, was zur Entfernung von Informationen aus unserem Zustand führt. </font><font style="vertical-align: inherit;">Das ist schlecht, Sie müssen Verluste minimieren. </font><font style="vertical-align: inherit;">Die kleinsten ungeraden Zahlen sind 1 und 3. Wir werden unterschiedliche Verschiebungswerte verwenden, um die Diskrepanz zwischen den beiden Teilen zu erhöhen. </font><font style="vertical-align: inherit;">Dies wird dazu beitragen, die Ähnlichkeit ihrer Selbstkorrelation zu verringern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden nach rechts verschieben, da die am weitesten rechts liegenden Bits während der Addition die geringste Diffusion aufweisen: Beispielsweise ist das niedrigstwertige Bit in A + B nur das XOR der niedrigstwertigen Bits A und B.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rühren</font></font></h3><br>
<pre><code class="plaintext hljs">t0 = _mm256_permutevar8x32_epi32(s0, shu0); t1 = _mm256_permutevar8x32_epi32(s1, shu1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden 32-Bit-Mixing verwenden, da es eine andere Granularität bietet als die 64-Bit-Operationen, die wir überall verwenden (die 64-Bit-Ausrichtung wird verletzt). Es kann sich auch um eine spurübergreifende Operation handeln: Andere Mischvorgänge können Bits innerhalb der linken 128 Bits verschieben, wenn sie links beginnen, oder innerhalb der rechten 128 Bits, wenn sie rechts beginnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mischkonstanten:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i shu0 = _mm256_set_epi32(4, 3, 2, 1, 0, 7, 6, 5),<font></font>
        shu1 = _mm256_set_epi32(2, 1, 0, 7, 6, 5, 4, 3);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit das Mischen das Ergebnis wirklich verbessert, verschieben wir die schwachen 32-Bit-Teile (mit geringer Streuung) von 64-Bit-Additionen an starke Positionen, damit die nächsten Additionen sie bereichern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Low-End-32-Bit-Teil des 64-Bit-Blocks bewegt sich niemals zum gleichen 64-Bit-Block wie der höherwertige Teil. </font><font style="vertical-align: inherit;">Somit bleiben beide Teile nicht im selben Block, was das Mischen verbessert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende durchläuft jeder 32-Bit-Teil alle Positionen in einem Kreis: von A nach B, von B nach C, ... von H nach A. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie haben vielleicht bemerkt, dass das einfachste Mischen, das all diese Anforderungen berücksichtigt, zwei 256-Bit-Teile sind Umsatz (Umdrehungen von 96 Bit bzw. 160 Bit nach rechts).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusatz</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen wir 64-Bit-Chunks aus zwei temporären Variablen hinzu - Shift und Mixing.</font></font><br>
<br>
<pre><code class="plaintext hljs">s0 = _mm256_add_epi64(t0, u0);              s1 = _mm256_add_epi64(t1, u1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Addition ist die Hauptquelle der Dispersion: Bei dieser Operation werden Bits zu irreduziblen Kombinationen von XOR- und AND-Ausdrücken kombiniert, die über 64-Bit-Positionen verteilt sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Speichern des Additionsergebnisses in einem Zustand bleibt diese Dispersion dauerhaft erhalten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgabefunktion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Woher bekommen wir die Ausgabe? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist ganz einfach: Die von uns erstellte Struktur ermöglicht es uns, zwei unabhängige Teile des Zustands s0 und s1 zu generieren, die sich in keiner Weise gegenseitig beeinflussen. </font><font style="vertical-align: inherit;">Wenden Sie XOR auf sie an und erhalten Sie ein völlig zufälliges Ergebnis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Unabhängigkeit zwischen den Daten zu stärken, auf die wir XOR anwenden, nehmen wir ein Teilergebnis: den verschobenen Teil eines Zustands und den gemischten Teil eines anderen.</font></font><br>
<br>
<pre><code class="plaintext hljs">o = _mm256_xor_si256(u0, t1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ähnelt dem Reduzieren der Lese- / Schreibabhängigkeiten zwischen Befehlen in einem superskalaren Prozessor, als ob u0 und t1 bereit wären, in s0 und s1 zu lesen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Besprechen Sie nun den Zähler. Wir verarbeiten es zu Beginn des Zyklus. Ändern Sie zuerst den Status und erhöhen Sie dann den Zählerwert:</font></font><br>
<br>
<pre><code class="plaintext hljs">s1 = _mm256_add_epi64(s1, counter);<font></font>
counter = _mm256_add_epi64(counter, increment);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ändern wir zuerst den Status und aktualisieren dann den Zähler? Wenn s1 früher verfügbar wird, verringert sich die Wahrscheinlichkeit, dass nachfolgende Anweisungen, die es lesen, in der Prozessor-Pipeline gestoppt werden. Diese Sequenz hilft auch, die direkte Abhängigkeit des Lese- / Schreibzählers zu vermeiden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wenden den Zähler auf s1 und nicht auf s0 an, da beide ohnehin die Ausgabe beeinflussen. S1 verliert jedoch aufgrund der Verschiebung mehr Bits, so dass es ihm hilft, nach der Verschiebung „auf die Beine zu kommen“. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zähler zeichnet den PractRand-Test möglicherweise nicht auf. Ihr einziger Zweck besteht darin, eine Untergrenze von 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69 festzulegen</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bytes = 512 Exbibytes für die PRNG-Periode: Wir beginnen den Zyklus erst nach einem Jahrtausend Arbeit mit einer Geschwindigkeit von 10 Gibytes pro Sekunde zu wiederholen. Es ist unwahrscheinlich, dass es in den kommenden Jahrhunderten für den praktischen Gebrauch zu langsam sein wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuwachs:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i increment = _mm256_set_epi64x(1, 3, 5, 7);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ungeraden Zahlen werden als Inkremente gewählt, da nur die grundlegenden Coprime-Zahlen den gesamten Zyklus des endlichen Feldes GF (2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">abdecken </font><font style="vertical-align: inherit;">und alle ungeraden Zahlen Coprime für 2 sind. Mit anderen Worten, wenn Sie um eine gerade ganze Zahl im Bereich von 0 bis inkrementieren 4, die nach 4 auf 0 zurückkehrt, ergibt die Sequenz 0-2-0-2- ..., die niemals zu 1 oder 3 führt. Und das ungerade Inkrement durchläuft alle ganzen Zahlen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für alle 64-Bit-Zahlen im Status werden unterschiedliche ungerade Zahlen verwendet, wodurch sie weiter voneinander getrennt werden und die Mischung leicht erhöht wird. </font><font style="vertical-align: inherit;">Ich habe die kleinsten ungeraden Zahlen gewählt, damit sie nicht magisch aussehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So funktionieren Zustandsübergang und Ausgabefunktion. </font><font style="vertical-align: inherit;">Wie initialisiere ich sie?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir initialisieren den Zustand mit den hexadezimalen Ziffern Φ, der irrationalen Zahl, die durch den Bruch am wenigsten angenähert wird.</font></font><br>
<br>
<pre><code class="plaintext hljs">static __uint64_t phi[8] = {<font></font>
  0x9E3779B97F4A7C15, 0xF39CC0605CEDC834, 0x1082276BF3A27251, 0xF86C6A11D0C18E95,<font></font>
  0x2767F0B153D27B7F, 0x0347045B5BF1827F, 0x01886F0928403002, 0xC1D64BA40F335E36,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen Sie einen 256-Bit-Startwert. </font><font style="vertical-align: inherit;">Dies geschieht häufig in der Kryptographie und schadet der Arbeit nicht kryptografischer PRNGs nicht:</font></font><br>
<br>
<pre><code class="plaintext hljs">prng_state prng_init(SEEDTYPE seed[4]) {<font></font>
  prng_state s;<font></font>
  // …<font></font>
  return s;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wollen nicht den gesamten Teil des Staates (s0 oder s1) mit dieser Anfangszahl neu definieren, wir müssen nur die Hälfte beeinflussen. </font><font style="vertical-align: inherit;">Auf diese Weise vermeiden wir die Verwendung der Dämpfung von Anfangszahlen, die versehentlich oder absichtlich zu einem bekannten schwachen Anfangszustand führen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da wir nicht die Hälfte jedes Zustands ändern, behalten wir die Kontrolle über 128 Statusbits. </font><font style="vertical-align: inherit;">Eine solche Entropie reicht aus, um eine starke Position einzunehmen und aufrechtzuerhalten.</font></font><br>
<br>
<pre><code class="plaintext hljs">s.state[0] = _mm256_set_epi64x(phi[3], phi[2] ^ seed[1], phi[1], phi[0] ^ seed[0]);<font></font>
s.state[1] = _mm256_set_epi64x(phi[7], phi[6] ^ seed[3], phi[5], phi[4] ^ seed[2]);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann wiederholen wir ( </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">mehrmals die </font><font style="vertical-align: inherit;">folgende Sequenz:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Führen Sie die Schritte ( </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) der SHISHUA-Iterationen aus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir weisen einen Teil des Zustands einem anderen Zustand und den anderen Teil der Ausgabe zu.</font></font></li>
</ol><br>
<pre><code class="plaintext hljs">for (char i = 0; i &lt; ROUNDS; i++) {<font></font>
  prng_gen(&amp;s, buf, 4 * STEPS);<font></font>
  s.state[0] = s.state[1];<font></font>
  s.state[1] = s.output;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Zuweisen eines Ausgabeergebnisses erhöht die Zustandsstreuung. </font><font style="vertical-align: inherit;">Während der Initialisierung spielt die zusätzliche Arbeit und Korrelation von Zuständen keine Rolle, da diese Reihe von Operationen einmal ausgeführt wird. </font><font style="vertical-align: inherit;">Wir sind nur an der Dispersion während der Initialisierung interessiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich die Auswirkung auf die Korrelation der Anfangswerte bewertet hatte, wählte ich </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font><font style="vertical-align: inherit;">für den </font><font style="vertical-align: inherit;">Wert und </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font><font style="vertical-align: inherit;">für </font><font style="vertical-align: inherit;">10. Ich berechnete die Korrelation durch Berechnung der „ungewöhnlichen“ und „verdächtigen“ Anomalien, die sich aus dem PRNG-Qualitätskontrollwerkzeug in PractRand ergeben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist aus mehreren Gründen schwierig, die Geschwindigkeit zu messen:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Taktmessung ist</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> möglicherweise nicht genau genug.</font></font></li>
<li>    <strong></strong>,      , -  ,  -,       .</li>
<li>,        .        <strong></strong>   .</li>
<li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>  </strong></a>:        ,       .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich verwende den RDTSC-Prozessorbefehl, der die Anzahl der Zyklen berechnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit jeder meine Ergebnisse reproduzieren kann, verwende ich eine Cloud-basierte virtuelle Maschine. Dies ändert nichts an der Höhe der Benchmark-Ergebnisse im Vergleich zu lokalen Tests. Außerdem müssen Sie nicht denselben Computer wie meinen kaufen. Schließlich gibt es viele Situationen, in denen das PRNG in den Clouds gestartet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe mich für Google Cloud Platform N2 (Intel-Prozessor) und N2D (AMD-Prozessor) entschieden. Der Vorteil von GCP ist, dass sie Server mit Prozessoren beider Hersteller anbieten. In diesem Artikel konzentrieren wir uns auf Intel, aber für AMD werden die Ergebnisse in derselben Reihenfolge angezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um tiefer in das Thema einzutauchen, entfernen wir zunächst den alten kryptografischen RC4-Generator. Ich konnte die Arbeit nicht parallelisieren</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7,5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Zyklen pro erzeugtem Byte). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun ein sehr beliebtes und schnelles MCG </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ausführen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Das </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">einfachste Lehmer128 PRNG</font></a><font style="vertical-align: inherit;"> , das den BigCrush-Test besteht, zeigte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wow großartig! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann werden wir die neueste Entwicklung ausführen, die für schnelle Hash-Tabellen verwendet wird - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wyrand</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,41 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etwas besser! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige PRSPs bestehen den 32-Terabyte-PractRand-Test nicht, arbeiten jedoch sehr schnell. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erreichte nur 512 Mebibyte, zeigte jedoch eine sehr hohe Geschwindigkeit: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,34 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere Neuentwicklung von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie behauptet, das schnellste PRNG der Welt zu sein - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,31 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Okay, das ist genug. </font><font style="vertical-align: inherit;">Was hat Semi-SHISHUA gezeigt? </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,14 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Zweimal so schnell wie RomuTrio.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/f7a/c9f/c84f7ac9fcbc4d4a7b2400ae552522a4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cool. </font><font style="vertical-align: inherit;">Testen Sie nun den kryptografischen Generator ChaCha8. </font><font style="vertical-align: inherit;">Er erreichte ... </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,12 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD ist echte Magie! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die kryptografische Gemeinschaft war </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dies keine besondere Überraschung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">ChaCha8 ist extrem einfach zu parallelisieren. </font><font style="vertical-align: inherit;">Dies ist nur ein gut gehashter Zähler in einem diffusen Zustand. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und erinnern Sie sich, wie das Julia-Sprachteam versucht hat, mehrere Instanzen der Vigny-Architektur zu kombinieren, um einen schnellen SIMD-basierten PRCH zu erstellen? </font><font style="vertical-align: inherit;">Schauen wir uns das Ergebnis mit dieser Technik an ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 Teile Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,09 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Technisch könnte mein Laptop die Ergebnisse beeinflussen. Ich bin mir nicht sicher, warum die Teamentwicklung von Julia in GCP schneller als ChaCha8 ist, aber langsamer, wenn sie lokal getestet wird. Auf meiner Maschine läuft semi-SHISHUA schneller als die Julia-Teamentwicklung, aber langsamer als ChaCha8. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist notwendig, alle Konkurrenten zu besiegen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie fragen sich wahrscheinlich schon, warum wir die vorherige Version des Semi-SHISHUA-Generators aufgerufen haben? Weil es sich als einfach herausstellte, die Geschwindigkeit zu verdoppeln, wenn Sie zwei Kopien von Semi-SHISHUA ausführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ähnlich wie bei der Idee des Julia-Befehls initialisieren wir zwei PRNGs (vier Blöcke mit einem 256-Bit-Zustand) separat und liefern abwechselnd die Ausgabe ihrer Arbeit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir jedoch mehr Zustände erstellen, können wir noch mehr Daten erzeugen, indem wir vier Zustände paarweise kombinieren:</font></font><br>
<br>
<pre><code class="plaintext hljs">o0 = _mm256_xor_si256(u0, t1);<font></font>
o1 = _mm256_xor_si256(u2, t3);<font></font>
o2 = _mm256_xor_si256(s0, s3);<font></font>
o3 = _mm256_xor_si256(s2, s1);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also haben wir SHISHUA bekommen, das eine Geschwindigkeit von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,06 cpb zeigte</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist doppelt so schnell wie der bisher schnellste Konkurrent der Welt, der den 32-Terabyte-PractRand-Test bestanden hat. </font><font style="vertical-align: inherit;">Das Ergebnis ist in der Grafik dargestellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich glaube, dass sich die Entwicklung als wettbewerbsfähig herausgestellt hat. </font><font style="vertical-align: inherit;">Auf meinem Laptop funktioniert es sogar noch schneller - 0,03 cpb, aber ich werde meine Grundsätze bezüglich des Benchmarks einhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoffentlich bleibt mein Generator noch ein paar Wochen auf dem Podium der schnellsten der Welt (bitte tun Sie dies).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualität</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Generator besteht ehrlich BigCrush und den 32-Terabyte-PractRand-Test. Und das alles dank vier Ausgangsströmen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu den Nachteilen der Architektur gehört ihre </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Irreversibilität</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies kann durch Reduzieren auf einen 4-Bit-Zustand mit </font></font><code>s0 = [a, b]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und gesehen werden </font></font><code>s1 = [c, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mit einer Schicht bekommen wir </font></font><code>[0, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>[0, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und mit Rühren </font></font><code>[b, c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>[d, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Neu </font></font><code>s0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleich </font></font><code>[b, c] + [0, a] = [b⊕(a∧c), a⊕c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber </font></font><code>s1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleich </font></font><code>[d, a] + [0, c] = [d⊕(a∧c), a⊕c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn </font></font><code>a = ¬c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dann </font></font><code>a⊕c = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>a∧c = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deshalb </font></font><code>s0 = [b, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>s1 = [d, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Das heißt, wir erhalten zwei Kombinationen von </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die uns den gleichen Endzustand geben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall ist dies kein Problem, da der 64-Bit-Zähler ebenfalls Teil des Status ist. Es ergibt sich der Mindestzyklus von 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">71</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bytes (128 Bytes pro Zustandsübergang) mit einer Geschwindigkeit von 10 Gibytes / Sek. </font><font style="vertical-align: inherit;">wird siebentausend Jahre dauern. </font><font style="vertical-align: inherit;">Dies gleicht die verlorenen Zustände aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich beträgt die durchschnittliche Übergangszeit zwischen Zuständen trotz Irreversibilität 2 ^ ((256 + 1) ÷ 2). </font><font style="vertical-align: inherit;">Dies ergibt einen durchschnittlichen Zyklus von </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.135</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bytes (mit einer Geschwindigkeit von 10 Gibytes / Sek. Es wird mehr als eine Billion Mal länger dauern, als das Universum existiert). </font><font style="vertical-align: inherit;">Obwohl ich glaube, dass mittlere Zyklen überschätzt werden, weil sie uns nichts über die Qualität des Generators sagen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind die Benchmark-Ergebnisse:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generator</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualität</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Samenkorrelation</font></font></strong></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHISHUA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,06</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 256 GiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 + x8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,09</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,31</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 +</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,34</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">512 MiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wyrand</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,41</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lehmer128</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,44</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RC4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.48</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
</tbody></table></div><br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leistung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die Anzahl der Prozessorzyklen, die für ein generiertes Byte aufgewendet wurden. </font><font style="vertical-align: inherit;">Auf den Cloud-Maschinen N2 GCP und N2D (AMD) empfangen, ist die Reihenfolge dieselbe.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualität</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die Stufe, bei der der Generator den PractRand-Test nicht besteht. </font><font style="vertical-align: inherit;">Wenn dies nicht fehlschlägt, gibt es ein&gt; -Zeichen. </font><font style="vertical-align: inherit;">Wenn das Ergebnis nicht bewiesen ist, gibt es ein Fragezeichen.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Korrelation der</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Startnummern: PractRand-Durchquerung mit abwechselnden Bytes von acht Streams mit den Startnummern 0, 1, 2, 4, 8, 16, 32, 64. Wir verwenden PractRand mit doppelter Faltung und erweiterten Tests.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3f6/f1d/ea73f6f1db25664622785ba127764dbc.png"></div><br>
</li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des Weiteren</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl es in unserem Fall keine Probleme mit der Irreversibilität gibt, können wir SHISHUA dennoch verbessern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meiner Meinung nach hat das ideale PRNG die folgenden Eigenschaften:</font></font><br>
<br>
<ol>
<li><strong>      </strong>,     2<sup>1024</sup>.      10 /.    10<sup>282</sup>  ,   .    «» (  ).              ,       .  ,      128-  NEON   ARM?  ,      ,     .</li>
<li><strong>    </strong>.      ,   SHISHUA  XOR    .     ,     .</li>
<li><strong>  ,</strong>      2<sup>128</sup>    (     ).        SHISHUA,  ,  .  ,      ( )    (, , .  2).</li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zustandsinitialisierung ist perfekt verteilt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Alle Bits der Anfangszahl wirken sich mit derselben Wahrscheinlichkeit auf alle Bits des Zustands aus. </font><font style="vertical-align: inherit;">Ich möchte es in Bezug auf SHISHUA herausfinden.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eines der Probleme, die die Entwicklung von PRNGs und der Kryptographie insgesamt behindern, ist das Fehlen besserer Allzweckwerkzeuge. </font><font style="vertical-align: inherit;">Ich benötige ein Tool, mit dem ich sofort das genaue Messergebnis erhalten kann, damit ich verschiedene Architekturen im laufenden Betrieb vergleichen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PractRand ist jedoch großartig im Vergleich zu früher:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es erlaubt keine Bewertung hochwertiger Generatoren, so dass es unmöglich ist, sie miteinander zu vergleichen. </font><font style="vertical-align: inherit;">Wir müssen sagen: "Nun, nach 32 Terabyte haben sie keine Anomalien ..."</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es dauert Wochen, um es auszuführen ...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, dass sich die Situation bald erheblich verbessern wird.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de498332/index.html">Implementierung einer vertrauenswürdigen Sicherheitsarchitektur: Zweite Ausgabe</a></li>
<li><a href="../de498334/index.html">So organisieren Sie den Planungsprozess in der SAP Analytics Cloud</a></li>
<li><a href="../de498340/index.html">Über das neue IDA Home (Bewertung)</a></li>
<li><a href="../de498346/index.html">GoLand 2020.1 - Verbesserte Unterstützung für Go-Module, viel automatische Vervollständigung und vieles mehr</a></li>
<li><a href="../de498350/index.html">Die besten Materialien für Vorstellungsgespräche und Jobsuche</a></li>
<li><a href="../de498354/index.html">Wie man "Wunschliste" in "Hardware" oder halbidealen halbmobilen Semi-Desktop übersetzt</a></li>
<li><a href="../de498358/index.html">Lernen Sie Französisch oder wie Sie einen Universaladapter von einem PSA-Diagnosescanner erhalten</a></li>
<li><a href="../de498360/index.html">Auswertung der integrierten Serverlastmetriken</a></li>
<li><a href="../de498362/index.html">Kingston ist weiterhin führend bei SSD-Sendungen: Wie machen wir das?</a></li>
<li><a href="../de498366/index.html">Welche Algorithmen implementieren Yandex-Entwickler täglich?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>