<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◽️ 👩‍👩‍👧 👩🏼‍🎨 Previsão de séries temporais usando redes neurais recorrentes 🐂 ✋ 👌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O modo remoto de operação no contexto do auto-isolamento universal pode levar a consequências muito ruins. E desgaste emocional - ainda é para onde qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Previsão de séries temporais usando redes neurais recorrentes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495884/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O modo remoto de operação no contexto do auto-isolamento universal pode levar a consequências muito ruins. E desgaste emocional - ainda é para onde quer que vá: afinal, não está longe do telhado. Nesse sentido, como muitos, ele tentou se acalmar alocando tempo para outras aulas - e começou a traduzir os artigos mais interessantes do inglês para o russo: "Você dá </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aprendizado de máquina</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> às massas!".) Devemos prestar homenagem: é uma grande distração. Se você tiver sugestões para o conteúdo semântico e a tradução deste texto para um leitor de língua russa, participe da discussão.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3d7/fe4/946/3d7fe49466cad76814b37e73ec1bc49a.jpg" alt="imagem"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então, aqui está uma tradução da página de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">previsão de séries</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> temporais da seção manual do tensorflow: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Minhas adições, juntamente com ilustrações para a tradução, visam ajudar a entender as idéias básicas em uma das áreas mais interessantes de ML e econometria em séries gerais de previsão. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma pequena introdução antes da tradução. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O manual é uma descrição da previsão da temperatura do ar com base em séries temporais unidimensionais </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> séries </font><i><font style="vertical-align: inherit;">temporais univariadas)</font></i><font style="vertical-align: inherit;"> e séries </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temporais multivariadas (</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> séries </font><i><font style="vertical-align: inherit;">temporais multivariadas)</font></i><font style="vertical-align: inherit;"> . Para cada parte, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">insira dados</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve ser preparado em conformidade. Levando em consideração o conjunto de dados meteorológicos considerado neste guia, a separação é a seguinte: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8fa/31a/a75/8fa31aa7531d8589dcee2ae93454a430.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para perguntas sobre o que levar para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e o que para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou seja, como preparar dados para a classe de treinamento supervisionado, ficará claro nas ilustrações a seguir. Observo apenas que a formação do vetor alvo (Y) para trabalhar com séries temporais unidimensionais e multidimensionais é a mesma: o vetor alvo é compilado com base no sinal </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T (degC)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(temperatura do ar). A diferença entre eles é "enterrada" na formação de um conjunto de recursos que são alimentados à entrada do modelo: no caso de uma série temporal unidimensional para prever a temperatura no futuro, o vetor de entrada (X) consiste em uma característica: na verdade, temperatura do ar; e para multidimensional - mais de um: além da temperatura do ar, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p (mbar)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (pressão atmosférica) e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rho (g / m ** 3)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (umidade) </font><font style="vertical-align: inherit;">são usados ​​no exemplo do manual em questão </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A princípio, um exemplo muito raso, com previsão de temperatura, parece pouco convincente do ponto de vista do uso de uma entrada multidimensional: para previsão de temperatura, o sinal mais relevante será a temperatura. No entanto, este não é absolutamente o caso: para desenvolver uma previsão qualitativa da temperatura do ar, muitos fatores devem ser levados em consideração, até a fricção do ar na superfície da terra, etc. Além disso, na prática, algumas coisas estão longe de serem óbvias, e o vetor alvo pode estar na forma dessa mistura (ou borsch). Nesse sentido, a análise exploratória de dados com a seleção dos recursos mais relevantes para a formação subsequente de uma entrada multidimensional é a única decisão correta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, a tradução do manual é apresentada abaixo. Texto adicional estará </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em itálico</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previsão de Séries Temporais</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este guia é uma introdução à previsão de séries temporais usando redes neurais recorrentes (RNS, da </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rede Neural Recorrente em</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inglês </font><i><font style="vertical-align: inherit;">, RNN</font></i><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Consiste em duas partes: a primeira descreve a previsão da temperatura do ar com base em uma série temporal unidimensional e a segunda - com base em uma série temporal multidimensional.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<font></font>
<font></font>
<span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
mpl.rcParams[<span class="hljs-string">'figure.figsize'</span>] = (<span class="hljs-number">8</span>, <span class="hljs-number">6</span>)<font></font>
mpl.rcParams[<span class="hljs-string">'axes.grid'</span>] = <span class="hljs-literal">False</span>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um conjunto de dados meteorológicos</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Todos os exemplos do manual usam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seqüências temporais de dados meteorológicos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gravados em uma estação hidrometeorológica no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instituto de Biogeoquímica com o nome de </font><font style="vertical-align: inherit;">Max Planck</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse conjunto de dados inclui medições de 14 indicadores meteorológicos diferentes (como temperatura do ar, pressão atmosférica, umidade), realizados a cada 10 minutos desde 2003. </font><font style="vertical-align: inherit;">Para economizar tempo e uso de memória, o manual utilizará dados que abrangem o período de 2009 a 2016. </font><font style="vertical-align: inherit;">Esta seção do conjunto de dados foi preparada por François Chollet para seu livro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deep Learning with Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs">zip_path = tf.keras.utils.get_file(<font></font>
    origin=<span class="hljs-string">'https://storage.googleapis.com/tensorflow/tf-keras-datasets/jena_climate_2009_2016.csv.zip'</span>,<font></font>
    fname=<span class="hljs-string">'jena_climate_2009_2016.csv.zip'</span>,<font></font>
    extract=<span class="hljs-literal">True</span>)<font></font>
csv_path, _ = os.path.splitext(zip_path)<font></font>
</code></pre><br>
<pre><code class="python hljs">df = pd.read_csv(csv_path)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver o que temos.</font></font><br>
<br>
<pre><code class="python hljs">df.head()
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/d5d/bfa/539/d5dbfa539de3da5ca04103b2db380a70.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O fato de o período de gravação da observação ser de 10 minutos pode ser verificado na tabela acima. Assim, em uma hora você terá 6 observações. Por sua vez, 144 (6x24) observações são acumuladas por dia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que você queira prever a temperatura, que será em 6 horas no futuro. Você faz essa previsão com base nos dados que possui por um determinado período: por exemplo, decide usar 5 dias de observação. Portanto, para treinar o modelo, você deve criar um intervalo de tempo contendo as últimas observações de 720 (5x144) (uma vez que são possíveis configurações diferentes, esse conjunto de dados é uma boa base para experiências). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A função abaixo retorna os intervalos de tempo acima para treinar o modelo. Argumento</font></font><code>history_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- este é o tamanho do último intervalo de tempo </font></font><code>target_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">um argumento que determina até que ponto o modelo o futuro deve aprender a prever. </font><font style="vertical-align: inherit;">Em outras palavras, </font></font><code>target_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é o vetor de destino que precisa ser previsto.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">univariate_data</span>(<span class="hljs-params">dataset, start_index, end_index, history_size, target_size</span>):</span><font></font>
  data = []<font></font>
  labels = []<font></font>
<font></font>
  start_index = start_index + history_size<font></font>
  <span class="hljs-keyword">if</span> end_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
    end_index = len(dataset) - target_size<font></font>
<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_index, end_index):<font></font>
    indices = range(i-history_size, i)<font></font>
    <span class="hljs-comment"># Reshape data from (history_size,) to (history_size, 1)</span>
    data.append(np.reshape(dataset[indices], (history_size, <span class="hljs-number">1</span>)))<font></font>
    labels.append(dataset[i+target_size])<font></font>
  <span class="hljs-keyword">return</span> np.array(data), np.array(labels)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nas duas partes do manual, as primeiras 300.000 linhas de dados serão usadas para treinar o modelo, e as demais para validá-lo (validar). </font><font style="vertical-align: inherit;">Nesse caso, a quantidade de dados de treinamento é de aproximadamente 2100 dias.</font></font><br>
<br>
<pre><code class="python hljs">TRAIN_SPLIT = <span class="hljs-number">300000</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para garantir resultados reproduzíveis, a função de semente está definida.</font></font><br>
<br>
<pre><code class="python hljs">tf.random.set_seed(<span class="hljs-number">13</span>)
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 1. Previsão baseada em uma série temporal unidimensional</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na primeira parte, você treinará o modelo usando apenas um atributo - temperatura; </font><font style="vertical-align: inherit;">o modelo treinado será usado para prever temperaturas futuras. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para começar, extraímos apenas a temperatura do conjunto de dados.</font></font><br>
<br>
<pre><code class="python hljs">uni_data = df[<span class="hljs-string">'T (degC)'</span>]<font></font>
uni_data.index = df[<span class="hljs-string">'Date Time'</span>]<font></font>
uni_data.head()<font></font>
</code></pre><br>
<code>Date Time<br>
01.01.2009 00:10:00 -8.02<br>
01.01.2009 00:20:00 -8.41<br>
01.01.2009 00:30:00 -8.51<br>
01.01.2009 00:40:00 -8.31<br>
01.01.2009 00:50:00 -8.27<br>
Name: T (degC), dtype: float64<br>
</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E vamos ver como esses dados mudam com o tempo.</font></font><br>
<br>
<pre><code class="python hljs">uni_data.plot(subplots=<span class="hljs-literal">True</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/208/b35/242/208b35242d3ce1ed30bd25d12d956703.jpg" alt="imagem"><br>
<br>
<pre><code class="python hljs">uni_data = uni_data.values
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de treinar uma rede neural artificial (doravante - RNA), uma etapa importante é a escala de dados. </font><font style="vertical-align: inherit;">Uma das maneiras comuns de executar o dimensionamento é a padronização ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">padronização</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), realizada subtraindo a média e dividindo pelo desvio padrão para cada característica. </font><font style="vertical-align: inherit;">Você também pode usar um método </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">tf.keras.utils.normalize</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que dimensiona valores para o intervalo [0,1]. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : a padronização deve ser realizada apenas com dados de treinamento.</font></font><br>
<br>
<pre><code class="python hljs">uni_train_mean = uni_data[:TRAIN_SPLIT].mean()<font></font>
uni_train_std = uni_data[:TRAIN_SPLIT].std()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Realizamos padronização de dados.</font></font><br>
<br>
<pre><code class="python hljs">uni_data = (uni_data-uni_train_mean)/uni_train_std
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, prepararemos os dados para o modelo com uma entrada unidimensional. </font><font style="vertical-align: inherit;">As últimas 20 observações registradas da temperatura serão alimentadas na entrada do modelo, e o modelo deve ser treinado para prever a temperatura no próximo passo.</font></font><br>
<br>
<pre><code class="python hljs">univariate_past_history = <span class="hljs-number">20</span>
univariate_future_target = <span class="hljs-number">0</span><font></font>
<font></font>
x_train_uni, y_train_uni = univariate_data(uni_data, <span class="hljs-number">0</span>, TRAIN_SPLIT,<font></font>
                                           univariate_past_history,<font></font>
                                           univariate_future_target)<font></font>
x_val_uni, y_val_uni = univariate_data(uni_data, TRAIN_SPLIT, <span class="hljs-literal">None</span>,<font></font>
                                       univariate_past_history,<font></font>
                                       univariate_future_target)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os resultados da aplicação da função </font></font><code>univariate_data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history'</span>)
<span class="hljs-keyword">print</span> (x_train_uni[<span class="hljs-number">0</span>])
<span class="hljs-keyword">print</span> (<span class="hljs-string">'\n Target temperature to predict'</span>)
<span class="hljs-keyword">print</span> (y_train_uni[<span class="hljs-number">0</span>])
</code></pre><br>
<code>Single window of past history<br>
[[-1.99766294]<br>
 [-2.04281897]<br>
 [-2.05439744]<br>
 [-2.0312405 ]<br>
 [-2.02660912]<br>
 [-2.00113649]<br>
 [-1.95134907]<br>
 [-1.95134907]<br>
 [-1.98492663]<br>
 [-2.04513467]<br>
 [-2.08334362]<br>
 [-2.09723778]<br>
 [-2.09376424]<br>
 [-2.09144854]<br>
 [-2.07176515]<br>
 [-2.07176515]<br>
 [-2.07639653]<br>
 [-2.08913285]<br>
 [-2.09260639]<br>
 [-2.10418486]]<br>
<br>
Target temperature to predict<br>
-2.1041848598100876<br>
</code><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além disso: a preparação de dados para um modelo com uma entrada unidimensional é mostrada esquematicamente na figura a seguir (por conveniência, nesta e nas figuras subseqüentes, os dados são apresentados em forma "bruta", antes da padronização e também sem o atributo 'Data e hora' como índice):</font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fa0/d0f/530/fa0d0f530b3496324425eeb5e52baff7.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Agora que os dados adequadamente preparado, considere um exemplo concreto. </font><font style="vertical-align: inherit;">As informações transmitidas à RNA são destacadas em azul; uma cruz vermelha indica o valor futuro que a RNA deve prever.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_time_steps</span>(<span class="hljs-params">length</span>):</span>
  <span class="hljs-keyword">return</span> list(range(-length, <span class="hljs-number">0</span>))
</code></pre><br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_plot</span>(<span class="hljs-params">plot_data, delta, title</span>):</span>
  labels = [<span class="hljs-string">'History'</span>, <span class="hljs-string">'True Future'</span>, <span class="hljs-string">'Model Prediction'</span>]<font></font>
  marker = [<span class="hljs-string">'.-'</span>, <span class="hljs-string">'rx'</span>, <span class="hljs-string">'go'</span>]<font></font>
  time_steps = create_time_steps(plot_data[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>])
  <span class="hljs-keyword">if</span> delta:<font></font>
    future = delta<font></font>
  <span class="hljs-keyword">else</span>:<font></font>
    future = <span class="hljs-number">0</span><font></font>
<font></font>
  plt.title(title)<font></font>
  <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> enumerate(plot_data):
    <span class="hljs-keyword">if</span> i:<font></font>
      plt.plot(future, plot_data[i], marker[i], markersize=<span class="hljs-number">10</span>,<font></font>
               label=labels[i])<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
      plt.plot(time_steps, plot_data[i].flatten(), marker[i], label=labels[i])<font></font>
  plt.legend()<font></font>
  plt.xlim([time_steps[<span class="hljs-number">0</span>], (future+<span class="hljs-number">5</span>)*<span class="hljs-number">2</span>])<font></font>
  plt.xlabel(<span class="hljs-string">'Time-Step'</span>)
  <span class="hljs-keyword">return</span> plt
</code></pre><br>
<pre><code class="python hljs">show_plot([x_train_uni[<span class="hljs-number">0</span>], y_train_uni[<span class="hljs-number">0</span>]], <span class="hljs-number">0</span>, <span class="hljs-string">'Sample Example'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/589/38c/574/58938c5740abfb08ed0074a1233f512f.jpg" alt="imagem"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solução básica (sem envolver o aprendizado de máquina)</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Antes de iniciar o treinamento do modelo, instalaremos uma solução básica simples ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linha de base</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ele consiste no seguinte: para um determinado vetor de entrada, o método básico da solução “varre” o histórico inteiro e prediz o próximo valor como a média das últimas 20 observações.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">baseline</span>(<span class="hljs-params">history</span>):</span>
  <span class="hljs-keyword">return</span> np.mean(history)
</code></pre><br>
<pre><code class="python hljs">show_plot([x_train_uni[<span class="hljs-number">0</span>], y_train_uni[<span class="hljs-number">0</span>], baseline(x_train_uni[<span class="hljs-number">0</span>])], <span class="hljs-number">0</span>,
           <span class="hljs-string">'Baseline Prediction Example'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/bed/941/0ef/bed9410ef6b96ad25ab68a0a3ebac05a.jpg" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver se podemos superar o resultado da "média" usando uma rede neural recorrente. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rede Neural Recorrente Uma</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
rede neural recorrente (RNS) é um tipo de RNA que é adequada para resolver problemas de séries temporais. O RNS processa passo a passo a sequência temporal dos dados, classificando seus elementos e preservando o estado interno obtido pelo processamento dos elementos anteriores. Você pode encontrar mais informações sobre o RNS no seguinte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Este guia utilizará uma camada especializada de RNC chamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Long Short-Term Memory ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSTM</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uso adicional</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">tf.data</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aleatório, lote e cache do conjunto de dados. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adição: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais sobre os métodos de shuffle, batch e cache na página </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tensorflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font></i><br>
<br>
<pre><code class="python hljs">BATCH_SIZE = <span class="hljs-number">256</span>
BUFFER_SIZE = <span class="hljs-number">10000</span><font></font>
<font></font>
train_univariate = tf.data.Dataset.from_tensor_slices((x_train_uni, y_train_uni))<font></font>
train_univariate = train_univariate.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_univariate = tf.data.Dataset.from_tensor_slices((x_val_uni, y_val_uni))<font></font>
val_univariate = val_univariate.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A visualização a seguir deve ajudá-lo a entender como são os dados após o processamento em lote. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/002/e4b/3ed/002e4b3ed48fa5d17f34ccee2cbfc40d.jpg" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pode-se observar que o LSTM requer uma certa forma de entrada de dados, que é fornecida a ele.</font></font><br>
<br>
<pre><code class="python hljs">simple_lstm_model = tf.keras.models.Sequential([<font></font>
    tf.keras.layers.LSTM(<span class="hljs-number">8</span>, input_shape=x_train_uni.shape[<span class="hljs-number">-2</span>:]),<font></font>
    tf.keras.layers.Dense(<span class="hljs-number">1</span>)<font></font>
])<font></font>
<font></font>
simple_lstm_model.compile(optimizer=<span class="hljs-string">'adam'</span>, loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verifique a saída do modelo.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_univariate.take(<span class="hljs-number">1</span>):<font></font>
    print(simple_lstm_model.predict(x).shape)<font></font>
</code></pre><br>
<code>(256, 1)<br>
</code><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adição: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
em termos gerais, os RNSs trabalham com sequências. </font><font style="vertical-align: inherit;">Isso significa que os dados fornecidos para a entrada do modelo devem ter o seguinte formato: </font></font><br>
<br>
<code>[,  , - ]</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A forma dos dados de treinamento para o modelo com uma entrada unidimensional possui o seguinte formato:</font></font></i><br>
<br>
<code>print(x_train_uni.shape)<br>
(299980, 20, 1)</code><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A seguir, estudaremos o modelo. </font><font style="vertical-align: inherit;">Devido ao grande tamanho do conjunto de dados e para economizar tempo, cada época passará apenas por 200 etapas ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">steps_per_epoch = 200</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) em vez dos dados completos do treinamento, como geralmente é feito.</font></font><br>
<br>
<pre><code class="python hljs">EVALUATION_INTERVAL = <span class="hljs-number">200</span>
EPOCHS = <span class="hljs-number">10</span><font></font>
<font></font>
simple_lstm_model.fit(train_univariate, epochs=EPOCHS,<font></font>
                      steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                      validation_data=val_univariate, validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 2s 11ms/step - loss: 0.4075 - val_loss: 0.1351<br>
Epoch 2/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.1118 - val_loss: 0.0360<br>
Epoch 3/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0490 - val_loss: 0.0289<br>
Epoch 4/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0444 - val_loss: 0.0257<br>
Epoch 5/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0299 - val_loss: 0.0235<br>
Epoch 6/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0317 - val_loss: 0.0224<br>
Epoch 7/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0287 - val_loss: 0.0206<br>
Epoch 8/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0263 - val_loss: 0.0200<br>
Epoch 9/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0254 - val_loss: 0.0182<br>
Epoch 10/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0228 - val_loss: 0.0174<br>
</code><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previsão usando um modelo LSTM simples</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Após concluir a preparação de um modelo LSTM simples, faremos várias previsões.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_univariate.take(<span class="hljs-number">3</span>):<font></font>
  plot = show_plot([x[<span class="hljs-number">0</span>].numpy(), y[<span class="hljs-number">0</span>].numpy(),<font></font>
                    simple_lstm_model.predict(x)[<span class="hljs-number">0</span>]], <span class="hljs-number">0</span>, <span class="hljs-string">'Simple LSTM model'</span>)<font></font>
  plot.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/cf8/0f6/810/cf80f681038da62889884ae5de86722d.jpg" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece melhor que o nível base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora que você se familiarizou com o básico, vamos para a segunda parte, que descreve o trabalho com uma série temporal multidimensional.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 2: Previsão multidimensional de séries temporais</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como afirmado, o conjunto de dados original contém 14 indicadores meteorológicos diferentes. </font><font style="vertical-align: inherit;">Por simplicidade e conveniência, na segunda parte, apenas três são considerados - temperatura do ar, pressão atmosférica e densidade do ar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para usar mais recursos, seus nomes devem ser adicionados à lista </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">feature_considered</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs">features_considered = [<span class="hljs-string">'p (mbar)'</span>, <span class="hljs-string">'T (degC)'</span>, <span class="hljs-string">'rho (g/m**3)'</span>]
</code></pre><br>
<pre><code class="python hljs">features = df[features_considered]<font></font>
features.index = df[<span class="hljs-string">'Date Time'</span>]<font></font>
features.head()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/1f8/589/b51/1f8589b51d64dcd9ba10e5f072df503e.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver como esses indicadores mudam com o tempo.</font></font><br>
<br>
<pre><code class="python hljs">features.plot(subplots=<span class="hljs-literal">True</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/7be/266/b59/7be266b59f38be1e4c365ee8562dffcd.jpg" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como antes, o primeiro passo é padronizar o conjunto de dados com o cálculo do valor médio e desvio padrão dos dados de treinamento.</font></font><br>
<br>
<pre><code class="python hljs">dataset = features.values<font></font>
data_mean = dataset[:TRAIN_SPLIT].mean(axis=<span class="hljs-number">0</span>)<font></font>
data_std = dataset[:TRAIN_SPLIT].std(axis=<span class="hljs-number">0</span>)
</code></pre><br>
<pre><code class="python hljs">dataset = (dataset-data_mean)/data_std
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adição: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais adiante neste manual, falaremos sobre previsão de pontos e intervalos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A linha inferior é a seguinte. Se você precisar que o modelo preveja um valor no futuro (por exemplo, o valor da temperatura após 12 horas) (modelo de uma etapa / etapa única), será necessário treinar o modelo para que ele preveja apenas um valor no futuro. Se a tarefa é prever o intervalo de valores no futuro (por exemplo, temperaturas por hora nas próximas 12 horas) (modelo de várias etapas), o modelo também deve ser treinado para prever o intervalo de valores no futuro. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/906/953/08e/90695308e69c21c37e772d98553209a4.png" alt="imagem"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previsão de pontos</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nesse caso, o modelo é treinado para prever um valor no futuro com base em algum histórico disponível.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A função abaixo executa a mesma tarefa de organizar intervalos de tempo apenas com a diferença de que aqui ela seleciona as observações mais recentes com base em um determinado tamanho de etapa.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multivariate_data</span>(<span class="hljs-params">dataset, target, start_index, end_index, history_size,
                      target_size, step, single_step=False</span>):</span><font></font>
  data = []<font></font>
  labels = []<font></font>
<font></font>
  start_index = start_index + history_size<font></font>
  <span class="hljs-keyword">if</span> end_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
    end_index = len(dataset) - target_size<font></font>
<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_index, end_index):<font></font>
    indices = range(i-history_size, i, step)<font></font>
    data.append(dataset[indices])<font></font>
<font></font>
    <span class="hljs-keyword">if</span> single_step:<font></font>
      labels.append(target[i+target_size])<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
      labels.append(target[i:i+target_size])<font></font>
<font></font>
  <span class="hljs-keyword">return</span> np.array(data), np.array(labels)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste guia, a ANN opera com dados dos últimos cinco (5) dias, ou seja, 720 observações (6x24x5). </font><font style="vertical-align: inherit;">Suponha que a seleção dos dados seja realizada não a cada 10 minutos, mas a cada hora: em 60 minutos, não são esperadas mudanças bruscas. </font><font style="vertical-align: inherit;">Portanto, a história dos últimos cinco dias consiste em 120 observações (720/6). </font><font style="vertical-align: inherit;">Para um modelo que realiza previsão de pontos, o objetivo é ler a temperatura após 12 horas no futuro. </font><font style="vertical-align: inherit;">Nesse caso, o vetor alvo será a temperatura após 72 (12x6) observações ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consulte a seguinte adição. - Tradutor aprox.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<pre><code class="python hljs">past_history = <span class="hljs-number">720</span>
future_target = <span class="hljs-number">72</span>
STEP = <span class="hljs-number">6</span><font></font>
<font></font>
x_train_single, y_train_single = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<font></font>
                                                   TRAIN_SPLIT, past_history,<font></font>
                                                   future_target, STEP,<font></font>
                                                   single_step=<span class="hljs-literal">True</span>)<font></font>
x_val_single, y_val_single = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>],<font></font>
                                               TRAIN_SPLIT, <span class="hljs-literal">None</span>, past_history,<font></font>
                                               future_target, STEP,<font></font>
                                               single_step=<span class="hljs-literal">True</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verifique o intervalo de tempo.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history : {}'</span>.format(x_train_single[<span class="hljs-number">0</span>].shape))
</code></pre><br>
<code>Single window of past history : (120, 3)<br>
</code><br>
<pre><code class="python hljs">train_data_single = tf.data.Dataset.from_tensor_slices((x_train_single, y_train_single))<font></font>
train_data_single = train_data_single.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_data_single = tf.data.Dataset.from_tensor_slices((x_val_single, y_val_single))<font></font>
val_data_single = val_data_single.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br>
<pre><code class="python hljs">single_step_model = tf.keras.models.Sequential()<font></font>
single_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">32</span>,<font></font>
                                           input_shape=x_train_single.shape[<span class="hljs-number">-2</span>:]))<font></font>
single_step_model.add(tf.keras.layers.Dense(<span class="hljs-number">1</span>))<font></font>
<font></font>
single_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(), loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verificaremos nossa amostra e derivaremos as curvas de perda nas etapas de treinamento e verificação.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_single.take(<span class="hljs-number">1</span>):<font></font>
  print(single_step_model.predict(x).shape)<font></font>
</code></pre><br>
<code>(256, 1)<br>
</code><br>
<pre><code class="python hljs">single_step_history = single_step_model.fit(train_data_single, epochs=EPOCHS,<font></font>
                                            steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                                            validation_data=val_data_single,<font></font>
                                            validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 4s 18ms/step - loss: 0.3090 - val_loss: 0.2646<br>
Epoch 2/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2624 - val_loss: 0.2435<br>
Epoch 3/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2616 - val_loss: 0.2472<br>
Epoch 4/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2567 - val_loss: 0.2442<br>
Epoch 5/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2263 - val_loss: 0.2346<br>
Epoch 6/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2416 - val_loss: 0.2643<br>
Epoch 7/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2411 - val_loss: 0.2577<br>
Epoch 8/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2410 - val_loss: 0.2388<br>
Epoch 9/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2447 - val_loss: 0.2485<br>
Epoch 10/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2388 - val_loss: 0.2422<br>
</code><br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_train_history</span>(<span class="hljs-params">history, title</span>):</span>
  loss = history.history[<span class="hljs-string">'loss'</span>]<font></font>
  val_loss = history.history[<span class="hljs-string">'val_loss'</span>]<font></font>
<font></font>
  epochs = range(len(loss))<font></font>
<font></font>
  plt.figure()<font></font>
<font></font>
  plt.plot(epochs, loss, <span class="hljs-string">'b'</span>, label=<span class="hljs-string">'Training loss'</span>)<font></font>
  plt.plot(epochs, val_loss, <span class="hljs-string">'r'</span>, label=<span class="hljs-string">'Validation loss'</span>)<font></font>
  plt.title(title)<font></font>
  plt.legend()<font></font>
<font></font>
  plt.show()<font></font>
</code></pre><br>
<pre><code class="python hljs">plot_train_history(single_step_history,
                   <span class="hljs-string">'Single Step Training and validation loss'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/baa/481/4df/baa4814df5d278c7be5a4daf629ec8e0.jpg" alt="imagem"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adição: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A preparação de dados para um modelo com uma entrada multidimensional executando a previsão de pontos é mostrada esquematicamente na figura a seguir. </font><font style="vertical-align: inherit;">Por conveniência e uma representação mais visual da preparação dos dados, o argumento </font></font><code>STEP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é 1. Observe que nas funções geradoras fornecidas, o </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">argumento é </font></font><code>STEP </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destinado apenas à formação da história</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e não ao vetor de destino. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfd/c0b/ef1/bfdc0bef1203da6840adcb4311455645.png" alt="imagem"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste caso, ele </font></font><code>x_train_single</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tem a forma </font></font><code>(299280, 720, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando </font></font><code>STEP=6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o formulário assumirá o seguinte formato: </font></font><code>(299280, 120, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a velocidade da função aumentará significativamente. </font><font style="vertical-align: inherit;">Em geral, você precisa dar crédito ao programador: os geradores apresentados no manual são muito vorazes em termos de consumo de memória. </font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Executando uma previsão de ponto</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora que o modelo foi treinado, executaremos várias previsões de teste. O histórico de observações de três sinais nos últimos cinco dias, selecionado a cada hora (intervalo de tempo = 120), é alimentado na entrada do modelo. Como nosso objetivo é prever apenas a temperatura, os valores anteriores da temperatura ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">histórico</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) são </font><font style="vertical-align: inherit;">exibidos em azul no gráfico </font><font style="vertical-align: inherit;">. A previsão foi feita meio dia no futuro (daí a diferença entre a história e o valor previsto).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_single.take(<span class="hljs-number">3</span>):<font></font>
  plot = show_plot([x[<span class="hljs-number">0</span>][:, <span class="hljs-number">1</span>].numpy(), y[<span class="hljs-number">0</span>].numpy(),<font></font>
                    single_step_model.predict(x)[<span class="hljs-number">0</span>]], <span class="hljs-number">12</span>,
                   <span class="hljs-string">'Single Step Prediction'</span>)<font></font>
  plot.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/6ac/a5b/ce3/6aca5bce3fef9de56f1fac299da5527c.jpg" alt="imagem"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previsão de intervalo</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nesse caso, com base em algum histórico disponível, o modelo é treinado para prever o intervalo de valores futuros. </font><font style="vertical-align: inherit;">Assim, ao contrário de um modelo que prevê apenas um valor no futuro, esse modelo prevê uma sequência de valores no futuro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que, como no caso do modelo que executa a previsão de pontos, os dados de treinamento sejam as medidas horárias dos últimos cinco dias (720/6). </font><font style="vertical-align: inherit;">No entanto, nesse caso, o modelo deve ser treinado para prever a temperatura pelas próximas 12 horas. </font><font style="vertical-align: inherit;">Como as observações são registradas a cada 10 minutos, a saída do modelo deve consistir em 72 previsões. </font><font style="vertical-align: inherit;">Para concluir esta tarefa, é necessário preparar o conjunto de dados novamente, mas com um intervalo de destino diferente.</font></font><br>
<br>
<pre><code class="python hljs">future_target = <span class="hljs-number">72</span>
x_train_multi, y_train_multi = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<font></font>
                                                 TRAIN_SPLIT, past_history,<font></font>
                                                 future_target, STEP)<font></font>
x_val_multi, y_val_multi = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>],<font></font>
                                             TRAIN_SPLIT, <span class="hljs-literal">None</span>, past_history,<font></font>
                                             future_target, STEP)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verifique a seleção.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history : {}'</span>.format(x_train_multi[<span class="hljs-number">0</span>].shape))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'\n Target temperature to predict : {}'</span>.format(y_train_multi[<span class="hljs-number">0</span>].shape))
</code></pre><br>
<code>Single window of past history : (120, 3)<br>
<br>
Target temperature to predict : (72,)<br>
</code><br>
<pre><code class="python hljs">train_data_multi = tf.data.Dataset.from_tensor_slices((x_train_multi, y_train_multi))<font></font>
train_data_multi = train_data_multi.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_data_multi = tf.data.Dataset.from_tensor_slices((x_val_multi, y_val_multi))<font></font>
val_data_multi = val_data_multi.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adição: a diferença na formação do vetor alvo para o "modelo de intervalo" do "modelo de ponto" é vista na figura a seguir. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/190/5c6/845/1905c6845d2746a1f0bc6ae88f913b99.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos preparar a visualização.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multi_step_plot</span>(<span class="hljs-params">history, true_future, prediction</span>):</span>
  plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<font></font>
  num_in = create_time_steps(len(history))<font></font>
  num_out = len(true_future)<font></font>
<font></font>
  plt.plot(num_in, np.array(history[:, <span class="hljs-number">1</span>]), label=<span class="hljs-string">'History'</span>)<font></font>
  plt.plot(np.arange(num_out)/STEP, np.array(true_future), <span class="hljs-string">'bo'</span>,<font></font>
           label=<span class="hljs-string">'True Future'</span>)
  <span class="hljs-keyword">if</span> prediction.any():<font></font>
    plt.plot(np.arange(num_out)/STEP, np.array(prediction), <span class="hljs-string">'ro'</span>,<font></font>
             label=<span class="hljs-string">'Predicted Future'</span>)<font></font>
  plt.legend(loc=<span class="hljs-string">'upper left'</span>)<font></font>
  plt.show()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste e em gráficos similares subsequentes, o histórico e os dados futuros são de hora em hora.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> train_data_multi.take(<span class="hljs-number">1</span>):<font></font>
  multi_step_plot(x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>], np.array([<span class="hljs-number">0</span>]))
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/245/beb/236/245beb236bc1f87f2d611ce8d2c0bc81.jpg" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como essa tarefa é um pouco mais complicada que a anterior, o modelo consistirá em duas camadas LSTM. </font><font style="vertical-align: inherit;">Finalmente, uma vez que são realizadas 72 previsões, a camada de saída possui 72 neurônios.</font></font><br>
<br>
<pre><code class="python hljs">multi_step_model = tf.keras.models.Sequential()<font></font>
multi_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">32</span>,<font></font>
                                          return_sequences=<span class="hljs-literal">True</span>,<font></font>
                                          input_shape=x_train_multi.shape[<span class="hljs-number">-2</span>:]))<font></font>
multi_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">16</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
multi_step_model.add(tf.keras.layers.Dense(<span class="hljs-number">72</span>))<font></font>
<font></font>
multi_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(clipvalue=<span class="hljs-number">1.0</span>), loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verificaremos nossa amostra e derivaremos as curvas de perda nas etapas de treinamento e verificação.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_multi.take(<span class="hljs-number">1</span>):
  <span class="hljs-keyword">print</span> (multi_step_model.predict(x).shape)
</code></pre><br>
<code>(256, 72)<br>
</code><br>
<pre><code class="python hljs">multi_step_history = multi_step_model.fit(train_data_multi, epochs=EPOCHS,<font></font>
                                          steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                                          validation_data=val_data_multi,<font></font>
                                          validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 21s 103ms/step - loss: 0.4952 - val_loss: 0.3008<br>
Epoch 2/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.3474 - val_loss: 0.2898<br>
Epoch 3/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.3325 - val_loss: 0.2541<br>
Epoch 4/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.2425 - val_loss: 0.2066<br>
Epoch 5/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.1963 - val_loss: 0.1995<br>
Epoch 6/10<br>
200/200 [==============================] - 18s 90ms/step - loss: 0.2056 - val_loss: 0.2119<br>
Epoch 7/10<br>
200/200 [==============================] - 18s 91ms/step - loss: 0.1978 - val_loss: 0.2079<br>
Epoch 8/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.1957 - val_loss: 0.2033<br>
Epoch 9/10<br>
200/200 [==============================] - 18s 90ms/step - loss: 0.1977 - val_loss: 0.1860<br>
Epoch 10/10<br>
200/200 [==============================] - 18s 88ms/step - loss: 0.1904 - val_loss: 0.1863<br>
</code><br>
<pre><code class="python hljs">plot_train_history(multi_step_history, <span class="hljs-string">'Multi-Step Training and validation loss'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/479/600/430/4796004305bd5b839ead7c35120ddc69.png" alt="imagem"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Executando uma previsão de intervalo</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Então, vamos descobrir com que êxito uma RNA treinada lida com previsões de valores futuros de temperatura.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_multi.take(<span class="hljs-number">3</span>):<font></font>
  multi_step_plot(x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>], multi_step_model.predict(x)[<span class="hljs-number">0</span>])
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/a3a/2fa/3cd/a3a2fa3cd17ec79c04d9ab44a3d3ad2c.jpg" alt="imagem"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Próximos passos</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este guia é uma breve introdução à previsão de séries temporais usando o RNS. Agora você pode tentar prever o mercado de ações e se tornar um bilionário </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(no original, exatamente assim :). - Nota tradutor)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, você pode escrever seu próprio gerador para preparar dados, em vez da função </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uni / multivariate_data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a fim de usar a memória com mais eficiência. Você também pode se familiarizar com o trabalho de “ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">janelas em série temporal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” e trazer suas idéias para este guia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para um entendimento mais aprofundado, é recomendável que você leia o capítulo 15 do livro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Aprendizado de máquina aplicado com o Scikit-Learn, Keras e TensorFlow"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Aurelien Geron, 2ª edição) e o capítulo 6 do livro</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Aprendizagem profunda em Python"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Francois Scholl). </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adição final </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enquanto estiver em casa, cuide não apenas da sua saúde, mas também tenha pena do computador executando exemplos do manual em um conjunto de dados truncados. </font><font style="vertical-align: inherit;">Por exemplo, levando em consideração a proporção de 70x30 (treinamento / teste), você pode limitar da seguinte forma:</font></font></i><br>
<br>
<pre><code class="python hljs">dataset = features[<span class="hljs-number">300000</span>:].values<font></font>
TRAIN_SPLIT = <span class="hljs-number">85000</span></code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt495850/index.html">Vida cotidiana do Scrum-Masters: equipe e autotransformação</a></li>
<li><a href="../pt495852/index.html">LDA em artigos do LiveJournal + visualização</a></li>
<li><a href="../pt495854/index.html">Como escapar do Covid e da vigilância?</a></li>
<li><a href="../pt495856/index.html">Intel DevCloud for oneAPI - um serviço em nuvem para desenvolvedores que ficam em casa</a></li>
<li><a href="../pt495858/index.html">Remoto e auto-isolamento: experiência espacial para ajudar os terráqueos</a></li>
<li><a href="../pt495888/index.html">A PyCon Russia abriu o CFP para futuros palestrantes. Formulários de participação e tópicos esperados</a></li>
<li><a href="../pt495890/index.html">Configurando um pacote Nginx / LetsEncrypt no Docker Swarm</a></li>
<li><a href="../pt495892/index.html">Você realmente sabe o que são matrizes?</a></li>
<li><a href="../pt495894/index.html">Medição de desempenho Javascript</a></li>
<li><a href="../pt495896/index.html">Pacote Use-Sound: Efeitos sonoros em aplicativos React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>