<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏼 🕺🏿 🏌️ Os erros notórios e como evitá-los no exemplo do ClickHouse 👨🏾‍🚀 🌧️ 😬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Se você estiver escrevendo código, prepare-se para problemas. Definitivamente serão, e devem ser esperados de todos os lados: do seu código e compilad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Os erros notórios e como evitá-los no exemplo do ClickHouse</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/497334/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você estiver escrevendo código, prepare-se para problemas. </font><font style="vertical-align: inherit;">Definitivamente serão, e devem ser esperados de todos os lados: do seu código e compilador, do sistema operacional e do hardware, e os usuários às vezes lançam "surpresas". </font><font style="vertical-align: inherit;">Se você escalou o cluster para escalas cósmicas, espere erros de "espaço". </font><font style="vertical-align: inherit;">Especialmente quando se trata de dados do tráfego da Internet.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ooBAQIe0KlQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexey Milovidov</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o6CuFl2Q</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) falará sobre os problemas mais ridículos, desanimadores e sem esperança da sua experiência no desenvolvimento e suporte ao ClickHouse. </font><font style="vertical-align: inherit;">Vamos ver como eles tiveram que ser depurados e quais medidas os desenvolvedores devem tomar desde o início, para que haja menos problemas.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erros notórios</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você escreveu algum código, prepare-se para problemas imediatamente. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erros no código.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eles serão necessários. Mas digamos que você escreveu o código perfeito, compilado, mas os bugs aparecerão </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no compilador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e o código não funcionará corretamente. Consertamos o compilador, tudo compilado - execute-o. Mas (inesperadamente) tudo funciona incorretamente, porque </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">também há bugs no kernel do sistema operacional</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se não houver erros no sistema operacional, inevitavelmente, eles estarão </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no hardware</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mesmo se você escreveu o código perfeito que funciona perfeitamente no hardware perfeito, ainda encontrará problemas, por exemplo, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erros de configuração</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Parece que você fez tudo certo, mas alguém cometeu um erro no arquivo de configuração e tudo não funciona novamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando todos os erros foram corrigidos, os usuários o terminam, porque constantemente usam seu código "incorretamente". </font><font style="vertical-align: inherit;">Mas o problema definitivamente não está nos usuários, mas no código: você </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escreveu algo que é difícil de usar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos esses erros com alguns exemplos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erros de configuração</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exclusão de dados</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O primeiro caso da prática. Felizmente, nem o meu nem o Yandex, não se preocupe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Introdutório primeiro. A arquitetura de um cluster de redução de mapa (como o Hadoop) consiste em vários servidores de dados (nós de dados) que armazenam dados e em um ou mais servidores principais que sabem a localização de todos os dados nos servidores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os nós de dados conhecem o endereço do mestre e se conectam a ele. O assistente monitora onde e quais dados devem ser localizados e fornece comandos diferentes para os nós de dados: “Faça o download dos dados X, você deve ter os dados Y e exclua os dados Z”. O que poderia dar errado?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando um novo arquivo de configuração foi carregado em todos os nós de dados, eles se conectaram por engano ao mestre de outro cluster e não ao próprio. </font><font style="vertical-align: inherit;">O mestre examinou os dados sobre os quais os nós foram informados, decidiu que os dados estavam incorretos e deveriam ser excluídos. </font><font style="vertical-align: inherit;">O problema foi percebido quando metade dos dados foi apagada.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/s8/ii/6i/s8ii6igrww4j3zdjhrfyyqrl2nk.png" width="350"></div><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os bugs mais épicos são aqueles que levam à exclusão acidental de dados.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evitar isso é muito simples. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não apague dados</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Por exemplo, reserve em um diretório separado ou exclua com um atraso. Primeiro, transferimos para que eles não fiquem visíveis para o usuário e, se ele descobrir que algo desapareceu dentro de alguns dias, nós o devolveremos. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não exclua dados inesperados se a causa for desconhecida</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Limite programaticamente o início da exclusão de dados desconhecidos: inesperado, com nomes estranhos ou se houver muitos deles. O administrador notará que o servidor não inicia e grava alguma mensagem e entenderá. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o programa executar ações destrutivas - isole os testes e a produção no nível da rede</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(iptables). Por exemplo, excluir arquivos ou enviar e-mail é uma ação destrutiva, pois "consome" a atenção de alguém. Coloque um limite neles: cem cartas podem ser enviadas e, para mil, coloque uma caixa de seleção de segurança, que é definida antes que algo terrível aconteça. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configurações</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O segundo exemplo já é da minha prática. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma boa empresa de alguma forma tinha um cluster ClickHouse estranho. O estranho é que as réplicas não foram sincronizadas. Quando o servidor foi reiniciado, ele não foi iniciado e apareceu uma mensagem informando que todos os dados estavam incorretos: “Existem muitos dados inesperados, não inicio. Temos que armar a bandeira </font></font><code>force_restore_data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e descobrir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ninguém conseguiu descobrir isso na empresa - eles apenas definiram a bandeira. Ao mesmo tempo, metade dos dados desapareceu em algum lugar, resultando em gráficos com lacunas. Os desenvolvedores se voltaram para mim, pensei que algo interessante estava acontecendo e decidi investigar. Quando a manhã chegou algumas horas depois e os pássaros começaram a cantar do lado de fora da janela, percebi que não entendia nada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O servidor ClickHouse usa o serviço ZooKeeper para coordenação. O ClickHouse armazena dados e o ZooKeeper determina em quais servidores quais dados devem estar: armazena metadados sobre quais dados em que réplica deve estar. O ZooKeeper também é um cluster - ele se replica de acordo com um algoritmo de consenso distribuído muito bom, com consistência estrita.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como regra, o ZooKeeper é de 3 máquinas, às vezes 5. Todas as máquinas são listadas na configuração do ClickHouse de uma só vez, uma conexão é estabelecida com uma máquina aleatória, interage com ela e esse servidor replica todas as solicitações. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que aconteceu? A empresa tinha três servidores ZooKeeper. Mas eles não funcionaram como um </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cluster de três nós</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas como </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">três nós independentes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - três clusters de um nó. Um ClickHouse se conecta a um servidor e grava dados. As réplicas desejam fazer o download desses dados, mas eles não são encontrados em nenhum lugar. Ao reiniciar, o servidor se conecta a outro ZooKeeper: vê que os dados com os quais trabalhou antes são supérfluos, devem ser adiados em algum lugar. Ele não os exclui, mas os transfere para um diretório separado - os dados do ClickHouse não são excluídos com tanta facilidade.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decido corrigir a configuração do ZooKeeper. </font><font style="vertical-align: inherit;">Renomeio todos os dados e solicito </font></font><code>ATTACH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partes dos dados do diretório </font></font><code>detached/unexpeted_*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, todos os dados foram restaurados, as réplicas foram sincronizadas, não houve perdas, os gráficos foram contínuos. </font><font style="vertical-align: inherit;">A empresa está satisfeita, agradecida, como se já tivessem esquecido como tudo funcionara mal antes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esses eram erros de configuração simples. </font><font style="vertical-align: inherit;">Mais bugs estarão no código.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erros no código</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escrevemos código em C ++. </font><font style="vertical-align: inherit;">Isso significa que já temos problemas.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O próximo exemplo é um bug real da produção no </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cluster Yandex.Metrica</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (2015) - uma consequência do código C ++. </font><font style="vertical-align: inherit;">O erro era que, às vezes, o usuário, em vez de responder à solicitação, recebia uma mensagem de erro:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“A soma de verificação não corresponde, dados corrompidos” - a soma de verificação não corresponde, os dados estão quebrados - assustador!</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"O LRUCache se tornou inconsistente. </font><font style="vertical-align: inherit;">Deve haver um bug nele ”- o cache se tornou inconsistente, provavelmente um bug nele.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O código que escrevemos informa que existe um bug lá. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"A </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soma de verificação não corresponde, dados corrompidos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ." </font><font style="vertical-align: inherit;">As somas dos blocos de dados compactados são verificadas antes de serem descompactadas. </font><font style="vertical-align: inherit;">Geralmente, esse erro aparece quando os dados são quebrados no sistema de arquivos. </font><font style="vertical-align: inherit;">Por várias razões, alguns arquivos acabam sendo lixo quando o servidor é reiniciado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas aqui está outro caso: eu li o arquivo manualmente, a soma da verificação corresponde, não há erro. </font><font style="vertical-align: inherit;">Uma vez exibido, o erro é reproduzido de forma estável mediante solicitação repetida. </font><font style="vertical-align: inherit;">Quando o servidor é reiniciado, o erro desaparece por um tempo e, em seguida, aparece de forma estável. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Talvez o problema esteja na RAM? </font><font style="vertical-align: inherit;">Uma situação típica é quando os bits estão batendo nela. </font><font style="vertical-align: inherit;">Eu olho em </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dmesg</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(kern.log), mas não há exceções na verificação da máquina - elas geralmente escrevem quando algo está errado com a RAM. Se o servidor tivesse ultrapassado a RAM, não apenas o meu programa funcionaria incorretamente, mas todos os outros gerariam erros aleatoriamente. No entanto, não há outras manifestações do erro. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"O LRUCache se tornou inconsistente. Deve haver um bug nele. "</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este é um erro claro no código, e estamos escrevendo em C ++ - talvez acesso à memória? Mas os testes em AddressSanitizer, ThreadSanitizer, MemorySanitizer, UndefinedBehaviorSanitizer no IC não mostram nada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Talvez alguns casos de teste não sejam cobertos? Eu coleciono o servidor com o AddressSanitizer, o executo na produção - ele não captura nada. Por algum tempo, o erro é resolvido ao redefinir algum cache de marca (cache de sachê).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma das regras de programação diz: se não estiver claro qual é o erro, observe atentamente o código, esperando encontrar algo lá. Fiz isso, encontrei um bug, consertei - não ajudou. Eu olho para outro lugar no código - também há um bug. Corrigido, novamente não ajudou. Corrigi mais um pouco, o código melhorou, mas o erro ainda não desapareceu! </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Causa.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tentando encontrar um padrão por servidor, por tempo, pela natureza da carga - nada ajuda. Então ele percebeu que o problema se manifesta apenas em um dos agrupamentos e nunca nos outros. O erro não é reproduzido com tanta frequência, mas sempre aparece em um cluster após uma reinicialização e tudo está limpo no outro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verificou-se que o motivo é que no cluster “problema” eles usaram um novo recurso - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dicionários de cache</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eles usam o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alocador de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memória manuscrita </font><strong><font style="vertical-align: inherit;">ArenaWithFreeLists</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Não apenas escrevemos em C ++, mas também vimos algum tipo de alocadores personalizados - nos condenamos a problemas duas vezes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ArenaWithFreeLists é uma parte da memória na qual a memória é alocada consecutivamente em tamanhos divisíveis por dois: 16, 32, 64 bytes. </font><font style="vertical-align: inherit;">Se a memória for liberada, eles formarão uma lista isolada de blocos gratuitos de FreeLists. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos dar uma olhada no código.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArenaWithFreeLists</span>
{</span>
    Block * free_lists[<span class="hljs-number">16</span>] {};
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">sizeToPreviousPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-keyword">return</span> _bit_scan_reverse(size - <span class="hljs-number">1</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">alloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> list_idx = findFreeListIndex(size);<font></font>
        free_lists[list_idx] -&gt;...<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele usa uma função </font></font><code>_bit_scan_reverse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com um sublinhado no início.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existe uma regra não escrita: "Se uma função tiver um sublinhado no início, leia a documentação uma vez e, se houver duas, leia duas vezes".</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ouvimos e lemos a documentação: “int _bit_scan_reverse (int a). Defina dst como o índice do bit mais alto definido no número inteiro de 32 bits a. Se nenhum bit estiver definido em um, então dst será </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indefinido</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . " Parece que encontramos um problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No C ++, essa situação é considerada impossível para o compilador. O compilador pode usar um comportamento indefinido, essa "impossibilidade", como uma suposição para otimizar o código. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O compilador não faz nada errado - honestamente gera instruções de montagem </font></font><code>bsr %edi, %eax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mas, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se o operando for zero, a instrução </font></font></strong><code><strong>bsr</strong></code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terá um comportamento indefinido, não no nível C ++, mas no nível da CPU.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se o registro de origem for zero, o registro de destino não será alterado: havia algum lixo na entrada, esse lixo também permanecerá na saída.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O resultado depende de onde o compilador coloca essa instrução. </font><font style="vertical-align: inherit;">Às vezes, uma função com esta instrução está embutida, às vezes não. </font><font style="vertical-align: inherit;">No segundo caso, haverá algo como este código:</font></font><br>
<br>
<pre><code class="cpp hljs">bsrl %edi, %eax<font></font>
retq</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então eu olhei para um exemplo de código semelhante no meu binário usando </font></font><code>objdump</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lq/6k/4f/lq6k4fg0lwpm2nhwhxbyauyjt2c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acordo com os resultados, vejo que algumas vezes o registro de origem e o destino são iguais. </font><font style="vertical-align: inherit;">Se houvesse zero, o resultado também será zero - está tudo bem. </font><font style="vertical-align: inherit;">Mas às vezes os registros são diferentes, e o resultado será lixo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como esse bug se manifesta?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos lixo como um índice na matriz FreeLists. </font><font style="vertical-align: inherit;">Em vez de uma matriz, vamos para um endereço distante e obtemos acesso à memória.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos sorte, quase todos os endereços próximos são preenchidos com dados do cache - nós estragamos o cache. </font><font style="vertical-align: inherit;">O cache contém deslocamentos de arquivo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lemos os arquivos no deslocamento errado. </font><font style="vertical-align: inherit;">Do deslocamento errado, obtemos a soma do cheque. </font><font style="vertical-align: inherit;">Mas não há uma soma de verificação, mas outra coisa - essa soma de verificação não coincidirá com os seguintes dados.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recebemos o erro "A soma de verificação não corresponde, dados corrompidos".</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Felizmente, não há dados corrompidos, mas apenas o cache da RAM. </font><font style="vertical-align: inherit;">Fomos informados imediatamente sobre o erro, porque verificamos a soma dos dados. </font><font style="vertical-align: inherit;">O erro foi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corrigido</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em 27 de dezembro de 2015 e foi comemorado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você pode ver, o código errado pode pelo menos ser corrigido. </font><font style="vertical-align: inherit;">Mas como consertar bugs no hardware?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erros no ferro</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esses nem são erros, mas leis físicas - efeitos inevitáveis. De acordo com as leis da física, o ferro é inevitavelmente danificado. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gravação não atômica para RAID</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Por exemplo, criamos o RAID1. Consiste em dois discos rígidos. Isso significa que um servidor é um sistema distribuído: os dados são gravados em um disco rígido e em outro. Mas e se os dados forem gravados em um disco e a energia for perdida durante a gravação no segundo? Os dados em uma matriz RAID1 não serão consistentes. Não conseguiremos entender quais dados estão corretos, porque leremos um byte ou outro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode lidar com isso colocando o log. Por exemplo, no ZFS, esse problema foi resolvido, mas mais tarde. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podridão de bits no HDD e SSD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Os bits nos discos rígidos e nos SSDs podem ficar ruins assim. Os SSDs modernos, especialmente aqueles com células de vários níveis, são projetados para garantir que as células se deteriorem constantemente. Os códigos de correção de erros ajudam, mas às vezes as células se deterioram tanto e até isso não salva. Erros não detectados são obtidos. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pouco vira na RAM</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (mas e o ECC?). Na RAM dos servidores, os bits também estão corrompidos. Também possui códigos de correção de erros. Quando ocorrem erros, eles geralmente são visíveis nas mensagens no log do kernel do Linux no dmesg. Quando houver muitos erros, veremos algo como: "N milhões de erros com memória foram corrigidos". Mas bits individuais não serão notados e, com certeza, algo ficará com erros. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit vira no nível da CPU e da rede</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Existem erros no nível da CPU, nos caches da CPU e, é claro, na transmissão de dados pela rede.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como os erros de ferro geralmente se manifestam? O ticket " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um znode malformado impede que o ClickHouse seja iniciado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">chega ao GitHub </font><font style="vertical-align: inherit;">- os dados no nó ZooKeeper estão corrompidos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No ZooKeeper, geralmente escrevemos alguns metadados em texto simples. Há algo errado com ele - " </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">réplica</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " está escrito muito estranho. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8_/gk/zk/8_gkzkxlb1dzwhiph0saer-0d50.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raramente acontece que, devido a um erro no código, um bit seja alterado. Claro, podemos escrever um código assim: pegamos o filtro Bloom, alteramos o bit em determinados endereços, calculamos os endereços incorretamente, alteramos o bit errado, ele cai em alguns dados. É isso aí, agora no ClickHouse não é " </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">réplica"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas " </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repli </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " e todos os dados estão errados. Mas geralmente, uma </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mudança em um bit é um sintoma de problemas de ferro</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Talvez você conheça o exemplo de bitsquatting. </font><font style="vertical-align: inherit;">Artyom Dinaburg </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fez um experimento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : existem domínios na Internet com muito tráfego, embora os usuários não acessem esses domínios por conta própria. </font><font style="vertical-align: inherit;">Por exemplo, esse domínio FB-CDN.com é um CDN do Facebook. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artyom registrou um domínio semelhante (e muitos outros), mas mudou um pouco. </font><font style="vertical-align: inherit;">Por exemplo, FA-CDN.com em vez de FB-CDN.com. </font><font style="vertical-align: inherit;">O domínio não foi publicado em nenhum lugar, mas o tráfego chegou a ele. </font><font style="vertical-align: inherit;">Às vezes, o host FB-CDN foi gravado nos cabeçalhos HTTP e a solicitação foi para outro host devido a erros na RAM nos dispositivos dos usuários. </font><font style="vertical-align: inherit;">RAM com correção de erros nem sempre ajuda. </font><font style="vertical-align: inherit;">Às vezes, até interfere e leva a vulnerabilidades (leia sobre Rowhammer, ECCploit, RAMBleed).</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão: sempre verifique os dados você mesmo.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao gravar no sistema de arquivos, verifique a soma sem falha. </font><font style="vertical-align: inherit;">Ao transmitir pela rede, verifique também resumir - não espere que haja somas de verificação lá.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais bugs! ..</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Métricas de Cluster de Produção</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Às vezes, os usuários em resposta a uma solicitação recebem uma exceção: “A soma de verificação não corresponde: dados corrompidos” - a soma da verificação não está correta, os dados estão corrompidos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jy/lb/wz/jylbwzqxrbk-g3hgygq4bktgdr8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A mensagem de erro exibe dados detalhados: qual valor de cheque era esperado, qual valor de cheque realmente está nesses dados, o tamanho do bloco para o qual verificamos o valor de cheque e o contexto de exceção. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando recebemos o pacote pela rede de algum servidor, uma exceção apareceu - parece familiar. </font><font style="vertical-align: inherit;">Talvez novamente passando pela memória, condição de raça ou outra coisa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta exceção apareceu em 2015. O bug foi corrigido, não apareceu mais. Em fevereiro de 2019, ele apareceu de repente novamente. Nessa época, eu estava em uma das conferências, meus colegas lidaram com o problema. O erro foi reproduzido várias vezes ao dia entre 1000 servidores com ClickHouse: não é possível coletar estatísticas em um servidor e depois em outro. Ao mesmo tempo, não havia novos lançamentos no momento. Não deu certo e resolveu o problema, mas depois de alguns dias o erro desapareceu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eles esqueceram o erro e, em 15 de maio de 2019, repetiu. Continuamos a lidar com ela. A primeira coisa que fiz foi examinar todos os logs e gráficos disponíveis. Ele os estudou o dia inteiro, não entendeu nada, não encontrou nenhum padrão. Se o problema não puder ser reproduzido, a única opção é coletar todos os casos, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">procurar padrões</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e vícios. </font><font style="vertical-align: inherit;">Talvez o kernel do Linux não funcione corretamente com o processador, salve ou carregue incorretamente quaisquer registros.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hipóteses e padrões</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7 de 9 servidores com E5-2683 v4 falharam. Mas, com relação ao erro, apenas cerca da metade do E5-2683 v4 é uma hipótese vazia. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erros geralmente não são repetidos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Além do cluster mtauxyz, onde há realmente dados corrompidos (dados incorretos no disco). Este é outro caso, rejeitamos a hipótese. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O erro não depende do kernel do Linux</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - verificado em servidores diferentes, não encontrou nada. Nada interessante no kern.log, </font></font><code>machine check exception</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sem </font><font style="vertical-align: inherit;">mensagens </font><font style="vertical-align: inherit;">. Em gráficos de rede, incluindo retransmissores, CPU, IO, Rede, nada de interessante. Todos os adaptadores de rede nos servidores em que os erros ocorrem e não aparecem são os mesmos. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não há padrões</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O que fazer? Continue procurando padrões. Segunda tentativa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu olho para servidores de tempo de atividade:</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o tempo de atividade é alto, os servidores funcionam de forma estável</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o segfault e algo assim não é. Sempre me alegro quando vejo que o programa travou com segfault - pelo menos ele travou. Pior, quando há um erro, estraga algo, mas ninguém percebe. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os erros são agrupados por dia</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e ocorrem dentro de alguns dias. Em cerca de 2 dias, mais aparecem, em alguns menos e mais uma vez - não é possível determinar com precisão o tempo de ocorrência de erros. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alguns erros correspondem aos pacotes e ao valor do cheque que esperávamos.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A maioria dos erros possui apenas duas opções de pacote. Tive sorte porque, na mensagem de erro, adicionamos o próprio valor da soma de verificação, o que ajudou a compilar estatísticas. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sem padrões de servidor</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de onde lemos os dados. O tamanho do bloco compactado que verificamos como soma é menor que um kilobyte. Observou os tamanhos das embalagens em HEX. Isso não foi útil para mim - a representação binária de tamanhos de pacotes e somas de verificação não é perceptível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não corrigi o erro: estava novamente procurando padrões. Terceira tentativa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por alguma razão, o erro aparece apenas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em um dos clusters</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - nas terceiras réplicas no Vladimir DC (gostamos de chamar data centers por nomes de cidades). Em fevereiro de 2019, um erro também apareceu no Vladimirs DC, mas em uma versão diferente do ClickHouse. Esse é outro argumento contra a hipótese de que escrevemos o código errado. Já o reescrevemos três vezes de fevereiro a maio - o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erro provavelmente não está no código</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos os erros ao ler pacotes pela rede -</font></font><code>while receiving packet from</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O pacote no qual o erro ocorreu depende da estrutura da solicitação. </font><font style="vertical-align: inherit;">Para solicitações que diferem na estrutura, um erro em diferentes somas de verificação. </font><font style="vertical-align: inherit;">Mas nas solicitações em que o erro está na mesma soma de verificação, as constantes diferem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas as solicitações com erro, exceto uma, são </font></font><code>GLOBAL JOIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas, para comparação, há uma solicitação incomumente simples e o tamanho do bloco compactado é de apenas 75 bytes.</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">max</span>(ReceiveTimestamp) <span class="hljs-keyword">FROM</span> tracking_events_all 
<span class="hljs-keyword">WHERE</span> APIKey = <span class="hljs-number">1111</span> <span class="hljs-keyword">AND</span> (OperatingSystem <span class="hljs-keyword">IN</span> (<span class="hljs-string">'android'</span>, <span class="hljs-string">'ios'</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rejeitamos a hipótese de influência </font></font><code>GLOBAL JOIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mais interessante é que os servidores afetados </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">são agrupados em faixas pelos seus nomes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<code>mtxxxlog01-{39..44 57..58 64 68..71 73..74 76}-3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu estava cansado e desesperado, comecei a procurar padrões completamente ilusórios. </font><font style="vertical-align: inherit;">É bom que eu não tenha conseguido depurar o código usando a numerologia. </font><font style="vertical-align: inherit;">Mas ainda havia pistas.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os grupos de servidores com problemas são os mesmos de fevereiro.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os servidores com problemas estão localizados em certas partes do data center. </font><font style="vertical-align: inherit;">Em DC Vladimir, existem as chamadas linhas - suas diferentes partes: VLA-02, VLA-03, VLA-04. </font><font style="vertical-align: inherit;">Os erros estão claramente agrupados: em algumas filas é bom (VLA-02), em outros problemas (VLA-03, VLA-04).</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digitando depuração</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Permaneceu apenas para depuração usando o método "spear". </font><font style="vertical-align: inherit;">Isso significa formar a hipótese "O que acontece se você tentar fazer isso?" </font><font style="vertical-align: inherit;">e coletar dados. </font><font style="vertical-align: inherit;">Por exemplo, encontrei uma </font></font><code>query_log</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consulta simples com um erro </font><font style="vertical-align: inherit;">na tabela </font><font style="vertical-align: inherit;">para o qual o tamanho do pacote é </font></font><code>size of compressed block</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muito pequeno (= 107). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/zz/fd/cszzfdvfkob2rhon1-n_xfnqtn4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peguei a solicitação, copiei e executei manualmente usando clickhouse-local.</font></font><br>
<br>
<pre><code class="sql hljs">strace -f -e trace=network -s 1000 -x \<font></font>
clickhouse-local <span class="hljs-comment">--query "</span>
    <span class="hljs-keyword">SELECT</span> uniqIf(DeviceIDHash, SessionType = <span class="hljs-number">0</span>)
    <span class="hljs-keyword">FROM</span> remote(<span class="hljs-string">'127.0.0.{2,3}'</span>, mobile.generic_events)
    <span class="hljs-keyword">WHERE</span> StartDate = <span class="hljs-string">'2019-02-07'</span> <span class="hljs-keyword">AND</span> APIKey <span class="hljs-keyword">IN</span> (<span class="hljs-number">616988</span>,<span class="hljs-number">711663</span>,<span class="hljs-number">507671</span>,<span class="hljs-number">835591</span>,<span class="hljs-number">262098</span>,<span class="hljs-number">159700</span>,<span class="hljs-number">635121</span>,<span class="hljs-number">509222</span>)
        <span class="hljs-keyword">AND</span> EventType = <span class="hljs-number">1</span> <span class="hljs-keyword">WITH</span> TOTALS<span class="hljs-string">" --config config.xml</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com a ajuda do strace, recebi uma captura instantânea (despejo) de blocos na rede - exatamente os mesmos pacotes que são recebidos quando essa solicitação é executada e posso estudá-los. Você pode usar o tcpdump para isso, mas é inconveniente: é difícil isolar uma solicitação específica do tráfego de produção. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usando strace, você pode rastrear o próprio servidor ClickHouse. Mas esse servidor funciona em produção, se eu fizer isso, receberei uma variedade de informações incompreensíveis. Portanto, lancei um programa separado que executa exatamente uma solicitação. Já para este programa eu corro strace e recebo o que foi transmitido pela rede. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A solicitação é executada sem erros - o erro não é reproduzido</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se reproduzido, o problema seria resolvido. Portanto, copiei os pacotes em um arquivo de texto e comecei a analisar manualmente o protocolo.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f5/0y/-8/f50y-8qvloj4brnns-nvgydpbsa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O valor do cheque era o mesmo que o esperado. </font><font style="vertical-align: inherit;">Este é exatamente o pacote no qual, às vezes, em outros momentos, em outras solicitações, ocorrem erros. </font><font style="vertical-align: inherit;">Mas até agora não houve erros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu escrevi um programa simples que pega um pacote e verifica o valor do cheque ao substituir um bit em cada byte. </font><font style="vertical-align: inherit;">O programa executou o bit flip em todas as posições possíveis e leu o valor do cheque. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/3m/fn/wr/3mfnwrp1udvm_ecrw0lnpcyoz0o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Iniciei o programa e descobri que, se você alterar o valor de um bit, obtém exatamente esse valor de verificação quebrado, para o qual há uma reclamação</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problema de hardware</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se houver um erro no software (por exemplo, dirigir através da memória), é improvável que o flip de bit único. </font><font style="vertical-align: inherit;">Portanto, surgiu uma nova hipótese - o problema está na glândula. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pode-se fechar a tampa do laptop e dizer: "O problema não está do nosso lado, mas no hardware, não fazemos isso". </font><font style="vertical-align: inherit;">Mas não, vamos tentar entender onde está o problema: na RAM, no disco rígido, no processador, na placa de rede ou na RAM da placa de rede no equipamento de rede. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como localizar um problema de hardware?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O problema surgiu e desapareceu em determinadas datas.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Servidores afetados são agrupados por seus nomes: </font></font><code>mtxxxlog01-{39..44 57..58 64 68..71 73..74 76}-3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os grupos de servidores com problemas são os mesmos de fevereiro.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os servidores com problemas estão apenas em determinadas filas do datacenter.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Havia perguntas para os engenheiros de rede - os dados estão batendo nos comutadores de rede. Acontece que os engenheiros de rede trocaram switches por outros exatamente nessas datas. Após uma pergunta, eles foram substituídos pelos anteriores e o problema desapareceu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema foi resolvido, mas ainda restam perguntas (não mais para engenheiros). </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que o ECC (memória de correção de erros) não ajuda nos comutadores de rede?</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como o flip de vários bits pode compensar um ao outro - você recebe um erro não detectado. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que as somas de verificação TCP não ajudam?</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eles são fracos. Se apenas um bit tiver sido alterado nos dados, as somas de verificação TCP sempre verão a alteração. Se dois bits foram alterados, as alterações podem não ser detectadas - elas se cancelam.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apenas um bit foi alterado em nosso pacote, mas o erro não é visível. Isso ocorre porque 2 bits foram alterados no segmento TCP: eles calcularam a soma de verificação, coincidiu. Mas em um segmento TCP, mais de um pacote de nosso aplicativo está localizado. E para um deles, já consideramos nossa soma de verificação. Apenas um bit foi alterado neste pacote. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que as somas de verificação de Ethernet não ajudam - elas são mais fortes que o TCP? </font></font></strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quantidade de verificação de Ethernet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faça um resumo dos dados para que eles não quebrem durante a transmissão por um segmento (posso estar errado com a terminologia, não sou engenheiro de rede). </font><font style="vertical-align: inherit;">O equipamento de rede encaminha esses pacotes e pode encaminhar alguns dados durante o encaminhamento. </font><font style="vertical-align: inherit;">Portanto, os valores dos cheques são simplesmente recontados. </font><font style="vertical-align: inherit;">Verificamos - nos fios os pacotes não foram alterados. </font><font style="vertical-align: inherit;">Mas se eles baterem no próprio switch de rede, ele recalculará o valor do cheque (será diferente) e encaminhará o pacote ainda mais.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nada irá salvá-lo - soma você mesmo. </font><font style="vertical-align: inherit;">Não espere que alguém faça isso por você.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para blocos de dados, uma soma de verificação de 128 bits é considerada (esse exagero apenas por precaução). </font><font style="vertical-align: inherit;">Informamos corretamente o usuário sobre o erro. </font><font style="vertical-align: inherit;">Os dados são transmitidos pela rede, estão danificados, mas não os gravamos em nenhum lugar - todos os nossos dados estão em ordem, não se preocupe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os dados armazenados no ClickHouse permanecem consistentes. </font><font style="vertical-align: inherit;">Use somas de verificação no ClickHouse. </font><font style="vertical-align: inherit;">Adoramos tanto os cheques que consideramos imediatamente três opções:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para blocos de dados compactados ao gravar em um arquivo, na rede.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A verificação total é a soma dos dados compactados para verificação de reconciliação.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificação total é a soma dos dados não compactados para verificação de reconciliação.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem erros nos algoritmos de compactação de dados, este é um caso conhecido. </font><font style="vertical-align: inherit;">Portanto, quando os dados são replicados, também consideramos a soma total de verificação dos dados compactados e a quantidade total de dados não compactados.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não tenha medo de contar os valores dos cheques, pois eles não diminuem a velocidade.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, depende de quais e como contar. </font><font style="vertical-align: inherit;">Existem nuances, mas não se esqueça de considerar o valor do cheque. </font><font style="vertical-align: inherit;">Por exemplo, se você contar a partir dos dados compactados, haverá menos dados, eles não diminuirão a velocidade.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mensagem de erro aprimorada</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como explicar ao usuário quando ele recebe uma mensagem de erro que este é um problema de hardware? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t4/f6/rj/t4f6rj1mtuo38kojydfgddfh2nc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se a soma de verificação não corresponder, antes de enviar uma exceção, tento mudar todos os bits - apenas por precaução. Se a soma da verificação convergir durante a alteração e um bit for alterado, o problema provavelmente será o hardware. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se podemos detectar esse erro e se ele muda quando um bit é alterado, por que não corrigi-lo? Podemos fazer isso, mas se corrigirmos erros o tempo todo, o usuário não saberá que o equipamento está com problemas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando descobrimos que havia problemas nos comutadores, pessoas de outros departamentos começaram a relatar: “E nós escrevemos um pouco incorretamente para o Mongo! E algo nos atingiu no PostgreSQL! ” Isso é bom, mas é melhor relatar problemas mais cedo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando lançamos uma nova versão de diagnóstico, o primeiro usuário a quem ele trabalhou escreveu uma semana depois: "Aqui está a mensagem - qual é o problema?" </font><font style="vertical-align: inherit;">Infelizmente, ele não leu. </font><font style="vertical-align: inherit;">Mas eu li e sugeri com uma probabilidade de 99% que, se o erro aparecer em um servidor, o problema esteja no hardware. </font><font style="vertical-align: inherit;">Deixo a porcentagem restante no caso de escrever o código incorretamente - isso acontece. </font><font style="vertical-align: inherit;">Como resultado, o usuário substituiu o SSD e o problema desapareceu.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Delirium" nos dados</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse problema interessante e inesperado me deixou preocupada. Temos dados Yandex.Metrica. Um JSON simples é gravado no banco de dados em uma das colunas - parâmetros do usuário do código JavaScript do contador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu faço algum tipo de solicitação e o servidor ClickHouse travou com o segfault. A partir do rastreamento da pilha, percebi qual era o problema - um novo commit de nossos colaboradores externos de outro país. A consolidação corrigida, segfault desapareceu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu executo o mesmo pedido: </font></font><code>SELECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no ClickHouse, para obter JSON, mas, novamente, bobagem, tudo funciona lentamente. Eu recebo JSON, e é 10 MB. Eu o mostro e olho com mais atenção: </font></font><code>{"jserrs": cannot find property of object undefind...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e então um megabyte de código binário caiu.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nt/ab/1g/ntab1gtbj8eialtctjq4nu-ucdi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Havia pensamentos de que isso é novamente uma passagem da memória ou uma condição de raça. </font><font style="vertical-align: inherit;">Muitos desses dados binários são ruins, podem conter qualquer coisa. </font><font style="vertical-align: inherit;">Nesse caso, agora vou encontrar senhas e chaves privadas lá. </font><font style="vertical-align: inherit;">Mas como não encontrei nada, rejeitei imediatamente a hipótese. </font><font style="vertical-align: inherit;">Talvez este seja um erro no meu programa no servidor ClickHouse? </font><font style="vertical-align: inherit;">Talvez em um programa que escreve (também é escrito em C ++) - de repente ela acidentalmente coloca sua memória de despejo no ClickHouse? </font><font style="vertical-align: inherit;">Neste inferno, comecei a olhar atentamente para as cartas e percebi que não era tão simples.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminho da pista</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mesmo lixo foi registrado em dois grupos, independentemente um do outro. </font><font style="vertical-align: inherit;">Os dados são lixo, mas são UTF-8 válidos. </font><font style="vertical-align: inherit;">Este UTF-8 possui alguns URLs estranhos, nomes de fontes e muitas letras "I" seguidas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que há de especial no pequeno "eu" cirílico? </font><font style="vertical-align: inherit;">Não, este não é o Yandex. </font><font style="vertical-align: inherit;">O fato é que, na codificação do Windows 1251, é o 255º caractere. </font><font style="vertical-align: inherit;">E em nossos servidores Linux, ninguém usa a codificação do Windows 1251. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acontece que este é um despejo do navegador: o código JavaScript do contador de métricas coleta erros de JavaScript. </font><font style="vertical-align: inherit;">Como se viu, a resposta é simples - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tudo veio do usuário</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A partir daqui também é possível tirar conclusões.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erros de toda a Internet</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Yandex.Metrica coleta tráfego de 1 bilhão de dispositivos na Internet: navegadores em PCs, telefones celulares, tablets. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O lixo virá inevitavelmente</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : existem bugs nos dispositivos dos usuários, em todos os lugares RAM não confiável e hardware terrível que superaquece. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O banco de dados armazena mais de 30 trilhões de linhas (visualizações de página). Se você analisar os dados desta tabela, poderá encontrar qualquer coisa lá. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, é correto simplesmente filtrar esse lixo antes de gravar no banco de dados. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não há necessidade de escrever lixo no banco de dados - ela não gosta.</font></font></b><br>
<br>
<blockquote> HighLoad++   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> 133 </a>   ),       -  ,   , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">++</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PHP Russia 2020 Online</a>. <br>
<br>
   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Badoo</a>, <b> PHP Russia 2020 Online  </b>. PHP Russia 2020 Online  13 ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>.<br>
<br>
          — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>,     . </blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt497324/index.html">“Como a menina de um olho ...” ou criamos um sistema de segurança simples baseado em um microcontrolador (Canny ou Arduino) e Raspberry PI</a></li>
<li><a href="../pt497326/index.html">Conectividade SSH mais segura com DNSSEC</a></li>
<li><a href="../pt497328/index.html">Maneira fácil de aprender um idioma (qualquer)</a></li>
<li><a href="../pt497330/index.html">Área de trabalho remota do Chrome. Suporte remoto</a></li>
<li><a href="../pt497332/index.html">Houston, nós temos um problema. Falha no projeto do sistema</a></li>
<li><a href="../pt497336/index.html">Marcas de computadores dos anos 90, parte 3, final</a></li>
<li><a href="../pt497338/index.html">O que aconteceu com o transporte na semana passada - a crise está se desenvolvendo</a></li>
<li><a href="../pt497340/index.html">COVID-19: como parar de ler notícias e começar a analisar dados</a></li>
<li><a href="../pt497342/index.html">Navegador atento às solicitações de API: construindo comunicação segura entre o front-end e o back-end</a></li>
<li><a href="../pt497346/index.html">Acelere o numpy, o scikit e os pandas 100 vezes com Rust e LLVM: entrevista com o desenvolvedor Weld</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>