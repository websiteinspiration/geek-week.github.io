<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßúüèø üßòüèª üë©üèª Die Leistung von modernem Java beim Arbeiten mit gro√üen Datenmengen, Teil 2 ‚ÅâÔ∏è ‚ò™Ô∏è üï¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zu Ihrer Information: Der erste Teil .
 
 Benchmark Batch Conveyor
 Die Batch-Pipeline verarbeitet die endg√ºltige Menge der gespeicherten Daten. Es gi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Die Leistung von modernem Java beim Arbeiten mit gro√üen Datenmengen, Teil 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/507210/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/d1/gm/bn/d1gmbnhwk4pkhy1bck7ykdmu-uq.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu Ihrer Information: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Teil</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmark Batch Conveyor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Batch-Pipeline verarbeitet die endg√ºltige Menge der gespeicherten Daten. Es gibt keinen Strom von Verarbeitungsergebnissen, die Ausgabe der Aggregationsfunktion muss auf den gesamten Datensatz angewendet werden. Dies √§ndert die Leistungsanforderungen: Die Latenz - ein Schl√ºsselfaktor bei der Streaming-Verarbeitung - fehlt hier, da wir Daten in Echtzeit verarbeiten. Die einzige wichtige Metrik ist die Gesamtlaufzeit des F√∂rderers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deshalb haben wir uns f√ºr Parallel entschieden. </font><font style="vertical-align: inherit;">In der ersten Testphase zeigte dieser Kollektor bei der Arbeit an einem einzelnen Knoten wirklich den besten Durchsatz (jedoch erst nach der Optimierung). </font><font style="vertical-align: inherit;">Dies wurde jedoch auf Kosten langer Pausen erreicht. </font><font style="vertical-align: inherit;">Wenn einer der Clusterknoten bei der Speicherbereinigung stoppt, wird die gesamte Pipeline gestoppt. </font><font style="vertical-align: inherit;">Und da die Knoten zu unterschiedlichen Zeiten M√ºll sammeln, erh√∂ht sich die gesamte Erstellungszeit mit dem Hinzuf√ºgen jedes Knotens zum Cluster. </font><font style="vertical-align: inherit;">Wir haben diesen Effekt analysiert, indem wir die Testergebnisse auf einem Knoten und auf einem Cluster von drei Knoten verglichen haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus haben wir zu diesem Zeitpunkt keine experimentellen Assembler mit geringer Latenz ber√ºcksichtigt. </font><font style="vertical-align: inherit;">Ihre sehr kurzen Pausen wirken sich nicht auf die Testergebnisse aus, au√üerdem wird dies aufgrund der Bandbreite erreicht.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen an einem einzelnen Knoten: F√∂rderer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr einen Batch-Benchmark auf einem einzelnen Knoten haben wir eine einfache Pipeline verwendet. Vollst√§ndiger Code </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="java hljs">p.readFrom(longSource)<font></font>
 .rebalance() <span class="hljs-comment">// Introduced in Jet 4.2</span><font></font>
 .groupingKey(n -&gt; n % NUM_KEYS)<font></font>
 .aggregate(summingLong(n -&gt; n))<font></font>
 .filter(e -&gt; (e.getKey() &amp; <span class="hljs-number">0xFF_FFFFL</span>) == <span class="hljs-number">0</span>)<font></font>
 .writeTo(Sinks.logger())<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Quelle ist ein Stub, der eine Folge von Typennummern generiert </font></font><code>long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Schl√ºsselfunktion ist so definiert, dass sie den </font></font><code>groupingKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tastenraum durchl√§uft: 0, 1, 2, ... </font></font><code>NUM_KEYS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,, 0, 1, 2, ... Dies bedeutet, dass die Pipeline w√§hrend des ersten Zyklus alle Schl√ºssel sieht und eine feste Datenstruktur zum Speichern der Ergebnisse erstellt Anh√§ufung. In den n√§chsten Zyklen aktualisiert das System nur die verf√ºgbaren Daten. Dies steht voll und ganz im Einklang mit der Hypothese der Speicherbereinigung unter Ber√ºcksichtigung verschiedener Generationen: Objekte durchlaufen entweder alle Berechnungen oder existieren nicht lange und werden kurz nach ihrer Erstellung zu M√ºll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Quelle hat 400 Millionen Elemente generiert, und wir haben 100 Millionen Einzelschl√ºssel erstellt, dh viermal alle Schl√ºssel durchlaufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operator</font></font><code>.rebalance()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ersetzt die standardm√§√üige </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zweistufige Aggregation von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jet </font><font style="vertical-align: inherit;">durch eine </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">einstufige Aggregation</font></a><font style="vertical-align: inherit;"> . Dies machte das Verhalten des Motors in unseren Benchmarks vorhersehbarer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben auch eine Option getestet, bei der die Aggregationsoperation eine Instanz eines Objekts vom Typ als Status verwendet </font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und bei jeder Aktualisierung des aktuellen Kontos M√ºll generiert. In diesem Fall sterben viele Objekte nach einer anst√§ndigen Zeit in der alten Generation. In dieser Situation mussten wir die Anzahl der Schl√ºssel auf 70 Millionen reduzieren, da die Belastung des Kollektors mit 100 Millionen zu hoch war.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben uns nicht auf Kollektoren mit geringer Latenz konzentriert, da diese im Fall einer Batch-Pipeline nichts zu bieten haben. </font><font style="vertical-align: inherit;">Da wir bereits gesehen haben, dass JDK 14 fast wie JDK 11 funktioniert, haben wir einen Test durchgef√ºhrt, um dies zu best√§tigen. </font><font style="vertical-align: inherit;">Und dann haben wir uns auf JDK 8 und JDK 11 konzentriert. Au√üerdem haben wir den in JDK 8 verwendeten Standard-Parallelkollektor mit G1 verglichen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen auf einem einzelnen Knoten: Ergebnisse</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den Benchmark auf einem Laptop mit 16 GB RAM und einem 6-Core Intel Core i7 durchgef√ºhrt. Die Heap-Gr√∂√üe betrug 10 GB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund von Parallel war die Leistung zun√§chst sehr schlecht, und wir mussten die Speicherbereinigung optimieren. Daher empfehlen wir dringend, VisualVM und das Visual GC-Plugin zu verwenden. Wenn Sie die maximale Bildrate (10 fps) festlegen, k√∂nnen Sie die Beziehung zwischen der Zuweisung Ihres Anwendungsspeichers und der Arbeit des Garbage Collector sehr detailliert visualisieren. Nachdem wir uns die Animation angesehen hatten, stellten wir fest, dass das Hauptproblem zu gro√üe Speicherpl√§tze f√ºr die neue Generation waren. Standardm√§√üig betr√§gt das Verh√§ltnis der alten zur neuen Generation nur 2: 1 und √§ndert sich w√§hrend der Ausf√ºhrung nicht dynamisch. Daher haben wir uns entschlossen, die Einstellung anzuwenden</font></font><code>-XX:NewRatio=8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und das hat das ganze Bild ver√§ndert. Jetzt funktionierte Parallel am besten. Wir haben auch </font></font><code>-XX:MaxTenuringThreshold=2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberlebensr√§ume </font><font style="vertical-align: inherit;">angewendet </font><font style="vertical-align: inherit;">, um das Kopieren von Daten zwischen R√§umen zu reduzieren, da tempor√§re Objekte in der Pipeline schnell sterben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun zu den Ergebnissen. Die einzig geeignete Metrik f√ºr eine Batch-Pipeline ist die Dauer der Aufgabe. Um die Ergebnisse zu visualisieren, haben wir ihre reziproken Werte verwendet. Daher zeigt die Grafik den Durchsatz in Elementen pro Sekunde. F√ºr einen Knoten:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/87a/5c6/a4f87a5c66be2c77e0337151adb9d2ca.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/377/c40/5ab/377c405ab09606862cb1464b07624d56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aggregation ohne Speicherbereinigung funktioniert trotz eines gr√∂√üeren Schl√ºsselsatzes etwa 30-35% schneller. Das G1- und JDK 8-Bundle funktionierte am schlechtesten und das Parallel- und JDK 11-Bundle am besten. Das G1- und JDK 11-Bundle hat nicht viel verloren. Bitte beachten Sie, dass wir die G1-Konfiguration nicht ber√ºhrt haben. Dies ist ein wichtiger Punkt. Die Konfiguration der Speicherbereinigung h√§ngt stark von der jeweiligen Situation ab. Die Ergebnisse k√∂nnen sich beispielsweise mit zunehmender Datenmenge dramatisch √§ndern. Und Sie m√ºssen f√ºr den gesamten Cluster f√ºr einen bestimmten Lasttyp konfigurieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist die Leistung des Standard-Parallelkollektors im Vergleich zu der benutzerdefinierten Version, die wir beim Testen verwendet haben:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81b/797/c4a/81b797c4acae8f632c51147b699c3cad.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit einem 10-GB-Heap sind die Ergebnisse sehr schlecht. </font><font style="vertical-align: inherit;">Das System blieb bei der Montage in vollen Pausen stecken, die jeweils etwa 7 Sekunden dauerten. </font><font style="vertical-align: inherit;">Mit zunehmendem Haufen verbesserte sich die Situation, dennoch traten sehr h√§ufig vollst√§ndige Montagezyklen auf. </font><font style="vertical-align: inherit;">Bitte beachten Sie, dass diese Ergebnisse f√ºr den h√§ufigsten Fall erhalten wurden - Aggregation ohne Zusammenbau.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen an drei Knoten: F√∂rderer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Cluster korrekt zu testen, mussten wir eine komplexere </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipeline verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="java hljs">p.readFrom(longSource())<font></font>
 .rebalance()<font></font>
 .flatMap(n -&gt; {<font></font>
     Long[] items = <span class="hljs-keyword">new</span> Long[SOURCE_STEP];<font></font>
     Arrays.setAll(items, i -&gt; n + i);<font></font>
     <span class="hljs-keyword">return</span> traverseArray(items);<font></font>
 })<font></font>
 .rebalance()<font></font>
 .groupingKey(n -&gt; n % NUM_KEYS)<font></font>
 .aggregate(AggregateOperations.summingLong(n -&gt; n))<font></font>
 .filter(e -&gt; e.getKey() % <span class="hljs-number">1_000_000</span> == <span class="hljs-number">0</span>)<font></font>
 .writeTo(Sinks.logger())<font></font>
;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Quelle nicht parallel funktioniert, haben wir einige Optimierungen vorgenommen, damit sie nicht zu einem Engpass im System wird. </font><font style="vertical-align: inherit;">Die Quelle generiert die Zahlen 0, 10, 20, ... und wir haben die Phase parallelisiert, </font></font><code>flatMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der die fehlenden Zahlen interpoliert werden. </font><font style="vertical-align: inherit;">Auch zwischen der Quelle und </font></font><code>flatMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uns verwendet </font></font><code>rebalance()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, verteilen Daten √ºber den Cluster. </font><font style="vertical-align: inherit;">Und vor dem Start der Hauptphase (Schl√ºsselaggregation) haben wir das Gleichgewicht wieder hergestellt. </font><font style="vertical-align: inherit;">Nach der Aggregation belassen wir zun√§chst nur jedes millionste Schl√ºssel-Wert-Paar und √ºbergeben es dann an den Logger. </font><font style="vertical-align: inherit;">Eine Milliarde Datenelemente und ein Satz von 500 Millionen Schl√ºsseln wurden verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bei einem Knoten haben wir den F√∂rderer mit Aggregation ohne M√ºll und damit getestet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen auf drei Knoten: Ergebnis</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben diesen Benchmark auf einem AWS-Cluster aus drei c5d.4xlarge-Instanzen ausgef√ºhrt. Sie hatten 16 virtualisierte Prozessorkerne und 32 GB Speicher. Kanalbandbreite 10 Gbit / s. Ergebnis:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/579/cc6/a6d/579cc6a6d172a6098f96b3c2b9cfbda8.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b28/32f/ca6/b2832fca67b0123a6ca976e518ecd87c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nebenbei stellen wir eine ungef√§hr dreifache Steigerung des Durchsatzes im Vergleich zu einem einzelnen Knoten fest. Dies ist eine Folge der verteilten Verarbeitung. Bei den Monteuren wurde die Kombination von G1 und JDK 11 zum Gewinner beider Tests. Ein weiteres bemerkenswertes Ergebnis war die fast nicht funktionsf√§hige Kombination von G1 und JDK 8. Dies hat jedoch tiefere Gr√ºnde, die sich auf andere Dimensionen auswirken. Zum Beispiel der offensichtliche Vorteil von Parallel unter JDK 8 und JDK 11. Dies ist auf den Effekt zur√ºckzuf√ºhren, den wir ganz am Anfang festgestellt haben: Sobald ein Knoten f√ºr die Speicherbereinigung pausiert, wird die Verarbeitung im gesamten Cluster gestoppt. Und G1 auf JDK 8 steigt f√ºr sehr lange Pausen, mehr als eine Minute. Dies reicht aus, damit der Fehlerdetektor im Cluster funktioniert und entscheidet, dass der Knoten gestorben ist. Die Aufgabe schl√§gt fehl, der Cluster organisiert sich neu und die Aufgabe wird auf zwei Knoten erneut gestartet.Dies f√ºhrt noch schneller zu einem neuen Fehler, da jeder Knoten jetzt mehr Daten verarbeitet. Gleichzeitig tritt der ausgeworfene Knoten erneut bei, und die Aufgabe wird erneut auf zwei Knoten gestartet, jedoch auf anderen. Es gibt eine endlose Schleife von Neustartaufgaben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parallele Pausen sind nicht so lang, dass der Cluster besch√§digt wird, aber bei Tests auf demselben Knoten hat es viel schlechter funktioniert. Auf drei Knoten verlor er 30% gegen G1 und JDK 11. Und in gr√∂√üeren Clustern wird die Situation noch schlimmer sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich alle Tests ansehen, ist es √ºberraschend, dass Parallel unter JDK 8 schneller ausgef√ºhrt wird als unter JDK 11. Dies ist jedoch auf einen sehr guten Zufall zur√ºckzuf√ºhren: In diesen Testl√§ufen wurden auf allen Knoten synchron vollst√§ndige Pausen gestartet, wodurch die Arbeit des Kollektors parallelisiert wurde. Auf diesen Effekt kann man sich nat√ºrlich nicht verlassen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass wir in unserer Testkonfiguration bei Verwendung von Parallel den katastrophalen Effekt langer Pausen auf die Clusterstabilit√§t nicht beobachtet haben, ist dies ein sehr wahrscheinliches Szenario. </font><font style="vertical-align: inherit;">In anderen Tests wirkte Parallel genauso destruktiv, wenn wir den Heap und die Datenmenge erh√∂hten oder denselben Heap verlie√üen, aber die operative Marge verringerten. </font><font style="vertical-align: inherit;">Aber selbst wenn es nicht zu Fehlern f√ºhrte, verschwand sein Vorteil in den Diagrammen, wenn auf demselben Knoten gearbeitet wurde. </font><font style="vertical-align: inherit;">Es ist zu erwarten, dass sich die Situation durch das Hinzuf√ºgen neuer Knoten zum Cluster verschlechtert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der anderen Seite arbeiteten einige G1 und JDK 11 mit relativ kurzen Pausen, sodass der F√∂rderer nicht anhielt. </font><font style="vertical-align: inherit;">Es verf√ºgt √ºber einen Mechanismus, der kurze Ausfallzeiten verringert. W√§hrend die Pausen 150 ms nicht √ºberschreiten, hat die Speicherbereinigung nur lokale Auswirkungen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de507198/index.html">Podcasts als Unternehmensmedien: Wie man damit Geld verdient und welche Metriken verwendet werden sollen</a></li>
<li><a href="../de507200/index.html">7 M√∂glichkeiten, wie Data Scientists Sie t√§uschen</a></li>
<li><a href="../de507202/index.html">Avito Analytics-Treffen</a></li>
<li><a href="../de507204/index.html">Innenk√ºche im Industriedesign: von der Skizze bis zum Produkt im Karton</a></li>
<li><a href="../de507206/index.html">Architektur Y Messenger</a></li>
<li><a href="../de507212/index.html">Trainieren Sie Smart-Gaming-Rivalen in Unity mithilfe der "Play with yourself" -Methode mithilfe von ML-Agents</a></li>
<li><a href="../de507214/index.html">So erstellen und √§ndern Sie interaktive PDF-Formulare oder die neue F√§higkeit ABBYY FineReader PDF</a></li>
<li><a href="../de507218/index.html">Lesen Sie mich oder warum der Text nicht bis zum Ende gelesen wird</a></li>
<li><a href="../de507222/index.html">Warum jeder Masken tragen sollte</a></li>
<li><a href="../de507224/index.html">So beseitigen Sie blinde Flecken mit visuellen Tests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>