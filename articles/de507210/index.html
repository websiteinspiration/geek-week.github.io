<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏿 🧘🏻 👩🏻 Die Leistung von modernem Java beim Arbeiten mit großen Datenmengen, Teil 2 ⁉️ ☪️ 🕴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zu Ihrer Information: Der erste Teil .
 
 Benchmark Batch Conveyor
 Die Batch-Pipeline verarbeitet die endgültige Menge der gespeicherten Daten. Es gi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Die Leistung von modernem Java beim Arbeiten mit großen Datenmengen, Teil 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/507210/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/d1/gm/bn/d1gmbnhwk4pkhy1bck7ykdmu-uq.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu Ihrer Information: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Teil</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmark Batch Conveyor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Batch-Pipeline verarbeitet die endgültige Menge der gespeicherten Daten. Es gibt keinen Strom von Verarbeitungsergebnissen, die Ausgabe der Aggregationsfunktion muss auf den gesamten Datensatz angewendet werden. Dies ändert die Leistungsanforderungen: Die Latenz - ein Schlüsselfaktor bei der Streaming-Verarbeitung - fehlt hier, da wir Daten in Echtzeit verarbeiten. Die einzige wichtige Metrik ist die Gesamtlaufzeit des Förderers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deshalb haben wir uns für Parallel entschieden. </font><font style="vertical-align: inherit;">In der ersten Testphase zeigte dieser Kollektor bei der Arbeit an einem einzelnen Knoten wirklich den besten Durchsatz (jedoch erst nach der Optimierung). </font><font style="vertical-align: inherit;">Dies wurde jedoch auf Kosten langer Pausen erreicht. </font><font style="vertical-align: inherit;">Wenn einer der Clusterknoten bei der Speicherbereinigung stoppt, wird die gesamte Pipeline gestoppt. </font><font style="vertical-align: inherit;">Und da die Knoten zu unterschiedlichen Zeiten Müll sammeln, erhöht sich die gesamte Erstellungszeit mit dem Hinzufügen jedes Knotens zum Cluster. </font><font style="vertical-align: inherit;">Wir haben diesen Effekt analysiert, indem wir die Testergebnisse auf einem Knoten und auf einem Cluster von drei Knoten verglichen haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus haben wir zu diesem Zeitpunkt keine experimentellen Assembler mit geringer Latenz berücksichtigt. </font><font style="vertical-align: inherit;">Ihre sehr kurzen Pausen wirken sich nicht auf die Testergebnisse aus, außerdem wird dies aufgrund der Bandbreite erreicht.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen an einem einzelnen Knoten: Förderer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für einen Batch-Benchmark auf einem einzelnen Knoten haben wir eine einfache Pipeline verwendet. Vollständiger Code </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="java hljs">p.readFrom(longSource)<font></font>
 .rebalance() <span class="hljs-comment">// Introduced in Jet 4.2</span><font></font>
 .groupingKey(n -&gt; n % NUM_KEYS)<font></font>
 .aggregate(summingLong(n -&gt; n))<font></font>
 .filter(e -&gt; (e.getKey() &amp; <span class="hljs-number">0xFF_FFFFL</span>) == <span class="hljs-number">0</span>)<font></font>
 .writeTo(Sinks.logger())<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Quelle ist ein Stub, der eine Folge von Typennummern generiert </font></font><code>long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Schlüsselfunktion ist so definiert, dass sie den </font></font><code>groupingKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tastenraum durchläuft: 0, 1, 2, ... </font></font><code>NUM_KEYS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,, 0, 1, 2, ... Dies bedeutet, dass die Pipeline während des ersten Zyklus alle Schlüssel sieht und eine feste Datenstruktur zum Speichern der Ergebnisse erstellt Anhäufung. In den nächsten Zyklen aktualisiert das System nur die verfügbaren Daten. Dies steht voll und ganz im Einklang mit der Hypothese der Speicherbereinigung unter Berücksichtigung verschiedener Generationen: Objekte durchlaufen entweder alle Berechnungen oder existieren nicht lange und werden kurz nach ihrer Erstellung zu Müll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Quelle hat 400 Millionen Elemente generiert, und wir haben 100 Millionen Einzelschlüssel erstellt, dh viermal alle Schlüssel durchlaufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operator</font></font><code>.rebalance()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ersetzt die standardmäßige </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zweistufige Aggregation von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jet </font><font style="vertical-align: inherit;">durch eine </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">einstufige Aggregation</font></a><font style="vertical-align: inherit;"> . Dies machte das Verhalten des Motors in unseren Benchmarks vorhersehbarer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben auch eine Option getestet, bei der die Aggregationsoperation eine Instanz eines Objekts vom Typ als Status verwendet </font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und bei jeder Aktualisierung des aktuellen Kontos Müll generiert. In diesem Fall sterben viele Objekte nach einer anständigen Zeit in der alten Generation. In dieser Situation mussten wir die Anzahl der Schlüssel auf 70 Millionen reduzieren, da die Belastung des Kollektors mit 100 Millionen zu hoch war.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben uns nicht auf Kollektoren mit geringer Latenz konzentriert, da diese im Fall einer Batch-Pipeline nichts zu bieten haben. </font><font style="vertical-align: inherit;">Da wir bereits gesehen haben, dass JDK 14 fast wie JDK 11 funktioniert, haben wir einen Test durchgeführt, um dies zu bestätigen. </font><font style="vertical-align: inherit;">Und dann haben wir uns auf JDK 8 und JDK 11 konzentriert. Außerdem haben wir den in JDK 8 verwendeten Standard-Parallelkollektor mit G1 verglichen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen auf einem einzelnen Knoten: Ergebnisse</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den Benchmark auf einem Laptop mit 16 GB RAM und einem 6-Core Intel Core i7 durchgeführt. Die Heap-Größe betrug 10 GB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund von Parallel war die Leistung zunächst sehr schlecht, und wir mussten die Speicherbereinigung optimieren. Daher empfehlen wir dringend, VisualVM und das Visual GC-Plugin zu verwenden. Wenn Sie die maximale Bildrate (10 fps) festlegen, können Sie die Beziehung zwischen der Zuweisung Ihres Anwendungsspeichers und der Arbeit des Garbage Collector sehr detailliert visualisieren. Nachdem wir uns die Animation angesehen hatten, stellten wir fest, dass das Hauptproblem zu große Speicherplätze für die neue Generation waren. Standardmäßig beträgt das Verhältnis der alten zur neuen Generation nur 2: 1 und ändert sich während der Ausführung nicht dynamisch. Daher haben wir uns entschlossen, die Einstellung anzuwenden</font></font><code>-XX:NewRatio=8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und das hat das ganze Bild verändert. Jetzt funktionierte Parallel am besten. Wir haben auch </font></font><code>-XX:MaxTenuringThreshold=2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überlebensräume </font><font style="vertical-align: inherit;">angewendet </font><font style="vertical-align: inherit;">, um das Kopieren von Daten zwischen Räumen zu reduzieren, da temporäre Objekte in der Pipeline schnell sterben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun zu den Ergebnissen. Die einzig geeignete Metrik für eine Batch-Pipeline ist die Dauer der Aufgabe. Um die Ergebnisse zu visualisieren, haben wir ihre reziproken Werte verwendet. Daher zeigt die Grafik den Durchsatz in Elementen pro Sekunde. Für einen Knoten:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/87a/5c6/a4f87a5c66be2c77e0337151adb9d2ca.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/377/c40/5ab/377c405ab09606862cb1464b07624d56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aggregation ohne Speicherbereinigung funktioniert trotz eines größeren Schlüsselsatzes etwa 30-35% schneller. Das G1- und JDK 8-Bundle funktionierte am schlechtesten und das Parallel- und JDK 11-Bundle am besten. Das G1- und JDK 11-Bundle hat nicht viel verloren. Bitte beachten Sie, dass wir die G1-Konfiguration nicht berührt haben. Dies ist ein wichtiger Punkt. Die Konfiguration der Speicherbereinigung hängt stark von der jeweiligen Situation ab. Die Ergebnisse können sich beispielsweise mit zunehmender Datenmenge dramatisch ändern. Und Sie müssen für den gesamten Cluster für einen bestimmten Lasttyp konfigurieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist die Leistung des Standard-Parallelkollektors im Vergleich zu der benutzerdefinierten Version, die wir beim Testen verwendet haben:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81b/797/c4a/81b797c4acae8f632c51147b699c3cad.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit einem 10-GB-Heap sind die Ergebnisse sehr schlecht. </font><font style="vertical-align: inherit;">Das System blieb bei der Montage in vollen Pausen stecken, die jeweils etwa 7 Sekunden dauerten. </font><font style="vertical-align: inherit;">Mit zunehmendem Haufen verbesserte sich die Situation, dennoch traten sehr häufig vollständige Montagezyklen auf. </font><font style="vertical-align: inherit;">Bitte beachten Sie, dass diese Ergebnisse für den häufigsten Fall erhalten wurden - Aggregation ohne Zusammenbau.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen an drei Knoten: Förderer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Cluster korrekt zu testen, mussten wir eine komplexere </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipeline verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="java hljs">p.readFrom(longSource())<font></font>
 .rebalance()<font></font>
 .flatMap(n -&gt; {<font></font>
     Long[] items = <span class="hljs-keyword">new</span> Long[SOURCE_STEP];<font></font>
     Arrays.setAll(items, i -&gt; n + i);<font></font>
     <span class="hljs-keyword">return</span> traverseArray(items);<font></font>
 })<font></font>
 .rebalance()<font></font>
 .groupingKey(n -&gt; n % NUM_KEYS)<font></font>
 .aggregate(AggregateOperations.summingLong(n -&gt; n))<font></font>
 .filter(e -&gt; e.getKey() % <span class="hljs-number">1_000_000</span> == <span class="hljs-number">0</span>)<font></font>
 .writeTo(Sinks.logger())<font></font>
;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Quelle nicht parallel funktioniert, haben wir einige Optimierungen vorgenommen, damit sie nicht zu einem Engpass im System wird. </font><font style="vertical-align: inherit;">Die Quelle generiert die Zahlen 0, 10, 20, ... und wir haben die Phase parallelisiert, </font></font><code>flatMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der die fehlenden Zahlen interpoliert werden. </font><font style="vertical-align: inherit;">Auch zwischen der Quelle und </font></font><code>flatMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uns verwendet </font></font><code>rebalance()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, verteilen Daten über den Cluster. </font><font style="vertical-align: inherit;">Und vor dem Start der Hauptphase (Schlüsselaggregation) haben wir das Gleichgewicht wieder hergestellt. </font><font style="vertical-align: inherit;">Nach der Aggregation belassen wir zunächst nur jedes millionste Schlüssel-Wert-Paar und übergeben es dann an den Logger. </font><font style="vertical-align: inherit;">Eine Milliarde Datenelemente und ein Satz von 500 Millionen Schlüsseln wurden verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bei einem Knoten haben wir den Förderer mit Aggregation ohne Müll und damit getestet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen auf drei Knoten: Ergebnis</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben diesen Benchmark auf einem AWS-Cluster aus drei c5d.4xlarge-Instanzen ausgeführt. Sie hatten 16 virtualisierte Prozessorkerne und 32 GB Speicher. Kanalbandbreite 10 Gbit / s. Ergebnis:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/579/cc6/a6d/579cc6a6d172a6098f96b3c2b9cfbda8.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b28/32f/ca6/b2832fca67b0123a6ca976e518ecd87c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nebenbei stellen wir eine ungefähr dreifache Steigerung des Durchsatzes im Vergleich zu einem einzelnen Knoten fest. Dies ist eine Folge der verteilten Verarbeitung. Bei den Monteuren wurde die Kombination von G1 und JDK 11 zum Gewinner beider Tests. Ein weiteres bemerkenswertes Ergebnis war die fast nicht funktionsfähige Kombination von G1 und JDK 8. Dies hat jedoch tiefere Gründe, die sich auf andere Dimensionen auswirken. Zum Beispiel der offensichtliche Vorteil von Parallel unter JDK 8 und JDK 11. Dies ist auf den Effekt zurückzuführen, den wir ganz am Anfang festgestellt haben: Sobald ein Knoten für die Speicherbereinigung pausiert, wird die Verarbeitung im gesamten Cluster gestoppt. Und G1 auf JDK 8 steigt für sehr lange Pausen, mehr als eine Minute. Dies reicht aus, damit der Fehlerdetektor im Cluster funktioniert und entscheidet, dass der Knoten gestorben ist. Die Aufgabe schlägt fehl, der Cluster organisiert sich neu und die Aufgabe wird auf zwei Knoten erneut gestartet.Dies führt noch schneller zu einem neuen Fehler, da jeder Knoten jetzt mehr Daten verarbeitet. Gleichzeitig tritt der ausgeworfene Knoten erneut bei, und die Aufgabe wird erneut auf zwei Knoten gestartet, jedoch auf anderen. Es gibt eine endlose Schleife von Neustartaufgaben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parallele Pausen sind nicht so lang, dass der Cluster beschädigt wird, aber bei Tests auf demselben Knoten hat es viel schlechter funktioniert. Auf drei Knoten verlor er 30% gegen G1 und JDK 11. Und in größeren Clustern wird die Situation noch schlimmer sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich alle Tests ansehen, ist es überraschend, dass Parallel unter JDK 8 schneller ausgeführt wird als unter JDK 11. Dies ist jedoch auf einen sehr guten Zufall zurückzuführen: In diesen Testläufen wurden auf allen Knoten synchron vollständige Pausen gestartet, wodurch die Arbeit des Kollektors parallelisiert wurde. Auf diesen Effekt kann man sich natürlich nicht verlassen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass wir in unserer Testkonfiguration bei Verwendung von Parallel den katastrophalen Effekt langer Pausen auf die Clusterstabilität nicht beobachtet haben, ist dies ein sehr wahrscheinliches Szenario. </font><font style="vertical-align: inherit;">In anderen Tests wirkte Parallel genauso destruktiv, wenn wir den Heap und die Datenmenge erhöhten oder denselben Heap verließen, aber die operative Marge verringerten. </font><font style="vertical-align: inherit;">Aber selbst wenn es nicht zu Fehlern führte, verschwand sein Vorteil in den Diagrammen, wenn auf demselben Knoten gearbeitet wurde. </font><font style="vertical-align: inherit;">Es ist zu erwarten, dass sich die Situation durch das Hinzufügen neuer Knoten zum Cluster verschlechtert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der anderen Seite arbeiteten einige G1 und JDK 11 mit relativ kurzen Pausen, sodass der Förderer nicht anhielt. </font><font style="vertical-align: inherit;">Es verfügt über einen Mechanismus, der kurze Ausfallzeiten verringert. Während die Pausen 150 ms nicht überschreiten, hat die Speicherbereinigung nur lokale Auswirkungen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de507198/index.html">Podcasts als Unternehmensmedien: Wie man damit Geld verdient und welche Metriken verwendet werden sollen</a></li>
<li><a href="../de507200/index.html">7 Möglichkeiten, wie Data Scientists Sie täuschen</a></li>
<li><a href="../de507202/index.html">Avito Analytics-Treffen</a></li>
<li><a href="../de507204/index.html">Innenküche im Industriedesign: von der Skizze bis zum Produkt im Karton</a></li>
<li><a href="../de507206/index.html">Architektur Y Messenger</a></li>
<li><a href="../de507212/index.html">Trainieren Sie Smart-Gaming-Rivalen in Unity mithilfe der "Play with yourself" -Methode mithilfe von ML-Agents</a></li>
<li><a href="../de507214/index.html">So erstellen und ändern Sie interaktive PDF-Formulare oder die neue Fähigkeit ABBYY FineReader PDF</a></li>
<li><a href="../de507218/index.html">Lesen Sie mich oder warum der Text nicht bis zum Ende gelesen wird</a></li>
<li><a href="../de507222/index.html">Warum jeder Masken tragen sollte</a></li>
<li><a href="../de507224/index.html">So beseitigen Sie blinde Flecken mit visuellen Tests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>