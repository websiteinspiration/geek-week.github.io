<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏾 🔉 😈 メール配信時：iOSでのプッシュ通知の喪失との戦い 👵🏿 🏍️ 🛌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ユーザーの側では、電子メールクライアントは単純なアプリケーションです。 Yandex.Mailの開発者は、アプリケーションには3つの画面しかないと冗談を言っています。手紙を送る;画面について。
 
 しかし、多くの興味深いことが内部で起こっています。多くのモバイルアプリと同様に、Mailはプッシュ通...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>メール配信時：iOSでのプッシュ通知の喪失との戦い</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462507/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーの側では、電子メールクライアントは単純なアプリケーションです。 Yandex.Mailの開発者は、アプリケーションには3つの画面しかないと冗談を言っています。手紙を送る;画面について。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、多くの興味深いことが内部で起こっています。多くのモバイルアプリと同様に、Mailはプッシュ通知を使用してユーザーと対話します。多くのiOSアプリケーションと同様に、Appleプッシュ通知サービスの性質上、Mailは一部の通知を失います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex.Mail iOSグループの責任者</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asya Sviridenko</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムの制限を考慮に入れても、プッシュ通知の損失は、アプリケーションにとって重要である場合に対処でき、対処する必要があることを証明します。</font><font style="vertical-align: inherit;">新しいメールのプッシュ通知は、ユーザーがアプリケーションをインストールする対象であるため、これはメールにも当てはまります。</font><font style="vertical-align: inherit;">アプリケーションにとって、プッシュ通知の配信がそれほど重要ではない場合でも、モバイルYandex.Mailが積み重ねた自転車を見つけることは興味深いことです。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/SVCMbPIuy8w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、リモート通知、つまりAPN（Apple Push Notification Service）を介してサーバーから送信される通知に関するものです。</font><font style="vertical-align: inherit;">ローカル通知については触れず、以下については説明しません。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プッシュ通知を操作するためのAPIはどのようなものですか。</font><font style="vertical-align: inherit;">プッシュ通知配信スキームと、このスキームで損失が発生する可能性のある場所を検討してください。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex.Mailでの損失への対処をどのように決定しましたか-プッシュ通知キューについて。</font></font></li>
<li>       .</li>
</ul><a name="habracut"></a><br>
<h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、プッシュ通知を操作するためのAPIは、多くの興味深いことを実行できる強力なものになります。しかし、常にそうであるとは限りませんでした。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p6/ln/n1/p6lnn1nbbopnz4xr9k2xiuf1dre.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は、プッシュ通知はこのように表示されていました。画面にポップアップ表示され、現在のアプリケーションでの作業がブロックされ、何も実行できず、永久に消えてしまい、それに関する通知はありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それから十分な時間が経ちました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nq/kr/9j/nqkr9jbh2v4nwacrbhksoa1tpy0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者としての私たちにとって、</font><font style="vertical-align: inherit;">プッシュ通知がサードパーティのライブラリで利用可能になったとき</font><font style="vertical-align: inherit;">、それは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてiOS 3で始まりました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通知センターはiOS 5</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><strong><font style="vertical-align: inherit;">登場し</font></strong><font style="vertical-align: inherit;">、プッシュ通知はどこにも行かなくなったが、今では通知センターに残り、そこで再び表示することができる。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOS 6では、サイレントが導入されました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ユーザーは、通知を受け取りたくない期間を設定する機会があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの変更は主に、ユーザーがプッシュ通知をどのように操作できるか、ユーザーがプッシュ通知をより快適にできるようにする方法であり、開発者が通知に影響を与える方法ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者にとって重要なマイルストーンは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iOS 8と、</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プッシュ通知によって特定のアプリケーションに固有のアクションを実行することを可能にする</font><strong><font style="vertical-align: inherit;">通知アクションの出現でした</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOS 10は通知サービス拡張と通知コンテンツ拡張を導入します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。最初の方法では、ユーザーに表示される前にプッシュ通知を変更できます。 2つ目は、Force Touchでプッシュ通知によっていくつかのUIを表示することです。たとえば、より詳細な情報を表示できます。 iOS 10では、このUIはクリックできませんでした-見ることができ、触ることはできません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOS 11は通知プライバシー設定を導入しました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これで、ユーザーは設定に移動して、受信した通知の内容を希望するかどうかを指定できます。これはセキュリティへの大きな一歩です。すべてのユーザーが、テーブルの上に横たわっているiPhoneに個人情報が突然ポップアップすることを望んでいるわけではないことを理解するのに、iOSのバージョンは8つだけでした。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iOS 12はプッシュ通知をグループ化する機能を追加します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thread-idにより、iOS 10でNotification Content Extensionを使用して取得したUIがクリック可能になりました。</font><font style="vertical-align: inherit;">ここで、ボタンとジェスチャーコントロールを追加できます。これらはすべて、ユーザーがUIを操作するのに役立ちます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今日のプッシュ通知</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、プッシュ通知は長い道のりを歩んできました。今日では、プッシュ通知を使用して、本当に多くのことができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テキストメッセージとローカリゼーション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前と同様に、プッシュ通知でテキストメッセージを送信できますが、ローカライズ用のキーを追加で指定できるようになりました。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-string">"aps"</span> : {
    <span class="hljs-string">"alert"</span> : {
        <span class="hljs-string">"title"</span> : <span class="hljs-string">"New Mail"</span>,
        <span class="hljs-string">"subtitle-loc-key"</span> : <span class="hljs-string">"alert_subtitle_localization_key"</span>,
        <span class="hljs-string">"loc-key"</span> : <span class="hljs-string">"alert_body_localization_key"</span>,<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通知ペイロードで</font><font style="vertical-align: inherit;">
を指定する</font></font><code>subtitle-loc-key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>loc-key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、デバイスにプッシュ通知が送信されると、Localizable.stringでアプリケーションファイルに目的の値が見つかり、ローカライズされたメッセージが表示されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">健全で重大な警告</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前と同様に、ペイロード通知にサウンドを追加できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-string">"aps"</span> : {
    <span class="hljs-string">"sound"</span> : {
        <span class="hljs-string">"critical"</span> : <span class="hljs-number">1</span>,
        <span class="hljs-string">"name"</span> : <span class="hljs-string">"bingbong.aiff"</span>,
        <span class="hljs-string">"volume"</span> : <span class="hljs-number">1.0</span>,<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クリティカルアラートはiOS 12で登場しました。</font><font style="vertical-align: inherit;">これらは、ユーザーがサイレントモードであっても再生されるサウンドです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、ユーザーは、たとえば、新しい番号がリリースされたことを報告するために、夜間に雑誌を購読しているアプリケーションを必要としません。</font><font style="vertical-align: inherit;">したがって、Appleはクリティカルアラートを使用できるアプリケーションを制限しています。</font><font style="vertical-align: inherit;">アプリケーションが正常性、安全性で動作する場合、またはクリティカルアラートがユーザーがアプリケーションを操作するのに役立つものであると思われる場合は、アップルにご連絡ください。</font><font style="vertical-align: inherit;">おそらく、この機能を使用できるようになるでしょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイレント通知</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーにはサイレント通知は表示されません。</font><font style="vertical-align: inherit;">ユーザーはアプリケーションに直接アクセスして起動し、アプリケーションを最新の状態にするためのいくつかのアクションを実行できます。サーバーにリクエストを送信し、バックグラウンドでデータをリクエストし、データベースからデータを更新し、UIを更新して、ユーザーがアプリケーションに入ると、更新されたデータ。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-string">"aps"</span> : {
    <span class="hljs-string">"content-available"</span> : <span class="hljs-number">1</span>
    <span class="hljs-comment">//   alert, sound  badge   payload</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プッシュ通知をサイレントで行うには、ペイロードにThe：を指定する必要があります</font></font><code>"content-available" : 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">また、ペイロードにはアラート、サウンド、バッジキーを指定しないでください。これらは、ユーザーに表示されないプッシュ通知にはまったく役に立ちません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通知のグループ化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージをグループ化するには、ペイロードに「thread-id」を指定する必要があります。</font><font style="vertical-align: inherit;">アカウント別、受信者別、トピック別など、さまざまな方法でグループ化する場合は、同じアプリケーション内でいくつかの意味を持つ可能性があります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-string">"aps"</span> : {
    <span class="hljs-string">"thread-id"</span> : <span class="hljs-string">"any_thread_identifier"</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは非常に便利です。これは、プッシュ通知がロックされた画面のすべてのスペースを占有するのではなく、グループ化されるためです。</font><font style="vertical-align: inherit;">この機能をまだ使用していない場合は、開始する時間です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示する前に通知を変更する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プッシュ通知は、表示される前に変更できます。</font><font style="vertical-align: inherit;">これを行うには、通知コンテンツ拡張機能をアプリケーションに追加し、メソッドをオーバーライドする必要があります</font></font><code>didReceive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このメソッドでは、通知コンテンツを取得して変更できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-string">"aps"</span> : { <span class="hljs-string">"mutable-content"</span> : <span class="hljs-number">1</span> }
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">didReceive</span><span class="hljs-params">(<span class="hljs-number">_</span> request: UNNotificationRequest,
      withContentHandler contentHandler: @escaping <span class="hljs-params">(UNNotificationContent)</span></span></span> -&gt; <span class="hljs-type">Void</span>) {
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> mutableContent = request.content.mutableCopy()
                        <span class="hljs-keyword">as</span>? <span class="hljs-type">UNMutableNotificationContent</span> <span class="hljs-keyword">else</span> {<font></font>
        contentHandler(request.content); <span class="hljs-keyword">return</span><font></font>
    }<font></font>
    mutableContent.subtitle = <span class="hljs-string">"Got it!"</span><font></font>
    contentHandler(mutableContent)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、通知内のメディアコンテンツへのリンクを送信し、拡張機能でコンテンツをダウンロードして、ダウンロードしたものを通知に添付できます。</font><font style="vertical-align: inherit;">その後、新しいコンテキストで完了を呼び出し、拡張プッシュ通知をユーザーに表示します。</font><font style="vertical-align: inherit;">タイトル、サブタイトルなどを変更できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の興味深いケースは、データをさらに保護したいのにAppleがそれを見なかった場合に、暗号化されたコンテキストでプッシュ通知を送信できることです。</font><font style="vertical-align: inherit;">通知コンテンツ拡張機能では、それらを復号化して、ユーザーがすでに復号化したデータを表示できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非表示の通知コンテンツ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iOS 11では、プッシュ通知の内容を非表示にすることが可能になり、開発者として私たちはこれに何らかの影響を与えることはできません。</font><font style="vertical-align: inherit;">ユーザーが「通知コンテンツを非表示にする」を選択した場合、何らかの方法で非表示になります。</font><font style="vertical-align: inherit;">UNNotificationCategoryを使用して、コンテンツの代わりに表示されるプレースホルダー（デフォルトでは通知）を指定し、タイトルとサブタイトルのどちらを表示するかを設定できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">let</span> commentCategory = <span class="hljs-type">UNNotificationCategory</span>(identifier: <span class="hljs-string">"comment-category"</span>,<font></font>
                actions: [],<font></font>
                intentIdentifiers: [],<font></font>
                hiddenPreviewsBodyPlaceholder:<font></font>
<span class="hljs-type">NSString</span>.localizedUserNotificationString(forKey:<span class="hljs-string">"COMMENT_KEY"</span>,arguments: <span class="hljs-literal">nil</span>),<font></font>
                options: [.hiddenPreviewsShowTitle])</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションを起動しないでの通知手順</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーション自体を起動せずにプッシュ通知のアクションを実行するには、カテゴリを作成してアクションを追加する必要があります。</font><font style="vertical-align: inherit;">カテゴリ識別子は、ペイロード通知のカテゴリフィールドに渡されます。</font><font style="vertical-align: inherit;">さまざまなアクションをさまざまなタイプの通知に接続できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-string">"aps"</span> : { <span class="hljs-string">"category"</span> : <span class="hljs-string">"message"</span> }
<span class="hljs-keyword">let</span> action = <span class="hljs-type">UNNotificationAction</span>(identifier:<span class="hljs-string">"reply"</span>, title:<span class="hljs-string">"Reply"</span>, options:[])
<span class="hljs-keyword">let</span> category = <span class="hljs-type">UNNotificationCategory</span>(identifier: <span class="hljs-string">"message"</span>,<font></font>
                actions: [action],<font></font>
                minimalActions: [action],<font></font>
                intentIdentifiers: [],<font></font>
                options: [])<font></font>
<span class="hljs-type">UNUserNotificationCenter</span>.current().setNotificationCategories([category])</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">豊富な通知</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この拡張機能では、プッシュ通知に追加した追加のアクションを処理して、カスタムUIを表示できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、アプリケーションに通知コンテンツ拡張機能を追加し、その中にUNNotificationContentExtensionから継承するクラスを定義して、通常のUIViewControllerと同様に操作する必要があります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotificationViewController</span>: <span class="hljs-title">UIViewController</span>, <span class="hljs-title">UNNotificationContentExtension</span> </span>{
    <span class="hljs-meta">@IBOutlet</span> <span class="hljs-keyword">var</span> userLabel: <span class="hljs-type">UILabel?</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">didReceive</span><span class="hljs-params">(<span class="hljs-number">_</span> notification: UNNotification)</span></span> {
        <span class="hljs-keyword">let</span> content = notification.request.content
        <span class="hljs-keyword">self</span>.title = content.title
        <span class="hljs-keyword">let</span> userInfo = content.userInfo
        <span class="hljs-keyword">self</span>.userLabel?.text = userInfo[<span class="hljs-string">"video-user"</span>] <span class="hljs-keyword">as</span>? <span class="hljs-type">String</span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カスタムアクションを処理する場合、これらのアクションは、ユーザーに表示しているUIを更新する価値があることを覚えておくことが重要です。</font><font style="vertical-align: inherit;">この拡張機能にビジネスロジックを実装する必要はありません。</font><font style="vertical-align: inherit;">ここではなく、メインアプリケーションでプッシュ通知を使用して、アクションによってサーバーにリクエストを送信します。</font><font style="vertical-align: inherit;">この場所はUI専用です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プッシュ通知配信スキーム</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iOSのプッシュ通知でできることをご覧ください。</font><font style="vertical-align: inherit;">バージョンごとに新しい機能が増えていますが、プッシュ通知の配信スキームはiOS 3とまったく同じになりました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gt/pb/dd/gtpbdd_4eu403euuueyxscvk8bw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プッシュ通知の配信スキームは最初から美しいと思いますが、そうではありません。そう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プッシュ通知配信スキームには3つの主要なノードがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ペイロードプッシュ通知を生成するプロバイダー。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APN-通知を配信するApple Push Notification Service。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iOSデバイスとアプリケーション。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
登録方法、トークンの受け取り方法、送信先については省略します。</font><font style="vertical-align: inherit;">これがすべてあるとしましょう。</font><font style="vertical-align: inherit;">次は何が起こる？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロバイダーはペイロードを生成し、それをAPNに送信します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APNはそれをデバイスに送信します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーはデバイスにプッシュメッセージを表示します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メールおよび他の多くのアプリケーションは、高度なプッシュ通知配信スキームを使用します。通知サービス拡張機能が追加され、そこからプッシュ通知が送信され</font></font><code>"mutable-content" : 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。プロバイダーは、アプリケーションのバックエンドロジックを処理するサーバーと、ペイロードを生成してサブスクリプションを処理するプロバイダー自体に分かれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandexでは、ペイロードを形成するプロバイダーはXIVAと呼ばれます。 XIVAはサブスクリプションデータベースです。 MailはXIVAを使用して、サードパーティのライブラリとしてプッシュ通知を処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mailでは、サブスクリプションの処理はかなり重要なものとして整理されています。</font><font style="vertical-align: inherit;">通知用のアプリケーションに署名するだけでなく、マルチアカウントを持っています。</font><font style="vertical-align: inherit;">異なるアカウントに署名したり、1つのアカウント内で、ユーザーが通知を受信したいフォルダーと、希望しないフォルダーを選択したりできます。</font><font style="vertical-align: inherit;">XIVAはこのすべてを扱います。</font><font style="vertical-align: inherit;">他のいくつかのYandexサービスもXIVAを介して機能します。アプリケーション、通知、サブスクリプション、トークンに関するすべての情報はXIVAに保存されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">損失は​​どこにありますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プッシュ通知配信スキームには4つの矢印があり、これらの遷移の3つで損失が発生する可能性があります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーとXIVAの間</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、次の場合に損失が発生する可能性があります。ユーザーは手紙を受け取り、サーバーはそれを知っており、通知を生成してXIVAに送信します。ただし、アプリケーションのユーザーがオフライン中に特定のフォルダーの「購読」を選択した場合など、XIVAはこの情報を失う可能性があります。その場合、XIVAはフォルダーのサブスクライブに関する情報を受信せず、ペイロードが到着したときにそれを削除するだけで、ユーザーには通知が表示されません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XIVAとAPNの間では</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ネットワークが失われる可能性があります。ネットワークにはほとんど影響を与えないので、この点については説明しません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APNsと内線間、またはAPNSとiOS間</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張機能を使用していない場合。これは最も一般的なタイプの損失です。 APNがデバイス上のアプリケーションごとに複数のプッシュを保存しないため、このような損失が発生します。ユーザーがオフラインのときにいくつかの通知を受け取った場合、オンラインになると、最後のメッセージのみが表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは、配信を保証したりプッシュ通知に依存したりできない損失と同じです。 Appleは、配信が保証されていないことを明確に書いています。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExtensionアプリケーションとiOSの間では、損失</font></font></strong><strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は発生しません</font></font></em></strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。Appleはこれを保証しています。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extensionを使用して、didReceiveContentをcompletionメソッドでオーバーライドした場合、この完了を呼び出さなくても、通知はとにかく表示されます。</font><font style="vertical-align: inherit;">これは覚えておくことが重要です。</font><font style="vertical-align: inherit;">呼び出すことはできません。または呼び出す時間がない場合でも、通知はAPNからのフォームで変更なしに表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APNsとExtensionの間の損失にどのように対処するかを見ていきます。</font><font style="vertical-align: inherit;">ただし、プッシュ通知の配信可能性を高める必要がある場合は、スキーム全体を確認してください。</font><font style="vertical-align: inherit;">プロバイダーがAPNと正常に対話する場合など、サービス側に損失がないかどうかを確認します。</font><font style="vertical-align: inherit;">チェーン全体をチェックして測定し、損失が最も多い場所と、この回路のどの部分を変更するべきかを判断します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プッシュ通知キュー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APNと拡張機能のバンドルでの損失に対処する方法は、プッシュ通知キューと呼ばれていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストーリー全体を1つのフレーズに圧縮すると、次のようになります。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プッシュ通知を見逃した場合は、再度リクエストできます。</font></font></blockquote><br>
<img src="https://habrastorage.org/webt/mi/dl/c8/midlc81bedgy18xv4gzgmkyb7zo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの通知配信スキームでは、同じ参加者はすべてXIVA、APN、拡張です。</font><font style="vertical-align: inherit;">簡略化されたスキームは次のように機能します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XIVAは、APNに送信する予定のプッシュ通知に番号を付けてから、情報を送信します。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張機能はプッシュ通知番号1を受け取り、しばらくすると番号3を受け取ります。一部のデータが欠落していることを理解しています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XIVAに、最後に受信した位置の要求を送信し、差分を取り、不足しているデータを再度送信するように要求します。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XIVAはペイロードデータベースとサブスクリプションデータベースを格納するため、プッシュ通知を再送信します。</font><font style="vertical-align: inherit;">すべてのサブスクリプションはしばらくの間保存され、再リクエストできます。</font></font></li>
<li>,  push-,      ,     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に予想される問題は、通知の重複です。</font><font style="vertical-align: inherit;">XIVAにメッセージを繰り返しリクエストする場合、直接ではなくAPNを介してメッセージと通信するため、送信キューに何があるのか​​わかりません。</font><font style="vertical-align: inherit;">一部の通知が欠落しているのを確認し、XIVAにリクエストを送信したとします。</font><font style="vertical-align: inherit;">XIVAはペイロードAPN経由で送信され、通知が届かなかった。</font><font style="vertical-align: inherit;">しかし、それを受け取る前に、別のペイロードとパスを受け取りました。</font><font style="vertical-align: inherit;">彼らは再び尋ねた-XIVAは再び送った。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通知が重複しないように、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apns-collapse-id</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この設定により、iOS側で同じIDのプッシュ通知を折りたたむことができます。</font><font style="vertical-align: inherit;">同じapns-collapse-idを持つ複数のプッシュ通知がデバイスに到着した場合、iOSはそれらを折りたたみ、ユーザーには1つの通知のみが表示されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XIVA</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンドで何が発生するかは常に気になるため、XIVAですべてがどのように機能するかを説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XIVAは、プッシュ通知キューの前に存在し、サブスクリプションデータベースでした。</font><font style="vertical-align: inherit;">データベースでは、すべてがユーザーによって格納されていることが重要です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼は鍵を務めた</font></font><code>&lt;service, user&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ペイロードは値として保存されました（メールの場合は文字に関するデータ）。&nbsp;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XIVAはiOSだけでなく機能するため、データベースからデータを取得してAPNsまたは別のサービスに送信しました。再利用することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはXIVA開発チームに来て、本当にプッシュ通知キューを要求しました。原則として、XIVAにはこのためのすべてがすでにあります。つまり、データベース、ペイロードのTTL、つまり、すぐには削除されず、転送することができます。欠けていた唯一のことは、番号付けにより、現在のXIVA実装の一部としてプッシュ通知キューを構成できることでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パススルー番号付けの場合、プッシュ通知はデバイスとapp_nameで番号付けする必要があります。つまり、エンドツーエンドの番号付けは、特定のデバイスおよび特定のアプリケーションで、クライアント側でそれに依存するために必要です。 XIVAデータベースを再利用しましたが、別のキーを使用してペイロードをデータベースに書き込み始めました。これで、apns_queueはユーザーとしてサービスとして</font></font><code>device_id + app_name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能します</font></font><code>key: &lt;apns_queue, device_id + app_name&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、クライアント上で番号付けが必要なデータ</font><font style="vertical-align: inherit;">そのもの</font><font style="vertical-align: inherit;">です</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、XIVAはメインデータベースからデータを取得し、送信する必要があるときにそれをキューに入れます。この時点で、ペイロードは新しいデータベースにありますが、キーが異なるため、新しい番号が付けられます。すでにそこからXIVAがそれらを取り出し、APN経由で送信します。全体として、クライアントは必要なペイロード番号を受け取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントは通知サービス拡張を使用します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">didReceive</span><span class="hljs-params">(<span class="hljs-number">_</span> request: UNNotificationRequest, withContentHandler
                contentHandler: @escaping <span class="hljs-params">(UNNotificationContent)</span></span></span> -&gt; <span class="hljs-type">Void</span>) {
        <span class="hljs-comment">// . . .</span>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その中でメソッドを再定義</font></font><code>didReceive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、サーバーからの結果を確認します。</font><font style="vertical-align: inherit;">すべてのプッシュ通知を追加</font></font><code>"mutable-content" : 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して、拡張機能に該当するようにします。そうしないと、計算でそれらを考慮に入れることができないためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、メソッド内のコードには継続的なチェックがあります。必要なペイロードが来たかどうか、それを解析できるかどうかです。</font><font style="vertical-align: inherit;">解析されない場合、このメッセージはXIVAからのものではありません。</font><font style="vertical-align: inherit;">メッセージがXIVAからのものではない場合、それを使用して作業を続けることはできず、APNからの通知で完了を呼び出すだけで、計算は実行されません。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> payload = <span class="hljs-keyword">try</span>? <span class="hljs-keyword">self</span>.payloadParser.parsePayload(from: request.content.userInfo) <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//  ,     xiva</span>
        contentHandler(request.content); <span class="hljs-keyword">return</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ログインして、deviceIdが変更されたかどうかを確認します。これは、iOSでは可能であることを認識しているためです。</font><font style="vertical-align: inherit;">正直なところ、deviceIdの変更は発生していませんが、変更する場合、XIVAからの番号を信頼できないため、処理している場合に備えて。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">self</span>.logger.logNotificationReceived(with: payload)
<span class="hljs-keyword">if</span> lastPositionDeviceId != deviceId {
        <span class="hljs-comment">// deviceId ,   </span>
        lastNotificationPosition = <span class="hljs-literal">nil</span><font></font>
        lastPositionDeviceId = deviceId<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、このペイロードでXIVAデータを受信できるかどうか、受信できるかどうかを調べます。</font><font style="vertical-align: inherit;">そうでない場合は、contentHandlerを再度呼び出します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> xivaInfo = payload.xivaInfo <span class="hljs-keyword">else</span> {<font></font>
        contentHandler(request.content); <span class="hljs-keyword">return</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データがある場合は、deviceIdがデータを受信したかどうかを確認します。</font><font style="vertical-align: inherit;">XIVAはデバイスのハッシュをペイロードに送信します。検証されて一致する場合、続行します。いいえ、contentHandlerを呼び出します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">guard</span> isHashCompatible(deviceId: deviceId, deviceIdHash: xivaInfo.deviceIdHash) <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// payload device_id   device_id </span>
        contentHandler(request.content); <span class="hljs-keyword">return</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のブロックは、保存された位置があるかどうかを確認することです：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後に保存した位置がない場合は、通知をまだ受け取っておらず、内線番号を入力していないか、何らかの理由で削除されています。</font><font style="vertical-align: inherit;">次に、差分を見逃すためにプッシュするものは何もありません。もう一度完了と呼びます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある場合は、次に進みます。</font></font></li>
</ul><br>
<pre><code class="swift hljs"><span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> lastPos = lastNotificationPosition <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//     </span><font></font>
        lastNotificationPosition = xivaInfo.notificationPosition<font></font>
        contentHandler(request.content); <span class="hljs-keyword">return</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不在通知の数をカウントします。</font><font style="vertical-align: inherit;">ゼロの欠落が問題なければ、何も見逃していません。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">let</span> missedMessages = xivaInfo.notificationPosition - lastPos - <span class="hljs-number">1</span>
<span class="hljs-keyword">guard</span> missedMessages &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//   push–    </span>
        contentHandler(request.content); <span class="hljs-keyword">return</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それ以外の場合は、位置に関するXIVAデータから取得します-その番号付けから。さらに、逃した量が特定の設定値を超えていないかどうかを調べます。</font></font><br>
<br>
<pre><code class="swift hljs">lastNotificationPosition = xivaInfo.notificationPosition
<span class="hljs-keyword">guard</span> missedMessages &lt;= repeatMaxCount <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//    ,  </span>
        contentHandler(buildNewNotification()); <span class="hljs-keyword">return</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれが必要なのですか？ユーザーが長い間オフラインになっていて、この間に何百もの不在メッセージが蓄積されたとします。全体を要求します（私たちにとっては簡単です）。XIVAは全体を送信し、ユーザーはすべての通知を受け取ります。スレッドIDでグループ化した場合（およびそれらをグループ化した場合）でも、通知ごとにこの拡張機能が呼び出され、すべてのチェックに合格します。ユーザーが100通の通知をすべて必要とする可能性は低いようです。したがって、100通のメッセージが届かなかったという通知を生成し、アプリケーションに移動して確認します。また、プッシュ通知を置き換えることができるため、ユーザーにこのメッセージを正確に表示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのチェックに合格したら、XIVAにリクエストを送信します。つまり、最後に到達した位置と、受信されなかったメッセージの数です。そして見て：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XIVAが正常に応答した場合：「すべて問題ありません。データを送信します」、ユーザーに現在の通知を表示し、XIVAが他のすべてを送信し、ユーザーがすべての失われたメッセージを表示するまで待機します。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XIVAがエラーで応答した場合、アプリケーションで表示できるメッセージを見逃したというカスタム通知をユーザーに表示します。&nbsp;</font></font></li>
</ul><br>
<pre><code class="swift hljs"><span class="hljs-keyword">self</span>.requestMissedNotifications(lastPosition: xivaInfo.notificationPosition,<font></font>
                    gap: missedMessages) { result <span class="hljs-keyword">in</span>
        result.onValue { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>
             <span class="hljs-keyword">self</span>.logger.logNotificationProcessed(with: .success)<font></font>
            contentHandler(request.content)<font></font>
        }.onError { error <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">self</span>.logger.logNotificationProcessed(with: .failure(error))<font></font>
            contentHandler(buildNewNotification())<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、クライアントでの実装は、受信したデータを処理できるかどうかを確認する多数のチェックに帰着します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロギングとその他の問題</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存知のように、アプローチが適切に機能することを確認するには、ログに記録する必要があります。</font><font style="vertical-align: inherit;">通知を配信するための新しい方法に関する統計の収集を開始し、配信可能性がどのように変化したかを比較しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プッシュ拡張の制限</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に遭遇したのは、プッシュ拡張の制限です。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常に呼び出されるわけではありません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。アプリケーション設定で通知描画をオフにすると（通知を受信する機能はオンのままですが、可能なすべてのレンダリングがオフになります）、拡張機能は呼び出されません-再カウントを伴うすべてのロジック、そして最も重要なことに、ロギングは呼び出されません。ユーザーにとって最も重要なこと、つまりユーザーが通知を受け取ったかどうかを確認することはできません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プッシュ拡張には時間制限があり</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。 Appleのドキュメントによると、約30秒以内に変更した通知で完了を呼び出す必要があります。そうしないと、最初の通知が表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どうやってそれを理解したのかしら。 「美しい」プッシュ通知と呼ばれる機能を実装し、通知にメディア要素を添付し、タイトル、サブタイトルを変更しました。テスト中に、いくつかのプッシュ通知が美しくなり、残りの醜いアヒルの子が残っていることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはこれらのプッシュ通知の違いを検討し始めましたが、何とかして完了を呼び出すことができたものだけに違いがないことがわかりました。したがって、時間がない場合、プッシュ通知はAPNから送信された形式で正確に表示されます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3番目の制限はメモリからです</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Appleは、プッシュ拡張に割り当てられるメモリが限られていることを警告し、大量のデータをロードすることを推奨しませんが、正確なサイズを指定しません。これは約12 MBであることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
で、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appleデベロッパフォーラム、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発者が積極的に、制限されている彼らの仮定を表現し、それらを正確に計算してみてください何を議論しています。</font><font style="vertical-align: inherit;">メモリの制限は少し異なりますが、順序はほぼ同じです-10 MB。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロギングを追加するときにこの制限が発生しました。</font><font style="vertical-align: inherit;">ログにはYandex AppMetricaを使用します。</font><font style="vertical-align: inherit;">私たちが始めたとき、AppMetricaはロードするために大量のメモリを必要としており、拡張機能は常に落ちていました。</font><font style="vertical-align: inherit;">したがって、通知の受信を保証するために、小さな自転車を積み上げる必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果の測定はゲームになりました。エクステンションとプレッジデータを削除しないようにしてください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果の測定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロギングの結果として、プッシュ拡張はデータをUserDefaultsに書き込みます。次に、メインアプリケーションが起動すると、データをAppMetricaに送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチには欠点があります。主なものは測定に影響します。ユーザーが必ずしも同じ日にアプリケーションを起動するとは限らないことを考慮する必要がありました。これは1か月で発生する可能性があります。したがって、当日または翌日にアプリケーションを起動したユーザーの測定値のみに基づいて結論を導き出します。そうしないと、XIVAが送信したデータ（ログに記録）とユーザーが受信したデータの間に大きな差異が生じます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notification ExtensionはiOS 10以降で機能することを覚えておくことが重要です。Extensionを介してデータをログに記録する場合は、以前のバージョンを使用しているユーザーに関するデータを忘れずに削除してください。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">防衛では</font></font></strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppMetrica</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：多くはそれ以来行われてきた、プッシュ拡張子は長い時間のためにメモリから落ちていません。 AppMetricaにはプッシュ通知ロギングがあり、近い将来、自転車を捨てて通常のロギングに戻ると思います。可能なことは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppMetrica Push SDKで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読むことができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが測定結果です。 1月のスケジュール-ラインが実装される前でした。垂直配信、水平時間。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tg/k_/nk/tgk_nkvmus8kud-brgg6v9jvmhm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明示的なクラッシュとは、ユーザーが通知を送信したりメールを開いたりする頻度が低くなる週末です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プッシュ通知キューを導入した後、スケジュールの性質は保持されましたが、配信可能性ははるかに高くなりました-2月のスケジュール。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デリバリーが増加しています。つまり、正しい方向に進んでいます。</font><font style="vertical-align: inherit;">ここで止めることは可能ですが...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">欲求不満</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードを書き、数を数え、グラフィックを描きました。</font><font style="vertical-align: inherit;">しかし、それが機能したかどうかを判断するにはどうすればよいですか？</font><font style="vertical-align: inherit;">プッシュ通知キューを実装したことから何か変更はありますか？</font><font style="vertical-align: inherit;">配信可能性は向上しましたが、これはアプリケーションの処理にどのように影響しましたか？</font><font style="vertical-align: inherit;">これにより、ユーザーエクスペリエンスと作業シナリオはどのように変わりましたか？</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1日に2〜20通の通知が表示されるという事実から、ユーザーは幸せになったでしょうか。</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たち、開発、タスク、解決策を考え出し、コードを書いて、結果を得て、それは幸せになりました。</font><font style="vertical-align: inherit;">しかし、製品の観点からは、何がプッシュ通知の配信を正確に増加させたのかを完全には理解していませんでした。</font><font style="vertical-align: inherit;">おそらくこれが次の話のトピックになるでしょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iOSのプッシュ通知は長い道のりを歩んできました。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションでそれらをまだ使用していない場合、または最小限に使用している場合は、Yandex.Mailの例をご覧ください。おそらくいくつかの解決策が役立つでしょう。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見逃されたプッシュ通知は再リクエストすることができます（また、そうする必要があります）。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> XIVAを介したYandex.Mailのように、これを行うことは完全にオプションです。多分あなたはこれであなたを助ける同様のサービスを持っています。たぶんあなたは、同様のことをする方法も知っているサードパーティを見つけるでしょう。それを探す！</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プッシュ拡張の制限を覚えておいてください。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリからオーバーロードしないでください。制限時間を考慮してください。呼び出されていることを確認してください。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配信の改善によって何が得られるかを考えてください。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この冒険に参加する前に、それが必要かどうか、それがアプリケーションに何かをもたらすかどうかについて考えてください。アプリケーションのプッシュ通知を増やすことは絶対に重要ではなく、何も提供しない可能性があります。しかし、おそらく、それはユーザーの成長をもたらし、あなたはApp Storeのトップに立つでしょう。</font></font><br>
<br>
<blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">AppsConf</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a> ,     21  22      ,        ..        50 ,     .  1   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   </a>      ,       — .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja462493/index.html">マルチモデルDBMS-現代の情報システムの基礎？</a></li>
<li><a href="../ja462495/index.html">8月5〜11日のモスクワでのデジタルイベント</a></li>
<li><a href="../ja462501/index.html">独自の証明機関が必要な理由</a></li>
<li><a href="../ja462503/index.html">モニタリングとSREの「ゴールデンシグナル」とは何ですか？</a></li>
<li><a href="../ja462505/index.html">関数型プログラミングに騙されないでください</a></li>
<li><a href="../ja462509/index.html">Product Fest-行きたいIT製品管理会議</a></li>
<li><a href="../ja462511/index.html">Google Play Instant。生涯のリファクタリング</a></li>
<li><a href="../ja462513/index.html">移転：領域の準備、選択、開発</a></li>
<li><a href="../ja462515/index.html">システムキーボードを操作するときのバグ</a></li>
<li><a href="../ja462519/index.html">本「マイクロサービス。開発とリファクタリングのパターン»</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>