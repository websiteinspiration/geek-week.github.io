<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥃 🚍 😜 macOSのプロセスとカーネル拡張を保護する方法 🌯 🤹🏿 🥥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！今日は、macOSで侵入者からプロセスを保護する方法についてお話します。たとえば、特にmacOSでプロセスを「強制終了」する方法がいくつかあるという事実を踏まえると、これはアンチウイルスシステムまたはバックアップシステムに役立ちます。それと猫の下での保護方法について読んでください...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>macOSのプロセスとカーネル拡張を保護する方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/497714/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font><font style="vertical-align: inherit;">今日は、macOSで侵入者からプロセスを保護する方法についてお話します。</font><font style="vertical-align: inherit;">たとえば、特にmacOSでプロセスを「強制終了」する方法がいくつかあるという事実を踏まえると、これはアンチウイルスシステムまたはバックアップシステムに役立ちます。</font><font style="vertical-align: inherit;">それと猫の下での保護方法について読んでください。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/403/e5f/065/403e5f065b7426d384f3c71e8cb3c8a5.jpg" alt="画像"></a><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスを強制終了する古典的な方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセスを「強制終了」するよく知られた方法は、SIGKILLプロセスに関するシグナルを送信することです。</font><font style="vertical-align: inherit;">bashを使用すると、標準の「kill -SIGKILL PID」または「pkill -9 NAME」を呼び出して殺すことができます。</font><font style="vertical-align: inherit;">killコマンドはUNIXから知られており、macOSだけでなく、他のUNIXライクなシステムでも使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UNIXライクなシステムと同様に、macOSでは、SIGKILLとSIGSTOPの2つを除いて、プロセスへのシグナルをインターセプトできます。</font><font style="vertical-align: inherit;">この記事では、SIGKILLシグナルは主にプロセスの強制終了を引き起こすシグナルと見なされます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MacOSの仕様</font></font><br>
</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
macOSでは、XNUカーネルのkillシステムコールがpsignal関数（SIGKILLなど）を呼び出します。ユーザー空間の他のユーザーアクションがpsignal関数を呼び出すことができるものを見てみましょう。カーネルの内部メカニズムでのpsignal関数の呼び出しを排除します（重要ではないかもしれませんが、別の記事に任せましょう:)-署名の検証、メモリエラー、終了/終了処理、ファイル保護違反など。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概要を関数と対応するシステムコール</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">terminate_with_payload</font></a><font style="vertical-align: inherit;">から始め</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">従来のkill呼び出しに加えて、macOSオペレーティングシステムに固有の代替アプローチがあり、BSDにはありません。</font><font style="vertical-align: inherit;">両方のシステムコールの動作原理も近いです。</font><font style="vertical-align: inherit;">これらは、psignalカーネル関数への直接の呼び出しです。</font><font style="vertical-align: inherit;">また、プロセスを強制終了する前に、「cansignal」チェックが実行されることにも注意してください。プロセスが別のプロセスにシグナルを送信できるかどうか、システムは、たとえばアプリケーションがシステムプロセスを強制終了できないようにします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>
<span class="hljs-title">terminate_with_payload_internal</span><span class="hljs-params">(struct proc *cur_proc, <span class="hljs-keyword">int</span> target_pid, <span class="hljs-keyword">uint32_t</span> reason_namespace,
				<span class="hljs-keyword">uint64_t</span> reason_code, <span class="hljs-keyword">user_addr_t</span> payload, <span class="hljs-keyword">uint32_t</span> payload_size,
				<span class="hljs-keyword">user_addr_t</span> reason_string, <span class="hljs-keyword">uint64_t</span> reason_flags)</span>
</span>{<font></font>
...<font></font>
	target_proc = proc_find(target_pid);<font></font>
...<font></font>
	<span class="hljs-keyword">if</span> (!cansignal(cur_proc, cur_cred, target_proc, SIGKILL)) {<font></font>
		proc_rele(target_proc);<font></font>
		<span class="hljs-keyword">return</span> EPERM;<font></font>
	}<font></font>
...<font></font>
	<span class="hljs-keyword">if</span> (target_pid == cur_proc-&gt;p_pid) {
		<span class="hljs-comment">/*
		 * psignal_thread_with_reason() will pend a SIGKILL on the specified thread or
		 * return if the thread and/or task are already terminating. Either way, the
		 * current thread won't return to userspace.
		 */</span><font></font>
		psignal_thread_with_reason(target_proc, current_thread(), SIGKILL, signal_reason);<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		psignal_with_reason(target_proc, SIGKILL, signal_reason);<font></font>
	}<font></font>
...<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">launchd</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムの起動時にデーモンを作成し、その寿命を制御する標準的な方法が起動されます。</font><font style="vertical-align: inherit;">ソースコードがmacOS 10.10より前の古いバージョンのlaunchctl用であるという事実に注目します。コード例は図として示されています。</font><font style="vertical-align: inherit;">最近のlaunchctlはXPCを介してlaunchd信号を送信し、launchctlのロジックがそれに転送されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションの停止方法を考えてみましょう。</font><font style="vertical-align: inherit;">SIGTERMシグナルを送信する前に、proc_terminateシステムコールを使用してアプリケーションを停止しようとします。</font></font><br>
<br>
<pre><code class="cpp hljs">&lt;launchctl src/core.c&gt;<font></font>
...<font></font>
	error = proc_terminate(j-&gt;p, &amp;sig);<font></font>
	<span class="hljs-keyword">if</span> (error) {<font></font>
		job_log(j, LOG_ERR | LOG_CONSOLE, <span class="hljs-string">"Could not terminate job: %d: %s"</span>, error, strerror(error));<font></font>
		job_log(j, LOG_NOTICE | LOG_CONSOLE, <span class="hljs-string">"Using fallback option to terminate job..."</span>);<font></font>
		error = kill2(j-&gt;p, SIGTERM);<font></font>
		<span class="hljs-keyword">if</span> (error) {<font></font>
			job_log(j, LOG_ERR, <span class="hljs-string">"Could not signal job: %d: %s"</span>, error, strerror(error));<font></font>
		} <font></font>
...<font></font>
&lt;&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部的には、proc_terminateはその名前にもかかわらず、SIGTERMだけでなくSIGKILLを使用してpsignalを送信できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間接キル-リソース制限</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より興味深いケースは、別の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">process_policy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムコールで見ることができます</font><font style="vertical-align: inherit;">。このシステムコールの標準的な用途は、アプリケーションリソースの制限です。たとえば、インデクサーの場合、システムがファイルキャッシュアクションによって大幅に遅くならないように、プロセッサ時間とメモリクォータには制限があります。 proc_apply_resource_actions関数からわかるように、アプリケーションがリソース制限に達した場合、SIGKILLシグナルがプロセスに送信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシステムコールはプロセスを強制終了する可能性がありますが、システムはシステムコールを引き起こしたプロセスの権限を適切にチェックしませんでした。実際、チェックは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存在しました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、代替フラグPROC_POLICY_ACTION_SETを使用してこの条件をバイパスするだけで十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、アプリケーションによってCPU使用量の割り当てを「制限」すると（たとえば、1 nsだけを実行できるようにする）、システム内の任意のプロセスを強制終了できます。</font><font style="vertical-align: inherit;">したがって、マルウェアは、ウイルス対策プロセスを含む、システム上のすべてのプロセスを強制終了できます。</font><font style="vertical-align: inherit;">また、プロセスがpid 1（launchctl）で強制終了されたときに発生する影響も興味深いものです。SIGKILLシグナルを処理しようとするとカーネルパニックが発生します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/91e/fea/a49/91efeaa490ffd57580d2e5f4a59b4988.png" alt="画像"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題を解決するには？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセスが強制終了されるのを防ぐ最も簡単な方法は、システムコールテーブルの関数ポインタを置き換えることです。残念ながら、この方法は多くの理由で自明で</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はありません。まず、メモリ内のsysentの位置に関与するシンボルは、XNUカーネルのプライベートシンボルであるだけでなく、カーネルシンボルでも見つかりません。関数の動的逆アセンブリなどのヒューリスティックな検索方法を使用して、関数内のポインターを検索する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、テーブル内のエントリの構造は、カーネルの構築に使用されたフラグによって異なります。 CONFIG_REQUIRES_U32_MUNGINGフラグが宣言されている場合、構造体のサイズが変更されます-追加フィールド</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">sy_arg_munge32</font></a><font style="vertical-align: inherit;">が追加されます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">カーネルのコンパイルに使用されたフラグの追加チェックを実行する必要があります。オプションとして、関数へのポインターを既知のものと比較します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysent</span> {</span>         <span class="hljs-comment">/* system call table */</span>
        <span class="hljs-keyword">sy_call_t</span>       *sy_call;       <span class="hljs-comment">/* implementing function */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> CONFIG_REQUIRES_U32_MUNGING || (__arm__ &amp;&amp; (__BIGGEST_ALIGNMENT__ &gt; 4))</span>
        <span class="hljs-keyword">sy_munge_t</span>      *sy_arg_munge32; <span class="hljs-comment">/* system call arguments munger for 32-bit process */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        <span class="hljs-keyword">int32_t</span>         sy_return_type; <span class="hljs-comment">/* system call return types */</span>
        <span class="hljs-keyword">int16_t</span>         sy_narg;        <span class="hljs-comment">/* number of args */</span>
        <span class="hljs-keyword">uint16_t</span>        sy_arg_bytes;   <span class="hljs-comment">/* Total size of arguments in bytes for
                                         * 32-bit system calls
                                         */</span><font></font>
};<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さいわい、最新バージョンのmacOSでは、Appleがプロセスを操作するための新しいAPIを提供しています。</font><font style="vertical-align: inherit;">Endpoint Security APIにより、クライアントは他のプロセスへの多くのリクエストを承認できます。</font><font style="vertical-align: inherit;">したがって、前述のAPIを使用して、SIGKILLシグナルを含むプロセスへのシグナルをブロックできます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bsm/libbsm.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;EndpointSecurity/EndpointSecurity.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>{
    <span class="hljs-keyword">es_client_t</span>* cli = <span class="hljs-literal">nullptr</span>;<font></font>
    {<font></font>
        <span class="hljs-keyword">auto</span> res = es_new_client(&amp;cli, ^(<span class="hljs-keyword">es_client_t</span> * client, <span class="hljs-keyword">const</span> <span class="hljs-keyword">es_message_t</span> * message) {
            <span class="hljs-keyword">switch</span> (message-&gt;event_type) {
                <span class="hljs-keyword">case</span> ES_EVENT_TYPE_AUTH_SIGNAL:<font></font>
                {<font></font>
                    <span class="hljs-keyword">auto</span>&amp; msg = message-&gt;event.signal;
                    <span class="hljs-keyword">auto</span> target = msg.target;
                    <span class="hljs-keyword">auto</span>&amp; token = target-&gt;audit_token;
                    <span class="hljs-keyword">auto</span> pid = audit_token_to_pid(token);
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"signal '%d' sent to pid '%d'\n"</span>, msg.sig, pid);<font></font>
                    es_respond_auth_result(client, message, pid == getpid() ? ES_AUTH_RESULT_DENY : ES_AUTH_RESULT_ALLOW, <span class="hljs-literal">false</span>);<font></font>
                }<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        });<font></font>
    }<font></font>
<font></font>
    {<font></font>
        <span class="hljs-keyword">es_event_type_t</span> evs[] = { ES_EVENT_TYPE_AUTH_SIGNAL };<font></font>
        es_subscribe(cli, evs, <span class="hljs-keyword">sizeof</span>(evs) / <span class="hljs-keyword">sizeof</span>(*evs));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, getpid());<font></font>
    sleep(<span class="hljs-number">60</span>); <span class="hljs-comment">// could be replaced with other waiting primitive</span><font></font>
<font></font>
    es_unsubscribe_all(cli);<font></font>
    es_delete_client(cli);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、シグナル保護メソッド（ポリシーproc_check_signal）を提供するMACポリシーをカーネルに登録できますが、APIは公式にはサポートされていません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カーネル拡張保護</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システム内のプロセスを保護することに加えて、カーネル拡張自体（kext）の保護も必要です。 macOSは、開発者がIOKitデバイスドライバーを便利に開発するためのフレームワークを提供します。 IOKitは、デバイスを操作するためのツールを提供することに加えて、C ++クラスのインスタンスを使用するドライバースタッキングメソッドを提供します。ユーザー空間のアプリケーションは、クラスの登録済みインスタンスを「検索」して、カーネルとユーザー空間の接続を確立できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システム内のクラスインスタンスの数を検出するために、ioclasscountユーティリティが存在します。</font></font><br>
<br>
<pre><code class="cpp hljs">my_kext_ioservice = <span class="hljs-number">1</span>
my_kext_iouserclient = <span class="hljs-number">1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドライバスタックに登録するカーネル拡張は、IOServiceから継承されたクラス（この場合はmy_kext_ioserviceなど）を宣言する必要があります。ユーザーアプリケーションを接続すると、IOUserClientから継承したクラスの新しいインスタンスが作成されます（例：my_kext_iouserclient）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムからドライバーをアンロードしようとすると（kextunloadコマンド）、仮想関数「bool terminate（IOOptionBits options）」が呼び出されます。</font><font style="vertical-align: inherit;">アンロードしてkextunloadを無効にしようとしたときに、terminate関数の呼び出しでfalseを返すだけで十分です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Kext::terminate</span><span class="hljs-params">(IOOptionBits options)</span>
</span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!IsUnloadAllowed)<font></font>
  {<font></font>
    <span class="hljs-comment">// Unload is not allowed, returning false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> super::<span class="hljs-built_in">terminate</span>(options);<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IsUnloadAllowedフラグは、ブート時にIOUserClientによって設定できます。</font><font style="vertical-align: inherit;">ロードが制限されている場合、kextunloadコマンドは次の出力を返します。</font></font><br>
<br>
<pre><code class="cpp hljs">admin@admins-Mac drivermanager % sudo kextunload ./test.kext<font></font>
Password:<font></font>
(kernel) Can<span class="hljs-number">'</span>t remove kext my.kext.test; services failed to <span class="hljs-built_in">terminate</span> - <span class="hljs-number">0xe00002c7</span>.<font></font>
Failed to unload my.kext.test - (iokit/common) unsupported function.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様の保護をIOUserClientに対して行う必要があります。</font><font style="vertical-align: inherit;">ユーザースペース関数IOKitLib“ IOCatalogueTerminate（mach_port_t、uint32_t flag、io_name_t description）;”を使用して、クラスインスタンスをアンロードできます。</font><font style="vertical-align: inherit;">アプリケーションのユーザースペースが終了するまで、つまりclientDied関数の呼び出しがなくなるまで、「終了」コマンドの呼び出しでfalseを返すことができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル保護</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルを保護するには、ファイルへのアクセスを制限できるKauth APIを使用するだけで十分です。 Appleは、スコープ内のさまざまなイベントに関する通知を開発者に提供します。KAUTH_VNODE_DELETE、KAUTH_VNODE_WRITE_DATA、およびKAUTH_VNODE_DELETE_CHILDの操作は、私たちにとって重要です。途中でファイルへのアクセスを制限するのが最も簡単です。API「vn_getpath」を使用してファイルへのパスを取得し、パスのプレフィックスを比較します。ファイルを含むフォルダーのパスの名前変更を最適化するために、システムは各ファイルへのアクセスを許可せず、名前が変更されたフォルダー自体へのアクセスのみを許可することに注意してください。親パスを比較して、KAUTH_VNODE_DELETEを制限する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6e2/ab5/2fb/6e2ab52fb8c17ea8adfe8b63bcf8f611.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの欠点は、プレフィックスの数が増えるとパフォーマンスが低下することです。比較がO（プレフィックス*長さ）と等しくないようにするには、プレフィックスがプレフィックスの数であり、長さが文字列の長さである場合、プレフィックスによって構築された確定的有限状態マシン（DFA）を使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のプレフィックスセットのDFAを構築する方法を検討してください。各プレフィックスの先頭でカーソルを初期化します。すべてのカーソルが同じ文字をポイントしている場合、各カーソルを1文字増やし、同じ行の長さが1つ大きいことを覚えておいてください。異なる文字を持つ2つのカーソルがある場合は、カーソルを指す文字によってカーソルをグループに分け、各グループに対してアルゴリズムを繰り返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のケース（カーソルの下のすべての文字は同じ）では、DFA状態が取得されます。これは、同じ行に1つだけ遷移がある状態です。</font><font style="vertical-align: inherit;">2番目のケースでは、関数を再帰的に呼び出して取得した後続の状態で、サイズ256（文字数とグループの最大数）の遷移テーブルを取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を考えてみましょう。</font><font style="vertical-align: inherit;">プレフィックスのセット（「/ foo / bar / tmp /」、「/ var / db / foo /」、「/ foo / bar / aba /」、「foo / bar / aac /」）の場合、次のDFAを取得できます。</font><font style="vertical-align: inherit;">この図は、他の状態につながる遷移のみを示しています。他の遷移は最終的なものではありません。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/190/d0f/5ec/190d0f5ec1fdd8c03df23387d83db44a.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DKA状態を通過するとき、3つのケースがある場合があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最終状態に達しました-パスは保護されています。KAUTH_VNODE_DELETE、KAUTH_VNODE_WRITE_DATA、およびKAUTH_VNODE_DELETE_CHILDの操作を制限します</font></font></li>
<li>    ,   “” (  -) —   ,   KAUTH_VNODE_DELETE. ,   vnode  ,     ‘/’,         “/foor/bar/t”,  .</li>
<li>    ,   .       ,   .</li>
</ol><br>
<h3></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発されたセキュリティソリューションの目的は、ユーザーとそのデータのセキュリティレベルを高めることです。一方で、この目標は、オペレーティングシステム自体が「弱い」脆弱性を対象とするアクロニスソフトウェア製品の開発によって保証されています。一方で、特にそのような脆弱性の閉鎖により製品としての私たち自身の安定性が高まるため、OS側で改善できるセキュリティ面の強化を無視するべきではありません。この脆弱性はApple Product Security Teamによって報告され、macOS 10.14.5（https://support.apple.com/en-gb/HT210119）で修正されました。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e27/604/c24/e27604c248d5405276235cf613319754.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、ユーティリティがカーネルに正式にインストールされている必要があります。</font><font style="vertical-align: inherit;">つまり、外部の不要なソフトウェアにそのような抜け穴はありません。</font><font style="vertical-align: inherit;">ただし、ご覧のように、ウイルス対策システムやバックアップシステムなどの正当なプログラムを保護するためにも、努力する必要があります。</font><font style="vertical-align: inherit;">ただし、現在、macOS用の新しいAcronis製品には、システムからのアンロードに対する追加の保護機能があります。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja497688/index.html">Kubernetesイブニングスクールの仕組み</a></li>
<li><a href="../ja497696/index.html">企業を攻撃するRyukランサムウェアはどのように</a></li>
<li><a href="../ja497700/index.html">4月17日からのバッキングとDevOps、セキュリティ、ロボットに関する毎週のオンラインmitap</a></li>
<li><a href="../ja497702/index.html">2020年に注目すべきデータストレージの5つのトレンド</a></li>
<li><a href="../ja497708/index.html">4月と5月に開催される一連の富士通ウェビナーにご参加ください</a></li>
<li><a href="../ja497724/index.html">PythonでWebアプリを公開するためのサーバーの準備</a></li>
<li><a href="../ja497726/index.html">OdnoklassnikiでのAndroidテストのスケーリング</a></li>
<li><a href="../ja497728/index.html">チップを「燃やす」ことの危険性</a></li>
<li><a href="../ja497730/index.html">便利なBDD：SpecFlow + TFS</a></li>
<li><a href="../ja497736/index.html">10の新しい内燃機関のレビュー</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>