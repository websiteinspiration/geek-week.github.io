<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌥️ 👍🏻 🖐️ Vom Fehler zum Alarm mit Aktionen 🅿️ 🕎 👩🏽‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Für den Benutzer sehen die Fehlermeldungen oft so aus: "Irgendwas stimmt nicht, AAAA!". Natürlich möchte er anstelle von Fehlern den magis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Vom Fehler zum Alarm mit Aktionen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/manychat/blog/495346/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font><font style="vertical-align: inherit;">Für den Benutzer sehen die Fehlermeldungen oft so aus: "Irgendwas stimmt nicht, AAAA!". </font><font style="vertical-align: inherit;">Natürlich möchte er anstelle von Fehlern den magischen Fehler „Repariere alles“ sehen. </font><font style="vertical-align: inherit;">Nun, oder andere Optionen. </font><font style="vertical-align: inherit;">Wir haben begonnen, diese aktiv zu uns selbst hinzuzufügen, und ich möchte darüber sprechen, wie Sie dies tun können. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6q/cf/s3/6qcfs3uiu0o9ajdlcfi8frjb5pg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich zunächst vor - mein Name ist Alexander, die letzten sechs Jahre habe ich der iOS-Entwicklung gewidmet. </font><font style="vertical-align: inherit;">Jetzt bin ich für die ManyChat-Mobilanwendung verantwortlich und werde Probleme anhand seines Beispiels lösen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns sofort formulieren, was wir tun werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion zum Fehlertyp hinzufügen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwandeln Sie Fehler in benutzerfreundliche Warnungen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir zeigen die möglichen weiteren Aktionen in der Oberfläche an und verarbeiten deren Klicks</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und das alles wird auf Swift sein :)</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden das Problem anhand eines Beispiels lösen. </font><font style="vertical-align: inherit;">Der Server hat einen Fehler mit dem Code 500 anstelle der erwarteten 200 zurückgegeben. Was soll der Entwickler tun? </font><font style="vertical-align: inherit;">Zumindest mit der Trauer, den Benutzer zu informieren - der erwartete Beitrag mit Siegeln konnte nicht heruntergeladen werden. </font><font style="vertical-align: inherit;">In Apple ist das Standardmuster alarmiert. Schreiben wir also eine einfache Funktion:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedViewController</span>: <span class="hljs-title">UIViewController</span> </span>{
  <span class="hljs-comment">// -   </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleFeedResponse</span><span class="hljs-params">(...)</span></span> {
	<span class="hljs-comment">/// -    </span>
	<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error = error {
		<span class="hljs-keyword">let</span> alertVC = <span class="hljs-type">UIAlertController</span>(<font></font>
			title: <span class="hljs-string">"Error"</span>,<font></font>
			message: <span class="hljs-string">"Error connecting to the server"</span>,<font></font>
			preferredStyle: .alert)<font></font>
		<span class="hljs-keyword">let</span> action = <span class="hljs-type">UIAlertAction</span>(title: <span class="hljs-string">"OK"</span>, style: .<span class="hljs-keyword">default</span>, handler: <span class="hljs-literal">nil</span>)<font></font>
		alertVC.addAction(action)<font></font>
		<span class="hljs-keyword">self</span>.present(alertVC, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<font></font>
	}<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Der</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einfachheit halber befindet sich der größte Teil des Codes in der Steuerung. </font><font style="vertical-align: inherit;">Es steht Ihnen frei, dieselben Ansätze in Ihrer Architektur zu verwenden. </font><font style="vertical-align: inherit;">Der Artikelcode wird im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verfügbar sein </font><font style="vertical-align: inherit;">. Am Ende des Artikels befindet sich auch dieser Link. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erhalten folgendes Bild: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9o/ra/ee/9oraeel1k7noyxjplcumz1b56jy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Theoretisch haben wir die Aufgabe erledigt. </font><font style="vertical-align: inherit;">Aber einige Dinge sind sofort offensichtlich:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben nicht die Möglichkeit gegeben, irgendwie von einem fehlerhaften zu einem erfolgreichen Szenario zu wechseln. </font><font style="vertical-align: inherit;">OK, im aktuellen Fall wird nur die Warnung ausgeblendet - und dies ist keine Lösung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus Sicht der Benutzererfahrung muss der Text klarer und neutraler gestaltet werden. </font><font style="vertical-align: inherit;">Damit der Benutzer keine Angst hat und nicht läuft, um Ihrer Anwendung einen Stern in den AppStore zu setzen. </font><font style="vertical-align: inherit;">In diesem Fall wäre ein detaillierter Text beim Debuggen hilfreich</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und um ehrlich zu sein - Warnungen sind als Lösung etwas veraltet (in Anwendungen werden zunehmend Dummy-Bildschirme oder Toasts angezeigt). </font><font style="vertical-align: inherit;">Dies ist jedoch bereits eine Frage, die separat mit dem Team besprochen werden sollte</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stimmen Sie zu, die unten dargestellte Option sieht viel sympathischer aus. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/0z/oz/jv0zozzv3foowtocsqkk_pjdifo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unabhängig davon, welche Option Sie auswählen, müssen Sie für jede dieser Optionen einen solchen Mechanismus zum Anzeigen einer Nachricht </font><font style="vertical-align: inherit;">ausdenken, die bei </font><font style="vertical-align: inherit;">Auftreten eines beliebigen Fehlers gut aussieht, dem Benutzer ein klares Skript für die weitere Arbeit in der Anwendung bieten und eine Reihe von Aktionen bereitstellen. </font><font style="vertical-align: inherit;">Die Lösung ist:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muss erweiterbar sein. </font><font style="vertical-align: inherit;">Wir alle kennen die inhärente Variabilität des Designs. </font><font style="vertical-align: inherit;">Unser Mechanismus muss zu allem bereit sein</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird dem Objekt in einigen Codezeilen hinzugefügt (und entfernt)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gut getestet</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber lassen Sie uns vorher in das theoretische Minimum für Fehler in Swift eintauchen. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehler in Swift</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Absatz bietet eine allgemeine Übersicht über Fehler auf oberster Ebene. </font><font style="vertical-align: inherit;">Wenn Sie Ihre Fehler in der Anwendung bereits aktiv verwenden, können Sie sicher mit dem nächsten Absatz fortfahren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist ein Fehler? </font><font style="vertical-align: inherit;">Eine falsche Handlung oder ein falsches Ergebnis. </font><font style="vertical-align: inherit;">Oft können wir mögliche Fehler annehmen und diese im Voraus im Code beschreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall gibt Apple den Typ Fehler an. </font><font style="vertical-align: inherit;">Wenn wir die Apple-Dokumentation öffnen, sieht der Fehler folgendermaßen aus (relevant für Swift 5.1):</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Error</span> </span>{<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nur ein Protokoll ohne zusätzliche Anforderungen. </font><font style="vertical-align: inherit;">In der Dokumentation wird freundlicherweise erläutert, dass aufgrund des Fehlens der erforderlichen Parameter jeder Typ im Swift-Fehlerbehandlungssystem verwendet werden kann. </font><font style="vertical-align: inherit;">Mit einem so sanften Protokoll werden wir einfach arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee, enum zu verwenden, kommt mir sofort in den Sinn: Es gibt eine endliche bekannte Anzahl von Fehlern, sie können eine Art von Parametern haben. </font><font style="vertical-align: inherit;">Welches ist, was Apple tut. </font><font style="vertical-align: inherit;">Sie können beispielsweise einen DecodingError implementieren:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DecodingError</span> : <span class="hljs-title">Error</span> </span>{<font></font>
    <font></font>
        <span class="hljs-comment">/// ,     . </span>
    	<span class="hljs-comment">///  ,    </span>
        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Context</span> </span>{<font></font>
    <font></font>
    	    <span class="hljs-comment">///      </span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> codingPath: [<span class="hljs-type">CodingKey</span>]
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> debugDescription: <span class="hljs-type">String</span><font></font>
    <font></font>
    	    <span class="hljs-comment">/// ,    . </span>
            <span class="hljs-comment">///      .   </span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> underlyingError: <span class="hljs-type">Error?</span><font></font>
    <font></font>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(codingPath: [<span class="hljs-type">CodingKey</span>], debugDescription: <span class="hljs-type">String</span>, underlyingError: <span class="hljs-type">Error?</span> = <span class="hljs-literal">nil</span>)<font></font>
        }<font></font>
    <font></font>
    	<span class="hljs-comment">/// N    </span>
        <span class="hljs-keyword">case</span> typeMismatch(<span class="hljs-type">Any</span>.<span class="hljs-type">Type</span>, <span class="hljs-type">DecodingError</span>.<span class="hljs-type">Context</span>)
        <span class="hljs-keyword">case</span> valueNotFound(<span class="hljs-type">Any</span>.<span class="hljs-type">Type</span>, <span class="hljs-type">DecodingError</span>.<span class="hljs-type">Context</span>)<font></font>
    <font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nutzen Sie die Best Practices von Apple. </font><font style="vertical-align: inherit;">Stellen Sie sich eine Gruppe möglicher Netzwerkfehler in vereinfachter Form vor:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetworkError</span>: <span class="hljs-title">Error</span> </span>{
       <span class="hljs-comment">//  500 </span>
	<span class="hljs-keyword">case</span> serverError
        <span class="hljs-comment">//   ,   </span>
	<span class="hljs-keyword">case</span> responseError
        <span class="hljs-comment">//  ,   ,  </span>
	<span class="hljs-keyword">case</span> internetError<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können wir überall in unserer Anwendung, wo der Fehler auftritt, unseren Network.Error verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie arbeite ich mit Fehlern? Es gibt einen Fangmechanismus. Wenn eine Funktion einen Fehler auslösen kann, wird sie mit dem Schlüsselwort throw markiert. Jetzt muss jeder seiner Benutzer über das Konstrukt do catch darauf zugreifen. Wenn es keinen Fehler gibt, fallen wir mit einem Fehler in den do-Block in den catch-Block. Die Funktionen, die zum Fehler führen, können eine beliebige Zahl im do-Block sein. Der einzige Nachteil ist, dass wir im Fang einen Fehler vom Typ Fehler erhalten. Sie müssen den Fehler in den gewünschten Typ umwandeln.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alternativ können wir die Option verwenden, dh im Fehlerfall Null erhalten und das sperrige Design entfernen. Manchmal ist es bequemer: Nehmen wir an, wir erhalten eine optionale Variable und wenden dann eine Wurffunktion darauf an. Der Code kann in einen if / guard-Block eingefügt werden und bleibt präzise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Beispiel für die Arbeit mit der Wurffunktion:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">blah</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">String</span> <span class="hljs-keyword">throws</span> {
    	<span class="hljs-keyword">throw</span> <span class="hljs-type">NetworkError</span>.serverError<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">do</span> {
    	<span class="hljs-keyword">let</span> string = <span class="hljs-keyword">try</span> blah()
    	<span class="hljs-comment">//     ,      </span>
    	<span class="hljs-keyword">let</span> anotherString = <span class="hljs-keyword">try</span> blah()<font></font>
    } <span class="hljs-keyword">catch</span> {
    	<span class="hljs-comment">//  NetworkError.serverError</span>
    	<span class="hljs-built_in">print</span>(error)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">//  string = nil</span>
    <span class="hljs-keyword">let</span> string = <span class="hljs-keyword">try</span>? blah()</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwechseln Sie nicht mit do catch in anderen Sprachen. Swift löst keine Ausnahme aus, schreibt jedoch den Wert des Fehlers (falls er aufgetreten ist) in ein spezielles Register. Wenn es einen Wert gibt, geht er zum Fehlerblock. Wenn nicht, wird der do-Block fortgesetzt. Quellen für die Neugierigsten: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.mikeash.com/pyblog/friday-qa-2017-08-25-swift-error-handling-implementation.html</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Diese Methode eignet sich für die Behandlung synchroner Ereignisse und ist für lange Vorgänge nicht so praktisch (z. B. Daten über das Netzwerk anfordern), was möglicherweise zeitaufwändig sein kann. Dann können Sie die einfache Vervollständigung verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Alternative zu Swift 5 wurde Result eingeführt - eine vorbereitete Aufzählung, die zwei Optionen enthält - Erfolg und Misserfolg. </font><font style="vertical-align: inherit;">An sich ist die Verwendung von Error nicht erforderlich. </font><font style="vertical-align: inherit;">Und es hat keine direkte Beziehung zur Asynchronität. </font><font style="vertical-align: inherit;">Für asynchrone Ereignisse ist es jedoch bequemer, genau diesen Typ auf den Abschluss zurückzusetzen (andernfalls müssen Sie zwei Abschlüsse ausführen, Erfolg und Misserfolg, oder zwei Parameter zurückgeben). </font><font style="vertical-align: inherit;">Schreiben wir ein Beispiel:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">blah</span>&lt;ResultType&gt;<span class="hljs-params">(handler: @escaping <span class="hljs-params">(Swift.Result&lt;ResultType, Error&gt;)</span></span></span> -&gt; <span class="hljs-type">Void</span>) {<font></font>
	handler(.failure(<span class="hljs-type">NetworkError</span>.serverError)<font></font>
}<font></font>
<font></font>
blah&lt;<span class="hljs-type">String</span>&gt;(handler { result <span class="hljs-keyword">in</span> 
	<span class="hljs-keyword">switch</span> result {
		<span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> value):
			<span class="hljs-built_in">print</span>(value)
		<span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
			<span class="hljs-built_in">print</span>(error)<font></font>
	}<font></font>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Informationen reichen für uns aus, um zu arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Noch einmal kurz:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehler in Swift ist ein Protokoll</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist zweckmäßig, Fehler in Form einer Aufzählung darzustellen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt zwei Möglichkeiten, mit Fehlern umzugehen: synchron (fangen) und asynchron (Ihre eigene Konkurrenz oder Ihr eigenes Ergebnis).</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehlertext</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kommen wir zurück zum Thema des Artikels. </font><font style="vertical-align: inherit;">Im obigen Absatz haben wir unsere eigene Art von Fehlern erstellt. </font><font style="vertical-align: inherit;">Da ist er:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetworkError</span>: <span class="hljs-title">Error</span> </span>{
        <span class="hljs-comment">//  500 </span>
	<span class="hljs-keyword">case</span> serverError
        <span class="hljs-comment">//   ,   </span>
	<span class="hljs-keyword">case</span> responseError
        <span class="hljs-comment">//  ,   ,  </span>
	<span class="hljs-keyword">case</span> internetError<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen wir jeden Fehler mit einem Text abgleichen, der für den Benutzer verständlich ist. </font><font style="vertical-align: inherit;">Wir werden es im Fehlerfall in der Benutzeroberfläche anzeigen. </font><font style="vertical-align: inherit;">LocalizedError Protocol beeilt sich, uns zu helfen. </font><font style="vertical-align: inherit;">Es erbt den Protokollfehler und ergänzt ihn mit 4 Eigenschaften:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">LocalizedError</span> : <span class="hljs-title">Error</span> </span>{
    <span class="hljs-keyword">var</span> errorDescription: <span class="hljs-type">String?</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> failureReason: <span class="hljs-type">String?</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> recoverySuggestion: <span class="hljs-type">String?</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> helpAnchor: <span class="hljs-type">String?</span> { <span class="hljs-keyword">get</span> }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir implementieren das Protokoll:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">NetworkError</span>: <span class="hljs-title">LocalizedError</span> </span>{
    	<span class="hljs-keyword">var</span> errorDescription: <span class="hljs-type">String?</span> {
            <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {
            <span class="hljs-keyword">case</span> .serverError, .responseError:
                <span class="hljs-keyword">return</span> <span class="hljs-string">"Error"</span>
    	    <span class="hljs-keyword">case</span> .internetError:
                <span class="hljs-keyword">return</span> <span class="hljs-string">"No Internet Connection"</span><font></font>
            }<font></font>
        }<font></font>
    <font></font>
        <span class="hljs-keyword">var</span> failureReason: <span class="hljs-type">String?</span> {
            <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {
            <span class="hljs-keyword">case</span> .serverError, .responseError:
                <span class="hljs-keyword">return</span> <span class="hljs-string">"Something went wrong"</span>
    	    <span class="hljs-keyword">case</span> .internetError:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
            }<font></font>
        }<font></font>
    <font></font>
        <span class="hljs-keyword">var</span> recoverySuggestion: <span class="hljs-type">String?</span> {
            <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {
            <span class="hljs-keyword">case</span> .serverError, .responseError:
                <span class="hljs-keyword">return</span> <span class="hljs-string">"Please, try again"</span>
    	    <span class="hljs-keyword">case</span> .internetError:
                <span class="hljs-keyword">return</span> <span class="hljs-string">"Please check your internet connection and try again"</span><font></font>
            }<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Fehleranzeige wird sich kaum ändern:</font></font><br>
<br>
<pre><code class="swift hljs">	<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error = error {
		<span class="hljs-keyword">let</span> errorMessage = [error.failureReason, error.recoverySuggestion].<span class="hljs-built_in">compactMap</span>({ $<span class="hljs-number">0</span> }).joined(separator: <span class="hljs-string">". "</span>)
		<span class="hljs-keyword">let</span> alertVC = <span class="hljs-type">UIAlertController</span>(<font></font>
			title: error.errorDescription,<font></font>
			message: errorMessage,<font></font>
			preferredStyle: .alert)<font></font>
		<span class="hljs-keyword">let</span> action = <span class="hljs-type">UIAlertAction</span>(title: <span class="hljs-string">"OK"</span>, style: .<span class="hljs-keyword">default</span>) { (<span class="hljs-number">_</span>) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span> }<font></font>
		alertVC.addAction(action)<font></font>
		<span class="hljs-keyword">self</span>.present(alertVC, animated: <span class="hljs-literal">true</span>, competion: <span class="hljs-literal">nil</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Großartig, mit dem Text war alles einfach. </font><font style="vertical-align: inherit;">Fahren wir mit den Schaltflächen fort.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehlerbehebung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns den Fehlerbehandlungsalgorithmus in einem einfachen Diagramm darstellen. </font><font style="vertical-align: inherit;">In einer Situation, in der aufgrund eines Fehlers ein Dialogfeld mit den Optionen "Erneut versuchen", "Abbrechen" und möglicherweise einigen bestimmten Optionen angezeigt wird, erhalten wir das folgende Schema: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/a9/te/n3/a9ten3zbrffm7sz8kkupfo8xsuy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden das Problem am Ende lösen. </font><font style="vertical-align: inherit;">Wir brauchen eine Funktion, die einen Alarm mit n + 1 Optionen anzeigt. </font><font style="vertical-align: inherit;">Wir werfen, da wir einen Fehler zeigen möchten:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RecovableAction</span> </span>{
    	<span class="hljs-keyword">let</span> title: <span class="hljs-type">String</span>
    	<span class="hljs-keyword">let</span> action: () -&gt; <span class="hljs-type">Void</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showRecovableOptions</span><span class="hljs-params">(actions: [RecovableAction], from viewController: UIViewController)</span></span> {
    	<span class="hljs-keyword">let</span> alertActions = actions.<span class="hljs-built_in">map</span> { <span class="hljs-type">UIAlertAction</span>(name: $<span class="hljs-number">0</span>.title, action: $<span class="hljs-number">0</span>.action) }
    	<span class="hljs-keyword">let</span> cancelAction = <span class="hljs-type">UIAlertAction</span>(name: <span class="hljs-string">"Cancel"</span>, action: <span class="hljs-literal">nil</span>)
    	<span class="hljs-keyword">let</span> alertController = <span class="hljs-type">UIAlertController</span>(actions: alertActions)<font></font>
    	viewController.present(alertController, complition: <span class="hljs-literal">nil</span>)<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Funktion, die die Art des Fehlers bestimmt und ein Signal sendet, um eine Warnung anzuzeigen:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleError</span><span class="hljs-params">(error: Error)</span></span> {
	<span class="hljs-keyword">if</span> error <span class="hljs-keyword">is</span> <span class="hljs-type">RecovableError</span> {<font></font>
		showRecovableOptions(actions: error.actions, from: viewController)<font></font>
		<span class="hljs-keyword">return</span><font></font>
	}<font></font>
	showErrorAlert(...)<font></font>
} </code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und eine erweiterte Art von Fehler, die einen Kontext und ein Verständnis dafür hat, was mit dieser oder jener Option zu tun ist.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RecovableError</span>: <span class="hljs-title">Error</span> </span>{
	<span class="hljs-keyword">let</span> recovableACtions: [<span class="hljs-type">RecovableAction</span>]
	<span class="hljs-keyword">let</span> context: <span class="hljs-type">Context</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Kopf zeichnet sofort ein Diagramm Ihres Fahrrads. </font><font style="vertical-align: inherit;">Aber zuerst überprüfen wir die Apple-Docks. </font><font style="vertical-align: inherit;">Vielleicht liegt ein Teil des Mechanismus bereits in unseren Händen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Native Implementierung?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein bisschen Internet-Suche führt zum Protokoll </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecoverableError</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">// A specialized error that may be recoverable by presenting several potential recovery options to the user.</span>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">RecoverableError</span> : <span class="hljs-title">Error</span> </span>{
    <span class="hljs-keyword">var</span> recoveryOptions: [<span class="hljs-type">String</span>] { <span class="hljs-keyword">get</span> }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">attemptRecovery</span><span class="hljs-params">(optionIndex recoveryOptionIndex: Int, resultHandler handler: @escaping <span class="hljs-params">(Bool)</span></span></span> -&gt; <span class="hljs-type">Void</span>)
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">attemptRecovery</span><span class="hljs-params">(optionIndex recoveryOptionIndex: Int)</span></span> -&gt; <span class="hljs-type">Bool</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht so aus, als ob wir suchen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recoveryOptions: [String] - eine Eigenschaft, in der Wiederherstellungsoptionen gespeichert werden</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">func tryRecovery (optionIndex: Int) -&gt; Bool - stellt einen Fehler synchron wieder her. </font><font style="vertical-align: inherit;">Richtig - auf Erfolg</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">func tryRecovery (optionIndex: Int, resultHandler: (Bool) -&gt; Void) - Asynchrone Option, die Idee ist dieselbe</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Bedienungsanleitungen ist alles bescheidener. </font><font style="vertical-align: inherit;">Eine kleine Suche auf der Apple-Website und in der Umgebung führt zu einem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel über die Fehlerbehandlung,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der vor den öffentlichen Ankündigungen von Swift verfasst wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Mechanismus ist für MacOs-Anwendungen gedacht und zeigt ein Dialogfeld</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wurde ursprünglich um NSError herum gebaut.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das RecoveryAttempter-Objekt ist in den Fehler in userInfo eingekapselt, der die Fehlerbedingungen kennt und die beste Lösung für das Problem auswählen kann. </font><font style="vertical-align: inherit;">Objekt darf nicht Null sein</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecoveryAttempter muss das informelle Protokoll NSErrorRecoveryAttempting unterstützen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auch in userInfo sollte Wiederherstellungsoption sein</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und alles hängt mit dem Aufruf der presentError-Methode zusammen, die nur im macOS SDK enthalten ist. </font><font style="vertical-align: inherit;">Er zeigt eine Warnung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Warnung über presentError angezeigt wird, wird bei Auswahl einer Option im Popup-Fenster in AppDelegate eine interessante Funktion angezeigt:</font></font></li>
</ul><br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">attemptRecovery</span><span class="hljs-params">(fromError error: Error, optionIndex recoveryOptionIndex: Int, delegate: <span class="hljs-keyword">Any</span>?, didRecoverSelector: Selector?, contextInfo: UnsafeMutableRawPointer?)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber da wir keinen PresentError haben, können wir ihn nicht ziehen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vp/xo/cj/vpxocjapqc5ywmiq8hhq3djow6o.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An diesem Punkt scheint es, als hätten wir eher eine Leiche als einen Schatz ausgegraben. </font><font style="vertical-align: inherit;">Wir müssen Error in NSError umwandeln und unsere eigene Funktion schreiben, um die Warnung von der Anwendung anzuzeigen. </font><font style="vertical-align: inherit;">Eine Reihe impliziter Verbindungen. </font><font style="vertical-align: inherit;">Es ist möglich, schwierig und nicht ganz klar - "Warum?". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während die nächste Tasse Tee brüht, könnte man sich fragen, warum die obige Funktion delegate als Any verwendet und den Selektor übergibt. </font><font style="vertical-align: inherit;">Die Antwort ist unten:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antworten</font></font></b><div class="spoiler_text">      iOS 2.          !         ( ,   ).  :)<br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Fahrrad bauen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns das Protokoll implementieren, es wird uns nicht schaden:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RecoverableError</span>: <span class="hljs-title">Foundation</span>.<span class="hljs-title">RecoverableError</span> </span>{
	<span class="hljs-keyword">let</span> error: <span class="hljs-type">Error</span>
	<span class="hljs-keyword">var</span> recoveryOptions: [<span class="hljs-type">String</span>] {
		<span class="hljs-keyword">return</span> [<span class="hljs-string">"Try again"</span>]s<font></font>
	}<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">attemptRecovery</span><span class="hljs-params">(optionIndex recoveryOptionIndex: Int)</span></span> -&gt; <span class="hljs-type">Bool</span> {
		<span class="hljs-comment">//  ,    </span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
	}<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">attemptRecovery</span><span class="hljs-params">(optionIndex: Int, resultHandler: <span class="hljs-params">(Bool)</span></span></span> -&gt; <span class="hljs-type">Void</span>) {
		<span class="hljs-comment">//      . </span>
               <span class="hljs-comment">//      </span>
		<span class="hljs-keyword">switch</span> optionIndex {
			<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
				resultHandler(<span class="hljs-literal">true</span>)
			<span class="hljs-keyword">default</span>: <font></font>
				resultHandler(<span class="hljs-literal">false</span>)<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Indexabhängigkeit ist nicht die bequemste Lösung (wir können leicht über das Array hinausgehen und die Anwendung zum Absturz bringen). </font><font style="vertical-align: inherit;">Aber für MVP reicht das. </font><font style="vertical-align: inherit;">Nehmen Sie die Idee von Apple, modernisieren Sie sie einfach. </font><font style="vertical-align: inherit;">Wir benötigen ein separates Attempter-Objekt und Schaltflächenoptionen, die wir ihm geben werden:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RecoveryAttemper</span> </span>{
    	<span class="hljs-comment">//   </span>
    	<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> _recoveryOptions: [<span class="hljs-type">RecoveryOptions</span>]<font></font>
    <font></font>
    	<span class="hljs-keyword">var</span> recoveryOptionsText: [<span class="hljs-type">String</span>] {
    		<span class="hljs-keyword">return</span> _recoveryOptions.<span class="hljs-built_in">map</span>({ $<span class="hljs-number">0</span>.title })<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-keyword">init</span>(options: [<span class="hljs-type">RecoveryOptions</span>] {<font></font>
    		_recoveryOptions = recoveryOptions<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-comment">//    </span>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">attemptRecovery</span><span class="hljs-params">(fromError error: Error, optionIndex: Int)</span></span> -&gt; <span class="hljs-type">Bool</span> {
    		<span class="hljs-keyword">let</span> option = _recoveryOptions[optionIndex]
    				<span class="hljs-keyword">switch</span> option {
    				<span class="hljs-keyword">case</span> .tryAgain(<span class="hljs-keyword">let</span> action)<font></font>
    					action()<font></font>
    					<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    				<span class="hljs-keyword">case</span> .cancel:
    					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
    				}<font></font>
    		}<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">//  enum,       </span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RecoveryOptions</span> </span>{
    	<span class="hljs-comment">//      (,     )</span>
    	<span class="hljs-keyword">case</span> tryAgain(action: (() -&gt; <span class="hljs-type">Void</span>))
    	<span class="hljs-keyword">case</span> cancel<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen Sie den Fehler anzeigen. </font><font style="vertical-align: inherit;">Ich mag Protokolle sehr, deshalb werde ich das Problem durch sie lösen. </font><font style="vertical-align: inherit;">Erstellen wir ein universelles Protokoll zum Erstellen eines UIAlertControllers aus Fehlern:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ErrorAlertCreatable</span>: <span class="hljs-title">class</span>, <span class="hljs-title">ErrorReasonExtractable</span> </span>{
    	<span class="hljs-comment">//     </span>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createAlert</span><span class="hljs-params">(<span class="hljs-keyword">for</span> error: Error)</span></span> -&gt; <span class="hljs-type">UIAlertController</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - Default implementation</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ErrorAlertCreatable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">UIViewController</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createAlert</span><span class="hljs-params">(<span class="hljs-keyword">for</span> error: Error)</span></span> -&gt; <span class="hljs-type">UIAlertController</span> {
    		<span class="hljs-comment">//      </span>
    		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> recoverableError = error <span class="hljs-keyword">as</span>? <span class="hljs-type">RecoverableError</span> {
    			<span class="hljs-keyword">return</span> createRecoverableAlert(<span class="hljs-keyword">for</span>: recoverableError)<font></font>
    		}<font></font>
    		<span class="hljs-keyword">let</span> defaultTitle = <span class="hljs-string">"Error"</span>
    		<span class="hljs-keyword">let</span> description = errorReason(from: error)<font></font>
    <font></font>
    		<span class="hljs-comment">//          </span>
    		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> localizedError = error <span class="hljs-keyword">as</span>? <span class="hljs-type">LocalizedError</span> {
    			<span class="hljs-keyword">return</span> createAlert(<font></font>
    				title: localizedError.errorDescription ?? defaultTitle,<font></font>
    				message: description,<font></font>
    				actions: [.okAction],<font></font>
    				aboveAll: aboveAll)<font></font>
    		}<font></font>
    <font></font>
    		<span class="hljs-keyword">return</span> createAlert(title: defaultTitle, message: description, actions: [.okAction])<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-keyword">fileprivate</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createAlert</span><span class="hljs-params">(title: String?, message: String?, actions: [UIAlertAction])</span></span> -&gt; <span class="hljs-type">UIAlertController</span> {
    		<span class="hljs-keyword">let</span> alertViewController = <span class="hljs-type">UIAlertController</span>(title: title, message: message, preferredStyle: .alert)<font></font>
    		actions.forEach({ alertViewController.addAction($<span class="hljs-number">0</span>) })
    		<span class="hljs-keyword">return</span> alertViewController<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-keyword">fileprivate</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createRecoverableAlert</span><span class="hljs-params">(<span class="hljs-keyword">for</span> recoverableError: RecoverableError)</span></span> -&gt; <span class="hljs-type">UIAlertController</span> {
    		<span class="hljs-keyword">let</span> title = recoverableError.errorDescription
    		<span class="hljs-keyword">let</span> message = recoverableError.recoverySuggestion
    		<span class="hljs-comment">//     . </span>
    		<span class="hljs-keyword">let</span> actions = recoverableError.recoveryOptions.enumerated().<span class="hljs-built_in">map</span> { (element) -&gt; <span class="hljs-type">UIAlertAction</span> <span class="hljs-keyword">in</span>
    		<span class="hljs-keyword">let</span> style: <span class="hljs-type">UIAlertAction</span>.<span class="hljs-type">Style</span> = element.offset == <span class="hljs-number">0</span> ? .cancel : .<span class="hljs-keyword">default</span>
    		<span class="hljs-keyword">return</span> <span class="hljs-type">UIAlertAction</span>(title: element.element, style: style) { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span><font></font>
    			recoverableError.attemptRecovery(optionIndex: element.offset)<font></font>
    		      }<font></font>
    		}<font></font>
    		<span class="hljs-keyword">return</span> createAlert(title: title, message: message, actions: actions)<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createOKAlert</span><span class="hljs-params">(with text: String)</span></span> -&gt; <span class="hljs-type">UIAlertController</span> {
    		<span class="hljs-keyword">return</span> createAlert(title: text, message: <span class="hljs-literal">nil</span>, actions: [.okAction])<font></font>
    	}<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ERror</span>
    
    //     <span class="hljs-title">ok</span>
    <span class="hljs-title">extension</span> <span class="hljs-title">UIAlertAction</span> </span>{
    	<span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> okAction = <span class="hljs-type">UIAlertAction</span>(title: <span class="hljs-string">"OK"</span>, style: .cancel) { (<span class="hljs-number">_</span>) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span> }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">//    </span>
    <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ErrorReasonExtractable</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errorReason</span><span class="hljs-params">(from error: Error)</span></span> -&gt; <span class="hljs-type">String?</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - Default implementation</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ErrorReasonExtractable</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errorReason</span><span class="hljs-params">(from error: Error)</span></span> -&gt; <span class="hljs-type">String?</span> {
    		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> localizedError = error <span class="hljs-keyword">as</span>? <span class="hljs-type">LocalizedError</span> {
    			<span class="hljs-keyword">return</span> localizedError.recoverySuggestion<font></font>
    		}<font></font>
    		<span class="hljs-keyword">return</span> <span class="hljs-string">"Something bad happened. Please try again"</span><font></font>
    	}<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und das Protokoll zum Anzeigen der erstellten Warnungen:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ErrorAlertPresentable</span>: <span class="hljs-title">class</span> </span>{
	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentAlert</span><span class="hljs-params">(from error: Error)</span></span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// MARK: - Default implementation</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ErrorAlertPresentable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">ErrorAlertCreatable</span> &amp; <span class="hljs-title">UIViewController</span> </span>{
	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentAlert</span><span class="hljs-params">(from error: Error)</span></span> {
		<span class="hljs-keyword">let</span> alertVC = createAlert(<span class="hljs-keyword">for</span>: error)<font></font>
		present(alertVC, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellte sich als umständlich, aber überschaubar heraus. </font><font style="vertical-align: inherit;">Wir können neue Möglichkeiten zum Anzeigen eines Fehlers erstellen (z. B. Toasten oder Anzeigen einer benutzerdefinierten Ansicht) und die Standardimplementierung registrieren, ohne die aufgerufene Methode zu ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, unsere Ansicht wäre durch ein Protokoll abgedeckt:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewControllerInput</span>: <span class="hljs-title">class</span> </span>{
     <span class="hljs-comment">//  </span><font></font>
    }<font></font>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewControllerInput</span>: <span class="hljs-title">ErrorAlertPresentable</span> </span>{ }<font></font>
    <font></font>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">ErrorAlertCreatable</span> </span>{ }
    <span class="hljs-comment">//  ,         ,    </span>
    <span class="hljs-comment">//    </span><font></font>
    <font></font>
    <span class="hljs-comment">//       "",    ErrorAlertPresentable      . </span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">ErrorToastCreatable</span> </span>{ }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Beispiel ist jedoch viel einfacher, daher unterstützen wir beide Protokolle und führen die Anwendung aus:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">requestFeed</span><span class="hljs-params">(...)</span></span> {<font></font>
    		service.requestObject { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] (result) <span class="hljs-keyword">in</span>
    			<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> `<span class="hljs-keyword">self</span>` = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
    			<span class="hljs-keyword">switch</span> result {
    			<span class="hljs-keyword">case</span> .success:
    				<span class="hljs-keyword">break</span>
    			<span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
    				<span class="hljs-comment">//           </span>
    				<span class="hljs-comment">// -     (   viewController)  ,</span>
    				<span class="hljs-comment">//    .     tryAgainOption </span>
    				<span class="hljs-keyword">let</span> tryAgainOption = <span class="hljs-type">RecoveryOptions</span>.tryAgain {
    					<span class="hljs-keyword">self</span>.requestFeed(...)<font></font>
    				}<font></font>
    				<span class="hljs-keyword">let</span> recoveryOptions = [tryAgainOption]
    				<span class="hljs-keyword">let</span> attempter = <span class="hljs-type">RecoveryAttemper</span>(recoveryOptions: recoveryOptions)
    				<span class="hljs-keyword">let</span> recovableError = <span class="hljs-type">RecoverableError</span>(error: error, attempter: attempter)
    				<span class="hljs-keyword">self</span>.presentAlert(from: recovableError)<font></font>
    			}<font></font>
    		}<font></font>
    	}<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - ErrorAlertCreatable</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">ErrorAlertCreatable</span> </span>{ }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - ErrorAlertPresentable</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">ErrorAlertPresentable</span> </span>{ }</code></pre><br>
<img src="https://habrastorage.org/webt/3h/fl/vh/3hflvhmxpfkuzgskzcpe9hodl2k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass alles geklappt hat. </font><font style="vertical-align: inherit;">Eine der Anfangsbedingungen war in 2-3 Zeilen. </font><font style="vertical-align: inherit;">Wir werden unseren Versucher mit einem praktischen Konstruktor erweitern:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RecoveryAttemper</span> </span>{
    	<span class="hljs-comment">//</span><font></font>
    	...<font></font>
    	<span class="hljs-comment">//</span>
    	<span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tryAgainAttempter</span><span class="hljs-params">(block: @escaping <span class="hljs-params">(<span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type">Void</span>)) -&gt; <span class="hljs-type">Self</span> {
    		<span class="hljs-keyword">return</span> <span class="hljs-type">RecoveryAttemper</span>(recoveryOptions: [.cancel, .tryAgain(action: block)])<font></font>
    	}<font></font>
    }<font></font>
    <font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">requestFeed</span><span class="hljs-params">()</span></span> {<font></font>
    		service.requestObject { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] (result) <span class="hljs-keyword">in</span>
    			<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> `<span class="hljs-keyword">self</span>` = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
    			<span class="hljs-keyword">switch</span> result {
    			<span class="hljs-keyword">case</span> .success:
    				<span class="hljs-keyword">break</span>
    			<span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
    				<span class="hljs-comment">//    </span>
    				<span class="hljs-keyword">let</span> recovableError = <span class="hljs-type">RecoverableError</span>(error: error, attempter: .tryAgainAttempter(block: {
    					<span class="hljs-keyword">self</span>.requestFeed()<font></font>
    				}))<font></font>
    				<span class="hljs-keyword">self</span>.presentAlert(from: recovableError)<font></font>
    			}<font></font>
    		}<font></font>
    	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben die MVP-Lösung erhalten, und es wird für uns nicht schwierig sein, eine Verbindung herzustellen und sie irgendwo in unserer Anwendung aufzurufen. </font><font style="vertical-align: inherit;">Beginnen wir mit der Überprüfung der Kantenfälle und der Skalierbarkeit.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist, wenn wir mehrere Exit-Szenarien haben?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, ein Benutzer hat ein Repository in unserer Anwendung. </font><font style="vertical-align: inherit;">Das Gewölbe hat ein Platzlimit. </font><font style="vertical-align: inherit;">In diesem Fall hat der Benutzer zwei Szenarien zum Beenden des Fehlers: Der Benutzer kann entweder Speicherplatz freigeben oder mehr kaufen. </font><font style="vertical-align: inherit;">Wir werden den folgenden Code schreiben:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//  </span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runOutOfSpace</span><span class="hljs-params">()</span></span> {<font></font>
    		service.runOfSpace { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] (result) <span class="hljs-keyword">in</span>
    			<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> `<span class="hljs-keyword">self</span>` = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
    			<span class="hljs-keyword">switch</span> result {
    			<span class="hljs-keyword">case</span> .success:
    				<span class="hljs-keyword">break</span>
    			<span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
    				<span class="hljs-keyword">let</span> notEnoughSpace = <span class="hljs-type">RecoveryOptions</span>.freeSpace {
    					<span class="hljs-keyword">self</span>.freeSpace()<font></font>
    				}<font></font>
    <font></font>
    				<span class="hljs-keyword">let</span> buyMoreSpace = <span class="hljs-type">RecoveryOptions</span>.buyMoreSpace {
    					<span class="hljs-keyword">self</span>.buyMoreSpace()<font></font>
    				}<font></font>
    				<span class="hljs-keyword">let</span> options = [notEnoughSpace, buyMoreSpace]
    				<span class="hljs-keyword">let</span> recovableError = <span class="hljs-type">RecoverableError</span>(error: error, attempter: .cancalableAttemter(options: options))
    				<span class="hljs-keyword">self</span>.presentAlert(from: recovableError)<font></font>
    			}<font></font>
    		}<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">freeSpace</span><span class="hljs-params">()</span></span> {
    		<span class="hljs-keyword">let</span> alertViewController = createOKAlert(with: <span class="hljs-string">"Free space selected"</span>)<font></font>
    		present(alertViewController, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buyMoreSpace</span><span class="hljs-params">()</span></span> {
    		<span class="hljs-keyword">let</span> alertViewController = createOKAlert(with: <span class="hljs-string">"Buy more space selected"</span>)<font></font>
    		present(alertViewController, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<font></font>
    	}<font></font>
    <font></font>
    <font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RecoveryAttemper</span> </span>{
    	<span class="hljs-comment">//</span><font></font>
    	...<font></font>
    	<span class="hljs-comment">//</span>
    	<span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cancalableAttemter</span><span class="hljs-params">(options: [RecoveryOptions])</span></span> -&gt; <span class="hljs-type">Self</span> {
    		<span class="hljs-keyword">return</span> <span class="hljs-type">RecoveryAttemper</span>(recoveryOptions: [.cancel] + options)<font></font>
    	}<font></font>
    }<font></font>
</code></pre><br>
<img src="https://habrastorage.org/webt/d5/eg/zq/d5egzquyykwxtjorhevcq2pe1mg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies war leicht zu handhaben. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir keine Warnung, sondern eine Informationsansicht in der Mitte des Bildschirms anzeigen möchten?</font></font></h3><br>
<img src="https://habrastorage.org/webt/fg/xr/pq/fgxrpqsgg_yqmy4txescavcvdvc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein paar neue Protokolle in Analogie werden unser Problem lösen:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ErrorViewCreatable</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createErrorView</span><span class="hljs-params">(<span class="hljs-keyword">for</span> error: Error)</span></span> -&gt; <span class="hljs-type">ErrorView</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - Default implementation</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ErrorViewCreatable</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createErrorView</span><span class="hljs-params">(<span class="hljs-keyword">for</span> error: Error)</span></span> -&gt; <span class="hljs-type">ErrorView</span> {
    		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> recoverableError = error <span class="hljs-keyword">as</span>? <span class="hljs-type">RecoverableError</span> {
    			<span class="hljs-keyword">return</span> createRecoverableAlert(<span class="hljs-keyword">for</span>: recoverableError)<font></font>
    		}<font></font>
    <font></font>
    		<span class="hljs-keyword">let</span> defaultTitle = <span class="hljs-string">"Error"</span>
    		<span class="hljs-keyword">let</span> description = errorReason(from: error)
    		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> localizedError = error <span class="hljs-keyword">as</span>? <span class="hljs-type">LocalizedError</span> {
    			<span class="hljs-keyword">return</span> createErrorView(<font></font>
    				title: localizedError.errorDescription ?? defaultTitle,<font></font>
    				message: description)<font></font>
    		}<font></font>
    		<span class="hljs-keyword">return</span> createErrorView(title: defaultTitle, message: description)<font></font>
    		}<font></font>
    <font></font>
    	<span class="hljs-keyword">fileprivate</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createErrorView</span><span class="hljs-params">(title: String?, message: String?, actions: [ErrorView.Action] = [])</span></span> -&gt; <span class="hljs-type">ErrorView</span> {
    		<span class="hljs-comment">//  ErrorView        . </span>
                <span class="hljs-comment">//     github</span>
    		<span class="hljs-keyword">return</span> <span class="hljs-type">ErrorView</span>(title: title, description: message, actions: actions)<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-keyword">fileprivate</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createRecoverableAlert</span><span class="hljs-params">(<span class="hljs-keyword">for</span> recoverableError: RecoverableError)</span></span> -&gt; <span class="hljs-type">ErrorView</span> {
    		<span class="hljs-keyword">let</span> title = recoverableError.errorDescription
    		<span class="hljs-keyword">let</span> message = errorReason(from: recoverableError)
    		<span class="hljs-keyword">let</span> actions = recoverableError.recoveryOptions.enumerated().<span class="hljs-built_in">map</span> { (element) -&gt; <span class="hljs-type">ErrorView</span>.<span class="hljs-type">Action</span> <span class="hljs-keyword">in</span>
    			<span class="hljs-keyword">return</span> <span class="hljs-type">ErrorView</span>.<span class="hljs-type">Action</span>(title: element.element) {<font></font>
    				recoverableError.attemptRecovery(optionIndex: element.offset)<font></font>
    			}<font></font>
    		}<font></font>
    		<span class="hljs-keyword">return</span> createErrorView(title: title, message: message, actions: actions)<font></font>
    	}<font></font>
    }</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ErrorViewAddable</span>: <span class="hljs-title">class</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentErrorView</span><span class="hljs-params">(from error: Error)</span></span><font></font>
    <font></font>
    	<span class="hljs-keyword">var</span> errorViewSuperview: <span class="hljs-type">UIView</span> { <span class="hljs-keyword">get</span> }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - Default implementation</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ErrorViewAddable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">ErrorViewCreatable</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentErrorView</span><span class="hljs-params">(from error: Error)</span></span> {
    		<span class="hljs-keyword">let</span> errorView = createErrorView(<span class="hljs-keyword">for</span>: error)<font></font>
    		errorViewSuperview.addSubview(errorView)<font></font>
    		errorView.center = errorViewSuperview.center<font></font>
    	}<font></font>
    }<font></font>
    <font></font>
    <font></font>
    <span class="hljs-comment">//    </span><font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - ErrorAlertCreatable</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">ErrorViewCreatable</span> </span>{ }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - ErrorAlertPresentable</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">ErrorViewAddable</span> </span>{
    	<span class="hljs-keyword">var</span> errorViewSuperview: <span class="hljs-type">UIView</span> {
    		<span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span><font></font>
    	}<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können wir Fehler in Form einer Informationsansicht anzeigen. </font><font style="vertical-align: inherit;">Darüber hinaus können wir entscheiden, wie wir sie zeigen möchten. </font><font style="vertical-align: inherit;">Zum Beispiel, wenn Sie zum ersten Mal den Bildschirm und den Fehler aufrufen - Informationsansicht anzeigen. </font><font style="vertical-align: inherit;">Und wenn der Bildschirm erfolgreich geladen wurde, die Aktion auf dem Bildschirm jedoch einen Fehler zurückgab, zeigen Sie eine Warnung an.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es keinen Zugriff auf die Ansicht gibt?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal müssen Sie einen Fehler auslösen, aber es gibt keinen Zugriff auf die Ansicht. </font><font style="vertical-align: inherit;">Oder wir wissen nicht, welche Ansicht gerade aktiv ist, und wir möchten zusätzlich zu allem eine Warnung anzeigen. </font><font style="vertical-align: inherit;">Wie kann man dieses Problem lösen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine der einfachsten Möglichkeiten (meiner Meinung nach), dasselbe zu tun wie Apple mit der Tastatur. </font><font style="vertical-align: inherit;">Erstellen Sie ein neues Fenster über dem aktuellen Bildschirm. </font><font style="vertical-align: inherit;">Machen wir das:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-meta">@UIApplicationMain</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppDelegate</span>: <span class="hljs-title">UIResponder</span>, <span class="hljs-title">UIApplicationDelegate</span> </span>{<font></font>
<font></font>
	<span class="hljs-comment">//   –   . </span>
	<span class="hljs-comment">//              DI</span>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> errorWindow: <span class="hljs-type">UIWindow</span> = {
		<span class="hljs-keyword">let</span> alertWindow = <span class="hljs-type">UIWindow</span>.<span class="hljs-keyword">init</span>(frame: <span class="hljs-type">UIScreen</span>.main.bounds)<font></font>
		alertWindow.backgroundColor = .clear<font></font>
<font></font>
		<span class="hljs-comment">//  rootViewController,    present   viewController</span>
		<span class="hljs-keyword">let</span> viewController = <span class="hljs-type">UIViewController</span>()<font></font>
		viewController.view.backgroundColor = .clear<font></font>
		alertWindow.rootViewController = viewController<font></font>
<font></font>
		<span class="hljs-keyword">return</span> alertWindow<font></font>
	}()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie eine neue Warnung, die über allem angezeigt werden kann:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AboveAllAlertController</span>: <span class="hljs-title">UIAlertController</span> </span>{
	<span class="hljs-keyword">var</span> alertWindow: <span class="hljs-type">UIWindow</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-type">AppDelegate</span>.alertWindow<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">let</span> topWindow = <span class="hljs-type">UIApplication</span>.shared.windows.last
		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> topWindow = topWindow {<font></font>
			alertWindow.windowLevel = topWindow.windowLevel + <span class="hljs-number">1</span><font></font>
		}<font></font>
<font></font>
		alertWindow.makeKeyAndVisible()<font></font>
		alertWindow.rootViewController?.present(<span class="hljs-keyword">self</span>, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewWillDisappear</span><span class="hljs-params">(<span class="hljs-number">_</span> animated: Bool)</span></span> {
		<span class="hljs-keyword">super</span>.viewWillDisappear(animated)<font></font>
<font></font>
		alertWindow.isHidden = <span class="hljs-literal">true</span><font></font>
	}<font></font>
}</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ErrorAlertCreatable</span>: <span class="hljs-title">class</span> </span>{
    	<span class="hljs-comment">//      </span>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createAlert</span><span class="hljs-params">(<span class="hljs-keyword">for</span> error: Error, aboveAll: Bool)</span></span> -&gt; <span class="hljs-type">UIAlertController</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - Default implementation</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ErrorAlertCreatable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">UIViewController</span> </span>{<font></font>
    	...<font></font>
    	<span class="hljs-comment">//     </span>
    	<span class="hljs-keyword">fileprivate</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createAlert</span><span class="hljs-params">(title: String?, message: String?, actions: [UIAlertAction], aboveAll: Bool)</span></span> -&gt; <span class="hljs-type">UIAlertController</span> {
    		<span class="hljs-keyword">let</span> alertViewController = aboveAll ?
    			<span class="hljs-type">AboveAllAlertController</span>(title: title, message: message, preferredStyle: .alert) :
    			<span class="hljs-type">UIAlertController</span>(title: title, message: message, preferredStyle: .alert)<font></font>
    		actions.forEach({ alertViewController.addAction($<span class="hljs-number">0</span>) })
    		<span class="hljs-keyword">return</span> alertViewController<font></font>
    	}<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">//     </span>
    <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ErrorAlertPresentable</span>: <span class="hljs-title">class</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentAlert</span><span class="hljs-params">(from error: Error)</span></span>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentAlertAboveAll</span><span class="hljs-params">(from error: Error)</span></span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - Default implementation</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ErrorAlertPresentable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">ErrorAlertCreatable</span> &amp; <span class="hljs-title">UIViewController</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentAlert</span><span class="hljs-params">(from error: Error)</span></span> {
    		<span class="hljs-keyword">let</span> alertVC = createAlert(<span class="hljs-keyword">for</span>: error, aboveAll: <span class="hljs-literal">false</span>)<font></font>
    		present(alertVC, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentAlertAboveAll</span><span class="hljs-params">(from error: Error)</span></span> {
    		<span class="hljs-keyword">let</span> alertVC = createAlert(<span class="hljs-keyword">for</span>: error, aboveAll: <span class="hljs-literal">true</span>)
    		<span class="hljs-comment">//         </span>
    		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> alertVC = alertVC <span class="hljs-keyword">as</span>? <span class="hljs-type">AboveAllAlertController</span> {<font></font>
    			alertVC.show()<font></font>
    			<span class="hljs-keyword">return</span><font></font>
    		}<font></font>
    		<span class="hljs-comment">//    ,  - </span>
    		<span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">"Should create AboveAllAlertController"</span>)<font></font>
    		present(alertVC, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<font></font>
    	}<font></font>
    }</code></pre><br>
<img src="https://habrastorage.org/webt/qr/es/uo/qresuobexdwaxevl3gnmsfjsc6i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Erscheinungsbild hat sich nichts geändert, aber jetzt haben wir die Hierarchie der Ansichts-Controller beseitigt. </font><font style="vertical-align: inherit;">Ich empfehle dringend, sich von dieser Gelegenheit nicht mitreißen zu lassen. </font><font style="vertical-align: inherit;">Es ist besser, den Anzeigecode in einem Router oder einer Entität mit denselben Rechten aufzurufen. </font><font style="vertical-align: inherit;">Im Namen von Transparenz und Klarheit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben Benutzern ein großartiges Tool zum Spammen von Servern bei Fehlfunktionen, Wartung usw. zur Verfügung gestellt. </font><font style="vertical-align: inherit;">Was können wir verbessern?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimale Anforderungszeit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir schalten das Internet aus und versuchen es erneut. </font><font style="vertical-align: inherit;">Führen Sie den Lader aus. </font><font style="vertical-align: inherit;">Die Antwort wird sofort kommen und ein Minispiel "Clicker" erhalten. </font><font style="vertical-align: inherit;">Mit blinkender Animation. </font><font style="vertical-align: inherit;">Nicht zu schön. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uz/3n/mu/uz3nmu7_ag_k4swmsiy8gw2y1z0.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns einen sofortigen Fehler in einen Prozess verwandeln. </font><font style="vertical-align: inherit;">Die Idee ist einfach - wir machen die minimale Anforderungszeit. </font><font style="vertical-align: inherit;">Hier hängt die Implementierung von Ihrem Netzwerkansatz ab. </font><font style="vertical-align: inherit;">Angenommen, ich verwende Operation und für mich sieht es so aus:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayOperation</span>: <span class="hljs-title">AsyncOperation</span> </span>{
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> _delayTime: <span class="hljs-type">Double</span><font></font>
<font></font>
	<span class="hljs-keyword">init</span>(delayTime: <span class="hljs-type">Double</span> = <span class="hljs-number">0.3</span>) {<font></font>
		_delayTime = delayTime<font></font>
	}<font></font>
	<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">super</span>.main()<font></font>
<font></font>
		<span class="hljs-type">DispatchQueue</span>.global().asyncAfter(deadline: .now() + _delayTime) {
			<span class="hljs-keyword">self</span>.state = .finished<font></font>
		}<font></font>
	}<font></font>
}<font></font>
		<font></font>
<span class="hljs-comment">// -  </span>
<span class="hljs-keyword">let</span> flowListOperation = flowService.list(<span class="hljs-keyword">for</span>: pageID, path: path, limiter: limiter)
<span class="hljs-keyword">let</span> handler = createHandler(<span class="hljs-keyword">for</span>: flowListOperation)
<span class="hljs-keyword">let</span> delayOperation = <span class="hljs-type">DelayOperation</span>(delayTime: <span class="hljs-number">0.5</span>)
<span class="hljs-comment">///  &gt;&gt;&gt;  addDependency. </span><font></font>
[flowListOperation, delayOperation] &gt;&gt;&gt; handler<font></font>
operationQueue.addOperations([flowListOperation, delayOperation, handler])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für den allgemeinen Fall kann ich dieses Design anbieten:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//  global      </span>
<span class="hljs-type">DispatchQueue</span>.global().asyncAfter(deadline: .now() + <span class="hljs-number">0.15</span>) {
    <span class="hljs-comment">// your code here</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oder wir können eine Abstraktion über unsere asynchronen Aktionen erstellen und die Verwaltbarkeit erweitern:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Task</span> </span>{
    	<span class="hljs-keyword">let</span> closure: () -&gt; <span class="hljs-type">Void</span><font></font>
    <font></font>
    	<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _delayTime: <span class="hljs-type">Double?</span><font></font>
    <font></font>
    	<span class="hljs-keyword">init</span>(closure: @escaping () -&gt; <span class="hljs-type">Void</span>) {
    		<span class="hljs-keyword">self</span>.closure = closure<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-keyword">fileprivate</span> <span class="hljs-keyword">init</span>(closure: @escaping () -&gt; <span class="hljs-type">Void</span>, time: <span class="hljs-type">Double</span>) {
    		<span class="hljs-keyword">self</span>.closure = closure<font></font>
    		_delayTime = time<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-meta">@discardableResult</span>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> {
    		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> delayTime = _delayTime {
    			<span class="hljs-type">DispatchQueue</span>.global().asyncAfter(deadline: .now() + delayTime) {
    				<span class="hljs-keyword">self</span>.closure()<font></font>
    			}<font></font>
    			<span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span><font></font>
    		}<font></font>
    		closure()<font></font>
    		<span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span><font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">delayedTask</span><span class="hljs-params">(time: Double)</span></span> -&gt; <span class="hljs-type">Self</span> {
    		<span class="hljs-keyword">return</span> <span class="hljs-type">Task</span>(closure: closure, time: time)<font></font>
    	}<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">//    </span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">requestObject</span><span class="hljs-params">(completionHandler: @escaping <span class="hljs-params">(<span class="hljs-params">(Result&lt;Bool, Error&gt;)</span></span></span></span> -&gt; <span class="hljs-type">Void</span>)) -&gt; <span class="hljs-type">Task</span> {
    		<span class="hljs-keyword">return</span> <span class="hljs-type">Task</span> {<font></font>
    			completionHandler(.failure(<span class="hljs-type">NetworkError</span>.internetError))<font></font>
    		}<font></font>
    			.delayedTask(time: <span class="hljs-number">0.5</span>)<font></font>
    		.run()<font></font>
    	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt erscheint unsere Animation auch im Offline-Modus nicht mehr so ​​scharf. </font><font style="vertical-align: inherit;">Ich empfehle diesen Ansatz an den meisten Stellen mit Animation. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9k/oq/46/9koq46qq0wffoivy0ucs18om1cm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Flugzeugmodus empfiehlt es sich, eine Warnmeldung anzuzeigen (der Benutzer kann vergessen, den Modus auszuschalten, um mit der Anwendung zu arbeiten). </font><font style="vertical-align: inherit;">Wie macht zum Beispiel ein Telegramm. </font><font style="vertical-align: inherit;">Und für wichtige Fragen ist es gut, einige Male unter der Haube zu wiederholen, bevor eine Warnung angezeigt wird ... Aber dazu ein anderes Mal mehr :)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testbarkeit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die gesamte Logik im viewController gespeichert ist (wie jetzt), ist es schwierig zu testen. </font><font style="vertical-align: inherit;">Wenn Ihr viewController jedoch mit der Geschäftslogik geteilt wird, wird das Testen zu einer trivialen Aufgabe. </font><font style="vertical-align: inherit;">Mit einer Bewegung der Arm </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hosen,</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dreht sich die </font><font style="vertical-align: inherit;">Geschäftslogik in:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">requestFeed</span><span class="hljs-params">()</span></span> {<font></font>
		service.requestObject { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] (result) <span class="hljs-keyword">in</span>
			<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> `<span class="hljs-keyword">self</span>` = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
			<span class="hljs-keyword">switch</span> result {
			<span class="hljs-keyword">case</span> .success:
				<span class="hljs-keyword">break</span>
			<span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
				<span class="hljs-type">DispatchQueue</span>.main.async {
					<span class="hljs-keyword">let</span> recoverableError = <span class="hljs-type">RecoverableError</span>(error: error, attempter: .tryAgainAttempter(block: {
						<span class="hljs-keyword">self</span>.requestFeed()<font></font>
					}))<font></font>
					<span class="hljs-comment">//     </span>
					<span class="hljs-keyword">self</span>.viewInput?.presentAlert(from: recoverableError)<font></font>
				}<font></font>
			}<font></font>
		}<font></font>
	}</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-comment">// -  </span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testRequestFeedFailed</span><span class="hljs-params">()</span></span> {
	<span class="hljs-comment">// Put out mock that conform to AlertPresntable protocol</span>
	controller.viewInput = <span class="hljs-type">ViewInputMock</span>()<font></font>
<font></font>
	<span class="hljs-comment">//  .    ,    </span>
	<span class="hljs-comment">//    expectation</span><font></font>
	controller.requestFeed()<font></font>
<font></font>
	<span class="hljs-comment">// Our mocked object should save to true to bool variable when method called</span>
	<span class="hljs-type">XCTAssert</span>(controller.viewInput.presentAlertCalled)
	<span class="hljs-comment">// Next we could compare recoverable error attempter to expected attempter</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammen mit diesem Artikel haben wir:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein praktischer Mechanismus zum Anzeigen von Warnungen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzer hatten die Möglichkeit, einen erfolglosen Vorgang erneut zu versuchen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und versucht, die Benutzererfahrung mit unserer Anwendung zu verbessern</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zum Code</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Vielen Dank für Ihre Zeit, ich werde Ihre Fragen gerne in den Kommentaren beantworten.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495336/index.html">Zwietracht als Corporate Messenger und nicht nur</a></li>
<li><a href="../de495338/index.html">Best Practices und Richtlinien zum Starten von Containern und Kubernetes in Produktionsumgebungen</a></li>
<li><a href="../de495340/index.html">So ändern Sie die Arbeit eines Administrators in einem Restaurant für einen guten Job in der IT</a></li>
<li><a href="../de495342/index.html">Abrechnung von Bankkarten im Handel - Erstellen eines offenen Datensatzes und einer Infografik in Google Data Studio</a></li>
<li><a href="../de495344/index.html">Vereinheitlichen Sie es: Wie Lamoda seine Go-Services konsistent macht</a></li>
<li><a href="../de499818/index.html">Usbekisches Telegramm-Marketing</a></li>
<li><a href="../de499820/index.html">Warum wir Kotlin als eine unserer Zielsprachen gewählt haben. Teil 2: Kotlin Multiplattform</a></li>
<li><a href="../de499822/index.html">Drahtloser Zugangspunkt vs. Router: Was sind die Unterschiede?</a></li>
<li><a href="../de499824/index.html">Die Zusammenfassung der Ereignisse für Personal- und IT-Personalvermittler im Mai 2020</a></li>
<li><a href="../de499826/index.html">Verteilter Blutdruck</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>