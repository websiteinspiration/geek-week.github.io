<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõãÔ∏è üë®‚Äçüë©‚Äçüëß üëãüèª Algoritmos de procesamiento r√°pido de cadenas HTTP ‚ùé üì∞ üë∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La compresi√≥n de encabezados est√°ndar apareci√≥ en HTTP / 2, pero el cuerpo de los valores de URI, Cookie, User-Agent todav√≠a puede ser de decenas de k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algoritmos de procesamiento r√°pido de cadenas HTTP</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/493242/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La compresi√≥n de encabezados est√°ndar apareci√≥ en HTTP / 2, pero el cuerpo de los valores de URI, Cookie, User-Agent todav√≠a puede ser de decenas de kilobytes y requiere tokenizaci√≥n, b√∫squeda y comparaci√≥n de subcadenas. </font><font style="vertical-align: inherit;">La tarea se vuelve cr√≠tica si un analizador HTTP necesita manejar tr√°fico malicioso pesado. </font><font style="vertical-align: inherit;">Las bibliotecas est√°ndar proporcionan amplias herramientas de procesamiento de cadenas, pero las cadenas HTTP tienen sus propios detalles. </font><font style="vertical-align: inherit;">Es por esta especificidad que se desarroll√≥ el analizador HTTP Tempesta FW. </font><font style="vertical-align: inherit;">Su rendimiento es varias veces mayor en comparaci√≥n con las soluciones modernas de c√≥digo abierto y supera a las m√°s r√°pidas.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GcAJF4648JI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Krizhanovsky</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">krizhanovsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) fundador y arquitecto de sistemas Tempesta Technologies, experto en inform√°tica de alto rendimiento en Linux / x86-64. Alexander hablar√° sobre las peculiaridades de la estructura de las cadenas HTTP, explicar√° por qu√© las bibliotecas est√°ndar no son adecuadas para procesarlas y presentar√° la soluci√≥n Tempesta FW. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debajo del corte: c√≥mo HTTP Flood convierte su analizador HTTP en un cuello de botella, problemas x86-64 con predicciones err√≥neas de ramificaci√≥n, almacenamiento en cach√© y falta de memoria en tareas t√≠picas de analizador HTTP, comparaci√≥n FSM con saltos directos, optimizaci√≥n GCC, vectorizaci√≥n autom√°tica, strspn () - y algoritmos similares a strcasecmp () para cadenas HTTP, SSE, AVX2 y ataques de inyecci√≥n de filtrado utilizando AVX2.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Tempesta Technologies desarrollamos software a medida: nos especializamos en √°reas complejas relacionadas con el alto rendimiento. </font><font style="vertical-align: inherit;">Estamos especialmente orgullosos del desarrollo del n√∫cleo de la primera versi√≥n WAF de Positive Technologies. </font><font style="vertical-align: inherit;">Web Application Firewall (WAF) es un proxy HTTP: se ocupa de un an√°lisis muy profundo del tr√°fico HTTP para ataques (Web y DDoS). </font><font style="vertical-align: inherit;">Escribimos el primer n√∫cleo para ello. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s de la consultor√≠a, estamos desarrollando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : este es el controlador de entrega de aplicaciones (ADC). </font><font style="vertical-align: inherit;">Hablaremos de √©l.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controlador de entrega de aplicaciones</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Application Delivery Controller es un proxy HTTP con funcionalidad mejorada. </font><font style="vertical-align: inherit;">Pero hablar√© sobre una funci√≥n relacionada con la seguridad: sobre el filtrado de ataques DDoS y web. </font><font style="vertical-align: inherit;">Tambi√©n mencionar√© limitaciones, y mostrar√© el trabajo y las funciones con ejemplos de c√≥digo.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mg/gf/tw/mggftw9mux_ycaxzjbfqe6hpdc0.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actuaci√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta FW est√° integrado en el n√∫cleo de pila TCP / IP de Linux. </font><font style="vertical-align: inherit;">Gracias a esto y a varias otras optimizaciones, es muy r√°pido: puede procesar 1,8 millones de solicitudes por segundo en hardware barato. </font><font style="vertical-align: inherit;">Esto es 3 veces m√°s r√°pido que Nginx en la carga superior y tambi√©n es r√°pido en comparaci√≥n con el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enfoque de derivaci√≥n del n√∫cleo. </font></font></strong><br>
<br>
<img src="https://habrastorage.org/webt/te/md/pe/temdpec1gcgnm98ktgwr4gewn-8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En un peque√±o n√∫mero de n√∫cleos, muestra un rendimiento similar con el proyecto Seastar, que se utiliza en ScyllaDB (escrito en DPDK).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problema</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El proyecto naci√≥ cuando comenzamos a trabajar en PT AF, en 2013. </font><font style="vertical-align: inherit;">Este WAF se bas√≥ en un acelerador HTTP de c√≥digo abierto popular. </font><font style="vertical-align: inherit;">Nginx, HAProxy, Varnish o Apache Traffic son buenos aceleradores HTTP: entregan contenido fino, cach√©, modificaci√≥n, pero ninguno de ellos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est√° dise√±ado para el procesamiento y filtrado de tr√°fico masivo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, pensamos que si hay un firewall de nivel de red, ¬øpor qu√© no continuar con esta idea e integrarla en la pila TCP / IP como un firewall de nivel de aplicaci√≥n? </font><font style="vertical-align: inherit;">En realidad, result√≥ Tempesta FW, un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h√≠brido de acelerador HTTP y firewall</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: Nginx se usar√° como ejemplo en el informe porque es un servidor web simple y popular. </font><font style="vertical-align: inherit;">En cambio, podr√≠a haber cualquier otro servidor HTTP de c√≥digo abierto.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos nuestra </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solicitud HTTP</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (HTTP / (1, ~ 2)) </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_o/3z/tq/_o3ztqvtwrv-7epdryhdztg8wsq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos tener un URI muy grande. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los separadores</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que son importantes en el momento del an√°lisis HTTP </font><font style="vertical-align: inherit;">se resaltan en negrita roja </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Destacar√© las caracter√≠sticas: cadenas grandes de varios kilobytes, as√≠ como diferentes delimitadores, por ejemplo, "puntos y comas" adicionales que necesitamos analizar, o la secuencia "\ r \ n". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n se necesita decir un poco sobre HTTP / 2.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caracter√≠sticas HTTP / 2</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2 es una mezcla de cadenas y datos binarios</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esta combinaci√≥n se trata m√°s de optimizar el ancho de banda de una conexi√≥n que de ahorrar recursos del servidor. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2 en HPACK usa una tabla din√°mica</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La primera solicitud del cliente no est√° optimizada, no est√° en la tabla. Debe analizarlo para que se agregue a la tabla. Si HTTP / 2 DDoS llega a usted, este ser√° el caso. En el caso normal, HTTP / 2 es un protocolo binario, pero a√∫n debe analizar el texto: nombres de encabezado de texto, datos. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codificaci√≥n Huffman</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esta es una codificaci√≥n simple, pero Huffman es monstruosamente dif√≠cil de programar r√°pidamente para la compresi√≥n: la codificaci√≥n de Huffman cruza el l√≠mite de bytes, no puede usar extensiones vectoriales y debe ir por bytes. </font><font style="vertical-align: inherit;">No podr√° procesar datos r√°pidamente en 32 o 16 bytes. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cookies, User-Agent, Referer, URI pueden ser muy grandes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Primero, elimine Huffman, luego env√≠elo a un analizador HTTP normal, igual que en HTTP / 1. </font><font style="vertical-align: inherit;">Aunque est√° permitido por el RFC, no se recomienda comprimir las cookies, ya que se trata de datos confidenciales; no debe proporcionar al atacante informaci√≥n sobre su tama√±o. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procesamiento HTTP lento</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Todos los servidores HTTP primero decodifican HTTP / 2 y luego env√≠an estas l√≠neas al analizador HTTP / 1 que HTTP / 1 ya utiliza. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øCu√°l es el problema con el an√°lisis HTTP / 1?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesita programar r√°pidamente la m√°quina de estado.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesita procesar r√°pidamente l√≠neas consecutivas.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tr√°fico malicioso se dirige a la parte m√°s lenta (m√°s d√©bil) del proceso. </font><font style="vertical-align: inherit;">Por lo tanto, si queremos hacer un filtro, debemos prestar atenci√≥n a las partes lentas para que tambi√©n funcionen r√°pidamente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perfil Nginx</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos el perfil nginx bajo la inundaci√≥n HTTP. </font><font style="vertical-align: inherit;">Deshabilite el registro de acceso para que el sistema de archivos no se ralentice. </font><font style="vertical-align: inherit;">Cuando incluso se solicita una p√°gina de √≠ndice regular, el analizador sube en la parte superior.</font></font><br>
<div class="scrollable-table"><table>
<tbody>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombre del s√≠mbolo</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,5719</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_parse_header_line</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,0303</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_vslprintf</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.6401</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5807</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recv</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5156</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_linux_sendfile_chain</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.4990</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_limit_req_handler</font></font></td>
</tr>
</tbody>
</table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Izquierda - "Perfil plano". </font><font style="vertical-align: inherit;">Curiosamente, el punto m√°s caliente no es mucho m√°s pesado que el siguiente, y despu√©s de eso, el perfil desciende suavemente. </font><font style="vertical-align: inherit;">Esto significa, por ejemplo, que optimizar la primera funci√≥n dos veces no ayudar√° a mejorar significativamente el rendimiento. </font><font style="vertical-align: inherit;">Es por eso que no optimizamos el mismo Nginx, sino que hicimos un nuevo proyecto que mejorar√° el rendimiento de toda la cola del perfil.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥mo se codifican los analizadores HTTP normales</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo general, tenemos un bucle ( </font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) que se ejecuta a lo largo de la l√≠nea y dos variables: estado ( </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y datos actuales ( </font></font><code>str_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entramos en el ciclo (1) y observamos el estado actual (verificar estado). Pasamos a los datos recibidos (s√≠mbolo </font></font><code><em>'b'</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e implementamos algo de l√≥gica. Pasamos al segundo estado (2). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hi/z7/s2/hiz7s2e3yw5bpqqz-qbir5hbteq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vaya al final </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3): esta es la segunda transici√≥n en relaci√≥n con el comienzo de nuestro c√≥digo y, posiblemente, la segunda falta en el cach√© de instrucciones. Luego vamos al principio </font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4), comemos el siguiente personaje ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/zs/17/gkzs17hdxtyfcaife8j1pms7wbi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... y nuevamente buscamos el estado en las instrucciones dentro </font></font><code>case 2:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando a una variable ya se le ha asignado un </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor</font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podr√≠amos ir a la siguiente instrucci√≥n. </font><font style="vertical-align: inherit;">Pero en cambio, subieron nuevamente y bajaron nuevamente. </font><font style="vertical-align: inherit;">"Cortamos c√≠rculos" por c√≥digo en lugar de simplemente bajar. </font><font style="vertical-align: inherit;">Los analizadores normales no, por ejemplo, Ragel genera un analizador con transiciones directas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mc/ba/3w/mcba3wgxqkflqjvq1mxytcy_kwo.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analizador HTTP Nginx</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunas palabras sobre el analizador nginx y su entorno. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx funciona con la API de socket normal</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : los datos que van al adaptador se copian en el espacio del usuario. </font><font style="vertical-align: inherit;">Como resultado, tenemos una gran porci√≥n de datos en la que estamos buscando lo que necesitamos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx utiliza un algoritmo que funciona en dos pasadas: primero busca la longitud, luego la verifica. </font><font style="vertical-align: inherit;">En el primer paso, escanea la cadena en busca de tokens, busca el primer token ("prueba"). </font><font style="vertical-align: inherit;">En el segundo, tokens, comprueba el final de la solicitud ( </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y comienza </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, de acuerdo con el tama√±o del token.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (p = b-&gt;pos; p &lt; b-&gt;last; p++) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">switch</span> (state) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">case</span> sw_method:
        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">' '</span>) {<font></font>
            m = r-&gt;request_start;<font></font>
            <span class="hljs-keyword">switch</span> (p - m) {         <span class="hljs-comment">// switch on token length!</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                <span class="hljs-keyword">if</span> (ngx_str3_cmp(m, <span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)) {<font></font>
                ...<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> ((ch &lt; <span class="hljs-string">'A'</span> || ch &gt; <span class="hljs-string">'Z'</span>) &amp;&amp; ch != <span class="hljs-string">'_'</span> &amp;&amp; ch != <span class="hljs-string">'-'</span>)
                <span class="hljs-keyword">return</span> NGX_HTTP_PARSE_INVALID_METHOD;
            <span class="hljs-keyword">break</span>;<font></font>
    ...</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Obtener" siempre est√° en la misma porci√≥n de datos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tempesta FW funciona con copia cero. </font><font style="vertical-align: inherit;">Esto significa que los datos pueden tener un tama√±o completamente arbitrario: 1 byte o 1000 bytes cada uno. </font><font style="vertical-align: inherit;">Este "mecanismo" no nos conviene. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos c√≥mo funciona </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en GCC.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gcc</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabla de b√∫squeda</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A la izquierda hay un ejemplo t√≠pico de enumeraci√≥n: comience con 0, luego etiquetas consecutivas, 26 constantes y luego alg√∫n c√≥digo que lo procese todo. A la derecha est√° el c√≥digo que genera el compilador. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ac/1n/hh/ac1nhhz9jqe87hdqb6bxfv541vu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, compare la variable </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el registro EAX con una constante. A continuaci√≥n, presentamos todas las etiquetas en forma de una matriz secuencial de punteros de 8 bytes (tabla de b√∫squeda). En esta instrucci√≥n, pasamos el desplazamiento en esta matriz: es una doble desreferenciaci√≥n de punteros. Abajo a la derecha est√° el c√≥digo al que cambiamos desde esta tabla. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resulta una doble desreferenciaci√≥n de la memoria: si recibimos datos secretos, entonces por bytes encontramos la direcci√≥n en la matriz y vamos a este puntero. Es importante saber que en la vida todav√≠a es peor que en el ejemplo: para la tabla de b√∫squeda, el compilador </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genera</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el c√≥digo es m√°s complicado en el caso de un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">script</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para un ataque Spectre. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La b√∫squeda binaria</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El siguiente caso </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font><font style="vertical-align: inherit;">es </font><font style="vertical-align: inherit;">con constantes secuenciales, sino con arbitrarias. El c√≥digo es el mismo, pero ahora GCC no puede compilar una matriz tan grande y usar constantes como el √≠ndice de la matriz. Cambia a la b√∫squeda binaria. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/mo/7p/asmo7pb4lxsv7pchnafv-qjz7u4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A la derecha vemos una comparaci√≥n secuencial, la transici√≥n a la direcci√≥n y la continuaci√≥n de la comparaci√≥n: la b√∫squeda binaria es por c√≥digo. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analizador HTTP Nginx.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Veamos qu√© es la m√°quina de estado nginx. Tiene 9 kilobytes de c√≥digo, esto es tres veces menos que el cach√© de primer nivel en la m√°quina en la que se lanzaron los puntos de referencia (como en la mayor√≠a de los procesadores x86-64).</font></font><br>
<br>
<pre><code class="bash hljs">$ nm -S /opt/nginx-1.11.5/sbin/nginx<font></font>
| grep http_parse | cut -d<span class="hljs-string">' '</span> -f 2<font></font>
| perl -le <span class="hljs-string">'$a += hex($_) while (&lt;&gt;); print $a'</span><font></font>
9220<font></font>
<font></font>
$ getconf LEVEL1_ICACHE_SIZE<font></font>
32768<font></font>
<font></font>
$ grep -c <span class="hljs-string">'case sw_'</span> src/http/ngx_http_parse.c<font></font>
84</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El analizador de encabezado nginx </font></font><code>ngx_http_parse_header_line ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es un tokenizador simple. </font><font style="vertical-align: inherit;">No hace nada con los valores de los encabezados y sus nombres, sino que simplemente coloca los tokens de los encabezados HTTP en un hash. </font><font style="vertical-align: inherit;">Si necesita alg√∫n valor de encabezado, escanee la tabla de encabezado y repita el an√°lisis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debemos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verificar estrictamente los nombres y valores de los encabezados</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por razones de seguridad </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></strong><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW: validaci√≥n de cadenas de cadenas HTTP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestra m√°quina de estados es un orden de magnitud m√°s potente: validamos el encabezado RFC e inmediatamente, en el analizador, procesamos casi todo. </font><font style="vertical-align: inherit;">Si nginx tiene 80 estados, entonces tenemos 520, y hay m√°s de ellos. </font><font style="vertical-align: inherit;">Si </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuamos, ser√≠a 10 veces m√°s grande. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E / S de copia cero</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : trozos de diferentes tama√±os pueden cortar datos en diferentes lugares. </font><font style="vertical-align: inherit;">diferentes fragmentos pueden cortar nuestros datos. </font><font style="vertical-align: inherit;">En E / S de copia cero, por ejemplo, "GET" puede (rara vez) aparecer como "GET", "GE" y "T" o "G", "E" y "T", por lo que debe almacenar el estado entre datos . </font><font style="vertical-align: inherit;">Pr√°cticamente eliminamos los costos de E / S, pero en el perfil se eleva, todo est√° mal. </font><font style="vertical-align: inherit;">El gran analizador HTTP es uno de los lugares m√°s cr√≠ticos del proyecto.</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -c <span class="hljs-string">'__FSM_STATE\|__FSM_TX\|__FSM_METH_MOVE\|__TFW_HTTP_PARSE_'</span> http_parser.c<font></font>
520<font></font>
    7.64% [tempesta_fw]     [k] tfw_http_parse_req<font></font>
    2.79% [e1000]           [k] e1000_xmit_frame<font></font>
    2.32% [tempesta_fw]     [k] __tfw_strspn_simd<font></font>
    2.31% [tempesta_fw]     [k] __tfw_http_msg_add_str_data<font></font>
    1.60% [tempesta_fw]     [k] __new_pgfrag<font></font>
    1.58% [kernel]          [k] skb_release_data<font></font>
    1.55% [tempesta_fw]     [k] __str_grow_tree<font></font>
    1.41% [kernel]          [k] __inet_lookup_established<font></font>
    1.35% [tempesta_fw]     [k] tfw_cache_do_action<font></font>
    1.35% [tempesta_fw]     [k] __tfw_strcmpspn</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© hacer para mejorar esta situaci√≥n?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referencias directas de FSM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo primero que hacemos es </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usar no un bucle, sino transiciones directas por etiquetas ( </font></font></strong><code>go to</code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Los generadores de analizadores normales como Ragel hacen esto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bq/di/pr/bqdipr9bt6au4ifisfpvjli2p_e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Codificamos cada uno de nuestros estados con una etiqueta </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y una etiqueta en C con </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el mismo nombre</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cada vez que queremos ir, encontramos una etiqueta </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o accedemos al mismo estado directamente desde el c√≥digo. La primera vez que pasamos </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y luego dentro de ella, vamos directamente a la etiqueta deseada. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desventaja</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cuando queremos cambiar al siguiente estado, debemos evaluar de inmediato si todav√≠a tenemos datos disponibles (porque E / S de copia cero). Condici√≥n del cuerpo</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se copia en cada estado: en lugar de una condici√≥n en un FSM controlado por conmutador normal, tenemos 500 de ellos seg√∫n el n√∫mero de estados. Generar c√≥digo para cada estado no es genial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el caso de m√°quinas de estado grandes, porque </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con un gran </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interior, GTC tambi√©n repite la condici√≥n </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">varias veces dentro del c√≥digo. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reemplazar con </font></font></strong><code><strong>switch</strong></code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transiciones directas.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La siguiente optimizaci√≥n es que no la usamos </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font><font style="vertical-align: inherit;">cambiamos </font><font style="vertical-align: inherit;">a saltos directos a las meta direcciones guardadas. Queremos ir inmediatamente al punto deseado tan pronto como ingresemos a la funci√≥n. GCC le permite hacer esto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i3/x5/7m/i3x57mb0tahhz99szccnfdbxde0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GCC tiene una extensi√≥n est√°ndar que puede ayudar. Tomamos el nombre de la etiqueta (aqu√≠ est√° </font></font><code>from</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y asignamos su direcci√≥n a alguna variable C mediante doble ampersand (&amp;&amp;). Ahora podemos hacer una instrucci√≥n de salto directo</font></font><code>jmp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la direcci√≥n de esta etiqueta con </font></font><code>goto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos que sale de eso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendimiento de conversi√≥n directa</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En un peque√±o n√∫mero de estados, el generador de c√≥digo de transici√≥n directa es incluso un poco m√°s lento de lo normal </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero para grandes m√°quinas de estado, la productividad se duplica. </font><font style="vertical-align: inherit;">Si la m√°quina de estado es peque√±a, es mejor usar la habitual </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -m 2 <span class="hljs-string">'model name\|bugs'</span> /proc/cpuinfo<font></font>
model name : Intel(R) Core(TM) i7-6500U CPU @ 2.50GHz<font></font>
bugs       : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf<font></font>
<font></font>
$ gcc --version|head -1<font></font>
gcc (GCC) 8.2.1 20181105 (Red Hat 8.2.1-5)<font></font>
<font></font>
States     Switch-driven automaton     Goto-driven automaton<font></font>
     7     header_line:      139ms     header_line:          156ms<font></font>
    27     request_line:     210ms     request_line:         186ms<font></font>
   406     big_header_line: 1406ms     goto_big_header_line: 727ms</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: el c√≥digo de Tempesta es m√°s complicado que los ejemplos. </font><font style="vertical-align: inherit;">GitHub tiene todos los </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/tempesta-tech/blog/tree/master/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puntos de referencia</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que pueda ver todo en detalle. </font><font style="vertical-align: inherit;">El c√≥digo del analizador original est√° disponible </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el enlace</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (analizador HTTP principal). </font><font style="vertical-align: inherit;">Adem√°s de eso, en Tempesta FW hay </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analizadores m√°s peque√±os</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que usan FSM m√°s f√°cilmente.</font></font></em><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© las transiciones directas pueden ser m√°s lentas?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la m√°quina de estado, pasamos por un mont√≥n de c√≥digo, por lo que (esperado) habr√° muchas predicciones err√≥neas de la rama. </font><font style="vertical-align: inherit;">Realicemos el "perfilado" de acuerdo con la predicci√≥n de errores de rama:</font></font><br>
<br>
<pre><code class="bash hljs">perf record -e branch-misses -g ./http_benchmark<font></font>
406 states:    switch       - 38% on switch(),<font></font>
               direct jumps - 13% on header value parsing<font></font>
			   <font></font>
7,27 states:   switch       - &lt;18% switch(), up to 40% <span class="hljs-keyword">for</span>()<font></font>
               direct jumps ‚Äì up to 46% on header &amp; URI parsing</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En una m√°quina de estado grande con 406 estados, pasamos el 38% del tiempo procesando transiciones </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En una m√°quina de estado con transiciones directas, los puntos calientes son an√°lisis de l√≠nea. </font><font style="vertical-align: inherit;">Analizar una cadena en cada estado incluye verificar la condici√≥n del final de la cadena: la condici√≥n </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la m√°quina de estado encendida </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="bash hljs">perf <span class="hljs-built_in">stat</span> -e L1-icache-load-misses ./http_benchmark<font></font>
<font></font>
                       Switch-driven automaton  Goto-driven automaton<font></font>
big FSM code size:                       29156                  49202<font></font>
L1-icache-load-misses:                      4M                     2M</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, analizamos el perfil de ambos tipos de m√°quinas de estado por eventos L1 de cach√© de instrucciones: casi 30 kilobytes para </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y 50 kilobytes para saltos directos (m√°s que el cach√© de las instrucciones de primer nivel). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que si no encajamos en el cach√©, deber√≠a haber muchos errores de cach√© para tal m√°quina de estado. </font><font style="vertical-align: inherit;">Pero no, son 2 veces menos. </font><font style="vertical-align: inherit;">Esto se debe a que la memoria cach√© funciona mejor: trabajamos con el c√≥digo secuencialmente y logramos extraer datos de las memorias cach√© m√°s antiguas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El compilador cambia el orden del c√≥digo.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando programamos el c√≥digo de m√°quina de estado </font></font><code>go to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, primero tenemos los estados que se llamar√°n primero cuando se reciban los datos: el m√©todo HTTP, el URI y luego los encabezados HTTP. Parece l√≥gico que el c√≥digo se cargue en la memoria cach√© del procesador de forma secuencial, de arriba a abajo, justo cuando revisamos los datos. Pero esto est√° completamente mal. Si observa el c√≥digo del ensamblador, ver√° cosas incre√≠bles. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tg/uf/zr/tgufzrnfusabmvn1gg9ulzjgvgo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A la izquierda est√° lo que programamos: primero analizamos los m√©todos </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">luego en alg√∫n lugar muy por debajo del m√©todo poco probable </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por lo tanto, esperamos ver el an√°lisis </font></font><code> GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font><font style="vertical-align: inherit;">al comienzo del ensamblador </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y luego </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pero todo es todo lo contrario: </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el medio, </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al final y </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arriba.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto se debe a que el compilador no comprende c√≥mo nos llegan los datos. </font><font style="vertical-align: inherit;">Distribuye el c√≥digo de acuerdo con su imagen de c√≥digo hermoso. </font><font style="vertical-align: inherit;">Para que pueda organizar el c√≥digo en el orden correcto, debemos usar la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">barrera del compilador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La barrera del compilador es un conjunto ficticio a trav√©s del cual el compilador no se reordenar√°. </font><font style="vertical-align: inherit;">Simplemente colocando tales barreras, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mejoramos la productividad en un 4%</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">STATE(sw_method) {<font></font>
    ... <span class="hljs-comment">// the most frequent states</span>
    MATCH(NGX_HTTP_GET, <span class="hljs-string">"GET "</span>);<font></font>
    MATCH(NGX_HTTP_POST, <span class="hljs-string">"POST"</span>);<font></font>
    <font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span>: : :<span class="hljs-string">"memory"</span>);<font></font>
    ... <span class="hljs-comment">// many other states</span><font></font>
    <font></font>
    <span class="hljs-comment">// Improbable states</span>
    METH_MOVE(Req_MethU, <span class="hljs-string">'N'</span>, Req_MethUn);<font></font>
    METH_MOVE(Req_MethUn, <span class="hljs-string">'L'</span>, Req_MethUnl);<font></font>
    METH_MOVE(Req_MethUnl, <span class="hljs-string">'O'</span>, Req_MethUnlo);<font></font>
    METH_MOVE(Req_MethUnlo, <span class="hljs-string">'C'</span>, Req_MethUnloc);<font></font>
    METH_MOVE_finish(Req_MethUnloc, <span class="hljs-string">'K'</span>, NGX_HTTP_UNLOCK)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redacta el c√≥digo a tu manera</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que el compilador no organiza los datos como queremos, haremos una </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">optimizaci√≥n guiada por el generador de perfiles</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (optimizaci√≥n bajo el control del generador de perfiles). </font><font style="vertical-align: inherit;">La optimizaci√≥n guiada del generador de perfiles (PGO) es el n√∫mero total de muestras, no una secuencia de llamadas. </font><font style="vertical-align: inherit;">Por ejemplo, un URI recibe m√°s muestras que un an√°lisis de m√©todo, por lo que posicionar√° el c√≥digo de procesamiento de URI antes de procesar el m√©todo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo funciona? </font><font style="vertical-align: inherit;">Escribiremos el c√≥digo, ejecutaremos puntos de referencia en √©l, daremos el resultado del perfil al compilador y generar√° el c√≥digo √≥ptimo para nuestras cargas. </font><font style="vertical-align: inherit;">Pero el problema es que simplemente compila las secciones m√°s populares del c√≥digo, pero no rastrea la dependencia del tiempo. </font><font style="vertical-align: inherit;">Si el URI m√°s grande en la carga, entonces este ser√° el lugar m√°s caluroso. </font><font style="vertical-align: inherit;">El URI se elevar√° a la parte superior de la funci√≥n, y PGO no mostrar√° que el nombre del m√©todo siempre est√° antes del URI. </font><font style="vertical-align: inherit;">En consecuencia, PGO no funciona.</font></font><br>
<br>
<pre><code class="cpp hljs">Req_Method: {
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_Uri;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'P'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'T'</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_UriSpace;<font></font>
    }<font></font>
    <span class="hljs-keyword">goto</span> Req_Meth_SlowPath;<font></font>
}<font></font>
... <span class="hljs-comment">// other methods: POST, PUT etc.</span><font></font>
Req_Uri:<font></font>
    ... <span class="hljs-comment">// URI processing</span><font></font>
Req_Meth_SlowPath:<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que funciona </font></font><br>
<br>
<code><strong>likely</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code><strong>unlikely</strong></code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">macros</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (para el c√≥digo del kernel de Linux, los intr√≠nsecos de GCC est√°n disponibles en el espacio del usuario </font></font><code>__builtin_expect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Dicen qu√© c√≥digo colocar m√°s cerca. Por ejemplo, probablemente informa que el cuerpo de la solicitud deber√≠a estar inmediatamente detr√°s </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Luego, la captaci√≥n previa del c√≥digo (captaci√≥n previa del procesador) seleccionar√° ese c√≥digo y todo ser√° r√°pido. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7x/4u/05/7x4u057of2wmtq310wflcuyvlei.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La imagen muestra el comienzo del m√©todo de an√°lisis, el final y la barrera. No esper√°bamos ver el c√≥digo detr√°s de la barrera. Parece que esto no deber√≠a ser, hemos puesto una barrera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPero qu√© pasa en la realidad? El compilador ve la </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">condici√≥n: lo m√°s probable es que ingresemos al cuerpo de la condici√≥n y all√≠ cambiemos a un salto incondicional a la etiqueta</font></font><code>Req_Uri</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Resulta que el c√≥digo que est√° despu√©s de nuestra condici√≥n no se procesa en la "ruta activa". </font><font style="vertical-align: inherit;">El compilador mueve el c√≥digo debajo de la etiqueta detr√°s </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a pesar de la barrera, porque se cumple la condici√≥n de c√≥digo activo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para esto no fue as√≠, GCC tiene una extensi√≥n: los atributos </font></font><code>hot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>cold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para las etiquetas. </font><font style="vertical-align: inherit;">Dicen qu√© etiqueta est√° caliente (lo m√°s probable) y cu√°l est√° fr√≠a (menos probable). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/ra/uh/bwrauhxesqvk_ke22cw67cqwuja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ acordamos qu√© es </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√°s probable </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y se lo dejamos a √©l </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bajo esta condici√≥n, el procesamiento de URI aumenta y </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se reduce. </font><font style="vertical-align: inherit;">El resto del c√≥digo para la m√°quina de estado menos probable permanece debajo porque la etiqueta est√° fr√≠a.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambiguo -O3</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos la optimizaci√≥n del compilador. </font><font style="vertical-align: inherit;">Lo primero que viene a la mente es usar no O2, sino O3: deber√≠a ser m√°s r√°pido. </font><font style="vertical-align: inherit;">Pero esto no es as√≠: O3 a veces genera un c√≥digo peor. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vc/-p/q8/vc-pq8a078kyofsx7cj1ukorbta.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O3 es una colecci√≥n de algunas optimizaciones</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si los agregamos a O2 por separado, obtenemos diferentes opciones: algunas optimizaciones ayudan, otras interfieren. </font><font style="vertical-align: inherit;">Para nuestro c√≥digo espec√≠fico, seleccionamos solo aquellas optimizaciones que generan mejor el c√≥digo. </font><font style="vertical-align: inherit;">Dejamos el mejor resultado: aqu√≠ hay 1.820 segundos en relaci√≥n con 1.838 y 1.858. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunas opciones est√°n resaltadas en verde: esta es la vectorizaci√≥n autom√°tica.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autovectorizaci√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un ejemplo de un ciclo de la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gu√≠a GCC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a[<span class="hljs-number">256</span>], b[<span class="hljs-number">256</span>], c[<span class="hljs-number">256</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<font></font>
        a[i] = b[i] + c[i];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si tenemos una matriz variable que se repite, podemos optimizar el ciclo: descomponerlo en vectores. </font><font style="vertical-align: inherit;">Por defecto, la auto- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vectorizaci√≥n est√°</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> habilitada en el tercer nivel de optimizaci√≥n -O3 </font><font style="vertical-align: inherit;">: GCC genera el c√≥digo vectorial donde puede. </font><font style="vertical-align: inherit;">Pero </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no todo el c√≥digo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se puede vectorizar autom√°ticamente (incluso si se vectoriza en principio). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos habilitar la opci√≥n GCC </font></font><code>-fopt-info-vec-all</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que muestra lo que se ha vectorizado y lo que no. </font><font style="vertical-align: inherit;">Obtenemos que para nuestro punto de referencia, nada est√° vectorizado, pero el c√≥digo a√∫n se genera peor. </font><font style="vertical-align: inherit;">Por lo tanto, la vectorizaci√≥n no siempre funciona: a veces ralentiza el c√≥digo. </font><font style="vertical-align: inherit;">Pero siempre podemos ver qu√© se ha vectorizado y qu√© no, y desactivar la vectorizaci√≥n, si es necesario.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alineaci√≥n: ¬øc√≥mo comparar una cadena con GET?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hacemos un peque√±o truco, como en nginx: no analizamos l√≠neas por bytes, sino que calculamos </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y comparamos l√≠neas con ellos.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR4_INT(a, b, c, d)    ((d &lt;&lt; 24) | (c &lt;&lt; 16) | (b &lt;&lt; 8) | a)</span>
<span class="hljs-keyword">if</span> (p == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)))
    <span class="hljs-comment">// we have GET as method</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sabemos que si no est√° </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alineado, se ralentiza 2-3 veces. </font><font style="vertical-align: inherit;">Escribimos un peque√±o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">punto de referencia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que lo demuestra.</font></font><br>
<br>
<pre><code class="cpp hljs">$ ./int_align<font></font>
Unaligned access = <span class="hljs-number">6.20482</span>
Aligned access = <span class="hljs-number">2.87012</span>
Read four bytes = <span class="hljs-number">2.45249</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego intenta alinear </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Miraremos, si la direcci√≥n est√° </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alineada, luego compararemos </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, si no, bytes.</font></font><br>
<br>
<pre><code class="cpp hljs"> (((<span class="hljs-keyword">long</span>)(p) &amp; <span class="hljs-number">3</span>)<font></font>
  ? ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">0</span>]) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>)<font></font>
  | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span>))<font></font>
  : *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(p));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero resulta que este enfoque funciona peor:</font></font><br>
<br>
<pre><code class="bash hljs">full request line:     no difference<font></font>
method only:           unaligned      - 214ms<font></font>
                       aligned        - 231ms<font></font>
                       bytes          - 216ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En resumen: existe una diferencia entre el c√≥digo de referencia aislado, no optimizable, y el c√≥digo del analizador incorporado, que pierde la optimizaci√≥n debido a la gran cantidad de c√≥digo. </font><font style="vertical-align: inherit;">No hubo penalidad en el perfil. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: una discusi√≥n detallada de por qu√© esto est√° sucediendo en nuestra tarea se puede </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leer en GitHub</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© las cadenas HTTP son importantes para nosotros?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, este es un URI normal: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pw/_d/tw/pw_dtwjndt-xro47gvj3qehvpm4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
si es lo suficientemente exigente con el hotel, vaya a Reservas y configure algunos filtros, obtenga un URI de m√°s de un kilobyte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx tiene una m√°quina de an√°lisis bastante masiva en </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No funciona muy r√°pido. </font><font style="vertical-align: inherit;">Adem√°s, en el caso de Tempesta FW, necesitamos no solo analizar el URI, sino tambi√©n verificar si hay inyecciones.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">case</span> sw_check_uri:
    <span class="hljs-keyword">if</span> (usual[ch &gt;&gt; <span class="hljs-number">5</span>] &amp; (<span class="hljs-number">1U</span> &lt;&lt; (ch &amp; <span class="hljs-number">0x1f</span>)))
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">switch</span> (ch) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:<font></font>
        r-&gt;uri_ext = <span class="hljs-literal">NULL</span>;<font></font>
        state = sw_after_slash_in_uri;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'.'</span>:<font></font>
        r-&gt;uri_ext = p + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">' '</span>:<font></font>
        r-&gt;uri_end = p;<font></font>
        state = sw_check_uri_http_09;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> CR:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;<font></font>
        state = sw_almost_done;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LF:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;
        <span class="hljs-keyword">goto</span> done;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'%'</span>:<font></font>
    r-&gt;quoted_uri = <span class="hljs-number">1</span>;<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro URI: /redir_lang.jsp?lang=foobar%0d%0aContent-Length:%200%0d% </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0a% 0d% 0aHTTP / 1.1% 20200% 20OK% 0d% 0aContent-Type:% 20text / </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html% 0d% 0aContent -Longitud:% 2019% 0d% 0a% 0d% 0aShazam &lt;/ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html&gt;. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece el primero, pero tiene una inyecci√≥n. Tendr√°s que cavar lo suficientemente profundo como para entender esto. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejecutemos una prueba</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : tome el primer URI, alimente wrk, config√∫relo en nginx y vea que analizar nginx se calienta mucho. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m-/y1/id/m-y1idxtawyq5rjayodyb_r2tgq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si en la consulta de √≠ndice regular anterior estaba claro que el analizador ya estaba en la parte superior, aqu√≠ se calienta a√∫n m√°s.</font></font><br>
<br>
<pre><code class="bash hljs">8.62%  nginx         [.] ngx_http_parse_request_line<font></font>
2.52%  nginx         [.] ngx_http_parse_header_line<font></font>
1.42%  nginx         [.] ngx_palloc<font></font>
0.90%  [kernel]      [k] copy_user_enhanced_fast_string<font></font>
0.85%  nginx         [.] ngx_strstrn<font></font>
0.78%  libc-2.24.so  [.] _int_malloc<font></font>
0.69%  nginx         [.] ngx_hash_find<font></font>
0.66%  [kernel]      [k] tcp_recvmsg</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© tienen de especial las cadenas HTTP? </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay diferentes separadores </font></font><code>' : '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>' , '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e incluso el final de las l√≠neas, que pueden ser de doble byte </font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o de un solo byte </font></font><code>\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que se discuti√≥ al principio. </font><font style="vertical-align: inherit;">No hay terminaci√≥n 0 de las l√≠neas C; por razones de seguridad, queremos verificar con mayor precisi√≥n lo que nos llega. </font><font style="vertical-align: inherit;">Tenemos dos funciones est√°ndar que ayudan en el analizador.</font></font><br>
<br>
<ul>
<li><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: comprueba el alfabeto, los caracteres disponibles en una cadena, compila din√°micamente un alfabeto v√°lido, aunque se conoce en la etapa de compilaci√≥n del programa.</font></font></li>
<li><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No hay necesidad de convertir el caso de comparar </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con </font></font><code>Foo:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En la mayor√≠a de los casos </font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, solo se requiere cumplimiento / incumplimiento, y no es necesario conocer la posici√≥n en la l√≠nea.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trabajan despacio. </font><font style="vertical-align: inherit;">Veamos los puntos de referencia y comprendamos qu√© les pasa.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analizadores r√°pidos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay varios analizadores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx es el analizador m√°s simple, analiza estrictamente el cumplimiento de RFC. Tambi√©n hay analizadores PicoHTTPParser (H2O) y Cloudflare. Procesan los datos m√°s r√°pido, pero pueden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://blog.cloudflare.com/improving-pico"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">omitir caracteres</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que no est√°n permitidos por el RFC. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCMESTRI.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los analizadores usan varios enfoques diferentes. La primera es la instrucci√≥n PCMESTRI, que se usa en el analizador Pico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Establecemos rangos en las instrucciones. Desafortunadamente, podemos cargar 16 caracteres u 8 rangos. Si el rango consta de un solo car√°cter, simplemente repita. Debido a esta limitaci√≥n, el analizador Pico no puede verificar completamente el cumplimiento de RFC, porque el RFC tiene m√°s de 8 rangos en esta ubicaci√≥n.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ks/x8/m_/ksx8m_ixc0oy3kzucdwzumppaus.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cargamos el alfabeto en el registro, cargamos la cadena, ejecutamos la instrucci√≥n. En la salida, vemos r√°pidamente si hay una coincidencia o no. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2 - Enfoque CloudFlare.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El analizador CloudFlare, que utiliza AVX2, procesa 32 bytes de una cadena a la vez, en lugar de 16 bytes con un analizador Pico. El an√°lisis es mejor en CloudFlare porque se transfiri√≥ a AVX2. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/b8/3j/g1/b83jg1epzz6ec6dllxv1j4a-0lo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verificamos todos los caracteres en un espacio en la tabla ASCII, todos los caracteres son mayores que 128 y toman el rango entre ellos. El c√≥digo simple es r√°pido. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compare PCMESTRI y AVX2.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para nosotros, el l√≠mite actual es 1500. Este es el tama√±o m√°ximo de paquete que nos llega. Vemos que el c√≥digo AVX2 en Big Data es mucho m√°s r√°pido que el analizador Pico. Pero funciona m√°s lento en datos peque√±os, porque las instrucciones son m√°s pesadas en AVX2. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/se/5t/c2/se5tc2npli1yed8ypqkdkk3z-pm.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comparable a</font></font><code><strong>strspn</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si decidimos usarlo </font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, las cosas empeoran, especialmente en big data. </font><font style="vertical-align: inherit;">En el "combate" no se puede usar el analizador sint√°ctico </font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/08/vq/bf08vqlzni3dcjzxgiuj73zgszo.png"><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta Matcher es m√°s r√°pido y m√°s preciso</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro analizador de velocidad es como estos dos. En datos peque√±os, es tan r√°pido como un analizador Pico, en grandes, como CloudFlare. Sin embargo, no omite caracteres no v√°lidos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5t/ns/lw/5tnslwsd-ywmrv1d4xaj5_ypwbw.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo se organiza el analizador?</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nosotros, como nginx, definimos una matriz de bytes y verificamos los datos de entrada por este: este es el pr√≥logo de la funci√≥n. Aqu√≠ trabajamos solo con t√©rminos cortos, lo usamos </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">porque la predicci√≥n err√≥nea de las ramas es m√°s dolorosa para las l√≠neas cortas que para las largas. Tomamos este c√≥digo. Tenemos un l√≠mite de 4 debido a la √∫ltima l√≠nea: debemos escribir una condici√≥n bastante poderosa. Si procesamos m√°s de 4 bytes, la condici√≥n ser√° m√°s dif√≠cil y el c√≥digo m√°s lento.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> uri_a[] __attribute__((aligned(<span class="hljs-number">64</span>))) = {
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<font></font>
        ...<font></font>
        <span class="hljs-comment">// Branch misprediction is more crucial for short strings</span>
        <span class="hljs-keyword">if</span> (likely(len &lt;= <span class="hljs-number">4</span>)) {
                <span class="hljs-keyword">switch</span> (len) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<font></font>
                    c3 = uri_a[s[<span class="hljs-number">3</span>]];
                    <span class="hljs-comment">// fall through to process other chars</span>
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    c2 = uri_a[s[<span class="hljs-number">2</span>]];
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    c1 = uri_a[s[<span class="hljs-number">1</span>]];
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span> (c0 &amp; c1) == <span class="hljs-number">0</span> ? c0 : <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bucle principal y cola grande. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el ciclo de procesamiento principal, dividimos los datos: si es lo suficientemente largo, procesamos 128, 64, 32 o 16 bytes cada uno. </font><font style="vertical-align: inherit;">Tiene sentido procesar 128 cada uno: en paralelo, utilizamos varios canales de procesador (varias canalizaciones) y un procesador superescalar.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> ( ; unlikely(s + <span class="hljs-number">128</span> &lt;= end); s += <span class="hljs-number">128</span>) {<font></font>
        n = match_symbols_mask128_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">128</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">64</span> &lt;= end)) {<font></font>
        n = match_symbols_mask64_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">64</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">64</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">32</span> &lt;= end)) {<font></font>
        n = match_symbols_mask32_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">32</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">32</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">16</span> &lt;= end)) {<font></font>
        n = match_symbols_mask16_c(__C.URI_BM128, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">16</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">16</span>;<font></font>
}</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cola. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El final de la funci√≥n es similar al principio. </font><font style="vertical-align: inherit;">Si tenemos menos de 16 bytes, procesamos 4 bytes en un bucle y luego no m√°s de 3 bytes al final.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">while</span> (s + <span class="hljs-number">4</span> &lt;= end) {<font></font>
        c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
        c1 = uri_a[s[<span class="hljs-number">1</span>]];<font></font>
        c2 = uri_a[s[<span class="hljs-number">2</span>]];<font></font>
        c3 = uri_a[s[<span class="hljs-number">3</span>]];
        <span class="hljs-keyword">if</span> (!(c0 &amp; c1 &amp; c2 &amp; c3)) {<font></font>
                n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;
                <span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }<font></font>
        s += <span class="hljs-number">4</span>;<font></font>
}<font></font>
<font></font>
c0 = c1 = c2 = <span class="hljs-number">0</span>;
<span class="hljs-keyword">switch</span> (end - s) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                c2 = uri_a[s[<span class="hljs-number">2</span>]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                c1 = uri_a[s[<span class="hljs-number">1</span>]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
}<font></font>
<font></font>
n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;
<span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + c2;</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargue m√°scaras de bits y datos:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> este es el algoritmo principal del cuerpo principal de la funci√≥n. Presentamos una tabla ASCII (como en la imagen) con 16 filas y 8 columnas. Primero, codificamos nuestras filas de tabla en el primer registro de BM URI: la primera y segunda fila. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9l/cv/k2/9lcvk2_wg7qs6svdibpx9m1b09c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los s√≠mbolos reales que permitimos son </font></font><code>0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Est√°n codificados de la siguiente manera: </font></font><code>b8 = inv(1011 1000) = 0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>f8 = inv(1111 1000) = 2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Codificamos en orden inverso: comenzamos en 0, el primer car√°cter de servicio no est√° permitido, y luego las unidades son lo que est√° permitido. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Establecer las m√°scaras de bits ASCII.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por ejemplo, entra una l√≠nea </font></font><code>"pr"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: el primer car√°cter de la primera l√≠nea es ASCII, el segundo de la segunda l√≠nea. Ejecutamos la instrucci√≥n aleatoria, que baraja las filas de nuestra tabla codificada de acuerdo con el orden de estos caracteres en la entrada.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_i/zr/ol/_izrolii19qo5olblx0zzjgq_iu.jpeg"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ID de columna para entrada.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A continuaci√≥n, colocamos las columnas de la tabla ASCII en un registro diferente. Luego "cruzamos" los registros de columnas y filas, y obtenemos una correspondencia: nuestro car√°cter o no. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como las columnas son los 4 bits m√°s significativos del byte, nos desplazamos hacia la izquierda. AVX tiene un desplazamiento de solo 2 bytes, as√≠ que primero cambie el byte, luego n con nuestra m√°scara para obtener solo bits significativos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d9/xy/xr/d9xyxrmjyplbnhkpwrxbqblians.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Organizaci√≥n de columnas ASCII</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ejecute la segunda combinaci√≥n aleatoria, mueva la columna a las posiciones deseadas. En ambos casos, el byte de entrada de la √∫ltima columna, por lo que en la primera y segunda posici√≥n obtenemos la misma columna. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/g1/2s/hxg12sn4xw-qlt7miq97k0pnwgy.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intersecci√≥n de columnas y filas de m√°scaras</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lo hacemos </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">("cruzamos" las columnas con columnas) y obtenemos que los datos de entrada son v√°lidos: el resultado</font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde la intersecci√≥n de columnas y filas no es cero. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cd/oa/kw/cdoakwgjf-oipltg_xeyyglobn8.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuente el n√∫mero de ceros al final. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo recolectamos todo del vector </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y lo devolvemos a la salida, de manera bastante simple. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f9/ci/tl/f9citlkgsjvtxifi9qe3pdxu7su.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personaliza los alfabetos. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al trabajar con la tabla ASCII, obtenemos una funci√≥n econ√≥mica: utilizamos tablas est√°ticas, pero nada nos impide preguntar al usuario qu√© alfabeto est√° disponible para los URI, los nombres y los valores de los diferentes encabezados. </font><font style="vertical-align: inherit;">La solicitud HTTP URI y el encabezado usan 8 alfabetos (m√°s o menos) para analizar una solicitud HTTP. </font><font style="vertical-align: inherit;">Estas tablas pueden cargarse en el mismo c√≥digo y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compararse en un solo alfabeto especificado por el usuario, un</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> URI v√°lido. </font><font style="vertical-align: inherit;">Si no, es diferente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los ataques</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunos casos en que esto puede ser √∫til. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ataque de SSRF con BlackHat'17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ("Una nueva era de SSRF"): </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://foo@evil.com:80@google.com/</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un s√≠mbolo de ampersand poco probable. </font><font style="vertical-align: inherit;">En algunas aplicaciones se usa, en otras no. </font><font style="vertical-align: inherit;">Pero si no lo est√° utilizando, puede excluirlo del alfabeto v√°lido y el ataque ser√° bloqueado. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RCE-ataque:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬´efectivo es el realizar ataques de inyecci√≥n de comandos como¬ª, BSides'16: </font></font><code>User-Agent: ...;echo NAELBD$((26+58))$echo(echo NAELBD)NAELBD...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El User-Agent es un encabezado est√°tico, pero hay casos de un ataque RCE cuando algunos vienen </font></font><code>shell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con caracteres at√≠picos para el User-Agent. </font><font style="vertical-align: inherit;">Nos protegemos excepto por el signo del d√≥lar. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobreescritura de ruta relativa</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">El √∫ltimo caso es el que Google tuvo en 2016. </font><font style="vertical-align: inherit;">Las llaves, los dos puntos, llegaron a la URI </font></font><code>.../gallery?q=%0a{}*{background:red}/..//apis/howto_guide.html</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Estos son caracteres poco probables que se pueden excluir del alfabeto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strcasecmp ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es un c√≥digo bastante trivial. </font><font style="vertical-align: inherit;">Tambi√©n comparamos cadenas de 32 bytes, dos matrices cada una.</font></font><br>
<br>
<pre><code class="cpp hljs">__m256i CASE = _mm256_set1_epi8(<span class="hljs-number">0x20</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker‚Äôs Delight for signed comparison: -0x80 for both operands</span>
__m256i A = _mm256_set1_epi8(<span class="hljs-string">'A'</span> ‚Äì <span class="hljs-number">0x80</span>);<font></font>
__m256i D = _mm256_set1_epi8(<span class="hljs-string">'Z'</span> - <span class="hljs-string">'A'</span> + <span class="hljs-number">1</span> ‚Äì <span class="hljs-number">0x80</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker‚Äôs Delight: 'a' &lt;= v &lt;= 'z' to</span>
<span class="hljs-comment">// v - ('a' ‚Äì 0x80) &lt; 'z' - 'a' + 1 - 0x80</span><font></font>
__m256i sub = _mm256_sub_epi8(str1, A);<font></font>
__m256i cmp_r = _mm256_cmpgt_epi8(D, sub);<font></font>
__m256i lc = _mm256_and_si256(cmp_r, CASE);<font></font>
__m256i vl = _mm256_or_si256(str1, lc);<font></font>
__m256i eq = _mm256_cmpeq_epi8(vl, str2);<font></font>
<span class="hljs-keyword">return</span> ~_mm256_movemask_epi8(eq);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le damos al registro solo una l√≠nea, porque en la segunda programamos las constantes en nuestro analizador en min√∫sculas. </font><font style="vertical-align: inherit;">Como tenemos comparaciones significativas, restamos 128 de cada byte (un truco de Hacker's Delight). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n comparamos el rango de un car√°cter v√°lido: si podemos registrarnos para esta cadena o no, es una letra o no. </font><font style="vertical-align: inherit;">En el momento de verificar esto, en lugar de dos comparaciones de la a a la z, solo podemos usar una comparaci√≥n (un truco de Hacker's Delight) y pasar a una constante.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendimiento strcasecmp ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta es mucho m√°s r√°pido que GLIBC, incluso la nueva versi√≥n (18 o 19). </font><font style="vertical-align: inherit;">El c√≥digo </font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n usa AVX, pero no la segunda versi√≥n. </font><font style="vertical-align: inherit;">AVX2 es m√°s r√°pido, por lo que Tempesta tiene un c√≥digo m√°s r√°pido.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/zi/pb/wxzipbzdsbvge8u_abhsnok-gfa.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux kernel FPU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usamos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extensiones de procesador de vectores</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : est√°n disponibles en el n√∫cleo. Las instrucciones vectoriales son procesadas por el m√≥dulo procesador FPU. Este no es el m√≥dulo del procesador principal, ni los registros principales, sino bastante voluminoso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, hay optimizaci√≥n en Linux. Si pasamos del kernel al espacio de usuario y viceversa, no guardamos el contexto de los registros de FPU (XMM, YMM, ZMM): cambiamos el contexto de solo los registros del m√≥dulo del procesador principal. Se supone que el kernel del sistema operativo no funciona con la extensi√≥n vectorial del procesador. Pero si lo necesita, por ejemplo, la criptograf√≠a puede hacerlo, pero necesita usar </font></font><code>fpu_begin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>fpu_end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guardar y restaurar el contexto del registro FPU:</font></font><br>
<br>
<pre><code class="cpp hljs">__kernel_fpu_begin_bh();<font></font>
memcpy_avx(dst, src, n);<font></font>
__kernel_fpu_end_bh();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas son macros nativas que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guardan y restauran el estado del m√≥dulo del procesador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que es responsable de los registros vectoriales. </font><font style="vertical-align: inherit;">Estos son recursos bastante lentos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX y SSE</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de los puntos de referencia de guardar y restaurar el contexto de FPU, un par de palabras sobre operaciones vectoriales. </font><font style="vertical-align: inherit;">¬øPor qu√© a veces tiene sentido trabajar con ensamblador? </font><font style="vertical-align: inherit;">A veces, GCC genera un c√≥digo sub√≥ptimo. </font><font style="vertical-align: inherit;">El problema es que en los modelos de procesadores m√°s antiguos, hay una penalizaci√≥n significativa por la transici√≥n de SSE a AVX. </font><font style="vertical-align: inherit;">GCC tiene una nueva clave </font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: √∫sela para que no genere esta instrucci√≥n </font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que borra los registros y elimina esta penalizaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debe usar esta instrucci√≥n solo si est√° trabajando con c√≥digo antiguo que fue compilado para SSE por un tercero. </font><font style="vertical-align: inherit;">Este no es nuestro caso y podemos tirar estas instrucciones con seguridad.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto-vectorizaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el procesador. Esto significa que en cualquier c√≥digo de espacio de usuario habr√° operaciones vectoriales. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n9/vy/0w/n9vy0wal4alh1eelo1rbdjabavc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dos procesos en el sistema usan extensiones de procesador de vectores. Cuando su proceso va al kernel y viceversa, no pierde el tiempo ahorrando y restaurando el estado vectorial del procesador. Pero si cambia de un espacio de usuario a otro (cambio de contexto), adem√°s del hecho de que los cach√©s de primer nivel est√°n deshabilitados all√≠, el m√≥dulo de cambio de contexto en FPU begin / end tambi√©n funciona mal. La operaci√≥n es bastante costosa, un microbenchmark.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En microbenchmarks, todo es siempre dram√°tico, pero la operaci√≥n es muy costosa. </font><font style="vertical-align: inherit;">Por lo tanto, en el espacio del usuario, cambie el contexto durante mucho tiempo. </font><font style="vertical-align: inherit;">No tenemos cambio de contexto en el n√∫cleo, por lo que todo es r√°pido. </font><font style="vertical-align: inherit;">Guardamos y restauramos el procesador de vectores solo una vez para un conjunto de paquetes suficientemente grande.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intelpocalypse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al principio, mostr√© una opci√≥n de tabla de b√∫squeda para optimizar el c√≥digo del conmutador: un proceso largo, enumeraci√≥n, compila la tabla del conmutador en una matriz y sigue la doble referencia del puntero que salta sobre esta matriz. Este es un escenario para un ataque Spectre que explota la ejecuci√≥n especulativa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google tiene un buen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre c√≥mo se organiza la doble desreferenciaci√≥n de punteros en compiladores modernos en este momento (desde principios de 2018). No funciona muy bien. Si anteriormente en el registro se almacen√≥ alguna direcci√≥n y fuimos a esta direcci√≥n, ahora tenemos un c√≥digo diferente.</font></font><br>
<br>
<pre><code class="cpp hljs">jmp *%r11 <font></font>
    call l1<font></font>
l0: pause<font></font>
    lfence<font></font>
    jmp l0<font></font>
l1: mov %r11, (%rsp)<font></font>
    ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øComo funciona? "Llamamos" a la funci√≥n en l1, el proceso pasa a esta etiqueta y hacemos un hack: como si volvi√©ramos de una funci√≥n (que no es), pero reescribimos la direcci√≥n de retorno. Cuando hacemos las instrucciones </font></font><code>call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">colocamos </font><font style="vertical-align: inherit;">la direcci√≥n de retorno, la direcci√≥n actual en la pila, la reescribimos con el contenido necesario del registro y vamos a l1. Pero el procesador, cuando se ejecuta su captador previo, ve que hay una funci√≥n y luego una barrera. En consecuencia, todo ser√° lento: arroja la captaci√≥n previa y eliminamos la vulnerabilidad Spectre. El c√≥digo es lento, el rendimiento cae un 15%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente ataque relativamente nuevo es </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meltdown.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es espec√≠fico solo para procesos de espacio de usuario. </font><font style="vertical-align: inherit;">Es muy doloroso leer la memoria del n√∫cleo desde el espacio del usuario. </font><font style="vertical-align: inherit;">El ataque es evitado por el Kernel Pate Table Isolation (KPTI), que se compila en los nuevos n√∫cleos de forma predeterminada. </font><font style="vertical-align: inherit;">Pero KPTI es muy costoso, hasta un 30-40% de degradaci√≥n del rendimiento ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">medido por MariaDB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto se debe al hecho de que ya no tiene una optimizaci√≥n TLB perezosa: el espacio de direcciones del kernel y el procesador est√° completamente separado en diferentes tablas de p√°ginas (antes, TLB perezoso segu√≠a asignando el espacio del kernel a la tabla de p√°ginas de cada proceso). </font><font style="vertical-align: inherit;">Esto es doloroso para el espacio del usuario, pero no para Tempesta FW, que funciona completamente en el n√∫cleo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunos enlaces √∫tiles:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=http://natsys-lab.blogspot.com/2014/11/the-fast-finite-state-machine-for-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√°quina de estado finito r√°pido para an√°lisis HTTP</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=http://natsys-lab.blogspot.com/2016/10/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procesamiento de cadenas HTTP usando C, SSE4.2 y AVX2</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El deleite del hacker</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentos de ataques Meltdown y Spectre</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Intelpocalypse: goodbye fast system calls</a></li>
</ul><br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Saint HighLoad++</a>        .       , 6   -- (  ,      Saint HighLoad++)  ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> web </a>. <br>
<br>
     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PHP Russia</a>: 13   ,  .       ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">KnowledgeConf</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">++</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TechLead Conf</a> ‚Äî     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  , ,    .<br>
</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es493226/index.html">C√≥mo leer y corregir 100,000 l√≠neas de c√≥digo por semana</a></li>
<li><a href="../es493230/index.html">Nuevo Google PageSpeed ‚Äã‚ÄãInsights con tecnolog√≠a de Lighthouse 6 (beta): verifique el rendimiento de su sitio</a></li>
<li><a href="../es493232/index.html">La historia de mi trabajo en Open Product LLC</a></li>
<li><a href="../es493234/index.html">ING lanza Lion: una biblioteca de componentes web productivos, asequibles y flexibles</a></li>
<li><a href="../es493236/index.html">Asterisco: troncales externos en estado Solicitud enviada</a></li>
<li><a href="../es493244/index.html">¬øQu√© puede hacer una computadora cu√°ntica?</a></li>
<li><a href="../es493248/index.html">Seminario web "Oportunidades de Winnum para an√°lisis industrial"</a></li>
<li><a href="../es493250/index.html">Lo que est√° sucediendo con los viajes en este momento y c√≥mo protegerse en el transporte</a></li>
<li><a href="../es493252/index.html">Experiencia docente en una escuela de desarrollo, o por qu√© necesita ir a la escuela despu√©s de la universidad</a></li>
<li><a href="../es493254/index.html">El sistema de escuchas telef√≥nicas masivas de la poblaci√≥n era pr√°cticamente in√∫til para el FBI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>