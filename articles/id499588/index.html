<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔯 💪 🍗 Otentikasi dalam .NET Core gRpc dengan JWT ❎ 🎅🏿 ✔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini saya akan berbicara tentang fitur otentikasi API di layanan gRpc menggunakan JWT. Saya berasumsi bahwa Anda terbiasa dengan JWT dan h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Otentikasi dalam .NET Core gRpc dengan JWT</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499588/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada artikel ini saya akan berbicara tentang fitur otentikasi API di layanan gRpc menggunakan JWT. </font><font style="vertical-align: inherit;">Saya berasumsi bahwa Anda terbiasa dengan JWT dan header HTTP yang menggunakannya di .NET Core WebAPI, jadi saya tidak akan membahas detail ini. </font><font style="vertical-align: inherit;">Ketika saya mencoba menerapkan otentikasi di gRpc, saya menemukan fakta bahwa sebagian besar contoh ditulis menggunakan aplikasi konsol. </font><font style="vertical-align: inherit;">Ini terlalu jauh dari kenyataan di mana, menurut pendapat saya, pengembang hidup. </font><font style="vertical-align: inherit;">Misalnya, saya tidak ingin membuat saluran setiap kali saya ingin memanggil metode layanan. </font><font style="vertical-align: inherit;">Saya juga tidak ingin khawatir tentang mengirim token dan informasi pengguna dengan setiap permintaan. </font><font style="vertical-align: inherit;">Sebaliknya, saya ingin memiliki tingkat infrastruktur yang akan mengurus semua ini untuk saya. </font><font style="vertical-align: inherit;">Jika topik ini menarik bagi Anda, maka akan ada lebih banyak di bawah potongan. </font><font style="vertical-align: inherit;">Semua contoh dalam artikel ini valid untuk .NET Core 3.1.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh yang digunakan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum mempelajari topik ini, ada baiknya menjelaskan contoh yang digunakan dalam artikel. Seluruh solusi terdiri dari dua aplikasi: situs web dan layanan gRpc (selanjutnya disebut API). Keduanya ditulis dalam .NET Core 3.1. Pengguna dapat login dan melihat beberapa data jika ia diizinkan untuk ini. Situs web tidak menyimpan data pengguna dan bergantung pada API dalam proses otentikasi. Untuk berkomunikasi dengan layanan gRpc, situs web harus memiliki token JWT yang valid, tetapi token ini tidak terkait dengan otentikasi pengguna dalam aplikasi. Aplikasi web menggunakan cookie di sisinya. Agar API mengetahui pengguna mana yang membuat permintaan ke layanan, informasi tentang ini dikirim bersama dengan token JWT, tetapi tidak di token itu sendiri, tetapi dengan header HTTP tambahan. Gambar di bawah ini menunjukkan skema contoh sistem yang baru saja saya bicarakan:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/1-/a_/vn/1-a_vno-j3cfyv8ps49vdd_jv6m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini saya harus mencatat bahwa ketika saya melakukan contoh ini, saya tidak memiliki tujuan menerapkan metode otentikasi yang paling benar untuk API. </font><font style="vertical-align: inherit;">Jika Anda ingin melihat beberapa praktik terbaik, maka lihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spesifikasi OpenID Connect</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Meskipun, kadang-kadang menurut saya solusi yang paling benar bisa menjadi redundan dibandingkan dengan apa yang bisa menyelesaikan masalah dan menghemat waktu dan uang.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktifkan Otentikasi JWT di Layanan gRpc</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konfigurasi layanan gRpc tidak berbeda dengan konfigurasi biasa yang diperlukan oleh .NET Core API. </font><font style="vertical-align: inherit;">Kelebihan lainnya adalah tidak ada perbedaan untuk protokol HTTP dan HTTPS. </font><font style="vertical-align: inherit;">Secara singkat, Anda perlu menambahkan layanan otentikasi dan otorisasi standar, serta middlewere di file </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startup.cs</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tempat Anda menambahkan middleware penting: Anda harus menambahkannya persis antara perutean dan titik ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beberapa kode tidak ada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Configure</span>(<span class="hljs-params">...</span>)</span> {<font></font>
    app.UseRouting();<font></font>
    <font></font>
    app.UseAuthentication();<font></font>
    app.UseAuthorization();<font></font>
    <font></font>
    app.UseEndpoints(...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi tempat di mana layanan terdaftar tidak begitu penting, cukup tambahkan metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureServices ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke metode </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Namun di sini Anda perlu mengonfigurasi pemeriksaan token JWT. </font><font style="vertical-align: inherit;">Ini dapat didefinisikan di sini, tetapi saya sarankan menariknya ke kelas yang terpisah. </font><font style="vertical-align: inherit;">Dengan demikian, kode tersebut dapat terlihat seperti ini:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureServices</span>(<span class="hljs-params">...</span>)</span> {<font></font>
    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)<font></font>
        .AddJwtBearer(o =&gt; {<font></font>
            <span class="hljs-keyword">var</span> validator = <span class="hljs-keyword">new</span> JwtTokenValidator(...);<font></font>
            o.SecurityTokenValidators.Add(validator);<font></font>
        });<font></font>
    services.AddAuthorization();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JwtTokenValidator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah </font><font style="vertical-align: inherit;">kelas </font><font style="vertical-align: inherit;">di mana Anda akan mendefinisikan logika validasi. </font><font style="vertical-align: inherit;">Anda perlu membuat kelas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TokenValidationParameters</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan pengaturan yang benar dan akan melakukan sisa pekerjaan validasi JWT. </font><font style="vertical-align: inherit;">Sebagai bonus, Anda dapat menambahkan lapisan keamanan tambahan di sini. </font><font style="vertical-align: inherit;">Mungkin diperlukan karena JWT adalah format yang terkenal. </font><font style="vertical-align: inherit;">Jika Anda memiliki JWT, Anda dapat pergi ke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jwt.io</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan melihat beberapa informasi. </font><font style="vertical-align: inherit;">Saya lebih suka menambahkan enkripsi tambahan ke JWT, yang membuat dekripsi lebih sulit. </font><font style="vertical-align: inherit;">Seperti apa bentuk validator:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">JwtTokenValidator</span> : <span class="hljs-title">ISecurityTokenValidator</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">CanReadToken</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> securityToken</span>)</span> =&gt; <span class="hljs-literal">true</span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ClaimsPrincipal <span class="hljs-title">ValidateToken</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> securityToken, TokenValidationParameters validationParameters, <span class="hljs-keyword">out</span> SecurityToken validatedToken</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">new</span> JwtSecurityTokenHandler();
        <span class="hljs-keyword">var</span> tokenValidationParameters = <span class="hljs-keyword">new</span> TokenValidationParameters<font></font>
        {<font></font>
            ValidateIssuer = <span class="hljs-literal">true</span>,<font></font>
            ValidateAudience = <span class="hljs-literal">true</span>,<font></font>
            ValidateLifetime = <span class="hljs-literal">true</span>,<font></font>
            ValidateIssuerSigningKey = <span class="hljs-literal">true</span>,<font></font>
            ValidIssuer = <span class="hljs-string">"your string"</span>,<font></font>
            ValidAudience = <span class="hljs-string">"your string"</span>,<font></font>
            IssuerSigningKey = <span class="hljs-keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(<span class="hljs-string">"your secrete code"</span>))<font></font>
        };<font></font>
        <font></font>
        <span class="hljs-keyword">var</span> claimsPrincipal = handler.ValidateToken(token, tokenValidationParameters, <span class="hljs-keyword">out</span> validatedToken);
        <span class="hljs-keyword">return</span> claimsPrincipal;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> CanValidateToken { <span class="hljs-keyword">get</span>; } = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> MaximumTokenSizeInBytes { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-keyword">int</span>.MaxValue;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan itu semua yang dibutuhkan sisi API. </font><font style="vertical-align: inherit;">Riwayat pengaturan klien sedikit lebih lama dan sedikit berbeda tergantung pada protokol HTTP atau HTTPS yang dipilih.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengirim tajuk HTTP dengan setiap permintaan ke layanan gRpc</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda mungkin tahu ini dari dokumentasi resmi, yang sebenarnya tidak bisa Anda gunakan di mana pun kecuali dalam program konsol bodoh. Misalnya, Anda bisa melihatnya di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> channel = GrpcChannel.ForAddress(<span class="hljs-string">"https://localhost:5001"</span>);
<span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Greeter.GreeterClient(channel);
<span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> client.SayHelloAsync(
    <span class="hljs-keyword">new</span> HelloRequest { Name = <span class="hljs-string">"World"</span> });<font></font>
Console.WriteLine(response.Message);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menggunakan ini dalam proyek nyata, kita masih perlu memiliki konfigurasi terpusat dan DI, yang hampir tidak dipertimbangkan. Inilah yang perlu Anda lakukan. Pertama, kita perlu menambahkan paket NuGet yang diperlukan ke proyek kita. </font><font style="vertical-align: inherit;">
Paket </font><i><font style="vertical-align: inherit;">Grpc.Tools</font></i><font style="vertical-align: inherit;"> akan membantu Anda membuat prototipe saat membangun proyek, dan </font><i><font style="vertical-align: inherit;">Grpc.Net.ClientFactory</font></i><font style="vertical-align: inherit;"> akan membantu Anda mengatur DI. </font><font style="vertical-align: inherit;">
Saat bekerja dengan gRpc, jika Anda perlu mengimplementasikan pemrosesan Anda di suatu tempat di tengah-tengah rantai permintaan-respons, Anda perlu menggunakan kelas yang diwarisi dari </font><i><font style="vertical-align: inherit;">Interceptor</font></i><font style="vertical-align: inherit;"> , yang merupakan bagian dari </font><i><font style="vertical-align: inherit;">gRpc.Core</font></i><font style="vertical-align: inherit;"> . Jika Anda perlu mengakses </font><i><font style="vertical-align: inherit;">HttpContext.User.Identity</font></i><font style="vertical-align: inherit;"> di dalam layanan Anda, Anda dapat menambahkan antarmuka </font><i><font style="vertical-align: inherit;">IHttpContextAccessor</font></i></font><br>
<br>
<code>dotnet add package Grpc.Net.Client<br>
dotnet add package Google.Protobuf<br>
dotnet add package Grpc.Tools<br>
dotnet add package Grpc.Net.ClientFactory<br>
</code><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke layanan Anda (ini memerlukan pendaftaran tambahan di layanan). </font><font style="vertical-align: inherit;">Anda perlu menambahkan berikut ini ke file Startup.cs Anda.</font></font><br>
<br>
<pre><code class="cs hljs">services.AddTransient&lt;AuthHeadersInterceptor&gt;();<font></font>
services.AddHttpContextAccessor();<font></font>
<font></font>
<span class="hljs-keyword">var</span> httpClientBuilder = services.AddGrpcClient&lt;MygRpcService.MygRpcServiceClient&gt;(o =&gt; { o.Address = <span class="hljs-keyword">new</span> Uri(<span class="hljs-string">"grpc-endpoint-url"</span>); });<font></font>
httpClientBuilder.AddInterceptor&lt;AuthHeadersInterceptor&gt;();              <font></font>
httpClientBuilder.ConfigureChannel(o =&gt; o.Credentials = ChannelCredentials.Insecure);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AuthHeadersInterceptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah </font><font style="vertical-align: inherit;">kelas </font><font style="vertical-align: inherit;">kita sendiri, berasal dari kelas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interceptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ia menggunakan IHttpContextAccessor dan mendaftar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.AddHttpContextAccessor ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memungkinkan Anda untuk melakukan ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur Konfigurasi untuk HTTP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda mungkin memperhatikan konfigurasi berikut:</font></font><br>
<br>
<pre><code class="cs hljs">httpClientBuilder.ConfigureChannel(o =&gt; o.Credentials = ChannelCredentials.Insecure);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini diperlukan untuk bekerja melalui HTTP, tetapi ini tidak cukup. </font><font style="vertical-align: inherit;">Anda juga perlu mengecualikan baris ini dari metode Configure ().</font></font><br>
<br>
<pre><code class="cs hljs">app.UseHttpsRedirection();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan Anda masih perlu </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menari untuk</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> membuat pengaturan khusus sebelum membuat saluran gRpc. </font><font style="vertical-align: inherit;">Ini dapat dilakukan hanya sekali selama peluncuran aplikasi. </font><font style="vertical-align: inherit;">Karena itu, saya menambahkannya pada posisi yang hampir sama dengan baris yang dihapus yang disebutkan di atas. </font><font style="vertical-align: inherit;">Ini seharusnya hanya dipanggil untuk HTTP.</font></font><br>
<br>
<pre><code class="cs hljs">AppContext.SetSwitch(<span class="hljs-string">"System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport"</span>, <span class="hljs-literal">true</span>);
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur Konfigurasi untuk HTTPS</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada beberapa kesulitan dengan bekerja dengan SSL di Windows dan Linux. </font><font style="vertical-align: inherit;">Ini mungkin terjadi bahwa Anda mengembangkan pada komputer Windows dan menyebar ke Docker / Kubernetes menggunakan gambar berbasis Linux. </font><font style="vertical-align: inherit;">Dalam hal ini, konfigurasi tidak sesederhana yang dijelaskan dalam banyak posting. </font><font style="vertical-align: inherit;">Saya akan menjelaskan konfigurasi ini di artikel lain, dan di sini saya hanya akan menyentuh kode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita perlu mengkonfigurasi ulang saluran gRpc untuk menggunakan kredensial SSL. </font><font style="vertical-align: inherit;">Jika Anda menggunakan Docker dan membuat gambar berbasis Linux, Anda mungkin juga perlu mengkonfigurasi HttpClient untuk mengizinkan sertifikat yang tidak valid. </font><font style="vertical-align: inherit;">HttpClient dibuat untuk setiap saluran.</font></font><br>
<br>
<pre><code class="cs hljs">httpClientBuilder.ConfigureChannel(o =&gt;<font></font>
{<font></font>
    <span class="hljs-comment">// add SSL credentials</span>
    o.Credentials = <span class="hljs-keyword">new</span> SslCredentials();
    <span class="hljs-comment">// allow invalid/untrusted certificates</span>
    <span class="hljs-keyword">var</span> httpClientHandler = <span class="hljs-keyword">new</span> HttpClientHandler<font></font>
    {<font></font>
        ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator<font></font>
    };<font></font>
    <span class="hljs-keyword">var</span> httpClient = <span class="hljs-keyword">new</span> HttpClient(httpClientHandler);<font></font>
    o.HttpClient = httpClient;<font></font>
});<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menambahkan HTTP Header</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Header ditambahkan di kelas interseptor (penerus dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interceptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">gRpc menggunakan konsep metadata, yang dikirim bersama dengan permintaan sebagai header. </font><font style="vertical-align: inherit;">Kelas pencegat harus menambahkan metadata untuk konteks panggilan.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthHeadersInterceptor</span> : <span class="hljs-title">Interceptor</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AuthHeadersInterceptor</span>(<span class="hljs-params">IHttpContextAccessor httpContextAccessor</span>)</span><font></font>
    {<font></font>
        _httpContextAccessor = httpContextAccessor;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> AsyncUnaryCall&lt;TResponse&gt; AsyncUnaryCall&lt;TRequest, TResponse&gt;(TRequest request, ClientInterceptorContext&lt;TRequest, TResponse&gt; context, AsyncUnaryCallContinuation&lt;TRequest, TResponse&gt; continuation)<font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> metadata = <span class="hljs-keyword">new</span> Metadata<font></font>
        {<font></font>
            {HttpHeaderNames.Authorization, <span class="hljs-string">$"Bearer &lt;JWT_TOKEN&gt;"</span>}<font></font>
        };<font></font>
        <span class="hljs-keyword">var</span> userIdentity = _httpContextAccessor.HttpContext.User.Identity;
        <span class="hljs-keyword">if</span> (userIdentity.IsAuthenticated)<font></font>
        {<font></font>
            metadata.Add(HttpHeaderNames.User, userIdentity.Name);<font></font>
        }<font></font>
        <span class="hljs-keyword">var</span> callOption = context.Options.WithHeaders(metadata);<font></font>
        context = <span class="hljs-keyword">new</span> ClientInterceptorContext&lt;TRequest, TResponse&gt;(context.Method, context.Host, callOption);<font></font>
        <font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">base</span>.AsyncUnaryCall(request, context, continuation);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk skenario, ketika Anda baru saja memanggil layanan gRpc, Anda hanya perlu mengganti metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AsyncUnaryCall</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tentu saja, token JWT dapat disimpan dalam file konfigurasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan itu semua. </font><font style="vertical-align: inherit;">Nanti saya akan menambahkan tautan ke kode dengan contoh sederhana dari use case yang dijelaskan. </font><font style="vertical-align: inherit;">Jika Anda memiliki pertanyaan lebih lanjut, silakan kirim surat kepada saya. </font><font style="vertical-align: inherit;">Saya akan mencoba menjawab.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id499576/index.html">Cara bekerja dengan kata kunci negatif di Yandex.Direct dan Google Ads [dan mengotomatiskan proses]</a></li>
<li><a href="../id499578/index.html">Jaringan DOS menggunakan tumpukan mTCP</a></li>
<li><a href="../id499582/index.html">Model Predator-Prey di Node.js</a></li>
<li><a href="../id499584/index.html">Monitor sentuh industri FPM-215W</a></li>
<li><a href="../id499586/index.html">Bagaimana memikirkan navigasi di aplikasi seluler</a></li>
<li><a href="../id499592/index.html">AI: Melengkapi dunia besok</a></li>
<li><a href="../id499594/index.html">Cara membatasi frekuensi permintaan di HAProxy: petunjuk langkah demi langkah</a></li>
<li><a href="../id499598/index.html">Dan kita akan pergi ke utara! Apakah mungkin untuk menghemat pendinginan pusat data karena cuaca?</a></li>
<li><a href="../id499600/index.html">Cara bekerja bersama, bekerja terpisah</a></li>
<li><a href="../id499602/index.html">Memindahkan Konferensi Online: Pengalaman InnerSource Commons Summit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>