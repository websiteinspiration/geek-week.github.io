<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😋 ➿ 🔭 ZX Spectrum von Coronavirus und Sticks (eigentlich nicht wirklich) 🕷️ 👩🏾‍🍳 👦🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selbstisolation ist die Geißel der modernen Menschheit. Hier, zum Beispiel in der Nachbarstadt, organisieren sie freitags und samstags nach dem tradit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ZX Spectrum von Coronavirus und Sticks (eigentlich nicht wirklich)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498222/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selbstisolation ist die Geißel der modernen Menschheit. Hier, zum Beispiel in der Nachbarstadt, organisieren sie freitags und samstags nach dem traditionellen Klatschen um 20 Uhr Balkonkonzerte. Sie fühlen sich gut, ihre Häuser sind groß und ihre Nachbarn sind jung. Unsere Nachbarn sind älter, sie wollen keine Konzerte. Und die Häuser sind niedrig, was auch nicht zum Nichtstun beiträgt. Deshalb werden wir gerettet, so gut wir können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Nachmittag an einem abgelegenen Ort, nicht so schlimm. Wie abends, bis die Kinder einschlafen. Wie in den ersten Tagen, bis die Bücher ausgehen und sich die Serie langweilt. Aber ein Monat vergeht, gefolgt von einem anderen. Die Seele braucht altes Eisen. Aber nicht nur, sondern mit Perversion. Und ich kramte in den Mülleimern und fand dort den Zilog Z80-Prozessor:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7f1/fe7/7c9/7f1fe77c9972b2270ad8478702521555.jpg" alt="Bild"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich muss sagen, ich liebe diesen Prozessor wirklich. Wahrscheinlich ist das einzige, was ich an ihm mag, der 486. Chip, aber meine Hände werden ihn nicht bald erreichen, weil es schwierig und sinnlos ist, ihn in das Steckbrett einzusetzen. Müssen löten. Aber ich möchte noch nicht löten. Und noch mehr als das Z80 selbst liebe ich den ZX Spectrum-Computer, der auf dieser Basis gebaut wurde. Das native Spectrum leidet jedoch unter einer Katastrophe in Form eines benutzerdefinierten ULA-Logikchips, und seine Klone auf der losen Seite sind zwar nicht besonders schwer zu erstellen und zu verfeinern, aber immer noch nicht für das Steckbrettmodell geeignet, und warum so viele Sorgen, wenn es Arduino gibt?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein intelligenter, ausgewogener und adäquater Leser hört hier entweder auf zu lesen oder wirft etwas wie „1 FPGA-Chip wird die Spectrum-Computerklasse aufnehmen“, bevor er ihn stoppt. Ich bin nicht schlau, nicht angemessen, obwohl ausgeglichen, aber ich weiß nur über FPGA, dass es cool ist. Ich kann nur Arduino machen. Möchte aber wirklich die Drähte im Z80 stecken. Höchst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lasst uns beginnen </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir natürlich. Aber zuerst Haftungsausschluss.</font></font><b>,   ,   ,    .  —       .      ,    , .      ,    (,   ?), ,   ,   ,     ,  .       ,    ,  ,   ,   ,    .</b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist ein adäquater 8-Bit-Computer? Dies ist in der Tat ein Prozessor, der mit ROM und RAM verbunden ist, und an der Seite befinden sich einige Zähler, die auf dem zusammengesetzten Bildschirm angezeigt werden sollen. Manchmal ein Timer zum Quietschen. ZX Spectrum unterscheidet sich nicht vom traditionellen Schema, außer einem. Es gibt eine ULA. Dies ist in der Tat der „Chipsatz“ des Spektrums. ULA verwaltet Peripheriegeräte wie Tonbandgeräte, Hochtöner und Tastatur (teilweise), die auf dem Bildschirm ausgegeben werden (ja, ja, die integrierte Grafikkarte wurde im Spectrum-Chipsatz angezeigt, bevor sie zum Mainstream wurde). Es gab auch ein gemeinsames Denkmal, die ersten 16 KB RAM (Adressen von 0x4000 bis 0x5B00). Daraus zeichnete die ULA ein Komposit auf den Bildschirm, und damit die Z80 dort nicht herumfummelte, wenn es nicht notwendig war, konnte die ULA den Prozessor bei Bedarf stoppen, da das Taktsignal auf der Z80 von dieser kam. Das heißt, wenn ULA mit Speicher gearbeitet und erkannt hat,Da sich der Prozessor auch in diesen Speicher einschleicht (dafür überwachte er ständig die MREQ- und die A15- und A14-Leitungen), stoppte er einfach die Prozessortaktung, bis er selbst fertig war, was er brauchte. Um eine Datenkorruption auf dem Bus zu vermeiden, wurden übrigens Teile des Busses auf der Prozessorseite und auf der ULA-Seite durch ... Widerstände ... begrenzt. Außerdem befand sich der Speicher von der ULA-Seite auf dem Bus und ignorierte dementsprechend im Falle einer Kollision die Daten und Adressen von der Prozessorseite vollständig.Die Daten und Adressen des Prozessors wurden vollständig ignoriert.Die Daten und Adressen des Prozessors wurden vollständig ignoriert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus verfügte das Spectrum über ROMs (Adressen 0x0000 - 0x3FFF) und einen eigenen Prozessorspeicher (0x8000 - 0xFFFF), auf die ULA keinen Zugriff hatte und der schneller als 16 KB gemeinsam genutzter Speicher arbeitete, da der Prozessor ULA in diesem Bereich nicht störte . Das war aber nur auf der 48K-Version des Computers. In der Basisversion gab es nur ROMs und 16 KiB, die mit ULA kompatibel waren. Wir fangen mit ihr an.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist praktisch, dass der Z80-Prozessor DRAM regenerieren kann, aber irgendwie möchte ich mich nicht darum kümmern, da SRAM leichter zu finden ist und ich keinen Multiplexer habe (oder ich kann ihn nicht finden). Also werden wir SRAM verwenden. Zunächst werden wir das Hauptskelett zusammenbauen, an dem dann alles andere aufgehängt werden kann. Das Skelett wird ein Prozessor sein, ein ROM mit Firmware, der der Adresse des Spectrum-ROM, dem RAM, den ersten 16 KB nach dem ROM und einigen Chips zugeordnet ist, um alles zu verpacken ... Ich muss sagen, dass ich lange Zeit nicht drehen wollte, weil ich chinesische Layouts habe $ 1 für 2 Stück in ibee. Aber für mich lohnt sich die Aufregung. Wenn Sie nicht lange herumspielen möchten, nehmen Sie gute Layouts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Installieren Sie also den Z80. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenblatt entnehmen können</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ee/n6/i0/een6i0aw3zjgv2b4gah5oo9t2ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Prozessor verfügt über 40 Pins, die in Gruppen unterteilt sind: Adressbus, Datenbus, Systemsteuerung, Prozessorsteuerung, Prozessorbussteuerung, Well, Leistung und Takt. Nicht alle dieser Schlussfolgerungen werden in realen Systemen wie dem ZX-Spektrum verwendet, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie aus dem Diagramm ersichtlich ist.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Von der Gruppe "Prozessorsteuerung" im Spektrum werden nur INT- und RESET-Signale verwendet. Das Signal M1 wird nicht von der Gruppe "Systemsteuerung" verwendet, die Gruppe "Bussteuerung" wird überhaupt nicht verwendet. Dafür gibt es einen Grund. Die alten 8-Bit-Systeme waren sehr einfach, und das Spektrum wurde mit der Idee erstellt, so einfach wie möglich zu sein, und alles, was ignoriert werden konnte, wurde ignoriert. Natürlich konnten Peripheriegerätehersteller Interrupts (INT- und NMI-Signale) verwenden, sie wurden zum Erweiterungssteckplatz geleitet, aber NMI wurde im Spektrum selbst nicht verwendet. Wie aus dem obigen Diagramm ersichtlich ist, werden die NMI-, WAIT- und BUSREQ-Signale von Leistungswiderständen hochgezogen, da es sich um aktivierte Eingänge mit niedrigem Pegel handelt (dies wird durch den Balken über dem Signalnamen angezeigt), und es muss eine logische Einheit (d. H. + 5 V) vorhanden sein, damit Gott bewahre, dass das unnötige Signal nicht funktioniert hat. Und hier sind die Ergebnisse, BUSACK, HALT, M1,und in der Luft hängen, mit nichts verbunden. Beachten Sie übrigens, dass das Spektrum keine Reset-Taste enthält. Der Reset-Pin ist über verbunden</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RC-Kette</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur Stromversorgung (RESET wird auch durch einen niedrigen Pegel aktiviert), da laut Datenblatt nach dem Einschalten von RESET mindestens 3 Taktzyklen aktiv sein müssen, damit der Prozessor in den Betriebsmodus wechselt. Diese RC-Schaltung hält einen niedrigen Pegel, bis der Kondensator über einen Widerstand auf einen hohen Pegel geladen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns kurz auf den Rest der Signale </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eingehen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">M1.</font></b><font style="vertical-align: inherit;"> Brauchen wir nicht. Er berichtet, dass der Prozessor begonnen hat, die nächste Anweisung auszuführen. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MREQ.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich brauche es. Es wird gemeldet, dass der Prozessor auf den Speicher zugreift. Wenn dieses Signal niedrig wird (dh an die Strommasse angeschlossen ist), müssen wir den an den Prozessor angeschlossenen Speicher aktivieren. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOREQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ich brauche es. Es wird gemeldet, dass der Prozessor auf ein Peripheriegerät zugreift. Zum Beispiel zur Tastatur.</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ich brauche es. Informiert, dass der Prozessor Daten aus dem Speicher (wenn MREQ aktiv ist) oder Peripheriegeräten (IOREQ) liest. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ich brauche es. Meldet, dass der Prozessor Daten in Speicher / Peripheriegeräte schreibt. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFSH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ich brauche es. Im Allgemeinen wird dieses Signal für den dynamischen Speicher (DRAM) benötigt. Ich habe nicht vor, es zu verwenden, da seine Adressierung schwieriger ist (Matrix, nicht linear, dh es wird notwendig sein, einen Multiplexer zu installieren), und im Allgemeinen sind SRAM-Mikroschaltungen mit geringer Kapazität in unserer Zeit leichter zu bekommen. Da der Prozessor selbst DRAM durch Sortieren von Adressen auf dem Speicherbus regeneriert, können wir mit diesem Signal die Regenerationszyklen ignorieren und den Speicher nicht mit aktivem RFSH aktivieren. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HALT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nicht benötigt. Zeigt an, dass der Prozessor gestoppt ist. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WARTEN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nicht benötigt. Dieses Signal wird benötigt, um den Prozessor aufzufordern, anzuhalten und etwas zu warten. Wird normalerweise von langsamen Peripheriegeräten oder Speichern verwendet. Aber nicht im Spektrum. Wenn in den Spectrum-Peripheriegeräten (ULA) der Prozessor gestoppt wird, sendet er einfach kein Taktsignal mehr an ihn. Dies ist zuverlässiger, da der Prozessor nach dem Empfang von WAIT nicht sofort stoppt. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Unterbrechen. Es ist noch nicht klar. Wir gehen davon aus, dass es noch nicht benötigt wird. Dann werden wir es herausfinden. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das NMI</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Unmaskierbare Unterbrechung. Super Interrupt. Nicht nötig. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RESET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ohne es wird es nicht fliegen. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUSREQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nicht benötigt. Fordert den Prozessor auf, die Verbindung zu den Daten- / Adressbussen sowie den Steuersignalen zu trennen. Dies ist erforderlich, wenn ein Gerät die Kontrolle über den Bus erlangen möchte. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUSACK</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nicht benötigt. Dient dazu, das Gerät, das BUSREQ ausgeführt hat, darüber zu informieren, dass der Bus frei ist. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die UHR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Taktsignal. Klar, er wird gebraucht. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mahlzeiten werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auch benötigt. Ehre sei den Entwicklern, nur + 5V / GND. Keine 3 Belastungen für Sie. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A0-A15</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Adressbus. Darauf zeigt der Prozessor entweder eine Speicheradresse (MREQ ist aktiv) oder eine E / A-Portadresse (IOREQ ist aktiv) mit entsprechenden Aufrufen an. Wie Sie sehen können, ist der Bus 16 Bit breit, sodass Sie 64 KB Speicher direkt adressieren können. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D0-D7</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Datenbus. Der Prozessor gibt die angeforderten Daten an ihn aus (WR aktiv) oder liest daraus (RD aktiv). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also werden wir den Prozessor auf das Steckbrett legen. Seine Schlussfolgerungen sind also physisch lokalisiert:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dcb/b3f/2c4/dcbb3f2c401007d7aa3e1083e403f301.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließen Sie die Stromversorgung an (Pin 11 und 29). Für alle Fälle habe ich auch einen 10 pF Kondensator zwischen diese Beine gelegt. Aber er hat mir am Ende nicht geholfen. Die Pins 27, 23, 18 können mit nichts verbunden bleiben. Die Pins 26, 25, 24, 17, 16 sind über Widerstände (ich habe 10 kOhm verwendet) mit der Stromversorgung verbunden. Ich brachte den Adressbus (Pins 1-5 und 30-40) auf die gegenüberliegende Seite des Steckbretts und den Datenbus (Pins 7-10 und 12-15) auf einen separaten Datenbus, der aus Prototyp-Leistungsbussen besteht. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Pins 6 (Taktsignal) und 26 (RESET) sind (später) mit Arduin verbunden, damit Sie den Prozessor von dort aus steuern können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellte sich so heraus:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/in/rx/jminrxjfjixmm4pod6jhxw3kzfy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bis Sie auf die Drähte von oben achten, gehen sie aus dem ROM, wir werden etwas später darauf eingehen. Auf dem Foto neben dem Prozessor ist außerdem ein weiterer Chip sichtbar. Wir brauchen es, um die oberen Bits der Adresse zu dekodieren. Wie ich oben sagte, gibt es 3 Arten von Speicher im Spektrum. Die unteren 16 KiB des Adressraums sind ROM. Wenn sich die Klemmen A14 und A15 in einem niedrigen Zustand (0 Volt) befinden, müssen wir dementsprechend alles außer dem ROM-Chip vom Bus trennen. Als nächstes stehen 16 KB gemeinsamer Speicher zur Verfügung. Dementsprechend müssen wir diesen Speicher an den Bus anschließen (und den Rest trennen), wenn der Ausgang A15 niedrig und A14 hoch ist (+5 Volt). Nun, dann kommen 32 KiB schneller Speicher. Wir werden diesen Speicher später anhängen und ihn aktivieren, wenn sich der Ausgang A15 in einem hohen Zustand befindet. Vergessen Sie außerdem nicht, dass wir den Speicher nur aktivieren, wenn er aktiv ist (hier aktiv - niedrig,0 Volt) MREQ und inaktiv (hier inaktiv - hoch, + 5 V) RFSH. All dies ist recht einfach in Standardlogik zu implementieren, auf denselben NANDs wie 74HC00 oder orthodoxem K155LA3, und ich verstehe, dass diese Aufgabe für die Vorbereitungsgruppe des Kindergartens bestimmt ist, ich kann jedoch nur in Wahrheitstabellen in Freiheit und in Gefangenschaft denken</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe dort ein vollständiges Harlekin-Diagramm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aus dem Sie einfach den Teil entnehmen können, in dem U4 gezeichnet ist (74HC138, zum Glück habe ich ungefähr hundert davon). </font><font style="vertical-align: inherit;">Wir werden U11 aus Gründen der Klarheit ignorieren, da die oberen 32 KB für uns bisher nicht von Interesse sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Anschließen ist sehr einfach. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2h/my/p2/2hmyp2xuiiuejpixie4e1mnoo1w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie aus der </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">kurzen Beschreibung</font></a><font style="vertical-align: inherit;"> ersichtlich ist</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Mikroschaltung ist ein Decoder, der Binärzahlen von 000 bis 111 für Ausgänge vom 1. bis 3. empfängt und einen von 8 Ausgängen (Abschnitte 7 und 9 bis 15) aktiviert, die dieser Nummer entsprechen. </font><font style="vertical-align: inherit;">Da nur 8 verschiedene Nummern in 3 Bits gespeichert werden können, gibt es nur acht Ausgänge. </font><font style="vertical-align: inherit;">Wie Sie sehen können, sind die Schlussfolgerungen invertiert, dh derjenige, der aktiv ist, hat einen Pegel von 0 V und alle anderen + 5 V. </font><font style="vertical-align: inherit;">Zusätzlich ist ein Schlüssel in Form eines Gatters mit 3 Eingängen vom Typ "I" in den Chip eingebaut, und zwei seiner drei Eingänge sind ebenfalls invertiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall verbinden wir den Decoder selbst wie folgt: Das höchstwertige Bit (3. Zweig) mit dem Boden, es wird immer 0 sein. Das mittlere Bit ist die Leitung A15. Es gibt nur 1, wenn der Prozessor auf die oberen 32 KB Speicher zugreift (Adressen 0x8000 - 0xFFFF oder 1000000000000000 - 1111111111111111 in Binärform, wenn das höchstwertige Bit immer auf 1 gesetzt ist). Wir verbinden das niedrigstwertige Bit mit der A14-Leitung, wo der hohe Pegel für den Fall ist, dass entweder nach den ersten 16 KiB auf den Speicher zugegriffen wird, aber bis zu den obersten 32 KiB (Adressen 0x4000 - 0x7FFF oder 0100000000000000 - 0111111111111111 in binärer Form) oder mit den letzten 16 KiB der Adresse Leerzeichen (Adressen 0xB000 - 0xFFFF oder 1100000000000000 - 1111111111111111 in binärer Form). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie die Ausgabe in jedem der Fälle sein wird:</font></font><br>
<br>
<ul>
<li>  14  15    ,       16  ,    ,     000,  0    (    ),     Y0 (15 ).      ,      .</li>
<li>  14   ,   15 —  ,         16 ,   32 ,    001,  1   ,     Y1 (14 ).      ,  16 ,       .</li>
<li>  14   ,   15 —  ,     -  32   48 ,    010,     Y2 (13 ).      ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn beide Leitungen (A14 und A15) aktiv sind, greift der Prozessor auf die obersten 16 KB Speicher zu, von 48 bis 64 KB, wir haben sie nicht, sodass der Y3-Pin (12. Pin) ebenfalls in der Luft ist.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dank eines anderen Elements aktiviert die Mikroschaltung ihre Ergebnisse nur dann, wenn die Eingänge 4 und 5 niedrig und 6 hoch sind. </font><font style="vertical-align: inherit;">Der 4. Eingang befindet sich immer im niedrigen Zustand (er ist direkt mit Masse verbunden), der fünfte ist nur niedrig, wenn der Prozessor auf den Speicher zugreift (denken Sie daran, MREQ im niedrigen Zustand bedeutet Zugriff auf den Speicher), und der sechste ist hoch, wenn der Prozessor keinen Aktualisierungszyklus durchführt DRAM (wir haben SRAM, daher sind DRAM-Aktualisierungszyklen der sicherste Weg, sie einfach zu ignorieren). </font><font style="vertical-align: inherit;">Es stellt sich als großartig heraus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes setzen Sie das ROM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe den W27C512 genommen, weil er billig und gut gelaunt ist, alles passt und Sie auch Bankgeschäfte tätigen können. 64 KB! 4 Firmware kann hochgeladen werden. Nun, ich habe ungefähr eine Million dieser Mikroschaltungen. Ich entschied, dass ich nur die obere Hälfte nähen würde, da bei Harlequin das A15-Bein an + 5V gebunden ist und das A14 mit einem Jumper verstellbar ist. So kann ich die Firmware auf Harlequin testen, um nicht lange herumzuspielen. Smorim </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenblatt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wir legen den Chip auf das Steckbrett. Ich habe es wieder in die rechte Ecke gestellt, um den Adressbus links zu platzieren. Wir ziehen das Bein A15 an die Stromversorgung, die A14-Kabel an den Boden. Verkabelung - Auf diese Weise können Sie die Speicherbänke ändern. Da der A15 immer auf einem hohen Niveau sein wird, stehen uns nur die besten 32-KiB-Flash-Laufwerke zur Verfügung. Von diesen wählt die A14-Leitung die oberen (+ 5V) oder unteren (Masse) 16 KiB. In ihnen füllte ich das </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Testbild mit dem</font></a><font style="vertical-align: inherit;"> Programmierer</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">48K BASIC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Firmware </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die restlichen 14 Adressleitungen (A0 - A13) sind links mit dem Adressbus verbunden. Wir verbinden den Datenbus (Q0 - Q7) in Form von Leistungsbussen der Steckbrettmodelle mit unserem improvisierten Bus. Essen nicht vergessen!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun die Steuersignale. </font><font style="vertical-align: inherit;">OE ist eine Ausgangsfreigabe. </font><font style="vertical-align: inherit;">Wir benötigen das ROM, um Daten an den Datenbus zu senden, wenn der Prozessor sie liest. </font><font style="vertical-align: inherit;">Wir verbinden uns also direkt mit dem Ausgang des RD-Prozessors. </font><font style="vertical-align: inherit;">Praktischerweise sind beide Pins, sowohl OE auf ROM als auch RD auf dem Prozessor, in einem niedrigen Zustand aktiv. </font><font style="vertical-align: inherit;">Dies ist wichtig, Sie müssen nichts umkehren. </font><font style="vertical-align: inherit;">Zusätzlich hat der ROM einen CS-Eingang, der auch in einem niedrigen Zustand aktiv ist. </font><font style="vertical-align: inherit;">Wenn dieser Eingang nicht aktiv ist, ignoriert das ROM alle anderen Signale und gibt nichts an den Datenbus aus. </font><font style="vertical-align: inherit;">Wir werden diesen Eingang mit dem Y0-Pin (15-Pin) des 74HC138-Chips verbinden, der auch im niedrigen Zustand aktiv ist. </font><font style="vertical-align: inherit;">In der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harlekin-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schaltung ist </font><font style="vertical-align: inherit;">dieses Signal aus irgendeinem Grund über einen Widerstand verbunden. </font><font style="vertical-align: inherit;">Wir werden das Gleiche tun. </font><font style="vertical-align: inherit;">Ich weiß nicht warum. </font><font style="vertical-align: inherit;">Vielleicht sagen es mir kluge Leute in den Kommentaren ... </font><i><font style="vertical-align: inherit;">Sie haben es</font></i><font style="vertical-align: inherit;"> mir </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gesagt. </font><font style="vertical-align: inherit;">Danke,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sterr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:: </font></font><blockquote>  .       ,    «» .            .</blockquote></i><br>
<br>
<img src="https://habrastorage.org/webt/1k/n7/h3/1kn7h3nfgruh121jefz2qfhucts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt RAM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist schwieriger damit, da nicht nur der Prozessor, sondern auch ULA oder in unserem Fall Arduino mit RAM (mit unseren 16 KiB) arbeiten. Da ist es notwendig, etwas zu lesen, das auf dem Bildschirm angezeigt wird. Daher müssen wir in der Lage sein, Steuersignale und den RAM-Adressbus vom Prozessor zu trennen. Wir werden den Datenbus nicht trennen, wir werden wie im ursprünglichen Spektrum (und in Harlequin) handeln: Wir werden den Bus durch Widerstände (470-500 Ohm) teilen. Die Widerstände sind einerseits der Prozessor und das ROM, andererseits RAM und Arduino. Im Falle eines Konflikts auf dem Datenbus funktioniert er somit als zwei separate Busse. Im Übrigen verwenden wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">74HC245</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harlekin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (U43, U44 im Diagramm), obwohl im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorliegenden Speccy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gab auch Widerstände (zwischen IC1 einerseits ist dies ULA und IC3, IC4 andererseits). </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der 74HC245</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein 8-Bit- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Buspuffer</font></a><font style="vertical-align: inherit;"> . Wir haben jedoch 2 Steuersignale (RD - beim Lesen aus dem Speicher und CE zum Aktivieren des RAM selbst. Wir werden uns beim späteren Schreiben in den Speicher mit WR befassen) und 14 Bits der Adresse: Denken Sie daran, dass wir oben bereits ein Signal in den Speicher nur mit 74HC138 erzeugen Für den Fall, dass der Prozessor A14 mit inaktivem A15 aktiviert hat, sodass keine zusätzliche Dekodierung der Adresse erforderlich ist, funktioniert der Speicher nur, wenn auf die ersten 16 KB nach dem ROM zugegriffen wird. Um 16 KiB zu adressieren, benötigen Sie natürlich nur 14 Adressleitungen (A0-A13). Insgesamt werden 16 Signale erhalten, sodass wir 2 74HC245-Mikroschaltungen benötigen. Wir verbinden sie mit dem Steckbrett links anstelle des Adressbusses.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus dem Datenblatt des 74HC245 geht hervor, dass es im Allgemeinen keine Rolle spielt, auf welcher Seite die Mikroschaltungen angeschlossen werden sollen. Da ich jedoch mit dem Aufbau der Layouts von unten nach oben begonnen habe und alle anderen Mikroschaltungen mit dem ersten Pin links installiert sind, wird der Adressbus mit Seite A (Pins 2) verbunden -9 Chips sind im Datenblatt als A0-A7 bezeichnet. Die Übertragungsrichtung ist immer vom Prozessor zum RAM, da der RAM die Adresse nie festlegt, sondern nur empfängt. Beim 74HC245 ist Pin 1 (DIR) für die Übertragungsrichtung verantwortlich. Laut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenblatt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit auf der B-Seite ein Ausgang vorhanden ist, der dem Eingang auf der A-Seite entspricht, muss das DIR auf HIGH gesetzt werden. Verbinden Sie also den 1. Pin beider Stromkreise mit + 5V. OE (20. Pin, aktiviert durch einen niedrigen Pegel) wird über Kabel mit Masse verbunden, so dass es schnell auf +5 V umgeschaltet und vom Prozessor getrennt werden kann. Weiter einfacher. Schließen Sie die Stromversorgung für beide Chips an. Die am weitesten rechts liegenden Pins der rechten Mikroschaltung (8. und 9. Pins, Eingänge A6 und A7) sind Steuersignale. Ich habe A7 an den RD-Anschluss des Prozessors und A6 an den Y1-Pin des 74HC138-Chips angeschlossen, da nur dann ein niedriger Pegel auftritt, wenn der Prozessor auf unseren RAM zugreift. Die verbleibenden Schlussfolgerungen von Seite A beider Mikrokreise (Beine 2–9 für links und Beine 2–7 für rechts) habe ich an den Adressbus angeschlossen, Klemmen A13-A0. Die oberen 2 Bits der Adresse werden nicht benötigt, da sie bereits im Signal vom 74HC138 decodiert sind.Nun zum RAM selbst. Natürlich habe ich das verwendet, was ich bereits hatte: einen Cache-Chip vom alten Motherboard. Ich bin rübergekommen</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IS61C256</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bei 20 ns, aber jeder wird es tun. Speccy arbeitete mit einer Frequenz von 3,5 MHz, aber im Moment werden wir im Allgemeinen Arduinki behandeln. Wenn 100 kHz herauskommen, wird es Glück geben! Also verbinden wir uns. Vergessen Sie natürlich nicht das Essen. Schlussfolgerungen I / O0 - I / O7 werden NACH den Widerständen an das Steckbrett des Datenbusses angeschlossen. Ich hatte Glück (eigentlich nicht), bei meinen chinesischen Modellen sind die Powerbusse genau in der Mitte geteilt. Ich habe diese Funktion verwendet, um den Bus mit Widerständen zu trennen. Wenn Ihre Layouts falsch sind, müssen Sie </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pervers sein</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machen Sie einen zweiten Datenbus und verbinden Sie ihn mit Widerständen mit dem ersten. Die Schlussfolgerungen von A0-A13 werden auf die entsprechenden B-Schlussfolgerungen der 74HC245-Chips geworfen, wobei nicht zu vergessen ist, dass die am weitesten rechts stehenden nicht mit dem Datenbus, sondern mit den Steuersignalen verbunden sind. A14 - wahlweise entweder am Boden oder auf +5V. Ein 32-KiB-Chip, daher wird diese Schlussfolgerung bestimmen, welche Hälfte wir verwenden werden. Wenn Sie einen 16-KiB-SRAM finden, befindet sich keine A14-Leitung darin. Die Ausgänge sind WE (Schreibfreigabe), CE (Chipfreigabe) und OE (Ausgangsfreigabe). Alle sind niedrig aktiviert. OE muss mit dem RD des Prozessors verbunden sein, aber natürlich nicht direkt, sondern über den rechten 74HC245, wo der RD zu meinem A7-Fuß kommt und dementsprechend aus dem B7-Fuß (11. Pin) herauskommt. Dort und verbinden. CE muss vom 74HC138 an Y1 angeschlossen werden, wodurch die Adresse dekodiert wird. Ihr Signal kommt auf der A6 des rechten Chips 74HC245 zu mirkommt aus Fuß B6 (12 Stifte). WIR habe ich direkt an den Ausgang des WR-Prozessors angeschlossen. Ich habe auch ein Überbrückungskabel aus dem OE-Signal installiert und es einfach in den nicht verwendeten Teil des Steckbretts gesteckt. Durch Anschließen dieses Kabels an die Strommasse kann ich die Aktivierung des RAM erzwingen, wenn ich es von Arduinka lese. Trotzdem habe ich alle Steuersignale des RAM mit Widerständen von 10 kOhm auf + 5V gezogen. Nur für den Fall. Es stellte sich so heraus:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9y/0k/3h/9y0k3ht6ehvrsvzoehp70h428mo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen sollte hier und wenn überhaupt zu Beginn ein Schulungsprogramm zum Zeitpunkt der Signale auf den Reifen durchgeführt werden. Ich werde dies nicht tun, da es im Netzwerk schon oft von viel intelligenteren Leuten als mir gemacht wurde. Für Interessierte kann ich dieses Video empfehlen:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/i_wrxBdXTgM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie diesen Kanal nicht abonniert haben und sich als Amateur und nicht als Profi für Elektronik interessieren, kann ich es Ihnen generell nur empfehlen. Dies ist ein sehr hochwertiger Inhalt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen ist das fast alles. Jetzt müssen Sie nur noch verstehen, wie Sie Daten aus dem RAM in Arduino lesen. Lassen Sie uns zunächst berechnen, wie viele Arduinki-Schlussfolgerungen wir benötigen. Wir müssen ein Taktsignal geben und den RESET steuern, das sind 2 Pins. 8 Bit Datenbus - weitere 8 Pins. Plus 13 Adressbits, insgesamt 23 Pins. Außerdem müssen wir mit Arduinka kommunizieren, wir werden dies über ihre serielle Schnittstelle tun, dies sind weitere 2 Pins. Leider gibt es nur 20 Schlussfolgerungen zu meiner DNA.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, das spielt keine Rolle. Ich kenne keine einzige Person, die Arduino hat und keine 74HC595 hat. Es scheint mir, dass sie nur im Kit verkauft werden. Zumindest habe ich nur 74HC00 Chips mehr als 595x. Also benutzen wir sie. Darüber hinaus werde ich Raum in dem Artikel speichern, weil die Arbeit des 595x mit Arduino perfekt beschrieben wird </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. 595mi werden wir die Adresse generieren. Der Chip benötigt 2 Teile (da wir 13 Bits der Adresse haben und der 595. 8 Pins hat). Wie Sie mehrere 595x für die Buserweiterung anschließen, wird unter dem obigen Link ausführlich beschrieben. Ich stelle nur fest, dass in den Beispielen an diesem Link OE (Pin 13) 595x zu Boden gezogen wird. Wir werden dies kategorisch nicht tun, wir werden dort ein Signal von Arduinki senden, da die 595x-Pins direkt mit dem RAM-Adressbus verbunden werden und wir dort kein Störsignal benötigen. Nach dem Anschließen der 595x-Pins an den RAM-Adressbus muss an den Modellen nichts mehr getan werden. Zeit, die Arduinka anzuschließen. Aber schreiben Sie zuerst eine Skizze:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU defines</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CPU_CLOCK_PIN 2</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CPU_RESET_PIN 3</span><font></font>
<font></font>
<span class="hljs-comment">// RAM defines</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_OUTPUT_ENABLE_PIN 4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_WRITE_ENABLE_PIN 5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_CHIP_ENABLE_PIN 6</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_BUFFER_PIN 7</span><font></font>
<font></font>
<span class="hljs-comment">// Shift Register defines</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_DATA_PIN 8</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_OUTPUT_ENABLE_PIN 9</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_LATCH_PIN 10</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_CLOCK_PIN 11</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// All CPU and RAM control signals need to be configured as inputs by default</span>
  <span class="hljs-comment">// and only changed to outputs when used.</span>
  <span class="hljs-comment">// Shift register control signals may be preconfigured</span><font></font>
<font></font>
  <span class="hljs-comment">// CPU controls seetup</span><font></font>
  DDRC = B00000000;<font></font>
  pinMode(CPU_CLOCK_PIN, INPUT);<font></font>
  pinMode(CPU_RESET_PIN, INPUT);<font></font>
<font></font>
  <span class="hljs-comment">// RAM setup</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_BUFFER_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_BUFFER_PIN, LOW);<font></font>
<font></font>
  <span class="hljs-comment">// SR setup</span><font></font>
  pinMode(SR_LATCH_PIN, OUTPUT);<font></font>
  pinMode(SR_CLOCK_PIN, OUTPUT);<font></font>
  pinMode(SR_DATA_PIN, OUTPUT);<font></font>
  pinMode(SR_OUTPUT_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
<font></font>
  <span class="hljs-comment">// common setup</span>
  Serial.begin(<span class="hljs-number">9600</span>);<font></font>
  Serial.println(<span class="hljs-string">"Hello"</span>);<font></font>
}<span class="hljs-comment">// setup</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shiftReadValueFromAddress</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> address, <span class="hljs-keyword">uint8_t</span> *value)</span> </span>{
  <span class="hljs-comment">// disable RAM output</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_WRITE_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span>
  <span class="hljs-comment">// set address</span><font></font>
  digitalWrite(SR_LATCH_PIN, LOW);<font></font>
  shiftOut(SR_DATA_PIN, SR_CLOCK_PIN, MSBFIRST, address&gt;&gt;<span class="hljs-number">8</span>); <font></font>
  shiftOut(SR_DATA_PIN, SR_CLOCK_PIN, MSBFIRST, address);  <font></font>
  digitalWrite(SR_LATCH_PIN, HIGH);<font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, LOW); <span class="hljs-comment">// active low</span>
  <span class="hljs-comment">// write value to RAM</span>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, LOW); <span class="hljs-comment">// active low</span>
  delay(<span class="hljs-number">1</span>);<font></font>
  DDRC = B00000000;<font></font>
  *value = PINC;<font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span>
  <span class="hljs-comment">// disable SR</span>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
}<span class="hljs-comment">// shiftWriteValueToAddress</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">runClock</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> cycles)</span> </span>{
  <span class="hljs-keyword">uint32_t</span> currCycle = <span class="hljs-number">0</span>;<font></font>
  pinMode(CPU_CLOCK_PIN, OUTPUT);<font></font>
  <span class="hljs-keyword">while</span>(currCycle &lt; cycles) {<font></font>
    digitalWrite(CPU_CLOCK_PIN, HIGH);<font></font>
    digitalWrite(CPU_CLOCK_PIN, LOW);<font></font>
    currCycle++;<font></font>
  }<font></font>
  pinMode(CPU_CLOCK_PIN, INPUT);<font></font>
}<span class="hljs-comment">// runClock</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trySpectrum</span><span class="hljs-params">()</span> </span>{<font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
  pinMode(CPU_RESET_PIN, OUTPUT);<font></font>
  digitalWrite(CPU_RESET_PIN, LOW);<font></font>
  runClock(<span class="hljs-number">30</span>);<font></font>
  digitalWrite(CPU_RESET_PIN, HIGH);<font></font>
  runClock(<span class="hljs-number">12500000</span>);<font></font>
}<span class="hljs-comment">// trySpectrum</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">readDisplayLines</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">uint8_t</span> value;<font></font>
  digitalWrite(RAM_BUFFER_PIN, HIGH);<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_CHIP_ENABLE_PIN, LOW);<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">uint16_t</span> i=<span class="hljs-number">16384</span>; i&lt;<span class="hljs-number">16384</span>+<span class="hljs-number">6144</span>;i++) {<font></font>
    shiftReadValueFromAddress(i, &amp;value);<font></font>
    Serial.println(value);<font></font>
  }<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, INPUT);<font></font>
}<span class="hljs-comment">// readDisplayLines</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{<font></font>
  trySpectrum();<font></font>
  Serial.println(<span class="hljs-string">"Hope we are ok now. Please set up memory for reading"</span>);<font></font>
  delay(<span class="hljs-number">40000</span>);<font></font>
  Serial.println(<span class="hljs-string">"Reading memory"</span>);<font></font>
  readDisplayLines();<font></font>
  Serial.println(<span class="hljs-string">"Done"</span>);<font></font>
  delay(<span class="hljs-number">100000</span>);<font></font>
}<span class="hljs-comment">// loop</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie der Skizze entnehmen können (nun, wirklich, plötzlich hat es jemand gelesen), habe ich den Datenbus zu Port C gelesen. Wie Arduischik sich erinnern kann, hat Port C in CID 6 Pins. Das heißt, ich lese nur 6 Bits. Ja, der Einfachheit halber ignoriere ich die 2 hohen Bits in jedem Byte des Bildschirmpuffers. Dies führt dazu, dass alle 2 Pixel nach 6 immer Hintergrundfarben angezeigt werden. Während einer Fahrt, dann reparieren Sie es. Das ist das Skelett. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun zur Verbindung selbst. Im Prinzip wird alles ganz oben auf die Skizze gemalt:</font></font><br>
<br>
<pre><code class="plaintext hljs">// CPU defines<font></font>
#define CPU_CLOCK_PIN 2 -  2     6  ( )<font></font>
#define CPU_RESET_PIN 3 -  3     26  (RESET)<font></font>
<font></font>
// RAM defines<font></font>
#define RAM_OUTPUT_ENABLE_PIN 4 -  4     22  (OE)<font></font>
#define RAM_WRITE_ENABLE_PIN 5 -  5    .     .<font></font>
#define RAM_CHIP_ENABLE_PIN 6 -  6     .        ,        .   - ,   -  .   ,   .<font></font>
#define RAM_BUFFER_PIN 7 -  ,    6,    .<font></font>
<font></font>
// Shift Register defines<font></font>
#define SR_DATA_PIN 8   -  8     14 "" 595.        9 ,     .<font></font>
#define SR_OUTPUT_ENABLE_PIN 9 -   13  595<font></font>
#define SR_LATCH_PIN 10 -   12  595<font></font>
#define SR_CLOCK_PIN 11 -   11  595.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles ist einfach. So sieht es aus, als wäre ich alle zusammengebaut (das Arduino wurde im Bild geschnitten, aber es gibt nichts Besonderes zu sehen): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pj/q5/si/pjq5siebaxafimb_nqnjxyry6_u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Start sagt Arduino fröhlich Hallo zur seriellen Schnittstelle des Computers (wenn auch virtuell) und beginnt, den Prozessor zu quälen. Nachdem Sie ihn gründlich gefoltert haben (ein paar Minuten), stoppt das Programm den armen Kerl und bietet Ihnen an, die Jumper mit den Stiften auf dem Steckbrett neu anzuordnen und den Speicher von den Adressbus- und Prozessorsteuersignalen zu trennen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen wir die Griffe verwenden, um die an den Pins 19 des 74HC245 angeschlossenen Kabel von Masse auf +5 V umzustellen. Daher trennen wir den Prozessor vom RAM. Pin 22 des RAM-Chips selbst muss mit Masse verbunden sein (ich habe oben über die Verkabelung geschrieben, die ich bisher an einer unbenutzten Stelle in das Steckbrett gesteckt habe). Daher schalten wir den RAM gewaltsam ein.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Arduinka ein wenig gewartet hat, beginnt er, den Inhalt des Speichers zu lesen und ihn in einer Spalte an die serielle Schnittstelle auszugeben. Es wird viele, viele Zahlen geben. Jetzt können Sie diese Daten von dort kopieren und beispielsweise in eine Textdatei einfügen, ohne zu vergessen, den gesamten unnötigen Text zu bereinigen (ein paar Zeilen oben und "Fertig" unten). Wir benötigen nur Zahlen. Dies ist, was unser Speccy im Videospeicher aufgezeichnet hat. Es bleibt nur zu sehen, was sich im Videospeicher befand. Und der Videospeicher des Spektrums ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht einfach</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, werden die Pixel selbst getrennt von der Farbe gespeichert. Wir werden die Farbe vorerst ignorieren, lassen Sie uns nur die Pixel selbst lesen. Aber sie sind nicht so einfach zu dekodieren. Nach vielen Schmerzen in Visual Studio kam ich zu dieser eleganten Lösung:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND, UINT, WPARAM, LPARAM)</span></span>;
<span class="hljs-keyword">uint8_t</span> *scrData;<font></font>
<font></font>
<span class="hljs-function">VOID <span class="hljs-title">OnPaint</span><span class="hljs-params">(HDC hdc)</span> </span>{
	<span class="hljs-keyword">size_t</span> arrSize = <span class="hljs-number">6144</span>;<span class="hljs-comment">//sizeof(scrData) / sizeof(scrData[0]);</span>
	<span class="hljs-comment">//int currRow = 0, currX = 0, currBlock = 0, currY = 0, currBase = 0;</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> arrPos = <span class="hljs-number">0</span>; arrPos &lt; arrSize; arrPos++) {
		<span class="hljs-keyword">int</span> blockPos = arrPos % <span class="hljs-number">2048</span>;
		<span class="hljs-keyword">int</span> currBase = (blockPos % <span class="hljs-number">256</span>) / <span class="hljs-number">32</span>;
		<span class="hljs-keyword">int</span> currX = blockPos % <span class="hljs-number">32</span>;
		<span class="hljs-keyword">int</span> currBlock = arrPos / <span class="hljs-number">2048</span>;
		<span class="hljs-keyword">int</span> currRow = blockPos / <span class="hljs-number">256</span>;
		<span class="hljs-keyword">int</span> currY = currBlock * <span class="hljs-number">64</span> + currBase * <span class="hljs-number">8</span> + currRow;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> trueX = <span class="hljs-number">0</span>; trueX &lt; <span class="hljs-number">8</span>; trueX++) {
			<span class="hljs-keyword">char</span> r = ((scrData[arrPos] &gt;&gt; trueX) &amp; <span class="hljs-number">1</span>)*<span class="hljs-number">255</span>;<font></font>
			SetPixel(hdc, currX * <span class="hljs-number">8</span> + (<span class="hljs-number">8</span>-trueX), currY, RGB(r, r, r));<font></font>
		}<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span> </span>{<font></font>
	FILE *file;<font></font>
	<span class="hljs-keyword">errno_t</span> err;
	<span class="hljs-keyword">if</span> ((err = fopen_s(&amp;file, <span class="hljs-string">"data.txt"</span>, <span class="hljs-string">"r"</span>))) {<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, <span class="hljs-string">L"Unable to oopen the file"</span>, <span class="hljs-string">L"Error"</span>, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
	scrData = (<span class="hljs-keyword">uint8_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">6144</span>);
	<span class="hljs-keyword">int</span> currDataPos = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">char</span> buffer[<span class="hljs-number">256</span>];
	<span class="hljs-keyword">char</span> currChar = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span> currLinePos = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span> (currChar != EOF) {<font></font>
		currChar = getc(file);<font></font>
		buffer[currLinePos++] = currChar;<font></font>
		<span class="hljs-keyword">if</span> (currChar == <span class="hljs-string">'\n'</span>) {<font></font>
			buffer[currLinePos] = <span class="hljs-number">0</span>;<font></font>
			scrData[currDataPos++] = (<span class="hljs-keyword">uint8_t</span>)atoi(buffer);<font></font>
			currLinePos = <span class="hljs-number">0</span>;<font></font>
		}<font></font>
	}<font></font>
	fclose(file);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">INT WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE, PSTR, INT iCmdShow)</span> </span>{<font></font>
	HWND                hWnd;<font></font>
	MSG                 msg;<font></font>
	WNDCLASS            wndClass;<font></font>
	wndClass.style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wndClass.lpfnWndProc = WndProc;<font></font>
	wndClass.cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wndClass.cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wndClass.hInstance = hInstance;<font></font>
	wndClass.hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wndClass.hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wndClass.lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wndClass.lpszClassName = TEXT(<span class="hljs-string">"GettingStarted"</span>);<font></font>
	RegisterClass(&amp;wndClass);<font></font>
	hWnd = CreateWindow(<font></font>
		TEXT(<span class="hljs-string">"GettingStarted"</span>),   <span class="hljs-comment">// window class name</span>
		TEXT(<span class="hljs-string">"Getting Started"</span>),  <span class="hljs-comment">// window caption</span>
		WS_OVERLAPPEDWINDOW,      <span class="hljs-comment">// window style</span>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial x position</span>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial y position</span>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial x size</span>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial y size</span>
		<span class="hljs-literal">NULL</span>,                     <span class="hljs-comment">// parent window handle</span>
		<span class="hljs-literal">NULL</span>,                     <span class="hljs-comment">// window menu handle</span>
		hInstance,                <span class="hljs-comment">// program instance handle</span>
		<span class="hljs-literal">NULL</span>);                    <span class="hljs-comment">// creation parameters</span><font></font>
	loadData();<font></font>
	ShowWindow(hWnd, iCmdShow);<font></font>
	UpdateWindow(hWnd);<font></font>
	<span class="hljs-keyword">while</span> (GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) {<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> msg.wParam;<font></font>
}  <span class="hljs-comment">// WinMain</span><font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>{<font></font>
	HDC          hdc;<font></font>
	PAINTSTRUCT  ps;<font></font>
	<span class="hljs-keyword">switch</span> (message) {
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hdc = BeginPaint(hWnd, &amp;ps);<font></font>
		OnPaint(hdc);<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);<font></font>
	}<font></font>
} <span class="hljs-comment">// WndProc</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Programm öffnet die Datei data.txt aus seinem Verzeichnis. </font><font style="vertical-align: inherit;">In dieser Datei die Textausgabe des Arduino (nach dem Löschen aller zusätzlichen Zeilen, wie oben erwähnt). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir geben ihm die resultierende Datei und als Ergebnis: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tv/ai/3f/tvai3fcvvg-y53dlrcxogjo9o-c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja, das Ergebnis ist zwar </font><font style="vertical-align: inherit;">alles andere als </font><font style="vertical-align: inherit;">ideal, aber es ist definitiv die Ausgabe auf dem Bildschirm. </font><font style="vertical-align: inherit;">Darüber hinaus diejenige, die benötigt wird. </font><font style="vertical-align: inherit;">Aus dem ROM mit Diagnose-Firmware. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, das Computerskelett ist fertig. </font><font style="vertical-align: inherit;">Ja, es ist noch nicht möglich, es zu verwenden, aber Sie können sehen, wie einfach die alten 8-Bit-Computer angeordnet waren. </font><font style="vertical-align: inherit;">Ich habe immer noch ein wenig über das Steckbrett geschlagen, aber das Fazit wurde nur noch schlimmer. </font><font style="vertical-align: inherit;">Es scheint, dass der nächste Schritt darin besteht, ein normales, nicht gelötetes Steckbrett mit normaler Leistung anzulöten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber ist es notwendig?</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de498208/index.html">Sicherheitswoche 17: Auswirkungen des Linux Server-Angriffs</a></li>
<li><a href="../de498214/index.html">Maria Popova: „Einige haben OpenStreetMap zum ersten Mal kennengelernt, weil sie Hogweed auf der Karte markiert haben.“</a></li>
<li><a href="../de498216/index.html">Färben von Texten in HTML und Reagieren</a></li>
<li><a href="../de498218/index.html">Als ich Musik aus kosmischen Strahlen schrieb</a></li>
<li><a href="../de498220/index.html">Как коронавирус (COVID-XX) может помочь 1С захватить мир?</a></li>
<li><a href="../de498224/index.html">Erstellen Sie eine interaktive Ausstellung mit .NET, Azure-Funktionen und der Magie kognitiver Dienste</a></li>
<li><a href="../de498226/index.html">Zersetzung. So zerlegen Sie ein großes Projekt für eine vorläufige Bewertung in verständliche Segmente</a></li>
<li><a href="../de498234/index.html">Echte Management-Mythen über DevOps</a></li>
<li><a href="../de498238/index.html">Elektrisch leitfähiges Polymer: Wie Wissenschaftler Kunststoff aus Metall herstellten</a></li>
<li><a href="../de498242/index.html">Verwenden von Speicher in Medieninhalten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>