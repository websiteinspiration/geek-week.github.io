<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§î üç° ‚èèÔ∏è Uso de la biblioteca OpenCV para reconocer arcos el√≠pticos en secciones 2D de nubes de puntos 3D üë©üèø‚Äçü§ù‚Äçüë©üèª üë©üèΩ‚Äçüåæ ‚õ¥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En relaci√≥n con la difusi√≥n m√°s amplia de esc√°neres l√°ser asequibles (lidares) capaces de recibir nubes de puntos 3D ( 3dOT ) y la aplicaci√≥n m√°s ampl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Uso de la biblioteca OpenCV para reconocer arcos el√≠pticos en secciones 2D de nubes de puntos 3D</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490400/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En relaci√≥n con la difusi√≥n m√°s amplia de esc√°neres l√°ser asequibles (lidares) capaces de recibir nubes de puntos 3D ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) y la aplicaci√≥n m√°s amplia de esta tecnolog√≠a en varios campos (desde ingenier√≠a hasta seguridad, desde la industria petrolera hasta la arquitectura), el inter√©s en los algoritmos de procesamiento ha revivido Nubes de puntos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una de las aplicaciones populares de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3d</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la industria es la creaci√≥n de documentaci√≥n de dise√±o solo para equipos construidos, viejos o convertidos, que generalmente consisten en tuber√≠as y otras estructuras de geometr√≠a cil√≠ndrica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para detectar primitivas geom√©tricas en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , generalmente se utilizan bibliotecas 3D especializadas, por ejemplo, </font><em><font style="vertical-align: inherit;">Microsoft PCL</font></em><font style="vertical-align: inherit;"> .</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. El enfoque con el uso de bibliotecas listas para usar, junto con las ventajas, tiene desventajas. Por ejemplo, es dif√≠cil incorporarlos en los esquemas de procesamiento de Kadov existentes, que generalmente tienen una dimensi√≥n 2D. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consideremos c√≥mo ser√≠a posible procesar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por ejemplo, una estaci√≥n de bombeo, comenzando con secciones 2D y utilizando todo el arsenal de procesamiento 2D, que est√° disponible en bibliotecas de procesamiento de im√°genes confiables y optimizadas, por ejemplo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c2/bu/-i/c2bu-isuyb45ji2pz_6nibzg8zi.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 1. Modelo 3D OT de una estaci√≥n de bombeo</font></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El elemento principal de las secciones obtenidas al escanear varias estructuras de tuber√≠as son los </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arcos el√≠pticos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8w/zl/2h/8wzl2hcgbhlmexqxdvl6ezottgm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 2. Secci√≥n transversal horizontal de un modelo 3D de una estaci√≥n de bombeo a un nivel promedio.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Para este art√≠culo, restringimos nuestra consideraci√≥n a un algoritmo clave que nos permite detectar arcos el√≠pticos arbitrarios: este es un algoritmo iterativo para el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crecimiento de segmentos de arco y uni√≥n de </font></font></i><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regi√≥n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><em><font style="vertical-align: inherit;">crecimiento de regi√≥n y enlace de borde</font></em><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los algoritmos de crecimiento son los m√°s obvios y f√°cilmente verificables, aunque consumen mucho tiempo en comparaci√≥n con los algoritmos estad√≠sticos, que son m√°s adecuados para el caso cuando la escena contiene objetos distantes y poco acoplados que pertenecen a una elipse. </font><font style="vertical-align: inherit;">Estos algoritmos se discutir√°n en futuros art√≠culos.</font></font><br>
<br>
</p><h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ahora, por simplicidad, omitimos el procedimiento para obtener una secci√≥n del archivo fuente </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3DOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , preprocesando una secci√≥n, agrup√°ndola para aislar primitivas geom√©tricas, as√≠ como la posterior uni√≥n, rectificaci√≥n y otras operaciones fotogram√©tricas necesarias para obtener los par√°metros del modelo. No discutiremos la parametrizaci√≥n de algoritmos de b√∫squeda heur√≠stica de la misma manera. Describamos todas las </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operaciones b√°sicas a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> partir de las cuales se construye el algoritmo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponemos que necesitamos detectar (reconocer, clasificar) un arco el√≠ptico (es decir, calcular los par√°metros de la elipse, as√≠ como el √°ngulo inicial y final del arco el√≠ptico) en esta imagen, recortada de la secci√≥n horizontal de la nube de puntos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/rj/km/corjkmmhyxcxvrnex89_iex1aei.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 3. Uno de los arcos el√≠pticos de la secci√≥n transversal del modelo 3D (despu√©s del suavizado)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para minimizar el trabajo con el r√°ster a ciegas, realizaremos todas las operaciones con el r√°ster a trav√©s del </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contorno</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> procedimiento </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findContours de </font></font></em><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">OpenCV</font></em><font style="vertical-align: inherit;"> encuentra en el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tapete</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> r√°ster </font><font style="vertical-align: inherit;">todos los </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contornos</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> externos (sin formas internas) </font><font style="vertical-align: inherit;">en forma de un vector de vectores de puntos enteros (en coordenadas r√°ster):</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">Mat <span class="hljs-title">mat</span><span class="hljs-params">(size)</span></span>;
 <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;Point&gt;&gt; contours;<font></font>
 findContours(mat, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es nuestra operaci√≥n clave, que en algunos casos simples </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resuelve completamente la tarea</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pero como no siempre se encuentran casos degenerados, consideremos con m√°s detalle la tecnolog√≠a de procesamiento mediante contorneado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La operaci√≥n inversa, que genera un r√°ster de acuerdo con el circuito externo existente utilizando la </font><font style="vertical-align: inherit;">funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tambi√©n parece simple:</font></font><br>
<pre><code class="cpp hljs"> drawContours(mat, contours, <span class="hljs-number">-1</span>, Scalar(<span class="hljs-number">255</span>), <span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n se usa con mucha frecuencia para enmascarar contornos, dibujar o calcular √°reas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, en la etapa inicial, tenemos un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conjunto de parches</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (piezas de cierta curva) que deben conectarse a un arco el√≠ptico, eliminando partes de otros componentes de la estructura (por ejemplo, sujetadores) o ruido √≥ptico causado por el sombreado durante el escaneo y otros razones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creemos una </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funci√≥n discriminante</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que devolver√° el tipo de contorno (elipse, segmento lineal, sombreado u otra cosa), as√≠ como los puntos finales del contorno y su rect√°ngulo de contorno girado:</font></font><br>
<pre><code class="cpp hljs"> contourTypeSearch(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, Vec4i &amp;def, RotatedRect &amp;rc);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La relaci√≥n entre la longitud y el ancho del rect√°ngulo ayuda a discriminar r√°pidamente los contornos cercanos a los </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segmentos lineales</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as√≠ como a los peque√±os </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contornos de ruido</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El rect√°ngulo girado en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiene un </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">complejo</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sistema de coordenadas. Si no se requiere el √°ngulo en s√≠, sino sus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funciones trigonom√©tricas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , es mucho menos obvio desde el contexto. Si </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se usa</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> el </font><i><font style="vertical-align: inherit;">valor absoluto del √°ngulo</font></i><font style="vertical-align: inherit;"> , debe </font><font style="vertical-align: inherit;">tenerse </font><font style="vertical-align: inherit;">en cuenta que el </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√°ngulo se cuenta desde el horizontal hasta el primer borde del rect√°ngulo en sentido antihorario y tiene un valor negativo</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los puntos finales de los</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contornos el√≠pticos se encuentran utilizando nuestro procedimiento, que recibe el r√°ster </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mate</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con un contorno discriminado extra√≠do de la imagen original enmascarando y devuelve el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defecto m√°ximo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<pre><code class="cpp hljs"> contourConvFeature(mat, &amp;def, ‚Ä¶ );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El c√≥digo principal para esta funci√≥n es llamar a dos procedimientos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; *hull = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<font></font>
 convexHull(contour, *hull);<font></font>
 <span class="hljs-built_in">vector</span>&lt;Vec4i&gt; *defs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;Vec4i&gt;();<font></font>
 convexityDefects(contour, *hull, *defs);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primer procedimiento encuentra un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pol√≠gono convexo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para el contorno en estudio, el segundo calcula todos los </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defectos de convexidad</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tomamos solo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> defecto </font><i><font style="vertical-align: inherit;">m√°s grande</font></i><font style="vertical-align: inherit;"> en t√©rminos de convexidad, considerando que determina los puntos finales del contorno. Este puede no ser el caso si los l√≠mites externos o internos del contorno tienen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caracter√≠sticas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suavizarlos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aplicamos suavizado adicional al contorno en estudio (y no a toda la imagen para no "desenfocar" los istmos entre los contornos y no violar la topolog√≠a original). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/e2/tl/cbe2tlqhmia2hyb727mcspjsb5w.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 4. C√°lculo del defecto de abultamiento La </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opci√≥n (a)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> define err√≥neamente el punto final rojo. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opci√≥n (b)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define correctamente los puntos finales. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La opci√≥n (c)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redefine los puntos finales en la forma original. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como en la tecnolog√≠a que adoptamos, el circuito se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regenera</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cada vez </font><font style="vertical-align: inherit;">, tenemos que volver a buscar los puntos de correspondencia (o m√°s bien, sus √≠ndices) mediante el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exhaustivo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> procedimiento de </font><i><font style="vertical-align: inherit;">b√∫squeda</font></i><font style="vertical-align: inherit;"> :</font></font><br>
<pre><code class="cpp hljs"> nearestContourPtIdx(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, <span class="hljs-keyword">const</span> Point&amp; pt);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para los casos en que no es posible deshacerse por completo de las caracter√≠sticas, tambi√©n se implement√≥ un modo adicional de </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separaci√≥n</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><u><font style="vertical-align: inherit;">arco</font></u><font style="vertical-align: inherit;"> (trabajar por separado con el arco interno / externo). Esto es importante, por ejemplo, en casos donde el arco externo del contorno est√° en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contacto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con otros objetos o es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruidoso</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En este caso, puede ir a trabajar con el arco interno. En este caso, no es necesario procesar los arcos externos e internos por separado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, de acuerdo con la f√≥rmula bien conocida para la relaci√≥n de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convexidad del arco</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">radio del</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c√≠rculo </font><font style="vertical-align: inherit;">se estima aproximadamente </font><font style="vertical-align: inherit;">y se rechazan las elipses demasiado grandes:</font></font><br>
<pre><code class="matlab hljs">R = bulge / <span class="hljs-number">2</span> + SQR(<span class="hljs-built_in">hypot</span>) / (<span class="hljs-number">8</span> * bulge);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, para todos los contornos, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> encontr√≥ su </font><i><font style="vertical-align: inherit;">m√©trica de defecto de convexidad</font></i><font style="vertical-align: inherit;"> (o se clasifican como lineales o peque√±os y se eliminan del procedimiento). </font><font style="vertical-align: inherit;">En la √∫ltima etapa, se agregan par√°metros adicionales a la m√©trica original, como el par√°metro de dimensi√≥n girada, etc., y el conjunto completo de m√©tricas en estudio se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordena por tama√±o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-keyword">int</span> , <span class="hljs-comment">// </span>
   RotatedRect, <span class="hljs-comment">//  </span>
   Vec4i, <span class="hljs-comment">//  </span>
   <span class="hljs-keyword">int</span>&gt; <span class="hljs-comment">// </span>
   RectDefMetric;</code></pre><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritmo para vincular segmentos de arco en puntos finales</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El algoritmo de crecimiento es claro y obvio: tomamos el contorno m√°s grande como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semilla</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y tratamos de cultivarlo, es decir, encontrar y adjuntar los parches m√°s cercanos a sus puntos finales que satisfagan las condiciones de crecimiento. En la figura adulta, ingresamos el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arco el√≠ptico deseado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Enmascarar y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">restar la</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> figura del conjunto original. Repetimos el procedimiento de crecimiento </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasta que se agote el conjunto inicial</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El procedimiento b√°sico del algoritmo de crecimiento se ve as√≠:</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;Point&gt; *patch =<font></font>
    growingContours(contour, def, tmp, hull);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
donde </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contorno</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el contorno en estudio, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es su defecto de convexidad, el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">casco</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el pol√≠gono convexo de toda la regi√≥n, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es la matriz auxiliar de amortiguaci√≥n. En la salida, obtenemos un contorno de crecimiento vectorial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El procedimiento consiste en un ciclo de intentos de crecimiento de la semilla, que termina agotando los parches disponibles para el crecimiento o limitado por el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√°metro del n√∫mero m√°ximo de iteraciones</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tp/se/p1/tpsep1tdzgtvitxcnptg9rxu4m0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 5. Muchos parches para el crecimiento sin semilla La</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
principal dificultad es seleccionar los </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parches m√°s cercanos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a los puntos finales del contorno, de modo que la figura crezca solo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hacia adelante</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direcci√≥n tangencial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tomamos la l√≠nea promediada que pertenece al arco en la vecindad del punto final. En la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 6, se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muestran los candidatos para la conexi√≥n a la semilla en una determinada iteraci√≥n. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5g/8x/ij/5g8xijwx2owywp4kgjielcgoft8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 6. Semilla rodeada por una pluralidad de parches candidatos de crecimiento.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Para cada parche candidato, se calcula la siguiente m√©trica:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> tuple&lt;
   <span class="hljs-keyword">double</span>, <span class="hljs-comment">//    2      2   </span>
   <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">bool</span>, <span class="hljs-comment">//,  4   </span>
   <span class="hljs-keyword">int</span>, <span class="hljs-comment">// </span>
   Vec4i&gt; <span class="hljs-comment">//  </span>
   DistMetric;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tienen en cuenta los parches que caen en el </font><i><font style="vertical-align: inherit;">cono tangencial</font></i><font style="vertical-align: inherit;"> . Luego, se selecciona el parche con la distancia m√°s peque√±a y, al imprimir la secci√≥n de conexi√≥n en la trama, se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conecta</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al extremo correspondiente de la semilla. Para el otro extremo de la semilla, se busca un parche que coincida con los par√°metros y, si se encuentra, tambi√©n se conecta a la semilla. Luego, la semilla se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enmascara y se resta</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de los muchos parches. El procedimiento se repite desde el principio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final del procedimiento de crecimiento, obtuvimos un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arco el√≠ptico</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que a√∫n no se ha verificado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comenzar, usando el est√°ndar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El procedimiento que recibe nuestro parche (en forma de una ruta, recordamos que la ruta y el r√°ster son intercambiables con nosotros) y devuelve la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dimensi√≥n rotada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , es decir, una elipse completa.</font></font><br>
<pre><code class="cpp hljs"> RotatedRect box = fitEllipse(patch);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, rechazamos las elipses demasiado grandes y demasiado peque√±as, y luego aplicamos nuestro procedimiento original para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comparar las √°reas del</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arco el√≠ptico resultante y el parche de crecimiento inicial en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forma de trama</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Este procedimiento incluye algunos trucos disfrazados, por lo que omitiremos su descripci√≥n por ahora. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y finalmente, encontramos los par√°metros restantes de la elipse detectada: los </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√°ngulos de inicio y finalizaci√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ya conocemos los semiejes de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fitEllipse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para determinar los √°ngulos inicial y final, procedemos de la siguiente manera: transformamos nuestra elipse completa, de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vuelta al pol√≠gono,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y por enumeraci√≥n directa encontramos sus puntos m√°s cercanos a nuestros extremos. Sus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coordenadas angulares</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(de hecho, √≠ndices) y ser√°n los √°ngulos inicial y final de un arco el√≠ptico. </font><font style="vertical-align: inherit;">En el c√≥digo, se ve as√≠ (un poco simplificado):</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;
   <span class="hljs-title">ellipseAngles</span><span class="hljs-params">(<span class="hljs-keyword">const</span> RotatedRect &amp;box,
   <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell, <span class="hljs-keyword">const</span> Point &amp;ps, 
   <span class="hljs-keyword">const</span> Point &amp;pe, <span class="hljs-keyword">const</span> Point &amp;pm)</span> 
 </span>{
    <span class="hljs-built_in">vector</span>&lt;Point&gt; ell0;<font></font>
    ellipse2Poly(Point(box.center.x, box.center.y), <font></font>
      Size(box.size.width / <span class="hljs-number">2</span>, box.size.height / <span class="hljs-number">2</span>),<font></font>
      box.angle, <span class="hljs-number">0</span>, <span class="hljs-number">355</span>, <span class="hljs-number">5</span>, ell0);
    <span class="hljs-keyword">int</span> i0 = nearestContourPtIdx(ell0, ps);
    <span class="hljs-keyword">int</span> i1 = nearestContourPtIdx(ell0, pe);<font></font>
    cutSides(ell0, i0, i1, i2, ell, <span class="hljs-literal">nullptr</span>);
    <span class="hljs-keyword">return</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(i0, i1);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro procedimiento </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cutSides tiene</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en cuenta la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">topolog√≠a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> transversal del arco el√≠ptico. </font><font style="vertical-align: inherit;">En total, deben considerarse ocho posibles casos de omisi√≥n de los √≠ndices </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i0, i1, i2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">¬øSeguimos el contorno exterior o el interior, y cu√°l de los √≠ndices es mayor, inicial o final? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C√≥digo m√°s f√°cil de ver:</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cutSides</span><span class="hljs-params">(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell0, <span class="hljs-keyword">int</span> i0, <span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2, 
   <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_in, <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_out)</span>
 </span>{
   <span class="hljs-keyword">if</span> (i0 &lt; i1) {
      <span class="hljs-keyword">if</span> (i2 &gt; i0 &amp;&amp; i2 &lt; i1) {
         <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}<font></font>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (i2 &gt; i1 &amp;&amp; i2 &lt; i0) {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunos resultados de la detecci√≥n de elipses en casos complejos se muestran en la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 7</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/56/hd/jv56hdcpfuvmi59k0unppjknlq4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los siguientes art√≠culos, se considerar√°n los m√©todos de detecci√≥n estad√≠stica.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es490386/index.html">¬øDe qu√© otra manera ganar dinero en la bolsa de valores y reducir el riesgo: acciones de empresas con pago de dividendos?</a></li>
<li><a href="../es490390/index.html">Olga Makushenko, directora gerente de 101XP: ‚Äú5 errores clave en el desarrollo de un juego como negocio‚Äù</a></li>
<li><a href="../es490392/index.html">Catchain: Algoritmo de consenso TON Blockchain</a></li>
<li><a href="../es490394/index.html">Commodore Amiga 500+: que nadie se ofenda</a></li>
<li><a href="../es490398/index.html">Hogwarts rojos. Oficiales, o por qu√© un historiador es como un detective</a></li>
<li><a href="../es490404/index.html">Por qu√© y c√≥mo 5G lo cambiar√° todo: tecnolog√≠a, implementaci√≥n por fases y base de elementos para el equipo del suscriptor</a></li>
<li><a href="../es490406/index.html">Inexpresiblemente atractivo: c√≥mo creamos un haniot que no puede ser expuesto</a></li>
<li><a href="../es490410/index.html">Neuronas vivas y artificiales conectadas a trav√©s de Internet</a></li>
<li><a href="../es490412/index.html">¬øQuiz√°s deber√≠amos calmarnos un poco con JavaScript?</a></li>
<li><a href="../es490416/index.html">Video de la conferencia Computer Science Club</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>