<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏾 👩🏼‍🏫 ☺️ HighLoad ++, Mikhail Tyulenev (MongoDB): Konsistensi sebab-akibat: dari teori ke praktik 👗 🙏🏾 🙎🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Konferensi HighLoad ++ berikutnya akan diadakan pada 6 dan 7 April 2020 di St. Petersburg. 
 Detail dan tiket di sini . HighLoad ++ Siberia 2019. Aula...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>HighLoad ++, Mikhail Tyulenev (MongoDB): Konsistensi sebab-akibat: dari teori ke praktik</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/487638/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konferensi HighLoad ++ berikutnya akan diadakan pada 6 dan 7 April 2020 di St. Petersburg. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Detail dan tiket di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . HighLoad ++ Siberia 2019. Aula "Krasnoyarsk". 25 Juni 12:00. Abstrak dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presentasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ok/iw/mz/okiwmzx4qkp6dxvjvqjxvfzqtnk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kebetulan persyaratan praktis bertentangan dengan teori di mana aspek-aspek penting untuk produk komersial tidak diperhitungkan. Laporan ini menyajikan proses memilih dan menggabungkan berbagai pendekatan untuk menciptakan komponen konsistensi Kausal berdasarkan penelitian akademik berdasarkan persyaratan produk komersial. Siswa akan belajar tentang pendekatan teoritis yang ada untuk jam logis, pelacakan ketergantungan, keamanan sistem, sinkronisasi jam, dan mengapa MongoDB berhenti pada ini atau solusi tersebut.</font></font><a name="habracut"></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mikhail Tyulenev (selanjutnya - MT):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Saya akan berbicara tentang konsistensi Kausal - ini adalah fitur yang kami kerjakan di MongoDB. </font><font style="vertical-align: inherit;">Saya bekerja dalam kelompok sistem terdistribusi, kami melakukannya sekitar dua tahun lalu. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ih/xx/xg/ihxxxghkrknnqdxg7tb4w97izi0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam prosesnya, saya harus berkenalan dengan banyak Penelitian akademis, karena fitur ini dipelajari dengan baik. </font><font style="vertical-align: inherit;">Ternyata tidak ada satu artikel yang cocok dengan apa yang diperlukan dalam produksi, database mengingat persyaratan yang sangat spesifik, mungkin, dalam aplikasi produksi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan berbicara tentang bagaimana kita, sebagai konsumen Riset akademis, menyiapkan sesuatu darinya yang kemudian dapat kita presentasikan kepada pengguna sebagai hidangan siap pakai yang nyaman, aman untuk digunakan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsistensi kausal. </font><font style="vertical-align: inherit;">Mari mendefinisikan konsep</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mulai dengan, saya ingin menguraikan secara umum apa konsistensi Kausal. Ada dua karakter - Leonard dan Penny (seri "The Big Bang Theory"): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7q/nw/lr/7qnwlrmqtidow8cl_jrdakec3d0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan Penny ada di Eropa, dan Leonard ingin membuat semacam kejutan baginya, sebuah pesta. Dan dia tidak menghasilkan sesuatu yang lebih baik daripada membuangnya keluar dari daftar teman, mengirimkan pembaruan untuk memberi makan semua teman: "Ayo buat Penny bahagia!" (dia di Eropa, saat tidur, tidak melihat ini semua dan tidak bisa melihat, karena dia tidak ada di sana). Pada akhirnya, ia menghapus posting ini, menghapusnya dari "Feed" dan mengembalikan akses sehingga tidak melihat apa-apa dan tidak ada skandal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini semua baik-baik saja, tetapi mari kita asumsikan bahwa sistemnya terdistribusi, dan acara berjalan agak salah. </font><font style="vertical-align: inherit;">Mungkin, misalnya, kebetulan bahwa pembatasan akses Penny terjadi setelah posting ini muncul, jika acara tidak terhubung oleh hubungan sebab akibat. </font><font style="vertical-align: inherit;">Sebenarnya, ini adalah contoh ketika konsistensi Kausal diperlukan untuk memenuhi fungsi bisnis (dalam hal ini). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faktanya, ini adalah properti non-sepele dari database - sangat sedikit orang yang mendukungnya. </font><font style="vertical-align: inherit;">Mari kita beralih ke model.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model Konsistensi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang dimaksud dengan model konsistensi dalam database secara umum? </font><font style="vertical-align: inherit;">Ini adalah beberapa jaminan yang diberikan oleh sistem terdistribusi mengenai data apa dan dalam urutan apa klien dapat menerima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada prinsipnya, semua model konsistensi datang ke bagaimana sistem terdistribusi seperti sistem yang bekerja, misalnya, pada anggukan yang sama pada laptop. </font><font style="vertical-align: inherit;">Dan ini adalah seberapa banyak sistem, yang bekerja pada ribuan "Nodes" yang didistribusikan secara geografis, mirip dengan laptop, di mana semua properti ini dilakukan secara otomatis pada prinsipnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, model konsistensi hanya berlaku untuk sistem terdistribusi. </font><font style="vertical-align: inherit;">Semua sistem yang sebelumnya ada dan bekerja pada penskalaan vertikal yang sama tidak mengalami masalah seperti itu. </font><font style="vertical-align: inherit;">Ada satu Buffer Cache, dan semuanya selalu terbaca darinya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model yang kuat</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebenarnya, model pertama adalah Strong (atau garis kemampuan naik, seperti yang sering disebut). </font><font style="vertical-align: inherit;">Ini adalah model konsistensi yang memastikan bahwa setiap perubahan, segera setelah konfirmasi diterima bahwa itu telah terjadi, dapat dilihat oleh semua pengguna sistem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini menciptakan tatanan global semua peristiwa dalam database. </font><font style="vertical-align: inherit;">Ini adalah properti konsistensi yang sangat kuat, dan umumnya sangat mahal. </font><font style="vertical-align: inherit;">Namun, itu dipelihara dengan sangat baik. </font><font style="vertical-align: inherit;">Ini sangat mahal dan lambat - mereka jarang digunakan. </font><font style="vertical-align: inherit;">Ini disebut kemampuan naik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada properti lain yang lebih kuat yang didukung di "Spanner" - disebut Konsistensi Eksternal. </font><font style="vertical-align: inherit;">Kami akan membicarakannya nanti.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kausal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut ini adalah Penyebab, hanya apa yang saya bicarakan. Ada beberapa sublevel antara Strong dan Causal yang tidak akan saya bicarakan, tetapi semuanya turun ke Causal. Ini adalah model yang penting karena ini adalah yang terkuat dari semua model, konsistensi terkuat di hadapan jaringan atau partisi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kausal sebenarnya adalah situasi di mana peristiwa dihubungkan oleh hubungan sebab akibat. Sangat sering mereka dianggap sebagai Baca hak Anda dari sudut pandang klien. Jika klien mengamati beberapa nilai, ia tidak bisa melihat nilai-nilai yang ada di masa lalu. Dia sudah mulai melihat pembacaan awalan. Semuanya bermuara pada hal yang sama.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kausal sebagai model konsistensi adalah pengurutan sebagian acara di server, di mana acara dari semua klien diamati dalam urutan yang sama. </font><font style="vertical-align: inherit;">Dalam hal ini, Leonard dan Penny.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Model ketiga adalah Konsistensi Akhir. Inilah yang benar-benar mendukung semua sistem terdistribusi, model minimal yang secara umum masuk akal. Ini berarti yang berikut: ketika kami memiliki beberapa perubahan dalam data, mereka menjadi konsisten di beberapa titik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada saat seperti itu, dia tidak mengatakan apa-apa, kalau tidak dia akan berubah menjadi Konsistensi Eksternal - akan ada cerita yang sama sekali berbeda. Meskipun demikian, ini adalah model yang sangat populer, yang paling umum. Secara default, semua pengguna sistem terdistribusi menggunakan Konsistensi Akhir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin memberikan beberapa contoh komparatif: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yn/5s/p9/yn5sp9tyjn4dh4q3vonroirvxic.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa arti panah-panah ini?</font></font><br>
<br>
<ul>
<li><b>Latency.</b>          :    ,       ,    ,     .   Eventual Consistency   ,   ,  ,    memory       .</li>
<li><b>Availability.</b>           , partitions,  -  –      ,    ,         - . Eventual Consistency        –    ,  .</li>
<li><b>Anomalies.</b>  , ,   .  Strong Consistency       ,  Eventual Consistency     .  :     Eventual Consistency,    ?    ,  Eventual Consistency- ,   , ,    ;        -   ;       .   ,       .</li>
</ul><br>
<h3> CAP</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika Anda melihat kata-kata konsistensi, ketersediaan - apa yang terlintas dalam pikiran? Kanan - teorema CAP! Sekarang saya ingin menghilangkan mitos ... Ini bukan saya - ada Martin Kleppman, yang menulis artikel yang bagus, buku yang bagus. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-k/rc/v1/-krcv1vofhv9ofnwbty6ql6hvhg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teorema CAP adalah prinsip yang dirumuskan pada tahun 2000-an bahwa Konsistensi, Ketersediaan, Partisi: ambil dua, dan Anda tidak dapat memilih tiga. Itu adalah prinsip tertentu. Itu terbukti sebagai teorema beberapa tahun kemudian, oleh Gilbert dan Lynch. Kemudian menjadi mantra - sistem mulai dibagi menjadi CA, CP, AP dan sebagainya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teorema ini sebenarnya dibuktikan karena alasan berikut ... Pertama, Ketersediaan dianggap bukan sebagai nilai kontinu dari nol hingga ratusan (0 - sistem "mati", 100 - jawaban cepat; kita sudah terbiasa mempertimbangkannya), tetapi sebagai properti algoritma , yang memastikan bahwa dengan semua eksekusi itu mengembalikan data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada sepatah kata pun tentang waktu respons! Ada algoritma yang mengembalikan data setelah 100 tahun - algoritma yang tersedia dengan sangat baik, yang merupakan bagian dari teorema CAP. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kedua: teorema terbukti untuk perubahan nilai-nilai kunci yang sama, meskipun fakta bahwa perubahan ini adalah garis resizable. Ini berarti bahwa pada kenyataannya mereka praktis tidak digunakan, karena model-model itu berbeda, Konsistensi Akhir, Konsistensi Kuat (mungkin).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kenapa ini semua? </font><font style="vertical-align: inherit;">Lebih lanjut, teorema CAP dalam bentuk yang dibuktikan secara praktis tidak berlaku jarang digunakan. </font><font style="vertical-align: inherit;">Dalam bentuk teoretis, entah bagaimana membatasi segalanya. </font><font style="vertical-align: inherit;">Ternyata prinsip tertentu yang secara intuisi benar, tetapi sama sekali tidak terbukti secara umum.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsistensi sebab akibat - model terkuat</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang terjadi sekarang - Anda bisa mendapatkan ketiga hal: Konsistensi, Ketersediaan dapat diperoleh dengan menggunakan Partisi. </font><font style="vertical-align: inherit;">Secara khusus, konsistensi kausal adalah model konsistensi terkuat, yang, di hadapan Partisi (istirahat jaringan), masih berfungsi. </font><font style="vertical-align: inherit;">Karena itu, ini sangat menarik, dan karena itu kami terlibat di dalamnya. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/4s/k8/ty4sk8sx4n73xnsxlkw2wtb1ity.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, ini menyederhanakan pekerjaan pengembang aplikasi. </font><font style="vertical-align: inherit;">Secara khusus, ada banyak dukungan dari server: ketika semua catatan yang terjadi di dalam satu klien dijamin akan tiba dalam urutan ini pada klien lain. </font><font style="vertical-align: inherit;">Kedua, tahan partisi.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dapur Interior MongoDB</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengingat makan siang itu, kami pindah ke dapur. Saya akan berbicara tentang model sistem, yaitu, apa itu MongoDB bagi mereka yang pertama kali mendengar tentang database seperti itu. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fn/-b/kj/fn-bkjwvkdxcokzum9xwwkshcu8.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/2u/qz/3g/2uqz3gts5ipfvvojtpo2epigtf4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MongoDB (selanjutnya disebut "MongoBD") adalah sistem terdistribusi yang mendukung penskalaan horizontal, yaitu sharding; dan di dalam setiap beling, ia juga mendukung redundansi data, yaitu replikasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sharding dalam "MongoBD" (database non-relasional) melakukan penyeimbangan otomatis, yaitu, setiap kumpulan dokumen (atau "tabel" dalam hal data relasional) menjadi potongan-potongan, dan sudah server secara otomatis memindahkan mereka di antara pecahan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Router Kueri yang mendistribusikan kueri untuk klien adalah beberapa klien yang digunakannya. Dia sudah tahu di mana dan data apa yang berada, mengirim semua permintaan ke beling yang benar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Poin penting lainnya: MongoDB adalah master tunggal. </font><font style="vertical-align: inherit;">Ada satu Pratama - dapat mengambil catatan yang mendukung kunci yang dikandungnya. </font><font style="vertical-align: inherit;">Anda tidak dapat menulis multi-master. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami membuat rilis 4.2 - hal-hal menarik baru muncul di sana. </font><font style="vertical-align: inherit;">Secara khusus, mereka memasukkan Lucene - pencarian - itu adalah executable java langsung di "Mongo", dan di sana menjadi mungkin untuk mencari melalui Lucene, sama seperti di "Elastic". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan mereka membuat produk baru - Bagan, itu juga tersedia di Atlas (Mongo sendiri Cloud). </font><font style="vertical-align: inherit;">Mereka memiliki Tier Gratis - Anda dapat bermain-main dengan ini. </font><font style="vertical-align: inherit;">Saya sangat menyukai grafik - visualisasi data sangat intuitif.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahan konsistensi kausal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menghitung sekitar 230 artikel yang diterbitkan tentang topik ini - dari Leslie Lampert. </font><font style="vertical-align: inherit;">Sekarang dari ingatan saya, saya akan membawa kepada Anda beberapa bagian dari materi ini. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2_/dt/2n/2_dt2nhood8jlup51kyeddsy7w8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya dimulai dengan sebuah artikel oleh Leslie Lampert, yang ditulis pada tahun 1970-an. </font><font style="vertical-align: inherit;">Seperti yang Anda lihat, beberapa penelitian tentang topik ini masih berlangsung. </font><font style="vertical-align: inherit;">Sekarang konsistensi Kausal sedang mengalami minat sehubungan dengan pengembangan sistem terdistribusi.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keterbatasan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa batasannya? </font><font style="vertical-align: inherit;">Ini sebenarnya adalah salah satu poin utama, karena pembatasan yang diberlakukan sistem produksi sangat berbeda dari pembatasan yang ada dalam artikel akademik. </font><font style="vertical-align: inherit;">Seringkali mereka cukup buatan.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qd/nh/ql/qdnhql6zcor1hzt53ur72spzqzy.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, "MongoDB" adalah master tunggal, seperti yang telah saya katakan (ini sangat disederhanakan).</font></font></li>
<li> ,   10     .     -  ,      .</li>
<li>   ,   ,      ,    binary,     ,    .</li>
<li>  ,   Research  :      . «» –  . ,     ,  –    .  ,     .</li>
<li>  ,     –  :    ,   performance degradation   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poin lain umumnya anti-akademik: kompatibilitas versi sebelumnya dan masa depan. </font><font style="vertical-align: inherit;">Driver lama harus mendukung pembaruan baru, dan database harus mendukung driver lama.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, semua ini memberlakukan batasan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponen konsistensi kausal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang saya akan berbicara tentang beberapa komponen. </font><font style="vertical-align: inherit;">Jika kita mempertimbangkan konsistensi Kausal umum, kita dapat membedakan blok. </font><font style="vertical-align: inherit;">Kami memilih dari karya-karya yang termasuk blok tertentu: Pelacakan Ketergantungan, pilihan jam, bagaimana jam tangan ini dapat disinkronkan satu sama lain, dan bagaimana kami memastikan keamanan - ini adalah rencana perkiraan dari apa yang akan saya bicarakan:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/rb/rq/zvrbrqunyfdrj1pmbrjncugqed4.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelacakan Ketergantungan Penuh</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa itu dibutuhkan? Agar ketika data direplikasi - setiap catatan, setiap perubahan data berisi informasi tentang perubahan yang bergantung padanya. Perubahan pertama dan naif adalah ketika setiap pesan yang berisi catatan berisi informasi tentang pesan sebelumnya: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/ue/jh/gkuejhztxm81mfji3fazhsmbmbm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh ini, nomor dalam kurung adalah jumlah rekaman. Kadang-kadang catatan dengan nilai ini bahkan ditransfer secara keseluruhan, kadang-kadang beberapa versi ditransfer. Intinya adalah bahwa setiap perubahan berisi informasi tentang yang sebelumnya (jelas itu membawa semuanya dengan sendirinya).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa kami memutuskan untuk tidak menggunakan pendekatan ini (pelacakan lengkap)? </font><font style="vertical-align: inherit;">Jelas, karena pendekatan ini tidak praktis: setiap perubahan di jejaring sosial tergantung pada semua perubahan sebelumnya di jejaring sosial ini, mentransmisikan, katakanlah, Facebook atau Vkontakte di setiap pembaruan. </font><font style="vertical-align: inherit;">Namun demikian, ada banyak penelitian yaitu Pelacakan Ketergantungan Penuh - ini adalah jejaring sosial, untuk beberapa situasi ini benar-benar berfungsi.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelacakan Ketergantungan Eksplisit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang berikutnya lebih terbatas. </font><font style="vertical-align: inherit;">Di sini juga, transmisi informasi dipertimbangkan, tetapi hanya yang jelas tergantung. </font><font style="vertical-align: inherit;">Apa yang tergantung pada apa, sebagai suatu peraturan, sudah ditentukan oleh Aplikasi. </font><font style="vertical-align: inherit;">Ketika data direplikasi, hanya respons yang dikembalikan ketika permintaan dibuat, ketika dependensi sebelumnya terpenuhi, yaitu, ditampilkan. </font><font style="vertical-align: inherit;">Ini adalah inti dari bagaimana konsistensi kausal bekerja. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y_/jc/mw/y_jcmwt2w-vqj9guslui0wl8vgi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dia melihat bahwa catatan 5 tergantung pada catatan 1, 2, 3, 4 - masing-masing, dia menunggu sebelum klien mendapatkan akses ke perubahan yang dibuat oleh keputusan akses Penny ketika semua perubahan sebelumnya telah diteruskan ke database. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini juga tidak cocok untuk kita, karena bagaimanapun juga ada terlalu banyak informasi, dan ini akan melambat. </font><font style="vertical-align: inherit;">Ada pendekatan yang berbeda ...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jam Lamport</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mereka sudah sangat tua. Lamport Clock menyiratkan bahwa ketergantungan ini runtuh menjadi fungsi skalar yang disebut Lamport Clock. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi skalar adalah angka abstrak. Sering disebut waktu logis. Di setiap acara, penghitung ini bertambah. Penghitung, yang saat ini diketahui prosesnya, mengirim setiap pesan. Jelas bahwa proses dapat tidak sinkron, mereka dapat memiliki waktu yang sama sekali berbeda. Namun demikian, sistem entah bagaimana menyeimbangkan jam dengan pesan seperti itu. Apa yang terjadi dalam kasus ini?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya membagi pecahan besar itu menjadi dua sehingga jelas: Teman-teman dapat hidup dalam satu simpul yang berisi sepotong koleksi, dan Feed dapat hidup di simpul lain yang berisi sepotong koleksi ini. Sudah jelas bagaimana mereka bisa keluar dari belokan? Pertama, Feed berkata, "Replicated," dan kemudian Friends. Jika sistem tidak memberikan jaminan bahwa Umpan tidak akan ditampilkan sampai dependensi Teman di koleksi Teman juga dikirimkan, maka kami hanya akan memiliki situasi yang saya sebutkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda melihat bagaimana penghitung waktu meningkat secara logis pada Umpan:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gv/pz/vw/gvpzvwwxqonuthkwv6j2ez0fruc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, properti utama dari Lamport Clock ini dan konsistensi kausal (dijelaskan melalui Lamport Clock) adalah sebagai berikut: jika kita memiliki event A dan B, dan event B tergantung pada event A *, maka itu mengikuti bahwa LogicalTime dari Event A kurang daripada LogicalTime dari Peristiwa B. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Kadang-kadang mereka bahkan mengatakan bahwa A terjadi sebelum B, yaitu, A terjadi sebelum B - ini adalah jenis hubungan yang sebagian memerintahkan seluruh rangkaian peristiwa yang umumnya terjadi.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Kebalikannya salah. Ini sebenarnya salah satu kelemahan utama dari Lamport Clock - pemesanan parsial. Ada konsep peristiwa simultan, yaitu peristiwa di mana tidak ada (A terjadi sebelum B) maupun (A terjadi sebelum B). Contohnya adalah penambahan paralel oleh Leonard ke teman-teman orang lain (bahkan bukan Leonard, tetapi Sheldon, misalnya).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah properti yang sering digunakan ketika bekerja dengan jam tangan Lamport: mereka melihat fungsinya dengan tepat dan menarik kesimpulan dari ini - mungkin acara ini tergantung. </font><font style="vertical-align: inherit;">Karena dalam satu arah ini benar: jika LogicalTime A kurang dari LogicalTime B, maka B tidak dapat terjadi sebelum A; </font><font style="vertical-align: inherit;">dan jika lebih, maka mungkin.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vektor Jam</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perkembangan logis dari jam tangan Lamport adalah Vector Clock. Mereka berbeda karena setiap node yang ada di sini berisi jam tersendiri, dan mereka ditransmisikan sebagai vektor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, Anda melihat bahwa indeks nol vektor bertanggung jawab untuk Umpan, dan indeks pertama vektor adalah untuk Teman (masing-masing node ini). Dan sekarang mereka akan meningkat: indeks nol "Umpan" meningkat saat merekam - 1, 2, 3: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cv/xm/cd/cvxmcdiz_dgbjsu7elnj3xt2hcc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana Jam Vektor lebih baik? Fakta bahwa mereka dapat mengetahui peristiwa mana yang simultan dan kapan mereka terjadi pada node yang berbeda. Ini sangat penting untuk sistem sharding seperti MongoBD. Namun, kami tidak memilih ini, meskipun ini adalah hal yang luar biasa, dan ini berfungsi dengan baik, dan mungkin akan cocok untuk kami ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita memiliki 10 ribu pecahan, kita tidak dapat mentransfer 10 ribu komponen, bahkan jika kita kompres, kita memikirkan sesuatu yang lain - semua sama, muatannya akan beberapa kali lebih sedikit dari volume seluruh vektor ini. </font><font style="vertical-align: inherit;">Karena itu, menggerogoti hati dan gigi kami, kami meninggalkan pendekatan ini dan pindah ke yang lain.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spanner TrueTime. </font><font style="vertical-align: inherit;">Jam atom</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mengatakan bahwa akan ada cerita tentang Spanner. Ini adalah hal yang keren, tepat abad ke-21: jam atom, sinkronisasi GPS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ide apa? Spanner adalah sistem Google yang baru-baru ini bahkan menjadi tersedia untuk orang-orang (mereka telah melampirkan SQL ke dalamnya). Setiap transaksi di sana memiliki cap waktu. Karena waktu disinkronkan *, setiap peristiwa dapat ditetapkan waktu tertentu - jam atom memiliki waktu tunggu, setelah itu dijamin bahwa waktu lain akan terjadi. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zn/vw/e3/znvwe3zwpqvjhsx-qglxpbqen9g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, hanya menulis ke database dan menunggu periode waktu tertentu, serialisasi acara dijamin secara otomatis. Mereka memiliki model Konsistensi yang terkuat, yang pada prinsipnya dapat dibayangkan - itu adalah Konsistensi Eksternal.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* Ini adalah masalah utama jam tangan Lampart - mereka tidak pernah sinkron pada sistem terdistribusi. </font><font style="vertical-align: inherit;">Mereka dapat menyimpang, bahkan dengan NTP, mereka masih tidak bekerja dengan baik. </font><font style="vertical-align: inherit;">"Spanner" memiliki jam atom dan sinkronisasi tampaknya menjadi mikrodetik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kenapa kita tidak memilih? </font><font style="vertical-align: inherit;">Kami tidak menganggap bahwa pengguna kami memiliki jam atom bawaan. </font><font style="vertical-align: inherit;">Ketika mereka muncul, dimasukkan ke dalam setiap laptop, akan ada semacam sinkronisasi GPS yang sangat keren - lalu ya ... Sementara itu, yang terbaik yang mungkin adalah Amazon, Base Station untuk fanatik ... Oleh karena itu, kami menggunakan jam tangan lain.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jam Hibrid</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inilah sebenarnya yang menandai "MongoBD" sambil memastikan konsistensi Kausal. </font><font style="vertical-align: inherit;">Apa itu hibrida? </font><font style="vertical-align: inherit;">Hibrida adalah nilai skalar, tetapi terdiri dari dua komponen:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hi/wz/uv/hiwzuvz-czbmb52b9iypojrr0_u.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang pertama adalah era unix (berapa detik telah berlalu sejak "awal dunia komputer").</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang kedua adalah beberapa kenaikan, juga int 32-bit unsigned.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu saja, sebenarnya. </font><font style="vertical-align: inherit;">Ada pendekatan semacam itu: bagian yang bertanggung jawab atas waktu disinkronkan dengan jam sepanjang waktu; </font><font style="vertical-align: inherit;">setiap kali pembaruan terjadi, bagian ini disinkronkan dengan jam dan ternyata waktu selalu lebih atau kurang benar, dan kenaikan memungkinkan Anda untuk membedakan antara peristiwa yang terjadi pada waktu yang sama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa ini penting untuk MongoBD? </font><font style="vertical-align: inherit;">Karena ini memungkinkan Anda untuk membuat semacam restorant cadangan pada titik waktu tertentu, yaitu acara tersebut diindeks berdasarkan waktu. </font><font style="vertical-align: inherit;">Ini penting ketika beberapa acara dibutuhkan; </font><font style="vertical-align: inherit;">untuk database, peristiwa adalah perubahan pada database yang terjadi pada waktu-waktu tertentu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya hanya akan memberi tahu Anda alasan paling penting (tolong, jangan beri tahu siapa pun)! </font><font style="vertical-align: inherit;">Kami melakukan ini karena data terurut dan terindeks di MongoDB OpLog terlihat seperti ini. </font><font style="vertical-align: inherit;">OpLog adalah struktur data yang benar-benar mengandung semua perubahan dalam basis data: mereka pertama-tama pergi ke OpLog, dan kemudian mereka sudah diterapkan ke Penyimpanan itu sendiri dalam kasus ketika itu adalah tanggal atau beling yang direplikasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itulah alasan utama. </font><font style="vertical-align: inherit;">Namun, ada juga persyaratan praktis untuk mengembangkan database, yang artinya harus sederhana - hanya ada sedikit kode, sesedikit mungkin kerusakan yang perlu ditulis ulang dan diuji. </font><font style="vertical-align: inherit;">Fakta bahwa oplog kami diindeks oleh arloji hybrid sangat membantu, dan memungkinkan kami untuk membuat pilihan yang tepat. </font><font style="vertical-align: inherit;">Ini benar-benar terbayar dan entah bagaimana ajaibnya, pada prototipe pertama. </font><font style="vertical-align: inherit;">Itu sangat keren!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinkronisasi jam</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada beberapa metode sinkronisasi yang dijelaskan dalam literatur ilmiah. </font><font style="vertical-align: inherit;">Saya berbicara tentang sinkronisasi ketika kami memiliki dua pecahan yang berbeda. </font><font style="vertical-align: inherit;">Jika ada satu set replika, tidak perlu sinkronisasi di sana: itu adalah "master tunggal"; </font><font style="vertical-align: inherit;">kami memiliki OpLog di mana semua perubahan masuk - dalam hal ini semuanya sudah dipesan secara berurutan di "Oplog" itu sendiri. </font><font style="vertical-align: inherit;">Tetapi jika kita memiliki dua pecahan yang berbeda, sinkronisasi waktu adalah penting di sini. </font><font style="vertical-align: inherit;">Di sini jam vektor lebih membantu! </font><font style="vertical-align: inherit;">Tetapi kita tidak memilikinya. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ei/kq/bk/eikqbkbbzrsdquzxjxlzayc81qq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang kedua adalah Detak Jantung. </font><font style="vertical-align: inherit;">Anda dapat bertukar beberapa sinyal yang muncul setiap satuan waktu. </font><font style="vertical-align: inherit;">Tapi Hartbit terlalu lambat, kami tidak bisa memberikan latensi kepada klien kami.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Waktu yang sebenarnya, tentu saja, adalah hal yang luar biasa. </font><font style="vertical-align: inherit;">Tapi, sekali lagi, ini mungkin masa depan ... Meskipun Atlas sudah dapat dilakukan, sudah ada sinkronisasi waktu cepat "Amazon". </font><font style="vertical-align: inherit;">Tetapi itu tidak akan tersedia untuk semua orang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gosip adalah saat semua pesan menyertakan waktu. </font><font style="vertical-align: inherit;">Ini kira-kira yang kita gunakan. </font><font style="vertical-align: inherit;">Setiap pesan antara node, driver, router dari node data, benar-benar segalanya untuk "MongoDB" - ini adalah beberapa elemen, komponen database yang berisi jam yang mengalir. </font><font style="vertical-align: inherit;">Di mana-mana mereka memiliki arti waktu hibrid, itu ditransmisikan. </font><font style="vertical-align: inherit;">64 bit? </font><font style="vertical-align: inherit;">Itu memungkinkan, itu mungkin.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana semuanya bekerja bersama?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini saya melihat satu set replika untuk membuatnya sedikit lebih mudah. Ada Pratama dan Sekunder. Sekunder melakukan replikasi dan tidak selalu sepenuhnya disinkronkan dengan Pratama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada sisipan (insert) di "Primaries" dengan nilai waktu tertentu. Sisipan ini menambah penghitung internal sebesar 11, jika maksimum. Atau akan memeriksa nilai jam dan menyinkronkan jam jika jam lebih besar. Ini memungkinkan Anda untuk mengurutkan berdasarkan waktu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah dia membuat catatan, momen penting terjadi. Jamnya berada di "MongoDB" dan bertambah hanya jika dicatat dalam "Oplog". Ini adalah peristiwa yang mengubah keadaan sistem. Benar-benar di semua artikel klasik, suatu peristiwa dianggap sebagai pesan yang memasuki sebuah simpul: pesan telah tiba - itu berarti sistem telah mengubah kondisinya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal ini disebabkan oleh fakta bahwa selama penelitian tidak sepenuhnya mungkin untuk memahami bagaimana pesan ini akan ditafsirkan. Kita tahu pasti bahwa jika itu tidak tercermin dalam "Oplog", maka itu tidak akan ditafsirkan dengan cara apa pun, dan hanya entri dalam "Oplog" adalah perubahan dalam status sistem. Ini menyederhanakan segalanya bagi kita: model menyederhanakan dan memungkinkan kita untuk mengatur dalam kerangka satu set replika, dan banyak hal berguna lainnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini mengembalikan nilai yang telah direkam dalam "Oplog" - kita tahu bahwa dalam "Oplog" nilai ini sudah ada, dan waktunya adalah 12. Sekarang, katakanlah, pembacaan dimulai dari node lain (Sekunder), dan sudah ditransfer setelahClusterTime sendiri pesan. Dia mengatakan, "Aku butuh semua yang terjadi setelah setidaknya 12 atau selama dua belas" (lihat gbr. Di atas).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inilah yang disebut Kausal a konsisten (CAT). Ada semacam teori dalam teori bahwa itu adalah sepotong waktu, yang konsisten dalam dirinya sendiri. Dalam hal ini, kita dapat mengatakan bahwa ini adalah keadaan sistem yang diamati pada waktu 12. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang tidak ada apa-apa di sini, karena tampaknya meniru situasi ketika Sekunder perlu mereplikasi data dari Pratama. Dia sedang menunggu ... Dan sekarang data telah datang - mengembalikan nilai-nilai ini kembali. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/a1/q7/3q/a1q73qclyk9sn567b2x8szr_ejm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Begitulah cara kerjanya. Hampir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa artinya "hampir"? Mari kita asumsikan bahwa ada beberapa orang yang telah membaca dan memahami bagaimana semua ini bekerja. Saya menyadari bahwa setiap kali ClusterTime terjadi, itu memperbarui jam logis internal, dan kemudian catatan berikutnya meningkat satu. Fungsi ini membutuhkan 20 baris. Misalkan orang ini mentransmisikan kemungkinan nomor 64-bit terbesar, minus satu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa minus satu? Karena jam internal diganti dengan nilai ini (jelas, ini adalah kemungkinan terbesar dan lebih dari waktu saat ini), maka akan ada entri di "Olog", dan jam akan bertambah satu lagi - dan akan ada nilai maksimum (hanya ada semua unit, tidak ada tempat untuk pergi , int yang tidak ditandatangani).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jelas bahwa setelah ini sistem menjadi sepenuhnya tidak dapat diakses dengan sia-sia. </font><font style="vertical-align: inherit;">Itu hanya dapat dibongkar, dibersihkan - banyak pekerjaan manual. </font><font style="vertical-align: inherit;">Ketersediaan penuh: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/lz/fs/iulzfslzcst3tn9c-qpouy9zqsk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, jika ini direplikasi di tempat lain, maka seluruh kluster hanya berbaring. </font><font style="vertical-align: inherit;">Situasi yang benar-benar tidak dapat diterima yang dapat diatur siapa pun dengan sangat cepat dan sederhana! </font><font style="vertical-align: inherit;">Karena itu, kami menganggap momen ini sebagai salah satu momen terpenting. </font><font style="vertical-align: inherit;">Bagaimana cara mencegahnya?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara kami adalah menandatangani clusterTime</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi itu dikirim dalam pesan (sebelum teks biru). Tetapi kami juga mulai membuat tanda tangan (teks biru): Tanda </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zg/9r/iu/zg9riuabqzdlnw9dwttrwkwzkmi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tangan dihasilkan oleh kunci yang disimpan di dalam basis data, di dalam perimeter yang dilindungi; itu dihasilkan, diperbarui (pengguna tidak melihat apa-apa). Hash dihasilkan, dan setiap pesan ditandatangani selama pembuatan, dan divalidasi setelah diterima. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin, muncul pertanyaan pada orang: "Berapa lambatnya?" Saya mengatakan bahwa itu harus bekerja dengan cepat, terutama karena tidak adanya fitur ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa artinya menggunakan konsistensi kausal dalam kasus ini? Ini akan menampilkan parameter afterClusterTime. Dan tanpa itu, itu hanya akan memberikan nilai. Gosip, sejak versi 3.6, selalu berhasil.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita meninggalkan generasi tanda tangan yang konstan, ini akan memperlambat sistem bahkan tanpa adanya fitur, yang tidak memenuhi pendekatan dan persyaratan kami. </font><font style="vertical-align: inherit;">Dan apa yang telah kita lakukan?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lakukan itu dengan cepat!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suatu hal yang cukup sederhana, tetapi triknya menarik - Saya akan membagikannya, mungkin seseorang akan tertarik. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memiliki hash yang menyimpan data yang ditandatangani. </font><font style="vertical-align: inherit;">Semua data melewati cache. </font><font style="vertical-align: inherit;">Cache tidak secara spesifik menandatangani waktu, tetapi Range. </font><font style="vertical-align: inherit;">Ketika nilai tertentu datang, kami menghasilkan Range, menutupi 16 bit terakhir, dan kami menandatangani nilai ini: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s8/ml/3a/s8ml3aaec2pj5xl8t0zvkrp7iik.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan menerima tanda tangan seperti itu, kami mempercepat sistem (kondisional) sebanyak 65 ribu kali. </font><font style="vertical-align: inherit;">Ini berfungsi dengan baik: ketika mereka melakukan percobaan, waktu ketika kami memiliki pembaruan yang konsisten benar-benar berkurang di sana sebanyak 10 ribu kali. </font><font style="vertical-align: inherit;">Jelas bahwa ketika mereka berselisih, ini tidak berhasil. </font><font style="vertical-align: inherit;">Tetapi dalam kebanyakan kasus praktis ini berhasil. </font><font style="vertical-align: inherit;">Kombinasi tanda tangan Range dengan tanda tangan menyelesaikan masalah keamanan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang telah kita pelajari?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pelajaran yang kami pelajari dari ini:</font></font><br>
<br>
<ul>
<li>  , , ,       .     -  ( ,      . .),  , .   ,       ,    ,   .        –   .<br>
<br>
,     ,      («», ) –      .     ?    .     ,      .   –   ,   .</li>
<li>    .  ,        «»     ,   ,  ,      availability, latency  .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang terakhir adalah kami harus mempertimbangkan ide-ide yang berbeda dan menggabungkan beberapa artikel yang umumnya berbeda menjadi satu pendekatan, bersama-sama. </font><font style="vertical-align: inherit;">Gagasan penandatanganan, misalnya, berasal dari sebuah artikel yang meneliti protokol Paxos, yang untuk non-Bizantium Faylor di dalam protokol otorisasi, untuk yang Bizantium di luar protokol otorisasi ... Secara umum, ini persis seperti yang kami lakukan pada akhirnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sama sekali tidak ada yang baru di sini! </font><font style="vertical-align: inherit;">Tapi begitu kita mencampur semuanya ... Ini seperti mengatakan bahwa resep salad Olivier itu omong kosong, karena telur, mayones dan mentimun telah muncul dengan ... Ini tentang cerita yang sama.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/6o/pc/q8/6opcq8ew4bcry9qnt0lsdlasflo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentang ini saya akan berakhir. </font><font style="vertical-align: inherit;">Terima kasih!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertanyaan</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertanyaan dari hadirin (selanjutnya - B):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Terima kasih, Michael atas laporannya! Tema waktu itu menarik. Anda menggunakan gosip. Mereka mengatakan bahwa setiap orang memiliki waktu mereka sendiri, semua orang tahu waktu setempat mereka. Seperti yang saya pahami, kami memiliki driver - mungkin ada banyak klien dengan driver, permintaan-perencana juga, banyak pecahan ... Tapi apa sistem akan jika kita tiba-tiba memiliki perbedaan: seseorang memutuskan bahwa dia sebentar depan, seseorang - satu menit di belakang? Di mana kita akan menemukan diri kita sendiri? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Pertanyaan bagus kok! Saya hanya ingin mengatakan tentang pecahan. Jika saya memahami pertanyaan dengan benar, kita memiliki situasi ini: ada beling 1 dan beling 2, bacaan terjadi dari dua pecahan ini - mereka memiliki perbedaan, mereka tidak berinteraksi satu sama lain, karena waktu yang mereka tahu berbeda, terutama waktu yang Mereka ada di oplog.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan pecahan 1 membuat sejuta catatan, pecahan 2 tidak melakukan apa-apa, dan permintaan datang dalam dua pecahan. Dan yang pertama memiliki afterClusterTime lebih dari satu juta. Dalam situasi seperti itu, seperti yang saya jelaskan, beling 2 tidak akan pernah merespons sama sekali. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Saya ingin tahu bagaimana mereka mensinkronkan dan memilih satu waktu yang logis? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Sangat mudah disinkronkan. Shard, ketika afterClusterTime datang kepadanya, dan dia tidak menemukan waktu di "Tangkapan" - inisiat tidak disetujui. Artinya, dia mengangkat tangannya ke nilai ini dengan tangannya. Ini berarti tidak ada acara yang cocok dengan kueri ini. Dia menciptakan acara ini secara artifisial dan dengan demikian menjadi Konsisten Kausal. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Dan jika setelah itu beberapa peristiwa lain yang hilang di suatu tempat di jaringan masih datang kepadanya? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Beling itu diatur sedemikian rupa sehingga mereka tidak akan datang lagi, karena itu adalah tuan tunggal. Jika dia sudah mencatat, maka mereka tidak akan datang, tetapi akan mengejar. Tidak dapat terjadi bahwa di suatu tempat ada sesuatu yang macet, maka dia tidak akan menulis, dan kemudian peristiwa ini tiba - dan konsistensi Kausal dilanggar. Ketika dia tidak menulis, mereka semua harus datang berikutnya (dia akan menunggu mereka). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t2/wb/oo/t2wboofhfs7qpepqz8zwsm1o0u4.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DI:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Saya punya beberapa pertanyaan tentang garis. Konsistensi sebab akibat mengasumsikan bahwa ada antrian tindakan tertentu yang perlu dilakukan. Apa yang terjadi jika kami kehilangan satu paket? Jadi tanggal 10 pergi, tanggal 11 ... tanggal 12 menghilang, dan semua orang menunggu untuk dipenuhi. Dan tiba-tiba mobil kami mati, kami tidak bisa melakukan apa-apa. Apakah ada panjang antrian maksimum yang terakumulasi sebelum dieksekusi? Kegagalan fatal apa yang terjadi ketika satu negara hilang? Selain itu, jika kita menuliskan bahwa ada semacam keadaan sebelumnya, maka kita harus entah bagaimana memulainya? Dan mereka tidak mendorong darinya! </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Juga pertanyaan yang bagus! Apa yang kita lakukan? MongoDB memiliki konsep catatan kuorum, membaca kuorum. Kapan pesan bisa hilang? Ketika catatan tidak kuorum atau ketika bacaan tidak kuorum (beberapa sampah juga bisa menempel). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengenai konsistensi Kausal, kami melakukan tes eksperimental besar, yang menghasilkan fakta bahwa ketika rekaman dan bacaan tidak kuorum, pelanggaran konsistensi Kausal terjadi. Apa yang Anda katakan!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kiat kami: Gunakan setidaknya membaca kuorum saat menggunakan konsistensi Kausal. Dalam hal ini, tidak ada yang akan hilang, bahkan jika catatan kuorum hilang ... Ini adalah situasi ortogonal: jika pengguna tidak ingin data hilang, Anda perlu menggunakan catatan kuorum. Konsistensi kausal tidak menjamin ketahanan. Jaminan ketahanan disediakan oleh replikasi dan mesin yang terkait dengan replikasi. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ketika kita membuat contoh yang sharding lakukan untuk kita (bukan master, tetapi budak, masing-masing), ia bergantung pada waktu unix dari mesinnya sendiri atau pada waktu "master"; disinkronkan untuk pertama kalinya atau secara berkala? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Sekarang saya akan membuatnya jelas. Shard (mis., Partisi horizontal) - selalu ada Pratama. Dan di beling mungkin ada "tuan" dan mungkin ada replika. Tetapi beling selalu mendukung penulisan, karena harus mendukung domain tertentu (Pratama ada di beling). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Artinya, semuanya tergantung murni pada "tuan"? Selalu menggunakan "master" -waktu? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ya. Secara kiasan Anda bisa mengatakan: jam terus berdetak ketika ada rekaman di "master", di "Olog". </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Kami memiliki klien yang terhubung, dan dia tidak perlu tahu apa-apa tentang waktu? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Secara umum, Anda tidak perlu tahu apa-apa! Jika kita berbicara tentang cara kerjanya pada klien: di klien, ketika dia ingin menggunakan konsistensi Kausal, dia perlu membuka sesi. Sekarang semuanya ada di sana: baik transaksi dalam sesi dan mengambil hak ... Sesi adalah urutan peristiwa logis yang terjadi dengan klien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika dia membuka sesi ini dan mengatakan di sana bahwa dia menginginkan konsistensi Kausal (jika secara default sesi mendukung konsistensi Kausal), semuanya secara otomatis berfungsi. Pengemudi ingat kali ini dan meningkatkannya ketika menerima pesan baru. Itu mengingat jawaban mana yang mengembalikan yang sebelumnya dari server yang mengembalikan data. Permintaan berikut akan berisi afterCluster ("waktu lebih besar dari ini").</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klien tidak perlu tahu apa-apa! Ini benar-benar buram baginya. Jika orang menggunakan fitur ini, apa yang bisa saya lakukan? Pertama, Anda dapat dengan aman membaca sekunder: Anda dapat menulis di Pratama, dan membaca dari sekunder yang direplikasi secara geografis dan pastikan itu berfungsi. Pada saat yang sama, sesi yang direkam pada Pratama dapat ditransfer bahkan ke Sekunder, yaitu, Anda dapat menggunakan tidak hanya satu sesi, tetapi beberapa sesi. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Topik konsistensi akhir sangat terkait dengan lapisan ilmu Komputasi baru - Jenis Data Replika bebas-Konflik). Sudahkah Anda mempertimbangkan integrasi tipe data ini ke dalam basis data dan apa yang dapat Anda katakan tentangnya? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Pertanyaan bagus! CRDT masuk akal untuk konflik tulis: di MongoDB - master tunggal. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DI:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Saya punya pertanyaan dari para devops. Di dunia nyata, ada situasi Yesuit seperti ketika Kegagalan Bizantium terjadi, dan orang-orang jahat di dalam perimeter yang dilindungi mulai menempel pada protokol, mengirim paket kerajinan dengan cara khusus? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8d/m3/p5/8dm3p5em6rsqsv2ojzy-vdylffg.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Orang jahat di dalam perimeter seperti kuda Troya! Orang jahat di dalam perimeter dapat melakukan banyak hal buruk. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Jelas bahwa meninggalkan lubang di server, secara kasar, di mana Anda dapat menempelkan kebun binatang gajah dan meruntuhkan seluruh cluster selamanya ... Ini akan memakan waktu untuk pemulihan manual ... Ini, untuk membuatnya lebih halus, salah. Di sisi lain, ini aneh: dalam kehidupan nyata, dalam praktik, ada situasi ketika serangan internal serupa terjadi? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Karena saya jarang menemukan pelanggaran keamanan dalam kehidupan nyata, saya tidak bisa mengatakan - mungkin itu terjadi. Tetapi jika kita berbicara tentang filosofi pembangunan, maka kita berpikir demikian: kita memiliki batas yang menyediakan orang-orang yang membuat keamanan - itu adalah kastil, tembok; dan di dalam perimeter Anda dapat melakukan apa pun yang Anda inginkan. Jelas bahwa ada pengguna dengan kemampuan hanya melihat, dan ada pengguna dengan kemampuan untuk menghapus direktori. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bergantung pada haknya, kerusakan yang dapat dilakukan pengguna mungkin adalah mouse, atau mungkin gajah. Jelas bahwa pengguna dengan hak penuh dapat melakukan apa saja. Seorang pengguna yang tidak memiliki hak bahaya yang luas dapat menyebabkan lebih sedikit. Secara khusus, ia tidak dapat merusak sistem. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DI:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dalam perimeter aman, seseorang naik untuk membentuk protokol yang tidak terduga untuk server untuk mengatur server dengan kanker, dan jika Anda beruntung, maka seluruh cluster ... Apakah itu pernah terjadi begitu "baik"? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Saya belum pernah mendengar hal seperti itu. Fakta bahwa cara ini Anda dapat mengisi server bukanlah rahasia. Untuk mengisi di dalam, karena dari protokol, menjadi pengguna yang berwenang yang dapat menulis sesuatu seperti itu dalam pesan ... Sebenarnya, itu tidak mungkin, karena bagaimanapun itu akan diverifikasi. Dimungkinkan untuk menonaktifkan otentikasi ini untuk pengguna yang tidak ingin - ini adalah masalah mereka; secara kasar, mereka sendiri menghancurkan dinding dan Anda dapat menjejalkan seekor gajah di sana, yang akan menginjak-injak ... Secara umum, Anda dapat berpakaian sebagai tukang reparasi, datang dan dapatkan! </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DI:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Terima kasih atas laporannya. </font><font style="vertical-align: inherit;">Sergey (Yandex). </font><font style="vertical-align: inherit;">Dalam "Mong" ada konstanta yang membatasi jumlah anggota pemilih dalam Set Replika, dan konstanta ini adalah 7 (tujuh). </font><font style="vertical-align: inherit;">Mengapa ini konstan? </font><font style="vertical-align: inherit;">Mengapa ini bukan semacam parameter? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Set Replika kami juga memiliki 40 node. </font><font style="vertical-align: inherit;">Selalu ada mayoritas. </font><font style="vertical-align: inherit;">Saya tidak tahu versi mana ... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Di Perangkat Replika, Anda dapat menjalankan anggota yang tidak memberikan suara, tetapi memilih - maksimum 7. Bagaimana, dalam hal ini, mengalami penutupan jika kami memiliki Set Replika ditarik ke 3 pusat data? </font><font style="vertical-align: inherit;">Satu pusat data dapat dengan mudah dimatikan, dan mesin lain jatuh. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ini sudah agak di luar ruang lingkup laporan. </font><font style="vertical-align: inherit;">Ini pertanyaan umum. </font><font style="vertical-align: inherit;">Mungkin dengan begitu aku bisa memberitahunya.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9t/cr/ga/9tcrgaodiufisllhrktf_5iok_a.jpeg"><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/UnAprFMX1d4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sedikit iklan :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terima kasih untuk tetap bersama kami. Apakah Anda suka artikel kami? Ingin melihat materi yang lebih menarik? Dukung kami dengan melakukan pemesanan atau merekomendasikan kepada teman Anda, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloud VPS untuk pengembang mulai $ 4,99</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analog unik dari server entry-level yang diciptakan oleh kami untuk Anda: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seluruh kebenaran tentang VPS (KVM) E5-2697 v3 (6 Cores) 10GB DDR4 480GB SSD 1Gbps mulai dari $ 19 atau cara membagi server?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (opsi tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2 kali lebih murah di pusat data Equinix Tier IV di Amsterdam?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hanya kami yang memiliki </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV dari $ 199</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di Belanda!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - mulai dari $ 99! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baca tentang</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cara Membangun Infrastruktur Bldg. </font><font style="vertical-align: inherit;">kelas c menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</font></font></a></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id487626/index.html">Cara kerja sensor parkir dan cara menipunya</a></li>
<li><a href="../id487628/index.html">Diagnosis penuaan berdasarkan 9 tanda tanda penuaan</a></li>
<li><a href="../id487630/index.html">Algoritma Sederhana untuk Membuat Puzzle Lapangan (Bagian 1)</a></li>
<li><a href="../id487632/index.html">“Kolega, bernapas lebih tenang”: mengapa kebisingan kantor membuat kita gila - kita membahas penelitian</a></li>
<li><a href="../id487636/index.html">API yang akhirnya layak ditingkatkan dari Java 8. Bagian 2</a></li>
<li><a href="../id487640/index.html">Pengujian Otomasi Game</a></li>
<li><a href="../id487644/index.html">Dapatkan penawaran harga menggunakan Python</a></li>
<li><a href="../id487646/index.html">Bintang neutron tabung reaksi. Sonoluminescence</a></li>
<li><a href="../id487648/index.html">Ini bisa menjadi kerangka kerja javascript lainnya.</a></li>
<li><a href="../id487650/index.html">Berharap pada SDK dan jangan salah: Masalah gulungan bersarang di BottomSheetBehavior</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>