<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐟 🧔🏾 🌛 C＃和C＃之间的关系：REST，gRPC及其之间的所有内容 🧓🏻 🦎 👩🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在C＃客户端和C＃服务器之间进行通信的方法有很多。其中一些是可靠的，另一些则不是。有些非常快，有些则不是。重要的是要知道各种选项，以便您可以确定最适合您的选项。本文将讨论迄今为止最流行的技术以及为何如此广泛地使用它们。我们将讨论REST，gRPC及其之间的所有内容。
 
 最佳方案
 让我们看一下我...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C＃和C＃之间的关系：REST，gRPC及其之间的所有内容</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488102/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在C＃客户端和C＃服务器之间进行通信的方法有很多。</font><font style="vertical-align: inherit;">其中一些是可靠的，另一些则不是。</font><font style="vertical-align: inherit;">有些非常快，有些则不是。</font><font style="vertical-align: inherit;">重要的是要知道各种选项，以便您可以确定最适合您的选项。</font><font style="vertical-align: inherit;">本文将讨论迄今为止最流行的技术以及为何如此广泛地使用它们。</font><font style="vertical-align: inherit;">我们将讨论REST，gRPC及其之间的所有内容。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最佳方案</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下我们希望客户-服务器通信在现实世界中如何看待。我提出这样的事情：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">// on client side</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> server = <span class="hljs-keyword">new</span> MyServer(<span class="hljs-keyword">new</span> Uri(<span class="hljs-string">"https://www.myserver.com/"</span>);)
    <span class="hljs-keyword">int</span> sum = server.Calculator.SumNumbers(<span class="hljs-number">12</span>,<span class="hljs-number">13</span>); <font></font>
}</code></pre><br>
<pre><code class="cs hljs"><span class="hljs-comment">// on server side</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">CalculatorController</span> : <span class="hljs-title">Controller</span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">SumNumbers</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> a + b;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想要全面的Intellisense支持。</font><font style="vertical-align: inherit;">当我单击</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务器</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我希望Visual Studio显示所有控制器。</font><font style="vertical-align: inherit;">当我单击</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalculatorController</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我想查看所有动作方法。</font><font style="vertical-align: inherit;">我还想要最高的性能，非常低的网络负载和双向数据传输。</font><font style="vertical-align: inherit;">而且，我需要一个可靠的系统来应对版本控制，以便可以轻松部署客户端的新版本和服务器的新版本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
太多了？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，我在这里谈论的是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无状态</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API </font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这等效于C＃项目，其中只有两种类型的类：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅带有静态方法的静态类。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POCO类，其中只有类型为基本类型或其他POCO类的字段和属性。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在API中使用状态会带来复杂性，这是万恶之源。</font><font style="vertical-align: inherit;">因此，就本文而言，让我们使事物变得美丽而无状态。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传统REST方法</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">REST API</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出现在2000年代初期，并征服了Internet。</font><font style="vertical-align: inherit;">现在，这是迄今为止创建Web服务的最流行方法。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">REST</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为从客户端到服务器的请求</font><font style="vertical-align: inherit;">定义了一组固定的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POST</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PUT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DELETE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对于每个请求，我们都会得到一个包含有效负载（通常为JSON）的响应。</font><font style="vertical-align: inherit;">当请求是POST或PUT请求时，请求会将参数包含在请求本身中或作为有效负载（通常为JSON）。</font><b><font style="vertical-align: inherit;">RESTful API</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
标准</font><font style="vertical-align: inherit;">定义了以下规则（您实际上并不需要）：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET用于获取资源</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PUT用于更改资源的状态。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POST用于创建资源。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DELETE用于删除资源。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果到目前为止您还不熟悉REST，那么上面的解释可能无济于事，因此这里是一个示例。</font><font style="vertical-align: inherit;">.NET具有内置的REST支持。</font><font style="vertical-align: inherit;">实际上，默认情况下，ASP.NET Web API是REST Web服务。</font><font style="vertical-align: inherit;">这是典型的ASP.NET客户端和服务器的外观：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在服务器上：</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">Route(<span class="hljs-meta-string">"People"</span>)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PeopleController</span> : <span class="hljs-title">Controller</span><font></font>
{<font></font>
    [<span class="hljs-meta">HttpGet</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">GetPersonById</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> id</span>)</span><font></font>
    {<font></font>
        Person person = _db.GetPerson(id);<font></font>
        <span class="hljs-keyword">return</span> person;<span class="hljs-comment">//Automatically serialized to JSON</span><font></font>
    }<font></font>
} </code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在客户端上：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> HttpClient();
<span class="hljs-keyword">string</span> resultJson = <span class="hljs-keyword">await</span> client.GetStringAsync(<span class="hljs-string">"https://www.myserver.com/People/GetPersonById?id=123"</span>);<font></font>
Person person = JsonConvert.DeserializeObject&lt;Person&gt;(resultJson);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
REST非常方便，但不适合最佳方案。</font><font style="vertical-align: inherit;">因此，让我们看看是否可以做得更好。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改装</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReFit不能替代</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> REST。</font><font style="vertical-align: inherit;">相反，它建立在REST之上，并允许我们像调用简单方法一样调用服务器端点。</font><font style="vertical-align: inherit;">这是通过在客户端和服务器之间共享接口来实现的。</font><font style="vertical-align: inherit;">在服务器端，您的控制器将实现接口：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMyEmployeeApi</span><font></font>
{<font></font>
    [<span class="hljs-meta">Get(<span class="hljs-meta-string">"/employee/{id}"</span>)</span>]
    <span class="hljs-function">Task&lt;Employee&gt; <span class="hljs-title">GetEmployee</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> id</span>)</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后在客户端，您将需要启用相同的接口并使用以下代码：</font></font><br>
<br>
<pre><code class="cs hljs">
<span class="hljs-keyword">var</span> api = RestService.For&lt;IMyEmployeeApi&gt;(<span class="hljs-string">"https://www.myserver.com"</span>);
<span class="hljs-keyword">var</span> employee = <span class="hljs-keyword">await</span> api.GetEmployee(<span class="hljs-string">"abc"</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
很简单。</font><font style="vertical-align: inherit;">除了几个NuGet程序包外，无需运行复杂的自动化程序或使用第三方工具。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这越来越接近最佳方案。</font><font style="vertical-align: inherit;">现在，我们有了IntelliSense以及客户端和服务器之间的可靠合同。</font><font style="vertical-align: inherit;">但是还有另一种选择在某些方面甚至更好。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">昂首阔步</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
像ReFit一样，Swagger也建立在REST之上。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenAPI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swagger</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是REST API规范。</font><font style="vertical-align: inherit;">它以简单的JSON文件描述了REST Web服务。</font><font style="vertical-align: inherit;">这些文件是Web服务API架构。</font><font style="vertical-align: inherit;">它们包括：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API中的所有路径（URL）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个路径的预期操作（GET，POST等）。</font><font style="vertical-align: inherit;">每个路径可以处理不同的操作。</font><font style="vertical-align: inherit;">例如，相同的路径</font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mystore.com/Product</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以接受添加产品的POST操作和返回产品的GET操作。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个路径和操作的预期参数。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个路径的预期答案。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个参数和响应对象的类型。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此JSON文件本质上是客户端与服务器之间的合同。</font><font style="vertical-align: inherit;">这是一个示例文件，描述了一个名为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swagger Petstore</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的Web服务</font><font style="vertical-align: inherit;">（为清楚起见，我删除了一些部分）：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Json模式</font></font></b><div class="spoiler_text"><pre><code class="json hljs">{ 
   <span class="hljs-attr">"swagger"</span>:<span class="hljs-string">"2.0"</span>,
   <span class="hljs-attr">"info"</span>:{ 
      <span class="hljs-attr">"version"</span>:<span class="hljs-string">"1.0.0"</span>,
      <span class="hljs-attr">"title"</span>:<span class="hljs-string">"Swagger Petstore"</span>,
      <span class="hljs-attr">"description"</span>:<span class="hljs-string">"A sample API that uses a petstore as an example to demonstrate features in the swagger-2.0 specification"</span>,<font></font>
   },<font></font>
   <span class="hljs-attr">"host"</span>:<span class="hljs-string">"petstore.swagger.io"</span>,
   <span class="hljs-attr">"basePath"</span>:<span class="hljs-string">"/api"</span>,
   <span class="hljs-attr">"schemes"</span>:[ 
      <span class="hljs-string">"http"</span><font></font>
   ],<font></font>
   <span class="hljs-attr">"consumes"</span>:[ 
      <span class="hljs-string">"application/json"</span><font></font>
   ],<font></font>
   <span class="hljs-attr">"produces"</span>:[ 
      <span class="hljs-string">"application/json"</span><font></font>
   ],<font></font>
   <span class="hljs-attr">"paths"</span>:{ 
      <span class="hljs-attr">"/pets"</span>:{ 
         <span class="hljs-attr">"get"</span>:{ 
            <span class="hljs-attr">"description"</span>:<span class="hljs-string">"Returns all pets from the system that the user has access to"</span>,
            <span class="hljs-attr">"operationId"</span>:<span class="hljs-string">"findPets"</span>,
            <span class="hljs-attr">"produces"</span>:[ 
               <span class="hljs-string">"application/json"</span>,
               <span class="hljs-string">"application/xml"</span>,<font></font>
            ],<font></font>
            <span class="hljs-attr">"parameters"</span>:[ <font></font>
               { <font></font>
                  <span class="hljs-attr">"name"</span>:<span class="hljs-string">"tags"</span>,
                  <span class="hljs-attr">"in"</span>:<span class="hljs-string">"query"</span>,
                  <span class="hljs-attr">"description"</span>:<span class="hljs-string">"tags to filter by"</span>,
                  <span class="hljs-attr">"required"</span>:<span class="hljs-literal">false</span>,
                  <span class="hljs-attr">"type"</span>:<span class="hljs-string">"array"</span>,
                  <span class="hljs-attr">"items"</span>:{ 
                     <span class="hljs-attr">"type"</span>:<span class="hljs-string">"string"</span><font></font>
                  },<font></font>
                  <span class="hljs-attr">"collectionFormat"</span>:<span class="hljs-string">"csv"</span><font></font>
               },<font></font>
               { <font></font>
                  <span class="hljs-attr">"name"</span>:<span class="hljs-string">"limit"</span>,
                  <span class="hljs-attr">"in"</span>:<span class="hljs-string">"query"</span>,
                  <span class="hljs-attr">"description"</span>:<span class="hljs-string">"maximum number of results to return"</span>,
                  <span class="hljs-attr">"required"</span>:<span class="hljs-literal">false</span>,
                  <span class="hljs-attr">"type"</span>:<span class="hljs-string">"integer"</span>,
                  <span class="hljs-attr">"format"</span>:<span class="hljs-string">"int32"</span><font></font>
               }<font></font>
            ],<font></font>
            <span class="hljs-attr">"responses"</span>:{ 
               <span class="hljs-attr">"200"</span>:{ 
                  <span class="hljs-attr">"description"</span>:<span class="hljs-string">"pet response"</span>,
                  <span class="hljs-attr">"schema"</span>:{ 
                     <span class="hljs-attr">"type"</span>:<span class="hljs-string">"array"</span>,
                     <span class="hljs-attr">"items"</span>:{ 
                        <span class="hljs-attr">"$ref"</span>:<span class="hljs-string">"#/definitions/Pet"</span><font></font>
                     }<font></font>
                  }<font></font>
               },<font></font>
...<font></font>
 </code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下这带来的后果。</font><font style="vertical-align: inherit;">使用上面的JSON文件，您可以潜在地创建具有完整IntelliSense的C＃客户端。</font><font style="vertical-align: inherit;">最后，您知道所有的路径，操作，它们期望的参数，参数的类型，答案是什么。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有几种工具可以做到这一点。</font><font style="vertical-align: inherit;">在服务器端，可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swashbuckle.AspNetCore</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将Swagger添加到ASP.NET并创建指定的JSON文件。</font><font style="vertical-align: inherit;">对于客户端，您可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swagger-codegen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AutoRest</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以JSON格式处理这些文件并生成客户端。</font><font style="vertical-align: inherit;">让我们看一个如何做到这一点的例子：</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将Swagger添加到ASP.NET Server</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先添加NuGet </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swashbuckle.AspNetCore</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">软件包</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureServices中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，注册Swagger生成器：</font></font><br>
<br>
<pre><code class="cs hljs">services.AddSwaggerGen(options =&gt; <font></font>
	options.SwaggerDoc(<span class="hljs-string">"v1"</span>, <span class="hljs-keyword">new</span> OpenApiInfo {Title = <span class="hljs-string">"My Web API"</span>, Version = <span class="hljs-string">"v1"</span>}));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font><b><font style="vertical-align: inherit;">Configure</font></b><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startup.cs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">中，</font><font style="vertical-align: inherit;">添加：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cs hljs">app.UseSwagger();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，控制器内部的操作方法必须标记为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[HttpXXX]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[FromXXX]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性：</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">HttpPost</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AddEmployee</span>(<span class="hljs-params">[FromBody]Employee employee</span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//...</span><font></font>
}<font></font>
 <font></font>
[<span class="hljs-meta">HttpGet</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;Employee&gt; <span class="hljs-title">Employee</span>(<span class="hljs-params">[FromQuery]<span class="hljs-keyword">string</span> id</span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于服务器端来说是如此简单。</font><font style="vertical-align: inherit;">项目</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动时</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">将生成</font><font style="vertical-align: inherit;">一个</font><b><font style="vertical-align: inherit;">swagger.json</font></b><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">，可用于生成客户端。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用AutoRest从Swagger生成客户端</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要开始使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AutoRest</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，与安装</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NPM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NPM安装-g autorest</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">安装后，您将需要使用AutoRest命令行界面从</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swagger.json</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件创建C＃客户端</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个例子：</font></font><br>
<br>
<pre><code class="plaintext hljs">autorest --input-file="./swagger.json" --output-folder="GeneratedClient" --namespace="MyClient" --override-client-name="MyClient" --csharp
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这将</font><font style="vertical-align: inherit;">使用生成的C＃文件</font><font style="vertical-align: inherit;">创建一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeneratedClient</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件夹</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">请注意，名称空间和客户端名称已重新定义。</font><font style="vertical-align: inherit;">将此文件夹添加到Visual Studio中的客户端项目中，如下所示。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ma/mt/7r/mamt7rut1jz53wgtyofocyivlec.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您将需要安装</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft.Rest.ClientRuntime</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NuGet软件包，因为生成的代码取决于该软件包。</font><font style="vertical-align: inherit;">安装后，您可以像使用常规C＃类一样使用API​​：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> MyClient();<font></font>
Employee employee = client.Employee(id: <span class="hljs-string">"abc"</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以在</font><font style="vertical-align: inherit;">AutoRest </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文档中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解一些细微之处</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">而且您将需要使该过程自动化，因此我建议阅读</font><font style="vertical-align: inherit;">Patrick Svensson的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以获取一些有用的提示，以及</font><font style="vertical-align: inherit;">Peter Yausovets的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这篇文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Swagger的问题在于JSON文件是在运行时创建的，因此使CI / CD处理的自动化有些困难。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传统REST vs Swagger vs ReFit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
选择时，请注意以下几点。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您有一个非常简单的私有REST API，则可能不必担心客户端的生成和通用接口。</font><font style="vertical-align: inherit;">一项小任务并不能证明付出额外的努力。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swagger支持多种语言，而ReFit仅支持.NET。</font><font style="vertical-align: inherit;">Swagger还是许多工具，测试，自动化工具和用户界面工具的基础。</font><font style="vertical-align: inherit;">如果要创建大型公共API，这可能是最佳选择。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swagger比ReFit复杂得多。</font><font style="vertical-align: inherit;">使用ReFit，只需在服务器和客户端项目中添加一个接口即可。</font><font style="vertical-align: inherit;">另一方面，使用ReFit，您将必须为每个控制器创建新接口，而Swagger将自动处理此接口。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是在决定某项之前，请检查第四个选项，它与REST无关。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPC</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（gRPC-远程过程调用）是Google开发的开源远程过程调用系统。</font><font style="vertical-align: inherit;">从某种意义上说，这有点像REST，它提供了一种从客户端向服务器发送请求的方式。</font><font style="vertical-align: inherit;">但这是非常不同的，这是相同点和不同点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像REST一样，gRPC是独立于语言的。</font><font style="vertical-align: inherit;">有适用于所有流行语言的工具，包括C＃。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPC基于合同，并使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.proto</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件定义合同。</font><font style="vertical-align: inherit;">这有点类似于Swagger </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swagger.json</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和常见的ReFit接口。</font><font style="vertical-align: inherit;">可以从这些文件中生成任何编程语言的客户端。</font></font></li>
<li>gRPC    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Protocol Buffer (Protobuf)</a>.    REST,     JSON  XML.    , , .</li>
<li>gRPC        HTTP/2.      .   ,  REST   HTTP 1.x ( HTTP 1.1).</li>
<li>HTTP 1.1  TCP- ()   ,   HTTP/2   .</li>
<li>HTTP/2    .  ,   TCP-    .     ,    ,   HTTP 1.1.</li>
<li>gRPC    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有两种使用gRPC的方法。</font><font style="vertical-align: inherit;">对于.NET Core 3.0，有一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于.NET</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库的完全托管的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">gRPC</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您也可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPC C＃</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这并不意味着</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPC for .NET会</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">替换</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPC C＃</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们来看一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于.NET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的更新</font><b><font style="vertical-align: inherit;">gRPC</font></b><font style="vertical-align: inherit;">的示例</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET服务器端的GRPC</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这不是指南，而是关于期望的一般概念。</font><font style="vertical-align: inherit;">这是一个示例控制器在gRPC中的外观：</font></font><br>
<br>
<pre><code class="cs hljs">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GreeterService</span> : <span class="hljs-title">Greeter.GreeterBase</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Task&lt;HelloReply&gt; <span class="hljs-title">SayHello</span>(<span class="hljs-params">HelloRequest request,
        ServerCallContext context</span>)</span><font></font>
    {<font></font>
        _logger.LogInformation(<span class="hljs-string">"Saying hello to {Name}"</span>, request.Name);
        <span class="hljs-keyword">return</span> Task.FromResult(<span class="hljs-keyword">new</span> HelloReply <font></font>
        {<font></font>
            Message = <span class="hljs-string">"Hello "</span> + request.Name<font></font>
        });<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您需要</font><font style="vertical-align: inherit;">在</font><b><font style="vertical-align: inherit;">Startup.cs</font></b><font style="vertical-align: inherit;">文件中</font><font style="vertical-align: inherit;">添加以下内容以进行</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cs hljs"><font></font>
app.UseEndpoints(endpoints =&gt;<font></font>
{<font></font>
    endpoints.MapGrpcService&lt;GreeterService&gt;();<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该API在项目的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.proto</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">中进行了描述</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">syntax = "proto3";<font></font>
 <font></font>
service Greeter {<font></font>
  rpc SayHello (HelloRequest) returns (HelloReply);<font></font>
}<font></font>
 <font></font>
message HelloRequest {<font></font>
  string name = 1;<font></font>
}<font></font>
 <font></font>
message HelloReply {<font></font>
  string message = 1;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.proto</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件已添加到.csproj文件中：</font></font><br>
<br>
<pre><code class="cs hljs">&lt;ItemGroup&gt;<font></font>
  &lt;Protobuf Include=<span class="hljs-string">"Protos\greet.proto"</span>/&gt;<font></font>
&lt;/ItemGroup&gt;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET客户端的GRPC</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
客户端是从</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.proto</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">生成的</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">代码本身非常简单：</font></font><br>
<br>
<pre><code class="cs hljs">
<span class="hljs-keyword">var</span> channel = GrpcChannel.ForAddress(<span class="hljs-string">"https://localhost:5001"</span>);
<span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Greeter.GreeterClient(channel);<font></font>
 <font></font>
<span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> client.SayHello(
    <span class="hljs-keyword">new</span> HelloRequest { Name = <span class="hljs-string">"World"</span> });<font></font>
 <font></font>
Console.WriteLine(response.Message);<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPC与REST</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GRPC听起来不错。它在引擎盖下更快，更容易。那么我们都应该从REST切换到gRPC吗？答案是，这</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取决于</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。以下是一些注意事项：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据我的经验，使用gRPC和ASP.NET的工作仍然很少。成熟的REST支持将使您更好。就合同通信而言，这很好，除了在REST中有我们已经讨论过的类似替代方案：Swagger和ReFit。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最大的优势是性能。在大多数情况下，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据这些条件</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，gRPC会快得多。特别是对于Protobuf序列化真正重要的大型有效负载。这意味着对于高负载的服务器而言，这是一个巨大的优势。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在大型ASP.NET应用程序中从REST迁移到gRPC将很困难。</font><font style="vertical-align: inherit;">但是，如果您具有基于微服务的体系结构，那么逐步完成此过渡将变得容易得多。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他沟通方式</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我根本没有提到其他几种交流方式，但是值得一提的是它们存在：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GraphQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是Facebook开发的一种API查询语言。</font><font style="vertical-align: inherit;">这允许客户端从服务器确切地请求它需要的数据。</font><font style="vertical-align: inherit;">因此，您只能在服务器上创建一个端点，这将非常灵活，并且仅返回客户端需要的数据。</font><font style="vertical-align: inherit;">近年来，GraphQL变得非常流行。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">TcpClient</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">TcpListener</a> ( <b>System.Net.Sockets</b>)     TCP.  ,        .      ,         ASP.NET      API.</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">UdpClient </a>     UDP. TCP      ,   UDP   . TCP ,     ,  UDP — .  UDP      ,       ,      .   :  ,       IP (VoIP).</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WCF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一种旧技术，主要使用基于SOAP的进程间通信。</font><font style="vertical-align: inherit;">这是一个我不会讨论的庞大框架，我只能说它在REST和JSON负载中已经失去了流行性。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就这样。</font><font style="vertical-align: inherit;">我希望这篇文章有趣！</font><font style="vertical-align: inherit;">所有人的好代码！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN488082/index.html">简而言之：.NET中的Async / Await最佳实践</a></li>
<li><a href="../zh-CN488088/index.html">哈伯如何与国家机构和其他申请人互动。多年来的透明度报告</a></li>
<li><a href="../zh-CN488092/index.html">黑客马拉松。如何充分利用并生存</a></li>
<li><a href="../zh-CN488096/index.html">400克 从变速器侧面看。ZR / ZR +</a></li>
<li><a href="../zh-CN488098/index.html">如何从模板创建Django项目</a></li>
<li><a href="../zh-CN488104/index.html">DBA：查找无用的索引</a></li>
<li><a href="../zh-CN488108/index.html">Azure中的SAP HANA实验室</a></li>
<li><a href="../zh-CN488112/index.html">了解Python中的迭代器</a></li>
<li><a href="../zh-CN488116/index.html">有关游戏平衡的五个重要课程</a></li>
<li><a href="../zh-CN488118/index.html">Haxe冬季状态报告</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>