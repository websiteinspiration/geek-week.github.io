<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏻 🚣🏽 💅🏼 U2Fの信頼性が高く、安全で用途の広いバックアップ ✊🏾 👆🏿 🔰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私はU2Fによって提供されるセキュリティのレベルが本当に好きですが、セキュリティとともに、回復計画を検討する必要があります。メインのU2Fトークンで何かが発生した場合、最も重要なアカウントへのアクセスを失うことは深刻な問題です。同時に、U2Fが提供するセキュリティを危険にさらすバックアップの使用は避...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>U2Fの信頼性が高く、安全で用途の広いバックアップ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474300/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はU2Fによって提供されるセキュリティのレベルが本当に好きですが、セキュリティとともに、回復計画を検討する必要があります。</font><font style="vertical-align: inherit;">メインのU2Fトークンで何かが発生した場合、最も重要なアカウントへのアクセスを失うことは深刻な問題です。</font><font style="vertical-align: inherit;">同時に、U2Fが提供するセキュリティを危険にさらすバックアップの使用は避けたいと思います。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ede/ae9/0a7/edeae90a73189ed879d63056d56afda5.jpg" alt="ユビキー"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的なバックアップ方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、バックアップ用に2つ目の独立したU2Fトークンを保持することがベストプラクティスです。</font><font style="vertical-align: inherit;">このトークンは、各サービスに手動で追加して、「安全な」場所に保管する必要があります。</font><font style="vertical-align: inherit;">別の一般的な方法は、U2F以外の方法をバックアップ（OTP、回復コード）として使用することです。</font><font style="vertical-align: inherit;">正直なところ、これらの方法はどちらも貧弱です。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独立したU2Fトークン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、新しいサービスに登録するたびに、両方のトークンを追加する必要があります。</font><font style="vertical-align: inherit;">この事実は多くの問題を引き起こします：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックアップトークンは、かなり簡単にアクセスできる必要があります。</font><font style="vertical-align: inherit;">キーチェーンを持っていないのですが、すぐに手に入れられるはずなので、家に置いておくよりはいいものが思いつきません。</font><font style="vertical-align: inherit;">金庫がどれほど本物であるか、金庫が使用されていても、長い間話すことができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外出中にサービスに登録する必要がある場合、バックアップトークンを追加できません。</font><font style="vertical-align: inherit;">したがって、後で追加する必要があることを覚えておく必要があります。これが発生するまで、バックアップはありません。</font><font style="vertical-align: inherit;">最悪の場合、私は彼のことを完全に忘れることができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私が家にいるとき、私のトークンは両方とも同じ場所にあります。</font><font style="vertical-align: inherit;">このバックアップ方法は理想とはほど遠いです。1つのインシデント（破壊または盗難）が原因で両方のトークンが利用できない場合があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックアップトークンが自宅に保存されているという事実は完全に明白です。</font><font style="vertical-align: inherit;">誰かが本当に私のトークンにアクセスしたい場合、彼はすでにどこでそれを探すべきか知っています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非ユニバーサルな方法：すべてのサービスでアカウントに複数のキーを追加できるわけではありません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、この「模範的実践」はあまり信頼できず、むしろ負担がかかります。</font><font style="vertical-align: inherit;">別の一般的な方法を見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックアップとしての非U2Fメソッド</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OTP：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OTPをバックアップとして使用することは、メインの2FA方法として使用するよりも優れていますが、OTPを使用しているという事実は、どういうわけか追加の攻撃経路を開きます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電話は故障し、紛失、盗難に遭い、紛失後に権限のない人の手に渡る可能性がある場合は、すべてのアカウントでこのバックアップを手動で呼び出す必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は常に電話</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> U2Fトークンを</font><font style="vertical-align: inherit;">携帯</font><font style="vertical-align: inherit;">しています。そのため、このようなバックアップ方法は理想とはほど遠いです。両方をすぐに失う可能性は、バックアップを個別に保存した場合よりもはるかに高くなります。</font><font style="vertical-align: inherit;">ただし、このアイテムは、たとえば、サーバーに暗号化されたバックアップを保存するAuthyを使用することで、わずかに補正できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非ユニバーサルな方法：残念ながら、カスタムアプリケーションのみを提供し、標準のTOTPをサポートしないサービスは十分にあります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回復コード：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回復コードは安全な場所に保管する必要があります。</font><font style="vertical-align: inherit;">繰り返しますが、この「安全な場所」はおそらく私の家であり、別のU2Fトークンとほぼ同じ問題があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">繰り返しますが、非ユニバーサルな方法：各サービスには独自のバックアップ方法があります</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、要約すると、これらの方法はすべて、普遍的ではなく、負担が大きく、安全性も高くありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最良のバックアップ方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、現状を十分に批判した後、ようやく本当のことを言いたいと思います。</font><font style="vertical-align: inherit;">私は2つのU2Fトークンを必要としています：プライマリとバックアップですが、それらは特定の方法で構成する必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意のデバイスにメイントークンを登録すると、このサービスのバックアップトークンが自動的に機能するようになります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスでバックアップトークンを使用するとすぐに、メイントークンはこのサービスでは無効になります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
U2Fのフレームワーク内でのこれの技術的な実現可能性について説明する前に、それが優れている理由と使用方法について説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜそれが素晴らしいのですか</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の独立したバックアップトークンの批判を見ると、この方法のすべての欠点が解消されていることがわかります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックアップトークンに簡単にアクセスできなくなります。</font><font style="vertical-align: inherit;">極端な例としては、トークンをレンガの壁に埋め込む、または庭などに1メートル半を埋め込む、などがあります。</font><font style="vertical-align: inherit;">冗談ではありません、私はそれに行く準備ができています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自分がどこにいるかに関係なく、サービスにサインアップした場合、このサービスにバックアップトークンを追加するために何もする必要はありません。</font><font style="vertical-align: inherit;">私はメイントークンを使用するだけで、バックアップがあることを知って安心しています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部外者にとって、私のバックアップトークンがどこにあるかは完全に不明です。</font><font style="vertical-align: inherit;">それが存在することを知っていても、自分で見つけようとしても意味がありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とても安全です。</font><font style="vertical-align: inherit;">メイントークンに問題が発生しても、同じ事件がバックアップトークンに影響を与える可能性はほとんどありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは普遍的です。</font><font style="vertical-align: inherit;">このバックアップ方法は、他にこのサービスがサポートするものに関係なく、U2Fをサポートするすべてのサービスで機能します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、メイントークンで何か悪いことが実際に発生した場合は、次のようにします。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックアップトークンを掘り出す/不明瞭にする。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U2Fを使用してすべてのサービスを認証し、メイントークンをキャンセルします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいトークンのペアを注文し、受け取り次第、すべてのサービスに新しいメイントークンを追加し、古いトークンを取り消します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少なくとも個人的には、この戦略は、高レベルのセキュリティと簡単なバックアップのための大きな妥協案です。</font><font style="vertical-align: inherit;">他のどの方法よりも安全で信頼性が高いです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U2Fプロトコルの概要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装について話す前に、U2Fがどのように機能するかをある程度理解する必要があります。</font><font style="vertical-align: inherit;">ほとんどのメーカーは、それは次の通り販売（すべてではない以下の標準に存在しているの、といくつかのものは実装の詳細ですが、ほとんどの既存の実装は、私の知る限り、ように動作します）：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
U2Fトークンでプログラムされている</font></font><code>device_secret</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32ビットと一緒に、</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、とすることができます増分のみ。</font><font style="vertical-align: inherit;">U2Fトークンをサービスに登録すると、次のことが起こります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブラウザはU2Fデバイス</font></font><code>AppID</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（実際にはドメイン名）に</font><font style="vertical-align: inherit;">送信し</font><font style="vertical-align: inherit;">ます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">装置は乱数（</font></font><code>nonce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">生成し、</font><font style="vertical-align: inherit;">それを彼と組み合わせ</font></font><code>AppID</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それを</font></font><code>device_secret</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーとして</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">てすべてのHMAC-SHA256を通過さ</font><font style="vertical-align: inherit;">せ</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">結果のハッシュがこの特定のサービスの秘密キーになり</font></font><code>service_private_key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font></font><code>service_private_key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、公開鍵が生成され</font></font><code>service_public_key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デバイスは</font></font><code>AppID</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再度</font><font style="vertical-align: inherit;">受け取り</font><font style="vertical-align: inherit;">、と組み合わせて</font><font style="vertical-align: inherit;">、キーとして</font></font><code>service_private_key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><code>device_secret</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">てHMAC-SHA256を再び通過し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">以前に生成さ</font></font><code>MAC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れ</font></font><code>nonce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た</font><font style="vertical-align: inherit;">結果（</font><font style="vertical-align: inherit;">）は</font><font style="vertical-align: inherit;">になり</font></font><code>key_handle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デバイスは、送信</font></font><code>key_handle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>service_public_key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背中ブラウザに、ブラウザは、将来の認証のためのデータを格納するサービスを、送信します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後の認証は次のように行われます。</font></font><br>
<br>
<ul>
<li>  <code>challenge</code> (  )       <code>key_handle</code> (   <code>nonce</code>  <code>MAC</code>).     ,   <code>AppID</code> (..  );</li>
<li>,  <code>nonce</code>  <code>AppID</code>,  <code>service_private_key</code>    ,      ;</li>
<li>  <code>MAC</code>        ,     <code>MAC</code>   ,   <code>nonce</code>  ,  , <code>service_private_key</code> ;</li>
<li>  <code>counter</code>;</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デバイス記号</font></font><code>challenge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>AppID</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">助けを借りて</font></font><code>service_private_key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、得られた署名（送信</font></font><code>signature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する）</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスにさらにこのデータを転送するブラウザを、</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>signature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">登録後、</font><font style="vertical-align: inherit;">サービスチェック</font><font style="vertical-align: inherit;">を利用できるようになります</font></font><code>service_public_key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">また、ほとんどのサービス</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は前の値よりも大きい</font><font style="vertical-align: inherit;">ことを確認し</font><font style="vertical-align: inherit;">ます（これが最初の認証でない場合）。</font><font style="vertical-align: inherit;">このテストの目的は、U2Fデバイスのクローンにアクセスできないようにすることです。</font><font style="vertical-align: inherit;">その結果、</font><font style="vertical-align: inherit;">以前の値</font><font style="vertical-align: inherit;">と</font></font><code>signature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一致し</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それよりも大きい場合、認証は正常に完了したと見なされ、サービスは新しい値を保存します</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ディスカッションに直接関連する詳細の概要を説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">興味のある詳細</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つ目は、デバイスが</font></font><code>service_private_key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスごとに</font><font style="vertical-align: inherit;">保存しない</font><font style="vertical-align: inherit;">ことです。代わりに</font></font><code>service_private_key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、HMAC-SHA256を使用して毎回</font><font style="vertical-align: inherit;">表示されます</font><font style="vertical-align: inherit;">。これは私たちにとって非常に重要です。明らかに、各デバイスがサービスごとに個別のキーを個別に格納する場合、その後はこのデバイスのみが認証できます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ちなみに、これはU2Fの要件ではありません。U2Fはキーの格納方法を正確に示していないため、初期のU2F実装では、実際には各サービスのキーを個別に格納していました。このアプローチには、デバイスを使用できるサービスの数が制限されるという欠点があります。派生</font></font><code>service_private_key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はこの欠点を取り除きます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
第二に、デバイスは</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クローンを防止する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見すると、これは</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">議論されたバックアップ戦略を実装することを許可していない</font><font style="vertical-align: inherit;">ように見えるかもしれ</font><font style="vertical-align: inherit;">ません（少なくとも、私が解決策を見つけようとしたとき、私には思えました）。</font><font style="vertical-align: inherit;">今から説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本旨</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアは次のとおりです。本番段階では、2つのトークンが同じになるようにプログラムし</font></font><code>device_secret</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ますが、バックアップトークンにはいくつかの修正が必要</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。通常のトークンのように純粋な形</font><font style="vertical-align: inherit;">で使用する代わりに、いくつかの</font><font style="vertical-align: inherit;">トークンを追加する</font><font style="vertical-align: inherit;">必要があります。</font><font style="vertical-align: inherit;">定数k </font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。たとえば、32ビットの範囲の半分、つまり約</font></font><code>2 000 000 000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それは合理的に見えます：私は、人生の間に多くの認証を使い果たす可能性はほとんどありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、それだけです。シンプルで効果的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようにプログラムされた2つのトークンがあるため、バックアップトークンを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アクセスできない場所で、決して触れないでください。</font><font style="vertical-align: inherit;">ひどいことが起こってメイントークンにアクセスできなくなっても、バックアップトークンにアクセスできます。メイントークンを登録したすべてのサービスですぐに使用できます。</font><font style="vertical-align: inherit;">バックアップには同じもの</font></font><code>device_secret</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり、それ</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は非常に大きな数字</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">始まります。これは、これからの人生では得られません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、私は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トークンをクローン化することを提案していない</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という事実に注意を向け</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">2つのトークンは同じですが</font></font><code>device_secret</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、カウンターが異なります。プログラミング後</font></font><code>device_secret</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、デバイスから</font><font style="vertical-align: inherit;">トークン</font><font style="vertical-align: inherit;">を取得したり、他の方法でクローンを作成したりすることはできません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カウンターについて</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意深い読者は、次のセキュリティ問題があることに気づくかもしれません：攻撃者がメイントークンにアクセスし、どういうわけか2,000,000,000認証を開始した場合はどうなりますか？その後、バックアップトークンがこのサービスで使用された後でも、サービスにアクセスできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、この問題には簡単な解決策があります。いずれの場合も、カウンタはハードウェアで実装されている必要があり（おそらく一部の暗号化プロセッサ上）、安全に実装するには、このハードウェアカウンタの範囲が32ビット未満である必要があります。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATECC508Aの場合</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カウンターは2097151までしかカウントできないため、カウンターに追加された定数をカウンターの最大値より大きい値に設定することで、メイントークンがバックアップトークンのカウンターにカウントされないようにすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明確にするために、私たちのU2FトークンがATECC508Aを使用し、ATECC508A内のカウンターをと表すとしましょう</font></font><code>hw_counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的にトークンは、計算に使用し</font></font><code>hw_counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックアップトークンは、次の計算に使用します</font></font><code>hw_counter + 2000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"></font><code>hw_counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗号化プロセッサの内部の</font><font style="vertical-align: inherit;">
実数は変更しないことに注意してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">代わりに、0から2097151までカウントします。代わりに、カウンター値を取得する必要があるたびに</font></font><code>hw_counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ATECC508Aから読み取り、定数を追加して返します（U2Fのさらなる計算のため）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、メイントークンのカウンター値の範囲は[0、2097151]になり、バックアップトークンのカウンター値の範囲は[2000000000、2002097151]になります。</font><font style="vertical-align: inherit;">これらの範囲が重複しないという事実により、バックアップを使用するときにメイントークンが確実にキャンセルされます（サービスがを使用している場合、</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェックしたメインサービスがそれを使用します）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際の実装</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が知っているU2Fトークンのメーカーは、今日必要なカスタマイズをサポートしていません。しかし幸い、U2Fトークンのオープンソース実装があります：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SoloKeys</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は1年前にオリジナルの記事（英語）を書きましたが、この部分は少し古くなっています。SoloKeysはプロトタイピングの段階にあり、プロジェクトの以前の反復である</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u2f-zeroを使用しました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。したがって、u2f-zeroデバイスを入手する唯一の方法は自分ではんだ付けすることであり、これを行うことはほとんどお勧めできないため（githubに指示がありますが）、この部分を今は翻訳しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それにもかかわらず、u2f-zeroの必要な変更の詳細はすべて、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元の記事に記載さ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れて</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">います</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手がソロキーに届いたら、修正の手順を書きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どういうわけか、これは、信頼できるバックアップを備えたU2Fトークンを取得するために今日知っている唯一の方法です。</font><font style="vertical-align: inherit;">複数のサービス（少なくともgoogleとgithub）をチェックすると、それが機能することがわかりました。サービスにメイントークンを登録することで、バックアップを使用することもできます。バックアップを最初に使用した後、メイントークンは機能しなくなります。</font><font style="vertical-align: inherit;">Awwwwwww。</font><font style="vertical-align: inherit;">&lt;3</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このバックアップ戦略はクールですが、u2f-zeroまたはsolokeyを使用した具体的な実装についてはよくわかりません。この道はあなたが望むものを得る唯一の道なので、私はその道を進みました。しかし、攻撃者がU2Fデバイスに物理的にアクセスしていると仮定すると、デバイスのハッキング（つまり、デバイス</font></font><code>device_secret</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からの</font><font style="vertical-align: inherit;">ハッキング</font><font style="vertical-align: inherit;">）がYubikeyまたは他の主要メーカーの場合ほど複雑になるかどうかはわかりません。 solokeyの作者は「セキュリティのレベルは現代の車のキーと同じです」と主張していますが、これを確認するための調査は行いませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、正直なところ、私はそれほど心配していません。攻撃者がトークンを返すことを意図せずに単にトークンを盗む場合、それを破壊する複雑さは問題ではありません。攻撃者はこのトークンを使用してアカウントにアクセスし、たとえば、このトークンを取り消して別のトークンを追加することができます。ただし、そのためには、他にも深刻なセキュリティ上の問題があるはずです。 U2Fトークンは2番目の要素にすぎません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、solokeyが他のものよりも安全でない可能性がある唯一のシナリオは、攻撃者が短期間デバイスにアクセスしようとした場合です。</font></font><code>device_secret</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それから、見えないようにデバイスを返してください。</font><font style="vertical-align: inherit;">これを行うには、フラッシュマイクロコントローラー（または適切なタイミングでRAM）の内容を読み取る必要がありますが、これは簡単なことではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての要因を考慮すると、個人的に信頼できるバックアップを作成することは、U2Fデバイスの超安全なハードウェア実装よりもはるかに重要であると思います。</font><font style="vertical-align: inherit;">このような安全な実装と適切なバックアップの欠如に関する問題の可能性は、u2f-zero（ソロキー）とバックアップの問題の可能性よりも高くなります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検討されているバックアップ戦略は、すべての面で他の方法よりも優れています。これは、他のどの方法よりも普遍的で、安全で信頼性が高い方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主要メーカーの少なくとも1社がこれを自社の製品に実装してくれればうれしいですが、まだ確実ではありません。</font><font style="vertical-align: inherit;">Yubicoのサポート担当者の1人であるJames A.は、必要に応じてバックアップを実装することはU2Fの設計方法では不可能であり、実装の詳細を設定した後、応答を停止したとさえ言っていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、これはユビコが信じているほど不可能ではなかった。</font></font><br>
<br>
<hr><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の元の英語の記事：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U2Fトークンの信頼性が高く、安全でユニバーサルなバックアップ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">なぜなら </font><font style="vertical-align: inherit;">元の記事の作成者は私自身です。そのため、あなたの許可を得て、この記事を「翻訳」のカテゴリに含めませんでした</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja474284/index.html">先物とオプションだけでなく、取引所には他にどのような二次金融商品が存在するか</a></li>
<li><a href="../ja474286/index.html">シンプレックス法の詳細分析</a></li>
<li><a href="../ja474292/index.html">JavaFXチュートリアル：はじめに</a></li>
<li><a href="../ja474294/index.html">バイナリー互換性：今または絶対</a></li>
<li><a href="../ja474298/index.html">P2Pゲートウェイのカード間転送操作の実装</a></li>
<li><a href="../ja474302/index.html">効果的なアプリケーションユーザビリティテストスクリプトの作成方法</a></li>
<li><a href="../ja474306/index.html">ポインティング、フォーカス、アクティブ状態のスタイルを変える。</a></li>
<li><a href="../ja474308/index.html">Pythonで記述されたHTTP APIのタイプ：Instagramの経験</a></li>
<li><a href="../ja474310/index.html">CSSに乱数はありますか？</a></li>
<li><a href="../ja474312/index.html">Windows Server CoreへのGUIのインストール</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>