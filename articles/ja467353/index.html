<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🌾 ⌛️ 👦🏼 Reddのコード最適化メソッド。パート1：キャッシュ効果 🎏 🌊 🏀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最初の記事シリーズ、私は積極的にReddのためのコード開発は二次的であり、メインプロジェクトが主であるという考えを促進しました。 Reddは補助的なツールなので、多くの時間を費やすのは間違いです。つまり、その開発は迅速に進むべきです。しかし、これは、結果として得られるプログラムが最適ではないという意...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Reddのコード最適化メソッド。パート1：キャッシュ効果</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467353/"><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリーズ、私は積極的にReddのためのコード開発は二次的であり、メインプロジェクトが主であるという考えを促進しました。 Reddは補助的なツールなので、多くの時間を費やすのは間違いです。つまり、その開発は迅速に進むべきです。しかし、これは、結果として得られるプログラムが最適ではないという意味ではまったくありません。実際、それらがまったく最適化されていない場合、単純に機器の能力では、目的のテストシステムを実装するのに十分ではありません。したがって、前述したように、プロセスは迅速かつ簡単でなければなりませんが、開発者は常に最適化のいくつかの原則に留意する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ky/gv/ge/kygvge7bilfbzntymcu3qzlk4mq.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最適化についての厚い本が出版されています。</font><font style="vertical-align: inherit;">これらの書籍の中には、有用なものもあれば、古くなっているものもあります。それらの中で説明されている原則は、コード構築時の自動最適化の段階に長い間移行されてきたためです。 。</font><font style="vertical-align: inherit;">これから検討を始めます。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまで、「1つの問題-1つの記事」という原則を書いてきました。</font><font style="vertical-align: inherit;">そして、記事は講義の形式で取得され、共通の問題に結び付けられて、一度にいくつかのトピックに影響を与えました。</font><font style="vertical-align: inherit;">しかし、一部の読者は、そのような記事は一度に読むことができないと述べました。</font><font style="vertical-align: inherit;">したがって、ここでは1つの記事で、1つのトピックについてのみ説明します。</font><font style="vertical-align: inherit;">そのように書くのも簡単です。</font><font style="vertical-align: inherit;">見てみましょう、それは突然誰にとっても便利になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、神秘的なマイナスを喜ばせます。</font><font style="vertical-align: inherit;">記事が朝に公開された場合、最初のマイナスは、テキスト全体を読むことができない期間が経過した後に到着します。</font><font style="vertical-align: inherit;">誰かがこれを純粋に原則から行い、UDBとバラライカに関するトピックのみを避けます。</font><font style="vertical-align: inherit;">出版物が朝ではなく午後の場合、彼は遅れてマイナスを投げます。</font><font style="vertical-align: inherit;">2番目のマイナスが日中に到着します（そして、その友人は、ところで、UDBとバラライカに関するトピックも免れました）。</font><font style="vertical-align: inherit;">新しい形式では、より多くの記事が掲載されます。つまり、このカップルにとってより楽しい瞬間になります（個人的には、著者として、私は悲しくて彼らの行動に腹を立てます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シリーズの以前の記事：</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReddにインストールされたFPGAの最も単純な「ファームウェア」の開発、および例としてメモリテストを使用したデバッグ。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReddにインストールされたFPGA用の最も単純な「ファームウェア」の開発。</font><font style="vertical-align: inherit;">パート2.プログラムコード。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPGAベースのプロセッサシステムに埋め込むための独自のコアの開発。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPGAへのアクセスの例に関する中央プロセッサReddのプログラムの開発。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReddコンプレックスのFPGAでのCPUとプロセッサの接続の例でストリーミングプロトコルを使用した最初の実験。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merry Quartusel、またはプロセッサがどのようにしてそのような生活を送ってきたか。</font></font></a></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">典型的なシステムの不可解な動作</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クロック、Nios II / fプロセッサー、SDRAMコントローラー、および出力ポートを組み込んで、最も単純なプロセッサーシステムを実行してみましょう。</font><font style="vertical-align: inherit;">これは、このシステムがSpartanのPlatform Designerでどのように見えるかを示しています。このシステム</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/mr/qt/hm/mrqthmfrz5vespqetdjwcguvclu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
のプログラムコードには関数が1つだけ含まれています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">関数の本体は幾分奇妙に見えます。繰り返し行が多く含まれているためですが、便利です。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードがきつすぎるため、コードは非表示になっています。</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">extern "C"<font></font>
{<font></font>
	#include "sys/alt_stdio.h"<font></font>
	#include &lt;system.h&gt;<font></font>
	#include &lt;io.h&gt;<font></font>
}<font></font>
<font></font>
void MagicFunction()<font></font>
{<font></font>
	while (1)<font></font>
	{<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
	}<font></font>
}<font></font>
int main()<font></font>
{ <font></font>
	MagicFunction();<font></font>
<font></font>
  /* Event loop never exits. */<font></font>
  while (1);<font></font>
<font></font>
  return 0;<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行の最後にブレークポイントを置きます。</font></font><br>
<br>
<pre><code class="plaintext hljs">IOWR (PIO_0_BASE,0,0);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
で</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MagicFunction</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、プログラムを実行します。</font><font style="vertical-align: inherit;">私たちは港の出口で何を手に入れましたか？</font><font style="vertical-align: inherit;">非常に不規則な衝動：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/n7/qt/qj/n7qtqjkwhcioypjv02_7ir7k3es.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ホラー？</font><font style="vertical-align: inherit;">はい、そうです。</font><font style="vertical-align: inherit;">ただし、もう一度「開始」ボタンをクリックして、ループの別の反復を完了します。</font><font style="vertical-align: inherit;">そして出口では、美しい滑らかな蛇行が見られ</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ez/nz/4k/eznz4kkvo8smagbksijd0tt4bso.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。</font><font style="vertical-align: inherit;">そしてもう1つ...安定した蛇行。</font><font style="vertical-align: inherit;">ブレークポイントを削除し、ダイナミクスで作業を監視します。そのようなブレークはもうありません。</font><font style="vertical-align: inherit;">パルスのバーストが無限にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のパスで衝動が引き裂かれたのはなぜですか？</font><font style="vertical-align: inherit;">事故？</font><font style="vertical-align: inherit;">番号。</font><font style="vertical-align: inherit;">デバッグを停止して、再開します。</font><font style="vertical-align: inherit;">そしてまた、私たちは引き裂かれた衝動を受けます。</font><font style="vertical-align: inherit;">プログラムの入り口には常にギャップが生じます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手がかりはキャッシュにあります</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、この動作の解決策はキャッシュにあります。私たちのプログラムはSDRAMに保存されています。 SDRAMからのコードのフェッチは高速ではありません。読み取りコマンドとアドレスを指定する必要があり、アドレスは2つの部分で構成されます。あなたは少し待たなければなりません。そうして初めて、マイクロ回路がデータを出力します。毎回そのような遅延を回避するために、マイクロ回路は1つではなく複数の連続したワードを発行できます。今日はタイムチャートは考慮しません。次の記事では延期します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、プロセッサコア側では、デフォルトでキャッシュが作成されました。その設定は次のとおりです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/n3/3b/cx/n33bcxjyhe2v_lvaiuqafjzvdoc.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、SDRAMからキャッシュへの命令のバッチロードが進行しているときに遅延が発生します。次の反復では、コードはすでにキャッシュにあるため、ロードは不要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オシログラムは、ロード操作ごとに、ポートあたり平均8エントリ（1つのユニットが4回書き込まれ、0が4回書き込まれる）を示しています。</font><font style="vertical-align: inherit;">1つのレコードは1つの</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p-/xp/nh/p-xpnhdsqsklxoqa_ityjp2u-hu.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アセンブラー</font><font style="vertical-align: inherit;">コマンドです。これは、ウィンドウ-&gt;ビューの表示-&gt;その他：</font><font style="vertical-align: inherit;">デバッグ-&gt;逆アセンブリーを</font><font style="vertical-align: inherit;">選択することで確認できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2n/7c/in/2n7cinmvmt04ov-_ibduzwcv9zo.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここに、文字列とそのアセンブリコードを</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_q/ox/wz/_qoxwz5u9qkgsn4gd5t0yuy4djw.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
示します。それぞれ4バイトの8つの命令です。</font><font style="vertical-align: inherit;">キャッシュラインごとに32バイトを取得します...お気に入りのヘルプファイルC：\ Work \ CachePlay \ software \ CachePlay_bsp \ system.hを見て、次のように表示します。</font></font><br>
<br>
<pre><code class="plaintext hljs">#define ALT_CPU_ICACHE_LINE_SIZE 32<font></font>
#define ALT_CPU_ICACHE_LINE_SIZE_LOG2 5<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際に計算されたデータは理論と一致した。</font><font style="vertical-align: inherit;">さらに、ドキュメントから、文字列のサイズは変更できないことがわかります。</font><font style="vertical-align: inherit;">常に32バイトの長さです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もう少し複雑な実験</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確立された作業中に再起動するようにキャッシュを起動してみましょう。</font><font style="vertical-align: inherit;">テストプログラムを少し変えましょう。</font><font style="vertical-align: inherit;">2つの関数を作成し</font><font style="vertical-align: inherit;">、ループを配置</font><font style="vertical-align: inherit;">して</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数から呼び出します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ブレークポイントを設定しません。</font><font style="vertical-align: inherit;">ちなみに、関数を完全に同一にすると、オプティマイザはこれに気づき、そのうちの1つを削除するので、少なくとも1行、そしてそれらは異なるはずです...これは、私が最初に書いたものです：オプティマイザは今非常にスマートです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更されたテストプログラムコード。</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">extern "C"<font></font>
{<font></font>
	#include "sys/alt_stdio.h"<font></font>
	#include &lt;system.h&gt;<font></font>
	#include &lt;io.h&gt;<font></font>
}<font></font>
<font></font>
void MagicFunction1()<font></font>
{<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
}<font></font>
void MagicFunction2()<font></font>
{<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
}<font></font>
int main()<font></font>
{ <font></font>
	while (1)<font></font>
	{<font></font>
		MagicFunction1();<font></font>
		MagicFunction2();<font></font>
	}<font></font>
<font></font>
  /* Event loop never exits. */<font></font>
  while (1);<font></font>
<font></font>
  return 0;<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非常に美しい結果が得られ、すでに確立されたプログラムモードで撮影されています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6q/ww/xa/6qwwxao-phas4ippal7a1hrhlik.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、この2つの関数の間に新しい関数を配置します。これを呼び出すことはありません。メモリ内のそれらの間に配置されるだけです。ここで、より多くのスペースを使用するようにします...キャッシュのサイズは4キロバイトなので、4キロバイトに等しくします...それぞれサイズが4バイトの1024のNOPを挿入するだけです。最初の関数の終わり、新しい関数、2番目の関数の始まりを示し、プログラムがどのように変化するかを明確にします。</font></font><br>
<br>
<pre><code class="plaintext hljs">...<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
}<font></font>
<font></font>
#define Nops4 	__asm__ volatile ("nop");__asm__ volatile ("nop");__asm__ volatile ("nop");__asm__ volatile ("nop");<font></font>
#define Nops16 Nops4 Nops4 Nops4 Nops4<font></font>
#define Nops64 Nops16 Nops16 Nops16 Nops16<font></font>
#define Nops256 Nops64 Nops64 Nops64 Nops64<font></font>
#define Nops1024 Nops256 Nops256 Nops256 Nops256<font></font>
<font></font>
volatile void FuncBetween()<font></font>
{<font></font>
	Nops1024<font></font>
}<font></font>
void MagicFunction2()<font></font>
{<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
		IOWR (PIO_0_BASE,0,1);<font></font>
		IOWR (PIO_0_BASE,0,0);<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムのロジックは変更されていませんが、実行中にパルスが途切れるようになりました。私は</font></font><br>
<br>
<img src="https://habrastorage.org/webt/20/on/rq/20onrqyrzqtcdeiqjiulcaa0yuw.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純な質問</font><font style="vertical-align: inherit;">をします。</font><font style="vertical-align: inherit;">キャッシュから飛び出し、ギャップが広がると、常にロードが行われますか？</font><font style="vertical-align: inherit;">どういたしまして！</font><font style="vertical-align: inherit;">「不良」関数のサイズを変更して、たとえば5キロバイトに等しくします。</font><font style="vertical-align: inherit;">4つ以上5つ、私たちはまだ空飛ぶ？</font><font style="vertical-align: inherit;">か否か？</font><font style="vertical-align: inherit;">インサートをこれに置き換えます：</font></font><br>
<br>
<pre><code class="plaintext hljs">volatile void FuncBetween()<font></font>
{<font></font>
	Nops1024<font></font>
	Nops256<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しになり</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cz/hh/up/czhhupgwhqdrrddlaeyg8kv50yg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ますが、コードをキャッシュにロードする必要性を決定するものは何ですか？</font><font style="vertical-align: inherit;">何かを予測できますか、それとも事実を確認する必要がありますか？</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nios IIプロセッサリファレンスガイドで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つ理論について詳しく見ていきましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理論のビット</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、プロセッサでアドレスフィールドが分​​割される方法です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ba/kw/5_/bakw5_bz0uipk2kzstdfcjuiuvy.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、アドレスは3つの部分に分かれています。</font><font style="vertical-align: inherit;">タグ、ライン、オフセット。</font><font style="vertical-align: inherit;">オフセットフィールドの次元は、Nios IIプロセッサでは一定であり、常に5ビットです。つまり、32バイトをアドレス指定できます。</font><font style="vertical-align: inherit;">「line」フィールドのサイズは、プロセッサの構成時に指定されたキャッシュサイズによって異なります。</font><font style="vertical-align: inherit;">上図ではかなり大きいです。</font><font style="vertical-align: inherit;">なぜこのような巨大な文書があるのか​​わかりません。</font><font style="vertical-align: inherit;">キャッシュサイズは4キロバイトです。これは、ラインとオフセットの合計容量が12ビットであることを意味します。</font><font style="vertical-align: inherit;">5ビットはオフセットを取ります。ラインの場合、12-5 = 7ビットのままです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それぞれ32バイト長の128行の特定のテーブルを取得します。</font><font style="vertical-align: inherit;">たとえば、最初の6行を示します。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タグフィールド</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールド「文字列」</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSB</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入手先</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要ではありません</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x000から0x01F</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュの行0に</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要ではありません</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x01</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x020〜0x03F</font></font></td>
<td>  1 </td>
</tr>
<tr>
<td> </td>
<td>0x02</td>
<td> 0x040  0x05F</td>
<td>  2 </td>
</tr>
<tr>
<td> </td>
<td>0x03</td>
<td> 0x060  0x07F</td>
<td>  3 </td>
</tr>
<tr>
<td> </td>
<td>0x04</td>
<td> 0x080  0x09F</td>
<td>  4 </td>
</tr>
<tr>
<td> </td>
<td>0x05</td>
<td> 0x0A0  0x0BF</td>
<td>  5 </td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td> </td>
<td>0x7F</td>
<td> 0xFE0  0xFFF</td>
<td>  127 </td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、アドレス0x123 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">004に目</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を向けました</font><font style="vertical-align: inherit;">。 「重要でない」部分を破棄すると、「ライン+オフセット」のペアは0x004になります。これはゼロの行範囲です。この行にデータが読み込まれます。さらに、0x123 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から0x123 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">01Fの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">範囲のデータを処理</font><font style="vertical-align: inherit;">すると、キャッシュが機能します。文字列はどのような状況でオーバーロードされますか？ 0x000から0x01Fの範囲で終わる他のアドレスにアクセスする場合。つまり、アドレス0xABC </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">204</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に目</font><font style="vertical-align: inherit;">を向けると、</font><font style="vertical-align: inherit;">下位アドレスの範囲が重複しないため、すべてがそのまま残ります。そして、0xABC </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">804</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は何も台無しにしません。しかし、アドレス0xABC </font><b><font style="vertical-align: inherit;">004</font></b><font style="vertical-align: inherit;">からコードを実行する場合</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいコンテンツがキャッシュラインにロードされます。そしてすでにアドレス0x123 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">004</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">への移行</font><font style="vertical-align: inherit;">は再び過負荷につながります。 0xABC </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">004</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と0x123 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">004の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間を常にジャンプする場合</font><font style="vertical-align: inherit;">、過負荷が継続的に発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを絵で表現してみましょう。キャッシュに8行しかない場合、それらを異なる色で着色する方が便利です。ラインサイズを0x10にします。アドレスを絵に描く方が便利です（実際のNios IIでは、ラインサイズは常に0x20バイトです）。キャッシュラインと同じサイズの条件付きページのメモリビート。メモリの赤いページは常にキャッシュの赤い線に、オレンジはオレンジに、というように続きます。これにより、古いコンテンツがアンロードされます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r0/he/sl/r0heslzwbiuxwjprhq4tnf-xela.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、実際には、実験中のプログラムの動作は今や明らかです。</font><font style="vertical-align: inherit;">関数が4キロバイトで厳密に分離されている場合、それらは類似した色のページにヒットしました。</font><font style="vertical-align: inherit;">したがって、コード</font></font><br>
<br>
<pre><code class="plaintext hljs">	while (1)<font></font>
	{<font></font>
		MagicFunction1();<font></font>
		MagicFunction2();<font></font>
	}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ある目的のためにキャッシュをロードし、次に別の機能のためにキャッシュをロードしました。</font><font style="vertical-align: inherit;">また、間隔が4ではなく5キロバイトの場合、関数は異なる色のブロックに分けられました。</font><font style="vertical-align: inherit;">衝突はなく、すべてが遅滞なく機能しました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何年も前に読んだとき、生産性の高いもの、リアルタイムでの作業用、安価なシステムでの作業用にそれぞれ設計されたCortex A、Cortex R、Cortex Mコアのラインがあるが、最初は理解できなかったが、実際には何が違うのか。いいえ、安いシステムは理解できますが、最初の2つは違いは何ですか？しかし、Cyclone V SoC FPGAで利用可能なCortex A9コアをプレイした後、Ironで作業するときにキャッシュのすべての欠点を感じました。 Cortex Aのコアには多くのキャッシュがあります...システムの動作の予測可能性はほとんどありません。しかし、キャッシュはパフォーマンスを向上させます。すべてがビートに対して予測どおりに正確ではなく、予測どおりに遅いよりも速く機能する方が良い場合があります。これは特に、グラフィックスの計算や表示に当てはまります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、主な問題は、記事に記載されていることが発生することではなく、システムの動作がアセンブリごとに変化することです。コードを追加または削除した後、関数がどのアドレスに対応するのかわからないためです。 15年前、ケーブルテレビデコーダー用のSegaゲームコンソールエミュレーターのプロジェクトでは、SPARC-8コアでMotorolaアセンブラーコマンドをエミュレートする関数を移動するプリプロセッサ全体を作成し、実行時間が常に同じになるようにしました（キャッシュのために、そうでなければすべてがたくさん泳ぎました）。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、いつ予測可能性が必要ですか？</font><font style="vertical-align: inherit;">もちろん、プログラムでタイムダイアグラムを作成する場合（一般にFPGAではこれをハードウェアに委託することも可能ですが、高速開発の場合にはいくつかの特徴があります）。</font><font style="vertical-align: inherit;">しかし、計算アルゴリズムを使用する場合、それはそれほど重要ではありません。</font><font style="vertical-align: inherit;">アルゴリズムが複雑でない限り、クリティカルセクションによってキャッシュが過負荷にならないようにする必要があります。</font><font style="vertical-align: inherit;">ほとんどの場合、キャッシュによって問題が発生することはなく、生産性が向上します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次回の記事では、常に最大速度で実行されるキャッシュ不可メモリへの重要な機能を予測する方法を検討し、このプロセスで使用されるテクノロジーから生じる、標準システムに対するFPGAの潜在的な利点について説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も注意深い</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
腐食性のある読者は、「4キロバイトのコードを挿入したときにオシログラムが十分に引き裂かれなかったのはなぜですか？」</font><font style="vertical-align: inherit;">すべてが簡単です。</font><font style="vertical-align: inherit;">ちょうど4キロバイトを挿入すると、関数をメモリに配置するための次のアドレスが取得されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">          MagicFunction1():<font></font>
0200006c:   movhi r2,1024<font></font>
02000070:   movi r4,1<font></font>
02000074:   addi r2,r2,4096<font></font>
02000078:   stwio r4,0(r2)<font></font>
 92       		IOWR (PIO_0_BASE,0,0);<font></font>
0200007c:   mov r3,zero<font></font>
02000080:   stwio r3,0(r2)<font></font>
 93       		IOWR (PIO_0_BASE,0,1);<font></font>
...<font></font>
120       		IOWR (PIO_0_BASE,0,0);<font></font>
020000f0:   stwio r3,0(r2)<font></font>
020000f4:   ret <font></font>
131       	Nops1024<font></font>
          FuncBetween():<font></font>
020000f8:   nop <font></font>
020000fc:   nop <font></font>
02000100:   nop <font></font>
02000104:   nop<font></font>
...<font></font>
020010ec:   nop <font></font>
020010f0:   nop <font></font>
020010f4:   nop <font></font>
020010f8:   ret <font></font>
135       		IOWR (PIO_0_BASE,0,0);<font></font>
          MagicFunction2():<font></font>
020010fc:   movhi r2,1024<font></font>
02001100:   mov r4,zero<font></font>
02001104:   addi r2,r2,4096<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的には悪い波形の場合、4キロバイトが</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MagicFunction1（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の長さと一緒にそのボリュームになるようにNOPを挿入する必要があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">あなたが美しい写真のために何をしようとも関係ありません！</font><font style="vertical-align: inherit;">挿入を次のように変更します。</font></font><br>
<br>
<pre><code class="plaintext hljs">volatile void FuncBetween()<font></font>
{<font></font>
	Nops256 Nops256 Nops256<font></font>
	Nops64 Nops64 Nops64<font></font>
	Nops16 Nops16<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何度も何度も、挿入が制御を受け取らないことに注意を払います。</font><font style="vertical-align: inherit;">メモリ内の関数の相対的な位置を変更するだけです。</font><font style="vertical-align: inherit;">このような挿入を行うと、希望する恐ろしい恐怖が得られ</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7d/by/om/7dbyomefuy0kgtjxmnysanc_lxm.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。メインテキストに挿入されたそのような詳細は、メインのテキストからすべての人の注意をそらすように思えたので、追記しました。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja467339/index.html">そして再び、今年の256日目</a></li>
<li><a href="../ja467343/index.html">フリーランスをやめる理由：2年間の「自由」の後のバックエンド開発者の印象</a></li>
<li><a href="../ja467345/index.html">ITブログと4層のトレーニングにアクセス：MosigraのSergey Abdulmanovへのインタビュー</a></li>
<li><a href="../ja467347/index.html">ブック「Creating Solidity smart contracts for the Ethereum blockchain。実用ガイド</a></li>
<li><a href="../ja467349/index.html">プログラマーをエストニアに移す：仕事、お金、生活費</a></li>
<li><a href="../ja467355/index.html">中央および東ヨーロッパの市場調査員およびソフトウェア開発動向のインタビュー、Eugene Schwab-Chesaru</a></li>
<li><a href="../ja467359/index.html">PVS-Studioがクラウドに移行：Azure DevOps</a></li>
<li><a href="../ja467361/index.html">JavaScriptでの委任について忘れていました。反応中のイベント委任</a></li>
<li><a href="../ja467363/index.html">Kerasでカスタム損失関数と学習品質メトリックを使用する</a></li>
<li><a href="../ja467365/index.html">住宅用電圧監視リレー</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>