<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏿 👼🏼 ✔️ 多数の小さなファイルを操作するときのハック 📂 👲🏿 ⏯️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="記事のアイデアは、記事「Something about inode」のコメントでの議論から自発的に生まれました。
 
 
 
 実際のところ、当社のサービスの内部仕様は、多数の小さなファイルのストレージです。現在、このようなデータは約数百テラバイトあります。そして、私たちはいくつかの明白であまりレー...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>多数の小さなファイルを操作するときのハック</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/srg/blog/462967/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事のアイデアは、記事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Something about inode」の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コメントでの議論から自発的に生まれました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ao/mn/mj/aomnmjglvkpfklyfa_vgdyonw70.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際のところ、当社のサービスの内部仕様は、多数の小さなファイルのストレージです。</font><font style="vertical-align: inherit;">現在、このようなデータは約数百テラバイトあります。</font><font style="vertical-align: inherit;">そして、私たちはいくつかの明白であまりレーキではないものに遭遇し、それらの上をうまく歩きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、私は私たちの経験を共有します。多分誰かが役に立つでしょう。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題1：「デバイスに空き容量がありません」</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の記事で述べたように、問題はファイルシステムに空きブロックがあるが、iノードが終了していることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたがコマンドで使用され、空きiノード数を確認することができます</font></font><code>df -ih</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vu/nw/80/vunw80lzvxvznckfvpu9ok9i5ha.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は短期で、メタ情報のため、直接ディスク上のデータとブロックのための両方のブロックがあり、記事を再び語るませんが、彼らはまた、iノード（インデックスノード）です。それらの数は、ファイルシステムの初期化中に設定され（ext2とその子孫について話している）、それ以上変更されません。データブロックとiノードのバランスは、平均統計データから計算されます。この場合、小さなファイルがたくさんある場合、バランスはiノードの数にシフトするはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linuxはすでにさまざまなバランスのオプションを提供しており、これらすべての事前計算された構成はファイルにあります</font></font><code>/etc/mke2fs.conf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、mke2fsによるファイルシステムの初期初期化中に、目的のプロファイルを指定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、ファイルの例です。</font></font><br>
<br>
<pre><code class="json hljs">    small = {<font></font>
        blocksize = 1024<font></font>
        inode_size = 128<font></font>
        inode_ratio = 4096<font></font>
    }<font></font>
<font></font>
    big = {<font></font>
        inode_ratio = 32768<font></font>
    }<font></font>
<font></font>
    largefile = {<font></font>
        inode_ratio = 1048576<font></font>
        blocksize = -1<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mke2fsを呼び出すときに、-Tオプションを使用して目的のユースケースを選択できます。</font><font style="vertical-align: inherit;">既製のソリューションがない場合は、必要なパラメータを手動で設定することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
詳細については、</font></font><code>mke2fs.conf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><font style="vertical-align: inherit;">のマニュアルに記載されてい</font></font><code>mke2fs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述の記事で言及されていない機能は、データブロックのサイズを設定できることです。</font><font style="vertical-align: inherit;">明らかに、大きなファイルの場合、小さなファイルの場合、小さなファイルの場合は、ブロックサイズを大きくするのが理にかなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、プロセッサアーキテクチャなどの興味深い機能を検討する価値があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かつて、大きな写真ファイルにはもっと大きなブロックサイズが必要だと思っていました。それは、ARMアーキテクチャのホームファイル名WDの自宅にありました。ためらうことなく、ブロックサイズを標準の4kではなく8kまたは16kに設定しました。そして、ディスクが生きている間にストレージ自体が故障しなかった瞬間まで、すべてが素晴らしかったです。通常のIntelプロセッサーを搭載した通常のコンピューターにディスクを挿入したところ、驚きました。サポートされていないブロックサイズです。言った。データはありますが、すべて問題はありませんが、読み取ることは不可能です。プロセッサi386などは、メモリページのサイズと一致しないブロックサイズを処理する方法を知りませんが、正確には4kです。一般的に、ケースはユーザー空間のユーティリティを使用して終了し、すべてが遅く悲しいものでしたが、データは保存されました。誰が気にする-ユーティリティの名前をグーグル</font></font><code>fuseext2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">モラル：すべてのケースを事前に検討するか、スーパーヒーローを自分で構築せずに主婦の標準設定を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UPD。</font><font style="vertical-align: inherit;">ユーザーによると</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベレス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i386の場合、ブロックサイズは4kを超えないようにする必要がありますが、厳密に4kである必要はありません。有効な1kおよび2k。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、どのように問題を解決したか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、数テラバイトのディスクにデータがいっぱいになり、ファイルシステムの構成をやり直すことができないときに問題が発生しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、解決策が緊急に必要でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、ファイル数を減らしてバランスを変える必要があるという結論に達しました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルの数を減らすために、ファイルを1つの共通アーカイブに配置することが決定されました。具体的には、すべてのファイルを1つのアーカイブに一定期間保存し、cronタスクを毎日夜にアーカイブしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
zipアーカイブを選択しました。前の記事へのコメントで、tarが提案されましたが、それには1つの複雑な点があります。目次がなく、その中のファイルがスレッド化されている（理由のため、「tar」はテープドライブのレガシーである「Tape Archive」の省略形です）。 。アーカイブの終わりに相対する各ファイルのオフセットがないため、アーカイブの最後にあるファイルを読み取る必要がある場合は、アーカイブ全体を読み取る必要があります。そして、これは長い操作です。 zipでは、すべてがはるかに優れています。アーカイブ内に同じ目次とファイルオフセットがあり、各ファイルへのアクセス時間はその場所に依存しません。さて、私たちの場合、すべてのファイルがあらかじめgzipで圧縮されているため、圧縮オプションを「0」に設定することが可能でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントはnginxを介してファイルを取得し、古いAPIによれば、たとえば次のようにファイル名のみが指定されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">http://www.server.com/hydra/20170416/0453/3bd24ae7-1df4-4d76-9d28-5b7fcb7fd8e5
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その場でファイルを解凍するために、nginx-unzip-moduleモジュール（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/youzee/nginx-unzip-module</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を見つけて接続し、</font><font style="vertical-align: inherit;">2つのアップストリームをセットアップしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果はこの構成でした：設定の</font></font><br>
<br>
<img src="https://habrastorage.org/webt/l1/q5/hm/l1q5hmgkz1ljq4qlnsyheuk9vsk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのホストは次のように見えました：</font></font><br>
<br>
<pre><code class="json hljs">server {<font></font>
  listen *:<span class="hljs-number">8081</span>;<font></font>
<font></font>
  location / {<font></font>
    root      /home/filestorage;<font></font>
  }<font></font>
}</code></pre><br>
<pre><code class="json hljs">server {<font></font>
  listen *:<span class="hljs-number">8082</span>;<font></font>
<font></font>
  location ~ ^/hydra/(\d+)/(\d+)/(.*)$ {<font></font>
    root      /home/filestorage;<font></font>
    file_in_unzip_archivefile <span class="hljs-attr">"/home/filestorage/hydra/$1/$2.zip"</span>;<font></font>
    file_in_unzip_extract <span class="hljs-attr">"$2/$3"</span>;<font></font>
    file_in_unzip;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして上流のnginxの上流の設定：</font></font><br>
<br>
<pre><code class="json hljs">upstream storage {<font></font>
  server server.com:<span class="hljs-number">8081</span>;<font></font>
  server server.com:<span class="hljs-number">8082</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのように機能しますか：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントはフロントnginxに移動します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロントnginxは最初の上流からファイルを与えようとします。</font><font style="vertical-align: inherit;">ファイルシステムから直接</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルがない場合は、2番目のアップストリームからファイルの提供を試み、アーカイブ内でファイルを見つけようとします。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の問題：繰り返しますが、「デバイスに空き容量がありません」</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ディレクトリに多数のファイルがある場合に発生する2番目の問題です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルを作成しようとしていますが、システムはスペースがないことを保証します。ファイル名を変更して、もう一度作成してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それが判明。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは次のようになります：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ab/rm/-t/abrm-tjedr5yhbypoyzymrkbwsy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iノードをチェックしても何も起こりません-それらの多くは空いています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場所の確認も同じです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディレクトリにはファイルが多すぎる可能性があると考えましたが、制限がありますが、制限はありません：ディレクトリあたりの最大ファイル数：〜1.3×10 ^ 20 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、名前を変更すればファイルを作成できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論はファイル名の問題です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに検索を行ったところ、ディレクトリインデックスを構築する際のハッシュアルゴリズムに問題があり、多数のファイルがあると、その後のすべての結果と衝突することがわかりました。詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">//ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout#Hash_Tree_Directoriesをご覧ください。</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このオプションは無効にできますが、名前でファイルを検索すると、すべてのファイルを繰り返し処理するときに、予期しないほど長くなることがあります。</font></font><br>
<br>
<pre><code class="bash hljs"> tune2fs -O <span class="hljs-string">"^dir_index"</span> /dev/sdb3
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、回避策がどのように機能するか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
道徳：ディレクトリ内の多くのファイルは通常悪いです。</font><font style="vertical-align: inherit;">これは必要ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、このような場合、ファイル名の最初の文字または日付などの他のパラメータによってサブディレクトリを作成し、ほとんどの場合これで保存されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ディレクトリに分割されている場合でも、小さなファイルの総数は依然として悪いです。最初の問題を参照してください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3番目の問題：ファイルのリストが多くある場合に、それらを表示する方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの状況では、ファイルの数が多いと、ディレクトリの内容をどのように表示するかという問題に直面しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準ソリューションはチーム</font></font><code>ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、4772098ファイルで何が起こるか見てみましょう：</font></font><br>
<br>
<pre><code class="bash hljs"><font></font>
$ time ls /home/app/express.repository/offercache/ &gt;/dev/null<font></font>
<font></font>
real	0m30.203s<font></font>
user	0m28.327s<font></font>
sys	0m1.876s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
30秒…多すぎます。</font><font style="vertical-align: inherit;">そして、ほとんどの場合、カーネルではなく、ユーザー空間でファイルを処理するのにかかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、解決策があります：</font></font><br>
<br>
<pre><code class="bash hljs"><font></font>
$ time find /home/app/express.repository/offercache/ &gt;/dev/null<font></font>
<font></font>
real	0m3.714s<font></font>
user	0m1.998s<font></font>
sys	0m1.717s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3秒 </font><font style="vertical-align: inherit;">10倍速くなります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
やったー！</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーの応答がさらに速くなる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベレス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -並べ替えを無効にする </font></font><code>ls</code><br>
<br>
<pre><code class="bash hljs"><font></font>
time ls -U /home/app/express.repository/offercache/ &gt;/dev/null<font></font>
real	0m2.985s<font></font>
user	0m1.377s<font></font>
sys	0m1.608s<font></font>
</code></pre><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4番目の問題：ファイルを操作するときの大きなLA</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あるマシンから別のマシンに一連のファイルをコピーする必要がある場合、定期的に状況が発生します。同時に、すべてがディスク自体のパフォーマンスに依存するため、LAはしばしば非現実的に成長します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたが望む最も合理的なことはSSDを使用することです。すごくかっこいい。唯一の問題は、マルチテラバイトSSDのコストです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ディスクが通常の場合は、ファイルをコピーする必要があります。これも本番システムであり、過負荷が原因で顧客からの不満が叫ばれますか？少なくとも2つの便利なツールが</font></font><code>nice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり</font></font><code>ionice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<code>nice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-それぞれプロセスの優先度を下げ、シェデュラーはより多くのタイムスライスを他のより優先度の高いプロセスに分配します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの実践では、niceを最大に設定するのに役立ちました（19が最小の優先順位、-20（マイナス20）が最大の優先順位です）。</font></font><br>
<br>
<code>ionice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-それに応じて入力/出力の優先度を調整します（I / Oスケジューリング）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAIDを使用していて突然同期する必要がある場合（再起動が失敗した後、またはディスクの交換後にRAIDアレイを復元する必要がある場合）、状況によっては同期速度を下げて残りのプロセスは多かれ少なかれ適切に機能する可能性があります。</font><font style="vertical-align: inherit;">これを行うには、次のコマンドが役立ちます。</font></font><br>
<br>
<pre><code class="bash hljs">
<span class="hljs-built_in">echo</span> 1000 &gt; /proc/sys/dev/raid/speed_limit_max
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5番目の問題：ファイルをリアルタイムで同期する方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回避するために2番目のサーバーにバックアップする必要がある同じ量のファイルがすべてあります...ファイルは常に書き込まれているため、損失を最小限に抑えるには、できるだけ早くコピーする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準ソリューション：SSH経由のRsync。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、数秒に1回実行する必要がない限り、適切なオプションです。そして、たくさんのファイルがあります。それらをコピーしない場合でも、何が変更されたかを理解する必要があり、数百万のファイルを比較するには、時間とディスクの負荷がかかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。毎回比較を開始することなく、何をコピーするかをすぐに知る必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
救い- </font></font><code>lsyncd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>Lsyncd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブ同期（ミラー）デーモン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これはrsyncでも機能しますが、さらにinotifyとfseventsを使用してファイルシステムの変更を監視し、表示または変更されたファイルのみのコピーを開始します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6番目の問題：ディスクをロードするユーザーを理解する方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だれもがこれを知っていると</font></font><code>iotop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">思い</font><font style="vertical-align: inherit;">ますが、それでも全体像を把握するには、ディスクサブシステムを監視するためのコマンド</font></font><code>top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/la/kj/hu/lakjhuoxiy2nge-vjg4mue3vtwc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、古き良きトップは、ディスクに問題があるかどうかもわかります。これには2つの最も適切なパラメーターがあります</font><b><font style="vertical-align: inherit;">。Load </font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Average</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOwait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jo/vh/ns/jovhnsuoremnqzucgoqnagvkbcy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つ目は、サービスキューにあるプロセスの数（通常は2を超える数）を示しています-すでに問題が発生しています。バックアップサーバーへのアクティブコピーでは、最大6〜8が許可され、その後は異常と見なされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つ目は、プロセッサがディスク操作でどれだけビジーであるかです。</font><font style="vertical-align: inherit;">IOwait&gt; 10％は問題の原因ですが、特定の負荷プロファイルを持つサーバーでは40-50％で安定しており、これが実際の基準です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで終わりますが、私たちが直面する必要のなかった多くのポイントがあると思いますが、興味深い実際のケースのコメントと説明をお待ちしています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja462957/index.html">長所と短所：.orgの価格しきい値は引き続きキャンセルされます</a></li>
<li><a href="../ja462959/index.html">オンラインチェックの自然言語処理：普通の猫やその他の問題に対する一連の魔法のレッスン</a></li>
<li><a href="../ja462961/index.html">データサイエンスダイジェスト（2019年8月）</a></li>
<li><a href="../ja462963/index.html">ReactでContext APIを使用してグローバルアプリケーションテーマを作成する</a></li>
<li><a href="../ja462965/index.html">LinuxでデータベースとWebサービスを公開してサーバー1cを上げる</a></li>
<li><a href="../ja462969/index.html">カザフスタン当局が証明書の導入で彼らの失敗を隠そうとしている方法</a></li>
<li><a href="../ja462971/index.html">JavaScriptで変数のlet宣言と結果のクロージャーの機能を使用する</a></li>
<li><a href="../ja462977/index.html">RPAとBluePrismでルーチンのHRプロセスをスピードアップ</a></li>
<li><a href="../ja462979/index.html">研修生のためのチートシート：Googleの面接でのタスクの段階的なソリューション</a></li>
<li><a href="../ja462983/index.html">ゲーム開発者のための音声：音声クエスト「ラブクラフトワールド」の開発方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>