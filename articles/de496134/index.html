<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♎️ ☢️ 👘 So entfernen Sie verschwommene Fotos mit Python 👨‍👩‍👧‍👧 👨🏼‍⚕️ 🤰🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn wir eine große Serie von Aufnahmen machen, sind einige davon unscharf. Ein großes Automobilunternehmen stand vor dem gleichen Problem. Einige der...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>So entfernen Sie verschwommene Fotos mit Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496134/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir eine große Serie von Aufnahmen machen, sind einige davon unscharf. </font><font style="vertical-align: inherit;">Ein großes Automobilunternehmen stand vor dem gleichen Problem. </font><font style="vertical-align: inherit;">Einige der Fotos während der Inspektion des Autos waren verschwommen, was sich negativ auf den Verkauf auswirken könnte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bilder von geringer Qualität reduzieren direkt den Gewinn.</font></font></i><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie erkennt eine Anwendung unscharfe Fotos auf Algorithmenebene?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann man die Klarheit eines RGB-Bildes messen?</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/be/p7/1g/bep71gaawmaf4thhfl5j7ig-1ze.jpeg"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formulierung des Problems</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich arbeite als Analyst in einem großen Automobilunternehmen. </font><font style="vertical-align: inherit;">Bei der Inspektion eines Autos, bei der Inspektion eines Autos, machen sie viele Fotos über eine spezielle Anwendung, die sofort an die Datenbank gesendet werden. </font><font style="vertical-align: inherit;">Einige Bilder sind verschwommen, was für den Verkauf schlecht ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von hier aus ergibt sich das Problem: "Wie erkennt man unscharfe Bilder auf Algorithmenebene?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entwicklung eines Algorithmus basierend auf einer Stichprobe von 1200 Fotos verschiedener Elemente von Autos. </font><font style="vertical-align: inherit;">Ein Merkmal des Beispiels ist, dass es nicht beschriftet ist, weil </font><font style="vertical-align: inherit;">Es ist schwer zu bestimmen, welche Bilder klar sind und welche nicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich heraus, dass das Erlernen des ML-Modells „mit einem Lehrer“ für die Lösung nicht anwendbar ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Laufe der Arbeit habe ich Werkzeuge verwendet:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bibliotheken: numpy, matplotlib, cv2;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jupyter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Notizbuch.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem Artikel werde ich die Lösung des Problems beschreiben, zu dem ich gekommen bin.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschreibung des Lösungsansatzes</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe 1. Grenzen definieren</font></font></h4><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welches Foto kann als klar bezeichnet werden? </font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine, in der die Grenzen von Objekten ausgesprochen werden. </font><font style="vertical-align: inherit;">Bei unscharfen Aufnahmen verschwimmen die Ränder von Objekten. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bestimme ich die Grenzen von Objekten im Bild? </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rahmen, an denen wir den größten Farbunterschied sehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich heraus, dass Sie zur Bestimmung der Klarheit des Bildes zuerst die Grenzen der Objekte von Fotografien bestimmen und dann deren Größe, Dicke, Anzahl usw. bewerten müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Foto besteht aus einer dreidimensionalen Anordnung von Zahlen von 0 bis 255: (Breite, Höhe, 3 Farben). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich definierte die Grenzen durch Anwenden eines Filters wie beim Erstellen eines tiefen neuronalen Netzwerks: durch Multiplizieren eines dreidimensionalen Arrays mit Matrizen (für jede Farbe):</font></font><br>
<br>
<pre><code class="plaintext hljs">    │ 1 -1 │<font></font>
    │ 1 -1 │<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit einem Farbunterschied erzeugt das resultierende Array eine hohe Modulzahl. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also definieren wir die vertikalen und horizontalen Grenzen. </font><font style="vertical-align: inherit;">Das arithmetische Mittel zeigt die gemeinsamen Grenzen der Fotografie.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe 2. Analyse der Grenzen zur Klarheit</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Grenzen sind definiert. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann man den Rand eines unscharfen Bildes vom Rand eines klaren Bildes unterscheiden? </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei verschiedenen Optionen habe ich folgenden Ansatz gefunden:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definieren Sie die Grenzen des Originalfotos (beschrieben in Schritt 1).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwischen Sie das Originalbild;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definieren Sie die Grenzen des verschwommenen Bildes (beschrieben in Schritt 1).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir betrachten das Verhältnis des arithmetischen Mittels von Absatz 1 und Absatz 2;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der resultierende Koeffizient kennzeichnet die Klarheit des Bildes.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Logik ist einfach: Bei klaren Fotos tritt die Änderung der Ränder signifikanter auf als bei unscharfen, was bedeutet, dass der Koeffizient höher ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python-Implementierung des Algorithmus</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Problem direkt zu lösen, verwenden wir die folgenden Bibliotheken:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> cv2
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die Parameter zur Bestimmung der Grenzen definieren wir die Matrixdefinitionsfunktion:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edges</span>(<span class="hljs-params">n, orient</span>):</span>
    edges = np.ones((<span class="hljs-number">2</span>*n, <span class="hljs-number">2</span>*n, <span class="hljs-number">3</span>))<font></font>
    <font></font>
    <span class="hljs-keyword">if</span> orient == <span class="hljs-string">'vert'</span>:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>*n):<font></font>
            edges[i][n: <span class="hljs-number">2</span>*n] *= <span class="hljs-number">-1</span>
    <span class="hljs-keyword">elif</span> orient == <span class="hljs-string">'horiz'</span>:<font></font>
        edges[n: <span class="hljs-number">2</span>*n] *= <span class="hljs-number">-1</span><font></font>
    <font></font>
    <span class="hljs-keyword">return</span> edges
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter dem Parameter n geben wir die Anzahl der Pixel an, die wir in die Grenzschätzung einbeziehen. </font><font style="vertical-align: inherit;">Die Ausrichtung der Matrix kann horizontal oder vertikal sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Funktionen ähneln einer tiefen neuronalen Netzwerkschicht:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Apply one filter defined by parameters W and single slice</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conv_single_step</span>(<span class="hljs-params">a_slice_prev, W</span>):</span><font></font>
    s = W * a_slice_prev<font></font>
    Z = np.sum(s)<font></font>
    Z = np.abs(Z)<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> Z<font></font>
   <font></font>
<span class="hljs-comment"># Full edge filter</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conv_forward</span>(<span class="hljs-params">A_prev, W, hparameters</span>):</span><font></font>
    m = len(A_prev)<font></font>
    (f, f, n_C) = W.shape<font></font>
    stride = hparameters[<span class="hljs-string">'stride'</span>]<font></font>
    pad = hparameters[<span class="hljs-string">'pad'</span>]<font></font>
    <font></font>
    Z = list()<font></font>
    flag = <span class="hljs-number">0</span>
    z_max = hparameters[<span class="hljs-string">'z_max'</span>]<font></font>
    <font></font>
    <span class="hljs-keyword">if</span> len(z_max) == <span class="hljs-number">0</span>:<font></font>
        z_max = list()<font></font>
        flag = <span class="hljs-number">1</span><font></font>
    <font></font>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):<font></font>
        <font></font>
        (x0, x1, x2) = A_prev[i].shape<font></font>
        A_prev_pad = A_prev[i][ <font></font>
                            int(x0 / <span class="hljs-number">4</span>) : int(x0 * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>), <font></font>
                            int(x1 / <span class="hljs-number">4</span>) : int(x1 * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>), <font></font>
                            :]<font></font>
        <font></font>
        (n_H_prev, n_W_prev, n_C_prev) = A_prev_pad.shape<font></font>
        n_H = int((n_H_prev - f + <span class="hljs-number">2</span>*pad) / stride) + <span class="hljs-number">1</span>
        n_W = int((n_W_prev - f + <span class="hljs-number">2</span>*pad) / stride) + <span class="hljs-number">1</span><font></font>
        z = np.zeros((n_H, n_W))<font></font>
        <font></font>
        a_prev_pad = A_prev_pad<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> range(n_H):<font></font>
            vert_start = h * stride<font></font>
            vert_end = h * stride + f<font></font>
            <font></font>
            <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> range(n_W):<font></font>
                horiz_start = w * stride<font></font>
                horiz_end = w * stride + f<font></font>
                <font></font>
               <font></font>
                a_slice_prev = a_prev_pad[vert_start: vert_end, horiz_start: horiz_end, :]<font></font>
<font></font>
                weights = W[:, :, :]<font></font>
                z[h, w] = conv_single_step(a_slice_prev, weights)<font></font>
        <font></font>
        <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span>:<font></font>
            z_max.append(np.max(z))<font></font>
        Z.append(z / z_max[i])<font></font>
        <font></font>
    cache = (A_prev, W, hparameters)<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> Z, z_max, cache<font></font>
<font></font>
<span class="hljs-comment"># pooling</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pool_forward</span>(<span class="hljs-params">A_prev, hparameters, mode = <span class="hljs-string">'max'</span></span>):</span><font></font>
    m = len(A_prev)<font></font>
    f = hparameters[<span class="hljs-string">'f'</span>]<font></font>
    stride = hparameters[<span class="hljs-string">'stride'</span>]<font></font>
    <font></font>
    A = list()<font></font>
    <font></font>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):<font></font>
        (n_H_prev, n_W_prev) = A_prev[i].shape<font></font>
        <font></font>
        n_H = int(<span class="hljs-number">1</span> + (n_H_prev - f) / stride)<font></font>
        n_W = int(<span class="hljs-number">1</span> + (n_W_prev - f) / stride)<font></font>
        <font></font>
        a = np.zeros((n_H, n_W))<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> range(n_H):<font></font>
            vert_start = h * stride<font></font>
            vert_end = h * stride + f<font></font>
            <font></font>
            <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> range(n_W):<font></font>
                horiz_start = w * stride<font></font>
                horiz_end = w * stride + f<font></font>
                <font></font>
                a_prev_slice = A_prev[i][vert_start: vert_end, horiz_start: horiz_end]<font></font>
<font></font>
                <span class="hljs-keyword">if</span> mode == <span class="hljs-string">'max'</span>:<font></font>
                    a[h, w] = np.max(a_prev_slice)<font></font>
                <span class="hljs-keyword">elif</span> mode == <span class="hljs-string">'avg'</span>:<font></font>
                    a[h, w] = np.mean(a_prev_slice)<font></font>
                        <font></font>
        A.append(a)<font></font>
<font></font>
    cache = (A_prev, hparameters)<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> A, cache
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
conv_single_step - eine Multiplikation der Bildfarben mit Matrizen, die den Rand enthüllen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
conv_forward - Eine vollständige Definition der Ränder im gesamten Foto. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pool_forward - Reduziert die Größe des resultierenden Arrays. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Separat notiere ich den Wert der Zeilen in der Funktion conv_forward:</font></font><br>
<br>
<pre><code class="python hljs">(x0, x1, x2) = A_prev[i].shape<font></font>
A_prev_pad = A_prev[i][ <font></font>
    int(x0 / <span class="hljs-number">4</span>) : int(x0 * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>), <font></font>
    int(x1 / <span class="hljs-number">4</span>) : int(x1 * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>), <font></font>
    :]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die Analyse verwenden wir nicht das gesamte Bild, sondern nur seinen zentralen Teil, weil </font><font style="vertical-align: inherit;">Die Kamera fokussiert häufiger auf die Mitte. </font><font style="vertical-align: inherit;">Wenn das Bild klar ist, ist die Mitte klar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende Funktion bestimmt die Grenzen von Objekten im Bild mithilfe der vorherigen Funktionen:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># main layer</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">borders</span>(<span class="hljs-params">images, filter_size = <span class="hljs-number">1</span>, stride = <span class="hljs-number">1</span>, pool_stride = <span class="hljs-number">2</span>, pool_size = <span class="hljs-number">2</span>, z_max = []</span>):</span>
    Wv = edges(filter_size, <span class="hljs-string">'vert'</span>)<font></font>
    hparameters = {<span class="hljs-string">'pad'</span>: pad, <span class="hljs-string">'stride'</span>: stride, <span class="hljs-string">'pool_stride'</span>: pool_stride, <span class="hljs-string">'f'</span>: pool_size, <span class="hljs-string">'z_max'</span>: z_max}<font></font>
    Z, z_max_v, _ = conv_forward(images, Wv, hparameters)<font></font>
    <font></font>
    print(<span class="hljs-string">'edge filter applied'</span>)<font></font>
    <font></font>
    hparameters_pool = {<span class="hljs-string">'stride'</span>: pool_stride, <span class="hljs-string">'f'</span>: pool_size}<font></font>
    Av, _ = pool_forward(Z, hparameters_pool, mode = <span class="hljs-string">'max'</span>)<font></font>
    <font></font>
    print(<span class="hljs-string">'vertical filter applied'</span>)<font></font>
    <font></font>
    Wh = edges(filter_size, <span class="hljs-string">'horiz'</span>)<font></font>
    hparameters = {<span class="hljs-string">'pad'</span>: pad, <span class="hljs-string">'stride'</span>: stride, <span class="hljs-string">'pool_stride'</span>: pool_stride, <span class="hljs-string">'f'</span>: pool_size, <span class="hljs-string">'z_max'</span>: z_max}<font></font>
    Z, z_max_h, _ = conv_forward(images, Wh, hparameters)<font></font>
    <font></font>
    print(<span class="hljs-string">'edge filter applied'</span>)<font></font>
    <font></font>
    hparameters_pool = {<span class="hljs-string">'stride'</span>: pool_stride, <span class="hljs-string">'f'</span>: pool_size}<font></font>
    Ah, _ = pool_forward(Z, hparameters_pool, mode = <span class="hljs-string">'max'</span>)<font></font>
    <font></font>
    print(<span class="hljs-string">'horizontal filter applied'</span>)   <font></font>
    <font></font>
    <span class="hljs-keyword">return</span> [(Av[i] + Ah[i]) / <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(Av))], list(map(np.max, zip(z_max_v, z_max_h)))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion bestimmt die vertikalen und dann die horizontalen Grenzen und gibt das arithmetische Mittel beider Arrays zurück. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und die Hauptfunktion für die Ausgabe des Definitionsparameters:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># calculate borders of original and blurred images</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orig_blur</span>(<span class="hljs-params">images, filter_size = <span class="hljs-number">1</span>, stride = <span class="hljs-number">3</span>, pool_stride = <span class="hljs-number">2</span>, pool_size = <span class="hljs-number">2</span>, blur = <span class="hljs-number">57</span></span>):</span><font></font>
    z_max = []<font></font>
<font></font>
    img, z_max = borders(images, <font></font>
                         filter_size = filter_size, <font></font>
                         stride = stride, <font></font>
                         pool_stride = pool_stride, <font></font>
                         pool_size = pool_size<font></font>
                        )<font></font>
    print(<span class="hljs-string">'original image borders is calculated'</span>)<font></font>
    <font></font>
    blurred_img = [cv2.GaussianBlur(x, (blur, blur), <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> images]<font></font>
    print(<span class="hljs-string">'images blurred'</span>)<font></font>
    <font></font>
    blurred, z_max = borders(blurred_img, <font></font>
                             filter_size = filter_size, <font></font>
                             stride = stride, <font></font>
                             pool_stride = pool_stride, <font></font>
                             pool_size = pool_size, <font></font>
                             z_max = z_max<font></font>
                            )<font></font>
    print(<span class="hljs-string">'blurred image borders is calculated'</span>)<font></font>
<font></font>
    <span class="hljs-keyword">return</span> [np.mean(orig) / np.mean(blurred) <span class="hljs-keyword">for</span> (orig, blurred) <span class="hljs-keyword">in</span> zip(img, blurred)], img, blurred</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst bestimmen wir die Grenzen des Originalbildes, verwischen dann das Bild, dann bestimmen wir die Grenzen des verschwommenen Fotos und schließlich betrachten wir das Verhältnis der arithmetischen Mittelgrenzen des Originalbildes und der Unschärfe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion gibt eine Liste von Definitionsfaktoren, ein Array von Rändern des Originalbilds und ein Array von verschwommenen Rändern zurück.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel für eine Algorithmusoperation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Analyse habe ich Bilder aus dem Fotobestand von freepik.com aufgenommen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/be/p7/1g/bep71gaawmaf4thhfl5j7ig-1ze.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/bx/q_/zt/bxq_ztaqhom_1utv10_fiik2qbw.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/k_/fa/x4/k_fax4jhbwyxzqhth0a7gdquwuk.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/zw/hc/fo/zwhcfoypmkq78gcvae5nxejwhkc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir bestimmen die Grenzen des ersten Bildes vor und nach der Unschärfe: </font></font><br>
<br>
<img align="left" src="https://habrastorage.org/webt/mu/tz/fw/mutzfwpy7abfonej9aowhiffg1s.jpeg"><img src="https://habrastorage.org/webt/z2/3u/xi/z23uxi_ei9xh9ql1qnhf9zaoz4i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens: </font></font><br>
<br>
<img align="left" src="https://habrastorage.org/webt/xi/fj/5c/xifj5chec5sccukkrgg2rhjj73e.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/ye/8n/ei/ye8neincmrszl7nf6cexjzmy6aa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Drittens: </font></font><br>
<br>
<img align="left" src="https://habrastorage.org/webt/x5/1z/js/x51zjshztdvw40frgdzknx09tic.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/r6/l6/uu/r6l6uum_2u9oee8vqacw0s5fvgo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viertens: </font></font><br>
<br>
<img align="left" src="https://habrastorage.org/webt/yp/4n/jy/yp4njywmsdj9p-wi7syid1srtgq.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/jc/dn/mv/jcdnmv7t8nontgodlfjd4robqaw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den Bildern ist zu sehen, dass die Randänderungen für klare Bilder (3. und 4.) stärker sind als für unscharfe (1. und 2.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach Berechnungen erhalten wir die Koeffizienten: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[5.92918651681958, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.672756123184502, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10.695051017699232, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
11.901115749698139] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Koeffizienten bestätigen die Schlussfolgerungen: </font><font style="vertical-align: inherit;">Je </font><font style="vertical-align: inherit;">größer der Koeffizient, </font><font style="vertical-align: inherit;">desto </font><font style="vertical-align: inherit;">schärfer das Foto. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus ist das zweite Bild weniger klar als das erste, was sich in den Koeffizienten widerspiegelt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annäherungsfunktionen</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je schärfer das Bild, desto stärker ändert sich der Rand, dh je höher der Parameter.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für unterschiedliche Bedürfnisse ist unterschiedliche Klarheit erforderlich. </font><font style="vertical-align: inherit;">Daher ist es notwendig, die Grenzen der Klarheit selbst zu bestimmen: Irgendwo liegt der Koeffizient für ausreichend klare Fotos über 7, irgendwo nur über 10;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Koeffizient hängt von der Helligkeit des Fotos ab. </font><font style="vertical-align: inherit;">Die Ränder dunkler Fotos ändern sich schwächer, was bedeutet, dass der Koeffizient geringer ist. </font><font style="vertical-align: inherit;">Es stellt sich heraus, dass die Grenzen der Klarheit unter Berücksichtigung der Beleuchtung, dh für Standardfotos, bestimmt werden müssen;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein funktionierender Algorithmus befindet sich auf meinem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konto </font><font style="vertical-align: inherit;">.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496118/index.html">Warum gibt es in Amsterdam so viele Rechenzentren?</a></li>
<li><a href="../de496122/index.html">Sorgen Sie für Ihre Hausaufgaben: Sichern Sie Ihren Laptop oder Desktop mit den kostenlosen Veeam-Agenten</a></li>
<li><a href="../de496126/index.html">Verrückte Protokolle</a></li>
<li><a href="../de496128/index.html">Wie SEO-Optimierung und Google-Algorithmen das echte Internet zerstörten</a></li>
<li><a href="../de496130/index.html">Spiegel der Seele: Die Geschichte des Fernsehens von der „Box“ bis zur Intelligenz</a></li>
<li><a href="../de496136/index.html">Verwenden der ColorPicker-Bibliothek in Android zum Implementieren einer flexiblen Farbauswahl</a></li>
<li><a href="../de496138/index.html">Nehmen Sie an der musikalischen Programmierung teil und machen Sie mit - Sprachen, die Ihnen dabei helfen</a></li>
<li><a href="../de496144/index.html">Die Früchte der Isolation: COVID-19 Interaktive Karte mit historischen Diagrammen und Migrationsbeschränkungen</a></li>
<li><a href="../de496146/index.html">Lua auf STM32</a></li>
<li><a href="../de496148/index.html">Strukturelle Entwurfsmuster in ES6 + am Beispiel des Game of Thrones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>