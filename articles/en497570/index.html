<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äç‚úàÔ∏è üëå üìã Databases in the IIoT platform: how Mail.ru Cloud Solutions works with petabytes of data from multiple devices üë©üèª‚Äçüöí üêÄ ‚òïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, I‚Äôm Andrey Sergeev, the head of the IoT solutions development group at Mail.ru Cloud Solutions . It is known that a universal database does not ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Databases in the IIoT platform: how Mail.ru Cloud Solutions works with petabytes of data from multiple devices</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/497570/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cq/9y/ln/cq9yln3qusppabwqddmvvyftzdk.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hi, I‚Äôm Andrey Sergeev, the head of the IoT solutions development group at </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mail.ru Cloud Solutions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It is known that a universal database does not exist. </font><font style="vertical-align: inherit;">Especially when you need to build an Internet of things platform capable of processing millions of events from sensors per second in near real-time mode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our product </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mail.ru IoT Platform</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> began with a prototype based on Tarantool. </font><font style="vertical-align: inherit;">I‚Äôll tell you which way we went, what problems we encountered and how we solved them. </font><font style="vertical-align: inherit;">And also show the current architecture of the modern platform of the industrial Internet of things. </font><font style="vertical-align: inherit;">In the article we will talk:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">about our database requirements, universal solution and CAP-theorem;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">whether the database + application server in one approach is a silver bullet;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">about the evolution of the platform and the databases used in it;</font></font></li>
<li> ,     Tarantool‚Äô       .</li>
</ul><a name="habracut"></a><br>
<i>  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">@Databases Meetup</a> by Mail.ru Cloud Solutions.    ,  :</i><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wigSv2_zWBU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2>Mail.ru IoT Platform   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our product, Mail.ru IoT Platform, is a scalable and hardware-independent platform for building solutions for the industrial Internet of things. </font><font style="vertical-align: inherit;">It allows you to collect data from hundreds of thousands of devices simultaneously and process this stream in near real-time mode (i.e. quasi-real time), including using custom rules - scripts in Python or Lua. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The platform can store an unlimited amount of raw data from sources, there is a set of ready-made components for visualizing and analyzing data, built-in tools for predictive analytics and creating applications based on the platform.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/kz/eq/lx/kzeqlxssqhyx4fop4gl2ifrnxwe.jpeg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is how the Mail.ru IoT Platform device looks.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
At the moment, the platform is available for installation according to the on-premise model at the customer‚Äôs facilities, this year it is planned to release the platform as a service in the public cloud.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarantool prototype: how it all began</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our platform began as a pilot project - a prototype with a single instance Tarantool, the main function of which was to receive data flow from an OPC server, process received events using Lua scripts in real time, monitor key indicators based on them, and generate events and alerts in superior systems.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/258/2a5/f8c/2582a5f8c1d12d5717365bb82081efa4.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarantool prototype scheme</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
This prototype even worked in combat conditions for several months at a cluster site, it is a platform for oil production on the high seas, in Iraq, in the Persian Gulf. </font><font style="vertical-align: inherit;">He monitored key indicators and supplied data for the visualization system and the event log. </font><font style="vertical-align: inherit;">The pilot was recognized as successful, but as is often the case with prototypes - it didn‚Äôt go beyond the pilot and the prototype was put into a long box until it fell into our hands.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our goals in developing an IoT platform</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Together with the prototype, we got the task - to make a full-fledged, scalable and fault-tolerant IoT-platform, which could later be launched as a service in a public cloud. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We needed to build a platform with the following introductory:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connect hundreds of thousands of devices simultaneously.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Receive millions of events per second.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream processing in near real-time mode.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Storage of raw data for several years.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tools for both streaming analytics and historical analytics.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deployment support in multiple data centers for maximum disaster recovery.</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pros and cons of the platform prototype</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the time of the start of active development, the prototype looked as follows:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarantool, which is used as a database + application server (Application Server);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all data is stored in Tarantool memory;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an application on Lua in the same Tarantool, which performs the functions of receiving data, processing it and calling user scripts on incoming data.</font></font></li>
</ul><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This approach to building applications has its advantages</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code and data are in one place, which allows you to operate on the data directly in the application‚Äôs memory and removes the overhead costs of network visits typical of traditional applications.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarantool uses JIT (Just in Time Compiler) for Lua, which at compile time compiles Lua code into machine code, which allows simple Lua scripts to run at a speed comparable to C code (40,000 RPS from one core - and this is not the limit !).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarantool is based on cooperative multitasking, that is, each stored procedure call is launched in its own fiber, an analogue of coroutine, which gives an even greater boost in performance in tasks with I / O operations, for example, network visits.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Efficient use of resources - few tools can handle 40,000 requests per second from a single CPU core.</font></font></li>
</ol><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But there are significant disadvantages</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to store raw data from devices for several years, but we do not have hundreds of petabytes of memory for Tarantool.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A direct consequence of the first plus: the entire code of our platform is stored procedures in the database, which means that any update to the code base of the platform is an update of the database, which is very painful.</font></font></li>
<li>  ,           .  ,        Tarantool       24-32   (Tarantool       )    .          ‚Äî        Tarantool,    .</li>
<li>        .    - ,  Tarantool   Lua    ,   - ,  LuaJIT           .</li>
</ol><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tarantool is a good choice for creating MVP, but for a full-fledged, scalable, easily supported and fault-tolerant IoT platform that can receive, process and store data from hundreds of thousands of devices, it is not suitable.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main pains of the prototype that we wanted to get rid of</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First of all, we wanted to cure two pains of our prototype:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get away from the concept of database + application service. </font><font style="vertical-align: inherit;">We wanted to update the application code regardless of the data store.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplify dynamic scaling under load. </font><font style="vertical-align: inherit;">I wanted to get easy independent horizontal scaling of as many functions as possible.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To solve these problems, we chose an innovative and not yet tested approach: microservice architecture and separation of services into Stateless - applications and Stateful - database. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To further facilitate the operation and horizontal scaling of Stateless services, we containerized them and adopted Kubernetes.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0db/687/017/0db687017d254d99d9502d5b4362a4f2.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We figured out Stateless services, it remains to decide what to do with the data.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basic database requirements for the IoT platform</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initially, we did not want to fence the garden and wanted to store all the platform data in one universal database. </font><font style="vertical-align: inherit;">After analyzing the goals, we came to the following list of requirements for a universal database:</font></font><br>
<br>
<ol>
<li><strong>ACID-</strong> ‚Äî        ,          .</li>
<li><strong> </strong> ‚Äî         .</li>
<li><strong>     </strong> ‚Äî      ,         near real-time.</li>
<li><strong></strong> ‚Äî        -    .</li>
<li><strong></strong> ‚Äî      ,          .</li>
<li><strong> </strong> <strong>  </strong> ‚Äî          (  !),     .</li>
<li><strong> </strong>‚Äî           ,       (      !).</li>
<li><strong>SQL</strong> ‚Äî         .</li>
</ol><br>
<h2>      CAP-</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before starting to sort through all the databases that are on the market for compliance with our requirements, we decided to validate our requirements for sanity using a fairly well-known tool - CAP-theorems. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The CAP theorem says that a distributed system can have a maximum of two of the following three properties:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consistency (data consistency)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - in all computing nodes at one point in time, the data does not contradict each other.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Availability</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - any request to a distributed system ends with a correct response, but without a guarantee that the answers of all nodes in the system match.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partition tolerance</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - even if there is no connection between nodes, they continue to work independently of each other.</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_p/8i/0o/_p8i0olwyxcps5ymii2x6j1diow.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, the classic CA system is a PostgreSQL Master-Slave cluster with synchronous replication, and the classic AP system is Cassandra. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let us return to our requirements and classify them using the CAP theorem:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACID transactions and strict consistency (or at least not eventual consistency) are C.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Horizontal scaling for writing and reading plus high availability is A (multi-master).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fault tolerance is P, when one data center falls out, the platform should not die.</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/fr/ju/xvfrjubabyxcsbepcrhpr_fuht0.jpeg"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : the universal database we need must have all three properties from the CAP theorem, which means that there is no universal database for all our requirements.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Choosing a database for the data with which the IoT platform works</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you can‚Äôt choose a universal database, we decided to select the types of data that the platform will work with and select a database for each type. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At a first approximation, we divided the data into two types:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><strong><font style="vertical-align: inherit;">information</font></strong><font style="vertical-align: inherit;"> is a model of the world, devices, settings, rules, almost all data, except those that transmit end devices.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raw data from devices</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - sensor readings, telemetry and service information from devices. </font><font style="vertical-align: inherit;">In fact, these are time series, where each individual message contains a value and a timestamp.</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Choosing a Database for Metadata</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Database requirements for metadata</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Metadata is inherently relational. They are characterized by a small amount, they are rarely modified, but they are important data, they cannot be lost, therefore consistency is important even within the framework of asynchronous replication, as well as ACID transactions and horizontal read scaling. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is relatively little such data and they will be relatively infrequently changed, so you can sacrifice horizontal scaling to the recording, as well as the possible inaccessibility of the recording database in the event of an accident. That is, in terms of the CAP theorem, we need a CA system. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Which is suitable in the usual case</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . With such a statement of the problem, any classical relational database with support for clusters with asynchronous replication like PostgreSQL or MySQL would be quite suitable for us.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Features of our platform</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . We also needed support for trees with specific requirements. As part of the prototype, there was a feature from the systems of the class BDRV (real-time databases) - modeling the world using a tag tree. They allow you to combine all the client devices in one tree structure, which facilitates the management of a large number of devices and their display.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/58e/f7e/b7c58ef7ef64fc742bcbd0f3190d5510.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is how the display of devices in the form of a tree structure looks like.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Such a tree allows you to link end devices with the environment, for example, you can put devices that are physically located in one room in one subtree, which greatly facilitates the work with them in the future. </font><font style="vertical-align: inherit;">This is a convenient function, in addition, further we wanted to work in the niche of the airborne detonator system, and there the presence of such functionality is actually the industry standard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the full implementation of tag trees, a potential database must meet the following requirements:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Support for trees with arbitrary width and depth.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modification of tree elements in ACID transactions.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">High performance when traversing a tree.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classic relational databases can handle small trees pretty well, but they do not do as well with arbitrary trees. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Possible Solution. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use two databases - a graph database for storing a tree and a relational database for storing the rest of the meta-information. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This approach has several big disadvantages at once:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To ensure consistency between two databases, you need to add an external transaction coordinator.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This design is difficult to maintain and not very reliable.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the output we get two databases instead of one, while the graph database is needed only to support limited functionality.</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5db/00d/e2d/5db00de2daec50d59dded73a98bc932c.jpg"></div><br>
<h4><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A possible but not very good solution with two databases</font></font></i></h4><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our solution for storing metadata</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">We also thought and remembered that initially this functionality was implemented in a prototype based on Tarantool and it turned out very well. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before continuing, I would like to give a non-standard definition of Tarantool: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarantool is not a database, but a set of primitives for building a database for your specific case. </font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Available primitives out of the box:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Space - an analogue of the tables in the database for storing data.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full-fledged ACID transactions.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Replication is asynchronous using WAL logs.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A sharding tool that supports automatic resharding.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Superfast LuaJIT for stored procedures.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Large standard library.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LuaRocks package manager with even more packages.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our CA solution was a relational + graph database based on Tarantool. </font><font style="vertical-align: inherit;">We have collected the dream meta information repository based on Tarantool primitives:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Space for data storage.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACID transactions - were available.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous replication - was available.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relations - done on stored procedures.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trees - also made on stored procedures.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The cluster installation we have is classic for such systems - one Master for writing and several Slive with asynchronous replication for scaling for reading. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The result: a fast, scalable hybrid of a relational and graph database. </font><font style="vertical-align: inherit;">A single Tarantool instance is capable of handling thousands of read requests, including those with active tree traversal.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Choosing a database for data from devices</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Database requirements for data from devices</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . These data are characterized by frequent recording and a large amount of data: millions of devices, several years of storage, petabytes of information of both incoming messages and stored data. Their high availability is important, since it is the sensor readings that mainly operate on both user rules and our internal services. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a database, horizontal scaling for reading and writing, availability and fault tolerance, as well as the availability of ready-made analytical tools for working with this data array, preferably based on SQL, are important. At the same time, we can sacrifice consistency and ACID transactions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, in the framework of the CAP theorem, we need an AP system. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additional requirements</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We had several additional requirements for deciding where the gigantic amounts of data would be stored:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time Series - data from sensors are time series, I wanted to get a specialized base.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open source - the advantages of open source code do not need comments.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A free cluster is a common scourge among newfangled databases.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Good compression - given the amount of data and in general their uniformity, I wanted to efficiently compress the stored data.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Successful operation - we wanted to start on a database that someone is already actively exploiting at close to our loads in order to minimize risks.</font></font></li>
</ol><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our decision</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">ClickHouse exclusively suited our requirements - a column-based database of time series with replication, multimaster, sharding, SQL support and a free cluster. </font><font style="vertical-align: inherit;">Moreover, Mail.ru has many years of successful experience in operating one of the largest ClickHouse clusters in storage volume. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But no matter how good ClickHouse is, and we have problems with it.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Database problems for these devices and their solution</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem with write performance.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Immediately there was a problem with the write performance of a large data stream. They need to be brought to the analytical database as quickly as possible so that the rules that analyze the flow of events in real time can look at the history of a particular device and decide whether to raise an alert or not. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solution to the problem</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . ClickHouse does not tolerate multiple single inserts (inserts), but works well with large packets (batches) of data - it easily copes with recording batches on millions of lines. We decided to buffer the incoming data stream, and then paste this data in batches.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66f/85b/77d/66f85b77dfb1fe8788658f7455bbb56b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we coped with poor recording performance. The recording</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
problem was resolved, but it cost us a significant delay of several seconds between data entering the system and their appearance in our database. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And this is critical for various algorithms that respond to data from sensors in real time. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Read performance issue.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stream analytics for real-time data processing constantly needs information from the database - these are tens of thousands of small queries. On average, one ClickHouse node holds about a hundred analytical queries at the same time; it was created for infrequent heavy analytical queries for processing large amounts of data. Of course, this is not suitable for calculating trends in the flow of data from hundreds of thousands of sensors.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20a/34a/2a9/20a34a2a9469b6a0276c8437a7dd6ec8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With a large number of requests ClickHouse does not work well. </font></font></i><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solving the problem</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . We decided to put a cache in front of ClickHouse, which will contain the most requested hot data for the last 24 hours. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The data for the last 24 hours is not data for a year, but also quite a significant amount of data, therefore, we also need an AP system with horizontal scaling for reading and writing, but with a focus on performance both for recording single events and for multiple reading. It also requires high availability, time series analytics, persistence, and built-in TTL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the end, we needed a quick ClickHouse, which can even store everything in memory for speed. </font><font style="vertical-align: inherit;">We did not find any suitable solution on the market, so we decided to construct it on the basis of Tarantool primitives:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persistence - is (WAL-logs + snapshots).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance - there is, all the data in memory.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scaling - there is replication + sharding.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">High availability - there is.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time series analytics tools (grouping, aggregation, etc.) - made on stored procedures.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TTL - made on stored procedures with one background fiber (coroutine).</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It turned out to be a convenient and productive solution - one instance holds 10,000 RPCs for reading, including analytical queries of up to tens of thousands of queries. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is the resulting architecture:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb3/ef4/260/fb3ef426007f70be5c2a737b75cea80b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Final architecture: ClickHouse as an analytical database and Tarantool cache that stores data in 24 hours</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New data type - state and its storage</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We selected specialized databases for all data, but the platform developed and a new data type appeared - state. </font><font style="vertical-align: inherit;">The state contains the current state of devices and sensors, as well as various global variables for stream analytics rules. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, there is a light bulb in the room. </font><font style="vertical-align: inherit;">It can be both turned off and on, and you must always have access to its current state, including in the rules. </font><font style="vertical-align: inherit;">Another example is a variable in stream rules, for example, some kind of counter. </font><font style="vertical-align: inherit;">This type of data is characterized by the need for frequent recording and quick access, but at the same time the data themselves occupy a relatively small amount.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The meta-information repository is poorly suited for these types of data, since the state can change often, and in our case the recording ceiling is limited to one Master. </font><font style="vertical-align: inherit;">Long-term and operational storages are also poorly suited, since our state last changed three years ago, and it is important for us to have quick read access. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, for the database in which the state is stored, horizontal scaling for reading and writing, high availability and fault tolerance are important, while consistency is needed at the level of values ‚Äã‚Äã/ documents. </font><font style="vertical-align: inherit;">You can draw on the overall consistency and ACID transactions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A suitable solution could be any Key Value or a document database: a shaded Redis cluster, MongoDB, or again Tarantool. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantool Pros:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the most popular way to use Tarantool.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Horizontal scaling - there is asynchronous replication + sharding.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consistency at the document level - is.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, we now have three Tarantools, which we use for completely different cases: storing meta-information, a cache for quickly reading data from devices and storing status data.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to choose a database for the IoT platform</font></font></h2><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A universal database does not exist.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each type of data has its own database that is most suitable for it.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sometimes the database you need may not be available on the market.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarantool is suitable as the basis for a specialized database.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This talk was first made at </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@Databases Meetup</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by Mail.ru Cloud Solutions. </font><font style="vertical-align: inherit;">Watch a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> other performances and sign up for Telegram event announcements </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Around Kubernetes at Mail.ru Group</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What else to read</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What database to choose for the project, so as not to choose again</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More than Ceph: block storage in the MCS cloud</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
</ol><br>
</div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en497560/index.html">How quarantine affects the labor market in IT</a></li>
<li><a href="../en497562/index.html">Mitap: stay home and GOnline</a></li>
<li><a href="../en497564/index.html">Local Hack Day - Online Hackathon</a></li>
<li><a href="../en497566/index.html">Huffman Compression Algorithm</a></li>
<li><a href="../en497568/index.html">How LANIT employees work in remote locations in Italy and Belarus</a></li>
<li><a href="../en497572/index.html">Service oriented state management with lamp-luwak</a></li>
<li><a href="../en497574/index.html">Oncology in the context of the COVID-19 pandemic: how to save maximum lives</a></li>
<li><a href="../en497578/index.html">AMD is committed to gaining a significant share of the market for data centers</a></li>
<li><a href="../en497580/index.html">Hard quarantine is very very bad</a></li>
<li><a href="../en497582/index.html">Habr takes first place in the ranking of digital rights of users</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>