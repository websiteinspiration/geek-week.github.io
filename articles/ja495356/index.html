<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎚️ 👩🏻‍⚖️ 🎏 Javaでの分散KVストレージ用のRAFTコンセンサスアルゴリズムの実装 🎋 🖐🏽 🤞🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="また会いましたね。数日前、コース「ソフトウェアアーキテクト」の新しいグループでトレーニングが始まりました。今日は、コースの学生の1人であるアントンプレシャコフ（プログラムロジスティクスの開発責任者であり、クラスターラの共同創設者）が書いた記事を共有したいと思います。
 
 
 
 現在、分散型マイク...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Javaでの分散KVストレージ用のRAFTコンセンサスアルゴリズムの実装</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/495356/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">また会いましたね。数日前、コース</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ソフトウェアアーキテクト」の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいグループでトレーニングが始まりました。</font><font style="vertical-align: inherit;">今日は、コースの学生の1人である</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アントン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレシャコフ（プログラムロジスティクスの開発責任者であり、クラスターラの共同創設者）が</font><font style="vertical-align: inherit;">書いた記事を共有したいと思い</font><font style="vertical-align: inherit;">ます。</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/pb/5h/qq/pb5hqqeunfv8gkvyvspmegwuj4w.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、分散型マイクロサービスシステムは、企業の世界だけでなく、事実上業界標準になっています。分散システムを使用する利点については、何度も説明および説明されています。マイクロサービスの利点は、タスク、コンポーザビリティ、スケーラビリティ、開発のスケーリング、TTMの削減などのテクノロジーなど、誰もが長い間知っていました。分散アプリケーションの開発により、増大するビジネスの要求とすべてのデジタル化にタイムリーに対応するためのオプションが増えることは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイクロサービスを支持する開発戦略の選択に影響を与える非常に重要な要素は、分散システムの運用に伴う追加コストに関連する問題の解決策を講じるあらゆる種類の既製のインフラストラクチャソリューションの可用性であることに注意することも重要です。コンテナーオーケストレーションシステム、サービスマッシュ、分散トレースの手段、監視、ロギングなどについて話します。今日、マイクロサービスアプローチのマイナス要素として前述した要因のほとんどは、数年前ほど影響力が少ないと言っても過言ではありません。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現代の現実に基づいて、ほとんどの開発者は、モノリシック構造からマイクロサービス構造に切り替える最初の機会を求めています。完全なリファクタリングと深刻な分解に頼らずに実行できる最初のステップの1つは、水平スケーラビリティシステムを実現することです。つまり、モノリシックアプリケーションをクラスターに変換し、場合によっては同じモノリスで構成することもできますが、それらの数を動的に変化させることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
水平方向のスケーラビリティを実現しようとすると、クラスター内のデータ同期の問題が非常に迅速かつ非常に深刻になります。幸いなことに、最近のすべてのDBMSは、何らかの方法でノード間のデータ複製をサポートしています。開発者は、タスク用のDBMSを選択し、必要なシステムのプロパティ（CAPの定理に従って）、CPまたはAPを決定するだけで、問題は解決します。 CPが必要で、整合性の要件が高い場合、データ同期の問題を解決する方法の1つは、RAFTコンセンサスアルゴリズムをサポートするクラスターを使用することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このかなり新しいアルゴリズム（2012年に開発されました）は、一貫性の高い保証を提供し、非常に人気があります。私はそれがどのように機能するかを理解することに決め、Java（Spring Boot）で一貫したキー値リポジトリの実装を書きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分散アルゴリズムを自分で実装することは理にかなっていますか？分散アルゴリズムの既製の実装を採用できることは明らかであり、この実装は自家製の「自転車」よりも高い確率で実現されます。たとえば、必要なレベルの一貫性を維持するDBMSを使用できます。または、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zookeeper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をデプロイすることもできます</font><font style="vertical-align: inherit;">。または、あなたの言語に適したフレームワークを見つけることができます。 Javaには</font><font style="vertical-align: inherit;">、分散データの同期の問題を完全に解決する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atomix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし反対側です。ターンキーソリューションを採用する場合、通常、外部アプリケーションを使用すると、システムに障害ポイントがさらに追加されます。また、フレームワークは冗長であったり、操作や学習が困難であったり、プログラミング言語にまったく存在しない場合があります。さらに、コンセンサスアルゴリズムの独立した実装は非常に興味深いエンジニアリングタスクであり、これにより視野が広がり、サービスがより最適な方法を使用してクラスター内で相互作用するときに発生する問題を解決する方法を理解できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムの仕様には、データの整合性を維持するための一連の対策が含まれているため、取得した知識を使用でき、アルゴリズム全体を使用することもできます。アルゴリズムのどの部分も実際の生活に役立ちます。ファイルを並行して解析するための一連のワーカーがあるとします。ワーカーは同等ですが、ワーカーの1つをコーディネーターとして指定し、コーディネーターが落ちたら、他の空いているワーカーをコーディネーターとして割り当てます。同等のノードからリーダーを選択する方法を説明するRAFTアルゴリズムの前半は、これに役立ちます。または、たとえば、マスタースレーブに関連してノードが2つしかない場合、RAFT仕様で説明されているレプリケーションルールを使用して、より簡単なケースでデータ交換を整理できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は基本的に、RAFTを自分で実装する方法に関する実用的なガイドです。</font><font style="vertical-align: inherit;">アルゴリズム自体とその作業の理論的側面は理解されません。</font><font style="vertical-align: inherit;">ここでこの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優れた記事の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単な説明を読むか、ここで</font><font style="vertical-align: inherit;">仕様全体を調べる</font><font style="vertical-align: inherit;">ことができ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そこでは、アルゴリズムの非常に明確な視覚化を見つけることができます。</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的なソリューションの説明</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムの実装に直接関連するコードの部分は、記事で分析されています。</font><font style="vertical-align: inherit;">記事の最後に、コード全体を確認できるリポジトリへのリンクがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクは次のとおりです。</font><font style="vertical-align: inherit;">Key-Valueデータベースにデータを保存できる分散システムを開発します。</font><font style="vertical-align: inherit;">各ノードのデータは一貫している必要があります。つまり、データが1つのノードのデータベースに取り込まれ、ほとんどのノードがこのデータも受信していることが確認された場合、遅かれ早かれ、このデータは各ノードのデータベースに格納されます。</font><font style="vertical-align: inherit;">クラスターの一部が切断され、再び接続された場合、クラスター外にあったノードがメインクラスターに追いつき、同期する必要があります。</font><font style="vertical-align: inherit;">各ノードは、データベースデータを読み書きするためのREST APIを提供します。</font><font style="vertical-align: inherit;">システムは、クライアントとサーバーの2種類のノード用の2つのモジュールで構成されています。</font><font style="vertical-align: inherit;">以下では、サーバー自体の実装の機能について検討します。</font><font style="vertical-align: inherit;">クライアントコードはリポジトリにあります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーノードは、次の3つの状態で動作できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォロワー（フォロワー）。</font><font style="vertical-align: inherit;">クライアントからの読み取り要求を受け入れます。</font><font style="vertical-align: inherit;">リーダーから鼓動を奪う</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">候補者（candidate）。</font><font style="vertical-align: inherit;">クライアントからの読み取り要求を受け入れます。</font><font style="vertical-align: inherit;">他のノードに投票リクエストを送信します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">盟主 </font><font style="vertical-align: inherit;">読み取りおよび書き込み要求を受け入れます。</font><font style="vertical-align: inherit;">他のノードにハートビート要求を送信します。</font><font style="vertical-align: inherit;">追加要求データを他のノードに送信します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノードの1つの「リーダーシップ」の期間は、ラウンド（期間）と呼ばれます。</font><font style="vertical-align: inherit;">新しい候補者が新しいラウンドを開きます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データストレージ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ノードは、データを変更するための操作が順次記録される操作ログのリポジトリへのアクセスを提供します。</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/operations/OperationsLog.java<br>
</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OperationsLog</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(Operation operation)</span></span>;
   <span class="hljs-function">Operation <span class="hljs-title">get</span><span class="hljs-params">(Integer index)</span></span>;
   <span class="hljs-function">List&lt;Operation&gt; <span class="hljs-title">all</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
   <span class="hljs-function">Long <span class="hljs-title">getTerm</span><span class="hljs-params">(Integer index)</span></span>;
   <span class="hljs-function">Integer <span class="hljs-title">getLastIndex</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">Long <span class="hljs-title">getLastTerm</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeAllFromIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newOperationIndex)</span></span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各操作には、データとタイプ（挿入、変更、削除）に加えて、作成されたラウンドの番号が含まれています。さらに、各操作には、順次増加するインデックスがあります。すべての操作は、リーダーのログに挿入されたのと同じ順序でフォロワーのログに挿入されることが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ノードは、データが直接格納されているデータベースにアクセスできます。</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/storage/Storage.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Storage</span> </span>{
   <span class="hljs-function">List&lt;Entry&gt; <span class="hljs-title">all</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(Long key)</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Long key, String val)</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Long key, String val)</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Long key)</span></span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在の実装では、ログとデータベース（通常の競合リストとマップ）の両方に埋め込みメモリソリューションが使用されています。必要に応じて、適切なインターフェースを実装するだけで、他のタイプのストレージをサポートできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ログからデータベースへの操作の適用は、分散状態マシンによって実行されます。ステートマシンは、クラスターの状態を変更し、誤った変更（順不同の操作またはそれ自体をリーダーと見なす切断されたノード）の使用を制限するメカニズムです。変更が有効であると見なされ、変更がデータベースに適用されるためには、一連のチェックに合格し、特定の基準を満たす必要があります。これは、ステートマシンが提供するものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リーダーの場合、ほとんどのノードが操作がログにも複製されることを確認した場合、操作はデータベースに適用されます。</font><font style="vertical-align: inherit;">フォロワーの場合、リーダーからデータベースに入力されたシグナルを受信すると、操作はデータベースに適用されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイマー </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ノードは他のノードとのデータ交換を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2種類のクエリがサポートされています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投票のラウンドを行うときに投票する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加、別名ハートビート（データがない場合）。ログデータをフォロワーに複製し、新しい投票が開始されないようにします。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントの開始の事実は、タイマーによって決定されます。</font><font style="vertical-align: inherit;">ノードでは2種類のタイマーが起動されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投票。</font><font style="vertical-align: inherit;">投票のラウンドを開始します。</font><font style="vertical-align: inherit;">各ノードには独自の間隔があり、その後、新しい投票を開始しようとします。</font><font style="vertical-align: inherit;">リーダーからハートビートを受け取ると、新たにカウントダウンが始まります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハートビート。</font><font style="vertical-align: inherit;">アペンドリーダーがフォロワーにリクエストを送信します。</font><font style="vertical-align: inherit;">ノードがハートビートを受信せず、投票タイマーの期限が切れた場合、そのノードは候補になり、選挙を開始し、投票ラウンドの数を増やし、投票リクエストを他のノードに送信します。</font><font style="vertical-align: inherit;">ノードが過半数の票を集めると、そのノードがリーダーになり、ハートビートの送信を開始します。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノードの現在の状態</font></font></h3> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ノードは現在の状態に関するデータを保存します。</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/context/Context.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Context</span> </span>{
   <span class="hljs-function">Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//    </span>
   <span class="hljs-function">State <span class="hljs-title">getState</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//: , ,  </span>
   <span class="hljs-function">Integer <span class="hljs-title">getVotedFor</span><span class="hljs-params">()</span></span>; 
               <span class="hljs-comment">//          </span>
   <span class="hljs-function">Long <span class="hljs-title">getCurrentTerm</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//  </span>
   <span class="hljs-function">Integer <span class="hljs-title">getCommitIndex</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//    </span>
   <span class="hljs-function">List&lt;Peer&gt; <span class="hljs-title">getPeers</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//      </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リーダーノードは、データの複製先のノードのメタデータも保存します。</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/node/peers/Peer.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Peer</span> </span>{
   <span class="hljs-function">Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//  </span>
   <span class="hljs-function">Integer <span class="hljs-title">getNextIndex</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//  ,    </span>
   <span class="hljs-function">Integer <span class="hljs-title">getMatchIndex</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//   </span>
   <span class="hljs-function">Boolean <span class="hljs-title">getVoteGranted</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//     </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノードのメタデータは、フォロワーからの応答を受信したときにリーダーによって更新されます。</font><font style="vertical-align: inherit;">これらは、リーダーがフォロワーが受け入れる準備ができている次のインデックス操作と、フォロワーのログにすでに追加されている操作を決定するために使用されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投票</font></font></h3><br><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ElectionService</font></a><font style="vertical-align: inherit;"> 
クラスは投票を担当します</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ElectionService</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processElection</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">AnswerVoteDTO <span class="hljs-title">vote</span><span class="hljs-params">(RequestVoteDTO requestVoteDTO)</span></span>;<font></font>
} </code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投票のリクエストを送信する </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノードがフォロワーであり、待機に設定された期間ハートビートを受信しない場合は、現在のラウンドを増やし、候補を宣言し、他のノードへの投票要求の送信を開始します。</font><font style="vertical-align: inherit;">彼がなんとかクォーラムを収集し、ほとんどのノードが投票した場合、彼は新しいリーダーになります。</font><font style="vertical-align: inherit;">RAFTの用語では、クォーラムはすべてのノードの半分（51％）を超えています。</font><font style="vertical-align: inherit;">投票期限が切れたときに投票タイマーによって呼び出され、ノード</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">に投票要求を</font></a><font style="vertical-align: inherit;">送信</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
する</font></font><code>processElection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">メソッドを分析してみましょう</font><font style="vertical-align: inherit;">。</font></font><code>ElectionServiceImpl</code><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
 <br>
<pre><code class="java hljs"><span class="hljs-comment">//1</span><font></font>
context.setState(CANDIDATE); <font></font>
Long term = context.incCurrentTerm(); <font></font>
context.setVotedFor(context.getId()); <font></font>
<font></font>
List&lt;Integer&gt; peersIds = context.getPeers().stream().map(Peer::getId).collect(Collectors.toList());<font></font>
<span class="hljs-keyword">long</span> voteGrantedCount = <span class="hljs-number">1L</span>;
<span class="hljs-keyword">long</span> voteRevokedCount = <span class="hljs-number">0L</span>;<font></font>
<font></font>
<span class="hljs-comment">//2</span>
<span class="hljs-keyword">while</span> (checkCurrentElectionStatus(term)) {<font></font>
   List&lt;AnswerVoteDTO&gt; answers = getVoteFromAllPeers(term, peersIds);<font></font>
   peersIds = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
   <span class="hljs-keyword">for</span> (AnswerVoteDTO answer : answers) {
       <span class="hljs-comment">//3</span>
       <span class="hljs-keyword">if</span> (answer.getStatusCode().equals(OK)) {
           <span class="hljs-comment">//4</span>
           <span class="hljs-keyword">if</span> (answer.getTerm()&gt;context.getCurrentTerm()) {<font></font>
               context.setTermGreaterThenCurrent(answer.getTerm());<font></font>
               <span class="hljs-keyword">return</span>;<font></font>
           }<font></font>
           <span class="hljs-keyword">if</span> (answer.isVoteGranted()) {
               <span class="hljs-comment">//5 </span>
               context.getPeer(answer.getId()).setVoteGranted(<span class="hljs-keyword">true</span>);<font></font>
               voteGrantedCount++;<font></font>
           } <span class="hljs-keyword">else</span>
               <span class="hljs-comment">//6 </span><font></font>
               voteRevokedCount++;<font></font>
       } <span class="hljs-keyword">else</span> {<font></font>
          peersIds.add(answer.getId());<font></font>
       }<font></font>
   }<font></font>
  <span class="hljs-comment">//7</span>
  <span class="hljs-keyword">if</span> (voteGrantedCount &gt;= context.getQuorum()) {<font></font>
       winElection(term);<font></font>
       <span class="hljs-keyword">return</span>;<font></font>
   } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (voteRevokedCount &gt;= context.getQuorum()) {<font></font>
       loseElection(term);<font></font>
       <span class="hljs-keyword">return</span>;<font></font>
   } </code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「候補」のステータスを設定します。</font><font style="vertical-align: inherit;">ラウンド数を上げて、自分に投票します。</font></font></li>
<li>  ,       (    ).  -  ,        ,           heartbeat                 .</li>
<li> -  ,    .    ,      ,     -. </li>
<li>       ,                            .     ,      heartbeat     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノードが投票しました！</font><font style="vertical-align: inherit;">投票するノードの数を増やし、このノードが投票したことを修正します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちのために投票しなかった、私たちはまた信じています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クォーラムが収集され、ノードが選挙に勝った場合、「リーダー」のステータスを確立します。</font><font style="vertical-align: inherit;">それ以外の場合は、フォロワーになって待機します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノードがリーダーになると、リーダーによって保存されたノードのリスト内の各ノードに次のインデックスが設定されることにも注意してください。これは、リーダーのログの最後のインデックスに1を加えたものに等しくなります。このインデックスから始めて、リーダーはフォロワーのログを更新しようとします。</font><font style="vertical-align: inherit;">実際、リーダーによって保存されたこのインデックスは、フォロワーのログの実際のインデックスに対応していない場合があり、実際の値はフォロワーとデータを交換する場合にのみ取得され、調整されます。</font><font style="vertical-align: inherit;">しかし、いくつかの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出発点が</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要です</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">winElection</span><span class="hljs-params">(Long term)</span> </span>{<font></font>
       context.setState(LEADER);<font></font>
       context.getPeers().forEach(peer -&gt;<font></font>
               peer.setNextIndex(operationsLog.getLastIndex()+<span class="hljs-number">1</span>)<font></font>
<font></font>
       );<font></font>
   }</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投票依頼処理 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
投票するとき、各ノードは候補者から</font><font style="vertical-align: inherit;">次の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形式のリクエストを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受け取ります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestVoteDTO</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long term; <span class="hljs-comment">//     </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer candidateId; <span class="hljs-comment">//  </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer lastLogIndex; <span class="hljs-comment">//     </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long lastLogTerm; <span class="hljs-comment">//       </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで</font></font><code>vote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスの</font><font style="vertical-align: inherit;">手順を見てみましょう。これ</font></font><code>ElectionServiceImpl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、候補者からの投票要求を処理し、リーダーの役割の候補者に関する決定を返します。</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://github.com/pleshakoff/raft/blob/eba5ea1984e2623702f4c299cf1b0af7a6ba0d14/server/src/main/java/com/raft/server/election/ElectionServiceImpl.java#L178 <br>
</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> AnswerVoteDTO <span class="hljs-title">vote</span><span class="hljs-params">(RequestVoteDTO dto)</span> </span>{<font></font>
   <font></font>
       <span class="hljs-keyword">boolean</span> termCheck;
       <span class="hljs-comment">//1</span>
       <span class="hljs-keyword">if</span> (dto.getTerm() &lt; context.getCurrentTerm())
           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerVoteDTO(context.getId(),context.getCurrentTerm(),<span class="hljs-keyword">false</span>);
       <span class="hljs-keyword">else</span> <span class="hljs-comment">//2</span>
       <span class="hljs-keyword">if</span> (dto.getTerm().equals(context.getCurrentTerm())) {<font></font>
           termCheck = (context.getVotedFor() == <span class="hljs-keyword">null</span>||<font></font>
                          context.getVotedFor().equals(dto.getCandidateId()));<font></font>
       }<font></font>
       <span class="hljs-keyword">else</span>
       {   <span class="hljs-comment">//3</span>
           termCheck = <span class="hljs-keyword">true</span>;<font></font>
             context.setTermGreaterThenCurrent(dto.getTerm());<font></font>
       }<font></font>
<font></font>
       <span class="hljs-comment">//4  </span>
       <span class="hljs-keyword">boolean</span> logCheck = !((operationsLog.getLastTerm() &gt; dto.getLastLogTerm()) ||<font></font>
               ((operationsLog.getLastTerm().equals(dto.getLastLogTerm())) &amp;&amp;<font></font>
                       (operationsLog.getLastIndex() &gt; dto.getLastLogIndex())));<font></font>
<font></font>
<font></font>
       <span class="hljs-keyword">boolean</span> voteGranted = termCheck&amp;&amp;logCheck;<font></font>
<font></font>
       <span class="hljs-comment">//5</span>
       <span class="hljs-keyword">if</span> (voteGranted) {<font></font>
           context.setVotedFor(dto.getCandidateId());<font></font>
       }<font></font>
       <span class="hljs-comment">//6   </span>
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerVoteDTO(context.getId(),context.getCurrentTerm(),voteGranted);<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
候補者からのリクエストを受信すると、ノードは2つのチェックを行います。候補者のラウンドとログの長さをチェックします。</font><font style="vertical-align: inherit;">候補者のラウンドが高く、対数が長いか等しい場合、ノードはノードに候補者への投票を与えます</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のノットのラウンドが候補のラウンドよりも大きい場合、これは遅延ノットの要求であり、明らかにクラスターの外にしばらくの間存在し、現在のリーダーが見つからなかったために選挙手順を開始したため、拒否します。 </font></font></li>
<li>   ,   , ,           ,        ,     ,       ;       .              —    .</li>
<li>     ,     </li>
<li> .                   ,            ,  ,        ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">肯定的な結果により、ノードが選挙に参加し、候補者に投票したという事実を修正します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果を候補者に送り返す</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確かに、条件は少し短く、よりエレガントに書くことができたかもしれませんが、私は混乱しないように、そして誰も混乱させないように、もっと「素朴な」オプションを残しました。 </font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レプリケーション </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイマーリーダーは、ハートビートフォロワーをすべてのノードに送信して、投票タイマーをリセットします。リーダーはすべてのフォロワーの最後の操作のメタデータインデックスを保存しているため、操作をノードに送信する必要があるかどうかを評価できます。リーダーの操作ログがフォロワーのログよりも長くなると、リーダーはハートビートとともに、欠落している操作を順番に送信します。追加要求と呼びます。ほとんどのノードが新しい操作の受信を確認すると、リーダーはこれらの操作を自分のデータベースに適用し、最後に適用された操作のインデックスを増やします。このインデックスは、ハートビート要求とともにフォロワーにも送信されます。また、リーダーインデックスがフォロワーインデックスよりも高い場合、フォロワーもインデックスを等しくするためにデータベースに操作を適用します。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リーダーがフォロワーに送信するこの種の追加リクエスト</font></font></a><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestAppendDTO</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long term; <span class="hljs-comment">//   </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer leaderId; <span class="hljs-comment">//   </span><font></font>
<font></font>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer prevLogIndex;<span class="hljs-comment">//   </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long prevLogTerm;<span class="hljs-comment">//   </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer leaderCommit;<span class="hljs-comment">//      </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Operation operation; <span class="hljs-comment">//</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
操作がリクエストごとにいくつかのバッチで転送される実装があります。</font><font style="vertical-align: inherit;">現在の実装では、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエスト</font><font style="vertical-align: inherit;">ごとに送信できるオペレーションは1つだけ</font><font style="vertical-align: inherit;">です。クラスは、ハートビート追加リクエストの送信と処理に応答します。</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://github.com/pleshakoff/raft/blob/eba5ea1984e2623702f4c299cf1b0af7a6ba0d14/server/src/main/java/com/raft/server/replication/ReplicationService.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReplicationService</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendRequest</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">AnswerAppendDTO <span class="hljs-title">append</span><span class="hljs-params">(RequestAppendDTO requestAppendDTO)</span></span>;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ変更リクエストを送信する </font></font></h3><br><font style="vertical-align: inherit;"></font><code>sendAppendForOnePeer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font></font><code>ReplicationServiceImpl</code><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
フラグメントについて考えてみましょう</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">。このメソッドは、フォロワーへのリクエストの生成と送信を担当し</font></a><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> CompletableFuture&lt;AnswerAppendDTO&gt; <span class="hljs-title">sendAppendForOnePeer</span><span class="hljs-params">(Integer id)</span> </span>{
   <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; {
       <span class="hljs-keyword">try</span> {
           <span class="hljs-comment">//1</span><font></font>
           Peer peer = context.getPeer(id);<font></font>
<font></font>
           Operation operation;<font></font>
           Integer prevIndex;<font></font>
           <span class="hljs-comment">//2    </span>
           <span class="hljs-keyword">if</span> (peer.getNextIndex() &lt;= operationsLog.getLastIndex()) {<font></font>
               operation = operationsLog.get(peer.getNextIndex());<font></font>
               prevIndex = peer.getNextIndex() - <span class="hljs-number">1</span>;<font></font>
           } <span class="hljs-keyword">else</span> 
           <span class="hljs-comment">//3  </span><font></font>
           {<font></font>
               operation = <span class="hljs-keyword">null</span>;<font></font>
               prevIndex = operationsLog.getLastIndex();<font></font>
           }<font></font>
<font></font>
<font></font>
           RequestAppendDTO requestAppendDTO = <span class="hljs-keyword">new</span> RequestAppendDTO(<font></font>
                   context.getCurrentTerm(), <span class="hljs-comment">//   </span>
                   context.getId(), <span class="hljs-comment">//  </span>
                   prevIndex,<span class="hljs-comment">//      </span>
                   operationsLog.getTerm(prevIndex),<span class="hljs-comment">//  </span><font></font>
                   context.getCommitIndex(),<font></font>
                               <span class="hljs-comment">//      </span>
                   Operation <span class="hljs-comment">//</span><font></font>
           );<font></font>
<font></font>
...<font></font>
<span class="hljs-comment">/*   http     */</span>
}</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォロワーのメタデータ</font></font></li>
<li>   ,   .             (      ),          ,      ,  ,   .    ,       ,    ,   ,     </li>
<li>   ,    ,       ;        ,     ,       ,  </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、</font></font><code>appendRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">メソッドについて考えます。この</font><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">メソッド</font></font><code>ReplicationServiceImpl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、追加要求を送信し、その結果をすべてのフォロワーに処理します。</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://github.com/pleshakoff/raft/blob/eba5ea1984e2623702f4c299cf1b0af7a6ba0d14/server/src/main/java/com/raft/server/replication/ReplicationServiceImpl.java#L109</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendRequest</span><span class="hljs-params">()</span> </span>{<font></font>
       List&lt;Integer&gt; peersIds = context.getPeers().stream().map(Peer::getId).collect(Collectors.toList());<font></font>
<font></font>
       <span class="hljs-comment">//1 </span>
       <span class="hljs-keyword">while</span> (peersIds.size() &gt; <span class="hljs-number">0</span>) {
           <span class="hljs-comment">//2 </span><font></font>
           List&lt;AnswerAppendDTO&gt; answers = sendAppendToAllPeers(peersIds);<font></font>
           peersIds = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
           <span class="hljs-keyword">for</span> (AnswerAppendDTO answer : answers) {
               <span class="hljs-comment">//3</span>
               <span class="hljs-keyword">if</span> (answer.getStatusCode().equals(OK)) {
                   <span class="hljs-comment">//4</span>
                   <span class="hljs-keyword">if</span> (answer.getTerm() &gt; context.getCurrentTerm()) {<font></font>
                        context.setTermGreaterThenCurrent(answer.getTerm());<font></font>
                       <span class="hljs-keyword">return</span>;<font></font>
                   }<font></font>
                   Peer peer = context.getPeer(answer.getId());<font></font>
                   <span class="hljs-comment">//5     </span>
                   <span class="hljs-keyword">if</span> (answer.getSuccess()) {                      <font></font>
                       peer.setNextIndex(answer.getMatchIndex() + <span class="hljs-number">1</span>);<font></font>
                       peer.setMatchIndex(answer.getMatchIndex());<font></font>
                       <span class="hljs-keyword">if</span> (peer.getNextIndex() &lt;= operationsLog.getLastIndex())<font></font>
                           peersIds.add(answer.getId());<font></font>
                   <span class="hljs-comment">//6      </span>
                   } <span class="hljs-keyword">else</span> {<font></font>
                       peer.decNextIndex();<font></font>
                       peersIds.add(answer.getId());<font></font>
                   }<font></font>
               }<font></font>
           }<font></font>
           <span class="hljs-comment">//7</span><font></font>
           tryToCommit();<font></font>
       }<font></font>
}<font></font>
</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのフォロワーから複製が成功したという応答を受け取るまで、要求を繰り返します。</font><font style="vertical-align: inherit;">リクエストごとに1つの操作が送信されるため、フォロワーのログを同期するために数回の反復が必要になる場合があります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのフォロワーにリクエストを送信し、回答のリストを取得します </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">利用可能なフォロワーからの回答のみを考慮します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォロワーの1人のラウンドがリーダーのラウンドよりも多いことが判明した場合、すべてを停止してフォロワーになります </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォロワーがすべて成功したと返信した場合は、フォロワーのメタデータを更新します。フォロワーのログの最後のインデックスと、フォロワーが期待する次の操作のインデックスを保存します。 </font></font></li>
<li>  ,    ,  ,           ,           .  ,                  ,      .     ,         .    ,          .</li>
<li>        ,      .     . </li>
</ol><br>
<h3>     </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、フォロワーがリーダーからの追加要求を正確に処理する方法を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見てみましょう</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">。</font></a><font style="vertical-align: inherit;">クラス</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド</font></font><code>append</code><font style="vertical-align: inherit;"></font><code>ReplicationServiceImpl</code><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> AnswerAppendDTO <span class="hljs-title">append</span><span class="hljs-params">(RequestAppendDTO dto)</span> </span>{<font></font>
     <font></font>
       <span class="hljs-comment">//1     </span>
       <span class="hljs-keyword">if</span> (dto.getTerm() &lt; context.getCurrentTerm()) {
           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(),context.getCurrentTerm(),<span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<font></font>
       } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dto.getTerm() &gt; context.getCurrentTerm()) {
           <span class="hljs-comment">//2 </span><font></font>
           context.setCurrentTerm(dto.getTerm());<font></font>
           context.setVotedFor(<span class="hljs-keyword">null</span>);<font></font>
       }<font></font>
       <span class="hljs-comment">//3  </span>
       applicationEventPublisher.publishEvent(<span class="hljs-keyword">new</span> ResetElectionTimerEvent(<span class="hljs-keyword">this</span>));<font></font>
<font></font>
       <span class="hljs-keyword">if</span> (!context.getState().equals(FOLLOWER)) {<font></font>
           context.setState(FOLLOWER);<font></font>
       }<font></font>
        <font></font>
       <span class="hljs-comment">//4  </span>
       <span class="hljs-keyword">if</span> ((dto.getPrevLogIndex() &gt; operationsLog.getLastIndex()) ||                                                                                        !dto.getPrevLogTerm().equals(operationsLog.getTerm(dto.getPrevLogIndex()))) {
                      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(), context.getCurrentTerm(), <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<font></font>
       }<font></font>
<font></font>
<font></font>
       Operation newOperation = dto.getOperation();<font></font>
       <span class="hljs-keyword">if</span> (newOperation != <span class="hljs-keyword">null</span>) {
           <span class="hljs-keyword">int</span> newOperationIndex = dto.getPrevLogIndex() + <span class="hljs-number">1</span>;<font></font>
           <font></font>
         <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
               <span class="hljs-comment">//5</span>
               <span class="hljs-keyword">if</span> ((newOperationIndex &lt;= operationsLog.getLastIndex()) &amp;&amp;<font></font>
                      (!newOperation.getTerm().equals(operationsLog.getTerm(newOperationIndex)))){<font></font>
                   operationsLog.removeAllFromIndex(newOperationIndex);<font></font>
               }<font></font>
               <span class="hljs-comment">//6</span>
               <span class="hljs-keyword">if</span> (newOperationIndex &lt;= operationsLog.getLastIndex())<font></font>
               {<font></font>
                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(), context.getCurrentTerm(), <span class="hljs-keyword">true</span>,      operationsLog.getLastIndex());<font></font>
               }<font></font>
               <span class="hljs-comment">//7</span><font></font>
               operationsLog.append(newOperation);<font></font>
           }<font></font>
        }<font></font>
        <span class="hljs-comment">//8 </span>
        <span class="hljs-keyword">if</span> (dto.getLeaderCommit() &gt; context.getCommitIndex()) {<font></font>
           context.setCommitIndex(Math.min(dto.getLeaderCommit(), operationsLog.getLastIndex()));<font></font>
       }<font></font>
<font></font>
                 <font></font>
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(), context.getCurrentTerm(), <span class="hljs-keyword">true</span>, operationsLog.getLastIndex());<font></font>
   }</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リーダーのラウンドがフォロワーのラウンドよりも少ない場合は、リーダーにラウンドと彼のリクエストが拒否されたというサインを送信します。</font><font style="vertical-align: inherit;">リーダーが応答よりも大きなラウンドを受け取るとすぐに、彼はフォロワーに変わります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リーダーのラウンドがフォロワーのラウンドよりも多い場合は、このラウンドをフォロワーに設定します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リーダーからリクエストを受け取ったので、データの有無に関わらず投票タイマーをリセットし、フォロワーでない場合は投票タイマーになります </font></font></li>
<li>   ,   ,            ,  ,   ,    ,   .        ,    ,      </li>
<li>              ,   .            .   ,     , - ,   ,      ,      ,      .             ,    .</li>
<li>  ,   .  ,    </li>
<li>  ,     </li>
<li>        ,   ,       ,    . </li>
</ol><br>
<h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リーダーがログからデータベースに操作をどのように適用するかを理解するだけです。操作をフォロワーに送信し、フォロワーからの応答を処理するプロセスで、リーダーはノードのメタデータを更新します。ログ内の最後の操作のインデックスが、リーダーによってデータベースに適用された最後の操作のインデックスよりも大きいノードの数がクォーラムと等しくなるとすぐに、ほとんどのノードが操作を受け取ってリーダーデータベースに適用できることを示すことができます。つまり、リーダーがフォロワーに操作を送信し、そのほとんどがフォロワーに操作を挿入してリーダーに回答した場合、この操作をリーダーのデータベースに適用し、最後に適用された操作のインデックスを増やすことができます。次の追加ハートビート要求を含むこのインデックスは、フォロワーに飛ん</font><font style="vertical-align: inherit;">で、同じインデックスを持つ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をログからデータベースに適用します。</font></font><br>
<br><font style="vertical-align: inherit;"></font><code>tryToCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">
メソッドを分析してみましょう</font></font><code>ReplicationServiceImpl</code><br>
<br>
<pre><code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryToCommit</span><span class="hljs-params">()</span> </span>{
       <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
           <span class="hljs-comment">//1</span>
           <span class="hljs-keyword">int</span> N = context.getCommitIndex() + <span class="hljs-number">1</span>;
           <span class="hljs-comment">//2</span><font></font>
           Supplier&lt;Long&gt; count = () -&gt;<font></font>
               context.getPeers().stream().map(Peer::getMatchIndex).<font></font>
                       filter(matchIndex -&gt; matchIndex &gt;= N).count() + <span class="hljs-number">1</span>;<font></font>
<font></font>
           <span class="hljs-comment">//3 </span>
           <span class="hljs-keyword">if</span> (operationsLog.getLastIndex() &gt;= N &amp;&amp;<font></font>
                   operationsLog.getTerm(N).equals(context.getCurrentTerm())&amp;&amp;<font></font>
                      count.get()&gt;=context.getQuorum()<font></font>
           )<font></font>
           {<font></font>
               context.setCommitIndex(N);<font></font>
           } <span class="hljs-keyword">else</span>
               <span class="hljs-keyword">return</span>;<font></font>
       }<font></font>
   }</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースに適用された操作の次のインデックスを取得します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのようなインデックスを持つ操作をログに記録しているフォロワーの数を数え、リーダーを追加することを忘れないでください </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのようなフォロワーの数が定足数であり、そのようなインデックスを持つ操作がリーダーのログにあり、この操作のラウンドが現在の操作と等しい場合、リーダーは操作をデータベースに適用し、最後に適用された操作のインデックスを増やします。</font><font style="vertical-align: inherit;">前のラウンドの操作は適用できません。別のリーダーが担当し、競合が発生する可能性があるためです。</font><font style="vertical-align: inherit;">各リーダーは、彼の現在のラウンドの操作のみを適用します。</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAFTのファミリーの代表である分散アルゴリズムは、仕様に記載されているすべてのルールに従って、結果の達成を保証する強力な統合ソリューションです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの分散アルゴリズムがあり、それらは異なります。 Zookeeperに実装されているZABがあり、たとえば、Kafkaでデータを同期するために使用されます。たとえば、APシステムで使用されるGossipプロトコルの大量実装など、一貫性の要件が厳しくないアルゴリズムがあります。 RAFTの原則に従うアルゴリズムがあり、同時に暗号化も使用するMOKKAなどのログを交換するためにゴシッププロトコルを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのアルゴリズムのいずれかを理解することは、どの開発者にとっても非常に有用であると私は信じています。前述のように、ソリューションは包括的および個別の部分の両方で興味深いものになる可能性があります。</font><font style="vertical-align: inherit;">そして、明らかに、標準的な産業用ソリューションを使用している場合でも、分散システムの開発とデータ同期の問題に関連する活動を行う方向に、この方向に目を向ける必要があります。</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リポジトリ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単な説明</font></font></a></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この資料がお役に立てば幸いです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コースを受講し</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たい場合</font><font style="vertical-align: inherit;">は、すぐに</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">受講</font></a><font style="vertical-align: inherit;">できます。</font></font></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja495344/index.html">統一：LamodaがGoサービスを一貫させる方法</a></li>
<li><a href="../ja495346/index.html">エラーからアクションによるアラートまで</a></li>
<li><a href="../ja495348/index.html">研究：Covid-19がメールマーケティングのパフォーマンスに与える影響</a></li>
<li><a href="../ja495350/index.html">ホームWebサーバー、または独自のホスティングプロバイダー</a></li>
<li><a href="../ja495354/index.html">死ぬことなく20の言語で製品を継続的にリリースする方法は？</a></li>
<li><a href="../ja495358/index.html">Kubernetesで欠落しているイメージを検出するためのk8s-image-availability-exporterの紹介</a></li>
<li><a href="../ja495360/index.html">C＃からC ++への製品の移植を自動化した方法</a></li>
<li><a href="../ja495362/index.html">自己分離とプログラム：家で夢中にならないようにして、便利に時間を過ごす方法</a></li>
<li><a href="../ja495364/index.html">APIスタイルガイド、またはユーザーに考えさせない</a></li>
<li><a href="../ja495366/index.html">16種類のプログラマ、または開発者は同じロボットではありません</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>