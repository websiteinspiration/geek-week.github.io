<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóíÔ∏è üíÖüèª üë©üèª‚Äçüî¨ The great split in import: clarifying the uncertainty with import in Typescript ‚è≠Ô∏è üìë üëÜüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A translation of the article was prepared ahead of the start of the course "React.js Developer"
 
 
 I have been working with typescript for quite som...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>The great split in import: clarifying the uncertainty with import in Typescript</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/507104/"><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A translation of the article was prepared ahead of the start of the course </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"React.js Developer"</font></font></a></b></i><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 I have been working with typescript for quite some time, and I had a lot of problems with sorting out its modules and advising settings, and I must say, there really is a lot of incomprehensible around them. Namespace </font></font><code> import * as React from 'react'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>esModuleInterop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etc. Therefore, let's understand why all the hype arose. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will not talk about namespaces as a modular system in typescript, because the idea was not the best (especially considering the current development vector), and nobody is using it now.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, how were things before they appeared </font></font><code>esModuleInterop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">There were almost all the same modules that babel or browsers had, as well as named imports / exports. </font><font style="vertical-align: inherit;">However, in matters of exports and imports by default, typescript had its own option: it was necessary to write </font></font><code>import * as React from 'react'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(instead </font></font><code>import React from 'react'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), and, of course, here we are talking not only about react, but about all default imports from </font></font><code>commonjs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">How did it happen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To understand this, let's see how the compatibility between some patterns in </font></font><code>commonjs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">modules works </font></font><code>es6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For example, we have a module that exports </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as keys:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">module</span>.exports = { foo, bar }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 We can import using require and destructuring:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> { foo, bar } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'my-module'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 And apply the same principle using named imports (although, to be honest, this is not a destructuring):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { foo, bar } <span class="hljs-keyword">from</span> <span class="hljs-string">'my-module'</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 However, the more common pattern in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commonjs</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is </font></font><code>const myModule = require('my-module')</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(because there hasn't been a destructuring yet), but how do you do it in </font></font><code>es6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When developing the specification for import, </font></font><code>es6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one of the important aspects was compatibility with </font></font><code>commonjs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, since a </font></font><code>commonjs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lot of code was already written </font><font style="vertical-align: inherit;">on </font><font style="vertical-align: inherit;">it. This is how the default import and export appeared. Yes, the only goal was to ensure compatibility with </font></font><code>commonjs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so that we could write </font></font><code> import myModule from 'my-module</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and get exactly the same result. However, from the specifications this was not obvious, and besides, the implementation of compatibility was the prerogative of the developers of the transpiler. And here the great schism just happened: </font></font><code> import React from 'react'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>import * as React from 'react'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- that is the question.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why did typescript choose the latter? </font><font style="vertical-align: inherit;">Put yourself in the place of the transpiler developer and ask yourself, what is the easiest way to transport imports from </font></font><code>es6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>commonjs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Suppose you have the following set of imports and exports:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-number">1</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> bar = <span class="hljs-number">2</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; {}
<span class="hljs-keyword">import</span> { foo } <span class="hljs-keyword">from</span> <span class="hljs-string">'module'</span>
<span class="hljs-keyword">import</span> func <span class="hljs-keyword">from</span> <span class="hljs-string">'module'</span><span class="hljs-string">`</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 So, we will use the object </font></font><code>js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the key </font></font><code>default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for export by default!</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">default</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}<font></font>
}<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'module'</span>)
<span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">module</span>.foo
<span class="hljs-keyword">const</span> func = <span class="hljs-built_in">module</span>.default</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Cool, but what about compatibility? If import by default means that we take a field with a name </font></font><code>default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then when we write </font></font><code>import React from 'react'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it will mean </font></font><code>const { default: React } = require('react')</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but it doesn‚Äôt work! Then instead try using import with an asterisk. Now users will have to write </font></font><code>import * as React from 'react'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to get to the content </font></font><code>module.exports</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, there is a semantic difference from </font></font><code>commonjs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<code>Commonjs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was like regular javascript, no more. Just functions and objects, without any </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">require</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . On the other hand, in import </font></font><code>es6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it is </font></font><code>require</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">now part of the specification, therefore</font></font><code>myModule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in this case, this is not just a regular javascript object, but what is called a namespace (not to be confused with namespaces in typescript), which, accordingly, has certain properties. </font><font style="vertical-align: inherit;">One of them is that the namespace cannot be called. </font><font style="vertical-align: inherit;">And what is the problem here, you may ask? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's try another pattern </font></font><code>commonjs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, with one function as an export:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// do something }</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 We can use </font></font><code>require</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and execute it:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">require</span>(<span class="hljs-string">'my-module'</span>)<font></font>
foo()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Although if you try to do this in a spec-complaint environment with ES6 modules, you will get an error:</font></font><br>
 <br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">'my-module'</span>
foo() <span class="hljs-comment">// Error</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 That's because the namespace is not the same as the javascript object, but a separate structure that stores each es6 export. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But Babel got it right and provided a compatibility option where we can write </font></font><code>import React from 'react</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'and it will work. During transpilation, he marks each es6 module with a special flag in </font></font><code>module.exports</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so that we understand that if the flag is true, then it is returned </font></font><code>module.exports</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and if it is false (for example, if it is a library </font></font><code>commonjs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that has not been transposed), then we will need to wrap the current export in </font></font><code>{ default: export }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that we could use every time </font></font><code>default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(take a look </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typescript made its way through imports with asterisks, but eventually gave up and added an option</font></font><code>esModuleInterop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the compiler. In general, this option does the same as babel, and if you enable it, you can write regular import as </font></font><code>import React from 'react'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and typescript will understand everything. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problem is that although it is turned on by default in new projects (at runtime </font></font><code>tsc --init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), it will not work for existing projects (even if you upgrade to TypeScript 3), because it does not have backward compatibility. Thus, you will have to rewrite unnecessary asterisk imports to the default imports. React will treat this normally, as it is still a collection of named exports, but not for example with a namespace call. But do not be afraid if everything is in order with the export typing (and for the most part, everything is in order, since many of them are </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">automatically fixed</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), TypeScript 3 will allow you to quickly convert import with asterisks to standard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, I really advocate the use of the option </font></font><code>esModuleInterop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, if only because it will not only allow you to write less code and make it easier to read (and these are not just words, for example, rollup will not allow you to use imports with asterisks like this), but also reduces disagreements between communities typescript and babel. </font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caution: there</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used to be an option </font></font><code>enableSyntheticDefaultImports</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that shut the compiler up when he tried to complain about incorrect import by default, so we needed our own way to ensure compatibility with </font></font><code>commonjs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(for example,</font></font><code>WebpackDefaultImportPlugin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), but it was problematic, because, for example, if you have tests, then you still need to ensure such compatibility. </font><font style="vertical-align: inherit;">Please note that </font></font><code>esModuleInterop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">includes synthetic import by default only if your target is </font></font><code>&lt;=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ES5. </font><font style="vertical-align: inherit;">Therefore, if you enable this option, and the compilers continue to complain about it </font></font><code>import React</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then understand what purpose you are pursuing, and perhaps the inclusion of default imports will be your option (or restart vscode / webstorm, who knows). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I hope my explanation clarified the situation a little, but if you still have questions, you can ask me them on </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br>
 <br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React patterns</font></font></a><br>
<br>
<hr></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en507080/index.html">All Cups: The Story of a Great Ecosystem Design</a></li>
<li><a href="../en507084/index.html">SpatialChat parties became popular during the pandemic - and they are unlikely to end after cove</a></li>
<li><a href="../en507086/index.html">Convert Bash script to C # code to send SMS via usb modem HUAWEI E3372</a></li>
<li><a href="../en507090/index.html">How can a tech team build their startup, or the path from functional monitoring to the AIOps platform</a></li>
<li><a href="../en507092/index.html">We invite you to the second online mitap Zabbix</a></li>
<li><a href="../en507106/index.html">How is the implementation of DNS-over-HTTPS</a></li>
<li><a href="../en507110/index.html">How to find errors in a C # project, working under Linux and macOS</a></li>
<li><a href="../en507112/index.html">PayOnline | Internet Acquiring for Business</a></li>
<li><a href="../en507114/index.html">Ode Excel: 34 Years of Magic</a></li>
<li><a href="../en507116/index.html">"Udalenka". Notes from yesterday‚Äôs office developer. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>