<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚ÄçüßëüèΩ ‚è´ ü¶ä Como a tela da mensagem VK √© renderizada? ü¶Ö üöº üë©‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O que a VK est√° fazendo para reduzir os atrasos na renderiza√ß√£o? Como exibir uma mensagem muito grande e n√£o matar o UiThread? Como reduzir os atrasos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Como a tela da mensagem VK √© renderizada?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/501988/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que a VK est√° fazendo para reduzir os atrasos na renderiza√ß√£o? </font><font style="vertical-align: inherit;">Como exibir uma mensagem muito grande e n√£o matar o UiThread? </font><font style="vertical-align: inherit;">Como reduzir os atrasos na rolagem no RecyclerView? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vs/2s/jg/vs2sjg1iyfq7cdkohrmgpuy5mla.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Minha experi√™ncia √© baseada no trabalho de desenhar uma tela de mensagem no aplicativo VK Android, na qual √© necess√°rio mostrar uma enorme quantidade de informa√ß√µes com o m√≠nimo de freios na interface do usu√°rio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Venho programando para Android h√° quase dez anos, antes era freelancer para PHP / Node.js. </font><font style="vertical-align: inherit;">Agora - um desenvolvedor s√™nior do Android VKontakte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sob o corte - v√≠deo e transcri√ß√£o do meu relat√≥rio da confer√™ncia Mobius 2019 em Moscou.</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GZkTwgetUWI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O relat√≥rio revela tr√™s t√≥picos</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solu√ß√µes padr√£o s√£o os princ√≠pios b√°sicos de como a tela de mensagens VK funciona. </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solu√ß√µes n√£o padr√£o s√£o solu√ß√µes pouco conhecidas ou originais que permitem minimizar os atrasos na interface do usu√°rio.</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As alternativas s√£o sobre v√°rias bibliotecas e implementa√ß√µes, e tamb√©m por que os desenvolvedores do VK n√£o as usaram.</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Olhe para a tela:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/he/h2/xj/heh2xjq-ij5pnzsu49cf11uuabu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta mensagem est√° em algum lugar em cinco telas. </font><font style="vertical-align: inherit;">E eles podem muito bem estar conosco (no caso de encaminhar mensagens). </font><font style="vertical-align: inherit;">Ferramentas padr√£o n√£o funcionar√£o mais. </font><font style="vertical-align: inherit;">Mesmo em um dispositivo superior, tudo pode ficar lento. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, al√©m disso, a pr√≥pria interface do usu√°rio √© bastante diversa:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datas e indicadores de carregamento,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mensagens de servi√ßo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texto (emoji, link, email, hashtags),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teclado bot</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">~ 40 maneiras de exibir anexos,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√°rvore de mensagens encaminhadas.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Surge a pergunta: como tornar o n√∫mero de defasagens o menor poss√≠vel? </font><font style="vertical-align: inherit;">Tanto no caso de mensagens simples, como no de mensagens em massa (case-edge do v√≠deo acima).</font></font><br>
<a name="ordinary"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solu√ß√µes padr√£o</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecyclerView e seus complementos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem v√°rios complementos para o RecyclerView.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setHasFixedSize ( </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muitas pessoas pensam que esse sinalizador √© necess√°rio quando os itens da lista s√£o do mesmo tamanho. </font><font style="vertical-align: inherit;">Mas, de fato, a julgar pela documenta√ß√£o, o oposto √© verdadeiro. </font><font style="vertical-align: inherit;">√â quando o tamanho do RecyclerView √© constante e independente dos elementos (aproximadamente, n√£o wrap_content). </font><font style="vertical-align: inherit;">A configura√ß√£o do sinalizador ajuda a aumentar levemente a velocidade do RecyclerView para evitar c√°lculos desnecess√°rios.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setNestedScrollingEnabled ( </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otimiza√ß√£o secund√°ria que desativa o suporte ao NestedScroll. </font><font style="vertical-align: inherit;">N√£o temos a CollapsingToolbar ou outros recursos, dependendo do NestedScroll nessa tela, para que possamos definir com seguran√ßa esse sinalizador como false.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setItemViewCacheSize ( </font></font><code>cache_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Configurando o cache interno do RecyclerView. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muitas pessoas pensam que a mec√¢nica do RecyclerView √©:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existe um ViewHolder exibido na tela;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existe um RecycledViewPool que armazena o ViewHolder;</font></font></li>
<li> ViewHolder    ‚Äî    RecycledViewPool.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na pr√°tica, tudo √© um pouco mais complicado, porque h√° um cache intermedi√°rio entre essas duas coisas. </font><font style="vertical-align: inherit;">√â chamado de ItemViewCache. </font><font style="vertical-align: inherit;">Qual √© a sua ess√™ncia? </font><font style="vertical-align: inherit;">Quando o ViewHolder sai da tela, ele n√£o √© colocado no RecycledViewPool, mas no cache intermedi√°rio (ItemViewCache). </font><font style="vertical-align: inherit;">Todas as altera√ß√µes no adaptador se aplicam ao ViewHolder vis√≠vel e ao ViewHolder dentro do ItemViewCache. </font><font style="vertical-align: inherit;">E para o ViewHolder dentro do RecycledViewPool, as altera√ß√µes n√£o s√£o aplicadas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atrav√©s do setItemViewCacheSize, podemos definir o tamanho desse cache intermedi√°rio. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quanto maior, mais r√°pido o deslocamento ocorrer√° em curtas dist√¢ncias, mas as opera√ß√µes de atualiza√ß√£o levar√£o mais tempo (devido ao ViewHolder.onBind, etc.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como o RecyclerView √© implementado e como seu cache √© estruturado √© um t√≥pico bastante amplo e complexo. </font><font style="vertical-align: inherit;">Voc√™ pode ler um √≥timo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, onde eles falam em detalhes sobre tudo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otimiza√ß√£o OnCreate / OnBind</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra solu√ß√£o cl√°ssica √© otimizar onCreateViewHolder / onBindViewHolder:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">layout f√°cil (tentamos usar o FrameLayout ou o Custom ViewGroup o m√°ximo poss√≠vel),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opera√ß√µes pesadas (links de an√°lise / emoji) s√£o realizadas de forma ass√≠ncrona no est√°gio de carregamento da mensagem,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StringBuilder para formatar nome, data, etc.,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e outras solu√ß√µes que reduzem o tempo de trabalho desses m√©todos.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acompanhamento Adapter.onFailedToRecyclerView ()</font></font></h3><br>
<img src="https://habrastorage.org/webt/8l/eo/1n/8leo1nki7gxrit4wg8mhhv0q3ua.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ tem uma lista na qual alguns elementos (ou parte deles) s√£o animados com alfa. </font><font style="vertical-align: inherit;">No momento em que o View, estando em processo de anima√ß√£o, sai da tela, ele n√£o vai para o RecycledViewPool. </font><font style="vertical-align: inherit;">Por qu√™? </font><font style="vertical-align: inherit;">O RecycledViewPool v√™ que o View agora √© animado pelo sinalizador View.hasTransientState e simplesmente o ignora. </font><font style="vertical-align: inherit;">Portanto, na pr√≥xima vez que voc√™ rolar para cima e para baixo, a foto n√£o ser√° tirada do RecycledViewPool, mas ser√° criada novamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A decis√£o mais correta √© que, quando o ViewHolder sai da tela, √© necess√°rio cancelar todas as anima√ß√µes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-7/1r/rh/-71rrhbw5idwburnf60gtfllcau.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ precisar de um hotfix o mais r√°pido poss√≠vel ou se for um desenvolvedor lento, no m√©todo onFailedToRecycle voc√™ poder√° simplesmente retornar sempre true e tudo funcionar√°, mas eu n√£o recomendaria isso.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/se/ha/iusehamefbgzcvc6miixbtfmfoy.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rastreamento de overdraw e profiler</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A maneira cl√°ssica de detectar problemas √© o excesso e o rastreamento do criador de perfil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Overdraw - o n√∫mero de redesenhos do pixel: quanto menos camadas e menos redesenhar o pixel, mais r√°pido. Mas, de acordo com minhas observa√ß√µes, nas realidades modernas, isso n√£o afeta muito o desempenho. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/0h/-d/fh/0h-dfhogberhs_hsy1eseaexkwa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Profiler - tamb√©m conhecido como Android Monitor, que est√° no Android Studio. Nele, voc√™ pode analisar todos os m√©todos chamados. Por exemplo, abra mensagens, role para cima e para baixo e veja quais m√©todos foram chamados e quanto tempo levaram. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dz/la/wy/dzlawyqmpqtzxbnpcbezvfoq_ww.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo o que est√° na metade esquerda s√£o as chamadas do sistema Android necess√°rias para criar / renderizar um View / ViewHolder. N√≥s n√£o podemos influenci√°-los ou precisaremos gastar muito esfor√ßo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A metade direita √© o nosso c√≥digo que √© executado no ViewHolder.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O bloco de chamadas no n√∫mero 1 √© uma chamada para express√µes regulares: em algum lugar eles ignoraram e esqueceram de transferir a opera√ß√£o para o encadeamento em segundo plano, diminuindo a rolagem em ~ 20%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloco de chamada no n√∫mero 2 - Fresco, uma biblioteca para exibi√ß√£o de imagens. </font><font style="vertical-align: inherit;">Em alguns lugares, n√£o √© o ideal, mas ainda n√£o est√° claro o que fazer com esse atraso, mas se conseguirmos resolv√™-lo, economizaremos outros ~ 15%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, corrigindo esses problemas, podemos obter um aumento de ~ 35%, o que √© bem legal.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diffiff</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muitos de voc√™s usam o DiffUtil em sua forma padr√£o: existem duas listas - chamadas, comparadas e empurradas. Fazer tudo isso no thread principal √© um pouco caro, porque a lista pode ser muito grande. Normalmente, o c√°lculo do DiffUtil √© executado em um encadeamento em segundo plano. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListAdapter e AsyncListDiffer fazem isso por voc√™. O ListAdapter estende o adaptador regular e inicia tudo de forma ass√≠ncrona - basta fazer um submitList e todo o c√°lculo das altera√ß√µes voa para o encadeamento interno em segundo plano. O ListAdapter pode levar em considera√ß√£o o caso de atualiza√ß√µes frequentes: se voc√™ o chamar tr√™s vezes seguidas, ele levar√° apenas o √∫ltimo resultado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No pr√≥prio DiffUtil, usamos apenas algumas mudan√ßas estruturais - a apar√™ncia da mensagem, sua altera√ß√£o e exclus√£o. </font><font style="vertical-align: inherit;">Para alguns dados de troca r√°pida, isso n√£o √© adequado. </font><font style="vertical-align: inherit;">Por exemplo, quando carregamos uma foto ou reproduzimos √°udio. </font><font style="vertical-align: inherit;">Esses eventos ocorrem com freq√º√™ncia - v√°rias vezes por segundo e, se voc√™ executar o DiffUtil a cada vez, ter√° muito trabalho extra.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anima√ß√µes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Era uma vez um quadro de anima√ß√£o - bastante escasso, mas ainda assim. </font><font style="vertical-align: inherit;">Trabalhamos com ele assim:</font></font><br>
<br>
<pre><code class="java hljs">view.startAnimation(TranslateAnimation(fromX = <span class="hljs-number">0</span>, toX = <span class="hljs-number">300</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema √© que o par√¢metro getTranslationXX () retornar√° o mesmo valor antes e depois da anima√ß√£o. </font><font style="vertical-align: inherit;">Isso ocorre porque a Anima√ß√£o alterou a representa√ß√£o visual, mas n√£o alterou as propriedades f√≠sicas. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f0/uu/tw/f0uutwhihhopkcfvps8itszyt_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No Android 3.0, a estrutura do Animator apareceu, o que √© mais correto porque alterou a propriedade f√≠sica espec√≠fica do objeto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q2/ib/qy/q2ibqywrlcla5cxqpslznxbxxm0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais tarde, o ViewPropertyAnimator apareceu e todos ainda n√£o entendem sua diferen√ßa do Animator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu vou explicar </font><font style="vertical-align: inherit;">Digamos que voc√™ precise fazer a tradu√ß√£o na diagonal - mude a Visualiza√ß√£o ao longo dos eixos x, y. </font><font style="vertical-align: inherit;">Muito provavelmente voc√™ escreveria um c√≥digo t√≠pico:</font></font><br>
<br>
<pre><code class="java hljs">val animX = ObjectAnimator.ofFloat(view, ‚ÄútranslationX‚Äù, <span class="hljs-number">100f</span>)<font></font>
val animY = ObjectAnimator.ofFloat(view, ‚ÄútranslationY‚Äù, <span class="hljs-number">200f</span>)<font></font>
AnimatorSet().apply {<font></font>
    playTogether(animX, animY)<font></font>
    start()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E voc√™ pode torn√°-lo mais curto:</font></font><br>
<br>
<pre><code class="java hljs">view.animate().translationX(<span class="hljs-number">100f</span>).translationY(<span class="hljs-number">200f</span>) </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao executar o view.animate (), voc√™ inicia implicitamente o ViewPropertyAnimator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que √© necess√°rio?</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais f√°cil de ler e manter o c√≥digo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anima√ß√£o de opera√ß√µes em lote.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No nosso √∫ltimo caso, alteramos duas propriedades. Quando fazemos isso por meio de animadores, os marcadores de anima√ß√£o ser√£o chamados separadamente para cada Animador. Ou seja, setTranslationX e setTranslationY ser√£o chamados separadamente e o View executar√° opera√ß√µes de atualiza√ß√£o separadamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No caso do ViewPropertyAnimator, a altera√ß√£o ocorre ao mesmo tempo, portanto, h√° uma economia devido a menos opera√ß√µes e a altera√ß√£o nas propriedades em si √© melhor otimizada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ pode conseguir isso com o Animator, mas precisar√° escrever mais c√≥digo. </font><font style="vertical-align: inherit;">Al√©m disso, usando o ViewPropertyAnimator, voc√™ pode ter certeza de que as anima√ß√µes ser√£o otimizadas o m√°ximo poss√≠vel. </font><font style="vertical-align: inherit;">Por qu√™? </font><font style="vertical-align: inherit;">O Android tem um RenderNode (DisplayList). </font><font style="vertical-align: inherit;">De maneira geral, eles armazenam em cache o resultado do onDraw e o usam ao redesenhar. </font><font style="vertical-align: inherit;">O ViewPropertyAnimator trabalha diretamente com o RenderNode e aplica anima√ß√µes a ele, evitando chamadas onDraw. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muitas propriedades do modo de exibi√ß√£o tamb√©m podem afetar diretamente o RenderNode, mas n√£o todos. </font><font style="vertical-align: inherit;">Ou seja, ao usar o ViewPropertyAnimator, voc√™ garante a utiliza√ß√£o da maneira mais eficiente. </font><font style="vertical-align: inherit;">Se de repente voc√™ tiver algum tipo de anima√ß√£o que n√£o pode ser feita com o ViewPropertyAnimator, talvez deva pensar e mudar.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anima√ß√µes: TransitionManager</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Geralmente, as pessoas associam que essa estrutura √© usada para passar de uma atividade para outra. De fato, ele pode ser usado de maneira diferente e simplificar bastante a implementa√ß√£o da anima√ß√£o de mudan√ßas estruturais. Suponha que tenhamos uma tela na qual uma mensagem de voz √© reproduzida. N√≥s a fechamos com uma cruz e o dado sobe. Como fazer isso? A anima√ß√£o √© bastante complicada: o jogador fecha com alfa, enquanto n√£o se move pela tradu√ß√£o, mas muda de altura. Ao mesmo tempo, nossa lista sobe e tamb√©m altera a altura. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mv/ff/kh/mvffkhe5udzkypeumimmusvhiig.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se o jogador fizesse parte da lista, a anima√ß√£o seria bem simples. Mas conosco o jogador n√£o √© um elemento da lista, mas uma Vis√£o completamente independente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Talvez come√ß√°ssemos a escrever algum tipo de Animador, depois encontrar√≠amos problemas, falhas, come√ßar√≠amos a serrar muletas e duplicar o c√≥digo. </font><font style="vertical-align: inherit;">E obteria algo como a tela abaixo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/0d/k-/wd0dk-urz2lfr6xugvvpmp16rdk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com o TransitionManager, voc√™ pode simplificar tudo:</font></font><br>
<br>
<pre><code class="java hljs">TransitionManager.beginDelayedTransition(<font></font>
        viewGroup = &lt;LinearLayoutManager&gt;,<font></font>
        transition = AutoTransition())<font></font>
playerView.visibility = View.GONE</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toda anima√ß√£o acontece automaticamente sob o cap√¥. </font><font style="vertical-align: inherit;">Parece m√°gica, mas se voc√™ se aprofundar e ver como funciona, o TransitionManager simplesmente assina todo o View, captura as altera√ß√µes em suas propriedades, calcula o diff, cria os animadores necess√°rios ou o ViewPropertyAnimator, quando necess√°rio, e faz tudo da maneira mais eficiente poss√≠vel. </font><font style="vertical-align: inherit;">O TransitionManager nos permite fazer anima√ß√µes na se√ß√£o de mensagens de forma r√°pida e f√°cil de implementar.</font></font><a name="extrodinary"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solu√ß√µes personalizadas</font></font></h2><br>
<img src="https://habrastorage.org/webt/u2/rx/ji/u2rxjicmid-zkuhvqsxc4kxbeem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa √© a coisa mais fundamental na qual o desempenho e os problemas a seguir se baseiam. O que fazer quando sua mensagem est√° em 10 telas? Se voc√™ prestar aten√ß√£o, todos os nossos elementos est√£o localizados exatamente um debaixo do outro. Se aceitarmos que o ViewHolder n√£o √© uma mensagem, mas dezenas de ViewHolders diferentes, tudo se torna muito mais simples. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o √© um problema para n√≥s que a mensagem tenha se tornado 10 telas, porque agora exibimos apenas seis ViewHolders em um exemplo concreto. Temos um layout f√°cil, o c√≥digo √© mais f√°cil de manter e n√£o h√° problemas especiais, exceto um - como fazer isso?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/gh/ui/hoghuifbuntyzu3uszyjr6vij_0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem ViewHolders simples - s√£o separadores de data cl√°ssicos, Carregar mais e assim por diante. </font><font style="vertical-align: inherit;">E BaseViewHolder - ViewHolder condicionalmente b√°sico para a mensagem. </font><font style="vertical-align: inherit;">Ele tem uma implementa√ß√£o b√°sica e v√°rias espec√≠ficas - TextViewHolder, PhotoViewHolder, AudioViewHolder, ReplyViewHolder e assim por diante. </font><font style="vertical-align: inherit;">Existem cerca de 70 deles.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que √© o BaseViewHolder respons√°vel?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O BaseViewHolder √© o √∫nico respons√°vel por desenhar o avatar e a parte desejada do bal√£o, bem como a linha de mensagens encaminhadas - azul √† esquerda. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/yh/ia/6oyhiaag8f94wm6s69vskpv6r4u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A implementa√ß√£o concreta do conte√∫do j√° √© realizada por outros herdeiros BaseViewHolder: TextViewHolder exibe apenas texto, FwdSenderViewHolder - o autor da mensagem encaminhada, AudioMsgViewHolder - a mensagem de voz e assim por diante. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/th/wi/sdthwihnbm9jm4xehrbh4mmrv20.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° um problema: o que fazer com a largura? Imagine uma mensagem em pelo menos duas telas. N√£o est√° muito claro qual largura definir, porque metade √© vis√≠vel, metade n√£o √© vis√≠vel (e ainda nem foi criada). Absolutamente tudo n√£o pode ser medido, porque estabelece. Eu tenho que pegar um pouco, infelizmente. Existem casos simples em que a mensagem √© muito simples: puramente texto ou voz - em geral, consiste em um item.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_q/i0/ov/_qi0ovd7qibtvqzcya0tzv_o4vq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, use o wrap_content cl√°ssico. </font><font style="vertical-align: inherit;">Para um caso complexo, quando uma mensagem consiste em v√°rias partes, pegamos e for√ßamos cada ViewHolder uma largura fixa. </font><font style="vertical-align: inherit;">Especificamente aqui - 220 dp. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fa/5t/yifa5tx6chfyxf2c26zeak-kaeu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se o texto for muito curto e a mensagem for encaminhada, haver√° um espa√ßo vazio √† direita. </font><font style="vertical-align: inherit;">N√£o h√° como escapar disso, porque o desempenho √© mais importante. </font><font style="vertical-align: inherit;">Por v√°rios anos, n√£o houve queixas - talvez algu√©m tenha notado, mas, em geral, todos se acostumaram. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/mz/0l/qbmz0lzz-o_lvhongodanb3fh1m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem casos extremos. </font><font style="vertical-align: inherit;">Se respondermos a uma mensagem com um adesivo, podemos especificar a largura especificamente para esse caso, para que fique mais bonito. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dividimos em ViewHolders no est√°gio de carregamento de mensagens: iniciamos o carregamento em segundo plano da mensagem, convertemos em item, eles s√£o exibidos diretamente no ViewHolders.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/12/w_/x7/12w_x7wp4a4a4s5f_dqeqrevlbc.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Global RecycledViewPool</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A mec√¢nica de usar nosso messenger √© tal que as pessoas n√£o se sentam no mesmo bate-papo, mas andam constantemente entre eles. </font><font style="vertical-align: inherit;">Na abordagem padr√£o, quando entramos no chat e o deixamos, o RecycledViewPool (e o ViewHolder nele) s√£o simplesmente destru√≠dos e toda vez que gastamos recursos criando o ViewHolder. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso pode ser resolvido pelo RecycledViewPool global:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro da estrutura do aplicativo, RecycledViewPool vive como um singleton;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reutilizado na tela de mensagens quando o usu√°rio caminha entre as telas;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definido como RecyclerView.setRecycledViewPool (pool).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem armadilhas, √© importante lembrar duas coisas:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voc√™ vai para a tela, clique em voltar, saia. </font><font style="vertical-align: inherit;">O problema √© que os ViewHolders que estavam na tela s√£o jogados fora e n√£o retornam ao pool. </font><font style="vertical-align: inherit;">Isso √© corrigido da seguinte maneira:</font></font><br>
<pre><code class="java hljs">LinearLayoutManager.recycleChildrenOnDetach = <span class="hljs-keyword">true</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O RecycledViewPool tem limita√ß√µes: n√£o mais que cinco ViewHolders podem ser armazenados para cada ViewType.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se 9 TextViews forem exibidos na tela, apenas cinco itens ser√£o retornados ao RecycledViewPool e o restante ser√° jogado fora. </font><font style="vertical-align: inherit;">Voc√™ pode alterar o tamanho do RecycledViewPool: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RecycledViewPool.setMaxRecycledViews (viewType, tamanho) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas, de alguma forma, √© triste prescrever para cada ViewType com as m√£os, porque voc√™ pode escrever seu RecycledViewPool, expandindo o padr√£o e torn√°-lo NoLimit. </font><font style="vertical-align: inherit;">Pelo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> voc√™ pode baixar a implementa√ß√£o conclu√≠da.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DiffUtil nem sempre √© √∫til</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° um caso cl√°ssico - fa√ßa o download, reproduzindo uma faixa de √°udio e uma mensagem de voz. </font><font style="vertical-align: inherit;">Nesse caso, o DiffUtil chama spam. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/3o/lt/ho3oltgo6763hgc65xxel-ccopa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosso BaseViewHolder possui um m√©todo updateUploadProgress abstrato.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseViewHolder</span> : <span class="hljs-title">ViewHolder</span> </span>{<font></font>
    ‚Ä¶<font></font>
    <span class="hljs-function">fun <span class="hljs-title">updateUploadProgress</span><span class="hljs-params">(attachId: Int, progress: Float)</span>
    ‚Ä¶        
}
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para lan√ßar um evento, precisamos ignorar todos os ViewHolder vis√≠veis:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">fun <span class="hljs-title">onUploadProgress</span><span class="hljs-params">(attachId: Int, progress: Float)</span> </span>{<font></font>
    forEachActiveViewHolder {<font></font>
        it.updateUploadProgress(attachId, progress)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta √© uma opera√ß√£o simples, √© improv√°vel que tenhamos mais de dez ViewHolder na tela. </font><font style="vertical-align: inherit;">Tal abordagem n√£o pode ficar em princ√≠pio. </font><font style="vertical-align: inherit;">Como encontrar o ViewHolder vis√≠vel? </font><font style="vertical-align: inherit;">Uma implementa√ß√£o ing√™nua seria algo como isto:</font></font><br>
<br>
<pre><code class="java hljs">val firstVisiblePosition = &lt;...&gt;<font></font>
val lastVisiblePosition = &lt;...&gt;<font></font>
<span class="hljs-keyword">for</span> (i in firstVisiblePosition.. lastVisiblePosition) {<font></font>
    val viewHolder = recycler.View.findViewHolderForAdapterPosition(i)<font></font>
    viewHolder.updateUploadProgress(..)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas h√° um problema. </font><font style="vertical-align: inherit;">O cache intermedi√°rio que mencionei anteriormente, ItemViewCache, cont√©m ViewHolders ativos que simplesmente n√£o aparecem na tela. </font><font style="vertical-align: inherit;">O c√≥digo acima n√£o os afetar√°. </font><font style="vertical-align: inherit;">Diretamente, n√≥s tamb√©m n√£o podemos abord√°-los. </font><font style="vertical-align: inherit;">E ent√£o muletas v√™m em nosso aux√≠lio. </font><font style="vertical-align: inherit;">Crie um WeakSet que armazena links para o ViewHolder. </font><font style="vertical-align: inherit;">Al√©m disso, √© suficiente simplesmente ignorarmos esse WeakSet.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> : <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span> </span>{<font></font>
    val activeViewHolders = WeakSet&lt;ViewHolder&gt;()<font></font>
        <font></font>
    <span class="hljs-function">fun <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: ViewHolder, position: Int)</span> </span>{<font></font>
        activeViewHolders.add(holder)<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">fun <span class="hljs-title">onViewRecycled</span><span class="hljs-params">(holder: ViewHolder)</span> </span>{<font></font>
        activeViewHolders.remove(holder)<font></font>
    }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobreposi√ß√£o do ViewHolder</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere o exemplo de hist√≥rias. Anteriormente, se uma pessoa reagia a uma hist√≥ria com um adesivo, a exib√≠amos da seguinte maneira: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rc/kd/z1/rckdz16ebmfwftxzfpql2lwmsko.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
parece muito feio. Eu queria fazer melhor, porque as hist√≥rias s√£o um conte√∫do brilhante e temos uma pequena pra√ßa l√°. Mas quer√≠amos obter algo assim: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vj/ma/51/vjma51z9m4eqwlhiagc7xvu2kg0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° um problema: nossa mensagem √© dividida no ViewHolder, eles est√£o localizados estritamente um no outro, mas aqui eles se sobrep√µem. Imediatamente n√£o est√° claro como resolver isso. Voc√™ pode criar outro ViewType "hist√≥rico + adesivo" ou "hist√≥rico + mensagem de voz". Ent√£o, em vez de 70 ViewType, ter√≠amos 140 ... N√£o, precisamos criar algo mais conveniente.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/01/mr/5j/01mr5jqsfdpq_zcq4s3b-vf9pyq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma de suas muletas favoritas no Android vem √† mente. </font><font style="vertical-align: inherit;">Por exemplo, est√°vamos fazendo algo, mas o Pixel Perfect n√£o converge. </font><font style="vertical-align: inherit;">Para corrigir isso, voc√™ precisa excluir tudo e escrever do zero, mas com pregui√ßa. </font><font style="vertical-align: inherit;">Como resultado, podemos criar margem = -2dp (negativo), e agora tudo se encaixa. </font><font style="vertical-align: inherit;">Mas apenas essa abordagem n√£o pode ser usada aqui. </font><font style="vertical-align: inherit;">Se voc√™ definir uma margem negativa, o adesivo se mover√°, mas o local ocupado permanecer√° vazio. </font><font style="vertical-align: inherit;">Mas temos ItemDecoration, onde itemOffset podemos criar um n√∫mero negativo. </font><font style="vertical-align: inherit;">E funciona! </font><font style="vertical-align: inherit;">Como resultado, obtemos a sobreposi√ß√£o esperada e, ao mesmo tempo, permanece um paradigma em que cada ViewHolder √© amigo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma solu√ß√£o bonita em uma linha.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OffsetItemDecoration</span> : <span class="hljs-title">RecyclerViewItemDecoration</span>() </span>{
    <span class="hljs-function">overrride fun <span class="hljs-title">getItemOffsets</span><span class="hljs-params">(offset: Rect, ‚Ä¶)</span> </span>{<font></font>
        offset.top = -<span class="hljs-number">100</span>dp<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idlehandler</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este √© um caso com um asterisco, √© complexo e nem sempre √© necess√°rio na pr√°tica, mas √© importante saber sobre a exist√™ncia desse m√©todo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, mostrarei como o principal thread do UiThread funciona. O esquema geral: h√° uma fila de eventos de tarefas na qual as tarefas s√£o definidas por meio de handler.post e um loop infinito que passa por essa fila. Ou seja, o UiThread √© apenas enquanto (verdadeiro). Se houver tarefas, n√≥s as executamos; caso contr√°rio, esperamos at√© que elas apare√ßam.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y3/ee/nn/y3eennjezxs29i4lkbvggnqkgjw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em nossas realidades usuais, Handler √© respons√°vel por colocar tarefas na fila, e Looper ignora indefinidamente a fila. </font><font style="vertical-align: inherit;">Existem tarefas que n√£o s√£o muito importantes para a interface do usu√°rio. </font><font style="vertical-align: inherit;">Por exemplo, um usu√°rio l√™ uma mensagem - n√£o √© t√£o importante para n√≥s quando a exibimos na interface do usu√°rio, agora ou ap√≥s 20 ms. </font><font style="vertical-align: inherit;">O usu√°rio n√£o notar√° a diferen√ßa. </font><font style="vertical-align: inherit;">Ent√£o, talvez valha a pena executar esta tarefa no thread principal apenas quando estiver livre? </font><font style="vertical-align: inherit;">Ou seja, seria bom sabermos quando a linha waititNewTask √© chamada. </font><font style="vertical-align: inherit;">Nesse caso, o Looper possui um addIdleHandler que √© acionado quando o c√≥digo task.isEmpty √© acionado. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looper.myQueue (). AddIdleHandler ()</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
E a implementa√ß√£o mais simples do IdleHandler ter√° a seguinte apar√™ncia:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@AnyThread</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdleHandler</span> </span>{
    <span class="hljs-keyword">private</span> val handler = Handler(Looper.getMainLooper())<font></font>
<font></font>
    <span class="hljs-function">fun <span class="hljs-title">post</span><span class="hljs-params">(task: Runnable)</span> </span>{<font></font>
        handler.post {<font></font>
            Looper.myQueue().addIdleHandler {<font></font>
                task.run()<font></font>
                <span class="hljs-keyword">return</span><span class="hljs-meta">@addIdleHandler</span> <span class="hljs-keyword">false</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da mesma forma, voc√™ pode medir um in√≠cio a frio honesto do aplicativo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emoji</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usamos nosso emoji personalizado em vez dos do sistema. Aqui est√° um exemplo de como os emojis pareciam em plataformas diferentes em anos diferentes. Os emoji esquerdo e direito s√£o muito bons, mas no meio ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bv/71/m3/bv71m3d7rginefvtev6ogcgwess.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° um segundo problema: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dw/-1/nx/dw-1nxxjfpggaxcjo_-idb0ofce.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cada linha √© o mesmo emoji, mas as emo√ß√µes que eles reproduzem s√£o diferentes. Eu gosto mais do canto inferior direito, ainda n√£o entendo o que isso significa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° uma bicicleta da VKontakte. Em ~ 2014, alteramos ligeiramente um emoji. Talvez algu√©m se lembre - "Marshmallow" foi. Ap√≥s sua mudan√ßa, um mini-motim come√ßou. Obviamente, ele n√£o alcan√ßou o n√≠vel de "retorno ao muro", mas a rea√ß√£o foi bastante interessante. E isso nos diz sobre a import√¢ncia da interpreta√ß√£o de emoji.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como os emojis s√£o feitos: temos um grande mapa de bits, onde todos s√£o reunidos em um grande "atlas". </font><font style="vertical-align: inherit;">Existem v√°rios deles - sob diferentes DPI. </font><font style="vertical-align: inherit;">E h√° um EmojiSpan que cont√©m informa√ß√µes: eu desenho emoji "tal e tal", ele est√° em tal e tal bitmap em tal e tal local (x, y). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E existe um ReplacementSpan que permite exibir algo em vez de texto em Span. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, voc√™ encontra emoji no texto, envolve-o com o EmojiSpan e o sistema desenha o emoji desejado em vez do emoji do sistema.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/y5/tq/agy5tq5wl0ys8vbwuqgwhpfeoli.png"><a name="alt"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternativas</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inflar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algu√©m pode dizer que, como o inflar √© lento, por que n√£o criar um layout com as m√£os, evitando o inflamento. </font><font style="vertical-align: inherit;">E, assim, acelere tudo, evitando o 100500 ViewHolder. </font><font style="vertical-align: inherit;">√â uma ilus√£o. </font><font style="vertical-align: inherit;">Antes de fazer algo, vale a pena medi-lo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Android tem uma classe Debug, tem startMethodTracing e stopMethodTracing.</font></font><br>
<br>
<pre><code class="java hljs">Debug.startMethodTracing(‚Äútrace¬ª)<font></font>
inflate(...)<font></font>
Debug.stopMethodTracing()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso nos permitir√° coletar informa√ß√µes sobre o tempo de execu√ß√£o de um peda√ßo de c√≥digo espec√≠fico. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ea/hz/wa/eahzwatykq-cflwr2ul3qnwbvq4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E vemos que aqui inflar como tal √© at√© invis√≠vel. </font><font style="vertical-align: inherit;">Um quarto do tempo foi gasto carregando drawable, um quarto estava carregando cores. </font><font style="vertical-align: inherit;">E apenas em algum lugar na parte etc √© o nosso inflar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentei traduzir o layout XML em c√≥digo e salvei em torno de 0,5 ms. </font><font style="vertical-align: inherit;">O aumento, de fato, n√£o √© o mais impressionante. </font><font style="vertical-align: inherit;">E o c√≥digo se tornou muito mais complicado. </font><font style="vertical-align: inherit;">Ou seja, reescrever n√£o faz muito sentido.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, na pr√°tica, muitos n√£o encontrar√£o esse problema, porque um inflamento longo geralmente ocorre apenas quando o aplicativo se torna muito grande. </font><font style="vertical-align: inherit;">Em nosso aplicativo VKontakte, por exemplo, existem aproximadamente 200 a 300 telas diferentes e o carregamento de todos os recursos trava. </font><font style="vertical-align: inherit;">O que fazer com isso ainda n√£o est√° claro. </font><font style="vertical-align: inherit;">Provavelmente, voc√™ precisar√° escrever seu pr√≥prio gerenciador de recursos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anko</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anko tornou-se obsoleto recentemente. </font><font style="vertical-align: inherit;">Enfim, Anko n√£o √© m√°gico, mas simples a√ß√∫car sint√°tico. </font><font style="vertical-align: inherit;">Ele traduz tudo para a nova View () condicional da mesma maneira. </font><font style="vertical-align: inherit;">Portanto, n√£o h√° benef√≠cio da Anko.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Litho / Flutter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que eu combinei duas coisas completamente n√£o relacionadas? </font><font style="vertical-align: inherit;">Porque n√£o se trata de tecnologia, mas da complexidade da migra√ß√£o para ela. </font><font style="vertical-align: inherit;">Voc√™ n√£o pode simplesmente pedir emprestado e mudar para uma nova biblioteca. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o est√° claro se isso nos dar√° um aumento de desempenho. </font><font style="vertical-align: inherit;">E n√£o teremos novos problemas, porque milh√µes de pessoas com dispositivos completamente diferentes usam nosso aplicativo a cada minuto (voc√™ provavelmente nem ouviu falar de um quarto deles). </font><font style="vertical-align: inherit;">Al√©m disso, as mensagens s√£o uma base de c√≥digo muito grande. </font><font style="vertical-align: inherit;">√â imposs√≠vel reescrever tudo instantaneamente. </font><font style="vertical-align: inherit;">E faz√™-lo por causa do hype da tecnologia √© est√∫pido. </font><font style="vertical-align: inherit;">Especialmente quando o Jetpack Compose aparece em algum lugar distante.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetpack compor</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Google nos promete um man√° do c√©u na forma desta biblioteca, mas ainda est√° em alfa. </font><font style="vertical-align: inherit;">E quando ser√° no lan√ßamento - n√£o est√° claro. </font><font style="vertical-align: inherit;">Tamb√©m n√£o √© claro se podemos obt√™-lo em sua forma atual. </font><font style="vertical-align: inherit;">√â muito cedo para experimentar. </font><font style="vertical-align: inherit;">Deixe sair est√°vel, deixe os principais erros fecharem. </font><font style="vertical-align: inherit;">E s√≥ ent√£o vamos olhar na dire√ß√£o dele.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma visualiza√ß√£o personalizada grande</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° outra abordagem sobre a qual aqueles que usam v√°rios mensageiros instant√¢neos falam: "pegue e escreva uma grande Visualiza√ß√£o Personalizada, sem hierarquia complicada". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quais s√£o as desvantagens?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â dif√≠cil de manter.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o faz sentido nas realidades atuais.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com o Android 4.3, o sistema de cache interno do View foi bombeado. </font><font style="vertical-align: inherit;">Por exemplo, onMeasure n√£o ser√° chamado se a Visualiza√ß√£o n√£o tiver sido alterada. </font><font style="vertical-align: inherit;">E os resultados da medi√ß√£o anterior s√£o usados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com o Android 4.3-4.4, um RenderNode (DisplayList) apareceu, fazendo o cache da renderiza√ß√£o. </font><font style="vertical-align: inherit;">Vejamos um exemplo. </font><font style="vertical-align: inherit;">Suponha que haja uma c√©lula na lista de di√°logos: avatar, t√≠tulo, legenda, status de leitura, hora, outro avatar. </font><font style="vertical-align: inherit;">Condicionalmente - 10 elementos. </font><font style="vertical-align: inherit;">E escrevemos o modo de exibi√ß√£o personalizado. </font><font style="vertical-align: inherit;">Nesse caso, ao alterar uma propriedade, mediremos novamente todos os elementos. </font><font style="vertical-align: inherit;">Ou seja, basta gastar os recursos extras. </font><font style="vertical-align: inherit;">No caso do ViewGroup, em que cada elemento √© uma View separada, quando voc√™ altera uma View, invalidaremos apenas uma View (exceto quando essa View afeta o tamanho de outras).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sum√°rio</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, voc√™ aprendeu que usamos o RecyclerView cl√°ssico com otimiza√ß√µes padr√£o. H√° uma parte n√£o padronizada, onde o mais importante e fundamental √© dividir a mensagem no ViewHolder. Obviamente, voc√™ pode dizer que isso √© aplic√°vel de maneira restrita, mas essa abordagem tamb√©m pode ser projetada em outras coisas, por exemplo, em um texto grande de 10 mil caracteres. Ele pode ser dividido em par√°grafos, onde cada par√°grafo √© um ViewHolder separado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tamb√©m vale a pena maximizar tudo no @WorkerThread: analisar links, DiffUtils - descarregando assim o @UiThead o m√°ximo poss√≠vel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O RecycledViewPool global permite percorrer as telas de mensagens e n√£o criar um ViewHolder a cada vez. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas h√° outras coisas importantes que ainda n√£o decidimos, por exemplo, um aumento excessivo, ou melhor, o carregamento de dados de recursos.</font></font><br>
<br>
<blockquote>    ,   Mobius 2019 Piter  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>,     .     ,     ,  SQLite,     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mobius 2020 Piter</a>     .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt501978/index.html">Como o histograma do Prometheus funciona?</a></li>
<li><a href="../pt501980/index.html">A hist√≥ria de um projeto ou como eu criei 7 anos de PBX baseado em Asterisk e Php</a></li>
<li><a href="../pt501982/index.html">Como transferir um shader de um mecanismo de jogo para o Substance Painter</a></li>
<li><a href="../pt501984/index.html">O que ver em quarentena? Uma sele√ß√£o de materiais da Technostream (parte 4)</a></li>
<li><a href="../pt501986/index.html">Segredos do incr√≠vel sucesso do Apple AirPods</a></li>
<li><a href="../pt501990/index.html">Postagem √∫til: 4 eventos para resolver os problemas do segundo dia no OpenShift e criar operadores</a></li>
<li><a href="../pt501992/index.html">Como organizar os testes para acelerar e estabilizar os lan√ßamentos de produtos. Parte 1</a></li>
<li><a href="../pt501994/index.html">Orchestrator for MySQL: por que um projeto √† prova de falhas n√£o pode ser constru√≠do sem ele</a></li>
<li><a href="../pt501996/index.html">Zen Go (vers√£o de bolso)</a></li>
<li><a href="../pt501998/index.html">Pre√ßo caro de estilos. Relat√≥rio Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>