<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👕 ↕️ 🕺🏿 Optimización de la representación para dispositivos móviles, parte 2. Las principales familias de GPU móviles modernas 📻 🔚 🚴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¡Saludos, queridos amantes y profesionales, programadores gráficos! Comencemos la segunda parte de nuestra serie de artículos sobre la optimización de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Optimización de la representación para dispositivos móviles, parte 2. Las principales familias de GPU móviles modernas</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/498564/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Saludos, queridos amantes y profesionales, programadores gráficos! </font><font style="vertical-align: inherit;">Comencemos la segunda parte de nuestra serie de artículos sobre la optimización de renderizado para dispositivos móviles. </font><font style="vertical-align: inherit;">En esta parte, consideraremos las principales familias de GPU presentadas por los jugadores en dispositivos móviles.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36d/cf7/711/36dcf7711d7ce68544c97bb8dc69ee32.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comenzar, considere una serie de criterios por los cuales se pueden clasificar las GPU móviles. </font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Núcleos sombreados unificados o especializados</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la era de las primeras tarjetas de video móviles, antes de la propagación de efectos complejos, había un punto de vista de que para los sombreadores de fragmentos, el soporte para cálculos con precisión reducida es suficiente. De hecho, en un modo de visualización típico, se utilizan 8 o incluso menos bits para cada canal de color. Esta vista ha llevado al uso de núcleos de sombreador especializados. Para los vértices, utilizamos núcleos optimizados para transformaciones matriciales con mayor precisión FP24 / FP32 ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Para píxeles, núcleos que funcionan de manera más eficiente con una precisión reducida FP16 ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mediump</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Con este </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No fueron apoyados. </font><font style="vertical-align: inherit;">A primera vista, esta especialización nos permite lograr una distribución más racional de los transistores en el chip. </font><font style="vertical-align: inherit;">Sin embargo, en la práctica, esto conduce a dificultades en el desarrollo de efectos complejos, así como al usar texturas de alta resolución. </font><font style="vertical-align: inherit;">Además, la especialización central puede conducir a un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuello de botella de vértices / fragmentos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este término se refiere a la situación en la que, debido a la carga asimétrica en los núcleos de vértices y píxeles, algunos de los núcleos estaban "inactivos".&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/307/144/547/30714454751e34703835ce904cf5f40a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, las arquitecturas modernas usan núcleos unificados. </font><font style="vertical-align: inherit;">Dichos núcleos pueden asumir vértices, píxeles y otras tareas computacionales dependiendo de la carga.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/d7c/363/ffed7c363ebecf0d390a0271c1a8b014.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vector (SIMD) o conjunto de instrucciones escalares</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el espíritu del deseo de ahorrar en los transistores descritos anteriormente, especializados en núcleos, se realizó el diseño de un conjunto de instrucciones de sombreado. Las transformaciones más típicas para gráficos tridimensionales operan con vectores de 4 componentes. Por lo tanto, las primeras GPU trabajaron específicamente con tales operandos. Si el código de sombreador contenía operaciones escalares heterogéneas que el optimizador no podía empaquetar en operaciones vectoriales, no se utilizó parte de la potencia informática. Este fenómeno puede ilustrarse de la siguiente manera:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b7/3dd/34a/6b73dd34a79eb4376ed816a37de4a4ae.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un sombreador que implementa la operación común Multiply Add: multiplica 2 operandos y luego agrega el tercero. Al compilar en una arquitectura vectorial condicional (Vector ISA = Arquitectura de conjunto de instrucciones vectoriales) obtenemos una instrucción vectorial </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vMADD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que se ejecuta durante 1 reloj. En la arquitectura escalar condicional, obtenemos 4 instrucciones escalares que, gracias a una tubería mejorada, también se ejecutan en 1 ciclo de reloj. Ahora considere un sombreador sofisticado que realiza 2 operaciones, pero en operandos de 2 componentes.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/333/539/b2f/333539b2fb573f8f93ff518ca25f6e5c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el caso de la arquitectura vectorial, ya obtenemos 2 instrucciones que requieren 2 ciclos de reloj para ejecutarse. Sin embargo, no </font><font style="vertical-align: inherit;">se realiza </font><font style="vertical-align: inherit;">ninguna </font><font style="vertical-align: inherit;">acción </font><font style="vertical-align: inherit;">en los componentes </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.zw</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y la potencia de procesamiento está inactiva. En el caso de la arquitectura escalar, estas mismas operaciones se pueden empaquetar en 4 </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sMADD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escalares </font><font style="vertical-align: inherit;">que se ejecutan en el mismo ciclo de 1 reloj. Por lo tanto, en la arquitectura escalar debido a la mejora de la tubería, se logra una mayor densidad de cálculos. Sin embargo, como se mostrará a continuación, el vector </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sigue siendo relevante. Por lo tanto, tiene sentido aplicar técnicas de vectorización para el código de sombreador. Le permiten lograr un mayor rendimiento en tarjetas de video con vector </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Al mismo tiempo, como regla, esto no daña el rendimiento en escalares más modernos.</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El ISA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Según las características anteriores, consideraremos las familias de GPU móviles que son comunes en nuestro tiempo. </font><font style="vertical-align: inherit;">Comencemos con la familia más común. </font><font style="vertical-align: inherit;">Mucha gente sabe que estamos hablando de tarjetas gráficas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la compañía británica </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">ARM no participa directamente en la producción de chips, sino que ofrece propiedad intelectual. </font><font style="vertical-align: inherit;">Al igual que otras tarjetas de video móviles, Mali es parte de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System on Chip (SoC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , es decir </font><font style="vertical-align: inherit;">funciona con </font><font style="vertical-align: inherit;">memoria </font><font style="vertical-align: inherit;">compartida para la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y el bus.&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali utgard</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En 2008, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nacieron</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> los primeros representantes de la arquitectura </font><strong><font style="vertical-align: inherit;">Mali Utgard</font></strong><font style="vertical-align: inherit;"> , relevantes hasta nuestros días. </font><font style="vertical-align: inherit;">Estas tarjetas de video se nombran de acuerdo con el esquema Mali-4 </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MP </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donde </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el número de modelo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yn</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el número de núcleos de fragmentos. </font><font style="vertical-align: inherit;">En </font><font style="vertical-align: inherit;">la especialidad del núcleo del sombreador </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malt Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y todos los modelos vienen con un vértice de solo 1 núcleo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otras características de la arquitectura Mali Utgard:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 2.0&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falta de soporte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en núcleos fragmentados</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conjunto de instrucciones vectoriales (tiene sentido vectorizar cálculos)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pesar de la especificación </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , los </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">controladores de la</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tarjeta de video </font><strong><font style="vertical-align: inherit;">Mali Utgard</font></strong><font style="vertical-align: inherit;"> compilan con éxito los sombreadores de fragmentos que usan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> precisión de </font><strong><font style="vertical-align: inherit;">alta</font></strong><font style="vertical-align: inherit;"> precisión </font><font style="vertical-align: inherit;">(por ejemplo, la precisión se establece de manera predeterminada utilizando la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flotación de precisión alta</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Pero la precisión de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mediump se</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usa realmente </font><font style="vertical-align: inherit;">. Por lo tanto, es aconsejable probar adicionalmente todos los sombreadores para juegos móviles en dichas tarjetas de video. Según los datos recopilados por </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a fines de 2019, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trabajó en dispositivos para aproximadamente el 10% de los jugadores. Y si configura los filtros apropiados en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">market.yandex.ru</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puede ver que en 2019 se anunciaron más de 10 teléfonos nuevos con tarjetas de video de esta arquitectura.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/5a9/8ae/7795a98ae2da31ecf49131939087c21e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si está listo para abandonar esta audiencia, es suficiente establecer el requisito de compatibilidad con OpenGL ES 3.0 en AndroidManifest.xml: </font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">uses-feature</span> <span class="hljs-attr">android:glEsVersion</span>=<span class="hljs-string">"0x00030000"</span> <span class="hljs-attr">android:required</span>=<span class="hljs-string">"true"</span>⁄&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , actualmente no hay GPU móviles generalizadas sin soporte para OpenGL ES 3.0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De particular interés es el uso de texturas de alta resolución en el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Diez partes de la mantisa con </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> precisión </font><strong><font style="vertical-align: inherit;">media</font></strong><font style="vertical-align: inherit;"> no </font><strong><font style="vertical-align: inherit;">son</font></strong><font style="vertical-align: inherit;"> suficientes para texturizar de alta calidad con una resolución de textura de más de 1024 en un lado. </font><font style="vertical-align: inherit;">Sin embargo, a pesar de admitir solo la </font><font style="vertical-align: inherit;">precisión de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mediump</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en los núcleos de fragmentos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puede obtener </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> precisión de coordenadas de textura </font><strong><font style="vertical-align: inherit;">fp24</font></strong><font style="vertical-align: inherit;"> cuando se usa la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variación</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> directa.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// vertex shader</span><font></font>
varying highp vec2 v_texc;<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
    v_texc = …;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//  fragment shader</span><font></font>
...<font></font>
varying highp vec2 v_texc;<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
    gl_FragColor = texture2D(u_sampler, v_texc); <span class="hljs-comment">//  v_texc </span>
                                                 <span class="hljs-comment">//  </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como beneficio adicional en algunas arquitecturas, este enfoque le permite </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">captar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> previamente el contenido de textura antes de ejecutar un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sombreador de fragmentos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lo que minimiza los </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloqueos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mientras espera resultados de muestreo de textura.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Midgard</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard ha sido</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reemplazado por la arquitectura </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Midgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hay varias generaciones de esta arquitectura con los nombres de las especies </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-6xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-7xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-8xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A pesar de la edad de 8 años, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Midgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede llamarse arquitectura moderna que brinda soporte para la mayoría de las nuevas características:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">núcleos de sombreadores unificados</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 3.2 (sombreadores de computación y geometría, teselación ...)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, el Mali Midgard retiene el vector </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dado el uso generalizado de Mali Midgard (aproximadamente el 25% de nuestra audiencia), la vectorización de la informática se vuelve apropiada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra característica de Mali Midgard es la tecnología </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forward Pixel Kill</font></font></strong></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cada píxel se calcula en una secuencia separada del núcleo del fragmento. </font><font style="vertical-align: inherit;">Si durante la ejecución de la secuencia se sabe que el píxel resultante será bloqueado por un píxel opaco de otra primitiva, la secuencia termina prematuramente y los recursos liberados se utilizan para otros cálculos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali bifrost</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Junto a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Midgard, la</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arquitectura </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bifrost destaca</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por su transición al </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escalar </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En comparación con la arquitectura anterior, se ha aumentado el número máximo de núcleos (de 16 a 32), y se admite una interfaz mejorada con una CPU, que permite un acceso coherente a la memoria compartida: los cambios en el contenido de la memoria de la CPU / GPU se vuelven "visibles" entre sí a pesar de los cachés, que le permite simplificar la sincronización.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De extraoficial</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se han hecho muchos intentos para aplicar ingeniería inversa a las tarjetas de video de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para crear </font><font style="vertical-align: inherit;">controladores de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">código</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abierto para </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Los trabajos de las personas dedicadas que intentan hacer esto nos permiten echar un vistazo a las características indocumentadas de las tarjetas de video </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por lo tanto, en el proyecto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PanFrost hay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un desensamblador para </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Midgard / Bifrost</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , con el que puede familiarizarse con un conjunto de instrucciones de sombreado (no hay información oficial abierta sobre este tema).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/f31/751/bbdf3175137a886431a23de54239900e.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La segunda familia más común de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> móviles </font><font style="vertical-align: inherit;">es </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esta tarjeta de video está instalada en el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SoC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , conocido bajo la marca </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Snapdragon</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , de la compañía estadounidense </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualcomm</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Snapdragon se instala en los teléfonos inteligentes de gama alta de nuestro tiempo de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Samsung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sony</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font><strong><font style="vertical-align: inherit;">otros.Las</font></strong></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
tarjetas de video </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> actuales </font><font style="vertical-align: inherit;">son las familias de las series 3xx - 6xx. </font><font style="vertical-align: inherit;">Todas estas series combinan las siguientes características:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">núcleos de sombreadores unificados</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pseudo TBR (grandes tamaños de mosaico ubicados en una memoria GPU dedicada tradicional)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambio automático en modo inmediato Renderizado según la naturaleza de la escena ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FlexRender</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conjunto de instrucciones escalares</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comenzando con </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 4xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , se presenta el soporte para </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 3.1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y con </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 5xx - Vulkan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 3.2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizado basado en mosaico Adreno</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las tarjetas de video Adreno tienen una GPU "tradicional" llamada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GMEM</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se aplican volúmenes de 128 kb a 1536 kb. Esto le permite usar un tamaño de mosaico mayor en comparación con las arquitecturas de otros desarrolladores de GPU móviles. En Adreno, el tamaño de los mosaicos es dinámico y depende del formato de color utilizado, el búfer de profundidad y la plantilla. Cuando se trabaja en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modo inmediato, la</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> representación se produce en la memoria del sistema. Existe una extensión GL ES que le permite especificar el modo preferido: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QCOM_binning_control</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sin embargo, las últimas recomendaciones de Qualcomm sugieren confiar completamente en los controladores de GPU, que determinan el modo más preferido para el búfer de comandos generado por la aplicación.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando trabaje en modo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TBR</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adreno realiza 2 pases de vértice:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pase binning</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : distribución de primitivas por bin ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bins</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sinónimo de mosaico)</font></font></li>
<li><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paso de vértice</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> completo </font><font style="vertical-align: inherit;">para representar solo aquellas primitivas que caen en el contenedor actual</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pase Binning,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adreno solo calcula las posiciones de vértice. </font><font style="vertical-align: inherit;">No se calculan otros atributos y el optimizador elimina el código innecesario. </font><font style="vertical-align: inherit;">En la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentación oficial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (9.2 Optimizar el procesamiento de vértices), se recomienda almacenar la información de vértices necesaria para calcular las posiciones por separado del resto de los datos. </font><font style="vertical-align: inherit;">Esto hace que el almacenamiento en caché de datos de vértices sea más eficiente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freedreno</font></font></h2><br>
<img src="https://habrastorage.org/getpro/habr/post_images/83e/c3d/15d/83ec3d15dc03e81e81e7d867cae2b3a3.png" align="left" width="120"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A diferencia de las tecnologías ARM e Imagination, Qualcomm es reacio a compartir los detalles de la estructura interna de sus GPU. </font><font style="vertical-align: inherit;">Sin embargo, gracias a los esfuerzos del ingeniero inverso Rob Clark, se puede aprender </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mucho del</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proyecto </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Freedreno</font></a><font style="vertical-align: inherit;"> , el controlador </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> código abierto </font><font style="vertical-align: inherit;">para Linux. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rob Clark de Freedreno</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR de Imagination Technologies</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagination Technologies</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una compañía británica de fábulas famosa por desarrollar GPU para productos de Apple. </font><font style="vertical-align: inherit;">La compañía desempeñó este papel hasta la llegada del iPhone 8 / X, que utiliza el desarrollo interno de Apple. </font><font style="vertical-align: inherit;">Aunque las recomendaciones sobre optimizaciones para estos chips que no han cambiado, así como las reclamaciones de patentes contra Apple de Imagination sugieren que Apple continuó desarrollando la arquitectura PowerVR, un desarrollo original de Imagination. </font><font style="vertical-align: inherit;">A principios de 2020, Apple </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">volvió</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a las prácticas de licencia con Imagination Technologies. </font><font style="vertical-align: inherit;">Además de los dispositivos con iOS / iPadOS, las tarjetas de video PowerVR se instalan en una gran cantidad de teléfonos inteligentes y tabletas con Android.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9d/86d/b66/a9d86db66b2293beaf3b01d3d809573f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere la familia de tarjetas gráficas PowerVR que todavía se pueden encontrar entre los usuarios.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR SGX</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las primeras tarjetas gráficas PowerVR SGX aparecieron en 2009. </font><font style="vertical-align: inherit;">Hay varias generaciones de esta arquitectura: Series5, Series5XT y Series5XE. </font><font style="vertical-align: inherit;">Apple usó estas GPU hasta el iPAD 4 / iPhone 5 / iPOD Touch 5. Se pueden citar las siguientes características de SGX:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">núcleos de sombreadores unificados</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 2.0</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conjunto de instrucciones de vector</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soporte para precisión de lowp de 10 bits en sombreadores</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bajo rendimiento de lecturas de textura dependientes</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Detengámonos en algunos de ellos con más detalle.&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisión baja</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PowerVR SGX son las únicas GPU móviles actualizadas con </font></font><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soporte de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hardware </font><strong><font style="vertical-align: inherit;">lowp</font></strong><font style="vertical-align: inherit;"> . Los modelos más nuevos de PowerVR, así como todas las GPU modernas de otros proveedores, en realidad usan precisión de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mediump</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El uso de </font></font><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lowp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el PowerVR SXG le permite lograr una mayor densidad de cómputo (más operaciones por ciclo). Al mismo tiempo, la operación de swizzle (permutación de los componentes del vector) para </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lowp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a diferencia de otra precisión, no es gratuita. Esta característica, así como el rango estrecho de valores que lowp proporciona ([-2,2]), limita su alcance. Al mismo tiempo, el </font><strong><font style="vertical-align: inherit;">lowp</font></strong><font style="vertical-align: inherit;"> mal configurado</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El resultado de los artefactos en la familia SGX no se verá en todas las otras tarjetas gráficas donde realmente se utilizará la precisión de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">medición</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por esta razón, debe considerar negarse a usar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lowp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en sombreadores.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lecturas de textura dependientes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como sabe, las operaciones de muestreo de textura son las más lentas debido a la necesidad de esperar los resultados de lectura de memoria. En el caso de SoC móvil, estamos hablando de memoria compartida del sistema con una CPU. Para reducir el número de accesos a la memoria lenta, se utilizan cachés de textura. Para evitar el tiempo de inactividad al comienzo de la rasterización utilizando una textura, tiene sentido almacenar en caché las áreas utilizadas de antemano. Si el sombreador de fragmentos usa la coordenada de textura pasada desde el sombreador de vértices sin cambios, entonces la sección de textura necesaria para el almacenamiento en caché se puede determinar antes de ejecutar el sombreador de fragmentos. Si el sombreador de fragmentos cambia la coordenada de textura o la calcula utilizando datos de otra textura, esto no siempre es posible. Como resultado, la ejecución del sombreador de fragmentos puede ralentizarse.Las tarjetas gráficas PowerVR SGX son particularmente dolorosas en este escenario. Además, incluso el uso de una permutación de los componentes de la coordenada de textura (swizzle) conduce a</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">textura dependiente leída</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Aquí hay un ejemplo de programa de sombreado sin </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lectura de textura dependiente</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programa de vértice</font></font></strong><br>
<br>
<pre><code class="cpp hljs">attribute highp vec2 a_texc;<font></font>
varying highp vec2 v_texc;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
	gl_Position = …<font></font>
	v_texc = a_texc;<font></font>
}<font></font>
<font></font>
</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programa de fragmentos</font></font></strong><br>
<br>
<pre><code class="cpp hljs">precision mediump <span class="hljs-keyword">float</span>;<font></font>
uniform sampler u_sampler;<font></font>
varying highp vec2 v_texc;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
	gl_FragColor = texture2D( u_sampler, v_texc ); <span class="hljs-comment">//  dependent texture read</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso: </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fragmento de programa</font></font></strong><br>
<br>
<pre><code class="cpp hljs">precision mediump <span class="hljs-keyword">float</span>;<font></font>
uniform sampler u_sampler;<font></font>
varying highp vec2 v_texc;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
	gl_FragColor = texture2D( u_sampler, v_texc.yx ); <span class="hljs-comment">// dependent texture read!</span><font></font>
}<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR Rogue</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las tarjetas de video PowerVR se desarrollaron aún más en la arquitectura </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rogue</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Hay varias generaciones de esta arquitectura: de Series6 a Series9. </font><font style="vertical-align: inherit;">Todos los </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR Rogue</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tienen estas características:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">núcleos de sombreadores unificados</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arquitectura de instrucción escalar</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soporte para OpenGL ES 3.0+ (hasta 3.2, así como la API de Vulkan para reglas nuevas)&nbsp;</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR TBDR</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al igual que todas las GPU móviles comunes, PowerVR usa una tubería en mosaico. Pero a diferencia de sus competidores, Imagination fue más allá e implementó la </font><font style="vertical-align: inherit;">rasterización </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diferida</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de primitivas, lo que permite omitir el sombreado de píxeles invisibles independientemente del orden de representación. Este enfoque se llama </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizado diferido basado en mosaico</font></font></strong></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y el proceso de eliminación de píxeles invisibles se </font><font style="vertical-align: inherit;">llama </font><font style="vertical-align: inherit;">Eliminación de superficie oculta (HSR).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff2/2db/1dd/ff22db1dd631bb54e964aa24c96b437f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminación de superficies ocultas</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Se recomienda dibujar la geometría opaca en transparente y no usar Z Prepass, que en el caso de las tarjetas de video PowerVR en la mayoría de los escenarios conducirá a un trabajo innecesario. </font><font style="vertical-align: inherit;">Sin embargo, varios píxeles transparentes consecutivos que se superponen entre sí están completamente sombreados para obtener el color correcto, teniendo en cuenta la mezcla. </font><font style="vertical-align: inherit;">El último píxel transparente puede descartarse si es seguido por un píxel opaco.&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tecnologías de imaginación abierta</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los creadores de PowerVR han proporcionado acceso abierto a más documentación que otros desarrolladores de GPU. </font><font style="vertical-align: inherit;">La arquitectura de la tubería gráfica se describe en detalle, así como un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conjunto de instrucciones para la arquitectura Rogue</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hay una herramienta conveniente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVRShaderEditor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que le permite recibir </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">instantáneamente</font></a><font style="vertical-align: inherit;"> información de perfil en el sombreador, así como su listado desmontado para Rogue.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aba/b9a/19e/abab9a19e78e6ff40638d5cdf971615a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pesar de la presencia limitada de las tarjetas de video PowerVR en el entorno de dispositivos basados ​​en Android, tiene sentido estudiar su arquitectura para la programación competente de gráficos para iOS.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU móviles en modo inmediato</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinamos las familias más comunes de tarjetas de video móviles. </font><font style="vertical-align: inherit;">Todas estas familias utilizaron la arquitectura de representación en mosaico. </font><font style="vertical-align: inherit;">Sin embargo, hay tarjetas de video móviles que utilizan el </font><font style="vertical-align: inherit;">enfoque </font><font style="vertical-align: inherit;">tradicional de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modo inmediato</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Éstos son algunos de ellos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nVIdia (Tegra SoC)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toda la familia Intel excepto la reciente Gen 11</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vivante GCxxxx (+ Arcturus GC8000)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una característica de las tarjetas de video móviles que funcionan en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modo inmediato</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es la costosa operación de limpieza de FBO. </font><font style="vertical-align: inherit;">Recuerde que en la arquitectura de mosaico, la limpieza de pantalla completa acelera el renderizado, permitiendo que el controlador no agregue la operación de carga de los contenidos antiguos a la memoria del mosaico. </font><font style="vertical-align: inherit;">En las </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU de modo inmediato</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> móvil </font><strong><font style="vertical-align: inherit;">,</font></strong><font style="vertical-align: inherit;"> la limpieza de pantalla completa es una operación que requiere mucho tiempo y permite, entre otras cosas, que estas GPU se "calculen". </font><font style="vertical-align: inherit;">Si agregar limpieza no acelera, pero ralentiza el renderizado, lo más probable es que estemos trabajando con </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU en modo inmediato</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bueno, por supuesto, no olvidemos mencionar que en las </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU en modo inmediato,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cambiar un objetivo es un procedimiento "condicionalmente libre".</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distribución de diferentes familias de GPU móviles entre nuestros jugadores.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas son las estadísticas sobre las GPU móviles recopiladas de nuestros jugadores a finales de 2019:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/184/634/e7f1846345e5e8bf798bbf207a11885d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuación abrimos el segmento "Otros"</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a3/f61/604/8a3f61604361a8c8e426ae0ae8920f05.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En base a estos datos, observamos la distribución de la GPU en términos de sus características principales.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b41/b97/3d5/b41b973d5d8d01e817a558d838396d63.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las ALU de vector (unidad de lógica aritmética) se vuelven obsoletas y se reemplazan por otras escalares. Hoy, la mayor parte de las GPU móviles con un conjunto de instrucciones vectoriales es </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Midgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que puede considerarse promedio en rendimiento. Porque La vectorización, como regla, no ralentiza la ejecución en ALU escalares; vale la pena considerar la vectorización como una técnica real para optimizar los sombreadores para dispositivos móviles.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los núcleos de sombreadores especializados están en desuso y son reemplazados por otros unificados. El cuello de botella del vértice en la malla esquelética ya no da miedo. Los núcleos especializados se utilizan solo en la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">familia Mali-4xx (Utgard)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Recuerde que estas GPU solo son compatibles con </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 2.0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nuestra audiencia tiene alrededor del 3.5% de ellos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, la gran mayoría de las GPU móviles utilizan el enfoque de mosaico. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El modo inmediato se ha</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> marginado y se está exprimiendo rápidamente junto con las tarjetas de video que lo usan. </font><font style="vertical-align: inherit;">La proporción de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en </font><strong><font style="vertical-align: inherit;">modo inmediato</font></strong><font style="vertical-align: inherit;"> en nuestros jugadores es de aproximadamente 0.7%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enlaces útiles:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">developer.arm.com/solutions/graphics</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">developer.qualcomm.com/software/adreno-gpu-sdk/tools</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.imgtec.com/developers/powervr-sdk-tools/documentation/</font></font></a></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Gracias por la atención! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el próximo artículo de la serie, consideraremos técnicas para optimizar sombreadores para dispositivos móviles.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es498548/index.html">Creando su propio paquete para Laravel Nova: OptimalImage</a></li>
<li><a href="../es498552/index.html">¿Qué errores cometen los gerentes en un sitio remoto?</a></li>
<li><a href="../es498556/index.html">Hans Peter Lun y el nacimiento del algoritmo hash</a></li>
<li><a href="../es498560/index.html">Componentes web en un proyecto real</a></li>
<li><a href="../es498562/index.html">Contrariamente a la cuarentena: cómo transferimos nuestras pasantías a un formato remoto</a></li>
<li><a href="../es498566/index.html">Ingeniería de resiliencia: notas de la conferencia REDeploy</a></li>
<li><a href="../es498568/index.html">Dentro del microprocesador seccional de múltiples chips Am2901 de los años 70 de AMD</a></li>
<li><a href="../es498572/index.html">¿Descuentos extraños? Acciones de proveedores de CRM con motivo de la transición a udalenka</a></li>
<li><a href="../es498574/index.html">¿Por qué decidí desarrollar juegos o un viaje nostálgico por cero?</a></li>
<li><a href="../es498576/index.html">Cómo desarrollamos el campo para ingresar nuevos mensajes en nuestro messenger (Gem4me)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>