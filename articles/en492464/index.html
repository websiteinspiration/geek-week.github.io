<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😽 👻 ⚾️ DBA: competently organize synchronization and imports 🏴󠁧󠁢󠁥󠁮󠁧󠁿 📬 🧕🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With complex processing of large data sets (different ETL processes : imports, conversions, and synchronization with an external source), it is often ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>DBA: competently organize synchronization and imports</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/492464/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With complex processing of large data sets (different </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETL processes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : imports, conversions, and synchronization with an external source), it is often necessary to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temporarily “remember” and immediately process</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> something voluminous. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A typical task of this kind usually sounds something like this: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“Here the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accounting department uploaded the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> last received payments </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">from the client bank</font></a><font style="vertical-align: inherit;"> , we need to quickly upload them to the website and link them to the accounts”</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
But when the volume of this “something” begins to be measured in hundreds of megabytes, and the service This should continue to work with the base in 24x7 mode, there are many side effects that will ruin your life.</font></font><br>
<img src="https://habrastorage.org/webt/tl/g3/ff/tlg3ffjptyayqlu-5k06oonr_vi.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To cope with them in PostgreSQL (and not only in it), you can use some optimization options that will allow you to process faster and with less resources.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Where to ship?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, let's decide where we can upload the data that we want to “process”.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1. </font><font style="vertical-align: inherit;">Temporary Tables (TEMPORARY TABLE)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In principle, for PostgreSQL, temporary ones are the same tables as any others. </font><font style="vertical-align: inherit;">Therefore, superstitions like </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“everything is stored there only in memory, but it can end”</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are incorrect </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But there are several significant differences.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Own namespace for each connection to the database</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If two connections try to make at the same time </font></font><code>CREATE TABLE x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then someone will definitely get an </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">error of non-unique</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DB objects. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But if both try to execute </font><font style="vertical-align: inherit;">, then both will normally do it, and each will receive </font><b><font style="vertical-align: inherit;">its own copy of the</font></b><font style="vertical-align: inherit;"> table. </font><font style="vertical-align: inherit;">And there will be nothing in common between them.</font></font><code>CREATE <b>TEMPORARY</b> TABLE x</code><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Self-destruction" with disconnect</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When you close the connection, all temporary tables are automatically deleted, so </font></font><code>DROP TABLE x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there is no sense in </font><font style="vertical-align: inherit;">“manually” executing </font><font style="vertical-align: inherit;">, except ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you work through </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pgbouncer in transaction mode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the database continues to assume that this connection is still active, and this temporary the table still exists. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, an attempt to recreate it, from another connection to pgbouncer, will result in an error. </font><font style="vertical-align: inherit;">But this can be circumvented by taking advantage </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">
True, it’s better not to do it all the same, because then you can “suddenly” find out the data left from the “previous owner” there. </font><font style="vertical-align: inherit;">Instead, it’s much better to read the manual, and see that when creating the table there is an opportunity to add</font></font><code>CREATE TEMPORARY TABLE <b>IF NOT EXISTS</b> x</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>ON COMMIT <b>DROP</b></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - that is, when the transaction is completed, the table will be automatically deleted.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Non-replication</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Because only a particular join belongs, temporary tables are not replicated. </font><font style="vertical-align: inherit;">But </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this eliminates the need to double-write data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in heap + WAL, so INSERT / UPDATE / DELETE is much faster in it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But since the temporary table is still an “almost ordinary” table, it cannot be created on the replica either. </font><font style="vertical-align: inherit;">At least for now, although the corresponding patch has been around for a long time.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2. </font><font style="vertical-align: inherit;">Unlogged tables (UNLOGGED TABLE)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But what to do, for example, if you have some cumbersome ETL process that cannot be implemented within a single transaction, and you still have </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pgbouncer in transaction mode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? .. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Or the data stream is so large that there is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not enough bandwidth per connection</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from the database (read, one process on the CPU)? .. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Or do some of the operations go </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asynchronously</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in different connections? .. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is only one option - to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temporarily create a non-temporary table</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pun, yeah. </font><font style="vertical-align: inherit;">I.e:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">created “his” tables with maximally random names so as not to cross with anyone</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extract</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : poured data from an external source into them</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transform</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : transformed, filled in key binding fields</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : poured finished data into target tables</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deleted "my" tables</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now - a fly in the ointment. </font><font style="vertical-align: inherit;">In fact, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all the writing in PostgreSQL happens twice</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first in the WAL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then in the body of the table / index. </font><font style="vertical-align: inherit;">All of this is done to support ACID and the correct visibility of data between </font></font><code>COMMIT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nested and </font></font><code>ROLLBACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nested transactions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But we don’t need this! </font><font style="vertical-align: inherit;">We have the whole process </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or successfully passed, or not</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It doesn’t matter how many intermediate transactions it contains - we are not interested in “continuing the process from the middle”, especially when it is not clear where it was. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To do this, the PostgreSQL developers introduced version 9.1 such as </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">non-journaled (UNLOGGED) tables</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<blockquote>      . ,    ,      (.  29),      <b>   </b>. ,     ;         <b> </b>.  ,    <b> </b>   .  ,    ,   .</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In short, it </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be much faster</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but if the database server "crashes" - it will be unpleasant. </font><font style="vertical-align: inherit;">But how often does this happen, and does your ETL process know how to correctly modify it “from the middle” after the “revitalization” of the database? .. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If not, and the case above is similar to yours - use </font></font><code>UNLOGGED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but never </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">include this attribute on real tables</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> data from which you are dear.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3. </font><font style="vertical-align: inherit;">ON COMMIT {DELETE ROWS | </font><font style="vertical-align: inherit;">DROP}</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This design allows when creating a table to set automatic behavior when the transaction ends. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
About </font><font style="vertical-align: inherit;">I already wrote above, it generates </font><font style="vertical-align: inherit;">, but the </font><font style="vertical-align: inherit;">situation is more interesting - here it is generated </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">
Since the entire infrastructure for storing the meta description of the temporary table is exactly the same as the usual one, the </font><b><font style="vertical-align: inherit;">constant creation and deletion of temporary tables leads to a strong "swelling" of the system tables</font></b><font style="vertical-align: inherit;"> pg_class, pg_attribute, pg_attrdef, pg_depend, ... </font><font style="vertical-align: inherit;">
Now imagine that you have a worker on the line connecting to the database, which every second opens a new transaction, creates, fills, processes and deletes the temporary table ... Garbage in the system tables will accumulate in excess, and this is extra brakes during each operation.</font></font><code>ON COMMIT <b>DROP</b></code><font style="vertical-align: inherit;"></font><code>DROP TABLE</code><font style="vertical-align: inherit;"></font><code>ON COMMIT <b>DELETE ROWS</b></code><font style="vertical-align: inherit;"></font><code>TRUNCATE TABLE</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, do not! </font><font style="vertical-align: inherit;">In this case, it’s much more efficient </font></font><code>CREATE TEMPORARY TABLE x ... ON COMMIT DELETE ROWS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to take it out of the transaction cycle - then by the beginning of each new transaction the table </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> already </font><b><font style="vertical-align: inherit;">exist</font></b><font style="vertical-align: inherit;"> (save the call </font></font><code>CREATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), but it </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be empty</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , thanks to </font></font><code>TRUNCATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(we saved the call too) at the end of the previous transaction.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4. </font><font style="vertical-align: inherit;">LIKE ... INCLUDING ...</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I mentioned at the beginning that one of the typical use cases for temporary tables is various kinds of imports - and the developer tiredly copy-paste the list of fields of the target table into the declaration of his temporary ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But laziness is the engine of progress! </font><font style="vertical-align: inherit;">Therefore, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creating a new table “on the model”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be much simpler:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TEMPORARY</span> <span class="hljs-keyword">TABLE</span> import_table(
  <span class="hljs-keyword">LIKE</span> target_table<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since you can then add a lot of data to this table, searches on it will never be quick. But there is a traditional solution against this - indexes! And, yes, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a temporary table can also have indexes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since, often, the desired indices coincide with the indices of the target table, you can simply write </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">
If you also need </font><font style="vertical-align: inherit;">-values ​​(for example, to fill in the primary key values), you can use </font><font style="vertical-align: inherit;">. Well, or just - </font><font style="vertical-align: inherit;">- it will copy defaults, indexes, constraints ... </font><font style="vertical-align: inherit;">
But here you need to understand that if you created an </font><b><font style="vertical-align: inherit;">import table right away with indexes, then the data will be filled in longer</font></b></font><code>LIKE target_table <b>INCLUDING INDEXES</b></code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>DEFAULT</code><font style="vertical-align: inherit;"></font><code>LIKE target_table <b>INCLUDING DEFAULTS</b></code><font style="vertical-align: inherit;"></font><code>LIKE target_table <b>INCLUDING ALL</b></code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">than if you fill everything first, and then roll the indices - look as an example of how </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_dump</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> does it </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All in all, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTFM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. How to write?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will say simply - use </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">COPY</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-stream instead of "packs" </font></font><code>INSERT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acceleration at times</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">You can even directly from a pre-generated file.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. How to handle?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, let our introductory look something like this:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you have in your database a plate with client data for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1M records</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">every day the client sends you a new </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">complete “image”</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from experience you know that </font><b><font style="vertical-align: inherit;">no more than 10K records change</font></b><font style="vertical-align: inherit;"> from time to time</font></font><b><font style="vertical-align: inherit;"></font></b></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A classic example of such a situation is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the KLADR database</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - there are a lot of addresses, but in each weekly uploading of changes (renaming of settlements, street associations, the appearance of new houses) there are very few, even nationwide.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1. </font><font style="vertical-align: inherit;">Full synchronization algorithm</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For simplicity, let’s say that you don’t even need to restructure the data - just bring the table in the right form, that is:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> everything that is no longer</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">update</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> everything that was already, and you need to update</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">insert</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> everything that has not been</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why in this order it is worth doing operations? </font><font style="vertical-align: inherit;">Because this is how the size of the table grows minimally ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remember about MVCC!</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DELETE FROM dst</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No, of course, you can do just two operations:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><code>DELETE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) at all</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paste</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> everything from a new image</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But at the same time, thanks to MVCC, the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size of the table will increase exactly twice</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Get + 1M image records in the table due to 10K update - so-so redundancy ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TRUNCATE dst</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A more experienced developer knows that the whole plate can be cleaned quite cheaply:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clear</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><code>TRUNCATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) the whole table</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paste</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> everything from a new image</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The method is effective, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sometimes it’s quite applicable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but there is a problem ... We will inject 1M records, so we cannot afford to leave the table empty for all this time (as will happen without wrapping in a single transaction). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Which means:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we start a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">long transaction</font></font></b></li>
<li><code>TRUNCATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imposes </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AccessExclusive</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Lock</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we do the insert for a long time, and everyone else at this time </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cannot even</font></font><code>SELECT</code></b></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Something is bad ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ALTER TABLE ... RENAME ... / DROP TABLE ...</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As an option, fill everything into a separate new table, and then simply rename it to the old one. </font><font style="vertical-align: inherit;">A couple of nasty little things:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AccessExclusive</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> too </font><font style="vertical-align: inherit;">, albeit substantially less in time</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all query plans / statistics of this table are reset, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it is necessary to drive ANALYZE</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all foreign keys</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (FK) </font><b><font style="vertical-align: inherit;">break</font></b><font style="vertical-align: inherit;"> on the table</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There was a WIP patch from Simon Riggs, which suggested doing an </font></font><code>ALTER</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operation to replace the table body at the file level, without touching the statistics and FK, but did not collect the quorum.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DELETE, UPDATE, INSERT</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we stop on a non-blocking version of three operations. </font><font style="vertical-align: inherit;">Almost three ... How to do this most effectively?</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-comment">--     ,     "" </span>
<span class="hljs-keyword">BEGIN</span>;<font></font>
<font></font>
<span class="hljs-comment">--      </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TEMPORARY</span> <span class="hljs-keyword">TABLE</span> tmp(
  <span class="hljs-keyword">LIKE</span> dst <span class="hljs-keyword">INCLUDING</span> <span class="hljs-keyword">INDEXES</span> <span class="hljs-comment">--    ,   </span>
) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">COMMIT</span> <span class="hljs-keyword">DROP</span>; <span class="hljs-comment">--       </span><font></font>
<font></font>
<span class="hljs-comment">-- -     COPY</span><font></font>
COPY tmp FROM STDIN;<font></font>
<span class="hljs-comment">-- ...</span>
<span class="hljs-comment">-- \.</span><font></font>
<font></font>
<span class="hljs-comment">--  </span>
<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span><font></font>
  dst D<font></font>
<span class="hljs-keyword">USING</span><font></font>
  dst X<font></font>
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span><font></font>
  tmp Y<font></font>
    <span class="hljs-keyword">USING</span>(pk1, pk2) <span class="hljs-comment">--   </span>
<span class="hljs-keyword">WHERE</span>
  (D.pk1, D.pk2) = (X.pk1, X.pk2) <span class="hljs-keyword">AND</span>
  Y <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">FROM</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">-- ""</span><font></font>
<font></font>
<span class="hljs-comment">--  </span>
<span class="hljs-keyword">UPDATE</span><font></font>
  dst D<font></font>
<span class="hljs-keyword">SET</span><font></font>
  (f1, f2, f3) = (T.f1, T.f2, T.f3)<font></font>
<span class="hljs-keyword">FROM</span><font></font>
  tmp T<font></font>
<span class="hljs-keyword">WHERE</span>
  (D.pk1, D.pk2) = (T.pk1, T.pk2) <span class="hljs-keyword">AND</span>
  (D.f1, D.f2, D.f3) <span class="hljs-keyword">IS</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">FROM</span> (T.f1, T.f2, T.f3); <span class="hljs-comment">--   </span><font></font>
<font></font>
<span class="hljs-comment">--  </span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span><font></font>
  dst<font></font>
<span class="hljs-keyword">SELECT</span><font></font>
  T.*<font></font>
<span class="hljs-keyword">FROM</span><font></font>
  tmp T<font></font>
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span><font></font>
  dst D<font></font>
    <span class="hljs-keyword">USING</span>(pk1, pk2)
<span class="hljs-keyword">WHERE</span>
  D <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">FROM</span> <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-keyword">COMMIT</span>;
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2. </font><font style="vertical-align: inherit;">Import post processing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the same KLADER, all changed records must be additionally run through post-processing - normalize, highlight keywords, and bring to the necessary structures. </font><font style="vertical-align: inherit;">But how do you know </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">what exactly has changed</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , without complicating the synchronization code, ideally without touching it at all? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If only your process has write access at the time of synchronization, then you can use a trigger that will collect all the changes for us:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-comment">--  </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> kladr(...);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> kladr_house(...);<font></font>
<font></font>
<span class="hljs-comment">--    </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> kladr$<span class="hljs-keyword">log</span>(<font></font>
  ro kladr, <span class="hljs-comment">--      /</span><font></font>
  rn kladr<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> kladr_house$<span class="hljs-keyword">log</span>(<font></font>
  ro kladr_house,<font></font>
  rn kladr_house<font></font>
);<font></font>
<font></font>
<span class="hljs-comment">--    </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">FUNCTION</span> diff$<span class="hljs-keyword">log</span>() <span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">trigger</span> <span class="hljs-keyword">AS</span> $$
<span class="hljs-keyword">DECLARE</span>
  dst <span class="hljs-built_in">varchar</span> = TG_TABLE_NAME || <span class="hljs-string">'$log'</span>;<font></font>
  stmt text = '';<font></font>
<span class="hljs-keyword">BEGIN</span>
  <span class="hljs-comment">--      </span>
  <span class="hljs-keyword">IF</span> TG_OP = <span class="hljs-string">'UPDATE'</span> <span class="hljs-keyword">THEN</span>
    <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NEW</span> <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">OLD</span> <span class="hljs-keyword">THEN</span>
      <span class="hljs-keyword">RETURN</span> <span class="hljs-keyword">NEW</span>;
    <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;
  <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;
  <span class="hljs-comment">--   </span>
  stmt = '<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">' || dst::text || '</span>(ro,rn)<span class="hljs-keyword">VALUES</span>(<span class="hljs-string">';
  CASE TG_OP
    WHEN '</span><span class="hljs-keyword">INSERT</span><span class="hljs-string">' THEN
      EXECUTE stmt || '</span><span class="hljs-literal">NULL</span>,$<span class="hljs-number">1</span>)<span class="hljs-string">' USING NEW;
    WHEN '</span><span class="hljs-keyword">UPDATE</span><span class="hljs-string">' THEN
      EXECUTE stmt || '</span>$<span class="hljs-number">1</span>,$<span class="hljs-number">2</span>)<span class="hljs-string">' USING OLD, NEW;
    WHEN '</span><span class="hljs-keyword">DELETE</span><span class="hljs-string">' THEN
      EXECUTE stmt || '</span>$<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>)<span class="hljs-string">' USING OLD;
  END CASE;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we can impose triggers (or enable through </font></font><code>ALTER TABLE ... ENABLE TRIGGER ...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">before starting synchronization </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-keyword">log</span>
  <span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">DELETE</span>
  <span class="hljs-keyword">ON</span> kladr
    <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span>
      <span class="hljs-keyword">EXECUTE</span> <span class="hljs-keyword">PROCEDURE</span> diff$<span class="hljs-keyword">log</span>();<font></font>
<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-keyword">log</span>
  <span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">DELETE</span>
  <span class="hljs-keyword">ON</span> kladr_house
    <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span>
      <span class="hljs-keyword">EXECUTE</span> <span class="hljs-keyword">PROCEDURE</span> diff$<span class="hljs-keyword">log</span>();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And then quietly from the log tables we extract all the changes we need and run it through additional handlers.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3. </font><font style="vertical-align: inherit;">Import related sets</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Above, we considered cases when the data structures of the source and receiver coincide. </font><font style="vertical-align: inherit;">But what if the unloading from an external system has a format different from the storage structure in our database? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Take the storage of customers and their accounts as an example, the classic many-to-one option:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">client</span>(<font></font>
  client_id<font></font>
    <span class="hljs-built_in">serial</span>
      PRIMARY <span class="hljs-keyword">KEY</span><font></font>
, inn<font></font>
    <span class="hljs-built_in">varchar</span>
      <span class="hljs-keyword">UNIQUE</span>
, <span class="hljs-keyword">name</span>
    <span class="hljs-built_in">varchar</span><font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> invoice(<font></font>
  invoice_id<font></font>
    <span class="hljs-built_in">serial</span>
      PRIMARY <span class="hljs-keyword">KEY</span><font></font>
, client_id<font></font>
    <span class="hljs-built_in">integer</span>
      <span class="hljs-keyword">REFERENCES</span> <span class="hljs-keyword">client</span>(client_id)<font></font>
, <span class="hljs-built_in">number</span>
    <span class="hljs-built_in">varchar</span><font></font>
, dt<font></font>
    <span class="hljs-built_in">date</span>
, <span class="hljs-keyword">sum</span>
    <span class="hljs-built_in">numeric</span>(<span class="hljs-number">32</span>,<span class="hljs-number">2</span>)<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But unloading from an external source comes to us in the form of "all in one":</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TEMPORARY</span> <span class="hljs-keyword">TABLE</span> invoice_import(<font></font>
  client_inn<font></font>
    <span class="hljs-built_in">varchar</span><font></font>
, client_name<font></font>
    <span class="hljs-built_in">varchar</span><font></font>
, invoice_number<font></font>
    <span class="hljs-built_in">varchar</span><font></font>
, invoice_dt<font></font>
    <span class="hljs-built_in">date</span><font></font>
, invoice_sum<font></font>
    <span class="hljs-built_in">numeric</span>(<span class="hljs-number">32</span>,<span class="hljs-number">2</span>)<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviously, customer data can be duplicated in this way, and the main record is the “account”:</font></font><br>
<br>
<pre><code class="plaintext hljs">0123456789;;A-01;2020-03-16;1000.00<font></font>
9876543210;;A-02;2020-03-16;666.00<font></font>
0123456789;;B-03;2020-03-16;9999.00<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the model, just insert our test data, but remember - </font></font><code>COPY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">more efficiently!</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> invoice_import
<span class="hljs-keyword">VALUES</span>
  (<span class="hljs-string">'0123456789'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'A-01'</span>, <span class="hljs-string">'2020-03-16'</span>, <span class="hljs-number">1000.00</span>)<font></font>
, (<span class="hljs-string">'9876543210'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'A-02'</span>, <span class="hljs-string">'2020-03-16'</span>, <span class="hljs-number">666.00</span>)<font></font>
, (<span class="hljs-string">'0123456789'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'B-03'</span>, <span class="hljs-string">'2020-03-16'</span>, <span class="hljs-number">9999.00</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, we select those “cuts” to which our “facts” refer. </font><font style="vertical-align: inherit;">In our case, accounts refer to customers:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TEMPORARY</span> <span class="hljs-keyword">TABLE</span> client_import <span class="hljs-keyword">AS</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">ON</span>(client_inn)
<span class="hljs-comment">--   SELECT DISTINCT,    </span><font></font>
  client_inn inn<font></font>
, client_name <span class="hljs-string">"name"</span>
<span class="hljs-keyword">FROM</span>
  invoice_import;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to correctly associate accounts with customer IDs, we need to first find out or generate these identifiers. </font><font style="vertical-align: inherit;">Add fields for them:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> invoice_import <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> client_id <span class="hljs-built_in">integer</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> client_import <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> client_id <span class="hljs-built_in">integer</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will use the method of synchronizing tables with the small correction described above - we will not update or delete anything in the target table, because importing clients is “append-only”:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-comment">--     ID   </span>
<span class="hljs-keyword">UPDATE</span><font></font>
  client_import T<font></font>
<span class="hljs-keyword">SET</span><font></font>
  client_id = D.client_id<font></font>
<span class="hljs-keyword">FROM</span>
  <span class="hljs-keyword">client</span> D
<span class="hljs-keyword">WHERE</span>
  T.inn = D.inn; <span class="hljs-comment">-- unique key</span><font></font>
<font></font>
<span class="hljs-comment">--       ID</span>
<span class="hljs-keyword">WITH</span> ins <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">client</span>(<font></font>
    inn<font></font>
  , <span class="hljs-keyword">name</span><font></font>
  )<font></font>
  <span class="hljs-keyword">SELECT</span><font></font>
    inn<font></font>
  , <span class="hljs-keyword">name</span>
  <span class="hljs-keyword">FROM</span><font></font>
    client_import<font></font>
  <span class="hljs-keyword">WHERE</span>
    client_id <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span> <span class="hljs-comment">--  ID  </span>
  <span class="hljs-keyword">RETURNING</span> *<font></font>
)<font></font>
<span class="hljs-keyword">UPDATE</span><font></font>
  client_import T<font></font>
<span class="hljs-keyword">SET</span><font></font>
  client_id = D.client_id<font></font>
<span class="hljs-keyword">FROM</span><font></font>
  ins D<font></font>
<span class="hljs-keyword">WHERE</span>
  T.inn = D.inn; <span class="hljs-comment">-- unique key</span><font></font>
<font></font>
<span class="hljs-comment">--  ID    </span>
<span class="hljs-keyword">UPDATE</span><font></font>
  invoice_import T<font></font>
<span class="hljs-keyword">SET</span><font></font>
  client_id = D.client_id<font></font>
<span class="hljs-keyword">FROM</span><font></font>
  client_import D<font></font>
<span class="hljs-keyword">WHERE</span>
  T.client_inn = D.inn; <span class="hljs-comment">--  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actually, everything - in </font></font><code>invoice_import</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">now we have filled in the communication field </font></font><code>client_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with which we will insert the account.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en492454/index.html">We sell Architecture Refactoring to a client or what is the problem of developers</a></li>
<li><a href="../en492456/index.html">How to visualize and animate (geophysical) models. Show raw data</a></li>
<li><a href="../en492458/index.html">Simple GUI for M5Stack (Arduino)</a></li>
<li><a href="../en492460/index.html">Functional programming is what you (probably) were told. If you listened</a></li>
<li><a href="../en492462/index.html">Source of truth: how an analyst teaches a manager and a developer to work together</a></li>
<li><a href="../en492466/index.html">How to move from any host provider with cPanel to Plesk in Rusonix in just five steps</a></li>
<li><a href="../en492468/index.html">Lenovo Thinkserver SE350: a hero from the periphery</a></li>
<li><a href="../en492474/index.html">We structure the information on Android boxes and analyze what a normal prefix should be able to do.</a></li>
<li><a href="../en492478/index.html">Without knowledge management it hurts: 5 main consequences of the lack of a system</a></li>
<li><a href="../en492480/index.html">How we struggled with epidemics before and what we do against coronavirus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>