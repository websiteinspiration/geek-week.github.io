<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¥« ğŸ‘†ğŸ¾ ğŸ–¼ï¸ Menghasilkan Cabang Acak dengan Python ğŸ•‰ï¸ ğŸ³ ğŸ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ingat Dawkins, gagasan utama dapat diungkapkan sebagai berikut: jika Anda menyimpan tornado di tempat sampah untuk waktu yang lama , maka Boeing 747 d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Menghasilkan Cabang Acak dengan Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504296/"><img src="https://habrastorage.org/webt/fy/vd/nr/fyvdnr83rzvq1tow9chyg7e0kry.gif" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ingat Dawkins, gagasan utama dapat diungkapkan sebagai berikut: jika Anda </font><font style="vertical-align: inherit;">menyimpan tornado di tempat sampah untuk waktu yang </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lama</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , maka Boeing 747 dapat berkumpul. Munculnya suatu struktur dari kekacauan oleh seorang durik: menyortir dan menggabungkan kembali semuanya secara berurutan, dari semua proses yang tidak berarti dan tidak teratur, orang dapat melihat proses yang cukup bermakna dan teratur. Jika proses semacam itu diperbaiki dan diulangi dalam beberapa cara, maka sistem, yang kemarin adalah gerakan Brown, hari ini mulai terlihat seolah-olah perilakunya diatur oleh tangan yang tak terlihat, dan bahwa ia membuat beberapa tindakan yang bermakna dari sudut pandang kami. Pada saat yang sama, tidak ada tangan sama sekali. Dia mengatur dirinya sendiri.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memastikan hal ini lagi, saya berusaha untuk menulis semacam kehidupan digital, yang, dari kekacauan dan tanpa instruksi yang tidak perlu dari seseorang, akan dapat secara acak menghasilkan logika untuk dirinya sendiri dan ada di sana di habitat aslinya - sistem operasi. Ya, dalam hal ini, mungkin, ada perbedaan dari banyak program dari arah "Kehidupan Buatan", yang "hidup" dalam koral, menghasilkan "predator" dan "herbivora," dan hidup berdampingan di ladang buatan dengan "makanan" dan satu sama lain. Tidak satu pun dari program ini berinteraksi dengan objek sistem (proses, file, dll.), Yang berarti bahwa kode tersebut tidak benar-benar hidup. Selain itu, kode ini dengan satu atau lain cara masih melakukan beberapa jenis tugas yang dibutuhkan seseorang dan cakupannya sangat terbatas karena hal ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengimplementasikan kode dengan tingkat kebebasan tindakan yang besar dalam sistem operasi, yang pada saat yang sama tidak hanya berupa kumpulan instruksi yang dapat dieksekusi yang kacau, sebuah model muncul yang terdiri dari 3 modul. </font></font><br>
<a name="habracut"></a><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modul generasi acak dari kode yang dapat dieksekusi utama</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modul Pendidikan Acak</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modul "visi komputer" objek OS</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada artikel ini, kita akan berbicara tentang modul pertama, yang sejauh ini hanya generasi percabangan acak, yaitu konstruksi seperti "if-elif-else". Mengapa bercabang? Karena, pada umumnya, kehidupan setiap organisme hidup terdiri dari reaksi terkondisi: semua yang kita lakukan adalah respons terhadap informasi yang dirasakan. Sel membelah jika kondisi tertentu terjadi, korban mencoba melarikan diri jika ia melihat predator yang lebih kuat, dan jika ia lebih lemah, ia dapat mencoba untuk menyerangnya, kecoak berserakan jika lampu menyala, seseorang pergi makan, jika ia lapar, dll. dll. - baris ini tidak ada habisnya. Tidak ada tindakan independen dan terpisah yang tidak dikondisikan oleh apa pun. Akibatnya, perilaku organisme hidup khususnya digambarkan sebagai reaksi terhadap kondisi: JIKA [sesuatu] MAKA [sesuatu]. Kami mencoba menghasilkan perilaku ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa secara acak? Untuk meninggalkan kode peluang maksimum untuk bertindak secara independen dan memindahkan orang (programmer) sejauh mungkin dari proses ini (idealnya sepenuhnya dikecualikan). Yang terakhir adalah yang paling sulit bagi programmer, karena pemrograman standar, yang semua orang terbiasa, menyerupai pelatihan keras hewan, yang harus melakukan persis apa yang ditunjukkan oleh programmer, persis seperti yang ditunjukkannya ketika ditunjukkan. Di sini situasinya sebaliknya: kode yang dihasilkan akhir harus bertindak sehingga tidak dapat diprediksi oleh pembuat generatornya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum kita beralih ke diagram dan kode generator, kita perlu memikirkan fungsi pengambilan keputusan, yang digunakan sebagai konduktor, memungkinkan satu atau bagian lain dari kode dieksekusi. Saya menulis tentang dia sebelumnya</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Saya kemudian diminta untuk menggambarkan ide Reinforcement Learning dan permainan John Conway, berjudul "Life." Mungkin saya tidak menentang penggunaan apa yang telah dikembangkan atau secara terbuka. Pada akhirnya, semua yang baru adalah sintesis dari yang sudah diketahui, dan saya sendiri mengakui bahwa saya mengadopsi ide memprioritaskan aliran, yang digunakan di Windows. Di sini dia sangat cocok. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat ini, fungsi yang disebutkan telah sedikit diubah:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_solution</span>(<span class="hljs-params">p_random, p_deter</span>):</span>                       
    deter_flag = <span class="hljs-number">0</span>
    random_flag = <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> p_random &gt;= random.random():<font></font>
            p_random-=<span class="hljs-number">0.01</span>                                  <span class="hljs-comment">#  </span>
            p_deter+=<span class="hljs-number">0.01</span>
            random_flag = <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> p_deter &gt;= random.random():<font></font>
            p_deter-=<span class="hljs-number">0.01</span>                                   <span class="hljs-comment">#  </span>
            p_random+=<span class="hljs-number">0.01</span>
            deter_flag = <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> random_flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> deter_flag == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span>(p_random, p_deter, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">elif</span> deter_flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> random_flag == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span>(p_random, p_deter, <span class="hljs-number">-1</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> (p_random, p_deter,<span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada input, dibutuhkan 2 probabilitas (secara default di awal keduanya sama dengan 0,5), setelah itu memeriksa operasi mereka satu per satu. Probabilitas yang dipicu berkurang sendiri sebesar 1% dan pada saat yang sama meningkatkan yang lain sebesar 1%. Oleh karena itu, setiap kali probabilitas bekerja, ia menurun, dan yang lainnya meningkat. Akibatnya, tidak ada probabilitas mendapat terlalu banyak keuntungan di atas yang lain, dan mereka menyeimbangkan diri, membentuk distribusi normal yang berpusat pada 0,5 dan dengan lingkungan kerja tidak lebih dari + -10%, yang membedakan fungsi ini dari acak standar, di mana probabilitas dalam kasus kami Itu akan selalu sama dengan 0,5 dan tidak akan tergantung pada perhitungan sebelumnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara kiasan, itu adalah pendulum probabilitas dengan amplitudo kecil. Jika probabilitas pertama berhasil dan yang kedua tidak berhasil, maka mengembalikan 1, jika tidak -1 dikembalikan, dan jika keduanya bekerja atau tidak berhasil, 0. Dengan demikian, fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk 2 probabilitas yang masuk mengembalikan satu dari 3 tindakan yang mungkin, memberikan keseimbangan solusi bercabang dua dengan kemungkinan opsi kelanjutan. Di masa depan, fungsi ini mungkin bersifat universal, dan akan dapat mengambil jumlah probabilitas yang tidak terbatas, karena variasi pada fork bisa lebih dari 3, tetapi dalam kasus if-elif-else generator, tiga opsi untuk kelanjutan sudah cukup.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu juga dicatat di sini bahwa dalam kode ada yang berbeda, sehingga bisa dikatakan, garpu khas. Misalnya, seperti yang akan dilihat di bawah ini, dalam fungsi utama generator ada garpu di mana ada pilihan skema untuk membangun cabang, di mana hanya ada 3, tetapi kasus-kasus lain juga hadir dalam kode: masukkan blok tindakan atau mulai rekursi, berapa banyak garis tindakan untuk menghasilkan, seberapa rumit seharusnya Sejalan dengan kondisi, menempatkan atau atau dan, elif atau yang lain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya percaya bahwa pendulum probabilistik, yang telah kita bahas di atas, harus ditetapkan untuk setiap jenis tindakan: maka garpu hanya seimbang berdasarkan apa yang terjadi sebelumnya pada garpu ini, dan bukan di beberapa bagian lain dari kode. Itu ketika memilih struktur percabangan umum, kita memiliki pasangan probabilitas kita sendiri, dan di dalam, ketika elemen-elemennya dibangun, yang lain.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, Anda dapat menyeimbangkan semua tindakan dengan satu pasangan, tetapi kemudian probabilitas pada setiap garpu akan sangat sulit dan akan tergantung pada semua tindakan sebelumnya di persimpangan lain. Keacakan dari desain seperti itu akan lebih tinggi, tetapi untuk saat ini saya pribadi cenderung ke skema pertama, karena saya suka desain di mana yang kecil berayun dalam kerangka satu pendulum ayunan besar, yaitu. saldo yang lebih kecil dilahirkan dalam satu saldo besar. Plus, dalam skema kedua, keacakan juga lebih dari cukup. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat menulis generator cabang, perlu untuk membuat tidak hanya kode yang bisa diterapkan yang menghasilkan generasi bebas kesalahan, tetapi juga kode seperti itu yang </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bisa</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menghasilkan konstruksi maksimum yang mungkin dari if-elif-else, tetapi tidak ada 2 atau 3 opsi yang memungkinkan. Pertimbangkan, misalnya, skema yang mungkin berikut. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qu/oj/i3/quoji3ppc2arksk-xwafu3lfiqm.jpeg" width="350" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan ikon </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[..]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam skema yang saya maksud serangkaian ekspresi untuk kondisi atau blok tindakan acak. Skema yang paling dasar adalah 1, di mana kondisinya cukup, dan setelah itu blok tindakan. 2a dan 2b adalah jika variasi dengan satu elif atau yang lain. Dalam opsi 2c, jika sudah datang dalam kombinasi dengan beberapa elif tanpa yang lain. Dan akhirnya, dalam opsi 2d, skema yang paling umum disajikan, di mana jika berisi beberapa elif dan 1 lainnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya akan sederhana jika bukan karena kebutuhan untuk membangun cabang yang tidak terbatas. Setelah masing-masing jika, elif atau yang lain, rekursi dapat disebut, yang pada gilirannya juga dapat berulang lagi dan menghasilkan blok elif-else baru di "kanan". Mari kita lihat skema opsi yang memungkinkan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y0/0z/vr/y00zvr1zkcwxuceu28olrpfabpo.jpeg" width="400" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perwujudan 2e dan 2f menunjukkan kasus khusus sederhana dari percabangan rekursif seperti ketika rekursi disebut setelah satu elif tunggal atau setelah satu lainnya. Opsi 2g menjelaskan kasus rekursi yang paling kompleks dan umum, ketika setelah setiap elif akan ada blok tindakan + rekursi (atau rekursi segera), dan hal yang sama dapat terjadi setelah yang lain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masih ada variasi ketika rekursi terjadi segera setelah jika atau setelah jika dan blok tindakan.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/dv/ye/hxdvyem6hl667rv0v-e-mjhpiv8.jpeg" width="400" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini terlihat dalam opsi 3a dan 3b. Opsi 3c menunjukkan skema seperti itu dalam bentuk paling umum. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini bukan untuk mengatakan bahwa skema di atas mencakup semua opsi yang mungkin untuk membangun cabang, tetapi bahkan dalam bentuk ini, kode akhir dengan mudah menimbulkan cabang dari 150 baris, pergi "ke kanan" selama 10-15 langkah. Bagaimanapun, memperumit skema jika perlu tidak sulit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat melihat contoh </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salah satu</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generasi tersebut untuk memastikan bahwa cabang-cabangnya dapat sangat beragam.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zs/8j/gd/zs8jgd-5efc6vzg0thgjztgfyq0.jpeg" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda tidak perlu memperhatikan komposisi ekspresi kondisional dan blok aksi - untuk kesederhanaan visual, mereka dihasilkan dari kombinasi hanya dari dua variabel, 3 ekspresi dan sejumlah kecil aritmatika dan tanda-tanda logis. Diskusi tentang â€œdagingâ€ nyata untuk rekombinasi berada di luar ruang lingkup artikel ini (ini akan dibahas dalam diskusi 3 modul). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum melanjutkan ke pemeriksaan langsung kode generator, perlu diingat bahwa blok yang dihasilkan harus bergeser horizontal ke kanan, jika itu elif, jika tidak, rekursi atau blok aksi, dan juga "kembali" ke kiri setelah cabang selesai. Selain itu, mengingat bahwa Python sangat pilih-pilih tentang indentasi horisontal, diinginkan untuk membuat langkah yang sama (dalam kasus kami, langkahnya adalah 3).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diagram berikut menggambarkan bagaimana perpindahan digeser. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mu/p8/ue/mup8uegwtzj-fydzcdcsswbsutw.jpeg" width="500" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang paling penting di sini adalah bahwa pemindahan dengan pendalaman cabang selalu bergeser ke kanan. Namun, jika kita memiliki, misalnya, blok elif-lain di mana ada beberapa pasangan elif atau satu pasangan elif lain, maka ada kebutuhan untuk "mengembalikan" kereta yang melayang ke kanan, sehingga elif berikutnya (atau yang lain) dimulai dengan offset yang sama dengan yang sebelumnya di blok. Untuk melakukan ini, Anda harus menyimpan offset asli ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wall_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dan setelah akhir generasi cabang (misalnya, percabangan penuh satu elif), kembalikan. Ini memastikan bahwa elemen elif, kalau tidak, di blok "di atas satu sama lain" secara merata. Apalagi setiap blok baru memiliki perpindahannya sendiri. Trik yang sama memberikan harmoni dalam keseluruhan konstruksi if-elif-else (termasuk rekursi). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita beralih ke kode. Kode dengan volume total sekitar 200 baris terdiri dari 8 fungsi, salah satunya kami periksa di atas. Karena sifat berulang dan sejumlah besar parameter dilewatkan ke fungsi, itu bisa dibaca di tempat. Untuk mulai dengan, saya akan mengutip "daging" yang digunakan untuk menghasilkan ekspresi kondisional dan blok aksi.</font></font><br>
<br>
<pre><code class="python hljs">var_list = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]<font></font>
exp_list = [<span class="hljs-string">'a+b'</span>,<span class="hljs-string">'b-a'</span>, <span class="hljs-string">'b//a'</span>]<font></font>
sign = [<span class="hljs-string">'+'</span>,<span class="hljs-string">'-'</span>,<span class="hljs-string">'/'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'//'</span>]<font></font>
sign2 = [<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'=='</span>,<span class="hljs-string">'&gt;='</span>,<span class="hljs-string">'&lt;='</span>,<span class="hljs-string">'!='</span>]<font></font>
a = <span class="hljs-number">3</span>
b = <span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, dua variabel digunakan: a dan b ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), yang diinisialisasi, 3 ekspresi aritmatika ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exp_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), serta dua lembar dengan tanda ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sign, sign2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Seperti disebutkan sebelumnya, komposisi dari ekspresi yang dihasilkan tidak masalah sekarang dan tidak dipertimbangkan dalam artikel ini - mereka diperlukan terutama untuk menggambarkan kode. Satu lagi keanehan yang harus diperhatikan: pada generasi blok elif-else, Anda perlu melacak tampilan yang lain dan menghentikan generasi, jika tidak, mungkin akan muncul sebelum elif, yang secara alami akan menyebabkan kesalahan. Bendera </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> digunakan untuk tujuan ini </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memulai pertimbangan kami dengan fungsi generasi utama.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">if_gen</span>(<span class="hljs-params">exp_list, var_list, if_str, offset_koeff, fin_else_flag, prob_list</span>):</span>             <font></font>
    choice_list = [exp_list, var_list]<font></font>
    base_offset = <span class="hljs-string">' '</span>
    <span class="hljs-comment">#   </span>
    prob_list[<span class="hljs-number">0</span>],prob_list[<span class="hljs-number">1</span>],sol = make_solution(prob_list[<span class="hljs-number">0</span>],prob_list[<span class="hljs-number">1</span>])       
    <span class="hljs-comment"># if +   (1   )        </span>
    <span class="hljs-keyword">if</span> sol == <span class="hljs-number">0</span>: 
        <span class="hljs-comment">#     +3                                                                   </span>
        action_str = action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)                 
        <span class="hljs-keyword">return</span>(base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> + action_str, offset_koeff, fin_else_flag, prob_list) 
    <span class="hljs-comment"># if + elif/else (2   )           </span>
    <span class="hljs-keyword">elif</span> sol == <span class="hljs-number">-1</span>:                                                                         <font></font>
        if_str= base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> + action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list) <span class="hljs-comment"># if [..]:</span>
        <span class="hljs-comment">#  elif/else</span>
        prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol2=make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])             
        <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:<font></font>
            ee_string=<span class="hljs-string">'elif'</span>
        <span class="hljs-keyword">else</span>:<font></font>
             ee_string=<span class="hljs-string">'else'</span>
        <span class="hljs-comment">#   elif/else</span><font></font>
        if_str, offset_koeff, fin_else_flag, prob_list = elif_else_block(ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
        <span class="hljs-keyword">return</span>(if_str, offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-comment"># if + if() (3   )</span>
    <span class="hljs-keyword">else</span>:                                                                                   <font></font>
            if_str= base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> <span class="hljs-comment"># if [..]:</span>
            <span class="hljs-comment">#  if/if+ </span>
            prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>],sol = make_solution(prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>])        
            <span class="hljs-keyword">if</span> sol==<span class="hljs-number">0</span>:
                <span class="hljs-comment">#     +3</span>
                if_str+=action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)      
            <span class="hljs-comment">#          </span><font></font>
            wall_offset = offset_koeff                                                      <font></font>
            if_rek, offset_koeff, fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, offset_koeff+<span class="hljs-number">3</span>, fin_else_flag, prob_list) <span class="hljs-comment">#  if+if</span>
            <span class="hljs-comment">#    </span><font></font>
            if_str+=if_rek   <font></font>
            <span class="hljs-comment">#   elif-else/                                                                </span>
            prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>],sol2=make_solution(prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>])         
            <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:<font></font>
                prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol3=make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
                <span class="hljs-keyword">if</span> sol3!=<span class="hljs-number">0</span>:<font></font>
                    ee_string=<span class="hljs-string">'elif'</span>
                <span class="hljs-keyword">else</span>:<font></font>
                    ee_string=<span class="hljs-string">'else'</span><font></font>
                if_str, offset_koeff, fin_else_flag, prob_list = elif_else_block(ee_string, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)  <font></font>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment">#     +3</span>
                if_str+=action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)              
            <span class="hljs-keyword">return</span>(if_str, offset_koeff,fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain daftar dengan "daging" untuk generasi (exp_list, var_list), fungsi juga </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menerima if_str</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ini adalah baris di mana kode yang dihasilkan dikumpulkan secara bergantian. Ini diterima di sini karena fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen itu sendiri</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dapat dipanggil secara rekursif, dan disarankan untuk tidak kehilangan bagian kode yang dihasilkan sebelumnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parameter </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offset_koeff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah koefisien offset, yang merupakan faktor untuk sebuah garis dengan satu spasi ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dan, karenanya, bertanggung jawab atas perpindahan horizontal blok kode. </font><font style="vertical-align: inherit;">Kami berbicara </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tentang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag di</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atas, di sini ia hanya diteruskan ke fungsi yang bertanggung jawab untuk menghasilkan if + elif / else (lihat di bawah). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nah, ada parameter lain -</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang merupakan sheet dengan 10 probabilitas (5 pasang probabilitas)</font></font><pre><code class="python hljs">prob_list = [<span class="hljs-number">0.5</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)] </code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan itu digunakan oleh fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seperti yang kita bahas di atas: satu atau beberapa probabilitas dari itu terkait dengan jenis garpu diteruskan ke sana (misalnya, garpu struktural utama menggunakan 2 probabilitas pertama dalam lembaran: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list [0]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list [1]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Hasil dari perubahan probabilitas dalam lembar ini, sebagai contoh, dapat dilihat pada gambar berikut. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tw/_o/qc/tw_oqckdotydpm1m5djcmdc3rgw.jpeg" width="550" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probabilitas dalam daftar ini berubah dari generasi ke generasi, jika selama generasi berikutnya sepotong kode yang sesuai dijalankan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam fungsi itu sendiri, choice_list bersarang diinisialisasi pada awal - diperlukan untuk menghasilkan ekspresi acak yang mudah dari "daging", dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base_offset base_offset = ''</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam satu ruang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah itu muncul garpu utama, yang, melalui fungsi make_solution, mendapatkan solusi ke dalam variabel sol. Sol mengambil satu dari tiga nilai (0, -1.1) dan menentukan, oleh karena itu, sesuai dengan skema apa struktur akan dibangun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opsi pertama mengimplementasikan opsi paling sederhana jika + [..]. Jawabannya dibentuk sebagai string dengan offset saat ini (tidak harus sama dengan 0!), String "jika", kondisi acak yang dihasilkan oleh fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_sub</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (yang akan dibahas nanti), carriage return, dan pembuatan blok tindakan menggunakan fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">action_str</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (lihat di bawah) . Akibatnya, kami mendapatkan sesuatu seperti:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a+b)==(b)):<font></font>
   b=b<font></font>
   a=b-a<font></font>
   a=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opsi kedua bertanggung jawab untuk menghasilkan tipe ini: if [..] + elif / else-block (opsi 2 dalam skema). </font><font style="vertical-align: inherit;">Pertama, garis if [[]] terbentuk di sana, kemudian garpu elif / else muncul, yang memutuskan apakah blok elif-else akan dihasilkan, hanya jika-elif atau if-else (fungsi e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lif_else_block</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - lihat di bawah). </font><font style="vertical-align: inherit;">Hasil dapat bervariasi. </font><font style="vertical-align: inherit;">Contohnya:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a+b)==(a)):<font></font>
   b=a+b<font></font>
<span class="hljs-keyword">elif</span> ((b//a)==(a)):
   <span class="hljs-literal">None</span>
<span class="hljs-keyword">elif</span> ((a+b)&lt;=(a)):<font></font>
   a=b//a<font></font>
<span class="hljs-keyword">else</span>:
   <span class="hljs-keyword">if</span> ((b)&lt;=(a)):<font></font>
      a=b-a<font></font>
      b=a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)==(b-a)):<font></font>
   b=b-a<font></font>
   b=b<font></font>
   a=b<font></font>
   a=b-a<font></font>
<span class="hljs-keyword">elif</span> ((b)&gt;(b-a))<span class="hljs-keyword">and</span>((a)&lt;(b-a)):
   <span class="hljs-keyword">if</span> ((b//a)&lt;(a)):<font></font>
      b=b-a<font></font>
   <span class="hljs-keyword">elif</span> ((a+b)&lt;(b-a))<span class="hljs-keyword">and</span>((b)&lt;(a+b))<span class="hljs-keyword">or</span>((a+b)==(a+b)):<font></font>
      b=b<font></font>
      a=b-a<font></font>
   <span class="hljs-keyword">elif</span> ((a)&gt;(b-a)):
      <span class="hljs-literal">None</span></code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b)&lt;=(b-a))<span class="hljs-keyword">or</span>((a+b)&gt;=(b)):<font></font>
   a=a<font></font>
   b=b<font></font>
<span class="hljs-keyword">elif</span> ((b)&lt;=(b)):
   <span class="hljs-keyword">if</span> ((a)&gt;=(b)):<font></font>
      a=a+b<font></font>
      a=b<font></font>
<span class="hljs-keyword">elif</span> ((b)&gt;=(a)):<font></font>
   a=b-a<font></font>
   a=a<font></font>
   <span class="hljs-keyword">if</span> ((a)&gt;=(b))<span class="hljs-keyword">and</span>((b//a)==(a))<span class="hljs-keyword">and</span>((b//a)!=(b)):<font></font>
      b=b-a<font></font>
<span class="hljs-keyword">else</span>:<font></font>
   a=b//a<font></font>
   <span class="hljs-keyword">if</span> ((b//a)&lt;(b-a)):<font></font>
      a=b<font></font>
      a=b-a<font></font>
   <span class="hljs-keyword">else</span>:
      <span class="hljs-keyword">if</span> ((a)==(b)):<font></font>
         a=a<font></font>
         a=b//a<font></font>
         b=b<font></font>
         b=a+b<font></font>
         b=a<font></font>
      <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opsi ketiga mengimplementasikan rekursi dari awal (opsi 3 dalam skema), yaitu </font><font style="vertical-align: inherit;">memunculkan cabang bentuk:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)==(a)):
   <span class="hljs-keyword">if</span> ((a+b)&lt;(b)):</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
atau </font></font><pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)&lt;=(a)):<font></font>
   a=a<font></font>
   <span class="hljs-keyword">if</span> ((b-a)==(b)):<font></font>
      a=a<font></font>
      a=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, jika garis terbentuk (sama), maka garpu muncul, yang memutuskan apakah akan lebih lanjut menyisipkan blok tindakan atau tidak, setelah itu offset disimpan dan rekursi disebut. Offset harus disimpan sehingga setelah rekursi selesai dan potongan kode dikembalikan, dimungkinkan untuk menambahkan blok elif-else lain pada offset yang sama dengan baris asli dengan if. Di sini Anda dapat melihat bagaimana elif dan lainnya di cabang berdiri diimbangi dengan "asli" mereka jika.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)==(b)):<font></font>
<font></font>
   <span class="hljs-keyword">if</span> ((a)&gt;(a+b)):
      <span class="hljs-keyword">if</span> ((b)==(b-a)):<font></font>
         b=b<font></font>
         a=a<font></font>
      <span class="hljs-keyword">elif</span> ((b)&gt;(b)):
         <span class="hljs-literal">None</span>
      <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span><font></font>
         b=a<font></font>
         b=b</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya datang garpu di blok elif-else-block / action, yang memutuskan apakah akan menambahkan blok aksi atau blok elif-else setelah rekursi. Jika Anda memutuskan untuk menambahkan blok elif-else, maka di sana, mirip dengan kasus yang dijelaskan di atas, dalam skema 2, elif atau yang lain dipilih. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini perlu untuk memperhatikan fakta bahwa rekursi disebut dengan offset +3 untuk menggeser kode yang dihasilkan ke kanan dengan langkah, dan blok elif-lain dipanggil dengan offset wall_offset sehingga blok ini tidak pergi ke kanan setelah rekursi, tetapi tetap dengan "asli" offset dari yang asli jika. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasilnya bisa sangat berbeda: dari yang sederhana sampai yang kompleks, tetapi penampilan rekursi segera menghasilkan cabang yang paling berhias.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)&gt;(a+b))<span class="hljs-keyword">and</span>((b)&lt;(a+b)):
   <span class="hljs-keyword">if</span> ((b-a)&lt;=(a+b)):<font></font>
      b=b//a<font></font>
   <span class="hljs-keyword">elif</span> ((b)!=(a)):<font></font>
      a=b-a<font></font>
<span class="hljs-keyword">else</span>:
   <span class="hljs-keyword">if</span> ((a+b)!=(b-a)):<font></font>
      a=a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b)&lt;(b-a)):
   <span class="hljs-keyword">if</span> ((a+b)==(b-a))<span class="hljs-keyword">and</span>((b-a)&lt;(a+b))<span class="hljs-keyword">and</span>((b-a)==(a))<span class="hljs-keyword">and</span>((a)&gt;(b//a))<span class="hljs-keyword">or</span>((a+b)&gt;(b//a)):
      <span class="hljs-keyword">if</span> ((b)&gt;=(b-a)):<font></font>
         a=b<font></font>
         b=b<font></font>
         <span class="hljs-keyword">if</span> ((b)&gt;(b)):<font></font>
            a=a+b<font></font>
            b=a+b<font></font>
            a=a<font></font>
            b=a+b<font></font>
            b=b//a<font></font>
            b=a<font></font>
      <span class="hljs-keyword">else</span>:<font></font>
         b=a+b<font></font>
         a=b<font></font>
         a=b<font></font>
   <span class="hljs-keyword">elif</span> ((a)&lt;(b-a)):<font></font>
      a=b//a<font></font>
      a=b-a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)&gt;=(b-a))<span class="hljs-keyword">or</span>((a)&gt;=(a))<span class="hljs-keyword">or</span>((b)&lt;=(b)):<font></font>
   a=a<font></font>
   a=a<font></font>
<span class="hljs-keyword">elif</span> ((a)==(a))<span class="hljs-keyword">and</span>((b)&gt;(b-a)):<font></font>
   a=b//a<font></font>
   <span class="hljs-keyword">if</span> ((a)&lt;(b)):
      <span class="hljs-keyword">if</span> ((a+b)==(b-a)):<font></font>
         a=a<font></font>
         <span class="hljs-keyword">if</span> ((a)!=(b//a)):
            <span class="hljs-keyword">if</span> ((b//a)!=(a))<span class="hljs-keyword">and</span>((b-a)&gt;=(b)):<font></font>
               a=b<font></font>
            <span class="hljs-keyword">else</span>:
               <span class="hljs-literal">None</span><font></font>
               a=b//a<font></font>
      <span class="hljs-keyword">else</span>:<font></font>
         b=b<font></font>
         b=a+b<font></font>
         <span class="hljs-keyword">if</span> ((b-a)&lt;=(b//a)):<font></font>
            a=b<font></font>
            a=b<font></font>
            a=a+b<font></font>
<span class="hljs-keyword">else</span>:<font></font>
   a=a+b<font></font>
   <span class="hljs-keyword">if</span> ((b-a)&gt;=(a)):<font></font>
      a=b<font></font>
      <span class="hljs-keyword">if</span> ((b-a)==(a))<span class="hljs-keyword">or</span>((b)!=(b//a)):<font></font>
         a=b-a<font></font>
         a=a<font></font>
         a=a<font></font>
         a=b//a<font></font>
         a=a+b<font></font>
         b=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita lihat fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else_block</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang bertanggung jawab untuk membentuk blok elif-else dan dipanggil dari fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utama </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">elif_else_block</span>(<span class="hljs-params">ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list,  fin_else_flag, prob_list</span>):</span>
    <span class="hljs-keyword">if</span> ee_string==<span class="hljs-string">'elif'</span>:<font></font>
        sol3 = <span class="hljs-number">9</span>
        <span class="hljs-comment">#  </span><font></font>
        wall_offset = offset_koeff<font></font>
        <span class="hljs-comment">#  elif  </span>
        <span class="hljs-keyword">while</span> sol3!=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> fin_else_flag!=<span class="hljs-number">1</span>:<font></font>
            temp_str, offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'elif'</span>, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
            if_str+=temp_str<font></font>
            prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol3 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-comment">#  -   else   elif?</span>
        prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol = make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
        <span class="hljs-keyword">if</span> sol!=<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  else,   </span>
            fin_else_flag=<span class="hljs-number">1</span>
            temp_str,offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'else'</span>, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
            if_str+=temp_str<font></font>
        <span class="hljs-keyword">return</span>(if_str,offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-comment">#  else</span>
    <span class="hljs-keyword">else</span>: <font></font>
          temp_str,offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'else'</span>, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
          if_str+=temp_str<font></font>
          <span class="hljs-keyword">return</span>(if_str, offset_koeff, fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi ini memutuskan apakah akan menambahkan blok elif atau elif / else ke kode. Dia tidak memutuskan apakah akan memasukkan yang lain, tetapi tergantung pada nilai input e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e_string</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang dia terima dari fungsi utama </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pertama, blok elif dihasilkan di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop sementara</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana 2 kondisi diperiksa: probabilistic - jumlah elif di blok dan flag </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag bergantung padanya</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan jika tiba-tiba menyala, itu berarti ada yang terhubung sebelum itu, dan karena itu Anda harus keluar dari loop . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keputusan apakah akan melampirkan yang lain ke blok elif juga diputuskan oleh garpu menggunakan fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sama </font><font style="vertical-align: inherit;">, dan jika lagi dilampirkan, flag </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag dihidupkan segera</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menghentikan pemblokiran. </font><b><font style="vertical-align: inherit;">Penggabungan</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
langsung elif dan lainnya dilakukan oleh fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (lihat di bawah). Di sini perlu diperhatikan bahwa saat membuat blok elif (dan juga ketika memasang yang lain), offset </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wall_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> digunakan untuk membangun blok secara keseluruhan dengan lancar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang perhatikan fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs">&lt;b&gt;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">elif_else</span>(<span class="hljs-params">ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list</span>):</span>
    ee_str = <span class="hljs-string">''</span>
    <span class="hljs-comment">#   else:  elif [..]:</span>
    <span class="hljs-keyword">if</span> ee_string==<span class="hljs-string">'else'</span>:<font></font>
        ee_str += <span class="hljs-string">' '</span>*offset_koeff+ee_string + <span class="hljs-string">':\n'</span>
    <span class="hljs-keyword">elif</span> ee_string==<span class="hljs-string">'elif'</span>:<font></font>
        ee_str += <span class="hljs-string">' '</span>*offset_koeff+ee_string+<span class="hljs-string">' '</span>+if_sub(exp_list, var_list, sign, prob_list) + <span class="hljs-string">':\n'</span>
    <span class="hljs-comment">#   -None /  +</span>
    prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol = make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
    <span class="hljs-keyword">if</span> sol!=<span class="hljs-number">0</span>:<font></font>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  </span>
            ee_str+=action_str_gen(choice_list,offset_koeff+<span class="hljs-number">3</span>, prob_list)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># None</span>
            ee_str+=<span class="hljs-string">' '</span>*(offset_koeff+<span class="hljs-number">3</span>)+<span class="hljs-string">'None\n'</span>
        <span class="hljs-keyword">return</span>(ee_str, offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment">#   </span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2==<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  </span>
            ee_str+=action_str_gen(choice_list,offset_koeff+<span class="hljs-number">3</span>, prob_list)
        <span class="hljs-comment">#  if_gen</span>
        if_str, offset_koeff,  fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, offset_koeff+<span class="hljs-number">3</span>, fin_else_flag, prob_list)                 <font></font>
        ee_str+=if_str<font></font>
        <span class="hljs-keyword">return</span>(ee_str, offset_koeff, fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi ini bertanggung jawab untuk pembentukan elif atau garis itu sendiri, serta untuk generasi aksi berikutnya atau blok rekursi setelah garis-garis ini. Itu juga mengambil variabel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ee_string</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang berisi elif atau yang lain, dan membentuk string yang sesuai. Lalu ada garpu, di mana ditentukan apa yang akan terjadi selanjutnya: (blok tindakan atau Tidak ada), atau (blok tindakan atau blok tindakan + rekursi). Di dalam fork ini, ada divisi, masing-masing, menjadi dua sub-fork, dan dalam setiap kasus fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution dipanggil</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan parameter yang sesuai untuk membuat keputusan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu dicatat bahwa ketika itu terjadi dalam kode</font></font><code>if sol!=0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ini berarti bahwa kami sengaja memberi keuntungan pada satu bagian kode daripada yang lain, karena jika sol! = 0, maka itu sama dengan -1, atau 1, dan oleh karena itu bagian kode lain akan dieksekusi lebih jarang (hanya ketika sol == 0). Ini digunakan, khususnya, dalam fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else_block</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana lebih menguntungkan bagi kita untuk membiarkan lebih banyak bentuk </font><b><font style="vertical-align: inherit;">elif</font></b><font style="vertical-align: inherit;"> di blok, daripada memberikan probabilitas yang sama untuk elif dan lainnya. Atau, misalnya, dalam fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami memberikan keuntungan untuk opsi ketika blok tindakan atau Tidak ada yang terbentuk daripada apa yang terjadi untuk rekursi - jika tidak, cabang-cabang dapat tumbuh menjadi ukuran yang benar-benar tidak senonoh.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita hanya perlu mempertimbangkan fungsi yang bertanggung jawab untuk generasi ekspresi acak dalam kondisi dan blok tindakan. Seperti yang saya katakan di atas, pada tahap ini mereka tidak memainkan peran yang menentukan dan diperkenalkan di sini untuk secara umum menunjukkan seperti apa nantinya kode yang dihasilkan. Tetapi karena mereka digunakan dalam generator, kita akan melihatnya secara singkat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi yang bertanggung jawab untuk menghasilkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blok</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aksi </font><b><font style="vertical-align: inherit;">action_str</font></b><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action_str_gen</span>(<span class="hljs-params">choice_list, offset_koeff, prob_list</span>):</span>
    sol = <span class="hljs-number">9</span>
    curr_offset = <span class="hljs-string">' '</span>*offset_koeff<font></font>
    act_str = <span class="hljs-string">''</span>
    <span class="hljs-keyword">while</span> sol!=<span class="hljs-number">0</span>:<font></font>
        act_str+= curr_offset+rand(rand(choice_list[<span class="hljs-number">1</span>]))+<span class="hljs-string">'='</span>+rand(rand(choice_list))+<span class="hljs-string">'\n'</span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
    <span class="hljs-keyword">return</span>(act_str)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya cukup sederhana di sini: dari daftar bersarang choise_list, yang, seperti kita ingat, terdiri dari v </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ar_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (daftar variabel) dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exp_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (daftar ekspresi), fungsi ini terdiri dari satu atau lebih baris dari formulir ini: a = a + b atau b = b . </font><font style="vertical-align: inherit;">Itu </font><font style="vertical-align: inherit;">baik ekspresi ditugaskan ke variabel, atau variabel lain (termasuk dirinya sendiri). </font><font style="vertical-align: inherit;">Fungsi rand secara acak memilih elemen dari daftar dan diperlukan di sini semata-mata agar tidak menghasilkan string yang mengerikan.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rand</span>(<span class="hljs-params">t_list</span>):</span>
    <span class="hljs-keyword">return</span>(t_list[random.randint(<span class="hljs-number">0</span>,len(t_list)<span class="hljs-number">-1</span>)])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi generasi ekspresi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_sub</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk kondisi terlihat lebih besar.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">if_sub</span>(<span class="hljs-params">exp_list, var_list, sign, prob_list</span>):</span>
    sub_str = <span class="hljs-string">''</span>
    sol = <span class="hljs-number">9</span><font></font>
    choice_list = [exp_list, var_list]<font></font>
    flag = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> sol!=<span class="hljs-number">0</span>:<font></font>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])<font></font>
        sub_str+=<span class="hljs-string">'(('</span>+rand(rand(choice_list))+<span class="hljs-string">')'</span>+rand(sign2)+<span class="hljs-string">'('</span>+rand(rand(choice_list))+<span class="hljs-string">'))'</span>
        <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> sol==<span class="hljs-number">1</span>:<font></font>
            sub_str+=<span class="hljs-string">')'</span>
            flag=<span class="hljs-number">0</span><font></font>
        or_and_exp = or_and(prob_list)<font></font>
        <span class="hljs-keyword">if</span> len(or_and_exp):<font></font>
            sub_str+=or_and_exp<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2 == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'D'</span> <span class="hljs-keyword">or</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'R'</span>) <span class="hljs-keyword">and</span> flag == <span class="hljs-number">0</span>:<font></font>
            sub_str+=<span class="hljs-string">'('</span>
            flag = <span class="hljs-number">1</span><font></font>
    <font></font>
    <span class="hljs-keyword">if</span> sub_str[<span class="hljs-number">-1</span>] == <span class="hljs-string">'('</span>:
        <span class="hljs-keyword">if</span> sub_str[<span class="hljs-number">-2</span>]==<span class="hljs-string">'d'</span>:<font></font>
           sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-4</span>]
        <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-2</span>]==<span class="hljs-string">'r'</span>:<font></font>
             sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-3</span>]
        <span class="hljs-keyword">else</span>:<font></font>
            sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-1</span>]
    <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'d'</span>:<font></font>
         sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-3</span>]
    <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'r'</span>:<font></font>
         sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-2</span>]
    <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span>
    <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span>:<font></font>
        sub_str+=<span class="hljs-string">')'</span>
        <span class="hljs-keyword">return</span>(sub_str)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span>(sub_str)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini menghasilkan ekspresi berdasarkan tipe: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">((a)&gt; = (ba)) atau ((a)&gt; = (a)) atau ((b) &lt;= (b))</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pada saat yang sama, kedua sisi kiri dan kanan dapat memiliki berbagai opsi dan berdiri sebagai variabel yang terpisah, serta ekspresi atau grup mereka. </font><font style="vertical-align: inherit;">Operator logis </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> juga digunakan di sini </font><font style="vertical-align: inherit;">, yang dipilih untuk kenyamanan menggunakan fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or_and_exp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">or_and</span>(<span class="hljs-params">prob_list</span>):</span>
    prob_list[<span class="hljs-number">8</span>],prob_list[<span class="hljs-number">9</span>],sol = make_solution(prob_list[<span class="hljs-number">8</span>],prob_list[<span class="hljs-number">9</span>])
    <span class="hljs-keyword">if</span> sol==<span class="hljs-number">-1</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">'and'</span>)
    <span class="hljs-keyword">elif</span> sol==<span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">'or'</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">''</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sisa fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_sub</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memotong ekor ekstra dari ekspresi dan menambahkan, bila perlu, kurung tutup - untuk mempertimbangkan tarian ini dengan rebana di sini, saya pikir, tidak layak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yah, itu saja. </font><font style="vertical-align: inherit;">Anda dapat memulai generator, misalnya, seperti ini:</font></font><br>
<br>
<pre><code class="python hljs">var_list = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]<font></font>
exp_list = [<span class="hljs-string">'a+b'</span>,<span class="hljs-string">'b-a'</span>, <span class="hljs-string">'b//a'</span>]<font></font>
sign = [<span class="hljs-string">'+'</span>,<span class="hljs-string">'-'</span>,<span class="hljs-string">'/'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'//'</span>]<font></font>
sign2 = [<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'=='</span>,<span class="hljs-string">'&gt;='</span>,<span class="hljs-string">'&lt;='</span>,<span class="hljs-string">'!='</span>]<font></font>
a = <span class="hljs-number">3</span>
b = <span class="hljs-number">2</span>       
prob_list = [<span class="hljs-number">0.5</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)]      
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
     if_str = <span class="hljs-string">''</span>
     if_str, offset_koeff, fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>, prob_list)
     <span class="hljs-keyword">try</span>:<font></font>
         exec(compile(if_str,<span class="hljs-string">'gen'</span>,<span class="hljs-string">'exec'</span>))<font></font>
         print(if_str)<font></font>
         input()<font></font>
         <font></font>
     <span class="hljs-keyword">except</span> ZeroDivisionError:
         <span class="hljs-literal">None</span>
     <span class="hljs-keyword">except</span>:<font></font>
         print(<span class="hljs-string">'error'</span>)<font></font>
         print(if_str)<font></font>
         input()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, input, termasuk </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan probabilitas </font><font style="vertical-align: inherit;">, kemudian dalam infinite loop, memanggil fungsi utama </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan memulai string yang dihasilkan untuk dieksekusi. Perlu memproses secara terpisah ZeroDivisionError, karena pembagian dengan nol dengan konstruksi ekspresi acak seperti itu sangat umum. Setelah peluncuran, cukup tekan Enter agar generasi berikutnya muncul. Paling sering mereka akan sangat sederhana, tetapi sering bercabang dan bahkan sangat bercabang. Nah, </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impor acak</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di awal juga akan lebih baik untuk menyisipkan;) Bagi mereka yang tidak ingin melihat mengumpulkan semuanya dengan tangan, Anda dapat mengunduh file dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (file if_gen.py).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai kesimpulan, saya ingin mengatakan bahwa kode yang saya sajikan diuji pada ratusan ribu generasi tanpa kesalahan, sementara itu menunjukkan seluruh palet skema if-elif-else yang akhirnya ingin saya lihat. Suatu kali, secara tidak sengaja, saya memberi dalam satu bagian kode kemungkinan rekursi yang terlalu tinggi dan saya mendapat 52.000 (!) Baris generasi dan pada saat yang sama itu berfungsi (walaupun comp ditangguhkan selama 30 detik). Ini juga menunjukkan keandalan algoritma. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin, mungkin untuk menulis lebih ringkas di suatu tempat, untuk mengoptimalkan suatu tempat, untuk menyusun fungsi utama dengan cara lain, tetapi yang utama adalah bahwa kode ini bekerja dan menghasilkan sekitar 250 generasi per detik, yang, menurut saya, cukup dapat diterima.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak pernah menganggap kode ini swasembada - itu hanya modul dari organisme digital masa depan dan ditulis untuk tujuan penelitian, sehingga hampir tidak memiliki aplikasi praktis. </font><font style="vertical-align: inherit;">Pada saat yang sama, saya tidak bertanggung jawab atas konsekuensi bagi siapa pun yang menggunakan kode di atas, dan saya mendorong semua orang untuk memotong roti dengan pisau untuk memotong roti, dan bukan sesuatu yang lain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada artikel selanjutnya, kita akan mempertimbangkan modul kedua, yang akan bertanggung jawab untuk pembentukan pengalaman secara acak. </font><font style="vertical-align: inherit;">Topik ini berjanji akan jauh lebih menarik daripada generator if, dan saya pasti akan memposting hasilnya segera setelah saya memilikinya.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id504270/index.html">Apakah Svelte pilihan yang baik untuk implementasi widget?</a></li>
<li><a href="../id504276/index.html">10 Buku Pengembang Teratas</a></li>
<li><a href="../id504282/index.html">Penciptaan arsitektur Enterprise di NSPK</a></li>
<li><a href="../id504284/index.html">Buku â€œAgile Murni. Dasar-Dasar Fleksibilitas</a></li>
<li><a href="../id504290/index.html">Memuat pengujian sebagai layanan CI untuk pengembang</a></li>
<li><a href="../id504306/index.html">Bagaimana perangkat keras Rusia dibuat untuk penyimpanan Aerodisk Vostok di Elbrus</a></li>
<li><a href="../id504310/index.html">Dikotomi data: memikirkan kembali hubungan dengan data dan layanan</a></li>
<li><a href="../id504312/index.html">Daftar terpadu program Rusia dan GPL. Lima sen saya</a></li>
<li><a href="../id504314/index.html">Implementasi docker pull dan docker push commands tanpa klien docker melalui permintaan HTTP</a></li>
<li><a href="../id504320/index.html">Kode baris tunggal atau validasi Nethermind menggunakan PVS-Studio C # untuk Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>