<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎨 🐢 🤰🏼 Optimización masiva de consultas PostgreSQL. Kirill Borovikov (Tensor) 👰🏻 🤖 👸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El informe presenta algunos enfoques que le permiten monitorear el rendimiento de las consultas SQL cuando hay millones de ellas por día y cientos de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Optimización masiva de consultas PostgreSQL. Kirill Borovikov (Tensor)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/487380/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El informe presenta algunos enfoques que le permiten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">monitorear el rendimiento de las consultas SQL cuando hay millones de ellas por día</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y cientos de servidores PostgreSQL controlados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qué soluciones técnicas nos permiten procesar eficientemente tal volumen de información y cómo facilita la vida de un desarrollador ordinario.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/5XKbFb-l5Do" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Quién está interesado en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analizar problemas específicos y diversas técnicas para optimizar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consultas SQL y resolver problemas típicos de DBA en PostgreSQL </font><font style="vertical-align: inherit;">? También </font><font style="vertical-align: inherit;">puede </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leer una serie de artículos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre este tema.</font></font><br>
<a name="habracut"></a><br>
<img src="https://habrastorage.org/webt/rj/lq/ao/rjlqaolzkdl1dwerrz6q1f41exs.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi nombre es Kirill Borovikov, represento a la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empresa "Tensor"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Específicamente, me especializo en trabajar con bases de datos en nuestra empresa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoy les diré cómo estamos haciendo la optimización de consultas, cuando no necesiten "recoger" el rendimiento de una sola solicitud, sino resolver el problema en masa. Cuando hay millones de solicitudes y necesita encontrar algunos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enfoques para resolver</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> este gran problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, "Tensor" para nuestros millones de clientes es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VLSI: nuestra aplicación</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : una red social corporativa, soluciones de comunicación por video, para la gestión de documentos internos y externos, sistemas de contabilidad para la contabilidad y el almacenamiento ... Es decir, una "mega-combinación" para la gestión empresarial integrada, que es más de 100 proyectos internos diferentes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para garantizar que todos trabajen y se desarrollen normalmente, tenemos 10 centros de desarrollo en todo el país, tienen más de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 desarrolladores</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hemos estado trabajando con PostgreSQL desde 2008 y hemos acumulado una gran cantidad de lo que procesamos, es decir, datos de clientes, estadísticas, análisis, datos de sistemas de información externos, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">más de 400 TB</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Solo "en producción" hay alrededor de 250 servidores, y en total los servidores de bases de datos que monitoreamos son alrededor de 1000. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dx/sb/ej/dxsbejtgor4d4qc7u1cpkmxptx8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQL es un lenguaje declarativo. Usted describe no "cómo" algo debería funcionar, sino "qué" desea recibir. DBMS sabe mejor cómo hacer JOIN: cómo conectar sus tabletas, qué condiciones imponer, qué irá por índice, qué no ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunos DBMS aceptan sugerencias: "No, conecte estas dos tabletas en tal o cual cola", pero PostgreSQL no. Esta es la posición consciente de los desarrolladores líderes: "Mejor terminaremos el optimizador de consultas que dejar que los desarrolladores usen algún tipo de sugerencia". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, a pesar de que PostgreSQL no permite que el "exterior" se controle a sí mismo, le permite </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ver</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perfectamente </font><b><font style="vertical-align: inherit;">qué sucede "dentro"</font></b><font style="vertical-align: inherit;"> cuando ejecuta su consulta y dónde tiene problemas. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/k_/wc/q0/k_wcq0dayliwb4tturtbl3dmyre.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, ¿con qué problemas clásicos suele aparecer el desarrollador [viene a DBA]? "Aquí hemos cumplido la solicitud, y </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todo es lento</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , todo se cuelga, algo sucede ... ¡Algún tipo de problema!" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las razones son casi siempre las mismas:</font></font><br>
<br>
<ul>
<li><b>  </b><br>
: «   SQL  10   JOIN...» —  ,       «»,     .    ,       (10    FROM)   - . [<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>]</li>
<li><b> </b><br>
     PostgreSQL,     «»  ,   —     «»  .       10 ,   10 ,  PostgreSQL      ,      . [<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>]</li>
<li><b>«»  </b><br>
          ,     , ,   .  … -   ,       .</li>
<li><b></b><br>
 ,         (INSERT, UPDATE, DELETE) —    .</li>
</ul><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... Y para todo lo demás, ¡ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necesitamos un plan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! Necesitamos ver qué está sucediendo dentro del servidor. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c8/ni/rt/c8nirti-tkun1t6z4sxgpnwfwbw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El plan de ejecución de consultas para PostgreSQL es un árbol del algoritmo de ejecución de consultas en una representación textual. Es el algoritmo que, como resultado del análisis realizado por el planificador, fue reconocido como el más efectivo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada nodo de árbol es una operación: extraer datos de una tabla o índice, construir un mapa de bits, unir dos tablas, unir, intersectar o eliminar muestras. El cumplimiento de la solicitud es un paso a través de los nodos de este árbol. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para obtener un plan de consulta, la forma más fácil es ejecutar la declaración </font></font><code>EXPLAIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para obtener todos los atributos reales, es decir, ejecutar una consulta basada en - </font></font><code>EXPLAIN (ANALYZE, BUFFERS) SELECT ...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El punto negativo: cuando lo ejecutas, sucede "aquí y ahora", por lo tanto, solo es adecuado para la depuración local. Si toma un servidor de alta carga, que está bajo una fuerte corriente de cambios de datos, y ve: “¡Ay! Aquí somos más lentos a </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xia</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> una solicitud ". Hace media hora, hace una hora, mientras estaba ejecutando y obteniendo esta solicitud de los registros, llevándola nuevamente al servidor, todo su conjunto de datos y estadísticas han cambiado. Lo ejecutas para depurar, ¡y funciona rápido! Y no puedes entender por qué, por qué </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fue</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lento. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y9/-t/fu/y9-tfu3qhvhayjt86xoy02qy4ju.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comprender qué era exactamente en el momento en que la solicitud se ejecuta en el servidor, las personas inteligentes escribieron el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">módulo auto_explain</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Está presente en casi todas las distribuciones PostgreSQL más comunes, y simplemente puede activarlo en el archivo de configuración. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si entiende que una solicitud se está ejecutando por más tiempo que el límite que usted le dijo, toma una </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"instantánea" del plan para esta solicitud y las escribe juntas en un registro</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qh/cs/c1/qhcsc15sgsaruhdj6ghcjggfz7c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo parece estar bien ahora, vamos al registro y vemos allí ... [paso de texto]. Pero no podemos decir nada sobre él, excepto por el hecho de que este es un plan excelente, porque tardó 11 ms en completarse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo parece estar bien, pero nada está claro sobre lo que realmente sucedió. Además del tiempo total, no vemos mucho. Porque mirar tal texto plano "latuha" es generalmente querido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero incluso si es amado, aunque incómodo, pero hay problemas más importantes:</font></font><br>
<br>
<ul>
<li>   <b>    </b>  .     ,       Index Scan    — ,     -  .    ,    «»   , CTE —     « ».</li>
<li> : ,    , —  <b>   </b>.      , ,    ,  ,      loops —   .         .    ,  ,        ,      — - « ».</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En estas circunstancias, comprenda "¿Quién es el eslabón más débil?" </font><font style="vertical-align: inherit;">Casi irrealista. </font><font style="vertical-align: inherit;">Por lo tanto, incluso los propios desarrolladores en el "manual" escriben que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Comprender el plan es un arte que necesita ser aprendido, experiencia ..."</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero tenemos 1000 desarrolladores, y cada uno de ellos no pasará esta experiencia a sus cabezas. </font><font style="vertical-align: inherit;">Yo, tú, él, ellos lo saben, y alguien de allá, ya no está allí. </font><font style="vertical-align: inherit;">Tal vez aprenderá, o tal vez no, pero necesita trabajar ahora, y de dónde obtendría esta experiencia.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualización del plan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, nos dimos cuenta de que para hacer frente a estos problemas, necesitamos una </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buena visualización del plan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[artículo]</font></font></a><br>
<br>
<img src="https://habrastorage.org/webt/ev/nz/3g/evnz3gitzrva603ckfpd42ilzas.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Primero fuimos "alrededor del mercado" - veamos en Internet lo que existe en general. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero resultó que las soluciones relativamente "en vivo" que están más o menos desarrolladas, son muy pocas, literalmente, una cosa: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explicar.depesz.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de Hubert Lubaczewski. </font><font style="vertical-align: inherit;">En la entrada al campo "alimente" una representación textual del plan, le muestra una placa con los datos analizados:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiempo de trabajo del nodo adecuado</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiempo total en todo el subárbol</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la cantidad de registros que se recuperaron y que se esperaba estadísticamente</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el propio cuerpo del nodo</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este servicio también tiene la capacidad de compartir el archivo de enlaces. Lanzaste tu plan allí y dijiste: "Oye, Vasya, aquí hay un enlace para ti, algo está mal allí". </font></font><br>
<br>
<img src="https://habrastorage.org/webt/od/td/ik/odtdikeo22jwnlaxmizq2jodns0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero hay algunos problemas menores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, una gran cantidad de copiar y pegar. Coges un trozo del tronco, lo pones allí, y una y otra vez. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En segundo lugar, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no hay un análisis de la cantidad de datos leídos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , los mismos buffers que muestra </font></font><code>EXPLAIN (ANALYZE, BUFFERS)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aquí no vemos. Simplemente no sabe cómo desmontarlos, comprenderlos y trabajar con ellos. Cuando lee muchos datos y comprende que puede "descomponerse" incorrectamente en un disco y caché en la memoria, esta información es muy importante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tercer punto negativo es el desarrollo muy débil de este proyecto. Los commits son muy pequeños, es bueno si cada seis meses, y el código en Perl.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d9/zu/o6/d9zuo6g5etaeqqdpfsozjtzv09c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero todo esto es "letra", de alguna manera se podría vivir con ella, pero hay una cosa que nos ha alejado de este servicio. Estos son errores de análisis de Expresión de tabla común (CTE) y varios nodos dinámicos como InitPlan / SubPlan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si cree en esta imagen, entonces tenemos que el tiempo de ejecución total de cada nodo individual es mayor que el tiempo de ejecución total de toda la solicitud. Es simple: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el tiempo de generación de este CTE no se resta del nodo de escaneo CTE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Por lo tanto, ya no sabemos la respuesta correcta, cuánto tomó el escaneo CTE en sí. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uj/gt/8a/ujgt8auhv331ek_visf6ew7jslq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego nos dimos cuenta de que era hora de escribir el nuestro: ¡hurra! Cada desarrollador dice: "Ahora escribiremos el nuestro, ¡será súper!"</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tomaron una pila típica de servicios web: el núcleo en Node.js + Express, extrajeron Bootstrap y para hermosos diagramas - D3.js. </font><font style="vertical-align: inherit;">Y nuestras expectativas estaban justificadas: recibimos el primer prototipo en 2 semanas:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propio analizador de planes</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Es decir, ahora generalmente podemos analizar cualquier plan de los generados por PostgreSQL.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Análisis correcto de nodos dinámicos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : CTE Scan, InitPlan, SubPlan</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Análisis de la distribución de los búferes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : dónde se leen las páginas de datos de la memoria, de la caché local, de dónde proviene el disco</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">visibilidad recibida</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Para que no esté "en el registro" que esté "cavando", sino que vea el "enlace más débil" inmediatamente en la imagen.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/ou/gb/jf/ougbjf30wnktdmvhpqtjj6feqto.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obtuvimos algo como esto, inmediatamente con resaltado de sintaxis. Pero generalmente nuestros desarrolladores ya no están trabajando con una presentación completa del plan, sino con una presentación más corta. Después de todo, ya analizamos todos los dígitos y los lanzamos de izquierda a derecha, y dejamos solo la primera línea en el medio, qué tipo de nodo es: CTE Scan, CTE o Seq Scan generación por algún tipo de etiqueta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta vista abreviada es lo que llamamos la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plantilla del plan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zg/do/j_/zgdoj_caxmbjnyiq_gkiy0cfniw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué más sería conveniente? Sería conveniente ver qué proporción de qué nodo del tiempo total se nos asigna, y simplemente "pegó" el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gráfico circular</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el lateral </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Señalamos el nodo y vemos: con nosotros, resulta que Seq Scan tomó menos de un cuarto de todo el tiempo, y los 3/4 restantes tomaron CTE Scan. ¡Horror! Este es un pequeño comentario sobre la "velocidad de disparo" de CTE Scan, si los usa activamente en sus consultas. No son muy rápidos: pierden incluso con el escaneo de tabla habitual. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[artículo] </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[artículo]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pero, por lo general, estos diagramas son más interesantes, más complicados cuando señalamos inmediatamente un segmento y vemos, por ejemplo, que más de la mitad de las veces, algunos Seq Scan “comieron”. Además, había algún tipo de filtro en el interior, se arrojaron un montón de registros ... Puede lanzar esta imagen directamente al desarrollador y decir: "Vasya, ¡todo está mal contigo aquí! ¡Comprende, mira, algo anda mal! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ul/4i/2q/ul4i2q_4iasvokxfdcwp7jd9tj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Naturalmente, hubo un "rastrillo".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo primero que "pisaron" es el problema del redondeo. El tiempo de nodo de cada individuo en el plan se indica con una precisión de 1 μs. Y cuando el número de ciclos de nodos excede, por ejemplo, 1000, después de la ejecución PostgreSQL lo dividió "hasta", luego, en el cálculo inverso, obtenemos el tiempo total "en algún lugar entre 0,95 ms y 1,05 ms". Cuando la cuenta se gasta en microsegundos, nada todavía, pero cuando ya está en [mili] segundos, es necesario tener en cuenta esta información al "desvincular" recursos en los nodos del "quién tiene cuánto consumió a quién". </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fp/ds/f9/fpdsf9qkt6t_0q810uqhmrivc-k.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo punto, más complejo, es la distribución de recursos (esos mismos buffers) entre nodos dinámicos. Esto nos costó las primeras 2 semanas en el prototipo más el plus de la semana 4.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obtener este problema es bastante simple: creamos un CTE y supuestamente estamos leyendo algo en él. De hecho, PostgreSQL es inteligente y no leerá nada allí. Luego tomamos el primer registro y los primeros cien del mismo CTE. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s5/fv/rg/s5fvrgut9bky4uqjgmawpm97ks4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observamos el plan y entendemos: extraño, tenemos 3 buffers (páginas de datos) que se "consumieron" en Seq Scan, otro 1 en CTE Scan y 2 más en el segundo CTE Scan. Es decir, si todo se resume simplemente, obtenemos 6, ¡pero de la placa solo leemos 3! CTE Scan no lee nada de ninguna parte, pero funciona directamente con la memoria de proceso. Es decir, ¡claramente hay algo mal aquí! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, resulta que aquí todas esas 3 páginas de datos que se solicitaron a Seq Scan, primero 1 pidieron el primer CTE Scan, y luego el segundo, y leyeron otras 2. Es decir, se leyeron 3 páginas en total datos, no 6.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3q/5q/nh/3q5qnhygdtg3fh1os2fa-1kixhg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y esta imagen nos llevó a comprender que la implementación del plan ya no es un árbol, sino solo una especie de gráfico acíclico. </font><font style="vertical-align: inherit;">Y obtuvimos un cuadro como este para que entendamos "de dónde vino en absoluto". </font><font style="vertical-align: inherit;">Es decir, aquí creamos un CTE de pg_class, y lo solicitamos dos veces, y casi todo el tiempo nos llevó a la sucursal cuando lo solicitamos por segunda vez. </font><font style="vertical-align: inherit;">Está claro que leer el registro 101 es mucho más costoso que solo el primero de la tableta. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yg/kx/3o/ygkx3o3reytihnn6mkhyys3j7l8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exhalamos por un rato. </font><font style="vertical-align: inherit;">Ellos dijeron: “Ahora, Neo, ¡sabes kung fu! </font><font style="vertical-align: inherit;">Ahora nuestra experiencia está en tu pantalla. </font><font style="vertical-align: inherit;">Ahora puedes usarlo. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[artículo]</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consolidación de registro</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestros 1000 desarrolladores dieron un suspiro de alivio. Pero entendimos que solo tenemos cientos de servidores de "batalla", y todo este "copiar y pegar" por parte de los desarrolladores no es del todo conveniente. Nos dimos cuenta de que necesitábamos recogerlo nosotros mismos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jl/1t/od/jl1todhk17wci0h_ekudinbrruw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, hay un módulo regular que puede recopilar estadísticas, sin embargo, también debe activarse en la configuración; este </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es el módulo pg_stat_statements</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pero no nos convenía. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, asigna </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diferentes QueryId</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a las mismas consultas en diferentes esquemas dentro de la misma base de datos </font><font style="vertical-align: inherit;">. Es decir, si primero realiza </font></font><code>SET search_path = '01'; SELECT * FROM user LIMIT 1;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y luego </font></font><code>SET search_path = '02';</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la misma solicitud, las estadísticas de este módulo tendrán entradas diferentes, y no podré recopilar estadísticas generales precisamente en el contexto de este perfil de solicitud, sin tener en cuenta los esquemas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo punto que nos impidió usarlo es la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falta de planes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es decir, no hay un plan, solo existe la solicitud en sí. Vemos lo que se desaceleró, pero no entendemos por qué. Y aquí volvemos al problema de un conjunto de datos que cambia rápidamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y el último punto es la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falta de "hechos"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es decir, es imposible abordar una instancia específica de ejecución de consulta: no está allí, solo hay estadísticas agregadas. Aunque es posible trabajar con él, es muy difícil. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7x/sr/ij/7xsrijw56i20-dz5oiw0hurx9aq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, decidimos luchar contra "copiar y pegar" y comenzamos a escribir un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coleccionista</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El recopilador está conectado a través de SSH, "extrae" una conexión segura al servidor con la base de datos utilizando el certificado y se </font></font><code>tail -F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"aferra" al archivo de registro. Entonces en esta sesión</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obtenemos un "espejo" completo del archivo de registro completo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que genera el servidor. La carga en el servidor en sí es mínima, porque no analizamos nada allí, simplemente reflejamos el tráfico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como ya comenzamos a escribir la interfaz en Node.js, continuamos escribiendo el recopilador en ella. Y esta tecnología valió la pena, porque es muy conveniente usar JavaScript para trabajar con datos de texto mal formateados, que es el registro. Y la propia infraestructura de Node.js como plataforma de back-end le permite trabajar de manera fácil y conveniente con conexiones de red y, de hecho, con algún tipo de flujo de datos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En consecuencia, "extraemos" dos conexiones: la primera es "escuchar" el registro en sí y llevarlo a nosotros mismos, y la segunda es pedir periódicamente la base de datos. "Pero en el registro llegó que la placa con el oid 123 estaba bloqueada", pero no le dice nada al desarrollador, y sería bueno preguntarle a la base de datos "¿Qué es OID = 123 después de todo?" Entonces, periódicamente le pedimos a la base algo que aún no sabemos en casa. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gt/vi/ft/gtviftgv1xepi43a7dayhn5-kxy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"¡Simplemente no se tenía en cuenta, hay una especie de abejas parecidas a elefantes! ..." Comenzamos a desarrollar este sistema cuando queríamos monitorear 10 servidores. El más crítico en nuestro entendimiento, en el que hubo algunos problemas que fueron difíciles de tratar. Pero durante el primer trimestre obtuvimos cien para el monitoreo, porque el sistema "entró", todos lo querían, todos estaban cómodos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo esto debe agregarse, el flujo de datos es grande, activo. En realidad, controlamos lo que podemos manejar y luego lo usamos. También usamos PostgreSQL como un almacén de datos. Pero nada es más rápido para "verter" datos en él que </font></font><code>COPY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todavía no hay un </font><font style="vertical-align: inherit;">operador </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero simplemente "verter" los datos no es realmente nuestra tecnología. Porque si tiene alrededor de 50 mil solicitudes por segundo en un centenar de servidores, esto generará entre 100 y 150 GB de registros por día. Por lo tanto, tuvimos que cuidadosamente "ver" la base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, hicimos la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partición todos los días</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , porque, en general, a nadie le interesa la correlación entre los días. ¿Cuál es la diferencia que tuvo ayer, si esta noche lanzó una nueva versión de la aplicación y algunas estadísticas nuevas?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En segundo lugar, aprendimos (nos vimos obligados) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a escribir muy, muy rápidamente usando</font></font><code>COPY</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es decir, no solo </font></font><code>COPY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">porque es más rápido </font></font><code>INSERT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sino aún más rápido. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rm/ik/nj/rmiknjdu2ydi-yrbk7v369qe8eu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tercer punto: tuve </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que abandonar los disparadores, respectivamente, y de Foreign Keys</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es decir, no tenemos integridad absolutamente referencial. Porque si tiene una tabla en la que hay un par de FK, y dice en la estructura de la base de datos que "aquí hay una entrada de registro se refiere a FK, por ejemplo, un grupo de registros", entonces cuando lo inserta, PostgreSQL no tiene nada más cómo tomar y ejecutar honestamente </font></font><code>SELECT 1 FROM master_fk1_table WHERE ...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con el identificador que está intentando insertar, solo para verificar que esta entrada está allí, que no está "rompiendo" esta clave externa con su inserción.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obtenemos en lugar de un registro en la tabla de destino y sus índices, otro plus de lectura de todas las tablas a las que se refiere. Y no lo necesitamos en absoluto: nuestra tarea es anotar tanto como sea posible y lo más rápido posible con la menor carga. Así que FK - ¡abajo! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente punto es la agregación y el hash. Inicialmente, se implementaron en nuestra base de datos; después de todo, es conveniente inmediatamente, cuando llega una grabación, hacer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"más uno"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en algún tipo de placa </font><b><font style="vertical-align: inherit;">justo en el gatillo</font></b><font style="vertical-align: inherit;"> . Es bueno, conveniente, pero lo mismo es malo: inserte un registro, pero se ve obligado a leer y escribir otra cosa desde otra tabla. Además, no solo eso, leer y escribir, sino también hacerlo siempre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora imagine que tiene una placa en la que simplemente cuenta el número de solicitudes que pasaron en un host en particular:</font></font><code>+1, +1, +1, ..., +1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Y usted, en principio, no lo necesita: todo esto puede </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resumirse en la memoria del recopilador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y enviarse a la base de datos a la vez </font></font><code>+10</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sí, en caso de algunos fallos de funcionamiento, su integridad lógica puede "desmoronarse", pero este es un caso casi irreal: porque tiene un servidor normal, tiene una batería en el controlador, tiene un registro de transacciones, un registro en el sistema de archivos ... En general, no vale la pena. No vale la pena la pérdida de productividad que obtiene debido al trabajo de los disparadores / FK, los costos en los que incurre al mismo tiempo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo mismo con el hash. Una determinada solicitud vuela hacia usted, usted calcula un determinado identificador de la base de datos a partir de ella, escribe en la base de datos y luego se la cuenta a todos. Todo está bien, hasta que en el momento de la grabación, una segunda persona se acerca a ti y quiere grabarlo, y tienes un bloqueo, y esto ya es malo. Por lo tanto, si puede eliminar la generación de algunos ID en el cliente (en relación con la base de datos), es mejor hacerlo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estábamos perfectamente preparados para usar MD5 a partir del texto: una solicitud, un plan, una plantilla, ... Lo calculamos en el lado del recopilador y "vertimos" la ID ya hecha en la base de datos. La longitud de MD5 y la partición diaria nos permiten no preocuparnos por posibles colisiones. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/3c/yz/uz/3cyzuzpcxxmshllydd9cjcclc9i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero para grabar todo esto rápidamente, necesitábamos modificar el procedimiento de grabación en sí.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cómo sueles escribir datos? Tenemos algún tipo de conjunto de datos, lo descomponemos en varias tablas y luego COPIAMOS - primero en el primero, luego en el segundo, en el tercero ... Es inconveniente, porque escribimos un flujo de datos en tres pasos secuencialmente. Desagradable. ¿Es posible hacerlo más rápido? ¡Lata! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer esto, es suficiente descomponer estos flujos en paralelo entre sí. Resulta que tenemos errores, solicitudes, plantillas, bloqueos, volando en flujos separados ... - y lo escribimos todo en paralelo. Para hacer esto, simplemente </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mantenga el canal COPY permanentemente abierto en cada tabla de destino individual</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/v_/0z/vvv_0zw3lqqoqoznvaaqpvm19wq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, el colector </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siempre tiene una secuencia</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el que puedo escribir los datos que necesito. Pero para que la base de datos vea estos datos y alguien no se quede bloqueado, esperando que se escriban estos datos, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COPY debe interrumpirse con cierta periodicidad</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para nosotros, un período del orden de 100 ms resultó ser el más efectivo: cierre e inmediatamente vuelva a abrirlo en la misma mesa. Y si no tenemos una transmisión en algunos picos, entonces agrupamos a un cierto límite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, descubrimos que para dicho perfil de carga, cualquier agregación cuando se recopilan registros en paquetes es mala. El mal clásico está </font></font><code>INSERT ... VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">más allá de 1000 registros. Porque en este momento tiene un pico de grabación en los medios, y todos los que intenten escribir algo en el disco esperarán.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para deshacerse de tales anomalías, simplemente no agregue nada, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no proteja en absoluto</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Y si se produce el almacenamiento en búfer en el disco (afortunadamente, la API Stream en Node.js le permite averiguarlo): posponga esta conexión. </font><font style="vertical-align: inherit;">Ahí es cuando llega el evento de que es gratis nuevamente: escríbalo desde la cola acumulada. </font><font style="vertical-align: inherit;">Mientras tanto, está ocupado: tome el próximo libre del grupo y escríbalo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de implementar este enfoque para la grabación de datos, teníamos aproximadamente operaciones de escritura 4K, y de esta manera redujimos la carga en 4 veces. </font><font style="vertical-align: inherit;">Ahora han crecido otras 6 veces debido a las nuevas bases observables, hasta 100 MB / s. </font><font style="vertical-align: inherit;">Y ahora almacenamos registros durante los últimos 3 meses en una cantidad de aproximadamente 10-15 TB, con la esperanza de que en solo tres meses cualquier desarrollador pueda resolver cualquier problema.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entendemos los problemas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero solo recopilar todos estos datos es bueno, útil, apropiado, pero no suficiente: debe comprenderlo. </font><font style="vertical-align: inherit;">Porque son millones de planes diferentes por día. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/j6/kw/jg/j6kwjgsvci1xw-p_vgxpnq6ynag.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero millones son incontrolables, primero debe hacer "menos". </font><font style="vertical-align: inherit;">Y, antes que nada, es necesario decidir cómo organizará este "más pequeño". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hemos identificado por nosotros mismos tres puntos clave:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quién</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> envió esta solicitud </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
, es decir, desde qué aplicación "voló": interfaz web, back-end, sistema de pago u otra cosa.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Dónde</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sucedió esto? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En qué servidor en particular. </font><font style="vertical-align: inherit;">Porque si tiene varios servidores en una aplicación, y de repente uno "embotado" (porque el "disco se ha podrido", "pérdida de memoria", algún otro problema), entonces necesita abordar específicamente el servidor.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cómo se</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> manifestó </font><b><font style="vertical-align: inherit;">el</font></b><font style="vertical-align: inherit;"> problema de una forma u otra</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comprender “quién” nos envió la solicitud, utilizamos una herramienta regular: establecer una variable de sesión: </font></font><code>SET application_name = '{bl-host}:{bl-method}';</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enviar el nombre de host de la lógica de negocios desde la cual se realiza la solicitud y el nombre del método o aplicación que la inició. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de pasar al "propietario" de la solicitud, debe mostrarse en el registro, para esto configuramos la variable </font></font><code>log_line_prefix = ' %m [%p:%v] [%d] %r %a'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cualquier persona interesada puede </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ver en el manual</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lo que todo esto significa. </font><font style="vertical-align: inherit;">Resulta que vemos en el registro:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hora</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identificadores de procesos y transacciones</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombre base</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP de la persona que envió esta solicitud</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y nombre del método</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/9d/ms/_c/9dms_cgsmfbpgjiyndalqfyadf8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego nos dimos cuenta de que no es muy interesante observar la correlación de una solicitud entre diferentes servidores. Ocurre con poca frecuencia cuando tiene una aplicación que igualmente daña aquí y allá. Pero incluso si es lo mismo, mire cualquiera de estos servidores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sección “un servidor - un día”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resultó ser suficiente para cualquier análisis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La primera sección analítica es la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"plantilla"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , una forma abreviada de presentación del plan, libre de todos los indicadores numéricos. La segunda sección es la aplicación o método, y la tercera es el nodo específico del plan que nos causó problemas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando pasamos de instancias específicas a plantillas, inmediatamente recibimos dos ventajas:</font></font><br>
<br>
<ul>
<li><b>     </b><br>
         ,    .</li>
<li><b></b><br>
 ,  «»   - ,       .     ,     -  , ,   ,    —   ,  ,     —     , ,      .    ,  ,  .</li>
</ul><br>
<br>
<img src="https://habrastorage.org/webt/_1/gb/is/_1gbissbzxhnibnhpb5kb5ebuuu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resto de los métodos se basan en los indicadores que extraemos del plan: cuántas veces se produjo dicho patrón, el tiempo total y promedio, la cantidad de datos leídos del disco y la cantidad de la memoria ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Porque, por ejemplo, usted llega a la página de análisis por host, vea: algo demasiado en el disco para leer el comienzo. El disco del servidor no funciona, ¿y quién lee de él? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y puede ordenar por cualquier columna y decidir con qué se enfrentará en este momento: con la carga en el procesador o el disco, o con el número total de solicitudes ... Ordenado, se veía "superior", reparado, lanzó una nueva versión de la aplicación. </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[video conferencia]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Y de inmediato puede ver diferentes aplicaciones que vienen con la misma plantilla de una solicitud como</font></font><code>SELECT * FROM users WHERE login = 'Vasya'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Frontend, backend, procesamiento ... Y te preguntas por qué el usuario debería leer el procesamiento si no interactúa con él. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La forma opuesta es ver inmediatamente desde la aplicación lo que está haciendo. Por ejemplo, una interfaz es esto, esto, esto y esto una vez por hora (solo ayuda la línea de tiempo). Y de inmediato surge la pregunta: parece que no es asunto del front-end hacer algo una vez por hora ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z7/z-/4n/z7z-4nvcqjd8xktjpl1ilja63eo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de un tiempo, nos dimos cuenta de que carecíamos de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estadísticas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> agregadas </font><b><font style="vertical-align: inherit;">en términos de nodos del plan</font></b><font style="vertical-align: inherit;"> . Aislamos de los planes solo aquellos nodos que hacen algo con los datos de las propias tablas (leerlos / escribirlos por índice o no). De hecho, en relación con la imagen anterior, solo se agrega un aspecto: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuántos registros nos trajo este nodo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y cuántos cayó (Filas eliminadas por filtro).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No tiene un índice adecuado en la placa, lo solicita, vuela más allá del índice, cae en Seq Scan ... ha filtrado todos los registros excepto uno. ¿Y por qué necesita 100 millones de registros filtrados por día, es mejor rodar el índice? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/bw/j9/tkbwj9b2v1gmeifbmblipiya86q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de examinar todos los planes por nodos, nos dimos cuenta de que hay algunas estructuras típicas en los planes que probablemente parezcan sospechosas. Y sería bueno decirle al desarrollador: "Amigo, aquí primero lees por índice, luego ordenas y luego cortas", como regla, hay un registro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos los que escribieron consultas con este patrón probablemente se encontraron con: "Dame el último pedido para Vasya, su fecha" Y si no tienes un índice por fecha, o el índice utilizado no tiene una fecha, entonces sigue exactamente ese "rastrillo" y pisa .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero sabemos que esto es un "rastrillo", entonces, ¿por qué no decirle inmediatamente al desarrollador qué debe hacer? </font><font style="vertical-align: inherit;">En consecuencia, al abrir el plan ahora, nuestro desarrollador ve de inmediato una hermosa imagen con indicaciones, donde se le dice de inmediato: "Tienes problemas aquí y aquí, pero se resuelven de un modo a otro". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, la cantidad de experiencia que se necesitaba para resolver problemas al principio y ahora ha disminuido significativamente. </font><font style="vertical-align: inherit;">Aquí tenemos esa herramienta.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/1g/g6/si1gg6ffbtpgsb3q2ew_cgudqa4.jpeg"></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es487370/index.html">Análisis del mercado inmobiliario basado en datos de msgr.ru</a></li>
<li><a href="../es487372/index.html">Certificado profesional de IBM Data Science Certified</a></li>
<li><a href="../es487374/index.html">Paul Graham: problemas de moda</a></li>
<li><a href="../es487376/index.html">10 funciones angulares útiles que te perdiste</a></li>
<li><a href="../es487378/index.html">Los mejores servidores de pequeñas empresas en 2020</a></li>
<li><a href="../es487384/index.html">Profesión: desarrollador front-end</a></li>
<li><a href="../es487386/index.html">Lista de verificación de adaptación como herramienta de entrada suave</a></li>
<li><a href="../es487388/index.html">Desarrollo natural: cómo pasar del aprendizaje electrónico a la gestión del conocimiento</a></li>
<li><a href="../es487390/index.html">Componentes web sin Shadow DOM</a></li>
<li><a href="../es487392/index.html">¿Qué quiere saber Magnet sobre sus clientes?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>