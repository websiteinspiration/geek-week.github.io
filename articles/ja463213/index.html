<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐴 📢 ✊ 初心者C＃開発者の誤解。標準的な質問に答えようとする 🐐 🖕🏿 🗄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私は最近、かなり多くの初心者C＃開発者とチャットする機会がありました。彼らの多くは言語とプラットフォームに興味があり、これはとてもクールです。緑のジュニアの間で、あいまいさは明白な（記憶についての本を読むだけの）ことについて広まっています。そして、これは私にこの記事を作成するよう促しました。この記事...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>初心者C＃開発者の誤解。標準的な質問に答えようとする</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463213/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は最近、かなり多くの初心者C＃開発者とチャットする機会がありました。</font><font style="vertical-align: inherit;">彼らの多くは言語とプラットフォームに興味があり、これはとてもクールです。</font><font style="vertical-align: inherit;">緑のジュニアの間で、あいまいさは明白な（記憶についての本を読むだけの）ことについて広まっています。</font><font style="vertical-align: inherit;">そして、これは私にこの記事を作成するよう促しました。</font><font style="vertical-align: inherit;">この記事は主に開発者を対象としていますが、エンジニアの練習には多くの事実が役立つと思います。</font><font style="vertical-align: inherit;">もちろん、最も明白で興味のないエラーは除外されます。</font><font style="vertical-align: inherit;">特に面接に合格するという観点から、最も興味深く、重要なものを以下に示します。</font></font><br>
<br>
<div style="text-align:center;"><img width="300" src="https://habrastorage.org/webt/_q/a5/nc/_qa5ncp0f-7ydqssgacmzqevk30.png"></div><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃1。</font><font style="vertical-align: inherit;">あらゆる状況で3世代についてのマントラ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはエラーというよりは不正確です。開発者にとっての「C＃のガベージコレクター」に関する質問は古典的になり、世代の概念について賢明に答える人はほとんどいないでしょう。ただし、何らかの理由で、偉大で恐ろしいガベージコレクターがランタイムの一部であるという事実に注目する人はほとんどいません。したがって、私はそれが指ではないことを明確にし、どのようなランタイム環境が関係しているかを尋ねたでしょう。インターネット上の「c＃のガベージコレクター」というクエリは、多くの類似した情報以上のものを見つけることができます。ただし、この情報が</font><i><font style="vertical-align: inherit;">CLR / CoreCLR</font></i><font style="vertical-align: inherit;">に関するものであると言及する人はほとんどいません。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（通常）。</font><font style="vertical-align: inherit;">しかし、モバイル開発（Unity、Xamarin）のニッチを占め、Blazorで使用されている軽量で柔軟な埋め込み可能なランタイムMonoを忘れないでください。</font><font style="vertical-align: inherit;">そして、それぞれの開発者のために、Monoのアセンブリデバイスの詳細について問い合わせることをお勧めします。</font><font style="vertical-align: inherit;">-たとえば、クエリ「モノガベージコレクタの世代」で、あなたは2つだけの世代があることがわかります</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保育所</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旧世代</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（新しい、ファッショナブルなガベージコレクタで- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SGENを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃2 </font><font style="vertical-align: inherit;">あらゆる状況でのガベージコレクションの2つのステージに関するマントラ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少し前まで、ガベージコレクタのソースは誰からも隠されていました。ただし、プラットフォームの内部構造には常に関心がありました。したがって、情報はさまざまな方法で抽出されました。そして、コレクターのリバースエンジニアリングにおけるいくつかの不正確さは、コレクターがマーキングとクリーニングの2段階で機能するという神話につながりました。またはさらに悪いことに、マーキング、クリーニング、圧縮の3つの段階。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">火の人々</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CoreCLR</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の出現と</font><font style="vertical-align: inherit;">コレクターのソースコードで</font><s><font style="vertical-align: inherit;">戦争</font></s><font style="vertical-align: inherit;">を</font><s><font style="vertical-align: inherit;">解き放ったとき</font></s><font style="vertical-align: inherit;">、すべてが変化</font><s><font style="vertical-align: inherit;">しました</font></s><font style="vertical-align: inherit;">。 CoreCLRのコンパイラコードは、完全にCLRバージョンから取得されました。それぞれ最初からそれを書いた人はいませんが、CoreCLRソースコードから学習できるほとんどすべてがCLRにも当てはまります。何かがどのように機能するかを理解するには、githubにアクセスしてソースコードでそれを見つけるか、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">readmeを</font></a><font style="vertical-align: inherit;">読んでください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。そこには、マーキング、計画、リンクの更新、コンパクト化（再配置を伴う削除）、および再配置を伴わない削除（これは変換が難しい）の5つのフェーズがあることがわかります。しかし正式には、マーキング、計画、クリーニングの3つの段階に分けることができます。</font><b><font style="vertical-align: inherit;">マーキング</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">段階で</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コレクターが収集しないオブジェクトが判明します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
で</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計画段階、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリの現在の状態の様々な指標が計算され、洗浄段階で必要なデータが収集されます。この段階で受け取った情報のおかげで、圧縮（デフラグ）の必要性が判断され、オブジェクトの移動に必要な量なども計算されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">掃除の段階で</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 圧縮の必要性に応じて、リンクを移動せずに更新および圧縮または削除できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃3 </font><font style="vertical-align: inherit;">ヒープへのメモリの割り当てはスタックと同じくらい高速です</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しますが、絶対的な真実というよりは不正確です。</font><font style="vertical-align: inherit;">もちろん、一般的なケースでは、メモリ割り当ての速度の違いはごくわずかです。</font><font style="vertical-align: inherit;">実際、最良の場合、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バンプポインターの割り当て</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、スタックと同様に、メモリの割り当ては単なるポインターのシフトです。</font><font style="vertical-align: inherit;">ただし、古いフィールドに新しいオブジェクトを割り当てるなどの要素は、ヒープ上のメモリの割り当てに影響を与える可能性があります（</font><i><font style="vertical-align: inherit;">カードテーブルを</font></i><font style="vertical-align: inherit;">更新する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">書き込みバリアに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">影響し</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-古い世代から新しい世代へのリンクを追跡できるメカニズム）、ファイナライザの存在（適切なキューにタイプを追加する必要があります）など。オブジェクトがヒープ内の空きホールの1つに書き込まれることもあります（デフラグせずにアセンブリした後）。</font><font style="vertical-align: inherit;">そして、そのような穴を見つけることは、高速ではありますが、単純なポインターシフトより明らかに遅いです。</font><font style="vertical-align: inherit;">もちろん、作成された各オブジェクトは、次のガベージコレクションに近づきます。</font><font style="vertical-align: inherit;">そして、メモリを割り当てる次の手順では、それが発生する可能性があります。</font><font style="vertical-align: inherit;">これには当然、時間がかかります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃4。</font><font style="vertical-align: inherit;">スタックとヒープの概念による参照、意味のあるタイプ、およびパッケージの定義</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸いなことに、これはそれほど一般的ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
参照型はヒープ上にあります。スタック上で重要です。確かに多くの人がこれらの定義を非常に頻繁に聞いています。しかし、これは部分的な真実であるだけでなく、リークされた抽象化を通じて概念を定義することは良い考えではありません。すべての定義について、CLI標準</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-ECMA 335</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を参照することをお勧めします</font><font style="vertical-align: inherit;">。まず、型が値を表すことを明確にする価値があります。したがって、参照タイプは次のように定義されます。参照タイプ（リンク）によって記述された値は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別の値の</font><b><font style="vertical-align: inherit;">場所を</font></b><font style="vertical-align: inherit;">示し</font><font style="vertical-align: inherit;">ます。重要なタイプの場合、それによって記述される値は自律的です（自己完結型）。これらまたはこれらの種類の単語がどこにあるかについて。これはリークされた抽象化であり、まだ知っておく必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要なタイプが見つかります：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的メモリ（ヒープ）内で、ヒープ上にあるオブジェクトの一部である場合、またはパッケージングの場合。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタック上で、それがローカル変数/引数/メソッドの戻り値の場合。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レジスター内で、重要なタイプのサイズやその他の条件を許可する場合。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
参照タイプ、つまりリンクが指す値は、現在ヒープ上にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リンク自体は、重要なタイプと同じ場所に配置できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
梱包は、保管場所によっても決定されません。</font><font style="vertical-align: inherit;">簡単な例を考えてみましょう。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C＃コード</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">    public struct MyStruct<font></font>
    {<font></font>
        public int justField;<font></font>
    }<font></font>
    <font></font>
    public class MyClass<font></font>
    {<font></font>
     	public MyStruct justStruct;   <font></font>
    }<font></font>
    <font></font>
    public static void Main() <font></font>
	{<font></font>
        MyClass instance = new MyClass();<font></font>
        object boxed = instance.justStruct;        <font></font>
    }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてMainメソッドに対応するILコード</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ILコード</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">    1: nop<font></font>
    2: newobj instance void C/MyClass::.ctor()<font></font>
    3: stloc.0<font></font>
    4: ldloc.0<font></font>
    5: ldfld valuetype C/MyStruct C/MyClass::justStruct<font></font>
    6: box C/MyStruct<font></font>
    7: stloc.1<font></font>
    8: ret<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要な型は参照の一部であるため、ヒープに配置されることは明らかです。</font><font style="vertical-align: inherit;">6行目は、パッケージングを扱っていることを明確に示しています。</font><font style="vertical-align: inherit;">したがって、「スタックからヒープへのコピー」の一般的な定義は失敗します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パッケージが何であるかを判断するには、まず第一に、重要な型ごとに、CTS（共通型システム）がパック型と呼ばれる参照型を定義することは価値があります。</font><font style="vertical-align: inherit;">したがって、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージ化</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、元の値のビット単位のコピーを含む対応するパックされた型の値を作成する重要な型に対する操作です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃4。</font><font style="vertical-align: inherit;">イベント-別のメカニズム</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントは言語の最初のバージョンから存在し、それらに関する質問はイベント自体よりもはるかに一般的です。ただし、このメカニズムを使用すると、非常に疎結合されたコードを作成できるため、理解する価値があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、多くの場合、イベントは別個の手段、タイプ、メカニズムとして理解されます。これは特に、BCL </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からのタイプによって促進さ</font><font style="vertical-align: inherit;">れます。その名前は、それが何か別のものであることを示唆しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントを定義するには、まずプロパティを定義する必要があります。私は長い間、このような類推を自分のために描いてきましたが、最近、それがCLI仕様で描かれていることを知りました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロパティは、名前付きの値とそれにアクセスするメソッドを定義します。</font><font style="vertical-align: inherit;">それはかなり明白に聞こえます。</font><font style="vertical-align: inherit;">イベントに合格。</font><font style="vertical-align: inherit;">CTSはイベントだけでなくプロパティもサポートしますが、アクセスのメソッドは異なり、イベントへのサブスクライブおよびサブスクライブ解除のメソッドが含まれます。</font><font style="vertical-align: inherit;">C＃言語仕様から、クラスはイベントを定義します...イベントキーワードを追加したフィールド宣言を連想させます。</font><font style="vertical-align: inherit;">この宣言のタイプはデリゲートのタイプでなければなりません。</font><font style="vertical-align: inherit;">定義についてはCLI標準に感謝します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、これは、イベントがデリゲートの機能の一部のみを公開するデリゲートにすぎないことを意味します。実行のためにリストに別のデリゲートを追加し、このリストから削除します。</font><font style="vertical-align: inherit;">クラス内では、イベントはデリゲートのような単純なフィールドと同じです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃5。</font><font style="vertical-align: inherit;">マネージリソースとアンマネージリソース。</font><font style="vertical-align: inherit;">ファイナライザとIDisposable</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのリソースを扱う際には、完全な混乱があります。これは、Disposeパターンの正しい実装に関する1000の記事を掲載したインターネットによって大幅に促進されています。実際、このパターンには犯罪者は何もいません。特定のケースに合わせてテンプレートを変更した方法です。しかし、問題はそれがまったく必要かどうかです。何らかの理由で、くしゃみごとにファイナライザを実装したいという欲求がたまらない人もいます。ほとんどの場合、これの理由は、「管理されていないリソース」が何であるかを完全に理解していないことです。そして、ファイナライザでは、原則として、この不完全な理解のために管理されていないリソースが解放され、通り過ぎて頭に残っていないという事実に関する行。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">管理されていないリソース</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font><b><font style="vertical-align: inherit;">管理されていないリソース</font></b><font style="vertical-align: inherit;">です（ただし、奇妙ですが）。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">管理対象リソース</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、CLIがガベージコレクションと呼ばれるプロセスを通じて自動的に割り当て、解放するもの。私はこの標準をCLI標準から勇敢に取り除きました。しかし、もっと簡単に説明しようとすると、アンマネージリソースは、ガベージコレクターが認識していないリソースです。 （厳密に言うと、GC.AddMemoryPressureとGC.RemoveMemoryPressureを使用して、コレクターにそのようなリソースに関する情報を提供できます。これは、コレクターの内部チューニングに影響を与える可能性があります）。したがって、彼は彼ら自身の解放の面倒を見ることができないでしょう、それゆえ私たちは彼のためにそれをしなければなりません。そして、これには多くのアプローチがあります。また、コードが開発者のさまざまな想像力に眩しくないように、2つの一般的に受け入れられているアプローチが使用されています。</font></font><br>
<br>
<ol>
<li> IDisposable (    IAsyncDisposable).    ,       .    — Dispose.    —  using.      Dispose —           .    .      ,      ,    .<br>
</li>
<li>.     .  ,   ,    .   ,   ,        ,    ,    ,      . -   ,       .    ,      (resurrection)       .      —   .    ,  ,       .<br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、管理されていないリソースを内部で使用する、パフォーマンスに重要なライブラリを作成するときに、このリソースを適切に処理してメモリを手動で解放するだけで処理できる状況を簡単に想像できます。そのような高性能ライブラリーを作成するとき、OOP、サポート、およびその他のようなものは道端に行きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、DisposeがCLRが私たちのためにすべてを行う、私たちに何かを強制する、何かを思い出させるなどの概念に違反するという主張に反して、私は次のように言います。アンマネージリソースを操作するときは、自分以外の人がリソースを管理しないように準備する必要があります。そして一般に、これらのリソースが企業で使用される状況はほとんど発生しません。そして、ほとんどの場合、SafeHandleのような素晴らしいラッパークラスで問題を解決できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何らかの理由で、リリースに追加のアクションが必要なリソースがアプリケーションに多数ある場合は、JetBrainsの優れたパターンであるライフタイムを確認する必要があります。ただし、最初のIDisposableオブジェクトが表示されている場合は使用しないでください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃6 </font><font style="vertical-align: inherit;">ストリームスタック、コールスタック、コンピューティングスタック、</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタック&lt;T&gt;</font></font></pre></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後の段落はそれのために笑いを加えました;私は後者を前の2つに帰する人がいるとは思いません。</font><font style="vertical-align: inherit;">ただし、ストリームスタック、コールスタック、および計算スタックについては、多くの混乱があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しスタック</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-関数から戻るための戻りアドレスを格納するためのデータ構造、つまりスタック。呼び出しスタックは、より論理的な概念です。返品のために情報を保存する場所と方法を規定していません。呼び出しスタックが最も一般的でネイティブなスタックであることがわかります。スタック（冗談）。ローカル変数はそこに格納され、パラメータが渡され、CALL命令と割り込みが呼び出されたときに戻りアドレスが格納されます。これらは、関数/割り込みから戻るためにRET命令によって使用されます。進め。ストリームの主要なジョークの1つは、さらに実行される命令へのポインタです。スレッドは次に、関数に結合する命令を実行します。したがって、各スレッドには呼び出しスタックがあります。したがって、ストリームスタックが呼び出しスタックであることがわかります。つまり、このストリームの呼び出しスタックです。一般に、ソフトウェアスタック、マシンスタックなど、他の名前でも呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前回の記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
で詳しく検討しました</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、コールスタックの定義は、任意の言語の特定のメソッドの呼び出しのチェーンを示すために使用されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算スタック（評価スタック）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ご存知のように、C＃コードはILコードにコンパイルされます。これは結果のDLLの一部です（最も一般的な場合）。そして、DLLを吸収してILコードを実行するランタイムの中心にあるのがスタックマシンです。ほとんどすべてのIL命令は特定のスタックで動作します。たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ldloc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のインデックスの下のローカル変数をスタックにロードします。</font><font style="vertical-align: inherit;">ここで、スタックは特定の仮想スタックを指します。結局、この変数は高い確率でレジスターに存在する可能性があるためです。</font><font style="vertical-align: inherit;">算術、論理、およびその他のIL命令は、スタックからの変数を操作し、結果をそこに格納します。</font><font style="vertical-align: inherit;">つまり、計算はこのスタックを介して行われます。</font><font style="vertical-align: inherit;">したがって、計算スタックは実行時の抽象概念であることがわかります。</font><font style="vertical-align: inherit;">ちなみに、多くの仮想マシンはスタックベースです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃ 7 </font><font style="vertical-align: inherit;">より多くのスレッド-より高速なコード</font></font></h3> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
直感的には、並列でデータを処理する方が交互に処理するよりも高速になるようです。したがって、スレッドの操作に関する知識を備えた多くの人が、サイクルと計算を並列化しようとします。ほとんどの人はすでにスレッドの作成に寄与するオーバーヘッドについて知っているため、有名なのは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadPool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><i><font style="vertical-align: inherit;">Taskの</font></i><font style="vertical-align: inherit;">スレッドを使用することです。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。しかし、ストリームを作成するためのオーバーヘッドは終わりではありません。ここでは、リークされた別の抽象化、つまりパフォーマンスを向上させるためにプロセッサが使用するメカニズム、つまりキャッシュを扱います。そして、よくあることですが、キャッシュは両刃のブレードです。一方では、1つのストリームからのデータへの順次アクセスにより、作業が大幅にスピードアップします。しかし、その一方で、複数のスレッドが機能する場合、それらを同期する必要がなくても、キャッシュは役に立たないだけでなく、速度が低下します。キャッシュの無効化に余分な時間が費やされています。関連データの維持。そして、最初はささいなことのように思われるこの問題を過小評価しないでください。キャッシュ効率の高いアルゴリズムは、キャッシュが非効率的に使用されるマルチスレッドよりも1つのスレッドを高速に実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、多くのスレッドからのドライブで作業しようとすることは自殺です。</font><font style="vertical-align: inherit;">ディスクは、それを扱う多くのプログラムですでに抑制要因となっています。</font><font style="vertical-align: inherit;">多くのスレッドから操作しようとする場合、速度を忘れる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての定義については、こちらに連絡することをお勧めします：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C＃言語仕様</font><font style="vertical-align: inherit;">
-ECMA </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-334</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ちょうど良い情報源：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konrad Kokosa-Pro .NETメモリ管理</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CLI仕様- </font><font style="vertical-align: inherit;">
ランタイムに関する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECMA-335</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CoreCLR開発者- </font><font style="vertical-align: inherit;">
ファイナライズなどに関するStanislav Sidristyから</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のランタイムの本</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 NETプラットフォームアーキテクチャ</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja463195/index.html">Tele2インターネットはどうなりますか</a></li>
<li><a href="../ja463197/index.html">Blazor + MVVM = Silverlightが反撃し、古代の悪は無敵です</a></li>
<li><a href="../ja463203/index.html">時間の重い負担。Yandexは時間を扱う際の一般的な間違いについて報告しています</a></li>
<li><a href="../ja463205/index.html">最初は動作しない：Windows 10のラップトップと32ギガバイトのドライブで生き残る方法</a></li>
<li><a href="../ja463207/index.html">チャットボットの開発（電報+ YouTube）</a></li>
<li><a href="../ja463215/index.html">エンジニアと建築家はすでに月の集落を設計しています</a></li>
<li><a href="../ja463221/index.html">太陽を見る：5種類のガジェット、5ドルから5,000ドル</a></li>
<li><a href="../ja463223/index.html">モバイル＃310開発者向けの興味深い資料のダイジェスト（8月5〜11日）</a></li>
<li><a href="../ja463225/index.html">WiFiエンタープライズ。FreeRadius + FreeIPA + Ubiquiti</a></li>
<li><a href="../ja463227/index.html">pwnable.kr 19でジョブを解決する-リンクを解除します。ヒープバッファオーバーフロー</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>