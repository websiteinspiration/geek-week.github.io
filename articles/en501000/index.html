<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µüèø üêô ‚öñÔ∏è Code generation in Go by the example of creating a client for the database üèë üë©üèæ‚Äçüè´ ‚ö∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I would like to consider the issues of code generation in Golang. I noticed that often in the comments on articles on Go mention code...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Code generation in Go by the example of creating a client for the database</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501000/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article, I would like to consider the issues of code generation in Golang. </font><font style="vertical-align: inherit;">I noticed that often in the comments on articles on Go mention code generation and reflection, which causes heated debate. </font><font style="vertical-align: inherit;">At the same time, there are few articles on code generation on the hub, although it is used quite a lot in projects on Go. </font><font style="vertical-align: inherit;">In the article I will try to tell you what code generation is, to describe the scope of application with code examples. </font><font style="vertical-align: inherit;">Also, I will not ignore the reflection.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When code generation is used</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On Habr√© there are already good articles on the topic </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , I will not repeat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code generation should be used in cases:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Increasing the speed of the code, that is, to replace reflection;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reducing the routine of a programmer (and errors associated with it);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementation of wrappers according to the given rules.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From the examples, we can consider the Stringer library, which is included in the standard language supply and allows you to automatically generate String () methods for sets of numeric constants. </font><font style="vertical-align: inherit;">Using it, you can implement the output of variable names. </font><font style="vertical-align: inherit;">Examples of the library were described in detail in the above articles. </font><font style="vertical-align: inherit;">The most interesting example was the derivation of the color name from the palette. </font><font style="vertical-align: inherit;">The application of code generation there avoids changing the code in several places when changing the palette.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From a more practical example, we can mention the easyjson library from Mail.ru. </font><font style="vertical-align: inherit;">This library allows you to speed up the execution of masrshall / unmarshall JSON from / to the structure. </font><font style="vertical-align: inherit;">Their implementation on benchmarks bypassed all the alternatives. </font><font style="vertical-align: inherit;">To use the library, you need to call easyjson, it will generate code for all structures that it finds in the transferred file, or only for those to which the comment // easyjson: json is indicated. </font><font style="vertical-align: inherit;">Take the user structure as an example:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span>{<font></font>
    ID <span class="hljs-keyword">int</span>
    Login <span class="hljs-keyword">string</span>
    Email <span class="hljs-keyword">string</span>
    Level <span class="hljs-keyword">int</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the file in which it is contained, run the code generation:</font></font><br>
<br>
<pre><code class="bash hljs">easyjson -all main.go</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, we get methods for User:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MarshalEasyJSON (w * jwriter.Writer) - to convert the structure to a JSON byte array;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnmarshalEasyJSON (l * jlexer.Lexer) - to convert from an array of bytes into a structure. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The functions MarshalJSON () ([] byte, error) and UnmarshalJSON (data [] byte) error are necessary for compatibility with the standard json interface.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Easyjson code</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestEasyJSON</span><span class="hljs-params">()</span></span> {<font></font>
	testJSON := <span class="hljs-string">`{"ID":123, "Login":"TestUser", "Email":"user@gmail.com", "Level":12}`</span>
	JSONb := []<span class="hljs-keyword">byte</span>(testJSON)<font></font>
	fmt.Println(testJSON)<font></font>
	recvUser := &amp;User{}<font></font>
	recvUser.UnmarshalJSON(JSONb)<font></font>
	fmt.Println(recvUser)<font></font>
	recvUser.Level += <span class="hljs-number">1</span><font></font>
	outJSON, _ := recvUser.MarshalJSON()<font></font>
	fmt.Println(<span class="hljs-keyword">string</span>(outJSON))<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this function, we first convert JSON into a structure, add one level and print the resulting JSON. </font><font style="vertical-align: inherit;">Code generation by easyjson means getting rid of runtime reflection and increasing code performance.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code generation is actively used to create microservices that communicate via gRPC. It uses the protobuf format to describe the methods of services - using the intermediate language EDL. After the description of the service, the protoc compiler is launched, which generates code for the desired programming language. In the generated code, we get the interfaces that need to be implemented in the server and the methods that are used on the client to organize communication. It turns out quite conveniently, we can describe our services in a single format and generate code for the programming language in which each of the interaction elements will be described.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, code generation can be used in the development of frameworks. </font><font style="vertical-align: inherit;">For example, to implement code that is not required to be written by the application developer, but it is necessary for correct operation. </font><font style="vertical-align: inherit;">For example, to create form field validators, Middleware automatic generation, dynamic generation of clients to the DBMS.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go Code Generator Implementation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let us examine in practice how the mechanism of code generation in Go works. First of all, it is necessary to mention the AST - Abstract Syntax Tree or Abstract Syntax Tree. For details, you can go to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . For our purposes, it is necessary to understand that the entire program is built in the form of a graph, where the vertices are mapped (marked) with the operators of the programming language, and the leaves with the corresponding operands. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, for starters, we need packages: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">go / ast </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">go / parser / </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">go / token /</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Parsing the file with the code and compiling the tree is performed by the following commands</font></font><br>
<br>
<pre><code class="go hljs"><font></font>
fset := token.NewFileSet()<font></font>
node, err := parser.ParseFile(fset, os.Args[<span class="hljs-number">1</span>], <span class="hljs-literal">nil</span>, parser.ParseComments)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We indicate that the file name should be taken from the first argument of the command line, we also ask that comments be added to the tree. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, to control code generation, the user (the developer of the code on the basis of which other code is generated) can use comments or tags (as we write `json:" "` near the structure field). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For an example, we will write a code generator for working with a database. </font><font style="vertical-align: inherit;">The code generator will look at the file transferred to it, look for structures that have a corresponding comment and create a wrapper over the structure (CRUD methods) for database interaction. </font><font style="vertical-align: inherit;">We will use the parameters:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dbe comment: {"table": "users"}, in which you can define the table in which the structure records will be;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dbe tag for the fields of the structure, in which you can specify the name of the column in which to put the field value and attributes for the database: primary_key and not_null. </font><font style="vertical-align: inherit;">They will be used when creating the table. </font><font style="vertical-align: inherit;">And for the field name, you can use "-" so as not to create a column for it.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will make a reservation in advance that the project is not yet combat, it will not contain part of the necessary checks and protections. </font><font style="vertical-align: inherit;">If there is interest, I will continue its development. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we have decided on the task and parameters for controlling the generation of code, we can start writing code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Links to all code will be at the end of the article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We start bypassing the resulting tree and will parse each element of the first level. </font><font style="vertical-align: inherit;">Go has predefined types for parsing: BadDecl, GenDecl, and FuncDecl.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Type Description</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs"><span class="hljs-comment">// A BadDecl node is a placeholder for declarations containing</span>
<span class="hljs-comment">// syntax errors for which no correct declaration nodes can be</span>
<span class="hljs-comment">// created.</span>
<span class="hljs-comment">//</span>
BadDecl <span class="hljs-keyword">struct</span> {<font></font>
    From, To token.Pos <span class="hljs-comment">// position range of bad declaration</span><font></font>
}<font></font>
<span class="hljs-comment">// A GenDecl node (generic declaration node) represents an import,</span>
<span class="hljs-comment">// constant, type or variable declaration. A valid Lparen position</span>
<span class="hljs-comment">// (Lparen.IsValid()) indicates a parenthesized declaration.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Relationship between Tok value and Specs element type:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// token.IMPORT *ImportSpec</span>
<span class="hljs-comment">// token.CONST *ValueSpec</span>
<span class="hljs-comment">// token.TYPE *TypeSpec</span>
<span class="hljs-comment">// token.VAR *ValueSpec</span>
<span class="hljs-comment">//</span>
GenDecl <span class="hljs-keyword">struct</span> {<font></font>
    Doc *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span>
    TokPos token.Pos <span class="hljs-comment">// position of Tok</span>
    Tok token.Token <span class="hljs-comment">// IMPORT, CONST, TYPE, VAR</span>
    Lparen token.Pos <span class="hljs-comment">// position of '(', if any</span><font></font>
    Specs []Spec<font></font>
    Rparen token.Pos <span class="hljs-comment">// position of ')', if any</span><font></font>
}<font></font>
<span class="hljs-comment">// A FuncDecl node represents a function declaration.</span>
FuncDecl <span class="hljs-keyword">struct</span> {<font></font>
    Doc *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span>
    Recv *FieldList <span class="hljs-comment">// receiver (methods); or nil (functions)</span>
    Name *Ident <span class="hljs-comment">// function/method name</span>
    Type *FuncType <span class="hljs-comment">// function signature: parameters, results, and position of "func" keyword</span>
    Body *BlockStmt <span class="hljs-comment">// function body; or nil for external (non-Go) function</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We are interested in structures, so we use GenDecl. </font><font style="vertical-align: inherit;">At this stage, FuncDecl may be useful, in which the definitions of functions lie and you wrap them, but now we do not need them. </font><font style="vertical-align: inherit;">Next, we look at the Specs array at each node, and look for that we are working with a type definition field (* ast.TypeSpec) and this is a structure (* ast.StructType). </font><font style="vertical-align: inherit;">After we have determined that we have a structure, we check that it has a comment // dbe. </font><font style="vertical-align: inherit;">The full tree traversal code and the definition of which structure to work with are below.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tree traversal and getting structures</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> node.Decls {<font></font>
	genD, ok := f.(*ast.GenDecl)<font></font>
	<span class="hljs-keyword">if</span> !ok {<font></font>
		fmt.Printf(<span class="hljs-string">"SKIP %T is not *ast.GenDecl\n"</span>, f)
		<span class="hljs-keyword">continue</span><font></font>
	}<font></font>
	targetStruct := &amp;StructInfo{}<font></font>
	<span class="hljs-keyword">var</span> thisIsStruct <span class="hljs-keyword">bool</span>
	<span class="hljs-keyword">for</span> _, spec := <span class="hljs-keyword">range</span> genD.Specs {<font></font>
		currType, ok := spec.(*ast.TypeSpec)<font></font>
		<span class="hljs-keyword">if</span> !ok {<font></font>
			fmt.Printf(<span class="hljs-string">"SKIP %T is not ast.TypeSpec\n"</span>, spec)
			<span class="hljs-keyword">continue</span><font></font>
		}<font></font>
<font></font>
		currStruct, ok := currType.Type.(*ast.StructType)<font></font>
		<span class="hljs-keyword">if</span> !ok {<font></font>
			fmt.Printf(<span class="hljs-string">"SKIP %T is not ast.StructType\n"</span>, currStruct)
			<span class="hljs-keyword">continue</span><font></font>
		}<font></font>
		targetStruct.Name = currType.Name.Name<font></font>
		thisIsStruct = <span class="hljs-literal">true</span><font></font>
	}<font></font>
	<span class="hljs-comment">//Getting comments</span>
	<span class="hljs-keyword">var</span> needCodegen <span class="hljs-keyword">bool</span>
	<span class="hljs-keyword">var</span> dbeParams <span class="hljs-keyword">string</span>
	<span class="hljs-keyword">if</span> thisIsStruct {
		<span class="hljs-keyword">for</span> _, comment := <span class="hljs-keyword">range</span> genD.Doc.List {<font></font>
			needCodegen = needCodegen || strings.HasPrefix(comment.Text, <span class="hljs-string">"// dbe"</span>)
			<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(comment.Text) &lt; <span class="hljs-number">7</span> {<font></font>
				dbeParams = <span class="hljs-string">""</span>
			} <span class="hljs-keyword">else</span> {<font></font>
				dbeParams = strings.Replace(comment.Text, <span class="hljs-string">"// dbe:"</span>, <span class="hljs-string">""</span>, <span class="hljs-number">1</span>)<font></font>
			}<font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> needCodegen {<font></font>
		targetStruct.Target = genD<font></font>
		genParams := &amp;DbeParam{}<font></font>
		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dbeParams) != <span class="hljs-number">0</span> {<font></font>
			err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(dbeParams), genParams)
			<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
				fmt.Printf(<span class="hljs-string">"Error encoding DBE params for structure %s\n"</span>, targetStruct.Name)
				<span class="hljs-keyword">continue</span><font></font>
			}<font></font>
		} <span class="hljs-keyword">else</span> {<font></font>
			genParams.TableName = targetStruct.Name<font></font>
		}<font></font>
<font></font>
		targetStruct.GenParam = genParams<font></font>
		generateMethods(targetStruct, out)<font></font>
	}<font></font>
}</code></pre><br>
     ,  :<br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> DbeParam <span class="hljs-keyword">struct</span> {<font></font>
	TableName <span class="hljs-keyword">string</span> <span class="hljs-string">`json:"table"`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">type</span> StructInfo <span class="hljs-keyword">struct</span> {<font></font>
	Name     <span class="hljs-keyword">string</span><font></font>
	GenParam *DbeParam<font></font>
	Target   *ast.GenDecl<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we will prepare information about the fields of the structure, so that, based on the information received, we will generate table creation functions (createTable) and CRUD methods.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code for getting fields from a structure</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateMethods</span><span class="hljs-params">(reqStruct *StructInfo, out *os.File)</span></span> {
	<span class="hljs-keyword">for</span> _, spec := <span class="hljs-keyword">range</span> reqStruct.Target.Specs {<font></font>
		fmt.Fprintln(out, <span class="hljs-string">""</span>)<font></font>
		currType, ok := spec.(*ast.TypeSpec)<font></font>
		<span class="hljs-keyword">if</span> !ok {
			<span class="hljs-keyword">continue</span><font></font>
		}<font></font>
		currStruct, ok := currType.Type.(*ast.StructType)<font></font>
		<span class="hljs-keyword">if</span> !ok {
			<span class="hljs-keyword">continue</span><font></font>
		}<font></font>
<font></font>
		fmt.Printf(<span class="hljs-string">"\tgenerating createTable methods for %s\n"</span>, currType.Name.Name)<font></font>
<font></font>
		curTable := &amp;TableInfo{<font></font>
			TableName: reqStruct.GenParam.TableName,<font></font>
			Columns:   <span class="hljs-built_in">make</span>([]*ColInfo, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(currStruct.Fields.List)),<font></font>
		}<font></font>
<font></font>
		<span class="hljs-keyword">for</span> _, field := <span class="hljs-keyword">range</span> currStruct.Fields.List {
			<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(field.Names) == <span class="hljs-number">0</span> {
				<span class="hljs-keyword">continue</span><font></font>
			}<font></font>
			tableCol := &amp;ColInfo{FieldName: field.Names[<span class="hljs-number">0</span>].Name}
			<span class="hljs-keyword">var</span> fieldIsPrimKey <span class="hljs-keyword">bool</span>
			<span class="hljs-keyword">var</span> preventThisField <span class="hljs-keyword">bool</span>
			<span class="hljs-keyword">if</span> field.Tag != <span class="hljs-literal">nil</span> {<font></font>
				tag := reflect.StructTag(field.Tag.Value[<span class="hljs-number">1</span> : <span class="hljs-built_in">len</span>(field.Tag.Value)<span class="hljs-number">-1</span>])<font></font>
				tagVal := tag.Get(<span class="hljs-string">"dbe"</span>)<font></font>
				fmt.Println(<span class="hljs-string">"dbe:"</span>, tagVal)<font></font>
				tagParams := strings.Split(tagVal, <span class="hljs-string">","</span>)<font></font>
			PARAMSLOOP:<font></font>
				<span class="hljs-keyword">for</span> _, param := <span class="hljs-keyword">range</span> tagParams {
					<span class="hljs-keyword">switch</span> param {
					<span class="hljs-keyword">case</span> <span class="hljs-string">"primary_key"</span>:
						<span class="hljs-keyword">if</span> curTable.PrimaryKey == <span class="hljs-literal">nil</span> {<font></font>
							fieldIsPrimKey = <span class="hljs-literal">true</span>
							tableCol.NotNull = <span class="hljs-literal">true</span>
						} <span class="hljs-keyword">else</span> {<font></font>
							log.Panicf(<span class="hljs-string">"Table %s cannot have more then 1 primary key!"</span>, currType.Name.Name)<font></font>
						}<font></font>
					<span class="hljs-keyword">case</span> <span class="hljs-string">"not_null"</span>:<font></font>
						tableCol.NotNull = <span class="hljs-literal">true</span>
					<span class="hljs-keyword">case</span> <span class="hljs-string">"-"</span>:<font></font>
						preventThisField = <span class="hljs-literal">true</span>
						<span class="hljs-keyword">break</span> PARAMSLOOP
					<span class="hljs-keyword">default</span>:<font></font>
						tableCol.ColName = param<font></font>
					}<font></font>
<font></font>
				}<font></font>
				<span class="hljs-keyword">if</span> preventThisField {
					<span class="hljs-keyword">continue</span><font></font>
				}<font></font>
			}<font></font>
			<span class="hljs-keyword">if</span> tableCol.ColName == <span class="hljs-string">""</span> {<font></font>
				tableCol.ColName = tableCol.FieldName<font></font>
			}<font></font>
			<span class="hljs-keyword">if</span> fieldIsPrimKey {<font></font>
				curTable.PrimaryKey = tableCol<font></font>
			}<font></font>
			<span class="hljs-comment">//Determine field type</span>
			<span class="hljs-keyword">var</span> fieldType <span class="hljs-keyword">string</span>
			<span class="hljs-keyword">switch</span> field.Type.(<span class="hljs-keyword">type</span>) {
			<span class="hljs-keyword">case</span> *ast.Ident:<font></font>
				fieldType = field.Type.(*ast.Ident).Name<font></font>
			<span class="hljs-keyword">case</span> *ast.SelectorExpr:<font></font>
				fieldType = field.Type.(*ast.SelectorExpr).Sel.Name<font></font>
			}<font></font>
			<span class="hljs-comment">//fieldType := field.Type.(*ast.Ident).Name</span>
			fmt.Printf(<span class="hljs-string">"%s- %s\n"</span>, tableCol.FieldName, fieldType)
			<span class="hljs-comment">//Check for integers</span>
			<span class="hljs-keyword">if</span> strings.Contains(fieldType, <span class="hljs-string">"int"</span>) {<font></font>
				tableCol.ColType = <span class="hljs-string">"integer"</span>
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-comment">//Check for other types</span>
				<span class="hljs-keyword">switch</span> fieldType {
				<span class="hljs-keyword">case</span> <span class="hljs-string">"string"</span>:<font></font>
					tableCol.ColType = <span class="hljs-string">"text"</span>
				<span class="hljs-keyword">case</span> <span class="hljs-string">"bool"</span>:<font></font>
					tableCol.ColType = <span class="hljs-string">"boolean"</span>
				<span class="hljs-keyword">case</span> <span class="hljs-string">"Time"</span>:<font></font>
					tableCol.ColType = <span class="hljs-string">"TIMESTAMP"</span>
				<span class="hljs-keyword">default</span>:<font></font>
					log.Panicf(<span class="hljs-string">"Field type %s not supported"</span>, fieldType)<font></font>
				}<font></font>
			}<font></font>
			tableCol.FieldType = fieldType<font></font>
			curTable.Columns = <span class="hljs-built_in">append</span>(curTable.Columns, tableCol)<font></font>
			curTable.StructName = currType.Name.Name<font></font>
<font></font>
		}<font></font>
		curTable.generateCreateTable(out)<font></font>
<font></font>
		fmt.Printf(<span class="hljs-string">"\tgenerating CRUD methods for %s\n"</span>, currType.Name.Name)<font></font>
		curTable.generateCreate(out)<font></font>
		curTable.generateQuery(out)<font></font>
		curTable.generateUpdate(out)<font></font>
		curTable.generateDelete(out)<font></font>
	}<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We go through all the fields of the desired structure and begin parsing the tags of each field. Using reflection, we get the tag we are interested in (after all, there may be other tags on the field, for example, for json). We analyze the contents of the tag and determine whether the field is a primary key (if more than one primary key is specified, curse about it and stop execution), is there a requirement for the field to be non-zero, do we need to work with the database for this field and define column name if it was overridden in the tag. We also need to determine the type of the table column based on the type of the structure field. There are a finite set of field types, we will generate only for basic types, we will reduce all the rows to the TEXT field type, although in general, you can add the definition of the column type to the tags so that you can configure more finely. On the other hand,no one bothers to create the desired table in the database in advance, or to correct the created automatically.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After parsing the structure, we start the method for creating the code for the table creation function and the methods for creating the Create, Query, Update, Delete functions. </font><font style="vertical-align: inherit;">We prepare an SQL expression for each function and a binding to run. </font><font style="vertical-align: inherit;">I didn‚Äôt bother with error handling, I just give the error from the database driver. </font><font style="vertical-align: inherit;">For code generation, it is convenient to use templates from the text / template library. </font><font style="vertical-align: inherit;">With their help, you can get a much more supported and predictable code (the code is visible immediately, but not smeared by the generator code).</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table creation</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tableD *TableInfo)</span> <span class="hljs-title">generateCreateTable</span><span class="hljs-params">(out *os.File)</span> <span class="hljs-title">error</span></span> {<font></font>
	fmt.Fprint(out, <span class="hljs-string">"func (in *"</span>+tableD.StructName+<span class="hljs-string">") createTable(db *sql.DB) (error) {\n"</span>)
	<span class="hljs-keyword">var</span> resSQLq = fmt.Sprintf(<span class="hljs-string">"\tsqlQ := `CREATE TABLE %s (\n"</span>, tableD.TableName)
	<span class="hljs-keyword">for</span> _, col := <span class="hljs-keyword">range</span> tableD.Columns {<font></font>
		colSQL := col.ColName + <span class="hljs-string">" "</span> + col.ColType
		<span class="hljs-keyword">if</span> col.NotNull {<font></font>
			colSQL += <span class="hljs-string">" NOT NULL"</span><font></font>
		}<font></font>
		<span class="hljs-keyword">if</span> col == tableD.PrimaryKey {<font></font>
			colSQL += <span class="hljs-string">" AUTO_INCREMENT"</span><font></font>
		}<font></font>
		colSQL += <span class="hljs-string">",\n"</span><font></font>
		resSQLq += colSQL<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> tableD.PrimaryKey != <span class="hljs-literal">nil</span> {<font></font>
		resSQLq += fmt.Sprintf(<span class="hljs-string">"PRIMARY KEY (%s)\n"</span>, tableD.PrimaryKey.ColName)<font></font>
	}<font></font>
	resSQLq += <span class="hljs-string">")`\n"</span><font></font>
	fmt.Fprint(out, resSQLq)<font></font>
	fmt.Fprint(out, <span class="hljs-string">"\t_, err := db.Exec(sqlQ)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n"</span>)<font></font>
	fmt.Fprint(out, <span class="hljs-string">"\t return nil\n}\n\n"</span>)
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add Record</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs"><font></font>
<font></font>
	fmt.Fprint(out, <span class="hljs-string">"func (in *"</span>+tableD.StructName+<span class="hljs-string">") Create(db *sql.DB) (error) {\n"</span>)
	<span class="hljs-keyword">var</span> columns, valuePlaces, valuesListParams <span class="hljs-keyword">string</span>
	<span class="hljs-keyword">for</span> _, col := <span class="hljs-keyword">range</span> tableD.Columns {
		<span class="hljs-keyword">if</span> col == tableD.PrimaryKey {
			<span class="hljs-keyword">continue</span><font></font>
		}<font></font>
		columns += <span class="hljs-string">"`"</span> + col.ColName + <span class="hljs-string">"`,"</span>
		valuePlaces += <span class="hljs-string">"?,"</span>
		valuesListParams += <span class="hljs-string">"in."</span> + col.FieldName + <span class="hljs-string">","</span><font></font>
	}<font></font>
	columns = columns[:<span class="hljs-built_in">len</span>(columns)<span class="hljs-number">-1</span>]<font></font>
	valuePlaces = valuePlaces[:<span class="hljs-built_in">len</span>(valuePlaces)<span class="hljs-number">-1</span>]<font></font>
	valuesListParams = valuesListParams[:<span class="hljs-built_in">len</span>(valuesListParams)<span class="hljs-number">-1</span>]<font></font>
<font></font>
	resSQLq := fmt.Sprintf(<span class="hljs-string">"\tsqlQ := \"INSERT INTO %s (%s) VALUES (%s);\"\n"</span>,<font></font>
		tableD.TableName,<font></font>
		columns,<font></font>
		valuePlaces)<font></font>
	fmt.Fprintln(out, resSQLq)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"result, err := db.Exec(sqlQ, %s)\n"</span>, valuesListParams)<font></font>
	fmt.Fprintln(out, <span class="hljs-string">`if err != nil {
		return err
	}`</span>)
	<span class="hljs-comment">//Setting id if we have primary key</span>
	<span class="hljs-keyword">if</span> tableD.PrimaryKey != <span class="hljs-literal">nil</span> {<font></font>
		fmt.Fprintf(out, <span class="hljs-string">`lastId, err := result.LastInsertId()
		if err != nil {
			return nil
		}`</span>)<font></font>
		fmt.Fprintf(out, <span class="hljs-string">"\nin.%s = %s(lastId)\n"</span>, tableD.PrimaryKey.FieldName, tableD.PrimaryKey.FieldType)<font></font>
	}<font></font>
	fmt.Fprintln(out, <span class="hljs-string">"return nil\n}\n\n"</span>)
	<span class="hljs-comment">//in., _ := result.LastInsertId()`)</span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retrieving records from a table</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tableD *TableInfo)</span> <span class="hljs-title">generateQuery</span><span class="hljs-params">(out *os.File)</span> <span class="hljs-title">error</span></span> {<font></font>
	fmt.Fprint(out, <span class="hljs-string">"func (in *"</span>+tableD.StructName+<span class="hljs-string">") Query(db *sql.DB) ([]*"</span>+tableD.StructName+<span class="hljs-string">", error) {\n"</span>)<font></font>
<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"\tsqlQ := \"SELECT * FROM %s;\"\n"</span>, tableD.TableName)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"rows, err := db.Query(sqlQ)\n"</span>)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"results := make([]*%s, 0)\n"</span>, tableD.StructName)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">`for rows.Next() {`</span>)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"\t tempR := &amp;%s{}\n"</span>, tableD.StructName)
	<span class="hljs-keyword">var</span> valuesListParams <span class="hljs-keyword">string</span>
	<span class="hljs-keyword">for</span> _, col := <span class="hljs-keyword">range</span> tableD.Columns {<font></font>
		valuesListParams += <span class="hljs-string">"&amp;tempR."</span> + col.FieldName + <span class="hljs-string">","</span><font></font>
	}<font></font>
	valuesListParams = valuesListParams[:<span class="hljs-built_in">len</span>(valuesListParams)<span class="hljs-number">-1</span>]<font></font>
<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"\terr = rows.Scan(%s)\n"</span>, valuesListParams)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">`if err != nil {
		return nil, err
		}`</span>)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"\n\tresults = append(results, tempR)"</span>)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">`}
		return results, nil
	}`</span>)<font></font>
	fmt.Fprintln(out, <span class="hljs-string">""</span>)<font></font>
	fmt.Fprintln(out, <span class="hljs-string">""</span>)
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Record update (works by primary key)</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tableD *TableInfo)</span> <span class="hljs-title">generateUpdate</span><span class="hljs-params">(out *os.File)</span> <span class="hljs-title">error</span></span> {<font></font>
	fmt.Fprint(out, <span class="hljs-string">"func (in *"</span>+tableD.StructName+<span class="hljs-string">") Update(db *sql.DB) (error) {\n"</span>)
	<span class="hljs-keyword">var</span> updVals, valuesListParams <span class="hljs-keyword">string</span>
	<span class="hljs-keyword">for</span> _, col := <span class="hljs-keyword">range</span> tableD.Columns {
		<span class="hljs-keyword">if</span> col == tableD.PrimaryKey {
			<span class="hljs-keyword">continue</span><font></font>
		}<font></font>
		updVals += <span class="hljs-string">"`"</span> + col.ColName + <span class="hljs-string">"`=?,"</span>
		valuesListParams += <span class="hljs-string">"in."</span> + col.FieldName + <span class="hljs-string">","</span><font></font>
	}<font></font>
	updVals = updVals[:<span class="hljs-built_in">len</span>(updVals)<span class="hljs-number">-1</span>]<font></font>
	valuesListParams += <span class="hljs-string">"in."</span> + tableD.PrimaryKey.FieldName<font></font>
<font></font>
	resSQLq := fmt.Sprintf(<span class="hljs-string">"\tsqlQ := \"UPDATE %s SET %s WHERE %s = ?;\"\n"</span>,<font></font>
		tableD.TableName,<font></font>
		updVals,<font></font>
		tableD.PrimaryKey.ColName)<font></font>
	fmt.Fprintln(out, resSQLq)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"_, err := db.Exec(sqlQ, %s)\n"</span>, valuesListParams)<font></font>
	fmt.Fprintln(out, <span class="hljs-string">`if err != nil {
		return err
	}`</span>)<font></font>
<font></font>
	fmt.Fprintln(out, <span class="hljs-string">"return nil\n}\n\n"</span>)
	<span class="hljs-comment">//in., _ := result.LastInsertId()`)</span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delete a record (works by primary key)</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tableD *TableInfo)</span> <span class="hljs-title">generateDelete</span><span class="hljs-params">(out *os.File)</span> <span class="hljs-title">error</span></span> {<font></font>
	fmt.Fprint(out, <span class="hljs-string">"func (in *"</span>+tableD.StructName+<span class="hljs-string">") Delete(db *sql.DB) (error) {\n"</span>)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"sqlQ := \"DELETE FROM %s WHERE id = ?\"\n"</span>, tableD.TableName)<font></font>
<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"_, err := db.Exec(sqlQ, in.%s)\n"</span>, tableD.PrimaryKey.FieldName)<font></font>
<font></font>
	fmt.Fprintln(out, <span class="hljs-string">`if err != nil {
		return err
	}
	return nil
}`</span>)<font></font>
	fmt.Fprintln(out)<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The start of the resulting code generator is performed by the usual go run, we pass the path to the file for which you want to generate the code in the -name flag. </font><font style="vertical-align: inherit;">As a result, we get the file with the suffix _dbe, in which the generated code lies. </font><font style="vertical-align: inherit;">For tests, create methods for the following structure:</font></font><br>
<br>
<pre><code class="go hljs">
<span class="hljs-comment">// dbe:{"table": "users"}</span>
<span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> {<font></font>
	ID       <span class="hljs-keyword">int</span>    <span class="hljs-string">`dbe:"id,primary_key"`</span>
	Login    <span class="hljs-keyword">string</span> <span class="hljs-string">`dbe:"login,not_null"`</span>
	Email    <span class="hljs-keyword">string</span>
	Level    <span class="hljs-keyword">uint8</span>
	IsActive <span class="hljs-keyword">bool</span>
	UError   error <span class="hljs-string">`dbe:"-"`</span><font></font>
}<font></font>
</code></pre><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The resulting code</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> <span class="hljs-string">"database/sql"</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *User)</span> <span class="hljs-title">createTable</span><span class="hljs-params">(db *sql.DB)</span> <span class="hljs-title">error</span></span> {<font></font>
	sqlQ := <span class="hljs-string">`CREATE TABLE users (
	id integer NOT NULL AUTO_INCREMENT,
	login text NOT NULL,
	Email text,
	Level integer,
	IsActive boolean,
	PRIMARY KEY (id)
	)`</span><font></font>
	_, err := db.Exec(sqlQ)<font></font>
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> err<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *User)</span> <span class="hljs-title">Create</span><span class="hljs-params">(db *sql.DB)</span> <span class="hljs-title">error</span></span> {<font></font>
	sqlQ := <span class="hljs-string">"INSERT INTO users (`login`,`Email`,`Level`,`IsActive`) VALUES (?,?,?,?);"</span><font></font>
<font></font>
	result, err := db.Exec(sqlQ, in.Login, in.Email, in.Level, in.IsActive)<font></font>
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> err<font></font>
	}<font></font>
	lastId, err := result.LastInsertId()<font></font>
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
	}<font></font>
	in.ID = <span class="hljs-keyword">int</span>(lastId)
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *User)</span> <span class="hljs-title">Query</span><span class="hljs-params">(db *sql.DB)</span> <span class="hljs-params">([]*User, error)</span></span> {<font></font>
	sqlQ := <span class="hljs-string">"SELECT * FROM users;"</span><font></font>
	rows, err := db.Query(sqlQ)<font></font>
	results := <span class="hljs-built_in">make</span>([]*User, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">for</span> rows.Next() {<font></font>
		tempR := &amp;User{}<font></font>
		err = rows.Scan(&amp;tempR.ID, &amp;tempR.Login, &amp;tempR.Email, &amp;tempR.Level, &amp;tempR.IsActive)<font></font>
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<font></font>
		}<font></font>
		results = <span class="hljs-built_in">append</span>(results, tempR)<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> results, <span class="hljs-literal">nil</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *User)</span> <span class="hljs-title">Update</span><span class="hljs-params">(db *sql.DB)</span> <span class="hljs-title">error</span></span> {<font></font>
	sqlQ := <span class="hljs-string">"UPDATE users SET `login`=?,`Email`=?,`Level`=?,`IsActive`=? WHERE id = ?;"</span><font></font>
<font></font>
	_, err := db.Exec(sqlQ, in.Login, in.Email, in.Level, in.IsActive, in.ID)<font></font>
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> err<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *User)</span> <span class="hljs-title">Delete</span><span class="hljs-params">(db *sql.DB)</span> <span class="hljs-title">error</span></span> {<font></font>
	sqlQ := <span class="hljs-string">"DELETE FROM users WHERE id = ?"</span><font></font>
	_, err := db.Exec(sqlQ, in.ID)<font></font>
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> err<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To test the operation of the generated code, create an object with arbitrary data, create a table for it (if the table exists in the database, an error will be returned). </font><font style="vertical-align: inherit;">After we place this object in the table, read all the fields from the table, update the level values ‚Äã‚Äãand delete the object.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call the resulting methods</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-keyword">var</span> err error<font></font>
db, err := sql.Open(<span class="hljs-string">"mysql"</span>, DSN)
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
	fmt.Println(<span class="hljs-string">"Unable to connect to DB"</span>, err)
	<span class="hljs-keyword">return</span><font></font>
}<font></font>
err = db.Ping()<font></font>
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
	fmt.Println(<span class="hljs-string">"Unable to ping BD"</span>)
	<span class="hljs-keyword">return</span><font></font>
}<font></font>
newUser := &amp;User{<font></font>
	Login:    <span class="hljs-string">"newUser"</span>,<font></font>
	Email:    <span class="hljs-string">"new@test.com"</span>,<font></font>
	Level:    <span class="hljs-number">0</span>,<font></font>
	IsActive: <span class="hljs-literal">false</span>,<font></font>
	UError:   <span class="hljs-literal">nil</span>,<font></font>
}<font></font>
<font></font>
err = newUser.createTable(db)<font></font>
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
	fmt.Println(<span class="hljs-string">"Error creating table."</span>, err)<font></font>
<font></font>
}<font></font>
err = newUser.Create(db)<font></font>
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
	fmt.Println(<span class="hljs-string">"Error creating user."</span>, err)
	<span class="hljs-keyword">return</span><font></font>
}<font></font>
<font></font>
nU := &amp;User{}<font></font>
dbUsers, err := nU.Query(db)<font></font>
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
	fmt.Println(<span class="hljs-string">"Error selecting users."</span>, err)
	<span class="hljs-keyword">return</span><font></font>
}<font></font>
fmt.Printf(<span class="hljs-string">"From table users selected %d fields"</span>, <span class="hljs-built_in">len</span>(dbUsers))
<span class="hljs-keyword">var</span> DBUser *User
<span class="hljs-keyword">for</span> _, user := <span class="hljs-keyword">range</span> dbUsers {<font></font>
	fmt.Println(user)<font></font>
	DBUser = user<font></font>
}<font></font>
DBUser.Level = <span class="hljs-number">2</span><font></font>
err = DBUser.Update(db)<font></font>
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
	fmt.Println(<span class="hljs-string">"Error updating users."</span>, err)
	<span class="hljs-keyword">return</span><font></font>
}<font></font>
err = DBUser.Delete(db)<font></font>
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
	fmt.Println(<span class="hljs-string">"Error deleting users."</span>, err)
	<span class="hljs-keyword">return</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the current implementation, the client‚Äôs functionality to the database is very limited:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only MySQL is supported;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not all field types are supported.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there are no filtering and limits for SELECT.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, fixing bugs is already beyond the scope of parsing Go source code and generating new code based on it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using a code generator in such a scenario will allow you to change the fields and types of structures used in the application in only one place, there is no need to remember to make changes to the code for interacting with the database, you just need to run the code generator every time. </font><font style="vertical-align: inherit;">This task could be solved with the help of reflection, but this would have affected the performance. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The source code generator and an example of the generated code posted on </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en500986/index.html">Monitoring in the data center: how we changed the old BMS to a new one. Part 3</a></li>
<li><a href="../en500992/index.html">How is Performance Management in the best IT companies</a></li>
<li><a href="../en500994/index.html">Run ant. Run</a></li>
<li><a href="../en500996/index.html">How to become a DevOps engineer in six months or even faster. Part 1. Introduction</a></li>
<li><a href="../en500998/index.html">Convolutional neural network and its integration in iOS (part 1)</a></li>
<li><a href="../en501002/index.html">Umka: new statically typed scripting language</a></li>
<li><a href="../en501004/index.html">Do it. Work</a></li>
<li><a href="../en501006/index.html">We are friends STM32 with LCD display 1604 on I2C bus (HAL library)</a></li>
<li><a href="../en501008/index.html">Dominos paving</a></li>
<li><a href="../en501010/index.html">Linux Kernel TLS and Nginx</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>