<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèùÔ∏è üë¢ üëµüèΩ Complementing SQL. Part 1. The complexity of parsing. Stories about finalizing the ANTLR file üì∑ üëèüèº üêé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I publish the original article on Habr, the translation of which is posted on the Codingsight blog .
 
 What will happen in this article?
 I have been...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Complementing SQL. Part 1. The complexity of parsing. Stories about finalizing the ANTLR file</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502416/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I publish the original article on Habr, the translation of which is posted on the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codingsight</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> blog </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What will happen in this article?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I have been working in the company for more than five years, which has been developing </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IDE </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">line</font></a><font style="vertical-align: inherit;"> for working with databases. When starting work on this article, I could not imagine how many interesting stories I could remember, because when I finished I got more than 30 pages of text. After a little thought, I grouped the stories by topic, and divided the article into several. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As I publish, I will add links to the following parts: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 1. The complexity of parsing. Stories about finalizing ANTLR with a file</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Part 2. Optimization of working with strings and opening files </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Part 3. Life of extensions for Visual Studio. Work with IO. Unusual use of SQL </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Part 4. Working with exceptions, the impact of data on the development process. Using ML.NET</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A lot of interesting things happened during the work: we found several bugs in .NET, optimized some functions many times, and some only by percent, did something very cool the first time, and something we didn‚Äôt succeed even after a few attempts. </font><font style="vertical-align: inherit;">My team is developing and supporting IDE language features, the main one being code completion. </font><font style="vertical-align: inherit;">Hence the name of the series of articles. </font><font style="vertical-align: inherit;">In each of their parts I will tell several stories: some about successes, some about failures. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this part, I will focus on the problems of parsing SQL, the fight against these problems and the mistakes made in this fight.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hg/xl/vm/hgxlvmyga2eic3ul4c_i72mrxma.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For those who are interested in only part of this and just for easy navigation, the content of the article:</font></font><br>
<br>
<h3><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content</font></font></u></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Who am I?</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What are the difficulties?</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desktop development</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parsing SQL and Dialects</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Predicate wars</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cool </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bike</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solutions</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grammar Inheritance</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another post-processing ANTLR</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mistakes</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Treeless Parsing</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></a></li>
</ul><br>
<a name="Who"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Who am I?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I came to this job as a June with very little experience. </font><font style="vertical-align: inherit;">I, like many, came to programming because I wanted to make toys. </font><font style="vertical-align: inherit;">Several even quite successfully done. </font><font style="vertical-align: inherit;">I even wrote about the development of one </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Recently, by the way, he resurrected her on another server. There were still a dozen games made or abandoned at different stages of readiness. In addition to games, before getting this work, I managed to complete several projects on freelance. The largest of these was the social media application, which was a football portal with tournament tables, player data and the ability to notify users of the final score or goals scored via SMS. This was done almost 10 years ago. At that time, not everyone went with smartphones, and who used to go more often without the Internet or with the three-cursed EDGE on which to open a text site was not always possible. So the idea seemed good to me.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somehow it turned out that in addition to games, I was also drawn to create different tuning for myself or other developers. At times, he was close to what I had to do at work a little later. For example, one of the projects that I did when studying the Win32 API was a program highlighting XML code in Rich Edit Control. In addition, it was possible to upload backlit code to BMP, HTML or BB codes that were fashionable then on different forums.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another project that turned out to be damn close to what I happened to do at work was a program that analyzes C / C ++ code and builds a block diagram from it. The flowchart was in strict accordance with the requirements of one teacher at the university. It was made clumsily, in the forehead, with zero knowledge of the theory of syntactic analysis, and worked exclusively on my crappy character. A few years later, while clearing the computer of old junk, I stumbled upon it and could not remove it, so I posted it on </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the sake of history.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These experiments, coupled with freelance, gave quite a good experience and made it possible to get a job. </font><font style="vertical-align: inherit;">Over time, after a couple dozen soaked in blood and tears review I even start to benefit the company and the product. </font><font style="vertical-align: inherit;">Turning back, it‚Äôs rather funny to understand that as a result of several accidents, I began to do exactly what I was drawn to.</font></font><br>
<a name="difficulties"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What are the difficulties?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This block is needed to immerse the reader in the context of what we are actually doing.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bp/sh/st/bpshstukfseasxycc6eyk1epb3s.jpeg"><br>
<a name="desktop"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desktop development</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhaps this is not even complexity, because it is already a very mature field in which there is not much unknown, the libraries are stable, best-practice is known. </font><font style="vertical-align: inherit;">This feature of our project is here, because I, like many other programmers, is prone to novelty, and novelty is now all gone on the web. </font><font style="vertical-align: inherit;">There were days when, in the rain, I climbed onto the windowsill, covered with a blanket, with a mug of cocoa, and thought about redis, react, highload and distributed systems that are being developed somewhere without me right now. </font><font style="vertical-align: inherit;">The other side of this problem is that it‚Äôs not easy to describe the complexity of the project to the familiar beer developers, and when you work on applications that operate according to fundamentally different laws, it becomes even more difficult.</font></font><br>
<br>
<a name="dialects"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parsing SQL and Dialects</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I have also written small parsers for different languages ‚Äã‚Äãbefore this work. For some time I taught .NET courses. For some groups, as an additional task, as part of the ‚Äústring‚Äù topic, they suggested writing their own simple JSON parser. Only SQL and its variants are far from XML or JSON designed to be equally understandable to parsers and people. Moreover, SQL is syntactically more complex than C / C ++, with its many functions accumulated over a long history. SQL is structured differently, they tried to make it look like a natural language, quite successfully, by the way. The language has several thousand (depending on the dialect) keywords. Often, in order to distinguish one expression from another, you need to peek two or more words (tokens) forward. This approach is called lookahead. There is a classification of parsers according tohow far they can peer ahead: LA (1), LA (2), or LA (*), which means that the parser can look as far forward as it can take to determine the correct branch. Sometimes the optional end of one clause inside one SQL statement coincides with the beginning of another, which is also optional: such situations make parsers much more complicated. T-SQL pours water into the fire, in which the semicolon is optional, and the possible, but not mandatory end of some SQL statements may conflict with the beginning of others.such situations greatly complicate parsers. T-SQL pours water into the fire, in which the semicolon is optional, and the possible, but not mandatory end of some SQL statements may conflict with the beginning of others.such situations greatly complicate parsers. T-SQL pours water into the fire, in which the semicolon is optional, and the possible, but not mandatory end of some SQL statements may conflict with the beginning of others.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Still not believing? There is a mechanism for describing formal languages ‚Äã‚Äãthrough </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grammars</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Grammar is a code in one language that describes another. From a grammar, you can often generate a parser using a tool. The most famous grammar description tools and languages ‚Äã‚Äãare </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YACC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANTLR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . YACC generated parsers are used directly in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MySQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MariaDB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">PostgreSQL</font></a><font style="vertical-align: inherit;"> engines</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. You could try to take them directly from open source and develop code completion and other functions based on SQL analysis based on them. Moreover, such an implementation would receive free updates in terms of development, and the parser would behave guaranteed to be identical to the database engine. So why do we use ANTLR? It qualitatively supports C # /. NET, there are good tools for working with it, its syntax is much easier to read and write. The ANTLR syntax turned out to be so convenient that microsoft has recently used it in the official </font><font style="vertical-align: inherit;">C # </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let us return to my proof of the complexity of SQL, in comparison with other languages, in terms of parsing. To do this, I want to compare the grammar sizes for different languages ‚Äã‚Äãavailable publicly. In dbForge we use our own grammars, they are more complete than those available publicly, but, unfortunately, are very clogged with C # code inserts to support different functions, more about this in the section ‚ÄúParsing without trees‚Äù in the ‚ÄúErrors‚Äù section. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Below are the grammar sizes for different languages: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 475 lines parser + 273 lexer = 748 lines </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 615 lines parser + 211 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lexer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 826 lines </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C #</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 1159 lines parser + 433 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lexer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1592 lines </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 1933 lines </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MySQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 2515 lines parser + 1189 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lexer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 3704 lines </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T-SQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 4035 lines parser + 896 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lexer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 4931 lines </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL SQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 6719 lines parser + 2366 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lexer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 9085 lines </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the end of some lexers there is an enumeration of Unicode characters available in the language, this is useless in assessment of the complexity of the language. I took the number of lines before starting such transfers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There may be questions regarding the complexity of parsing a language based on the number of lines in its grammar. Questions can also be to the fullness of open grammars in comparison with the actual syntax of languages. Despite this, I still consider it useful to give these numbers, since the spread is too large.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is not all, because we need not just to parse several files into SQL. We are doing an IDE, which means we must work on incomplete or invalid scripts. Even if you write your scripts without errors, perhaps you write them inconsistently, it is unlikely that the script is valid throughout the process of its development. For example, I first write ‚ÄúSELECT FROM‚Äù, after which I will be glad to see the list of available tables. When I select a table, I will rearrange the carriage to SELECT, press the spacebar and wait for the list of columns from this particular table. This is a very simple example, but it shows that the parser providing the Code Completion in the IDE cannot crash with the exception of encountering an invalid script. We had to come up with a lot of tricks to ensure that the tooltip works correctly in many such scenarios,but users still send different scenarios for working with unfinished scripts, which means we have to come up with new tricks.</font></font><br>
<a name="predicates"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Predicate wars</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When parsing the code, sometimes there are situations when the next word does not make it clear which of the two alternatives to choose. </font><font style="vertical-align: inherit;">Sometimes it‚Äôs enough to peek at a strictly defined number of words in advance and you can definitely choose an alternative. </font><font style="vertical-align: inherit;">The mechanism for resolving this kind of inaccuracy is called the ANTLR lookahead. </font><font style="vertical-align: inherit;">The parser method in this case is constructed as an embedded chain of ifs, each of which looks one word further. </font><font style="vertical-align: inherit;">Below is an example of a grammar generating uncertainty of this kind.</font></font><br>
<br>
<pre><code class="lisp hljs">rule1:<font></font>
    'a' rule2 | rule3<font></font>
    <span class="hljs-comment">;</span><font></font>
<font></font>
rule2:<font></font>
    'b' 'c' 'd'<font></font>
    <span class="hljs-comment">;</span><font></font>
<font></font>
rule3:<font></font>
    'b' 'c' 'e'<font></font>
    <span class="hljs-comment">;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the middle of rule1, having already passed token 'a', the parser will have to look 2 token ahead to choose which rule to follow. Once again, this check will be done inside the rule. This grammar can be rewritten so that this lookahead does not exist, unfortunately the structure often suffers from such optimizations, and the performance gain is relatively not high. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
More complex mechanisms exist to resolve more complex uncertainties. One of them is the syntax predicate mechanism (synpred) in ANTLR3.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
He comes to the rescue in those cases when, for example, the optional completion of one clause intersects with the beginning of the optional other following. </font><font style="vertical-align: inherit;">The predicate, in ANTLR3 terms, is the generated method, which makes a virtual passage through the text in accordance with one of the alternatives and, if successful, returns true, this completion of the predicate is called successful. </font><font style="vertical-align: inherit;">Virtual pass is also called backtracking pass. </font><font style="vertical-align: inherit;">If the predicate worked successfully, then a real pass is made. </font><font style="vertical-align: inherit;">This becomes a problem when another predicate begins inside one predicate, then one section can be traversed a hundred and a thousand times. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider a simplified example. </font><font style="vertical-align: inherit;">There are 3 points of uncertainty (A, B, C).</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The parser enters A, remembers the position in the text, begins a virtual passage of the 1st level.</font></font></li>
<li>   B,    ,    2- .</li>
<li>   C,    ,    3- .</li>
<li>     3- ,   2    .</li>
<li>     2 ,   1   B   .</li>
<li>    ,       A, B  .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, all checks inside C will be performed 4 times, B - 3 times, A - 2 times. But what if the suitable alternative is second or third in the list? Then at some stage of one of the predicates it will fail, the position in the text will roll back and another predicate will start executing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Repeatedly analyzing the cause of the application freezing, we came across cases when the synpred ‚Äútail‚Äù was executed several thousand times. Synpreds are especially problematic in recursive rules. Unfortunately, by its nature, SQL is recursive, which is at least the ability to use a subquery almost everywhere. Sometimes with the help of various tricks and tricks it turns out to turn out the rule so that the predicate is gone.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviously, synpred has a negative effect on performance. At some stage, it was necessary to put their population under strict control. The only problem is that when writing grammar code, the appearance of synpred may not be obvious. Moreover, sometimes a change in one rule leads to the appearance of a predicate in another. This cannot be controlled manually. To control the number of predicates, we wrote a simple regular, which was called by a special MsBuild Task. If the number of predicates was different from the number specified in a separate file, then Task interrupted the assembly and reported an error. Seeing such an error, the developer had to rewrite the rule code several times, trying to get rid of unnecessary predicates, possibly involving other developers in the problem. If a predicate is inevitable,then the developer updates the number of predicates in the corresponding file. A change to this file draws extra attention to the review.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In rare cases, we even wrote our own predicates in C # to get around the ones that ANTLR generates. </font><font style="vertical-align: inherit;">Fortunately, such a mechanism also exists.</font></font><br>
<a name="bikes"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cool </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bike</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solutions</font></font></h2><br>
<img src="https://habrastorage.org/webt/r2/sr/zk/r2srzksxi_3aseqm2bv50nwjfby.jpeg"><br>
<a name="inheritance"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grammar Inheritance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the announcement of any changes in each of the DBMS we support, our work to support them begins. Almost always, the starting point for this is to support syntactic constructions in the grammar. For each SQL dialect, we write our own grammar, this generates some repetition of the code, but ultimately it is easier than looking for a common between them. Just a couple of years ago, MySQL and MariaDB were very similar, writing separate grammars was impractical. Because those few constructions that were in MariaDB, but were not in MySQL, we supported in the MySQL grammar. This was an unpleasant moment: for the MySQL user, we could suggest constructs that would not be valid. In recent years, MariaDB and MySQL have become very divergent in terms of syntax and more. It became apparentthat it‚Äôs wrong to support two different languages ‚Äã‚Äãwithin the same grammar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A possible solution could be a complete copy of the grammar, after which each is supported separately. As a result of a lengthy discussion, we made a bold decision. I am very glad that we did not copy the code, every cell in me resisted this decision. It was decided to write your own grammar preprocessor ANTLR, which implements the mechanism of grammar inheritance. Some time ago, I came across an ANTLR3 grammar in the official repository of ANTLR4 grammars. I think this sentence needs to be read several times to realize the depth of madness.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Discussing the idea of ‚Äã‚Äãinheritance, we quickly realized that we would like to have a mechanism for polymorphism. The ability in the grammar of the heir not only to redefine the rule, but also to call the base. Moreover, I want to control the position of the call of the basic rule: beginning, middle or end. We decided that all the rules can be redefined, for this you do not need to specify anything additional. In order to redefine a rule, it is enough to declare a rule with the same name in the successor grammar. After that, the rule from the parent grammar will be available under a different name.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ANTLR makes a pleasant tool for development by tuning - there is an extension for VS, there are ANTLRWorks. Introducing the inheritance mechanism, I would not want to lose this opportunity. But how then to indicate the basic grammar? You can come up with some kind of convention for naming files, but this is not at all obvious. Another option could be to indicate such additional information in a separate file, but even now, typing these lines, I felt the stink of this solution. The output was an indication of the basic grammar in the grammar of the heir in the format of an ANTLR comment. All tools will simply ignore this text, and we can easily pull out the code that interests us.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The requirements have been formed, it is time to implement them. We wrote the MsBuild Task, which was built into the general build system as a pre-build-action. Task performed the work of the ANTLR grammar preprocessor, generating the resulting grammar from the base and inherited. The resulting grammar has already been processed by ANTLR itself. If a rule with the same name as in the parent was found in the successor grammar, the basic rule was renamed: the name of the parent grammar was added to its name after the underscore. By this name he could be contacted in the heir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The preprocessor mechanism itself did not take much time, but together with the generation of the parser it turned out that it slowed down every reassembly of the project by 10-20 seconds. </font><font style="vertical-align: inherit;">At some point, this ceased to suit us. </font><font style="vertical-align: inherit;">We decided to think about how this can be optimized. </font><font style="vertical-align: inherit;">The solution was to add the hash of the sum of all the grammars on which it depends in the form of a comment to the header of the CS parser file. </font><font style="vertical-align: inherit;">Before doing anything, the preprocessor compared these hashes with the hashes of files on the disk, and if they do not differ, then the parser file was considered relevant. </font><font style="vertical-align: inherit;">At the initial development stage, we had to step on the rake of invalid parsers and grammars collected by the outdated version of the preprocessor more than once. </font><font style="vertical-align: inherit;">As a result, the hash sum of the assembly with the preprocessor appeared in the header comment.</font></font><br>
<a name="postprocessing"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another post-processing ANTLR</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In many programming languages, if the word is the key, then it can no longer be used as the name of the object. In SQL, depending on the dialect, from 800 to 3000 keywords. Most of them are closely related to the subject area, in addition, not all were introduced immediately, so a ban on using them all as object names would be met with a flurry of indignation. SQL introduces the concept of reserved and non-reserved keywords. You cannot name an object in the same way as a reserved keyword (SELECT, FROM etc) without quoting it, as it is not a reserved keyword (CONVERSATION, AVAILABILITY etc) - you can. This behavior complicates the development of the parser. At the time of the lexical analysis, the context is unknown, but the parser requires different numbers for the identifier and keyword. To solve this problem, we added one more postprocessing to the ANTLR parser.Postprocessing replaces all explicit checks with an identifier, with a call to a special method. This method implements a trickier check. If an identifier is input and an identifier is expected further, then everything is fine, but if an unreserved keyword is supplied to the input, it needs to be checked additionally. An additional check is that the method is examined in the current context in the search for branches, where this unreserved keyword can be used precisely as a keyword, and if there are no such branches, then it can be used as an identifier.but if an unreserved keyword is input, then it needs to be additionally checked. An additional check is that the method is examined in the current context in the search for branches, where this unreserved keyword can be used precisely as a keyword, and if there are no such branches, then it can be used as an identifier.but if an unreserved keyword is input, then it needs to be additionally checked. An additional check is that the method is examined in the current context in the search for branches, where this unreserved keyword can be used exactly as a keyword, and if there are no such branches, then it can be used as an identifier.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Strictly speaking, this problem can only be solved by means of ANTLR, but such a solution will not be optimal. </font><font style="vertical-align: inherit;">A classic solution to this problem is creating a rule that lists all unreserved keywords and an identifier token. </font><font style="vertical-align: inherit;">Further, wherever it is permissible to use an identifier, it is no longer used the identifier token of the identifier, but this is a special rule. </font><font style="vertical-align: inherit;">Such a solution not only makes you remember to add the keyword when you enter it, not only where it is used, but also in this special rule, it also works much more slowly.</font></font><br>
<a name="mistakes"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mistakes</font></font></h2><br>
<a name="trees"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Treeless Parsing</font></font></h3><br>
<img src="https://habrastorage.org/webt/g1/ty/qw/g1tyqwxs43omgbkeozhr5ygvxw0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The result of the parser, as a rule, is a syntax tree. </font><font style="vertical-align: inherit;">A syntax tree ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abstract</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">concrete</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) is a data structure that reflects the program text through the prism of formal grammar. </font><font style="vertical-align: inherit;">If you want to implement a code editor with autocompletion for the language that you recently came up with, having studied the issue, you are likely to implement approximately the following algorithm:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parse text in the editor. </font><font style="vertical-align: inherit;">Get the syntax tree.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Find the knot under the carriage. </font><font style="vertical-align: inherit;">Match it with grammar. </font><font style="vertical-align: inherit;">Find out what keywords and types of objects will be available at the point.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, the grammar is conveniently represented as a graph or a finite state machine.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, at the start of development, the IDE ANTLR existed in its third version. The fourth version has been rewritten from scratch and is fundamentally different from the third; by passing the code, the parser will automatically generate a parse tree without a single additional line. In the third version, there was a mechanism by which one could tell ANTLR how to build a tree, but it was not very pleasant to use it. Moreover, many examples and articles on this topic suggested using the actions mechanism to execute code at the moment the parser passes the rule. This mechanism is incredibly convenient and allows you to quickly get results. Unfortunately, this solution led to major architectural problems with the development of the product and an increase in the complexity of supporting new functionality. The fact is that in one file, in a grammar file,actions began to accumulate associated with a large number of different functionality, which would be nice to spread to different assemblies. In the future, we were able to distribute the handlers of the actions themselves for different assemblies, implementing a rather tricky version of the subscriber-notifier pattern, but the calls themselves, with the transmission of the necessary information, still clutter up our grammar, complicate the support of new functionality and impose serious and unpleasant restrictions on the architecture.complicate the support of new functionality and impose serious and unpleasant restrictions on the architecture.complicate the support of new functionality and impose serious and unpleasant restrictions on the architecture.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But everything is not as obvious as it might seem. </font><font style="vertical-align: inherit;">The fact is that ANTLR3 is much faster than ANTLR4. </font><font style="vertical-align: inherit;">According to our measurements, the differences are about 6 times. </font><font style="vertical-align: inherit;">In addition, the syntax tree for large scripts could take up a lot of RAM space, and as long as we have to survive in the 32-bit address space of Visual and SqlServer Management studios this can be critical.</font></font><br>
<a name="end"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Subtotals may be as follows:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANTLR a powerful tool for building parsers</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Its advantage over others is tools, convenient syntax, a large number of supported languages</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANTLR4 was rewritten from scratch and implies working with the parser different from the third version</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is always a way to get a little more from ThirdParty libraries than they give</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL specific language, building parsers for it is not an easy task</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parsing code for tasks related to building an IDE has its own peculiarities: you need to consider working on scripts that are not closed or invalid</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
See you in the next part!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en502406/index.html">Antiquities: A Second Approach to VHS, Hi-Fi Stereo and Soapy Video</a></li>
<li><a href="../en502408/index.html">Fakes and conspiracy theories. How not to go crazy yourself and save others?</a></li>
<li><a href="../en502410/index.html">29th successful launch of the year. USA. Military launch. "Space Plane" X-37</a></li>
<li><a href="../en502412/index.html">Guilloche in a different manner</a></li>
<li><a href="../en502414/index.html">FOSS News No. 16 - a review of free and open source software for May 11-17, 2020</a></li>
<li><a href="../en502418/index.html">3D image monitor</a></li>
<li><a href="../en502420/index.html">Interesting CSS Finds in Twitter Design</a></li>
<li><a href="../en502422/index.html">60% reduction in React Native application size in a few simple steps</a></li>
<li><a href="../en502424/index.html">Stop importing whole JavaScript packages</a></li>
<li><a href="../en502428/index.html">Syntactic Goodies Julia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>