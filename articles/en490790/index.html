<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüé§ ü§∞ üõ•Ô∏è Zip Files: History, Explanation, and Implementation üë®üèø‚Äçüíº üîê üöµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have long been wondering how data is compressed, including in Zip files. Once I decided to satisfy my curiosity: to learn how compression works, and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Zip Files: History, Explanation, and Implementation</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/490790/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bo/tw/dr/botwdrbtegpbnpnwmy7id56fbaa.jpeg"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I have long been wondering how data is compressed, including in Zip files. Once I decided to satisfy my curiosity: to learn how compression works, and write my own Zip program. Implementation has become an exciting exercise in programming. You get great pleasure from creating a debugged machine that takes data, transfers its bits to a more efficient representation, and then collects it back. I hope you will also be interested in reading about it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The article explains in great detail how Zip files and the compression scheme work: LZ77 compression, Huffman algorithm, Deflate algorithm and more. You will learn the history of the development of the technology and look at fairly effective implementation examples written from scratch in C. The source code is here: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hwzip-1.0.zip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I am very grateful to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ange Albertini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gynvael Coldwind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fabian Giesen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonas Skeppstedt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">web</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primiano Tucci,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nico Weber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , who provided valuable feedback on the drafts of this article.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Story</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PKZip</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Info-zip and zlib</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winzip</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lempel-Ziv Compression (LZ77)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman Code</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman Algorithm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman's canonical codes</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Efficient Huffman Decoding</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deflate</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit streams</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unpacking (Inflation)</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uncompressed Deflate Blocks</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deflate blocks using fixed Huffman codes</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deflate blocks using dynamic Huffman codes</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compression (Deflation)</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zip File Format</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Overview</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data structures</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">End of central directory entry</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Central file header</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Local file header</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementation of Zip Read</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zip Record Implementation</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hwzip</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembly instructions</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exercises</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Useful materials</font></font></a></li>
</ul><br>
<a name="1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Story</font></font></h2><br>
<a name="2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PKZip</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the eighties and early nineties, before the Internet became widespread, computer enthusiasts used dial-up modems to connect via the telephone network to the Bulletin Board Systems (BBS) network. </font><font style="vertical-align: inherit;">BBS was an interactive computer system that allowed users to send messages, play games and share files. </font><font style="vertical-align: inherit;">To get online, it was enough to have a computer, modem and a good BBS phone number. </font><font style="vertical-align: inherit;">Numbers </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">were published in computer magazines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and on other BBS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An important tool to facilitate the distribution of files was the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archiver</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It allows you to save one or more files in a single </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archive file</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to more conveniently store or transmit information. And ideally, the archive also compressed files to save space and time for transmission over the network. In the days of BBS, the Arc archiver was popular, written by Tom Henderson of System Enhancement Associates (SEA), a small company that he founded with his brother-in-law. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the late 1980s, programmer Phil Katz released his own version of Arc, PKArc. It was compatible with SEA Arc, but it worked faster thanks to subroutines written in assembly language and used a new compression method. The program became popular, Katz quit his job and created PKWare to focus on further development. According to legend, most of the work took place in his mother‚Äôs kitchen in Glendale, Wisconsin.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1e/50a/990/b1e50a990a86a05045dde9d2a819fbf0.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Photo by Phil Katz </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from an article in the Milwaukee Sentinel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , September 19, 1994.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
However, the SEA was not happy with Katz‚Äôs initiative. The company accused him of trademark and copyright infringement. The litigation and controversy on the BBS network and the PC world has become known as </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arc Wars</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In the end, the dispute was </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">settled</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in favor of the SEA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abandoning Arc, Katz created a new archiving format in 1989, which he called Zip and made available </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the public</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote> ,   ,        ,      .  ,  ".ZIP",             ,      ,     ,          , , ,                  ,     ,      .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Katz's program for creating such files was called PKZip and soon spread to the world of BBS and PC. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the aspects that most likely contributed to the success of the Zip format is that the documentation came with PKZip, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application Note</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which explained in detail how the format works. This allowed others to learn the format and create programs that generate, extract, or otherwise interact with Zip files. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zip - a compression format </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">without loss</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : after unpacking the data will be the same as before compression. The algorithm seeks redundancy in the source data and more efficiently presents information. This approach is different from lossy </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compression.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is used in formats such as JPEG and MP3: when compressed, some of the information that is less noticeable to the human eye or ear is thrown out. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PKZip was distributed as Shareware: it could be freely used and copied, but the author suggested users to ‚Äúregister‚Äù the program. </font><font style="vertical-align: inherit;">For $ 47, you could get printed instructions, premium support, and an enhanced version of the app.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/031/509/4fc/0315094fc6917b61db8f78b2f776ce13.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the key versions of PKZip was 2.04c, released on December 28, 1992 ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">version 2.04g</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was released shortly after </font><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">It used the default Deflate compression algorithm. </font><font style="vertical-align: inherit;">The version determined the further development of compression in Zip files ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article devoted to the release</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58e/bd3/69b/58ebd369bf36c272d0c8c7c9515fc670.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since then, the zip format has been used in many other file formats. </font><font style="vertical-align: inherit;">For example, Java archives (.jar), Android Application Packages (.apk), and Microsoft Office .docx files use the Zip format. </font><font style="vertical-align: inherit;">Many formats and protocols use the same compression algorithm, Deflate. </font><font style="vertical-align: inherit;">Say, web pages are probably transferred to your browser as a gzip file, the format of which uses Deflate compression. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Phil Katz died in 2000. </font><font style="vertical-align: inherit;">PKWare still exists and supports the Zip format, although the company focuses mainly on data protection software.</font></font><br>
<br>
<a name="3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Info-zip and zlib</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soon after the release of PKZip in 1989, other programs for unpacking Zip files began to appear. For example, an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unzip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> program </font><font style="vertical-align: inherit;">that could unpack on Unix systems. In March 1990, a mailing list called Info-ZIP was created. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Info-ZIP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> group </font><font style="vertical-align: inherit;">has released free open source programs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unzip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which were used to unpack and create zip files. The code has been ported to many systems, and it is still the standard for Zip programs for Unix systems. This later helped to increase the popularity of Zip files. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Once the Info-ZIP code that did the deflate compression and decompression was moved to a separate </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zlib</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">that they wrote</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jean-loup Gailly</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (compression) and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mark Adler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (unpacking).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68b/216/d1d/68b216d1debaffdb2d890067e38bed47.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jean-loup Gailly (left) and Mark Adler (right) at the </font><font style="vertical-align: inherit;">2009 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USENIX STUG Award</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
One of the reasons for creating the library was that it provided the convenience of using Deflate compression in other applications and formats, for example, in the new </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gzip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PNG</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . These new formats were intended to replace </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compress</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GIF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which used the patent-protected LZW algorithm. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As part of creating these formats, Peter Deutsch wrote the Deflate specification and published it under the name </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internet RFC 1951</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in May 1996. This turned out to be a more accessible description compared to the original PKZip Application Note.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Today zlib is used everywhere. </font><font style="vertical-align: inherit;">Perhaps he is now responsible for compressing this page on a web server and unpacking it in your browser. </font><font style="vertical-align: inherit;">Today, most zip files are compressed and decompressed using zlib.</font></font><br>
<br>
<a name="4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winzip</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Many of those who did not find PKZip used WinZip. PC users switched from DOS to Windows, and from PKZip to WinZip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It all started with a project by programmer Nico Mac, who created software for OS / 2 at Mansfield Software Group in Storrs-Mansfield, Connecticut. Nico used Presentation Manager, this is a graphical user interface in OS / 2, and he was upset that he had to switch from a file manager to DOS commands every time he wanted to create Zip files. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mac wrote a simple GUI program that worked with Zip files directly in Presentation Manager, named it </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PMZip,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and released it as shareware in the 1990s.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OS / 2 did not succeed, and the PC world took over Microsoft Windows. </font><font style="vertical-align: inherit;">In 1991, Mac decided to learn how to write Windows programs, and his first project was to port his Zip application to a new OS. </font><font style="vertical-align: inherit;">In April 1991, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WinZip 1.00 was released</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It was distributed as shareware with a 21-day trial period and a registration fee of $ 29. </font><font style="vertical-align: inherit;">She looked like this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b1/2f4/bcd/0b12f4bcd048691aa0487b9d3a445b39.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the first versions of WinZip, PKZip was used under the hood. </font><font style="vertical-align: inherit;">But from version 5.0 in 1993, code from Info-ZIP began to be used for direct processing of Zip files. </font><font style="vertical-align: inherit;">The user interface has also gradually evolved.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf4/273/962/bf427396212f63fba9c80db12fdd2132.png"></div><br>
<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WinZip 6.3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> under Windows 3.11 for Workgroups. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WinZip was one of the most popular shareware programs in the 1990s. </font><font style="vertical-align: inherit;">But in the end, it lost relevance due to embedding support for Zip files in operating systems. </font><font style="vertical-align: inherit;">Windows has been working with them as ‚Äúcompressed folders‚Äù since 2001 (Windows XP), the</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DynaZip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library is used for this</font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mac was originally called Nico Mak Computing. </font><font style="vertical-align: inherit;">In 2000, it was renamed WinZip Computing, and around those years Mack left it. </font><font style="vertical-align: inherit;">In 2005,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vector Capital sold the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> company</font><font style="vertical-align: inherit;">, and in the end, it became owned by</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which still releases WinZip as a product.</font></font><br>
<br>
<a name="5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lempel-Ziv Compression (LZ77)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zip compression consists of two main ingredients: Lempel-Ziv compression and Huffman code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One way to compress the text is to create a list of common words or phrases with the replacement of varieties of these words within the text with links to the dictionary. For example, the long word ‚Äúcompression‚Äù in the source text can be represented as # 1234, where 1234 refers to the position of the word in the list. This is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dictionary compression</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But from the point of view of universal compression, this method has several drawbacks. First, what exactly should get into the dictionary? The source data can be in different languages, it can even be not human-readable text. And if the dictionary is not agreed upon in advance between compression and decompression, then it will have to be stored and transferred along with the compressed data, which reduces the benefits of compression. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An elegant solution to this problem is to use the source data itself as a dictionary. In </font><font style="vertical-align: inherit;">1977, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Universal Algorithm for Sequential Data Compression</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Jacob Ziv and Abraham Lempel (who worked at Technion), proposed a compression scheme in which the source data is presented as a sequence of triplets:</font></font><br>
<br>
<pre><code class="cpp hljs">(, , )
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
where </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">they </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">form a backward link to the sequence of characters that you want to copy from the previous position in the original text, and </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is the next character in the generated data.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e5/21e/fdb/5e521efdb5649015f685e26ab308d1b9.jpg"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ce/cfa/2e3/2cecfa2e39798ce3302ff4b48e1a62ef.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abraham Lempel and Jacob Ziv. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider the following lines:</font></font><br>
<br>
<pre><code class="cpp hljs">It was the best of times,<font></font>
it was the worst of times,<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the second line, the sequence ‚Äút was the w‚Äù can be represented as (26, 10, w), since it is recreated by copying 10 characters from the position of 26 characters back to the letter ‚Äúw‚Äù. For characters that have not yet appeared, zero-length backlinks are used. For example, the initial ‚ÄúI‚Äù can be represented as (0, 0, I). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This scheme is called Lempel-Ziv compression, or LZ77 compression. However, in practical implementations of the algorithm, part of the triplet is usually not used </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Instead, characters are generated individually, and ( </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">pairs are used for backlinks </font><font style="vertical-align: inherit;">(this option is called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LZSS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compression </font><font style="vertical-align: inherit;">). How </font><font style="vertical-align: inherit;">literals and backlinks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are encoded</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a separate issue, we will consider it below when we analyze the algorithm</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Deflate</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This text:</font></font><br>
<br>
<pre><code class="cpp hljs">It was the best of times,<font></font>
it was the worst of times,<font></font>
it was the age of wisdom,<font></font>
it was the age of foolishness,<font></font>
it was the epoch of belief,<font></font>
it was the epoch of incredulity,<font></font>
it was the season of Light,<font></font>
it was the season of Darkness,<font></font>
it was the spring of hope,<font></font>
it was the winter of despair,<font></font>
we had everything before us,<font></font>
we had nothing before us,<font></font>
we were all going direct to Heaven,<font></font>
we were all going direct the other way<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can compress in this:</font></font><br>
<br>
<pre><code class="cpp hljs">It was the best of times,<font></font>
i(<span class="hljs-number">26</span>,<span class="hljs-number">10</span>)wor(<span class="hljs-number">27</span>,<span class="hljs-number">24</span>)age(<span class="hljs-number">25</span>,<span class="hljs-number">4</span>)wisdom(<span class="hljs-number">26</span>,<span class="hljs-number">20</span>)<font></font>
foolishnes(<span class="hljs-number">57</span>,<span class="hljs-number">14</span>)epoch(<span class="hljs-number">33</span>,<span class="hljs-number">4</span>)belief(<span class="hljs-number">28</span>,<span class="hljs-number">22</span>)incredulity<font></font>
(<span class="hljs-number">33</span>,<span class="hljs-number">13</span>)season(<span class="hljs-number">34</span>,<span class="hljs-number">4</span>)Light(<span class="hljs-number">28</span>,<span class="hljs-number">23</span>)Dark(<span class="hljs-number">120</span>,<span class="hljs-number">17</span>)<font></font>
spring(<span class="hljs-number">31</span>,<span class="hljs-number">4</span>)hope(<span class="hljs-number">231</span>,<span class="hljs-number">14</span>)inter(<span class="hljs-number">27</span>,<span class="hljs-number">4</span>)despair,
<span class="hljs-function">we had <span class="hljs-title">everyth</span><span class="hljs-params">(<span class="hljs-number">57</span>,<span class="hljs-number">4</span>)</span>before <span class="hljs-title">us</span><span class="hljs-params">(<span class="hljs-number">29</span>,<span class="hljs-number">9</span>)</span><span class="hljs-title">no</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">20</span>)</span>
<span class="hljs-title">we</span><span class="hljs-params">(<span class="hljs-number">12</span>,<span class="hljs-number">3</span>)</span>all <span class="hljs-title">go</span><span class="hljs-params">(<span class="hljs-number">29</span>,<span class="hljs-number">4</span>)</span>direct to <span class="hljs-title">Heaven</span>
<span class="hljs-params">(<span class="hljs-number">36</span>,<span class="hljs-number">28</span>)</span><span class="hljs-params">(<span class="hljs-number">139</span>,<span class="hljs-number">3</span>)</span><span class="hljs-params">(<span class="hljs-number">83</span>,<span class="hljs-number">3</span>)</span><span class="hljs-params">(<span class="hljs-number">138</span>,<span class="hljs-number">3</span>)</span>way
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the important properties of backlinks is that they can overlap. </font><font style="vertical-align: inherit;">This happens when the length is greater than the distance. </font><font style="vertical-align: inherit;">For instance:</font></font><br>
<br>
<pre><code class="cpp hljs">Fa-la-la-la-la
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can compress to:</font></font><br>
<br>
<pre><code class="cpp hljs">Fa-la(<span class="hljs-number">3</span>,<span class="hljs-number">9</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It may seem strange to you, but the method works: after the bytes of the first three ‚Äú-la‚Äù are copied, the copying continues using the newly generated bytes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, this is a type of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coding of series lengths</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in which part of the data is repeatedly copied to obtain the desired length. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An interactive example of using Lempel-Ziv compression for lyrics is shown in an article by Colin Morris </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Are Pop Lyrics Getting More Repetitive? </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following is an example of copying backlinks in C. Please note that due to possible overlap, we cannot use </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>memmove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output the (dist,len) backref at dst_pos in dst. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lz77_output_backref</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_pos,
                                       <span class="hljs-keyword">size_t</span> dist, <span class="hljs-keyword">size_t</span> len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        assert(dist &lt;= dst_pos &amp;&amp; <span class="hljs-string">"cannot reference before beginning of dst"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {<font></font>
                dst[dst_pos] = dst[dst_pos - dist];<font></font>
                dst_pos++;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is easy to generate literals, but for completeness we will use an auxiliary function:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output lit at dst_pos in dst. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lz77_output_lit</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_pos, <span class="hljs-keyword">uint8_t</span> lit)</span>
</span>{<font></font>
        dst[dst_pos] = lit;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note that the caller of this function must make sure that there is </font></font><code>dst</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enough space for the generated data and that the backlink does not access the position before the start of the buffer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It‚Äôs difficult not to generate data using backlinks during unpacking, but to create it first when compressing the source data. This can be done in different ways, but we will use the method based on hash tables from zlib, which is proposed in RFC 1951. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will use a hash table with the positions of three-character prefixes that were previously found in the line (shorter backlinks do not bring any benefit). Deflate allows backlinks within the previous 32,768 characters - this is called a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">window</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This provides streaming compression: the input data is processed a little at a time, provided that the window with the last bytes is stored in memory. However, our implementation assumes that all of the input data is available to us and that we can process it whole at a time. This allows you to focus on compression rather than accounting, which is necessary for stream processing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will use two arrays: in </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains the hash value of the three-character prefix for the position in the input, and in </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains the position of the previous position with this hash value. In fact, </font></font><code>head[h]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is the heading of a linked list of prefix positions with a hash </font></font><code>h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and </font></font><code>prev[x]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">receives the element preceding </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the list.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LZ_WND_SIZE 32768</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LZ_MAX_LEN  258</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HASH_SIZE 15</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NO_POS    SIZE_MAX</span><font></font>
<font></font>
<span class="hljs-comment">/* Perform LZ77 compression on the len bytes in src. Returns false as soon as
   either of the callback functions returns false, otherwise returns true when
   all bytes have been processed. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">lz77_compress</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> len,
                   <span class="hljs-keyword">bool</span> (*lit_callback)(<span class="hljs-keyword">uint8_t</span> lit, <span class="hljs-keyword">void</span> *aux),
                   <span class="hljs-keyword">bool</span> (*backref_callback)(<span class="hljs-keyword">size_t</span> dist, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">void</span> *aux),
                   <span class="hljs-keyword">void</span> *aux)</span>
</span>{
        <span class="hljs-keyword">size_t</span> head[<span class="hljs-number">1U</span> &lt;&lt; HASH_SIZE];
        <span class="hljs-keyword">size_t</span> prev[LZ_WND_SIZE];<font></font>
<font></font>
        <span class="hljs-keyword">uint16_t</span> h;
        <span class="hljs-keyword">size_t</span> i, j, dist;
        <span class="hljs-keyword">size_t</span> match_len, match_pos;
        <span class="hljs-keyword">size_t</span> prev_match_len, prev_match_pos;<font></font>
<font></font>
        <span class="hljs-comment">/* Initialize the hash table. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(head) / <span class="hljs-keyword">sizeof</span>(head[<span class="hljs-number">0</span>]); i++) {<font></font>
                head[i] = NO_POS;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To insert a new string position into the hash table </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it is updated to indicate the previous one </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and then it is updated itself </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert_hash</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> hash, <span class="hljs-keyword">size_t</span> pos, <span class="hljs-keyword">size_t</span> *head, <span class="hljs-keyword">size_t</span> *prev)</span>
</span>{<font></font>
        prev[pos % LZ_WND_SIZE] = head[hash];<font></font>
        head[hash] = pos;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pay attention to the modulo operation when indexing in </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: we are only interested in those positions that fall into the current window. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instead of calculating the hash value for each three-character prefix from scratch, we will use a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ring hash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and will constantly update it so that only the last three characters are reflected in its value:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">update_hash</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> hash, <span class="hljs-keyword">uint8_t</span> c)</span>
</span>{<font></font>
        hash &lt;&lt;= <span class="hljs-number">5</span>;                     <span class="hljs-comment">/* Shift out old bits. */</span>
        hash ^= c;                      <span class="hljs-comment">/* Include new bits. */</span>
        hash &amp;= (<span class="hljs-number">1U</span> &lt;&lt; HASH_SIZE) - <span class="hljs-number">1</span>;  <span class="hljs-comment">/* Mask off excess bits. */</span><font></font>
<font></font>
        <span class="hljs-keyword">return</span> hash;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The hash map can then be used to efficiently search for previous matches with a sequence, as shown below. </font><font style="vertical-align: inherit;">Searching for matches is the most resource-intensive compression operation, so we will limit the depth of the search in the list. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Changing various parameters, such as the depth of the search on the list of prefixes and performing lazy comparisons, as described below, is a way to increase speed by reducing the degree of compression. </font><font style="vertical-align: inherit;">The settings in our code are selected to match the maximum compression level in zlib.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Find the longest most recent string which matches the string starting
 * at src[pos]. The match must be strictly longer than prev_match_len and
 * shorter or equal to max_match_len. Returns the length of the match if found
 * and stores the match position in *match_pos, otherwise returns zero. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">find_match</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> pos, <span class="hljs-keyword">uint16_t</span> hash,
                         <span class="hljs-keyword">size_t</span> prev_match_len, <span class="hljs-keyword">size_t</span> max_match_len,
                         <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> *head, <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> *prev,
                         <span class="hljs-keyword">size_t</span> *match_pos)</span>
</span>{
        <span class="hljs-keyword">size_t</span> max_match_steps = <span class="hljs-number">4096</span>;
        <span class="hljs-keyword">size_t</span> i, l;
        <span class="hljs-keyword">bool</span> found;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (prev_match_len == <span class="hljs-number">0</span>) {
                <span class="hljs-comment">/* We want backrefs of length 3 or longer. */</span>
                prev_match_len = <span class="hljs-number">2</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (prev_match_len &gt;= max_match_len) {
                <span class="hljs-comment">/* A longer match would be too long. */</span>
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (prev_match_len &gt;= <span class="hljs-number">32</span>) {
                <span class="hljs-comment">/* Do not try too hard if there is already a good match. */</span>
                max_match_steps /= <span class="hljs-number">4</span>;<font></font>
        }<font></font>
<font></font>
        found = <span class="hljs-literal">false</span>;<font></font>
        i = head[hash];<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (max_match_steps != <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (i == NO_POS) {
                        <span class="hljs-comment">/* No match. */</span>
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
<font></font>
                assert(i &lt; pos &amp;&amp; <span class="hljs-string">"Matches should precede pos."</span>);
                <span class="hljs-keyword">if</span> (pos - i &gt; LZ_WND_SIZE) {
                        <span class="hljs-comment">/* The match is outside the window. */</span>
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
<font></font>
                l = cmp(src, i, pos, prev_match_len, max_match_len);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (l != <span class="hljs-number">0</span>) {<font></font>
                        assert(l &gt; prev_match_len);<font></font>
                        assert(l &lt;= max_match_len);<font></font>
<font></font>
                        found = <span class="hljs-literal">true</span>;<font></font>
                        *match_pos = i;<font></font>
                        prev_match_len = l;<font></font>
<font></font>
                        <span class="hljs-keyword">if</span> (l == max_match_len) {
                                <span class="hljs-comment">/* A longer match is not possible. */</span>
                                <span class="hljs-keyword">return</span> l;<font></font>
                        }<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Look further back in the prefix list. */</span><font></font>
                i = prev[i % LZ_WND_SIZE];<font></font>
                max_match_steps--;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!found) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> prev_match_len;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Compare the substrings starting at src[i] and src[j], and return the length
 * of the common prefix. The match must be strictly longer than prev_match_len
 * and shorter or equal to max_match_len. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> i, <span class="hljs-keyword">size_t</span> j,
                  <span class="hljs-keyword">size_t</span> prev_match_len, <span class="hljs-keyword">size_t</span> max_match_len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> l;<font></font>
<font></font>
        assert(prev_match_len &lt; max_match_len);<font></font>
<font></font>
        <span class="hljs-comment">/* Check whether the first prev_match_len + 1 characters match. Do this
         * backwards for a higher chance of finding a mismatch quickly. */</span>
        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>; l &lt; prev_match_len + <span class="hljs-number">1</span>; l++) {
                <span class="hljs-keyword">if</span> (src[i + prev_match_len - l] !=<font></font>
                    src[j + prev_match_len - l]) {<font></font>
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        assert(l == prev_match_len + <span class="hljs-number">1</span>);<font></font>
<font></font>
        <span class="hljs-comment">/* Now check how long the full match is. */</span>
        <span class="hljs-keyword">for</span> (; l &lt; max_match_len; l++) {
                <span class="hljs-keyword">if</span> (src[i + l] != src[j + l]) {
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        assert(l &gt; prev_match_len);<font></font>
        assert(l &lt;= max_match_len);<font></font>
        assert(<span class="hljs-built_in">memcmp</span>(&amp;src[i], &amp;src[j], l) == <span class="hljs-number">0</span>);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> l;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can terminate the function with </font></font><code>lz77_compress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this code to search for previous matches:</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-comment">/* h is the hash of the three-byte prefix starting at position i. */</span>
        h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (len &gt;= <span class="hljs-number">2</span>) {<font></font>
                h = update_hash(h, src[<span class="hljs-number">0</span>]);<font></font>
                h = update_hash(h, src[<span class="hljs-number">1</span>]);<font></font>
        }<font></font>
<font></font>
        prev_match_len = <span class="hljs-number">0</span>;<font></font>
        prev_match_pos = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i + <span class="hljs-number">2</span> &lt; len; i++) {<font></font>
                h = update_hash(h, src[i + <span class="hljs-number">2</span>]);<font></font>
<font></font>
                <span class="hljs-comment">/* Search for a match using the hash table. */</span><font></font>
                match_len = find_match(src, i, h, prev_match_len,<font></font>
                                       min(LZ_MAX_LEN, len - i), head, prev,<font></font>
                                       &amp;match_pos);<font></font>
<font></font>
                <span class="hljs-comment">/* Insert the current hash for future searches. */</span><font></font>
                insert_hash(h, i, head, prev);<font></font>
<font></font>
                <span class="hljs-comment">/* If the previous match is at least as good as the current. */</span>
                <span class="hljs-keyword">if</span> (prev_match_len != <span class="hljs-number">0</span> &amp;&amp; prev_match_len &gt;= match_len) {
                        <span class="hljs-comment">/* Output the previous match. */</span>
                        dist = (i - <span class="hljs-number">1</span>) - prev_match_pos;
                        <span class="hljs-keyword">if</span> (!backref_callback(dist, prev_match_len, aux)) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                        <span class="hljs-comment">/* Move past the match. */</span>
                        <span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; min((i - <span class="hljs-number">1</span>) + prev_match_len,<font></font>
                                                len - <span class="hljs-number">2</span>); j++) {<font></font>
                                h = update_hash(h, src[j + <span class="hljs-number">2</span>]);<font></font>
                                insert_hash(h, j, head, prev);<font></font>
                        }<font></font>
                        i = (i - <span class="hljs-number">1</span>) + prev_match_len - <span class="hljs-number">1</span>;<font></font>
                        prev_match_len = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* If no match (and no previous match), output literal. */</span>
                <span class="hljs-keyword">if</span> (match_len == <span class="hljs-number">0</span>) {<font></font>
                        assert(prev_match_len == <span class="hljs-number">0</span>);
                        <span class="hljs-keyword">if</span> (!lit_callback(src[i], aux)) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Otherwise the current match is better than the previous. */</span><font></font>
<font></font>
                <span class="hljs-keyword">if</span> (prev_match_len != <span class="hljs-number">0</span>) {
                        <span class="hljs-comment">/* Output a literal instead of the previous match. */</span>
                        <span class="hljs-keyword">if</span> (!lit_callback(src[i - <span class="hljs-number">1</span>], aux)) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Defer this match and see if the next is even better. */</span><font></font>
                prev_match_len = match_len;<font></font>
                prev_match_pos = match_pos;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Output any previous match. */</span>
        <span class="hljs-keyword">if</span> (prev_match_len != <span class="hljs-number">0</span>) {<font></font>
                dist = (i - <span class="hljs-number">1</span>) - prev_match_pos;
                <span class="hljs-keyword">if</span> (!backref_callback(dist, prev_match_len, aux)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                i = (i - <span class="hljs-number">1</span>) + prev_match_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Output any remaining literals. */</span>
        <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
                <span class="hljs-keyword">if</span> (!lit_callback(src[i], aux)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This code is looking for the longest backlink that can be generated at the current position. But before issuing it, the program decides whether it is possible to find an even longer match in the next position. In zlib, this is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lazy comparison evaluation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is still a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">greedy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algorithm: it selects the longest match, even if the current shorter one allows later to get a match even longer and achieve stronger compression. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lempel-Ziv compression can work both fast and slow. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zopfli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spent a lot of time looking for optimal backlinks to squeeze extra compression percentages. This is useful for data that is compressed once and then reused, for example, for static information on a web server. On the other side of the scale are compressors such as </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Snappy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LZ4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which are compared only with the last 4-byte prefix and are very fast. This type of compression is useful in databases and RPC systems in which the time spent on compression pays off by saving time when sending data over a network or to disk. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The idea of ‚Äã‚Äãusing source data as a dictionary is very elegant, but you can also benefit from a static dictionary. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brotli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is an LZ77 based algorithm, but it also uses a large</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static dictionary</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of string, which are often found on the network. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LZ77 code can be viewed </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in lz77.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lz77.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="6"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman Code</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second Zip compression algorithm is the Huffman code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The term </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in this context is a reference to a system for presenting data in some other form. </font><font style="vertical-align: inherit;">In this case, we are interested in code that can be used to efficiently represent literals and backlinks generated by the Lempel-Ziv algorithm. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Traditionally, English text is presented using the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">American Standard Code for Information Interchange (ASCII)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This system assigns each character a number, which is usually stored in an 8-bit representation. </font><font style="vertical-align: inherit;">Here are the ASCII codes for the uppercase letters of the English alphabet:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">01000001</font></font></td>
<td><strong>N</strong></td>
<td>01001110</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>01000010</td>
<td><strong>O</strong></td>
<td>01001111</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>01000011</td>
<td><strong>P</strong></td>
<td>01010000</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>01000100</td>
<td><strong>Q</strong></td>
<td>01010001</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>01000101</td>
<td><strong>R</strong></td>
<td>01010010</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>01000110</td>
<td><strong>S</strong></td>
<td>01010011</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>01000111</td>
<td><strong>T</strong></td>
<td>01010100</td>
</tr>
<tr>
<td><strong>H</strong></td>
<td>01001000</td>
<td><strong>U</strong></td>
<td>01010101</td>
</tr>
<tr>
<td><strong>I</strong></td>
<td>01001001</td>
<td><strong>V</strong></td>
<td>01010110</td>
</tr>
<tr>
<td><strong>J</strong></td>
<td>01001010</td>
<td><strong>W</strong></td>
<td>01010111</td>
</tr>
<tr>
<td><strong>K</strong></td>
<td>01001011</td>
<td><strong>X</strong></td>
<td>01011000</td>
</tr>
<tr>
<td><strong>L</strong></td>
<td>01001100</td>
<td><strong>Y</strong></td>
<td>01011001</td>
</tr>
<tr>
<td><strong>M</strong></td>
<td>01001101</td>
<td><strong>Z</strong></td>
<td>01011010</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One byte per character is a convenient way to store text. It allows you to easily access or modify parts of the text, and it is always clear how many bytes are required to store N characters, or how many characters are stored in N bytes. However, this is not the most effective way in terms of occupied space. For example, in English, the letter E is used most often, and Z is the least used. Therefore, in terms of volume, it is more efficient to use a shorter bit representation for E and a longer one for Z, rather than assigning the same number of bits to each character. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A code that specifies encodings of different lengths to different source characters is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a variable-length code</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The most famous example is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Morse code.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in which each character is encoded with dots and dashes, originally transmitted by telegraph with short and long pulses:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ‚Ä¢</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ‚Ä¢ ‚Ä¢ ‚Ä¢</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- - -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ‚Ä¢ - ‚Ä¢</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ - - ‚Ä¢</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ‚Ä¢ ‚Ä¢</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- - ‚Ä¢ -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ - ‚Ä¢</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ ‚Ä¢ - ‚Ä¢</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ ‚Ä¢ ‚Ä¢</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- - ‚Ä¢</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ ‚Ä¢ -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ ‚Ä¢</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ ‚Ä¢ ‚Ä¢ -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ - - -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ - -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ‚Ä¢ -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ‚Ä¢ ‚Ä¢ -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ - ‚Ä¢ ‚Ä¢</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ‚Ä¢ - -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- - ‚Ä¢ ‚Ä¢</font></font></strong></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the drawbacks of Morse code is that one codeword may be a prefix of another. For example, ‚Ä¢ ‚Ä¢ - ‚Ä¢ does not have a unique decoding: it can be F or ER. This is solved by pauses (three dots in length) between the letters during the transmission. However, it would be better if codewords could not be prefixes of other words. This code is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unrefixed</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . ASCII code of a fixed length is unrefixed because codewords are always the same length. But variable length codes can also be unrefixed. Phone numbers are often unrefixed. Before the emergency telephone number 112 was introduced in Sweden, all the numbers starting with 112 had to be changed. But in the USA there is not a single telephone number starting with 911.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To minimize the size of the encoded message, it is better to use an unrefixed code in which frequently occurring characters have shorter codewords. </font><font style="vertical-align: inherit;">The optimal code will be the one that generates the shortest possible result - the sum of the lengths of code words, multiplied by their frequency of occurrence, will be the minimum possible. </font><font style="vertical-align: inherit;">This is called a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">non-prefix code with minimal redundancy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a Huffman code</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in honor of the inventor of an efficient algorithm for generating such codes.</font></font><br>
<br>
<a name="7"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman Algorithm</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
While studying materials for writing his doctoral dissertation on electronic engineering at MIT, David Huffman attended a course on information theory taught by Robert Fano. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to legend</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Fano allowed his students to choose: write the final exam or course. Huffman chose the latter, and he was given the topic of searching for prefixless codes with minimal redundancy. It is assumed that he did not know that Fano himself was working on this task at that time (the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shannon-Fano algorithm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was the most famous method in those years </font><font style="vertical-align: inherit;">). Huffman's work was published in 1952 under the title </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Method for the Construction of Minimum-Redundancy Codes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in 1952. And since then its algorithm has been widely used.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/4fe/003/cf04fe00303a663594eea8e8db063002.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">David Huffman </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">press release</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UC Santa Cruz. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Huffman algorithm creates unrefixed code with minimal redundancy for the character set and their frequency of use. </font><font style="vertical-align: inherit;">The algorithm repeatedly selects two characters that are least likely to be found in the source data ‚Äî say, X and Y ‚Äî and replaces them with a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">composite character</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> meaning ‚ÄúX or Y‚Äù. </font><font style="vertical-align: inherit;">The frequency of occurrence of a composite symbol is the sum of the frequencies of two source symbols. </font><font style="vertical-align: inherit;">The codewords for X and Y can be any codewords that are assigned to the compound character ‚ÄúX or Y‚Äù followed by 0 or 1 to distinguish the original characters. </font><font style="vertical-align: inherit;">When the input data is reduced to one character, the algorithm stops working ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video explanation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is an example of the algorithm working on a small character set:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frequency</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First iteration of processing:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e90/a8f/4e4/e90a8f4e47c49cd14ca3a55f884d55e3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The two rarest symbols, C and D, are removed from the set and replaced by a composite symbol whose frequency is the sum of the frequencies C and D:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e9/b0b/aed/7e9b0baeda34fc4d368c933bed7e1d15.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now the rarest symbols are B and a composite symbol with a frequency of 5. They are removed from the set and replaced with a composite symbol with a frequency of 9:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bca/94b/ad6/bca94bad698775402e8bab2c6a20f664.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, A and a composite symbol with a frequency of 9 are combined into a new symbol with a frequency of 15:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/260/aa3/800/260aa38005cf701421881214915d859a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The whole set was reduced to one character, processing is complete. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The algorithm created a structure called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Huffman tree</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Input characters are leaves, and the higher the frequency of a character, the higher it is located. </font><font style="vertical-align: inherit;">Starting from the root of the tree, you can generate code words for characters by adding 0 or 1 when moving left or right, respectively. </font><font style="vertical-align: inherit;">It turns out like this:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The codeword</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No codeword is a prefix for any other. The more often a symbol occurs, the shorter its code word. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The tree can also be used for decoding: we start from the root and go right or left for the value with 0 or 1 in front of the character. For example, line 010100 is decoded in ABBA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note that the length of each codeword is equivalent to the depth of the corresponding tree node. As we will see in the next part, we do not need a real tree to assign codewords. It is enough to know the length of the words themselves. Thus, the result of our implementation of the Huffman algorithm will be the length of code words. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To store the character set and efficiently find the lowest frequencies, we will use the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">binary heap</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> data structure </font><font style="vertical-align: inherit;">. In particular, we are interested in</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min-heap</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as the minimum value should be at the top.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Swap the 32-bit values pointed to by a and b. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap32</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *a, <span class="hljs-keyword">uint32_t</span> *b)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> tmp;<font></font>
<font></font>
        tmp = *a;<font></font>
        *a = *b;<font></font>
        *b = tmp;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Move element i in the n-element heap down to restore the minheap property. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">minheap_down</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *heap, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">size_t</span> i)</span>
</span>{
        <span class="hljs-keyword">size_t</span> left, right, min;<font></font>
<font></font>
        assert(i &gt;= <span class="hljs-number">1</span> &amp;&amp; i &lt;= n &amp;&amp; <span class="hljs-string">"i must be inside the heap"</span>);<font></font>
<font></font>
        <span class="hljs-comment">/* While the ith element has at least one child. */</span>
        <span class="hljs-keyword">while</span> (i * <span class="hljs-number">2</span> &lt;= n) {<font></font>
                left = i * <span class="hljs-number">2</span>;<font></font>
                right = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<font></font>
<font></font>
                <span class="hljs-comment">/* Find the child with lowest value. */</span><font></font>
                min = left;<font></font>
                <span class="hljs-keyword">if</span> (right &lt;= n &amp;&amp; heap[right] &lt; heap[left]) {<font></font>
                        min = right;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Move i down if it is larger. */</span>
                <span class="hljs-keyword">if</span> (heap[min] &lt; heap[i]) {<font></font>
                        swap32(&amp;heap[min], &amp;heap[i]);<font></font>
                        i = min;<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Establish minheap property for heap[1..n]. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">minheap_heapify</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *heap, <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        <span class="hljs-comment">/* Floyd's algorithm. */</span>
        <span class="hljs-keyword">for</span> (i = n / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--) {<font></font>
                minheap_down(heap, n, i);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To track the frequency of </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">characters, we will use a bunch of </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elements. </font><font style="vertical-align: inherit;">Also, each time a composite symbol is created, we want to ‚Äúlink‚Äù both source symbols to it. </font><font style="vertical-align: inherit;">Therefore, each symbol will have a ‚Äúcommunication element‚Äù. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To store the </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-element heap and </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">communication elements, we will use an array of </font></font><code>n * 2 + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elements. </font><font style="vertical-align: inherit;">When two characters on the heap are replaced by one, we will use the second element to save the link to the new character. </font><font style="vertical-align: inherit;">This approach is based on the implementation of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Managing Gigabytes of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Witten, Moffat and Bell.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At each node in the heap, we will use the 16 most significant bits to store the symbol frequency, and the 16 least significant bits to store the index of the symbol communication element. Due to the use of high bits, the frequency difference will be determined by the result of a 32-bit comparison between two elements of the heap. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Because of this representation, we need to make sure that the frequency of characters always fits in 16 bits. After completion of the algorithm, the final composite symbol will have the frequency of all combined symbols, that is, this sum should be placed in 16 bits. Our Deflate implementation will verify this by simultaneously processing up to 64,535 characters. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Symbols with zero frequency will receive code words of zero length and will not participate in the compilation of the encoding.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the code word reaches the specified maximum depth, we will ‚Äúsmooth out‚Äù the frequency distribution by imposing a frequency limit and try again (yes, with the help </font></font><code>goto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). There are more sophisticated ways to do depth-limited Huffman coding, but this one is simple and efficient.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_HUFFMAN_SYMBOLS 288      <span class="hljs-comment">/* Deflate uses max 288 symbols. */</span></span><font></font>
<font></font>
<span class="hljs-comment">/* Construct a Huffman code for n symbols with the frequencies in freq, and
 * codeword length limited to max_len. The sum of the frequencies must be &lt;=
 * UINT16_MAX. max_len must be large enough that a code is always possible,
 * i.e. 2 ** max_len &gt;= n. Symbols with zero frequency are not part of the code
 * and get length zero. Outputs the codeword lengths in lengths[0..n-1]. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compute_huffman_lengths</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> *freqs, <span class="hljs-keyword">size_t</span> n,
                                    <span class="hljs-keyword">uint8_t</span> max_len, <span class="hljs-keyword">uint8_t</span> *lengths)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> nodes[MAX_HUFFMAN_SYMBOLS * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>], p, q;
        <span class="hljs-keyword">uint16_t</span> freq;
        <span class="hljs-keyword">size_t</span> i, h, l;
        <span class="hljs-keyword">uint16_t</span> freq_cap = UINT16_MAX;<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span>
        <span class="hljs-keyword">uint32_t</span> freq_sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                freq_sum += freqs[i];<font></font>
        }<font></font>
        assert(freq_sum &lt;= UINT16_MAX &amp;&amp; <span class="hljs-string">"Frequency sum too large!"</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
        assert(n &lt;= MAX_HUFFMAN_SYMBOLS);<font></font>
        assert((<span class="hljs-number">1U</span> &lt;&lt; max_len) &gt;= n &amp;&amp; <span class="hljs-string">"max_len must be large enough"</span>);<font></font>
<font></font>
try_again:<font></font>
        <span class="hljs-comment">/* Initialize the heap. h is the heap size. */</span>
        h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                freq = freqs[i];<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (freq == <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">/* Ignore zero-frequency symbols. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (freq &gt; freq_cap) {<font></font>
                        freq = freq_cap; <span class="hljs-comment">/* Enforce the frequency cap. */</span><font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* High 16 bits: Symbol frequency.
                   Low 16 bits:  Symbol link element index. */</span><font></font>
                h++;<font></font>
                nodes[h] = ((<span class="hljs-keyword">uint32_t</span>)freq &lt;&lt; <span class="hljs-number">16</span>) | (<span class="hljs-keyword">uint32_t</span>)(n + h);<font></font>
        }<font></font>
        minheap_heapify(nodes, h);<font></font>
<font></font>
        <span class="hljs-comment">/* Special case for less than two non-zero symbols. */</span>
        <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">2</span>) {
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                        lengths[i] = (freqs[i] == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Build the Huffman tree. */</span>
        <span class="hljs-keyword">while</span> (h &gt; <span class="hljs-number">1</span>) {
                <span class="hljs-comment">/* Remove the lowest frequency node p from the heap. */</span>
                p = nodes[<span class="hljs-number">1</span>];<font></font>
                nodes[<span class="hljs-number">1</span>] = nodes[h--];<font></font>
                minheap_down(nodes, h, <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-comment">/* Get q, the next lowest frequency node. */</span>
                q = nodes[<span class="hljs-number">1</span>];<font></font>
<font></font>
                <span class="hljs-comment">/* Replace q with a new symbol with the combined frequencies of
                   p and q, and with the no longer used h+1'th node as the
                   link element. */</span>
                nodes[<span class="hljs-number">1</span>] = ((p &amp; <span class="hljs-number">0xffff0000</span>) + (q &amp; <span class="hljs-number">0xffff0000</span>))<font></font>
                           | (<span class="hljs-keyword">uint32_t</span>)(h + <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-comment">/* Set the links of p and q to point to the link element of
                   the new node. */</span>
                nodes[p &amp; <span class="hljs-number">0xffff</span>] = nodes[q &amp; <span class="hljs-number">0xffff</span>] = (<span class="hljs-keyword">uint32_t</span>)(h + <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-comment">/* Move the new symbol down to restore heap property. */</span>
                minheap_down(nodes, h, <span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Compute the codeword length for each symbol. */</span>
        h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {
                <span class="hljs-keyword">if</span> (freqs[i] == <span class="hljs-number">0</span>) {<font></font>
                        lengths[i] = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
                h++;<font></font>
<font></font>
                <span class="hljs-comment">/* Link element for the i'th symbol. */</span><font></font>
                p = nodes[n + h];<font></font>
<font></font>
                <span class="hljs-comment">/* Follow the links until we hit the root (link index 2). */</span>
                l = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span> (p != <span class="hljs-number">2</span>) {<font></font>
                        l++;<font></font>
                        p = nodes[p];<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (l &gt; max_len) {
                        <span class="hljs-comment">/* Lower freq_cap to flatten the distribution. */</span>
                        assert(freq_cap != <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-string">"Cannot lower freq_cap!"</span>);<font></font>
                        freq_cap /= <span class="hljs-number">2</span>;
                        <span class="hljs-keyword">goto</span> try_again;<font></font>
                }<font></font>
<font></font>
                assert(l &lt;= UINT8_MAX);<font></font>
                lengths[i] = (<span class="hljs-keyword">uint8_t</span>)l;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An elegant alternative to the binary heap option is to store characters in two queues. </font><font style="vertical-align: inherit;">The first contains the source characters, sorted by frequency. </font><font style="vertical-align: inherit;">When a compound symbol is created, it is added secondarily. </font><font style="vertical-align: inherit;">Thus, the symbol with the lowest frequency will always be in the first position of one of the queues. </font><font style="vertical-align: inherit;">This approach is described by </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jan van Leeuwen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the Construction of Huffman Trees</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (1976). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Huffman coding is optimal for non-prefix codes, but in other cases there are more efficient methods: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arithmetic coding</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asymmetric number systems</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="8"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman's canonical codes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the example above, we built a Huffman tree:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/260/aa3/800/260aa38005cf701421881214915d859a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we go from the root and use 0 for the left branch and 1 for the right, then we get the following codes:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The codeword</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The decision to use 0 for the left branch and 1 for the right one seems arbitrary. </font><font style="vertical-align: inherit;">If we do the opposite, we get:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The codeword</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">01</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">001</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can arbitrarily mark two branches originating from a node with zero and one (the main thing is that the labels are different), and still get the equivalent code:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29b/acb/499/29bacb4999e9a3f530f22634846a97b7.png"></div><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The codeword</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eleven</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">101</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although the Huffman algorithm provides the required codeword lengths for unrefixed code with minimal redundancy, there are many ways to assign individual codewords. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Given the length of the codeword calculated by the Huffman algorithm, the canonical Huffman code assigns codewords to characters in a specific way. This is useful because it allows you to store and transmit codeword lengths with compressed data: the decoder will be able to recover codewords based on their lengths. Of course, you can store and transmit symbol frequencies and run the Huffman algorithm in the decoder, but this will require more work and more storage from the decoder. Another very important property is that the structure of canonical codes uses efficient decoding.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The idea is to assign code words to characters sequentially, under one at a time. The first code word is 0. The next will be a word with a length of the previous word + 1. The first word with a length of N is made up of the last word of length N-1, adding one (to get a new code word) and shifting one step to the left (to increase the length). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the terminology of the Hoffman tree, code words are sequentially assigned to leaves in the order from left to right, one level at a time, shifting to the left when moving to the next level.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our ABCD example, the Huffman algorithm assigned code words with lengths of 1, 2, 3, and 3. The first word is 0. This is also the last word of length 1. For length 2, we take 0 and add 1 to get the next code, which will become the prefix of two-bit codes , shift to the left and get 10. This is now the last word of length 2. To get length 3, we add 1 and shift: 110. To get the next word of length 3 we add 1: 111.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The codeword</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The implementation of the canonical code generator is shown below. </font><font style="vertical-align: inherit;">Note that the Deflate algorithm expects codewords to be generated on the basis of the LSB-first principle (first, the least significant bit). </font><font style="vertical-align: inherit;">That is, the first bit of the codeword should be stored in the least significant bit. </font><font style="vertical-align: inherit;">This means that we need to change the order of the bits, for example, using the lookup table.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_HUFFMAN_BITS 15          <span class="hljs-comment">/* Deflate uses max 15-bit codewords. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compute_canonical_code</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> *codewords, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lengths,
                                   <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint16_t</span> count[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>] = {<span class="hljs-number">0</span>};
        <span class="hljs-keyword">uint16_t</span> code[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">int</span> l;<font></font>
<font></font>
        <span class="hljs-comment">/* Count the number of codewords of each length. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                count[lengths[i]]++;<font></font>
        }<font></font>
        count[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* Ignore zero-length codes. */</span><font></font>
<font></font>
        <span class="hljs-comment">/* Compute the first codeword for each length. */</span>
        code[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">1</span>; l &lt;= MAX_HUFFMAN_BITS; l++) {<font></font>
                code[l] = (<span class="hljs-keyword">uint16_t</span>)((code[l - <span class="hljs-number">1</span>] + count[l - <span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Assign a codeword for each symbol. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                l = lengths[i];<font></font>
                <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                codewords[i] = reverse16(code[l]++, l); <span class="hljs-comment">/* Make it LSB-first. */</span><font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Reverse the n least significant bits of x.
   The (16 - n) most significant bits of the result will be zero. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">reverse16</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> x, <span class="hljs-keyword">int</span> n)</span>
</span>{
        <span class="hljs-keyword">uint16_t</span> lo, hi;
        <span class="hljs-keyword">uint16_t</span> reversed;<font></font>
<font></font>
        assert(n &gt; <span class="hljs-number">0</span>);<font></font>
        assert(n &lt;= <span class="hljs-number">16</span>);<font></font>
<font></font>
        lo = x &amp; <span class="hljs-number">0xff</span>;<font></font>
        hi = x &gt;&gt; <span class="hljs-number">8</span>;<font></font>
<font></font>
        reversed = (<span class="hljs-keyword">uint16_t</span>)((reverse8_tbl[lo] &lt;&lt; <span class="hljs-number">8</span>) | reverse8_tbl[hi]);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> reversed &gt;&gt; (<span class="hljs-number">16</span> - n);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now put it all together and write the encoder initialization code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_encoder_t</span> <span class="hljs-title">huffman_encoder_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_encoder_t</span> {</span>
        <span class="hljs-keyword">uint16_t</span> codewords[MAX_HUFFMAN_SYMBOLS]; <span class="hljs-comment">/* LSB-first codewords. */</span>
        <span class="hljs-keyword">uint8_t</span> lengths[MAX_HUFFMAN_SYMBOLS];    <span class="hljs-comment">/* Codeword lengths. */</span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize a Huffman encoder based on the n symbol frequencies. */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">huffman_encoder_init</span><span class="hljs-params">(<span class="hljs-keyword">huffman_encoder_t</span> *e, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> *freqs, <span class="hljs-keyword">size_t</span> n,
                          <span class="hljs-keyword">uint8_t</span> max_codeword_len)</span>
</span>{<font></font>
        assert(n &lt;= MAX_HUFFMAN_SYMBOLS);<font></font>
        assert(max_codeword_len &lt;= MAX_HUFFMAN_BITS);<font></font>
<font></font>
        compute_huffman_lengths(freqs, n, max_codeword_len, e-&gt;lengths);<font></font>
        compute_canonical_code(e-&gt;codewords, e-&gt;lengths, n);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We also make a function to configure the encoder using the already calculated code lengths:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Initialize a Huffman encoder based on the n codeword lengths. */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">huffman_encoder_init2</span><span class="hljs-params">(<span class="hljs-keyword">huffman_encoder_t</span> *e, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lengths,
                           <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                e-&gt;lengths[i] = lengths[i];<font></font>
        }<font></font>
        compute_canonical_code(e-&gt;codewords, e-&gt;lengths, n);<font></font>
}<font></font>
</code></pre><br>
<a name="9"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Efficient Huffman Decoding</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The easiest way to decode Huffman is to traverse the tree starting from the root, reading one bit of input at a time and deciding which branch to take next, left or right. </font><font style="vertical-align: inherit;">When a leaf node is reached, it is a decoded character. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This method is often taught in universities and books. </font><font style="vertical-align: inherit;">It is simple and elegant, but processing one bit at a time is too slow. </font><font style="vertical-align: inherit;">It is much faster to decode using the lookup table. </font><font style="vertical-align: inherit;">For the above example, in which the maximum codeword length is three bits, you can use the following table:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codeword Length</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 01</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although there are only four characters, we need a table with eight entries to cover all possible three-bit combinations. </font><font style="vertical-align: inherit;">Symbols with codewords shorter than three bits have several entries in the table. </font><font style="vertical-align: inherit;">For example, the word 10 was ‚Äúsupplemented‚Äù with </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 to cover all three-bit combinations starting with 10. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To decode in this way, you need to index in the table with the following three input bits and immediately find the corresponding character and the length of its code word. </font><font style="vertical-align: inherit;">The length is important, because despite looking at the next three bits, we need to get the same number of input bits as the length of the codeword.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The search table-based method works very quickly, but it has a drawback: the size of the table doubles with each additional bit in the length of the codeword. That is, the construction of the table slows down exponentially, and if it ceases to fit in the processor cache, then the method starts to work slowly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Because of this, the lookup table is usually used only for code words no larger than a certain length. And for longer words take a different approach. Just as Huffman coding assigns shorter codewords to more frequent characters, the use of a lookup table for short codewords is in many cases an excellent optimization. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In zlib</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">several levels of search tables are used. </font><font style="vertical-align: inherit;">If the codeword is too long for the first table, then the search will go to the secondary table to index the remaining bits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But there is another, very elegant method, based on the properties of canonical Huffman codes. </font><font style="vertical-align: inherit;">It is described in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the Implementation of Minimum Redundancy Prefix Codes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Moffat and Turpin, 1997), and is also explained in </font><font style="vertical-align: inherit;">Charles Bloom's </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Lost Huffman Paper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We take the code words from the canonical version: 0, 10, 110, 111. We will track the first code words of each length, as well as the number of each code word in the general sequence - ‚Äúsymbolic index‚Äù.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codeword Length</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First codeword</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First character index</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 (A)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 (B)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 (C)</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since code words are assigned sequentially, if we know the number of bits, we can find in the above table the symbol that these bits represent. </font><font style="vertical-align: inherit;">For example, for three-bit 111 we see that this is an offset by one from the first codeword of this length (110). </font><font style="vertical-align: inherit;">The first character index of this length is 3, and an offset of one gives us an index of 4. Another table compares the character index with the character:</font></font><br>
<br>
<pre><code class="cpp hljs">sym_idx = d-&gt;first_symbol[len] + (bits - d-&gt;first_code[len]);<font></font>
sym = d-&gt;syms[sym_idx];<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A little optimization: instead of separately storing the first character index and the first code word, we can store the first index in the table minus the first code word:</font></font><br>
<br>
<pre><code class="cpp hljs">sym_idx = d-&gt;offset_first_sym_idx[len] + bits;<font></font>
sym = d-&gt;syms[sym_idx];<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To understand how many bits need to be estimated, we again use the code sequence property. </font><font style="vertical-align: inherit;">In our example, all valid one-bit codewords are strictly less than 1, two-bit - strictly less than 11, three-bit - less than 1000 (in fact, true for all three-bit values). </font><font style="vertical-align: inherit;">In other words, the valid N-bit codeword must be strictly less than the first N-bit codeword plus the number of N-bit codewords. </font><font style="vertical-align: inherit;">Moreover, we can shift these boundaries to the left so that they are all three-bit wide. </font><font style="vertical-align: inherit;">Let's call it </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">restrictive bits</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for each of the codeword lengths:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codeword Length</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limit bits</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></td>
</tr>
</tbody></table></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The limiter for length 3 has overflowed to 4 bits, but this only means that any three-bit word will do. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can search among the three-bit input data and compare with the restrictive bits to understand how long our code word is. </font><font style="vertical-align: inherit;">After completion, we shift the input bits, only to calculate their correct number, and then find the character index:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (len = <span class="hljs-number">1</span>; len &lt;= <span class="hljs-number">3</span>; len++) {
        <span class="hljs-keyword">if</span> (bits &lt; d-&gt;sentinel_bits[len]) {<font></font>
                bits &gt;&gt;= <span class="hljs-number">3</span> - len;  <span class="hljs-comment">/* Get the len most significant bits. */</span><font></font>
                sym_idx = d-&gt;offset_first_sym_idx[len] + bits;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The time complexity of the process is linear with respect to the number of bits in the code words, but the place is spent efficiently, only downloading and comparison are required at each step, and since shorter code words are more common, the method allows optimizing compression in many situations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Full decoder code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HUFFMAN_LOOKUP_TABLE_BITS 8  <span class="hljs-comment">/* Seems a good trade-off. */</span></span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_decoder_t</span> <span class="hljs-title">huffman_decoder_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_decoder_t</span> {</span>
        <span class="hljs-comment">/* Lookup table for fast decoding of short codewords. */</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
                <span class="hljs-keyword">uint16_t</span> sym : <span class="hljs-number">9</span>;  <span class="hljs-comment">/* Wide enough to fit the max symbol nbr. */</span>
                <span class="hljs-keyword">uint16_t</span> len : <span class="hljs-number">7</span>;  <span class="hljs-comment">/* 0 means no symbol. */</span>
        } table[<span class="hljs-number">1U</span> &lt;&lt; HUFFMAN_LOOKUP_TABLE_BITS];<font></font>
<font></font>
        <span class="hljs-comment">/* "Sentinel bits" value for each codeword length. */</span>
        <span class="hljs-keyword">uint16_t</span> sentinel_bits[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-comment">/* First symbol index minus first codeword mod 2**16 for each length. */</span>
        <span class="hljs-keyword">uint16_t</span> offset_first_sym_idx[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-comment">/* Map from symbol index to symbol. */</span>
        <span class="hljs-keyword">uint16_t</span> syms[MAX_HUFFMAN_SYMBOLS];
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span>
        <span class="hljs-keyword">size_t</span> num_syms;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Get the n least significant bits of x. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">lsb</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> x, <span class="hljs-keyword">int</span> n)</span>
</span>{<font></font>
        assert(n &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt;= <span class="hljs-number">63</span>);
        <span class="hljs-keyword">return</span> x &amp; (((<span class="hljs-keyword">uint64_t</span>)<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Use the decoder d to decode a symbol from the LSB-first zero-padded bits.
 * Returns the decoded symbol number or -1 if no symbol could be decoded.
 * *num_used_bits will be set to the number of bits used to decode the symbol,
 * or zero if no symbol could be decoded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">huffman_decode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_decoder_t</span> *d, <span class="hljs-keyword">uint16_t</span> bits,
                                 <span class="hljs-keyword">size_t</span> *num_used_bits)</span>
</span>{
        <span class="hljs-keyword">uint64_t</span> lookup_bits;
        <span class="hljs-keyword">size_t</span> l;
        <span class="hljs-keyword">size_t</span> sym_idx;<font></font>
<font></font>
        <span class="hljs-comment">/* First try the lookup table. */</span><font></font>
        lookup_bits = lsb(bits, HUFFMAN_LOOKUP_TABLE_BITS);<font></font>
        assert(lookup_bits &lt; <span class="hljs-keyword">sizeof</span>(d-&gt;table) / <span class="hljs-keyword">sizeof</span>(d-&gt;table[<span class="hljs-number">0</span>]));
        <span class="hljs-keyword">if</span> (d-&gt;table[lookup_bits].len != <span class="hljs-number">0</span>) {<font></font>
                assert(d-&gt;table[lookup_bits].len &lt;= HUFFMAN_LOOKUP_TABLE_BITS);<font></font>
                assert(d-&gt;table[lookup_bits].sym &lt; d-&gt;num_syms);<font></font>
<font></font>
                *num_used_bits = d-&gt;table[lookup_bits].len;<font></font>
                <span class="hljs-keyword">return</span> d-&gt;table[lookup_bits].sym;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Then do canonical decoding with the bits in MSB-first order. */</span><font></font>
        bits = reverse16(bits, MAX_HUFFMAN_BITS);<font></font>
        <span class="hljs-keyword">for</span> (l = HUFFMAN_LOOKUP_TABLE_BITS + <span class="hljs-number">1</span>; l &lt;= MAX_HUFFMAN_BITS; l++) {
                <span class="hljs-keyword">if</span> (bits &lt; d-&gt;sentinel_bits[l]) {<font></font>
                        bits &gt;&gt;= MAX_HUFFMAN_BITS - l;<font></font>
<font></font>
                        sym_idx = (<span class="hljs-keyword">uint16_t</span>)(d-&gt;offset_first_sym_idx[l] + bits);<font></font>
                        assert(sym_idx &lt; d-&gt;num_syms);<font></font>
<font></font>
                        *num_used_bits = l;<font></font>
                        <span class="hljs-keyword">return</span> d-&gt;syms[sym_idx];<font></font>
                }<font></font>
        }<font></font>
<font></font>
        *num_used_bits = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To configure the decoder, we will pre-compute the canonical codes, as for </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">huffman_encoder_init</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and fill in different tables:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Initialize huffman decoder d for a code defined by the n codeword lengths.
   Returns false if the codeword lengths do not correspond to a valid prefix
   code. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">huffman_decoder_init</span><span class="hljs-params">(<span class="hljs-keyword">huffman_decoder_t</span> *d, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lengths,
                          <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint16_t</span> count[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>] = {<span class="hljs-number">0</span>};
        <span class="hljs-keyword">uint16_t</span> code[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">uint32_t</span> s;
        <span class="hljs-keyword">uint16_t</span> sym_idx[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">int</span> l;<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><font></font>
        assert(n &lt;= MAX_HUFFMAN_SYMBOLS);<font></font>
        d-&gt;num_syms = n;<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
        <span class="hljs-comment">/* Zero-initialize the lookup table. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(d-&gt;table) / <span class="hljs-keyword">sizeof</span>(d-&gt;table[<span class="hljs-number">0</span>]); i++) {<font></font>
                d-&gt;table[i].len = <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Count the number of codewords of each length. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                assert(lengths[i] &lt;= MAX_HUFFMAN_BITS);<font></font>
                count[lengths[i]]++;<font></font>
        }<font></font>
        count[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">/* Ignore zero-length codewords. */</span><font></font>
<font></font>
        <span class="hljs-comment">/* Compute sentinel_bits and offset_first_sym_idx for each length. */</span>
        code[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<font></font>
        sym_idx[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">1</span>; l &lt;= MAX_HUFFMAN_BITS; l++) {
                <span class="hljs-comment">/* First canonical codeword of this length. */</span>
                code[l] = (<span class="hljs-keyword">uint16_t</span>)((code[l - <span class="hljs-number">1</span>] + count[l - <span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (count[l] != <span class="hljs-number">0</span> &amp;&amp; code[l] + count[l] - <span class="hljs-number">1</span> &gt; (<span class="hljs-number">1U</span> &lt;&lt; l) - <span class="hljs-number">1</span>) {
                        <span class="hljs-comment">/* The last codeword is longer than l bits. */</span>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
<font></font>
                s = (<span class="hljs-keyword">uint32_t</span>)((code[l] + count[l]) &lt;&lt; (MAX_HUFFMAN_BITS - l));<font></font>
                d-&gt;sentinel_bits[l] = (<span class="hljs-keyword">uint16_t</span>)s;<font></font>
                assert(d-&gt;sentinel_bits[l] == s &amp;&amp; <span class="hljs-string">"No overflow."</span>);<font></font>
<font></font>
                sym_idx[l] = sym_idx[l - <span class="hljs-number">1</span>] + count[l - <span class="hljs-number">1</span>];<font></font>
                d-&gt;offset_first_sym_idx[l] = sym_idx[l] - code[l];<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Build mapping from index to symbol and populate the lookup table. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                l = lengths[i];<font></font>
                <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                d-&gt;syms[sym_idx[l]] = (<span class="hljs-keyword">uint16_t</span>)i;<font></font>
                sym_idx[l]++;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (l &lt;= HUFFMAN_LOOKUP_TABLE_BITS) {<font></font>
                        table_insert(d, i, l, code[l]);<font></font>
                        code[l]++;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">table_insert</span><span class="hljs-params">(<span class="hljs-keyword">huffman_decoder_t</span> *d, <span class="hljs-keyword">size_t</span> sym, <span class="hljs-keyword">int</span> len,
                         <span class="hljs-keyword">uint16_t</span> codeword)</span>
</span>{
        <span class="hljs-keyword">int</span> pad_len;
        <span class="hljs-keyword">uint16_t</span> padding, index;<font></font>
<font></font>
        assert(len &lt;= HUFFMAN_LOOKUP_TABLE_BITS);<font></font>
<font></font>
        codeword = reverse16(codeword, len); <span class="hljs-comment">/* Make it LSB-first. */</span><font></font>
        pad_len = HUFFMAN_LOOKUP_TABLE_BITS - len;<font></font>
<font></font>
        <span class="hljs-comment">/* Pad the pad_len upper bits with all bit combinations. */</span>
        <span class="hljs-keyword">for</span> (padding = <span class="hljs-number">0</span>; padding &lt; (<span class="hljs-number">1U</span> &lt;&lt; pad_len); padding++) {<font></font>
                index = (<span class="hljs-keyword">uint16_t</span>)(codeword | (padding &lt;&lt; len));<font></font>
                d-&gt;table[index].sym = (<span class="hljs-keyword">uint16_t</span>)sym;<font></font>
                d-&gt;table[index].len = (<span class="hljs-keyword">uint16_t</span>)len;<font></font>
<font></font>
                assert(d-&gt;table[index].sym == sym &amp;&amp; <span class="hljs-string">"Fits in bitfield."</span>);<font></font>
                assert(d-&gt;table[index].len == len &amp;&amp; <span class="hljs-string">"Fits in bitfield."</span>);<font></font>
        }<font></font>
}<font></font>
</code></pre><br>
<a name="10"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deflate</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deflate algorithm, introduced in PKZip 2.04c in 1993, is a standard compression method in modern Zip files. </font><font style="vertical-align: inherit;">It is also used in gzip, PNG and many other formats. </font><font style="vertical-align: inherit;">It uses a combination of LZ77 compression and Huffman coding, which we will discuss and implement in this section. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prior to Deflate, PKZip used Shrink, Reduce, and Implode compression methods. </font><font style="vertical-align: inherit;">Today they are rare, although after Deflate were still in use for some time, because they consumed less memory. </font><font style="vertical-align: inherit;">But we will not consider them.</font></font><br>
<br>
<a name="11"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit streams</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deflate stores Huffman codewords in a bitstream according to the LSB-first principle. This means that the first bit of the stream is stored in the least significant bit of the first byte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider a bitstream (read from left to right) 1-0-0-1-1. When it is stored according to the LSB-first principle, the byte value becomes 0b00011001 (binary) or 0x19 (hexadecimal). It may seem that the stream is simply represented backwards (in a sense, it is), but the advantage is that it is easier for us to get the first N bits from a computer word: we simply hide the N least significant bits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These procedures are taken from </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bitstream.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Input bitstream. */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">istream_t</span> <span class="hljs-title">istream_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">istream_t</span> {</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src;  <span class="hljs-comment">/* Source bytes. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *end;  <span class="hljs-comment">/* Past-the-end byte of src. */</span>
        <span class="hljs-keyword">size_t</span> bitpos;       <span class="hljs-comment">/* Position of the next bit to read. */</span>
        <span class="hljs-keyword">size_t</span> bitpos_end;   <span class="hljs-comment">/* Position of past-the-end bit. */</span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize an input stream to present the n bytes from src as an LSB-first
 * bitstream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">istream_init</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> n)</span>
</span>{<font></font>
        is-&gt;src = src;<font></font>
        is-&gt;end = src + n;<font></font>
        is-&gt;bitpos = <span class="hljs-number">0</span>;<font></font>
        is-&gt;bitpos_end = n * <span class="hljs-number">8</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our Huffman decoder needs to look at the following bits in the stream (enough bits for the longest codeword possible), and then continue the stream by the number of bits used by the decoded symbol:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ISTREAM_MIN_BITS (64 - 7)</span><font></font>
<font></font>
<span class="hljs-comment">/* Get the next bits from the input stream. The number of bits returned is
 * between ISTREAM_MIN_BITS and 64, depending on the position in the stream, or
 * fewer if the end of stream is reached. The upper bits are zero-padded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">istream_bits</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">istream_t</span> *is)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *next;
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
        next = is-&gt;src + (is-&gt;bitpos / <span class="hljs-number">8</span>);<font></font>
<font></font>
        assert(next &lt;= is-&gt;end &amp;&amp; <span class="hljs-string">"Cannot read past end of stream."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (is-&gt;end - next &gt;= <span class="hljs-number">8</span>) {
                <span class="hljs-comment">/* Common case: read 8 bytes in one go. */</span><font></font>
                bits = read64le(next);<font></font>
        } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">/* Read the available bytes and zero-pad. */</span>
                bits = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; is-&gt;end - next; i++) {<font></font>
                        bits |= (<span class="hljs-keyword">uint64_t</span>)next[i] &lt;&lt; (i * <span class="hljs-number">8</span>);<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> bits &gt;&gt; (is-&gt;bitpos % <span class="hljs-number">8</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Advance n bits in the bitstream if possible. Returns false if that many bits
 * are not available in the stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">istream_advance</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">size_t</span> n)</span> </span>{
        <span class="hljs-keyword">if</span> (is-&gt;bitpos + n &gt; is-&gt;bitpos_end) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        is-&gt;bitpos += n;<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The bottom line is that on 64-bit machines </font></font><code>istream_bits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you can usually execute as a single-boot instruction and some arithmetic, given that the structure elements </font></font><code>istream_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are in registers. </font><font style="vertical-align: inherit;">read64le is implemented in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bits.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (modern compilers convert it to a single 64-bit download using the little-endian principle):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Read a 64-bit value from p in little-endian byte order. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">read64le</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p)</span>
</span>{
        <span class="hljs-comment">/* The one true way, see
         * https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html */</span>
        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">0</span>)  |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>)  |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">24</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">32</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">5</span>] &lt;&lt; <span class="hljs-number">40</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">6</span>] &lt;&lt; <span class="hljs-number">48</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">7</span>] &lt;&lt; <span class="hljs-number">56</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We also need a function to continue the bitstream to the border of the next byte:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Round x up to the next multiple of m, which must be a power of 2. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">round_up</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> x, <span class="hljs-keyword">size_t</span> m)</span>
</span>{<font></font>
        assert((m &amp; (m - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-string">"m must be a power of two"</span>);
        <span class="hljs-keyword">return</span> (x + m - <span class="hljs-number">1</span>) &amp; (<span class="hljs-keyword">size_t</span>)(-m); <span class="hljs-comment">/* Hacker's Delight (2nd), 3-1. */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Align the input stream to the next 8-bit boundary and return a pointer to
 * that byte, which may be the past-the-end-of-stream byte. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-title">istream_byte_align</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *byte;<font></font>
<font></font>
        assert(is-&gt;bitpos &lt;= is-&gt;bitpos_end &amp;&amp; <span class="hljs-string">"Not past end of stream."</span>);<font></font>
<font></font>
        is-&gt;bitpos = round_up(is-&gt;bitpos, <span class="hljs-number">8</span>);<font></font>
        byte = is-&gt;src + is-&gt;bitpos / <span class="hljs-number">8</span>;<font></font>
        assert(byte &lt;= is-&gt;end);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> byte;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For an outgoing bitstream, we write bits using a read-modify-write process. </font><font style="vertical-align: inherit;">In the quick case, you can write a bit using a 64-bit read, some kind of bit operation and 64-bit write.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output bitstream. */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ostream_t</span> <span class="hljs-title">ostream_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ostream_t</span> {</span>
        <span class="hljs-keyword">uint8_t</span> *dst;
        <span class="hljs-keyword">uint8_t</span> *end;
        <span class="hljs-keyword">size_t</span> bitpos;
        <span class="hljs-keyword">size_t</span> bitpos_end;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize an output stream to write LSB-first bits into dst[0..n-1]. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ostream_init</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os, <span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> n)</span>
</span>{<font></font>
        os-&gt;dst = dst;<font></font>
        os-&gt;end = dst + n;<font></font>
        os-&gt;bitpos = <span class="hljs-number">0</span>;<font></font>
        os-&gt;bitpos_end = n * <span class="hljs-number">8</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Get the current bit position in the stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">ostream_bit_pos</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">ostream_t</span> *os)</span>
</span>{
        <span class="hljs-keyword">return</span> os-&gt;bitpos;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Return the number of bytes written to the output buffer. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">ostream_bytes_written</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os)</span>
</span>{
        <span class="hljs-keyword">return</span> round_up(os-&gt;bitpos, <span class="hljs-number">8</span>) / <span class="hljs-number">8</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Write n bits to the output stream. Returns false if there is not enough room
 * at the destination. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ostream_write</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os, <span class="hljs-keyword">uint64_t</span> bits, <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint64_t</span> x;
        <span class="hljs-keyword">int</span> shift, i;<font></font>
<font></font>
        assert(n &lt;= <span class="hljs-number">57</span>);<font></font>
        assert(bits &lt;= ((<span class="hljs-keyword">uint64_t</span>)<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-string">"Must fit in n bits."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (os-&gt;bitpos_end - os-&gt;bitpos &lt; n) {
                <span class="hljs-comment">/* Not enough room. */</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        p = &amp;os-&gt;dst[os-&gt;bitpos / <span class="hljs-number">8</span>];<font></font>
        shift = os-&gt;bitpos % <span class="hljs-number">8</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (os-&gt;end - p &gt;= <span class="hljs-number">8</span>) {
                <span class="hljs-comment">/* Common case: read and write 8 bytes in one go. */</span><font></font>
                x = read64le(p);<font></font>
                x = lsb(x, shift);<font></font>
                x |= bits &lt;&lt; shift;<font></font>
                write64le(p, x);<font></font>
        } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">/* Slow case: read/write as many bytes as are available. */</span>
                x = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; os-&gt;end - p; i++) {<font></font>
                        x |= (<span class="hljs-keyword">uint64_t</span>)p[i] &lt;&lt; (i * <span class="hljs-number">8</span>);<font></font>
                }<font></font>
                x = lsb(x, shift);<font></font>
                x |= bits &lt;&lt; shift;<font></font>
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; os-&gt;end - p; i++) {<font></font>
                        p[i] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; (i * <span class="hljs-number">8</span>));<font></font>
                }<font></font>
        }<font></font>
<font></font>
        os-&gt;bitpos += n;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Write a 64-bit value x to dst in little-endian byte order. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write64le</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">uint64_t</span> x)</span>
</span>{<font></font>
        dst[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">0</span>);<font></font>
        dst[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">8</span>);<font></font>
        dst[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">16</span>);<font></font>
        dst[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">24</span>);<font></font>
        dst[<span class="hljs-number">4</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">32</span>);<font></font>
        dst[<span class="hljs-number">5</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">40</span>);<font></font>
        dst[<span class="hljs-number">6</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">48</span>);<font></font>
        dst[<span class="hljs-number">7</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">56</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We also need to efficiently write bytes to the stream. </font><font style="vertical-align: inherit;">Of course, you can repeatedly execute 8-bit recordings, but it will be much faster to use </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Align the bitstream to the next byte boundary, then write the n bytes from
   src to it. Returns false if there is not enough room in the stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ostream_write_bytes_aligned</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os,
                                               <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src,
                                               <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">if</span> (os-&gt;bitpos_end - round_up(os-&gt;bitpos, <span class="hljs-number">8</span>) &lt; n * <span class="hljs-number">8</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        os-&gt;bitpos = round_up(os-&gt;bitpos, <span class="hljs-number">8</span>);
        <span class="hljs-built_in">memcpy</span>(&amp;os-&gt;dst[os-&gt;bitpos / <span class="hljs-number">8</span>], src, n);<font></font>
        os-&gt;bitpos += n * <span class="hljs-number">8</span>;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br>
<a name="12"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unpacking (Inflation)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the compression algorithm is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deflate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - blowing, extracting air from something - the unpacking process is sometimes called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inflation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If you first study this process, we will understand how the format works. </font><font style="vertical-align: inherit;">You can see the code in the first part of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deflate.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deflate.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bits.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tables.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tables.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (generated using </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generate_tables.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Data compressed using Deflate is stored as a series of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blocks.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Each block starts with a 3-bit header, in which the first (least significant) bit is set if this is the final block of the series, and the other two bits indicate its type.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/875/b36/1fd/875b361fd3414431d2a20d1ab0b6ef8b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are three types of blocks: uncompressed (0), compressed using fixed Huffman codes (1), and compressed using ‚Äúdynamic‚Äù Huffman codes (2). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This code performs unpacking using auxiliary functions for different types of blocks, which we will implement later:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> {<font></font>
        HWINF_OK,   <span class="hljs-comment">/* Inflation was successful. */</span>
        HWINF_FULL, <span class="hljs-comment">/* Not enough room in the output buffer. */</span>
        HWINF_ERR   <span class="hljs-comment">/* Error in the input data. */</span>
} <span class="hljs-keyword">inf_stat_t</span>;<font></font>
<font></font>
<span class="hljs-comment">/* Decompress (inflate) the Deflate stream in src. The number of input bytes
   used, at most src_len, is stored in *src_used on success. Output is written
   to dst. The number of bytes written, at most dst_cap, is stored in *dst_used
   on success. src[0..src_len-1] and dst[0..dst_cap-1] must not overlap.
   Returns a status value as defined above. */</span>
<span class="hljs-function"><span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">hwinflate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len, <span class="hljs-keyword">size_t</span> *src_used,
                     <span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_used)</span>
</span>{
        <span class="hljs-keyword">istream_t</span> is;
        <span class="hljs-keyword">size_t</span> dst_pos;
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">bool</span> bfinal;
        <span class="hljs-keyword">inf_stat_t</span> s;<font></font>
<font></font>
        istream_init(&amp;is, src, src_len);<font></font>
        dst_pos = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">do</span> {
                <span class="hljs-comment">/* Read the 3-bit block header. */</span><font></font>
                bits = istream_bits(&amp;is);<font></font>
                <span class="hljs-keyword">if</span> (!istream_advance(&amp;is, <span class="hljs-number">3</span>)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
                bfinal = bits &amp; <span class="hljs-number">1</span>;<font></font>
                bits &gt;&gt;= <span class="hljs-number">1</span>;<font></font>
<font></font>
                <span class="hljs-keyword">switch</span> (lsb(bits, <span class="hljs-number">2</span>)) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">/* 00: No compression. */</span><font></font>
                        s = inf_noncomp_block(&amp;is, dst, dst_cap, &amp;dst_pos);<font></font>
                        <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">/* 01: Compressed with fixed Huffman codes. */</span><font></font>
                        s = inf_fixed_block(&amp;is, dst, dst_cap, &amp;dst_pos);<font></font>
                        <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">/* 10: Compressed with "dynamic" Huffman codes. */</span><font></font>
                        s = inf_dyn_block(&amp;is, dst, dst_cap, &amp;dst_pos);<font></font>
                        <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>: <span class="hljs-comment">/* Invalid block type. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (s != HWINF_OK) {
                        <span class="hljs-keyword">return</span> s;<font></font>
                }<font></font>
        } <span class="hljs-keyword">while</span> (!bfinal);<font></font>
<font></font>
        *src_used = (<span class="hljs-keyword">size_t</span>)(istream_byte_align(&amp;is) - src);<font></font>
<font></font>
        assert(dst_pos &lt;= dst_cap);<font></font>
        *dst_used = dst_pos;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
}<font></font>
</code></pre><br>
<a name="13"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uncompressed Deflate Blocks</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These are "stored" blocks, the simplest type. </font><font style="vertical-align: inherit;">It begins with the next 8-bit boundary of the bitstream with a 16-bit word (len) denoting the length of the block. </font><font style="vertical-align: inherit;">Behind it is another 16-bit word (nlen), which complements (the order of the bits is inverted) of the words len. </font><font style="vertical-align: inherit;">It is assumed that nlen acts as a simple len checksum: if the file is damaged, then the values ‚Äã‚Äãwill probably not be complementary and the program will be able to detect an error.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e1/eb8/15b/0e1eb815b2dfec1edb50eeafd1291cc5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After len and nlen are uncompressed data. </font><font style="vertical-align: inherit;">Since the block length is a 16-bit value, the data size is limited to 65,535 bytes.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_noncomp_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst,
                                    <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_pos)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint16_t</span> len, nlen;<font></font>
<font></font>
        p = istream_byte_align(is);<font></font>
<font></font>
        <span class="hljs-comment">/* Read len and nlen (2 x 16 bits). */</span>
        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">32</span>)) {
                <span class="hljs-keyword">return</span> HWINF_ERR; <span class="hljs-comment">/* Not enough input. */</span><font></font>
        }<font></font>
        len  = read16le(p);<font></font>
        nlen = read16le(p + <span class="hljs-number">2</span>);<font></font>
        p += <span class="hljs-number">4</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (nlen != (<span class="hljs-keyword">uint16_t</span>)~len) {
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!istream_advance(is, len * <span class="hljs-number">8</span>)) {
                <span class="hljs-keyword">return</span> HWINF_ERR; <span class="hljs-comment">/* Not enough input. */</span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (dst_cap - *dst_pos &lt; len) {
                <span class="hljs-keyword">return</span> HWINF_FULL; <span class="hljs-comment">/* Not enough room to output. */</span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">memcpy</span>(&amp;dst[*dst_pos], p, len);<font></font>
        *dst_pos += len;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
}<font></font>
</code></pre><br>
<a name="14"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deflate blocks using fixed Huffman codes</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compressed Deflate blocks use Huffman code to represent a sequence of LZ77 literals. </font><font style="vertical-align: inherit;">Backlinks are broken using block end markers. </font><font style="vertical-align: inherit;">For literals, backlink lengths, and markers, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">litlen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Huffman code is </font><i><font style="vertical-align: inherit;">used</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">And for backlink distances, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> code is used </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c35/0e1/a8c/c350e1a8c73f69203949ccc534141497.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Litlen encodes values ‚Äã‚Äãin the range 0-285. </font><font style="vertical-align: inherit;">Values ‚Äã‚Äã0-255 are used for literal bytes, 256 is the end-of-block marker, and 257-285 are used for backlink lengths. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Backlinks are 3-258 bytes long. </font><font style="vertical-align: inherit;">The Litlen value determines the base length to which zero or more </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">additional bits</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are added from the stream </font><font style="vertical-align: inherit;">to get the full length according to the table below. </font><font style="vertical-align: inherit;">For example, a litlen value of 269 means a base length of 19 and two extra bits. </font><font style="vertical-align: inherit;">The addition of two bits from the stream gives the final length from 19 to 22.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Litlen</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extra bits</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lengths</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">257</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">258</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">259</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">260</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">261</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">262</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">263</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">264</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">265</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11-12</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">266</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13-14</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">267</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15-16</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">268</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17-18</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">269</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19-22</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">270</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23‚Äì26</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">271</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">27-30</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">272</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">31‚Äì34</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">273</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">35‚Äì42</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">274</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">43-50</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">275</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">51‚Äì58</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">276</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59‚Äì66</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">277</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67‚Äì82</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">278</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">83‚Äì98</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">279</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">99‚Äì114</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">280</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">115‚Äì130</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">281</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">131‚Äì162</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">282</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">163‚Äì194</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">283</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">195‚Äì226</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">284</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">227‚Äì257</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">285</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">258</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Please note that a litlen value of 284 plus 5 extra bits can represent lengths from 227 to 258, however, the specification states that length 258 - the maximum length of the backlink - must be represented using a separate litlen value. </font><font style="vertical-align: inherit;">This is supposed to reduce coding in situations where the maximum length is often encountered. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The decompressor uses the table to get the base length and additional bits from the litlen value (minus 257):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Table of litlen symbol values minus 257 with corresponding base length
   and number of extra bits. */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">litlen_tbl_t</span> {</span>
        <span class="hljs-keyword">uint16_t</span> base_len : <span class="hljs-number">9</span>;
        <span class="hljs-keyword">uint16_t</span> ebits : <span class="hljs-number">7</span>;<font></font>
};<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">litlen_tbl_t</span> <span class="hljs-title">litlen_tbl</span>[29] = {</span>
<span class="hljs-comment">/* 257 */</span> { <span class="hljs-number">3</span>, <span class="hljs-number">0</span> },
<span class="hljs-comment">/* 258 */</span> { <span class="hljs-number">4</span>, <span class="hljs-number">0</span> },<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/* 284 */</span> { <span class="hljs-number">227</span>, <span class="hljs-number">5</span> },
<span class="hljs-comment">/* 285 */</span> { <span class="hljs-number">258</span>, <span class="hljs-number">0</span> }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Huffman's fixed litlen code is canonical and uses the following codeword lengths (286‚Äì287 are not valid litlen values, but they are involved in code generation):</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Litlen values</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codeword Length</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0‚Äì143</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">144‚Äì255</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">256‚Äì279</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">280‚Äì287</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The decompressor stores these lengths in a table convenient for transmission to </font></font><code>huffman_decoder_init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> fixed_litlen_lengths[<span class="hljs-number">288</span>] = {
<span class="hljs-comment">/*   0 */</span> <span class="hljs-number">8</span>,
<span class="hljs-comment">/*   1 */</span> <span class="hljs-number">8</span>,<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/* 287 */</span> <span class="hljs-number">8</span>,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Backlink distances vary from 1 to 32,768. They are encoded using a scheme that is similar to a length coding scheme. </font><font style="vertical-align: inherit;">The Huffman code dist encodes values ‚Äã‚Äãfrom 0 to 29, each of which corresponds to the base length, to which additional bits are added to obtain the final distance:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dist</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extra bits</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distances</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5-6</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7-8</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9-12</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13‚Äì16</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17-24</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25‚Äì32</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">33‚Äì48</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eleven</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">49‚Äì64</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65‚Äì96</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thirteen</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">97‚Äì128</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">129‚Äì192</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fifteen</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">193‚Äì256</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sixteen</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">257‚Äì384</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">385-512</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eighteen</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">513-768</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nineteen</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">769-1024</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">twenty</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1025-1536</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1537‚Äì2048</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2049-3072</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3073‚Äì4096</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eleven</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4097-6144</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eleven</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6145‚Äì8192</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8193‚Äì12288</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">27</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12289‚Äì16384</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thirteen</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16385‚Äì24576</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">29th</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thirteen</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24577‚Äì32768</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Huffman's fixed code dist is canonical. </font><font style="vertical-align: inherit;">All codewords are 5 bits long. </font><font style="vertical-align: inherit;">It is simple, the decompressor stores the codes in a table that can be used with </font></font><code>huffman_decoder_init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dist values ‚Äã‚Äã30‚Äì31 are not correct. It is indicated that they are involved in the generation of Huffman codes, but actually have no effect):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> fixed_dist_lengths[<span class="hljs-number">32</span>] = {
<span class="hljs-comment">/*  0 */</span> <span class="hljs-number">5</span>,
<span class="hljs-comment">/*  1 */</span> <span class="hljs-number">5</span>,<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/* 31 */</span> <span class="hljs-number">5</span>,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decompression or Unpacking Code - Deflate block using fixed Huffman codes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_fixed_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst,
                                  <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_pos)</span>
</span>{
        <span class="hljs-keyword">huffman_decoder_t</span> litlen_dec, dist_dec;<font></font>
<font></font>
        huffman_decoder_init(&amp;litlen_dec, fixed_litlen_lengths,<font></font>
                             <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths) /
                             <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths[<span class="hljs-number">0</span>]));<font></font>
        huffman_decoder_init(&amp;dist_dec, fixed_dist_lengths,<font></font>
                             <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths) /
                             <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths[<span class="hljs-number">0</span>]));<font></font>
<font></font>
        <span class="hljs-keyword">return</span> inf_block(is, dst, dst_cap, dst_pos, &amp;litlen_dec, &amp;dist_dec);<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LITLEN_EOB 256</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LITLEN_MAX 285</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LITLEN_TBL_OFFSET 257</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LEN 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_LEN 258</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DISTSYM_MAX 29</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_DISTANCE 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_DISTANCE 32768</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_cap,
                            <span class="hljs-keyword">size_t</span> *dst_pos,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_decoder_t</span> *litlen_dec,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_decoder_t</span> *dist_dec)</span>
</span>{
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">size_t</span> used, used_tot, dist, len;
        <span class="hljs-keyword">int</span> litlen, distsym;
        <span class="hljs-keyword">uint16_t</span> ebits;<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                <span class="hljs-comment">/* Read a litlen symbol. */</span><font></font>
                bits = istream_bits(is);<font></font>
                litlen = huffman_decode(litlen_dec, (<span class="hljs-keyword">uint16_t</span>)bits, &amp;used);<font></font>
                bits &gt;&gt;= used;<font></font>
                used_tot = used;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (litlen &lt; <span class="hljs-number">0</span> || litlen &gt; LITLEN_MAX) {
                        <span class="hljs-comment">/* Failed to decode, or invalid symbol. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (litlen &lt;= UINT8_MAX) {
                        <span class="hljs-comment">/* Literal. */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, used_tot)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">if</span> (*dst_pos == dst_cap) {
                                <span class="hljs-keyword">return</span> HWINF_FULL;<font></font>
                        }<font></font>
                        lz77_output_lit(dst, (*dst_pos)++, (<span class="hljs-keyword">uint8_t</span>)litlen);
                        <span class="hljs-keyword">continue</span>;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (litlen == LITLEN_EOB) {
                        <span class="hljs-comment">/* End of block. */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, used_tot)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* It is a back reference. Figure out the length. */</span><font></font>
                assert(litlen &gt;= LITLEN_TBL_OFFSET &amp;&amp; litlen &lt;= LITLEN_MAX);<font></font>
                len   = litlen_tbl[litlen - LITLEN_TBL_OFFSET].base_len;<font></font>
                ebits = litlen_tbl[litlen - LITLEN_TBL_OFFSET].ebits;<font></font>
                <span class="hljs-keyword">if</span> (ebits != <span class="hljs-number">0</span>) {<font></font>
                        len += lsb(bits, ebits);<font></font>
                        bits &gt;&gt;= ebits;<font></font>
                        used_tot += ebits;<font></font>
                }<font></font>
                assert(len &gt;= MIN_LEN &amp;&amp; len &lt;= MAX_LEN);<font></font>
<font></font>
                <span class="hljs-comment">/* Get the distance. */</span>
                distsym = huffman_decode(dist_dec, (<span class="hljs-keyword">uint16_t</span>)bits, &amp;used);<font></font>
                bits &gt;&gt;= used;<font></font>
                used_tot += used;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (distsym &lt; <span class="hljs-number">0</span> || distsym &gt; DISTSYM_MAX) {
                        <span class="hljs-comment">/* Failed to decode, or invalid symbol. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
                dist  = dist_tbl[distsym].base_dist;<font></font>
                ebits = dist_tbl[distsym].ebits;<font></font>
                <span class="hljs-keyword">if</span> (ebits != <span class="hljs-number">0</span>) {<font></font>
                        dist += lsb(bits, ebits);<font></font>
                        bits &gt;&gt;= ebits;<font></font>
                        used_tot += ebits;<font></font>
                }<font></font>
                assert(dist &gt;= MIN_DISTANCE &amp;&amp; dist &lt;= MAX_DISTANCE);<font></font>
<font></font>
                assert(used_tot &lt;= ISTREAM_MIN_BITS);<font></font>
                <span class="hljs-keyword">if</span> (!istream_advance(is, used_tot)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Bounds check and output the backref. */</span>
                <span class="hljs-keyword">if</span> (dist &gt; *dst_pos) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (round_up(len, <span class="hljs-number">8</span>) &lt;= dst_cap - *dst_pos) {<font></font>
                        output_backref64(dst, *dst_pos, dist, len);<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &lt;= dst_cap - *dst_pos) {<font></font>
                        lz77_output_backref(dst, *dst_pos, dist, len);<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">return</span> HWINF_FULL;<font></font>
                }<font></font>
                (*dst_pos) += len;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pay attention to this optimization: when there is not enough space in the outgoing buffer, we issue backlinks using the function below, which copies 64 bits at a time. This is ‚Äúmessy‚Äù in the sense that it often copies a few extra bytes (up to the next multiple of 8). But it works much faster </font></font><code>lz77_output_backref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because it requires less cyclic iterations and memory accesses. In fact, short backlinks will now be processed in one iteration, which is very good for predicting branching.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output the (dist,len) backref at dst_pos in dst using 64-bit wide writes.
   There must be enough room for len bytes rounded to the next multiple of 8. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">output_backref64</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_pos, <span class="hljs-keyword">size_t</span> dist,
                             <span class="hljs-keyword">size_t</span> len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint64_t</span> tmp;<font></font>
<font></font>
        assert(len &gt; <span class="hljs-number">0</span>);<font></font>
        assert(dist &lt;= dst_pos &amp;&amp; <span class="hljs-string">"cannot reference before beginning of dst"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (len &gt; dist) {
                <span class="hljs-comment">/* Self-overlapping backref; fall back to byte-by-byte copy. */</span><font></font>
                lz77_output_backref(dst, dst_pos, dist, len);<font></font>
                <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">do</span> {
                <span class="hljs-built_in">memcpy</span>(&amp;tmp, &amp;dst[dst_pos - dist + i], <span class="hljs-number">8</span>);
                <span class="hljs-built_in">memcpy</span>(&amp;dst[dst_pos + i], &amp;tmp, <span class="hljs-number">8</span>);<font></font>
                i += <span class="hljs-number">8</span>;<font></font>
        } <span class="hljs-keyword">while</span> (i &lt; len);<font></font>
}<font></font>
</code></pre><br>
<a name="15"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deflate blocks using dynamic Huffman codes</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deflate blocks using dynamic Huffman codes work the same way as described above. But instead of the predefined codes for litlen and dist, they use the codes stored in the Deflate stream itself at the beginning of the block. The name is probably unsuccessful, since dynamic Huffman codes are also called codes that change during coding - this is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adaptive Huffman coding</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The codes described here have nothing to do with that procedure. They are dynamic only in the sense that different blocks can use different codes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Generating dynamic litlen and dist codes is the most difficult part of the Deflate format. But as soon as the codes are generated, decompression is performed in the same way as described in the previous part, using </font></font><code>inf_block</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_dyn_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst,
                                <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_pos)</span>
</span>{
        <span class="hljs-keyword">inf_stat_t</span> s;
        <span class="hljs-keyword">huffman_decoder_t</span> litlen_dec, dist_dec;<font></font>
<font></font>
        s = init_dyn_decoders(is, &amp;litlen_dec, &amp;dist_dec);<font></font>
        <span class="hljs-keyword">if</span> (s != HWINF_OK) {
                <span class="hljs-keyword">return</span> s;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> inf_block(is, dst, dst_cap, dst_pos, &amp;litlen_dec, &amp;dist_dec);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Litlen and dist codes for dynamic Deflate blocks are stored as a series of codeword lengths. </font><font style="vertical-align: inherit;">The lengths themselves are encoded using the third Huffman code - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codelen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This code is determined by the length of the code words ( </font></font><code>codelen_lens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) that are stored in the block (did I mention that it is difficult?).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84e/1fc/0e3/84e1fc0e3d3cfcb56ff215702d14f73d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the beginning of the dynamic block there are 14 bits that determine the number of litlen-, dist- and codelen-lengths of code words that need to be read from the block:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_CODELEN_LENS 4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_CODELEN_LENS 19</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LITLEN_LENS 257</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_LITLEN_LENS 288</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_DIST_LENS 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_DIST_LENS 32</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_MAX_LIT 15</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_COPY 16</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_COPY_MIN 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_COPY_MAX 6</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS 17</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS_MIN 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS_MAX 10</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS2 18</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS2_MIN 11</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS2_MAX 138</span><font></font>
<font></font>
<span class="hljs-comment">/* RFC 1951, 3.2.7 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> codelen_lengths_order[MAX_CODELEN_LENS] =<font></font>
{ <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">13</span>, <span class="hljs-number">2</span>, <span class="hljs-number">14</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span> };<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">init_dyn_decoders</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is,
                                    <span class="hljs-keyword">huffman_decoder_t</span> *litlen_dec,
                                    <span class="hljs-keyword">huffman_decoder_t</span> *dist_dec)</span>
</span>{
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">size_t</span> num_litlen_lens, num_dist_lens, num_codelen_lens;
        <span class="hljs-keyword">uint8_t</span> codelen_lengths[MAX_CODELEN_LENS];
        <span class="hljs-keyword">uint8_t</span> code_lengths[MAX_LITLEN_LENS + MAX_DIST_LENS];
        <span class="hljs-keyword">size_t</span> i, n, used;
        <span class="hljs-keyword">int</span> sym;
        <span class="hljs-keyword">huffman_decoder_t</span> codelen_dec;<font></font>
<font></font>
        bits = istream_bits(is);<font></font>
<font></font>
        <span class="hljs-comment">/* Number of litlen codeword lengths (5 bits + 257). */</span>
        num_litlen_lens = lsb(bits, <span class="hljs-number">5</span>) + MIN_LITLEN_LENS;<font></font>
        bits &gt;&gt;= <span class="hljs-number">5</span>;<font></font>
        assert(num_litlen_lens &lt;= MAX_LITLEN_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Number of dist codeword lengths (5 bits + 1). */</span>
        num_dist_lens = lsb(bits, <span class="hljs-number">5</span>) + MIN_DIST_LENS;<font></font>
        bits &gt;&gt;= <span class="hljs-number">5</span>;<font></font>
        assert(num_dist_lens &lt;= MAX_DIST_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Number of code length lengths (4 bits + 4). */</span>
        num_codelen_lens = lsb(bits, <span class="hljs-number">4</span>) + MIN_CODELEN_LENS;<font></font>
        bits &gt;&gt;= <span class="hljs-number">4</span>;<font></font>
        assert(num_codelen_lens &lt;= MAX_CODELEN_LENS);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">4</span>)) {
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then come the codeword lengths for the codelen code. </font><font style="vertical-align: inherit;">These lengths are the usual three-bit values, but written in the special order specified in </font></font><code>codelen_lengths_order</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Since it is necessary to determine 19 lengths, only will be read from the stream </font></font><code>num_codelen_lens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">everything else is implicitly null. </font><font style="vertical-align: inherit;">The lengths are listed in a specific order so that zero lengths are more likely to fall at the end of the list and not be stored in the block.</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-comment">/* Read the codelen codeword lengths (3 bits each)
           and initialize the codelen decoder. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_codelen_lens; i++) {<font></font>
                bits = istream_bits(is);<font></font>
                codelen_lengths[codelen_lengths_order[i]] =<font></font>
                        (<span class="hljs-keyword">uint8_t</span>)lsb(bits, <span class="hljs-number">3</span>);
                <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">3</span>)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
        }<font></font>
        <span class="hljs-keyword">for</span> (; i &lt; MAX_CODELEN_LENS; i++) {<font></font>
                codelen_lengths[codelen_lengths_order[i]] = <span class="hljs-number">0</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (!huffman_decoder_init(&amp;codelen_dec, codelen_lengths,<font></font>
                                  MAX_CODELEN_LENS)) {<font></font>
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By setting the codelen decoder, we can read the lengths of code words litlen and dist from the stream.</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-comment">/* Read the litlen and dist codeword lengths. */</span>
        i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i &lt; num_litlen_lens + num_dist_lens) {<font></font>
                bits = istream_bits(is);<font></font>
                sym = huffman_decode(&amp;codelen_dec, (<span class="hljs-keyword">uint16_t</span>)bits, &amp;used);<font></font>
                bits &gt;&gt;= used;<font></font>
                <span class="hljs-keyword">if</span> (!istream_advance(is, used)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (sym &gt;= <span class="hljs-number">0</span> &amp;&amp; sym &lt;= CODELEN_MAX_LIT) {
                        <span class="hljs-comment">/* A literal codeword length. */</span>
                        code_lengths[i++] = (<span class="hljs-keyword">uint8_t</span>)sym;<font></font>
                }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16, 17 and 18 are not real lengths, they are indicators that the previous length needs to be repeated a number of times, or that you need to repeat the zero length:</font></font><br>
<br>
<pre><code class="cpp hljs">               <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_COPY) {
                        <span class="hljs-comment">/* Copy the previous codeword length 3--6 times. */</span>
                        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span>) {
                                <span class="hljs-keyword">return</span> HWINF_ERR; <span class="hljs-comment">/* No previous length. */</span><font></font>
                        }<font></font>
                        n = lsb(bits, <span class="hljs-number">2</span>) + CODELEN_COPY_MIN; <span class="hljs-comment">/* 2 bits + 3 */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">2</span>)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        assert(n &gt;= CODELEN_COPY_MIN &amp;&amp; n &lt;= CODELEN_COPY_MAX);<font></font>
                        <span class="hljs-keyword">if</span> (i + n &gt; num_litlen_lens + num_dist_lens) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">while</span> (n--) {<font></font>
                                code_lengths[i] = code_lengths[i - <span class="hljs-number">1</span>];<font></font>
                                i++;<font></font>
                        }<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS) {
                        <span class="hljs-comment">/* 3--10 zeros. */</span>
                        n = lsb(bits, <span class="hljs-number">3</span>) + CODELEN_ZEROS_MIN; <span class="hljs-comment">/* 3 bits + 3 */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">3</span>)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        assert(n &gt;= CODELEN_ZEROS_MIN &amp;&amp;<font></font>
                               n &lt;= CODELEN_ZEROS_MAX);<font></font>
                        <span class="hljs-keyword">if</span> (i + n &gt; num_litlen_lens + num_dist_lens) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">while</span> (n--) {<font></font>
                                code_lengths[i++] = <span class="hljs-number">0</span>;<font></font>
                        }<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS2) {
                        <span class="hljs-comment">/* 11--138 zeros. */</span>
                        n = lsb(bits, <span class="hljs-number">7</span>) + CODELEN_ZEROS2_MIN; <span class="hljs-comment">/* 7 bits +138 */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">7</span>)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        assert(n &gt;= CODELEN_ZEROS2_MIN &amp;&amp;<font></font>
                               n &lt;= CODELEN_ZEROS2_MAX);<font></font>
                        <span class="hljs-keyword">if</span> (i + n &gt; num_litlen_lens + num_dist_lens) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">while</span> (n--) {<font></font>
                                code_lengths[i++] = <span class="hljs-number">0</span>;<font></font>
                        }<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-comment">/* Invalid symbol. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note that litlen and dist lengths are read one by one into the array </font></font><code>code_lengths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. They cannot be read separately, because code length runs can be carried over from the last litlen lengths to the first dist lengths. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having prepared the codeword lengths, we can configure Huffman decoders and return to the task of decoding literals and backlinks:</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-keyword">if</span> (!huffman_decoder_init(litlen_dec, &amp;code_lengths[<span class="hljs-number">0</span>],<font></font>
                                  num_litlen_lens)) {<font></font>
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (!huffman_decoder_init(dist_dec, &amp;code_lengths[num_litlen_lens],<font></font>
                                  num_dist_lens)) {<font></font>
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
}<font></font>
</code></pre><br>
<a name="16"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compression (Deflation)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the previous parts, we created all the tools necessary for Deflate compression: Lempel-Ziv, Huffman coding, bit streams and a description of the three types of Deflate blocks. And in this part we will put it all together to get Deflate compression. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compression Lempel-Ziv parses the source data into a sequence of backlinks and literals. This sequence must be divided and encoded into Deflate blocks, as described in the previous part. Choosing a partitioning method is often called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blocking.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">On the one hand, each new block means some kind of overhead, the volume of which depends on the type of block and its contents. </font><font style="vertical-align: inherit;">Fewer blocks - less overhead. </font><font style="vertical-align: inherit;">On the other hand, these costs of creating a new block can pay off. </font><font style="vertical-align: inherit;">For example, if the characteristics of the data allow you to more efficiently perform Huffman coding and reduce the total amount of data generated. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Blocking is a difficult optimization task. </font><font style="vertical-align: inherit;">Some compressors (for example, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zopfli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) try better than others, but most simply use the greedy approach: they issue blocks as soon as they reach a certain size. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Different types of blocks have their own size restrictions:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uncompressed blocks can contain no more than 65,535 bytes.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman fixed codes do not have a maximum size.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic Huffman codes generally do not have a maximum size, but since our implementation of the Huffman algorithm uses 16-bit character sequences, we are limited to 65,535 characters.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To use blocks of any type freely, limit their size to 65,534 bytes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* The largest number of bytes that will fit in any kind of block is 65,534.
   It will fit in an uncompressed block (max 65,535 bytes) and a Huffman
   block with only literals (65,535 symbols including end-of-block marker). */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_BLOCK_LEN_BYTES 65534</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To track the outgoing bitstream and the contents of the current block during compression, we will use the structure:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deflate_state_t</span> <span class="hljs-title">deflate_state_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deflate_state_t</span> {</span>
        <span class="hljs-keyword">ostream_t</span> os;<font></font>
<font></font>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *block_src; <span class="hljs-comment">/* First src byte in the block. */</span><font></font>
<font></font>
        <span class="hljs-keyword">size_t</span> block_len;       <span class="hljs-comment">/* Number of symbols in the current block. */</span>
        <span class="hljs-keyword">size_t</span> block_len_bytes; <span class="hljs-comment">/* Number of src bytes in the block. */</span><font></font>
<font></font>
        <span class="hljs-comment">/* Symbol frequencies for the current block. */</span>
        <span class="hljs-keyword">uint16_t</span> litlen_freqs[LITLEN_MAX + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">uint16_t</span> dist_freqs[DISTSYM_MAX + <span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
                <span class="hljs-keyword">uint16_t</span> distance;    <span class="hljs-comment">/* Backref distance. */</span>
                <span class="hljs-keyword">union</span> {
                        <span class="hljs-keyword">uint16_t</span> lit; <span class="hljs-comment">/* Literal byte or end-of-block. */</span>
                        <span class="hljs-keyword">uint16_t</span> len; <span class="hljs-comment">/* Backref length (distance != 0). */</span><font></font>
                } u;<font></font>
        } block[MAX_BLOCK_LEN_BYTES + <span class="hljs-number">1</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reset_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s)</span>
</span>{<font></font>
        s-&gt;block_len = <span class="hljs-number">0</span>;<font></font>
        s-&gt;block_len_bytes = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">memset</span>(s-&gt;litlen_freqs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s-&gt;litlen_freqs));
        <span class="hljs-built_in">memset</span>(s-&gt;dist_freqs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s-&gt;dist_freqs));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To add work results to the block, </font></font><code>lz77_compress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we will use the callback functions, and upon reaching the maximum size, we will write the block to the bitstream:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">lit_callback</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> lit, <span class="hljs-keyword">void</span> *aux)</span>
</span>{
        <span class="hljs-keyword">deflate_state_t</span> *s = aux;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (s-&gt;block_len_bytes + <span class="hljs-number">1</span> &gt; MAX_BLOCK_LEN_BYTES) {
                <span class="hljs-keyword">if</span> (!write_block(s, <span class="hljs-literal">false</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                s-&gt;block_src += s-&gt;block_len_bytes;<font></font>
                reset_block(s);<font></font>
        }<font></font>
<font></font>
        assert(s-&gt;block_len &lt; <span class="hljs-keyword">sizeof</span>(s-&gt;block) / <span class="hljs-keyword">sizeof</span>(s-&gt;block[<span class="hljs-number">0</span>]));<font></font>
        s-&gt;block[s-&gt;block_len  ].distance = <span class="hljs-number">0</span>;<font></font>
        s-&gt;block[s-&gt;block_len++].u.lit = lit;<font></font>
        s-&gt;block_len_bytes++;<font></font>
<font></font>
        s-&gt;litlen_freqs[lit]++;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">backref_callback</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> dist, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">void</span> *aux)</span>
</span>{
        <span class="hljs-keyword">deflate_state_t</span> *s = aux;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (s-&gt;block_len_bytes + len &gt; MAX_BLOCK_LEN_BYTES) {
                <span class="hljs-keyword">if</span> (!write_block(s, <span class="hljs-literal">false</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                s-&gt;block_src += s-&gt;block_len_bytes;<font></font>
                reset_block(s);<font></font>
        }<font></font>
<font></font>
        assert(s-&gt;block_len &lt; <span class="hljs-keyword">sizeof</span>(s-&gt;block) / <span class="hljs-keyword">sizeof</span>(s-&gt;block[<span class="hljs-number">0</span>]));<font></font>
        s-&gt;block[s-&gt;block_len  ].distance = (<span class="hljs-keyword">uint16_t</span>)dist;<font></font>
        s-&gt;block[s-&gt;block_len++].u.len = (<span class="hljs-keyword">uint16_t</span>)len;<font></font>
        s-&gt;block_len_bytes += len;<font></font>
<font></font>
        assert(len &gt;= MIN_LEN &amp;&amp; len &lt;= MAX_LEN);<font></font>
        assert(dist &gt;= MIN_DISTANCE &amp;&amp; dist &lt;= MAX_DISTANCE);<font></font>
        s-&gt;litlen_freqs[len2litlen[len]]++;<font></font>
        s-&gt;dist_freqs[distance2dist[dist]]++;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most interesting thing is the recording of blocks. </font><font style="vertical-align: inherit;">If the block is not compressed, then everything is simple:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_uncomp_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> len_nlen[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-comment">/* Write the block header. */</span>
        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, (<span class="hljs-number">0x0</span> &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-keyword">final</span>, <span class="hljs-number">3</span>)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        len_nlen[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">uint8_t</span>)(s-&gt;block_len_bytes &gt;&gt; <span class="hljs-number">0</span>);<font></font>
        len_nlen[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">uint8_t</span>)(s-&gt;block_len_bytes &gt;&gt; <span class="hljs-number">8</span>);<font></font>
        len_nlen[<span class="hljs-number">2</span>] = ~len_nlen[<span class="hljs-number">0</span>];<font></font>
        len_nlen[<span class="hljs-number">3</span>] = ~len_nlen[<span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!ostream_write_bytes_aligned(&amp;s-&gt;os, len_nlen, <span class="hljs-keyword">sizeof</span>(len_nlen))) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!ostream_write_bytes_aligned(&amp;s-&gt;os, s-&gt;block_src,<font></font>
                                         s-&gt;block_len_bytes)) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To write a static Huffman block, we first generate canonical codes based on fixed codeword lengths for litlen and dist codes. </font><font style="vertical-align: inherit;">Then we iterate the block, writing down the characters that use these codes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_static_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>)</span>
</span>{
        <span class="hljs-keyword">huffman_encoder_t</span> litlen_enc, dist_enc;<font></font>
<font></font>
        <span class="hljs-comment">/* Write the block header. */</span>
        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, (<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-keyword">final</span>, <span class="hljs-number">3</span>)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        huffman_encoder_init2(&amp;litlen_enc, fixed_litlen_lengths,<font></font>
                              <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths) /
                              <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths[<span class="hljs-number">0</span>]));<font></font>
        huffman_encoder_init2(&amp;dist_enc, fixed_dist_lengths,<font></font>
                              <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths) /
                              <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths[<span class="hljs-number">0</span>]));<font></font>
<font></font>
        <span class="hljs-keyword">return</span> write_huffman_block(s, &amp;litlen_enc, &amp;dist_enc);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_huffman_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *litlen_enc,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *dist_enc)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, nbits;
        <span class="hljs-keyword">uint64_t</span> distance, dist, len, litlen, bits, ebits;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; s-&gt;block_len; i++) {
                <span class="hljs-keyword">if</span> (s-&gt;block[i].distance == <span class="hljs-number">0</span>) {
                        <span class="hljs-comment">/* Literal or EOB. */</span><font></font>
                        litlen = s-&gt;block[i].u.lit;<font></font>
                        assert(litlen &lt;= LITLEN_EOB);<font></font>
                        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os,<font></font>
                                           litlen_enc-&gt;codewords[litlen],<font></font>
                                           litlen_enc-&gt;lengths[litlen])) {<font></font>
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Back reference length. */</span><font></font>
                len = s-&gt;block[i].u.len;<font></font>
                litlen = len2litlen[len];<font></font>
<font></font>
                <span class="hljs-comment">/* litlen bits */</span><font></font>
                bits = litlen_enc-&gt;codewords[litlen];<font></font>
                nbits = litlen_enc-&gt;lengths[litlen];<font></font>
<font></font>
                <span class="hljs-comment">/* ebits */</span><font></font>
                ebits = len - litlen_tbl[litlen - LITLEN_TBL_OFFSET].base_len;<font></font>
                bits |= ebits &lt;&lt; nbits;<font></font>
                nbits += litlen_tbl[litlen - LITLEN_TBL_OFFSET].ebits;<font></font>
<font></font>
                <span class="hljs-comment">/* Back reference distance. */</span><font></font>
                distance = s-&gt;block[i].distance;<font></font>
                dist = distance2dist[distance];<font></font>
<font></font>
                <span class="hljs-comment">/* dist bits */</span>
                bits |= (<span class="hljs-keyword">uint64_t</span>)dist_enc-&gt;codewords[dist] &lt;&lt; nbits;<font></font>
                nbits += dist_enc-&gt;lengths[dist];<font></font>
<font></font>
                <span class="hljs-comment">/* ebits */</span><font></font>
                ebits = distance - dist_tbl[dist].base_dist;<font></font>
                bits |= ebits &lt;&lt; nbits;<font></font>
                nbits += dist_tbl[dist].ebits;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, bits, nbits)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, writing Huffman dynamic blocks is harder because they contain tricky coding of litlen and dist codes. </font><font style="vertical-align: inherit;">To represent this encoding, we use the following structure:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">codelen_sym_t</span> <span class="hljs-title">codelen_sym_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">codelen_sym_t</span> {</span>
        <span class="hljs-keyword">uint8_t</span> sym;
        <span class="hljs-keyword">uint8_t</span> count; <span class="hljs-comment">/* For symbols 16, 17, 18. */</span><font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, we discard the tail of their zero lengths of the litlen and dist codewords, and then copy them into a regular array for subsequent encoding. </font><font style="vertical-align: inherit;">We cannot discard all zeros: it is impossible to encode a Deflate block if there is not a single dist code in it. </font><font style="vertical-align: inherit;">It is also impossible to have less than 257 litlen codes, but since we always have a byte end marker, there will always be a non-zero code length for a character of 256.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Encode litlen_lens and dist_lens into encoded. *num_litlen_lens and
   *num_dist_lens will be set to the number of encoded litlen and dist lens,
   respectively. Returns the number of elements in encoded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">encode_dist_litlen_lens</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *litlen_lens,
                                      <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *dist_lens,
                                      <span class="hljs-keyword">codelen_sym_t</span> *encoded,
                                      <span class="hljs-keyword">size_t</span> *num_litlen_lens,
                                      <span class="hljs-keyword">size_t</span> *num_dist_lens)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, n;
        <span class="hljs-keyword">uint8_t</span> lens[LITLEN_MAX + <span class="hljs-number">1</span> + DISTSYM_MAX + <span class="hljs-number">1</span>];<font></font>
<font></font>
        *num_litlen_lens = LITLEN_MAX + <span class="hljs-number">1</span>;<font></font>
        *num_dist_lens = DISTSYM_MAX + <span class="hljs-number">1</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* Drop trailing zero litlen lengths. */</span>
        assert(litlen_lens[LITLEN_EOB] != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-string">"EOB len should be non-zero."</span>);
        <span class="hljs-keyword">while</span> (litlen_lens[*num_litlen_lens - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) {<font></font>
                (*num_litlen_lens)--;<font></font>
        }<font></font>
        assert(*num_litlen_lens &gt;= MIN_LITLEN_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Drop trailing zero dist lengths, keeping at least one. */</span>
        <span class="hljs-keyword">while</span> (dist_lens[*num_dist_lens - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; *num_dist_lens &gt; <span class="hljs-number">1</span>) {<font></font>
                (*num_dist_lens)--;<font></font>
        }<font></font>
        assert(*num_dist_lens &gt;= MIN_DIST_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Copy the lengths into a unified array. */</span>
        n = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; *num_litlen_lens; i++) {<font></font>
                lens[n++] = litlen_lens[i];<font></font>
        }<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; *num_dist_lens; i++) {<font></font>
                lens[n++] = dist_lens[i];<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> encode_lens(lens, n, encoded);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having added the code lengths into one array, we perform coding using special characters to run the same code lengths.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Encode the n code lengths in lens into encoded, returning the number of
   elements in encoded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">encode_lens</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lens, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">codelen_sym_t</span> *encoded)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, j, num_encoded;
        <span class="hljs-keyword">uint8_t</span> count;<font></font>
<font></font>
        i = <span class="hljs-number">0</span>;<font></font>
        num_encoded = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i &lt; n) {
                <span class="hljs-keyword">if</span> (lens[i] == <span class="hljs-number">0</span>) {
                        <span class="hljs-comment">/* Scan past the end of this zero run (max 138). */</span>
                        <span class="hljs-keyword">for</span> (j = i; j &lt; min(n, i + CODELEN_ZEROS2_MAX) &amp;&amp;<font></font>
                                    lens[j] == <span class="hljs-number">0</span>; j++);<font></font>
                        count = (<span class="hljs-keyword">uint8_t</span>)(j - i);<font></font>
<font></font>
                        <span class="hljs-keyword">if</span> (count &lt; CODELEN_ZEROS_MIN) {
                                <span class="hljs-comment">/* Output a single zero. */</span>
                                encoded[num_encoded++].sym = <span class="hljs-number">0</span>;<font></font>
                                i++;<font></font>
                                <span class="hljs-keyword">continue</span>;<font></font>
                        }<font></font>
<font></font>
                        <span class="hljs-comment">/* Output a repeated zero. */</span>
                        <span class="hljs-keyword">if</span> (count &lt;= CODELEN_ZEROS_MAX) {
                                <span class="hljs-comment">/* Repeated zero 3--10 times. */</span><font></font>
                                assert(count &gt;= CODELEN_ZEROS_MIN &amp;&amp;<font></font>
                                       count &lt;= CODELEN_ZEROS_MAX);<font></font>
                                encoded[num_encoded].sym = CODELEN_ZEROS;<font></font>
                                encoded[num_encoded++].count = count;<font></font>
                        } <span class="hljs-keyword">else</span> {
                                <span class="hljs-comment">/* Repeated zero 11--138 times. */</span><font></font>
                                assert(count &gt;= CODELEN_ZEROS2_MIN &amp;&amp;<font></font>
                                       count &lt;= CODELEN_ZEROS2_MAX);<font></font>
                                encoded[num_encoded].sym = CODELEN_ZEROS2;<font></font>
                                encoded[num_encoded++].count = count;<font></font>
                        }<font></font>
                        i = j;<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Output len. */</span><font></font>
                encoded[num_encoded++].sym = lens[i++];<font></font>
<font></font>
                <span class="hljs-comment">/* Scan past the end of the run of this len (max 6). */</span>
                <span class="hljs-keyword">for</span> (j = i; j &lt; min(n, i + CODELEN_COPY_MAX) &amp;&amp;<font></font>
                            lens[j] == lens[i - <span class="hljs-number">1</span>]; j++);<font></font>
                count = (<span class="hljs-keyword">uint8_t</span>)(j - i);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (count &gt;= CODELEN_COPY_MIN) {
                        <span class="hljs-comment">/* Repeat last len 3--6 times. */</span><font></font>
                        assert(count &gt;= CODELEN_COPY_MIN &amp;&amp;<font></font>
                               count &lt;= CODELEN_COPY_MAX);<font></font>
                        encoded[num_encoded].sym = CODELEN_COPY;<font></font>
                        encoded[num_encoded++].count = count;<font></font>
                        i = j;<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> num_encoded;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The characters used for encoding will be recorded using the Huffman code - codelen. </font><font style="vertical-align: inherit;">The lengths of codewords from codelen code are written to the block in a specific order so that zero lengths are more likely to end up at the end. </font><font style="vertical-align: inherit;">Here is a function that calculates how many lengths should be written:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> codelen_lengths_order[<span class="hljs-number">19</span>] =<font></font>
{ <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">13</span>, <span class="hljs-number">2</span>, <span class="hljs-number">14</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span> };<font></font>
<font></font>
<span class="hljs-comment">/* Count the number of significant (not trailing zeros) codelen lengths. */</span>
<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">count_codelen_lens</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *codelen_lens)</span>
</span>{
        <span class="hljs-keyword">size_t</span> n = MAX_CODELEN_LENS;<font></font>
<font></font>
        <span class="hljs-comment">/* Drop trailing zero lengths. */</span>
        <span class="hljs-keyword">while</span> (codelen_lens[codelen_lengths_order[n - <span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>) {<font></font>
                n--;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* The first 4 lengths in the order (16, 17, 18, 0) cannot be used to
           encode any non-zero lengths. Since there will always be at least
           one non-zero codeword length (for EOB), n will be &gt;= 4. */</span><font></font>
        assert(n &gt;= MIN_CODELEN_LENS &amp;&amp; n &lt;= MAX_CODELEN_LENS);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> n;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose we have already set the litlen and dist codes, set up the encoding of the lengths of their code words and the code for these lengths. </font><font style="vertical-align: inherit;">Now we can write a dynamic Huffman block:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_dynamic_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>,
                                <span class="hljs-keyword">size_t</span> num_litlen_lens, <span class="hljs-keyword">size_t</span> num_dist_lens,
                                <span class="hljs-keyword">size_t</span> num_codelen_lens,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *codelen_enc,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">codelen_sym_t</span> *encoded_lens,
                                <span class="hljs-keyword">size_t</span> num_encoded_lens,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *litlen_enc,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *dist_enc)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint8_t</span> codelen, sym;
        <span class="hljs-keyword">size_t</span> nbits;
        <span class="hljs-keyword">uint64_t</span> bits, hlit, hdist, hclen, count;<font></font>
<font></font>
        <span class="hljs-comment">/* Block header. */</span>
        bits = (<span class="hljs-number">0x2</span> &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-keyword">final</span>;<font></font>
        nbits = <span class="hljs-number">3</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* hlit (5 bits) */</span><font></font>
        hlit = num_litlen_lens - MIN_LITLEN_LENS;<font></font>
        bits |= hlit &lt;&lt; nbits;<font></font>
        nbits += <span class="hljs-number">5</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* hdist (5 bits) */</span><font></font>
        hdist = num_dist_lens - MIN_DIST_LENS;<font></font>
        bits |= hdist &lt;&lt; nbits;<font></font>
        nbits += <span class="hljs-number">5</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* hclen (4 bits) */</span><font></font>
        hclen = num_codelen_lens - MIN_CODELEN_LENS;<font></font>
        bits |= hclen &lt;&lt; nbits;<font></font>
        nbits += <span class="hljs-number">4</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, bits, nbits)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Codelen lengths. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_codelen_lens; i++) {<font></font>
                codelen = codelen_enc-&gt;lengths[codelen_lengths_order[i]];<font></font>
                <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, codelen, <span class="hljs-number">3</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Litlen and dist code lengths. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_encoded_lens; i++) {<font></font>
                sym = encoded_lens[i].sym;<font></font>
<font></font>
                bits = codelen_enc-&gt;codewords[sym];<font></font>
                nbits = codelen_enc-&gt;lengths[sym];<font></font>
<font></font>
                count = encoded_lens[i].count;<font></font>
                <span class="hljs-keyword">if</span> (sym == CODELEN_COPY) { <span class="hljs-comment">/* 2 ebits */</span><font></font>
                        bits |= (count - CODELEN_COPY_MIN) &lt;&lt; nbits;<font></font>
                        nbits += <span class="hljs-number">2</span>;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS) { <span class="hljs-comment">/* 3 ebits */</span><font></font>
                        bits |= (count - CODELEN_ZEROS_MIN) &lt;&lt; nbits;<font></font>
                        nbits += <span class="hljs-number">3</span>;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS2) { <span class="hljs-comment">/* 7 ebits */</span><font></font>
                        bits |= (count - CODELEN_ZEROS2_MIN) &lt;&lt; nbits;<font></font>
                        nbits += <span class="hljs-number">7</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, bits, nbits)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> write_huffman_block(s, litlen_enc, dist_enc);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For each block, we want to use the type that requires the least number of bits. </font><font style="vertical-align: inherit;">The length of an uncompressed block can be calculated quickly:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Calculate the number of bits for an uncompressed block, including header. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">uncomp_block_len</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">deflate_state_t</span> *s)</span>
</span>{
        <span class="hljs-keyword">size_t</span> bit_pos, padding;<font></font>
<font></font>
        <span class="hljs-comment">/* Bit position after writing the block header. */</span>
        bit_pos = ostream_bit_pos(&amp;s-&gt;os) + <span class="hljs-number">3</span>;<font></font>
        padding = round_up(bit_pos, <span class="hljs-number">8</span>) - bit_pos;<font></font>
<font></font>
        <span class="hljs-comment">/* Header + padding + len/nlen + block contents. */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> + padding + <span class="hljs-number">2</span> * <span class="hljs-number">16</span> + s-&gt;block_len_bytes * <span class="hljs-number">8</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For Huffman encoded blocks, you can calculate the body length using the litlen- and dist-frequencies of characters and codeword lengths:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Calculate the number of bits for a Huffman encoded block body. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">huffman_block_body_len</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">deflate_state_t</span> *s,
                                     <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *litlen_lens,
                                     <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *dist_lens)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, freq, len;<font></font>
<font></font>
        len = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= LITLEN_MAX; i++) {<font></font>
                freq = s-&gt;litlen_freqs[i];<font></font>
                len += litlen_lens[i] * freq;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (i &gt;= LITLEN_TBL_OFFSET) {<font></font>
                        len += litlen_tbl[i - LITLEN_TBL_OFFSET].ebits * freq;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= DISTSYM_MAX; i++) {<font></font>
                freq = s-&gt;dist_freqs[i];<font></font>
                len += dist_lens[i] * freq;<font></font>
                len += dist_tbl[i].ebits * freq;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> len;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The total length of the static block is 3 bits of the header plus the length of the body. </font><font style="vertical-align: inherit;">Calculating the header size of a dynamic block requires much more work:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Calculate the number of bits for a dynamic Huffman block. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">dyn_block_len</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">size_t</span> num_codelen_lens,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> *codelen_freqs,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *codelen_enc,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *litlen_enc,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *dist_enc)</span>
</span>{
        <span class="hljs-keyword">size_t</span> len, i, freq;<font></font>
<font></font>
        <span class="hljs-comment">/* Block header. */</span>
        len = <span class="hljs-number">3</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* Nbr of litlen, dist, and codelen lengths. */</span>
        len += <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">4</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* Codelen lengths. */</span>
        len += <span class="hljs-number">3</span> * num_codelen_lens;<font></font>
<font></font>
        <span class="hljs-comment">/* Codelen encoding. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_CODELEN_LENS; i++) {<font></font>
                freq = codelen_freqs[i];<font></font>
                len += codelen_enc-&gt;lengths[i] * freq;<font></font>
<font></font>
                <span class="hljs-comment">/* Extra bits. */</span>
                <span class="hljs-keyword">if</span> (i == CODELEN_COPY) {<font></font>
                        len += <span class="hljs-number">2</span> * freq;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == CODELEN_ZEROS) {<font></font>
                        len += <span class="hljs-number">3</span> * freq;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == CODELEN_ZEROS2) {<font></font>
                        len += <span class="hljs-number">7</span> * freq;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> len + huffman_block_body_len(s, litlen_enc-&gt;lengths,<font></font>
                                            dist_enc-&gt;lengths);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we will put everything together and create the main function for writing blocks:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Write the current deflate block, marking it final if that parameter is true,
   returning false if there is not enough room in the output stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>)</span>
</span>{
        <span class="hljs-keyword">size_t</span> old_bit_pos, uncomp_len, static_len, dynamic_len;
        <span class="hljs-keyword">huffman_encoder_t</span> dyn_litlen_enc, dyn_dist_enc, codelen_enc;
        <span class="hljs-keyword">size_t</span> num_encoded_lens, num_litlen_lens, num_dist_lens;
        <span class="hljs-keyword">codelen_sym_t</span> encoded_lens[LITLEN_MAX + <span class="hljs-number">1</span> + DISTSYM_MAX + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">uint16_t</span> codelen_freqs[MAX_CODELEN_LENS] = {<span class="hljs-number">0</span>};
        <span class="hljs-keyword">size_t</span> num_codelen_lens;
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        old_bit_pos = ostream_bit_pos(&amp;s-&gt;os);<font></font>
<font></font>
        <span class="hljs-comment">/* Add the end-of-block marker in case we write a Huffman block. */</span>
        assert(s-&gt;block_len &lt; <span class="hljs-keyword">sizeof</span>(s-&gt;block) / <span class="hljs-keyword">sizeof</span>(s-&gt;block[<span class="hljs-number">0</span>]));<font></font>
        assert(s-&gt;litlen_freqs[LITLEN_EOB] == <span class="hljs-number">0</span>);<font></font>
        s-&gt;block[s-&gt;block_len  ].distance = <span class="hljs-number">0</span>;<font></font>
        s-&gt;block[s-&gt;block_len++].u.lit = LITLEN_EOB;<font></font>
        s-&gt;litlen_freqs[LITLEN_EOB] = <span class="hljs-number">1</span>;<font></font>
<font></font>
        uncomp_len = uncomp_block_len(s);<font></font>
<font></font>
        static_len = <span class="hljs-number">3</span> + huffman_block_body_len(s, fixed_litlen_lengths,<font></font>
                                                fixed_dist_lengths);<font></font>
<font></font>
        <span class="hljs-comment">/* Compute "dynamic" Huffman codes. */</span><font></font>
        huffman_encoder_init(&amp;dyn_litlen_enc, s-&gt;litlen_freqs,<font></font>
                             LITLEN_MAX + <span class="hljs-number">1</span>, <span class="hljs-number">15</span>);<font></font>
        huffman_encoder_init(&amp;dyn_dist_enc, s-&gt;dist_freqs, DISTSYM_MAX + <span class="hljs-number">1</span>, <span class="hljs-number">15</span>);<font></font>
<font></font>
        <span class="hljs-comment">/* Encode the litlen and dist code lengths. */</span><font></font>
        num_encoded_lens = encode_dist_litlen_lens(dyn_litlen_enc.lengths,<font></font>
                                                   dyn_dist_enc.lengths,<font></font>
                                                   encoded_lens,<font></font>
                                                   &amp;num_litlen_lens,<font></font>
                                                   &amp;num_dist_lens);<font></font>
<font></font>
        <span class="hljs-comment">/* Compute the codelen code. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_encoded_lens; i++) {<font></font>
                codelen_freqs[encoded_lens[i].sym]++;<font></font>
        }<font></font>
        huffman_encoder_init(&amp;codelen_enc, codelen_freqs, MAX_CODELEN_LENS, <span class="hljs-number">7</span>);<font></font>
        num_codelen_lens = count_codelen_lens(codelen_enc.lengths);<font></font>
<font></font>
        dynamic_len = dyn_block_len(s, num_codelen_lens, codelen_freqs,<font></font>
                                    &amp;codelen_enc, &amp;dyn_litlen_enc,<font></font>
                                    &amp;dyn_dist_enc);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (uncomp_len &lt;= dynamic_len &amp;&amp; uncomp_len &lt;= static_len) {
                <span class="hljs-keyword">if</span> (!write_uncomp_block(s, <span class="hljs-keyword">final</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                assert(ostream_bit_pos(&amp;s-&gt;os) - old_bit_pos == uncomp_len);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (static_len &lt;= dynamic_len) {
                <span class="hljs-keyword">if</span> (!write_static_block(s, <span class="hljs-keyword">final</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                assert(ostream_bit_pos(&amp;s-&gt;os) - old_bit_pos == static_len);<font></font>
        } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (!write_dynamic_block(s, <span class="hljs-keyword">final</span>, num_litlen_lens,<font></font>
                                         num_dist_lens, num_codelen_lens,<font></font>
                                         &amp;codelen_enc, encoded_lens,<font></font>
                                         num_encoded_lens, &amp;dyn_litlen_enc,<font></font>
                                         &amp;dyn_dist_enc)) {<font></font>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                assert(ostream_bit_pos(&amp;s-&gt;os) - old_bit_pos == dynamic_len);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, the initiator of the entire compression process should set the initial state, start Lempel-Ziv compression and write the resulting block:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Compress (deflate) the data in src into dst. The number of bytes output, at
   most dst_cap, is stored in *dst_used. Returns false if there is not enough
   room in dst. src and dst must not overlap. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hwdeflate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len, <span class="hljs-keyword">uint8_t</span> *dst,
               <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_used)</span>
</span>{
        <span class="hljs-keyword">deflate_state_t</span> s;<font></font>
<font></font>
        ostream_init(&amp;s.os, dst, dst_cap);<font></font>
        reset_block(&amp;s);<font></font>
        s.block_src = src;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!lz77_compress(src, src_len, &amp;lit_callback,<font></font>
                           &amp;backref_callback, &amp;s)) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!write_block(&amp;s, <span class="hljs-literal">true</span>)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* The end of the final block should match the end of src. */</span><font></font>
        assert(s.block_src + s.block_len_bytes == src + src_len);<font></font>
<font></font>
        *dst_used = ostream_bytes_written(&amp;s.os);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br>
<a name="17"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zip File Format</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Above, we examined how the Deflate compression used in Zip files works. </font><font style="vertical-align: inherit;">What about the file format itself? </font><font style="vertical-align: inherit;">In this part, we will examine in detail its structure and implementation. </font><font style="vertical-align: inherit;">The code is available in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zip.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zip.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="18"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Overview</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The file format is described in PKZip </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application Note</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each file, or archive item, in a zip file has a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">local file header</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with metadata about the item.</font></font></li>
<li><i> </i>   .         ,      ,    ,      Zip-.</li>
<li>  ,     <i>   </i>.       ,        .     Zip-.</li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/821/bba/6ce/821bba6cede767c834da639e00d7d6ba.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each archive item is compressed and stored individually. This means that even if there are matches between files in the archive, they will not be taken into account to improve compression. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The location of the central catalog at the end allows you to gradually complete the archive. As file elements are compressed, they are added to the archive. The index is recorded after all compressed sizes, which allows you to find out the offsets of all files. Adding files to an existing archive is quite easy, it is placed after the last element, and the central directory is overwritten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The ability to gradually create archives was especially important for disseminating information on numerous floppy disks or volumes. As it compressed, PKZip suggested users insert new diskettes, and write the central directory to the last (last) ones. To unzip a multi-volume archive, PKZip first asked for the last diskette to write to read the central directory, and then the rest of the diskette needed to extract the requested files. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This may surprise you, but there was no rule prohibiting having multiple files with the same name in the archive. This could lead to a lot of confusion when unpacking: if there are several files with the same name, which one should you unpack? In turn, this could lead to security problems. Due to the ‚ÄúMaster Key‚Äù bug in Android (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CVE-2013-4787</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slides</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from the report on Black Hat) an attacker could bypass the checks of the </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">cryptographic signature</font></a><font style="vertical-align: inherit;"> operating system when installing programs. Android programs are distributed in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> files, which are Zip files. As it turned out, if the APK contained several files with the same name, the signature verification code selected the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">last</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file with the same name, and the installer selected the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file, that is, the verification was not performed. In other words, this small difference between the two Zip libraries made it possible to bypass the entire operating system security model. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unlike most formats, zip files should not start with a signature or </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">magic number</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It is generally not indicated that the Zip file should start in any particular way, which easily allows you to create files that are both valid as Zip and as a different format ‚Äî </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">polyglot files</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . For example, self-extracting Zip archives (for example, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pkz204g.exe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) are usually both executable and Zip files: the first part is executable, followed by a Zip file (which is unpacked by the executable part). The OS can execute it as executable, but the Zip program will open it as a Zip file. This feature could cause you to not require a signature at the beginning of the file.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although such polyglot files are smart, they can lead to security problems because they can trick programs trying to determine the contents of the file and also allow delivering malicious code in a place with files of different types. For example, exploits used </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GIFAR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> files, which at the same time are valid GIF images and Java archives (JAR, a type of Zip file). For more information on this issue, see the article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abusing file formats</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (starting on page 18). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As we will see below, Zip files use 32-bit fields for offsets and sizes in order to limit the size of the archive and its elements to four gigabytes. In </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application Note 4.5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PKWare has added format extensions allowing the use of 64-bit offsets and sizes. Files using these extensions are in the Zip64 format, but we will not consider them.</font></font><br>
<br>
<a name="19"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data structures</font></font></h3><br>
<a name="20"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">End of central directory entry</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The end of a central directory entry (EOCDR) is typically used as the starting point for reading a zip file. It contains the location and size of the central directory, as well as optional comments about the entire archive. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Zip files that occupied several diskettes - or volumes - EOCDR also contained information about which disk we are currently using, on which disk the central directory starts, etc. Today, this functionality is rarely used, and the code in this article does not process such files. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EOCDR is determined by the signature 'P' 'K', followed by bytes 5 and 6. It is followed by the structure below, the numbers are stored according to the little-endian principle:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* End of Central Directory Record. */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eocdr</span> {</span>
        <span class="hljs-keyword">uint16_t</span> disk_nbr;        <span class="hljs-comment">/* Number of this disk. */</span>
        <span class="hljs-keyword">uint16_t</span> cd_start_disk;   <span class="hljs-comment">/* Nbr. of disk with start of the CD. */</span>
        <span class="hljs-keyword">uint16_t</span> disk_cd_entries; <span class="hljs-comment">/* Nbr. of CD entries on this disk. */</span>
        <span class="hljs-keyword">uint16_t</span> cd_entries;      <span class="hljs-comment">/* Nbr. of Central Directory entries. */</span>
        <span class="hljs-keyword">uint32_t</span> cd_size;         <span class="hljs-comment">/* Central Directory size in bytes. */</span>
        <span class="hljs-keyword">uint32_t</span> cd_offset;       <span class="hljs-comment">/* Central Directory file offset. */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;     <span class="hljs-comment">/* Archive comment length. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;   <span class="hljs-comment">/* Archive comment. */</span><font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EOCDR should be located at the end of the file. </font><font style="vertical-align: inherit;">But since there may be a comment of arbitrary 16-bit length in its tail, it may be necessary to find a specific position:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Read 16/32 bits little-endian and bump p forward afterwards. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> READ16(p) ((p) += 2, read16le((p) - 2))</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> READ32(p) ((p) += 4, read32le((p) - 4))</span><font></font>
<font></font>
<span class="hljs-comment">/* Size of the End of Central Directory Record, not including comment. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EOCDR_BASE_SZ 22</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EOCDR_SIGNATURE 0x06054b50  <span class="hljs-comment">/* "PK\5\6" little-endian. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">find_eocdr</span><span class="hljs-params">(struct eocdr *r, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> comment_len;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint32_t</span> signature;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (comment_len = <span class="hljs-number">0</span>; comment_len &lt;= UINT16_MAX; comment_len++) {
                <span class="hljs-keyword">if</span> (src_len &lt; EOCDR_BASE_SZ + comment_len) {
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
<font></font>
                p = &amp;src[src_len - EOCDR_BASE_SZ - comment_len];<font></font>
                signature = READ32(p);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (signature == EOCDR_SIGNATURE) {<font></font>
                        r-&gt;disk_nbr = READ16(p);<font></font>
                        r-&gt;cd_start_disk = READ16(p);<font></font>
                        r-&gt;disk_cd_entries = READ16(p);<font></font>
                        r-&gt;cd_entries = READ16(p);<font></font>
                        r-&gt;cd_size = READ32(p);<font></font>
                        r-&gt;cd_offset = READ32(p);<font></font>
                        r-&gt;comment_len = READ16(p);<font></font>
                        r-&gt;comment = p;<font></font>
                        assert(p == &amp;src[src_len - comment_len] &amp;&amp;<font></font>
                               <span class="hljs-string">"All fields read."</span>);<font></font>
<font></font>
                        <span class="hljs-keyword">if</span> (r-&gt;comment_len == comment_len) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
                        }<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recording EOCDR is easy. </font><font style="vertical-align: inherit;">This function writes and returns the number of bytes written:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Write 16/32 bits little-endian and bump p forward afterwards. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WRITE16(p, x) (write16le((p), (x)), (p) += 2)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WRITE32(p, x) (write32le((p), (x)), (p) += 4)</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">write_eocdr</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">const</span> struct eocdr *r)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p = dst;<font></font>
<font></font>
        WRITE32(p, EOCDR_SIGNATURE);<font></font>
        WRITE16(p, r-&gt;disk_nbr);<font></font>
        WRITE16(p, r-&gt;cd_start_disk);<font></font>
        WRITE16(p, r-&gt;disk_cd_entries);<font></font>
        WRITE16(p, r-&gt;cd_entries);<font></font>
        WRITE32(p, r-&gt;cd_size);<font></font>
        WRITE32(p, r-&gt;cd_offset);<font></font>
        WRITE16(p, r-&gt;comment_len);<font></font>
        assert(p - dst == EOCDR_BASE_SZ);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (r-&gt;comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, r-&gt;comment, r-&gt;comment_len);<font></font>
                p += r-&gt;comment_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">size_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="21"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Central file header</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The central directory consists of central file headers written one after another, one for each archive item. </font><font style="vertical-align: inherit;">Each heading begins with the signature 'P', 'K', 1, 2, and then there is such a structure:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXT_ATTR_DIR (1U &lt;&lt; 4)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXT_ATTR_ARC (1U &lt;&lt; 5)</span><font></font>
<font></font>
<span class="hljs-comment">/* Central File Header (Central Directory Entry) */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> {</span>
        <span class="hljs-keyword">uint16_t</span> made_by_ver;    <span class="hljs-comment">/* Version made by. */</span>
        <span class="hljs-keyword">uint16_t</span> extract_ver;    <span class="hljs-comment">/* Version needed to extract. */</span>
        <span class="hljs-keyword">uint16_t</span> gp_flag;        <span class="hljs-comment">/* General purpose bit flag. */</span>
        <span class="hljs-keyword">uint16_t</span> method;         <span class="hljs-comment">/* Compression method. */</span>
        <span class="hljs-keyword">uint16_t</span> mod_time;       <span class="hljs-comment">/* Modification time. */</span>
        <span class="hljs-keyword">uint16_t</span> mod_date;       <span class="hljs-comment">/* Modification date. */</span>
        <span class="hljs-keyword">uint32_t</span> crc32;          <span class="hljs-comment">/* CRC-32 checksum. */</span>
        <span class="hljs-keyword">uint32_t</span> comp_size;      <span class="hljs-comment">/* Compressed size. */</span>
        <span class="hljs-keyword">uint32_t</span> uncomp_size;    <span class="hljs-comment">/* Uncompressed size. */</span>
        <span class="hljs-keyword">uint16_t</span> name_len;       <span class="hljs-comment">/* Filename length. */</span>
        <span class="hljs-keyword">uint16_t</span> extra_len;      <span class="hljs-comment">/* Extra data length. */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;    <span class="hljs-comment">/* Comment length. */</span>
        <span class="hljs-keyword">uint16_t</span> disk_nbr_start; <span class="hljs-comment">/* Disk nbr. where file begins. */</span>
        <span class="hljs-keyword">uint16_t</span> int_attrs;      <span class="hljs-comment">/* Internal file attributes. */</span>
        <span class="hljs-keyword">uint32_t</span> ext_attrs;      <span class="hljs-comment">/* External file attributes. */</span>
        <span class="hljs-keyword">uint32_t</span> lfh_offset;     <span class="hljs-comment">/* Local File Header offset. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *name;     <span class="hljs-comment">/* Filename. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *extra;    <span class="hljs-comment">/* Extra data. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;  <span class="hljs-comment">/* File comment. */</span><font></font>
};<font></font>
</code></pre><br>
<code>made_by_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>extract_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encode information about the OS and version of the program used to add this item, as well as which version is needed to retrieve it. </font><font style="vertical-align: inherit;">The most important eight bits encode the operating system (for example, 0 means DOS, 3 means Unix, 10 means Windows NTFS), and the lower eight bits encode the software version. </font><font style="vertical-align: inherit;">Set the decimal value to 20, which means compatibility with PKZip 2.0. </font></font><br>
<br>
<code>gp_flag</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains different flags. </font><font style="vertical-align: inherit;">We are interested:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 0, indicating the fact of encryption of the element (we will not consider this);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And bits 1 and 2, encoding the level of Deflate compression (0 - normal, 1 - maximum, 2 - fast, 3 - very fast).</font></font></li>
</ul><br>
<code>method</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encodes a compression method. 0 - data not compressed, 8 - Delate applied. Other values ‚Äã‚Äãrelate to old or new algorithms, but almost all Zip use these two values. </font></font><br>
<br>
<code>mod_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>mod_date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contain the date and time the file was modified, encoded in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS-DOS format</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Using this code, we will convert the usual C timestamps </font></font><code>time_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to and from the MS-DOS format:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Convert DOS date and time to time_t. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">time_t</span> <span class="hljs-title">dos2ctime</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> dos_date, <span class="hljs-keyword">uint16_t</span> dos_time)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> <span class="hljs-title">tm</span> = {</span><span class="hljs-number">0</span>};<font></font>
<font></font>
        tm.tm_sec = (dos_time &amp; <span class="hljs-number">0x1f</span>) * <span class="hljs-number">2</span>;  <span class="hljs-comment">/* Bits 0--4:  Secs divided by 2. */</span>
        tm.tm_min = (dos_time &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0x3f</span>; <span class="hljs-comment">/* Bits 5--10: Minute. */</span>
        tm.tm_hour = (dos_time &gt;&gt; <span class="hljs-number">11</span>);      <span class="hljs-comment">/* Bits 11-15: Hour (0--23). */</span><font></font>
<font></font>
        tm.tm_mday = (dos_date &amp; <span class="hljs-number">0x1f</span>);          <span class="hljs-comment">/* Bits 0--4: Day (1--31). */</span>
        tm.tm_mon = ((dos_date &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0xf</span>) - <span class="hljs-number">1</span>; <span class="hljs-comment">/* Bits 5--8: Month (1--12). */</span>
        tm.tm_year = (dos_date &gt;&gt; <span class="hljs-number">9</span>) + <span class="hljs-number">80</span>;       <span class="hljs-comment">/* Bits 9--15: Year-1980. */</span><font></font>
<font></font>
        tm.tm_isdst = <span class="hljs-number">-1</span>;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> mktime(&amp;tm);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Convert time_t to DOS date and time. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ctime2dos</span><span class="hljs-params">(<span class="hljs-keyword">time_t</span> t, <span class="hljs-keyword">uint16_t</span> *dos_date, <span class="hljs-keyword">uint16_t</span> *dos_time)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">tm</span> = <span class="hljs-title">localtime</span>(&amp;<span class="hljs-title">t</span>);</span><font></font>
<font></font>
        *dos_time = <span class="hljs-number">0</span>;<font></font>
        *dos_time |= tm-&gt;tm_sec / <span class="hljs-number">2</span>;    <span class="hljs-comment">/* Bits 0--4:  Second divided by two. */</span>
        *dos_time |= tm-&gt;tm_min &lt;&lt; <span class="hljs-number">5</span>;   <span class="hljs-comment">/* Bits 5--10: Minute. */</span>
        *dos_time |= tm-&gt;tm_hour &lt;&lt; <span class="hljs-number">11</span>; <span class="hljs-comment">/* Bits 11-15: Hour. */</span><font></font>
<font></font>
        *dos_date = <span class="hljs-number">0</span>;<font></font>
        *dos_date |= tm-&gt;tm_mday;             <span class="hljs-comment">/* Bits 0--4:  Day (1--31). */</span>
        *dos_date |= (tm-&gt;tm_mon + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">5</span>;   <span class="hljs-comment">/* Bits 5--8:  Month (1--12). */</span>
        *dos_date |= (tm-&gt;tm_year - <span class="hljs-number">80</span>) &lt;&lt; <span class="hljs-number">9</span>; <span class="hljs-comment">/* Bits 9--15: Year from 1980. */</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The field </font></font><code>crc32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value of the cyclic redundant code of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uncompressed data. It is used to verify data integrity after retrieval. Implementation here: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crc32.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<code>comp_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>uncomp_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contain the compressed and uncompressed size of the item file data. The following three fields contain the length of the name, comment, and additional data immediately following the title. </font></font><code>disk_nbr_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Designed for archives using multiple diskettes. </font></font><br>
<br>
<code>int_attrs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>ext_attrs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">describe the internal and external attributes of the file. Internal ones relate to the contents of the file, for example, the least significant bit indicates whether the file contains only text. External attributes indicate whether the file is hidden, read-only, etc. The content of these fields depends on the OS, in particular, on</font></font><code>made_by_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In DOS, the lower 8 bits contain the file attribute byte, which can be obtained from the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Int 21 / AX = 4300h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> system call </font><font style="vertical-align: inherit;">. For example, bit 4 means that it is a directory, and bit 5 means that the ‚Äúarchive‚Äù attribute is set (true for most files in DOS). As far as I understand, for the sake of compatibility, these bits are similarly set in other OSs. On Unix, the high 16 bits of this field contain file mode bits that are returned by </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stat (2)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><code>st_mode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>lfh_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tells us where to look for the local file header. </font></font><code>name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- file name (C-line), and </font></font><code>comment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- optional comment for this archive element (C-line). </font></font><code>extra</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">may contain optional additional data such as information about the owner of the Unix file, more accurate date and time of the change, or Zip64 fields.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This function is used to read the central headers of files:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Size of a Central File Header, not including name, extra, and comment. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFH_BASE_SZ 46</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFH_SIGNATURE 0x02014b50 <span class="hljs-comment">/* "PK\1\2" little-endian. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">read_cfh</span><span class="hljs-params">(struct cfh *cfh, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len,
                     <span class="hljs-keyword">size_t</span> offset)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint32_t</span> signature;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (offset &gt; src_len || src_len - offset &lt; CFH_BASE_SZ) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        p = &amp;src[offset];<font></font>
        signature = READ32(p);<font></font>
        <span class="hljs-keyword">if</span> (signature != CFH_SIGNATURE) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        cfh-&gt;made_by_ver = READ16(p);<font></font>
        cfh-&gt;extract_ver = READ16(p);<font></font>
        cfh-&gt;gp_flag = READ16(p);<font></font>
        cfh-&gt;method = READ16(p);<font></font>
        cfh-&gt;mod_time = READ16(p);<font></font>
        cfh-&gt;mod_date = READ16(p);<font></font>
        cfh-&gt;crc32 = READ32(p);<font></font>
        cfh-&gt;comp_size = READ32(p);<font></font>
        cfh-&gt;uncomp_size = READ32(p);<font></font>
        cfh-&gt;name_len = READ16(p);<font></font>
        cfh-&gt;extra_len = READ16(p);<font></font>
        cfh-&gt;comment_len = READ16(p);<font></font>
        cfh-&gt;disk_nbr_start = READ16(p);<font></font>
        cfh-&gt;int_attrs = READ16(p);<font></font>
        cfh-&gt;ext_attrs = READ32(p);<font></font>
        cfh-&gt;lfh_offset = READ32(p);<font></font>
        cfh-&gt;name = p;<font></font>
        cfh-&gt;extra = cfh-&gt;name + cfh-&gt;name_len;<font></font>
        cfh-&gt;comment = cfh-&gt;extra + cfh-&gt;extra_len;<font></font>
        assert(p == &amp;src[offset + CFH_BASE_SZ] &amp;&amp; <span class="hljs-string">"All fields read."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (src_len - offset - CFH_BASE_SZ &lt;<font></font>
            cfh-&gt;name_len + cfh-&gt;extra_len + cfh-&gt;comment_len) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">write_cfh</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">const</span> struct cfh *cfh)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p = dst;<font></font>
<font></font>
        WRITE32(p, CFH_SIGNATURE);<font></font>
        WRITE16(p, cfh-&gt;made_by_ver);<font></font>
        WRITE16(p, cfh-&gt;extract_ver);<font></font>
        WRITE16(p, cfh-&gt;gp_flag);<font></font>
        WRITE16(p, cfh-&gt;method);<font></font>
        WRITE16(p, cfh-&gt;mod_time);<font></font>
        WRITE16(p, cfh-&gt;mod_date);<font></font>
        WRITE32(p, cfh-&gt;crc32);<font></font>
        WRITE32(p, cfh-&gt;comp_size);<font></font>
        WRITE32(p, cfh-&gt;uncomp_size);<font></font>
        WRITE16(p, cfh-&gt;name_len);<font></font>
        WRITE16(p, cfh-&gt;extra_len);<font></font>
        WRITE16(p, cfh-&gt;comment_len);<font></font>
        WRITE16(p, cfh-&gt;disk_nbr_start);<font></font>
        WRITE16(p, cfh-&gt;int_attrs);<font></font>
        WRITE32(p, cfh-&gt;ext_attrs);<font></font>
        WRITE32(p, cfh-&gt;lfh_offset);<font></font>
        assert(p - dst == CFH_BASE_SZ);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (cfh-&gt;name_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, cfh-&gt;name, cfh-&gt;name_len);<font></font>
                p += cfh-&gt;name_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (cfh-&gt;extra_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, cfh-&gt;extra, cfh-&gt;extra_len);<font></font>
                p += cfh-&gt;extra_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (cfh-&gt;comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, cfh-&gt;comment, cfh-&gt;comment_len);<font></font>
                p += cfh-&gt;comment_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">size_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="22"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Local file header</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The data of each archive element is preceded by a local file header, which repeats most of the information from the central header. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The duplication of data in the central and local headers was probably introduced so that PKZip would not keep the entire central directory in memory when unpacking. Instead, as each file is extracted, its name and other information can be read from the local header. In addition, local headers are useful for recovering files from Zip archives in which the central directory is missing or damaged. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, this redundancy is also the main source of uncertainty. For example, what happens if the file names in the central and local headers do not match? This often leads to bugs and security issues.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Not all information from the central heading is duplicated. </font><font style="vertical-align: inherit;">For example, fields with file attributes. </font><font style="vertical-align: inherit;">In addition, if the third least significant bit </font></font><code>gp_flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(CRC-32) is </font><font style="vertical-align: inherit;">specified </font><font style="vertical-align: inherit;">, then the compressed and uncompressed fields will be reset to zero, and this information can be found in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Descriptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> block </font><font style="vertical-align: inherit;">after the data of the file itself (we will not consider it). </font><font style="vertical-align: inherit;">This allows you to record a local header before the file size of the element is known or to what size it will be compressed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The local header begins with the signature 'P', 'K', 3, 4, and then there is such a structure:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Local File Header. */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> {</span>
        <span class="hljs-keyword">uint16_t</span> extract_ver;
        <span class="hljs-keyword">uint16_t</span> gp_flag;
        <span class="hljs-keyword">uint16_t</span> method;
        <span class="hljs-keyword">uint16_t</span> mod_time;
        <span class="hljs-keyword">uint16_t</span> mod_date;
        <span class="hljs-keyword">uint32_t</span> crc32;
        <span class="hljs-keyword">uint32_t</span> comp_size;
        <span class="hljs-keyword">uint32_t</span> uncomp_size;
        <span class="hljs-keyword">uint16_t</span> name_len;
        <span class="hljs-keyword">uint16_t</span> extra_len;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *name;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *extra;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These functions read and write local headers, like other data structures:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Size of a Local File Header, not including name and extra. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LFH_BASE_SZ 30</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LFH_SIGNATURE 0x04034b50 <span class="hljs-comment">/* "PK\3\4" little-endian. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">read_lfh</span><span class="hljs-params">(struct lfh *lfh, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len,
                     <span class="hljs-keyword">size_t</span> offset)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint32_t</span> signature;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (offset &gt; src_len || src_len - offset &lt; LFH_BASE_SZ) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        p = &amp;src[offset];<font></font>
        signature = READ32(p);<font></font>
        <span class="hljs-keyword">if</span> (signature != LFH_SIGNATURE) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        lfh-&gt;extract_ver = READ16(p);<font></font>
        lfh-&gt;gp_flag = READ16(p);<font></font>
        lfh-&gt;method = READ16(p);<font></font>
        lfh-&gt;mod_time = READ16(p);<font></font>
        lfh-&gt;mod_date = READ16(p);<font></font>
        lfh-&gt;crc32 = READ32(p);<font></font>
        lfh-&gt;comp_size = READ32(p);<font></font>
        lfh-&gt;uncomp_size = READ32(p);<font></font>
        lfh-&gt;name_len = READ16(p);<font></font>
        lfh-&gt;extra_len = READ16(p);<font></font>
        lfh-&gt;name = p;<font></font>
        lfh-&gt;extra = lfh-&gt;name + lfh-&gt;name_len;<font></font>
        assert(p == &amp;src[offset + LFH_BASE_SZ] &amp;&amp; <span class="hljs-string">"All fields read."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (src_len - offset - LFH_BASE_SZ &lt; lfh-&gt;name_len + lfh-&gt;extra_len) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">write_lfh</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">const</span> struct lfh *lfh)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p = dst;<font></font>
<font></font>
        WRITE32(p, LFH_SIGNATURE);<font></font>
        WRITE16(p, lfh-&gt;extract_ver);<font></font>
        WRITE16(p, lfh-&gt;gp_flag);<font></font>
        WRITE16(p, lfh-&gt;method);<font></font>
        WRITE16(p, lfh-&gt;mod_time);<font></font>
        WRITE16(p, lfh-&gt;mod_date);<font></font>
        WRITE32(p, lfh-&gt;crc32);<font></font>
        WRITE32(p, lfh-&gt;comp_size);<font></font>
        WRITE32(p, lfh-&gt;uncomp_size);<font></font>
        WRITE16(p, lfh-&gt;name_len);<font></font>
        WRITE16(p, lfh-&gt;extra_len);<font></font>
        assert(p - dst == LFH_BASE_SZ);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (lfh-&gt;name_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, lfh-&gt;name, lfh-&gt;name_len);<font></font>
                p += lfh-&gt;name_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (lfh-&gt;extra_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, lfh-&gt;extra, lfh-&gt;extra_len);<font></font>
                p += lfh-&gt;extra_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">size_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="23"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementation of Zip Read</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using the above functions, we implement the reading of the Zip file into memory and get an iterator for accessing the archive elements:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">size_t</span> <span class="hljs-keyword">zipiter_t</span>; <span class="hljs-comment">/* Zip archive member iterator. */</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zip_t</span> <span class="hljs-title">zip_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zip_t</span> {</span>
        <span class="hljs-keyword">uint16_t</span> num_members;    <span class="hljs-comment">/* Number of members. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;  <span class="hljs-comment">/* Zip file comment (not terminated). */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;    <span class="hljs-comment">/* Zip file comment length. */</span>
        <span class="hljs-keyword">zipiter_t</span> members_begin; <span class="hljs-comment">/* Iterator to the first member. */</span>
        <span class="hljs-keyword">zipiter_t</span> members_end;   <span class="hljs-comment">/* Iterator to the end of members. */</span><font></font>
<font></font>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src;
        <span class="hljs-keyword">size_t</span> src_len;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize zip based on the source data. Returns true on success, or false
   if the data could not be parsed as a valid Zip file. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">zip_read</span><span class="hljs-params">(<span class="hljs-keyword">zip_t</span> *zip, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eocdr</span> <span class="hljs-title">eocdr</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> <span class="hljs-title">cfh</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> <span class="hljs-title">lfh</span>;</span>
        <span class="hljs-keyword">size_t</span> i, offset;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comp_data;<font></font>
<font></font>
        zip-&gt;src = src;<font></font>
        zip-&gt;src_len = src_len;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!find_eocdr(&amp;eocdr, src, src_len)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (eocdr.disk_nbr != <span class="hljs-number">0</span> || eocdr.cd_start_disk != <span class="hljs-number">0</span> ||<font></font>
            eocdr.disk_cd_entries != eocdr.cd_entries) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Cannot handle multi-volume archives. */</span><font></font>
        }<font></font>
<font></font>
        zip-&gt;num_members = eocdr.cd_entries;<font></font>
        zip-&gt;comment = eocdr.comment;<font></font>
        zip-&gt;comment_len = eocdr.comment_len;<font></font>
<font></font>
        offset = eocdr.cd_offset;<font></font>
        zip-&gt;members_begin = offset;<font></font>
<font></font>
        <span class="hljs-comment">/* Read the member info and do a few checks. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; eocdr.cd_entries; i++) {
                <span class="hljs-keyword">if</span> (!read_cfh(&amp;cfh, src, src_len, offset)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (cfh.gp_flag &amp; <span class="hljs-number">1</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* The member is encrypted. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (cfh.method != ZIP_STORED &amp;&amp; cfh.method != ZIP_DEFLATED) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Unsupported compression method. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (cfh.method == ZIP_STORED &amp;&amp;<font></font>
                    cfh.uncomp_size != cfh.comp_size) {<font></font>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (cfh.disk_nbr_start != <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Cannot handle multi-volume archives. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memchr</span>(cfh.name, <span class="hljs-string">'\0'</span>, cfh.name_len) != <span class="hljs-literal">NULL</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Bad filename. */</span><font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (!read_lfh(&amp;lfh, src, src_len, cfh.lfh_offset)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
<font></font>
                comp_data = lfh.extra + lfh.extra_len;<font></font>
                <span class="hljs-keyword">if</span> (cfh.comp_size &gt; src_len - (<span class="hljs-keyword">size_t</span>)(comp_data - src)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Member data does not fit in src. */</span><font></font>
                }<font></font>
<font></font>
                offset += CFH_BASE_SZ + cfh.name_len + cfh.extra_len +<font></font>
                          cfh.comment_len;<font></font>
        }<font></font>
<font></font>
        zip-&gt;members_end = offset;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As I mentioned above, element iterators are simply offsets to the central file header through which you can access element data:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> { ZIP_STORED = <span class="hljs-number">0</span>, ZIP_DEFLATED = <span class="hljs-number">8</span> } <span class="hljs-keyword">method_t</span>;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zipmemb_t</span> <span class="hljs-title">zipmemb_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zipmemb_t</span> {</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *name;      <span class="hljs-comment">/* Member name (not null terminated). */</span>
        <span class="hljs-keyword">uint16_t</span> name_len;        <span class="hljs-comment">/* Member name length. */</span>
        <span class="hljs-keyword">time_t</span> mtime;             <span class="hljs-comment">/* Modification time. */</span>
        <span class="hljs-keyword">uint32_t</span> comp_size;       <span class="hljs-comment">/* Compressed size. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comp_data; <span class="hljs-comment">/* Compressed data. */</span>
        <span class="hljs-keyword">method_t</span> method;          <span class="hljs-comment">/* Compression method. */</span>
        <span class="hljs-keyword">uint32_t</span> uncomp_size;     <span class="hljs-comment">/* Uncompressed size. */</span>
        <span class="hljs-keyword">uint32_t</span> crc32;           <span class="hljs-comment">/* CRC-32 checksum. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;   <span class="hljs-comment">/* Comment (not null terminated). */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;     <span class="hljs-comment">/* Comment length. */</span>
        <span class="hljs-keyword">bool</span> is_dir;              <span class="hljs-comment">/* Whether this is a directory. */</span>
        <span class="hljs-keyword">zipiter_t</span> next;           <span class="hljs-comment">/* Iterator to the next member. */</span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Get the Zip archive member through iterator it. */</span>
<span class="hljs-function"><span class="hljs-keyword">zipmemb_t</span> <span class="hljs-title">zip_member</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">zip_t</span> *zip, <span class="hljs-keyword">zipiter_t</span> it)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> <span class="hljs-title">cfh</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> <span class="hljs-title">lfh</span>;</span>
        <span class="hljs-keyword">bool</span> ok;
        <span class="hljs-keyword">zipmemb_t</span> m;<font></font>
<font></font>
        assert(it &gt;= zip-&gt;members_begin &amp;&amp; it &lt; zip-&gt;members_end);<font></font>
<font></font>
        ok = read_cfh(&amp;cfh, zip-&gt;src, zip-&gt;src_len, it);<font></font>
        assert(ok);<font></font>
<font></font>
        ok = read_lfh(&amp;lfh, zip-&gt;src, zip-&gt;src_len, cfh.lfh_offset);<font></font>
        assert(ok);<font></font>
<font></font>
        m.name = cfh.name;<font></font>
        m.name_len = cfh.name_len;<font></font>
        m.mtime = dos2ctime(cfh.mod_date, cfh.mod_time);<font></font>
        m.comp_size = cfh.comp_size;<font></font>
        m.comp_data = lfh.extra + lfh.extra_len;<font></font>
        m.method = cfh.method;<font></font>
        m.uncomp_size = cfh.uncomp_size;<font></font>
        m.crc32 = cfh.crc32;<font></font>
        m.comment = cfh.comment;<font></font>
        m.comment_len = cfh.comment_len;<font></font>
        m.is_dir = (cfh.ext_attrs &amp; EXT_ATTR_DIR) != <span class="hljs-number">0</span>;<font></font>
<font></font>
        m.next = it + CFH_BASE_SZ +<font></font>
                 cfh.name_len + cfh.extra_len + cfh.comment_len;<font></font>
<font></font>
        assert(m.next &lt;= zip-&gt;members_end);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> m;<font></font>
}<font></font>
</code></pre><br>
<a name="24"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zip Record Implementation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To write a zip file to the memory buffer, you first need to find out how much memory to allocate for it. </font><font style="vertical-align: inherit;">And since we do not know how much data we will compress before we try to write, we will calculate the upper boundary based on the sizes of the uncompressed elements:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Compute an upper bound on the dst size required by zip_write() for an
 * archive with num_memb members with certain filenames, sizes, and archive
 * comment. Returns zero on error, e.g. if a filename is longer than 2^16-1, or
 * if the total file size is larger than 2^32-1. */</span>
<span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">zip_max_size</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> num_memb, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *filenames,
                      <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *file_sizes, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *comment)</span>
</span>{
        <span class="hljs-keyword">size_t</span> comment_len, name_len;
        <span class="hljs-keyword">uint64_t</span> total;
        <span class="hljs-keyword">uint16_t</span> i;<font></font>
<font></font>
        comment_len = (comment == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">strlen</span>(comment));
        <span class="hljs-keyword">if</span> (comment_len &gt; UINT16_MAX) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        total = EOCDR_BASE_SZ + comment_len; <span class="hljs-comment">/* EOCDR */</span><font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_memb; i++) {<font></font>
                assert(filenames[i] != <span class="hljs-literal">NULL</span>);<font></font>
                name_len = <span class="hljs-built_in">strlen</span>(filenames[i]);
                <span class="hljs-keyword">if</span> (name_len &gt; UINT16_MAX) {
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
                }<font></font>
<font></font>
                total += CFH_BASE_SZ + name_len; <span class="hljs-comment">/* Central File Header */</span>
                total += LFH_BASE_SZ + name_len; <span class="hljs-comment">/* Local File Header */</span>
                total += file_sizes[i];          <span class="hljs-comment">/* Uncompressed data size. */</span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (total &gt; UINT32_MAX) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">uint32_t</span>)total;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This code writes the zip file using the deflate compression of each element, reducing their size:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Write a Zip file containing num_memb members into dst, which must be large
   enough to hold the resulting data. Returns the number of bytes written, which
   is guaranteed to be less than or equal to the result of zip_max_size() when
   called with the corresponding arguments. comment shall be a null-terminated
   string or null. callback shall be null or point to a function which will
   get called after the compression of each member. */</span>
<span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">zip_write</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">uint16_t</span> num_memb,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *filenames,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-keyword">const</span> *file_data,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *file_sizes,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">time_t</span> *mtimes,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *comment,
                   <span class="hljs-keyword">void</span> (*callback)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">uint32_t</span> size,
                                    <span class="hljs-keyword">uint32_t</span> comp_size))</span>
</span>{
        <span class="hljs-keyword">uint16_t</span> i;
        <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eocdr</span> <span class="hljs-title">eocdr</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> <span class="hljs-title">cfh</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> <span class="hljs-title">lfh</span>;</span>
        <span class="hljs-keyword">bool</span> ok;
        <span class="hljs-keyword">uint16_t</span> name_len;
        <span class="hljs-keyword">uint8_t</span> *data_dst;
        <span class="hljs-keyword">size_t</span> comp_sz;
        <span class="hljs-keyword">uint32_t</span> lfh_offset, cd_offset, eocdr_offset;<font></font>
<font></font>
        p = dst;<font></font>
<font></font>
        <span class="hljs-comment">/* Write Local File Headers and deflated or stored data. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_memb; i++) {<font></font>
                assert(filenames[i] != <span class="hljs-literal">NULL</span>);<font></font>
                assert(<span class="hljs-built_in">strlen</span>(filenames[i]) &lt;= UINT16_MAX);<font></font>
                name_len = (<span class="hljs-keyword">uint16_t</span>)<span class="hljs-built_in">strlen</span>(filenames[i]);<font></font>
<font></font>
                data_dst = p + LFH_BASE_SZ + name_len;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (hwdeflate(file_data[i], file_sizes[i], data_dst,<font></font>
                              file_sizes[i], &amp;comp_sz) &amp;&amp;<font></font>
                                comp_sz &lt; file_sizes[i]) {<font></font>
                        lfh.method = ZIP_DEFLATED;<font></font>
                        assert(comp_sz &lt;= UINT32_MAX);<font></font>
                        lfh.comp_size = (<span class="hljs-keyword">uint32_t</span>)comp_sz;<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-built_in">memcpy</span>(data_dst, file_data[i], file_sizes[i]);<font></font>
                        lfh.method = ZIP_STORED;<font></font>
                        lfh.comp_size = file_sizes[i];<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">NULL</span>) {<font></font>
                        callback(filenames[i], file_sizes[i], lfh.comp_size);<font></font>
                }<font></font>
<font></font>
                lfh.extract_ver = (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">8</span>) | <span class="hljs-number">20</span>; <span class="hljs-comment">/* DOS | PKZIP 2.0 */</span>
                lfh.gp_flag = (lfh.method == ZIP_DEFLATED ? (<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">1</span>) : <span class="hljs-number">0x0</span>);<font></font>
                ctime2dos(mtimes[i], &amp;lfh.mod_date, &amp;lfh.mod_time);<font></font>
                lfh.crc32 = crc32(file_data[i], file_sizes[i]);<font></font>
                lfh.uncomp_size = file_sizes[i];<font></font>
                lfh.name_len = name_len;<font></font>
                lfh.extra_len = <span class="hljs-number">0</span>;<font></font>
                lfh.name = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>*)filenames[i];<font></font>
                p += write_lfh(p, &amp;lfh);<font></font>
                p += lfh.comp_size;<font></font>
        }<font></font>
<font></font>
        assert(p - dst &lt;= UINT32_MAX);<font></font>
        cd_offset = (<span class="hljs-keyword">uint32_t</span>)(p - dst);<font></font>
<font></font>
        <span class="hljs-comment">/* Write the Central Directory based on the Local File Headers. */</span>
        lfh_offset = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_memb; i++) {<font></font>
                ok = read_lfh(&amp;lfh, dst, SIZE_MAX, lfh_offset);<font></font>
                assert(ok);<font></font>
<font></font>
                cfh.made_by_ver = lfh.extract_ver;<font></font>
                cfh.extract_ver = lfh.extract_ver;<font></font>
                cfh.gp_flag = lfh.gp_flag;<font></font>
                cfh.method = lfh.method;<font></font>
                cfh.mod_time = lfh.mod_time;<font></font>
                cfh.mod_date = lfh.mod_date;<font></font>
                cfh.crc32 = lfh.crc32;<font></font>
                cfh.comp_size = lfh.comp_size;<font></font>
                cfh.uncomp_size = lfh.uncomp_size;<font></font>
                cfh.name_len = lfh.name_len;<font></font>
                cfh.extra_len = <span class="hljs-number">0</span>;<font></font>
                cfh.comment_len = <span class="hljs-number">0</span>;<font></font>
                cfh.disk_nbr_start = <span class="hljs-number">0</span>;<font></font>
                cfh.int_attrs = <span class="hljs-number">0</span>;<font></font>
                cfh.ext_attrs = EXT_ATTR_ARC;<font></font>
                cfh.lfh_offset = lfh_offset;<font></font>
                cfh.name = lfh.name;<font></font>
                p += write_cfh(p, &amp;cfh);<font></font>
<font></font>
                lfh_offset += LFH_BASE_SZ + lfh.name_len + lfh.comp_size;<font></font>
        }<font></font>
<font></font>
        assert(p - dst &lt;= UINT32_MAX);<font></font>
        eocdr_offset = (<span class="hljs-keyword">uint32_t</span>)(p - dst);<font></font>
<font></font>
        <span class="hljs-comment">/* Write the End of Central Directory Record. */</span>
        eocdr.disk_nbr = <span class="hljs-number">0</span>;<font></font>
        eocdr.cd_start_disk = <span class="hljs-number">0</span>;<font></font>
        eocdr.disk_cd_entries = num_memb;<font></font>
        eocdr.cd_entries = num_memb;<font></font>
        eocdr.cd_size = eocdr_offset - cd_offset;<font></font>
        eocdr.cd_offset = cd_offset;<font></font>
        eocdr.comment_len = (<span class="hljs-keyword">uint16_t</span>)(comment == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">strlen</span>(comment));<font></font>
        eocdr.comment = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>*)comment;<font></font>
        p += write_eocdr(p, &amp;eocdr);<font></font>
<font></font>
        assert(p - dst &lt;= zip_max_size(num_memb, filenames, file_sizes,<font></font>
                                       comment));<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">uint32_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="25"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hwzip</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we know how to read and write Zip files, how to compress and decompress the data stored in them. </font><font style="vertical-align: inherit;">Now let's write a simple Zip program containing all of these tools. </font><font style="vertical-align: inherit;">The code is available at </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hwzip.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will use a macro for simple error handling and several auxiliary functions for checked memory allocation:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PERROR_IF(cond, msg) <span class="hljs-meta-keyword">if</span> (cond) { perror(msg); exit(1); }</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">xmalloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span>
</span>{
        <span class="hljs-keyword">void</span> *ptr = <span class="hljs-built_in">malloc</span>(size);<font></font>
        PERROR_IF(ptr == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"malloc"</span>);
        <span class="hljs-keyword">return</span> ptr;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">xrealloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">size_t</span> size)</span>
</span>{<font></font>
        ptr = <span class="hljs-built_in">realloc</span>(ptr, size);<font></font>
        PERROR_IF(ptr == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"realloc"</span>);
        <span class="hljs-keyword">return</span> ptr;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The other two functions are used to read and write files:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-title">read_file</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">size_t</span> *file_sz)</span>
</span>{<font></font>
        FILE *f;<font></font>
        <span class="hljs-keyword">uint8_t</span> *buf;
        <span class="hljs-keyword">size_t</span> buf_cap;<font></font>
<font></font>
        f = fopen(filename, <span class="hljs-string">"rb"</span>);<font></font>
        PERROR_IF(f == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"fopen"</span>);<font></font>
<font></font>
        buf_cap = <span class="hljs-number">4096</span>;<font></font>
        buf = xmalloc(buf_cap);<font></font>
<font></font>
        *file_sz = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (feof(f) == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (buf_cap - *file_sz == <span class="hljs-number">0</span>) {<font></font>
                        buf_cap *= <span class="hljs-number">2</span>;<font></font>
                        buf = xrealloc(buf, buf_cap);<font></font>
                }<font></font>
<font></font>
                *file_sz += fread(&amp;buf[*file_sz], <span class="hljs-number">1</span>, buf_cap - *file_sz, f);<font></font>
                PERROR_IF(ferror(f), <span class="hljs-string">"fread"</span>);<font></font>
        }<font></font>
<font></font>
        PERROR_IF(fclose(f) != <span class="hljs-number">0</span>, <span class="hljs-string">"fclose"</span>);
        <span class="hljs-keyword">return</span> buf;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write_file</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">size_t</span> n)</span>
</span>{<font></font>
        FILE *f;<font></font>
<font></font>
        f = fopen(filename, <span class="hljs-string">"wb"</span>);<font></font>
        PERROR_IF(f == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"fopen"</span>);<font></font>
        PERROR_IF(fwrite(data, <span class="hljs-number">1</span>, n, f) != n, <span class="hljs-string">"fwrite"</span>);<font></font>
        PERROR_IF(fclose(f) != <span class="hljs-number">0</span>, <span class="hljs-string">"fclose"</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our Zip program can perform three functions: make a list of the contents of Zip files and extract it, as well as create Zip files. </font><font style="vertical-align: inherit;">Listing is nowhere easier:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list_zip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *zip_data;
        <span class="hljs-keyword">size_t</span> zip_sz;
        <span class="hljs-keyword">zip_t</span> z;
        <span class="hljs-keyword">zipiter_t</span> it;
        <span class="hljs-keyword">zipmemb_t</span> m;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Listing ZIP archive: %s\n\n"</span>, filename);<font></font>
<font></font>
        zip_data = read_file(filename, &amp;zip_sz);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!zip_read(&amp;z, zip_data, zip_sz)) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Failed to parse ZIP file!\n"</span>);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (z.comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.*s\n\n"</span>, (<span class="hljs-keyword">int</span>)z.comment_len, z.comment);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (it = z.members_begin; it != z.members_end; it = m.next) {<font></font>
                m = zip_member(&amp;z, it);<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.*s\n"</span>, (<span class="hljs-keyword">int</span>)m.name_len, m.name);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
        <span class="hljs-built_in">free</span>(zip_data);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The extraction is a little more complicated. </font><font style="vertical-align: inherit;">We will use auxiliary functions for null termination of the file name (to pass it to </font></font><code>fopen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and unpacking:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">terminate_str</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">char</span> *p = xmalloc(n + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">memcpy</span>(p, str, n);<font></font>
        p[n] = <span class="hljs-string">'\0'</span>;
        <span class="hljs-keyword">return</span> p;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-title">inflate_member</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">zipmemb_t</span> *m)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">size_t</span> src_used, dst_used;<font></font>
<font></font>
        assert(m-&gt;method == ZIP_DEFLATED);<font></font>
<font></font>
        p = xmalloc(m-&gt;uncomp_size);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (hwinflate(m-&gt;comp_data, m-&gt;comp_size, &amp;src_used, p, m-&gt;uncomp_size,<font></font>
                      &amp;dst_used) != HWINF_OK) {<font></font>
                <span class="hljs-built_in">free</span>(p);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (src_used != m-&gt;comp_size || dst_used != m-&gt;uncomp_size) {
                <span class="hljs-built_in">free</span>(p);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> p;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our program will skip any archive elements that have directories. </font><font style="vertical-align: inherit;">This is done in order to avoid the so-called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">path traversal attacks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : a malicious archive is used to write the file from outside the directory specified by the user. </font><font style="vertical-align: inherit;">Read the details in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Info-ZIP FAQ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">extract_zip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *zip_data;
        <span class="hljs-keyword">size_t</span> zip_sz;
        <span class="hljs-keyword">zip_t</span> z;
        <span class="hljs-keyword">zipiter_t</span> it;
        <span class="hljs-keyword">zipmemb_t</span> m;
        <span class="hljs-keyword">char</span> *tname;
        <span class="hljs-keyword">uint8_t</span> *inflated;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *uncomp_data;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Extracting ZIP archive: %s\n\n"</span>, filename);<font></font>
<font></font>
        zip_data = read_file(filename, &amp;zip_sz);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!zip_read(&amp;z, zip_data, zip_sz)) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Failed to read ZIP file!\n"</span>);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (z.comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.*s\n\n"</span>, (<span class="hljs-keyword">int</span>)z.comment_len, z.comment);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (it = z.members_begin; it != z.members_end; it = m.next) {<font></font>
                m = zip_member(&amp;z, it);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (m.is_dir) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" (Skipping dir: %.*s)\n"</span>,<font></font>
                               (<span class="hljs-keyword">int</span>)m.name_len, m.name);
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memchr</span>(m.name, <span class="hljs-string">'/'</span>,  m.name_len) != <span class="hljs-literal">NULL</span> ||
                    <span class="hljs-built_in">memchr</span>(m.name, <span class="hljs-string">'\\'</span>, m.name_len) != <span class="hljs-literal">NULL</span>) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" (Skipping file in dir: %.*s)\n"</span>,<font></font>
                               (<span class="hljs-keyword">int</span>)m.name_len, m.name);
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                assert(m.method == ZIP_STORED || m.method == ZIP_DEFLATED);<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %s: %.*s"</span>,<font></font>
                       m.method == ZIP_STORED ? <span class="hljs-string">"Extracting"</span> : <span class="hljs-string">" Inflating"</span>,<font></font>
                       (<span class="hljs-keyword">int</span>)m.name_len, m.name);<font></font>
                fflush(<span class="hljs-built_in">stdout</span>);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (m.method == ZIP_STORED) {<font></font>
                        assert(m.uncomp_size == m.comp_size);<font></font>
                        inflated = <span class="hljs-literal">NULL</span>;<font></font>
                        uncomp_data = m.comp_data;<font></font>
                } <span class="hljs-keyword">else</span> {<font></font>
                        inflated = inflate_member(&amp;m);<font></font>
                        <span class="hljs-keyword">if</span> (inflated == <span class="hljs-literal">NULL</span>) {
                                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error: inflation failed!\n"</span>);
                                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
                        }<font></font>
                        uncomp_data = inflated;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (crc32(uncomp_data, m.uncomp_size) != m.crc32) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error: CRC-32 mismatch!\n"</span>);
                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
                }<font></font>
<font></font>
                tname = terminate_str((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)m.name, m.name_len);<font></font>
                write_file(tname, uncomp_data, m.uncomp_size);<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
                <span class="hljs-built_in">free</span>(inflated);
                <span class="hljs-built_in">free</span>(tname);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        <span class="hljs-built_in">free</span>(zip_data);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To create a zip archive, we will read the input files and feed them </font></font><code>zip_write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Since the standard C library does not allow you to get the file modification time, we will use the current time (I leave this as a homework to fix this feature).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">zip_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">uint32_t</span> size, <span class="hljs-keyword">uint32_t</span> comp_size)</span>
</span>{
        <span class="hljs-keyword">bool</span> deflated = comp_size &lt; size;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %s: %s"</span>, deflated ? <span class="hljs-string">"Deflated"</span> : <span class="hljs-string">"  Stored"</span>, filename);
        <span class="hljs-keyword">if</span> (deflated) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" (%u%%)"</span>, <span class="hljs-number">100</span> - <span class="hljs-number">100</span> * comp_size / size);<font></font>
        }<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create_zip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *zip_filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *comment,
                       <span class="hljs-keyword">uint16_t</span> n, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *filenames)</span>
</span>{
        <span class="hljs-keyword">time_t</span> mtime;
        <span class="hljs-keyword">time_t</span> *mtimes;
        <span class="hljs-keyword">uint8_t</span> **file_data;
        <span class="hljs-keyword">uint32_t</span> *file_sizes;
        <span class="hljs-keyword">size_t</span> file_size, zip_size;
        <span class="hljs-keyword">uint8_t</span> *zip_data;
        <span class="hljs-keyword">uint16_t</span> i;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Creating ZIP archive: %s\n\n"</span>, zip_filename);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (comment != <span class="hljs-literal">NULL</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n\n"</span>, comment);<font></font>
        }<font></font>
<font></font>
        mtime = time(<span class="hljs-literal">NULL</span>);<font></font>
<font></font>
        file_data = xmalloc(<span class="hljs-keyword">sizeof</span>(*file_data) * n);<font></font>
        file_sizes = xmalloc(<span class="hljs-keyword">sizeof</span>(*file_sizes) * n);<font></font>
        mtimes = xmalloc(<span class="hljs-keyword">sizeof</span>(*mtimes) * n);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                file_data[i] = read_file(filenames[i], &amp;file_size);<font></font>
                <span class="hljs-keyword">if</span> (file_size &gt;= UINT32_MAX) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s is too large!\n"</span>, filenames[i]);
                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
                }<font></font>
                file_sizes[i] = (<span class="hljs-keyword">uint32_t</span>)file_size;<font></font>
                mtimes[i] = mtime;<font></font>
        }<font></font>
<font></font>
        zip_size = zip_max_size(n, filenames, file_sizes, comment);<font></font>
        <span class="hljs-keyword">if</span> (zip_size == <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"zip writing not possible"</span>);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        zip_data = xmalloc(zip_size);<font></font>
        zip_size = zip_write(zip_data, n, filenames,<font></font>
                             (<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-keyword">const</span> *)file_data,<font></font>
                             file_sizes, mtimes, comment, zip_callback);<font></font>
<font></font>
        write_file(zip_filename, zip_data, zip_size);<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
        <span class="hljs-built_in">free</span>(zip_data);
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {
                <span class="hljs-built_in">free</span>(file_data[i]);<font></font>
        }<font></font>
        <span class="hljs-built_in">free</span>(mtimes);
        <span class="hljs-built_in">free</span>(file_sizes);
        <span class="hljs-built_in">free</span>(file_data);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, it </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">checks the command line arguments and decides what to do:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print_usage</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *argv0)</span>
</span>{
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Usage:\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  %s list &lt;zipfile&gt;\n"</span>, argv0);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  %s extract &lt;zipfile&gt;\n"</span>, argv0);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  %s create &lt;zipfile&gt; [-c &lt;comment&gt;] &lt;files...&gt;\n"</span>, argv0);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"HWZIP "</span> VERSION <span class="hljs-string">" -- A very simple ZIP program "</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"from https://www.hanshq.net/zip.html\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"list"</span>) == <span class="hljs-number">0</span>) {<font></font>
                list_zip(argv[<span class="hljs-number">2</span>]);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"extract"</span>) == <span class="hljs-number">0</span>) {<font></font>
                extract_zip(argv[<span class="hljs-number">2</span>]);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"create"</span>) == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">5</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">3</span>], <span class="hljs-string">"-c"</span>) == <span class="hljs-number">0</span>) {<font></font>
                        create_zip(argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">4</span>], (<span class="hljs-keyword">uint16_t</span>)(argc - <span class="hljs-number">5</span>),<font></font>
                                   (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *)&amp;argv[<span class="hljs-number">5</span>]);<font></font>
                } <span class="hljs-keyword">else</span> {<font></font>
                        create_zip(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, (<span class="hljs-keyword">uint16_t</span>)(argc - <span class="hljs-number">3</span>),<font></font>
                                   (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *)&amp;argv[<span class="hljs-number">3</span>]);<font></font>
                }<font></font>
        } <span class="hljs-keyword">else</span> {<font></font>
                print_usage(argv[<span class="hljs-number">0</span>]);
                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
<a name="26"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembly instructions</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A complete set of source files is available at </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hwzip-1.0.zip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">How to compile HWZip under Linux or Mac:</font></font><br>
<br>
<pre><code class="cpp hljs">$ clang generate_tables.c &amp;&amp; ./a.out &gt; tables.c<font></font>
$ clang -O3 -DNDEBUG -march=native -o hwzip crc32.c deflate.c huffman.c \<font></font>
        hwzip.c lz77.c tables.c zip.c<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On Windows, at the developer‚Äôs command prompt in Visual Studio (if you don‚Äôt have Visual Studio, download the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">build tools</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="cpp hljs">cl /TC generate_tables.c &amp;&amp; generate_tables &gt; tables.c<font></font>
cl /O2 /DNDEBUG /MT /Fehwzip.exe /TC crc32.c deflate.c huffman.c hwzip.c<font></font>
        lz77.c tables.c zip.c /link setargv.obj<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setargv.obj for </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expanding wildcard command line arguments</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .)</font></font><br>
<br>
<a name="27"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is amazing how technology is developing rapidly and slowly. </font><font style="vertical-align: inherit;">The Zip format was created 30 years ago based on technology from the fifties and seventies. </font><font style="vertical-align: inherit;">And although much has changed since then, Zip files, in fact, have remained the same and today are more common than ever. </font><font style="vertical-align: inherit;">I think it will be useful to have a good understanding of how they work.</font></font><br>
<br>
<a name="28"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exercises</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Make HWZip record the time it took for each file to change, rather than the current time the archive was created. </font><font style="vertical-align: inherit;">Use </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stat (2)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on Linux or Mac and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetFileTime</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on Windows. </font><font style="vertical-align: inherit;">Or add a command line flag that allows the user to set a specific time for file changes.</font></font></li>
<li>              gzip-.   ‚Äî    ,    Deflate (   ).    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">RFC 1952</a>.</li>
<li>    Zip-     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">   </a>.  HWZip ,   <code>read_file</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">mmap(2)</a>  Linux  Mac  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">CreateFileMapping</a>  Windows.</li>
<li> HWZip ,          Zip64.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="> appnote.txt</a>.</li>
</ul><br>
<a name="29"></a><h2> </h2><br>
<ul>
<li>  BBS-   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">BBS: The Documentary</a>.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="> YouTube</a>.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">Part 8: Compression</a>    SEA  PKWare.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">  </a>.</li>
<li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">A better Zip bomb</a>    Zip-,    ¬´¬ª    .</li>
<li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">Zip Files All The Way Down</a> ,   <i>Zip-</i> ‚Äî ,    .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">ascii-zip</a> ‚Äî  ,  Deflate-   ASCII-.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">Rosetta Flash</a>.</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">Ten Thousand Security Pitfalls: the Zip File Format</a> ‚Äî        .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">Reading bits in far too many ways part 1</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">part 2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">part 3</a> ‚Äî       .</li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">Understanding Compression</a>      .</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en490780/index.html">Intel Xeon Scalable Gen2: Big Sale of Cores</a></li>
<li><a href="../en490782/index.html">AnalogBytes Conference: Roskomnadzor, media, highload and all-all-all</a></li>
<li><a href="../en490784/index.html">I am an Android developer and I didn‚Äôt like to do manual work.</a></li>
<li><a href="../en490786/index.html">Second order leak analysis: when it leaks from those who steal data from a bank</a></li>
<li><a href="../en490788/index.html">Useless REPL. Yandex Report</a></li>
<li><a href="../en490792/index.html">VXLAN in NSX-V - Troubled Underlay</a></li>
<li><a href="../en490796/index.html">How to automate the security of containers in the style of Policy as Code using CRD</a></li>
<li><a href="../en490804/index.html">How a hacker's mom got into prison and infected the boss‚Äôs computer</a></li>
<li><a href="../en490808/index.html">Mathematics in astronautics: rotational detonation engine</a></li>
<li><a href="../en490812/index.html">Spring Professional Certification 5 Submission Experience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>