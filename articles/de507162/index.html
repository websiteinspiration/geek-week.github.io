<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴🏾 📉 🤶🏾 Game Code Command & Conquer: Bugs aus den 90ern. Band Eins 🔸 🌘 👌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das amerikanische Unternehmen Electronic Arts Inc (EA) hat den Open-Source-Code für die Spiele Command & Conquer: Tiberian Dawn und Command & Conquer:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Game Code Command & Conquer: Bugs aus den 90ern. Band Eins</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/507162/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45c/686/581/45c686581b6cddb3473e6f0f7912deec.png" alt="image1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das amerikanische Unternehmen Electronic Arts Inc (EA) hat den Open-Source-Code für die Spiele Command &amp; Conquer: Tiberian Dawn und Command &amp; Conquer: Red Alert veröffentlicht. </font><font style="vertical-align: inherit;">Dieser Code soll Spielegemeinschaften helfen, Mods und Maps zu entwickeln, benutzerdefinierte Einheiten zu erstellen und die Spiellogik anzupassen. </font><font style="vertical-align: inherit;">Wir alle haben die einmalige Gelegenheit, in die Entwicklungsgeschichte einzutauchen, die sich stark von der modernen unterscheidet. </font><font style="vertical-align: inherit;">Dann gab es keine StackOverflow-Site, keine praktischen Code-Editoren und keine leistungsstarken Compiler. </font><font style="vertical-align: inherit;">Und dann gab es keine statischen Analysatoren, und das erste, was der Community begegnen wird, sind Hunderte von Fehlern im Code. </font><font style="vertical-align: inherit;">Das PVS-Studio-Team wird Ihnen dabei helfen und auf die Stellen dieser Fehler hinweisen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Command &amp; Conquer - eine Reihe von Computerspielen im Genre der Echtzeitstrategie. </font><font style="vertical-align: inherit;">Das erste Spiel der Serie wurde 1995 veröffentlicht. </font><font style="vertical-align: inherit;">Electronic Arts erwarb das Entwicklungsstudio für dieses Spiel erst 1998. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seitdem wurden mehrere Spiele und viele Mods veröffentlicht. </font><font style="vertical-align: inherit;">Der Quellcode für die Spiele wurde </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">veröffentlicht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der Veröffentlichung der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Command &amp; Conquer Remastered</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sammlung </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Fehler im Code zu finden, wurde der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Analysator verwendet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ein Tool zum Erkennen von Fehlern und potenziellen Schwachstellen im Quellcode von Programmen, die in C, C ++, C # und Java geschrieben wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund der großen Anzahl von Problemen im Code werden alle Fehlerbeispiele in einem Zyklus von zwei Artikeln angegeben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tippfehler und Copy-Paste</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V501 Links und rechts vom '||' befinden sich identische Unterausdrücke. </font><font style="vertical-align: inherit;">Operator: dest == 0 || </font><font style="vertical-align: inherit;">dest == 0 CONQUER.CPP 5576</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">List_Copy</span><span class="hljs-params">(<span class="hljs-keyword">short</span> <span class="hljs-keyword">const</span> * source, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">short</span> * dest)</span>
</span>{
  <span class="hljs-keyword">if</span> (dest == <span class="hljs-literal">NULL</span> || dest == <span class="hljs-literal">NULL</span>) {
    <span class="hljs-keyword">return</span>;<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte die Überprüfung mit dem ewigen Kopieren und Einfügen beginnen. </font><font style="vertical-align: inherit;">In der Funktion zum Kopieren von Listen haben sie den Quellzeiger und den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zielzeiger</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nie zweimal überprüft, da sie die Prüfung </font><i><font style="vertical-align: inherit;">dest == NULL</font></i><font style="vertical-align: inherit;"> kopiert </font><font style="vertical-align: inherit;">und vergessen haben, den Variablennamen zu ersetzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V584 Der Wert 'Current' ist auf beiden Seiten des Operators '! =' Vorhanden. </font><font style="vertical-align: inherit;">Der Ausdruck ist falsch oder kann vereinfacht werden. </font><font style="vertical-align: inherit;">CREDITS.CPP 173</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreditClass::AI</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> forced, HouseClass *player_ptr, <span class="hljs-keyword">bool</span> logic_only)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">long</span> adder = Credits - Current;<font></font>
  adder = ABS(adder);<font></font>
  adder &gt;&gt;= <span class="hljs-number">5</span>;<font></font>
  adder = Bound(adder, <span class="hljs-number">1L</span>, <span class="hljs-number">71</span>+<span class="hljs-number">72</span>);
  <span class="hljs-keyword">if</span> (Current &gt; Credits) adder = -adder;<font></font>
  Current += adder;<font></font>
  Countdown = <span class="hljs-number">1</span>;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (Current-adder != Current) {        <span class="hljs-comment">// &lt;=</span>
    IsAudible = <span class="hljs-literal">true</span>;<font></font>
    IsUp = (adder &gt; <span class="hljs-number">0</span>);<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Analysator fand einen bedeutungslosen Vergleich. </font><font style="vertical-align: inherit;">Ich nehme an, es hätte so etwas geben sollen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (Current-adder != Credits)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aber Unaufmerksamkeit gewann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Genau das gleiche Codefragment wird in eine andere Funktion kopiert:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V584 Der Wert 'Current' ist auf beiden Seiten des Operators '! =' Vorhanden. </font><font style="vertical-align: inherit;">Der Ausdruck ist falsch oder kann vereinfacht werden. </font><font style="vertical-align: inherit;">CREDITS.CPP 246</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V524 Es ist seltsam, dass der Hauptteil der Funktion 'Mono_Y' dem Hauptteil der Funktion 'Mono_X' vollständig entspricht. </font><font style="vertical-align: inherit;">MONOC.CPP 753</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonoClass</span> {</span><font></font>
  ....<font></font>
  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Get_X</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> </span>{<span class="hljs-keyword">return</span> X;};
  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Get_Y</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> </span>{<span class="hljs-keyword">return</span> Y;};<font></font>
  ....<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Mono_X</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
  <span class="hljs-keyword">if</span> (MonoClass::Is_Enabled()) {<font></font>
    MonoClass *mono = MonoClass::Get_Current();<font></font>
    <span class="hljs-keyword">if</span> (!mono) {<font></font>
      mono = <span class="hljs-keyword">new</span> MonoClass();<font></font>
      mono-&gt;View();<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span>(<span class="hljs-keyword">short</span>)mono-&gt;Get_X();                  <span class="hljs-comment">// &lt;=</span><font></font>
  }<font></font>
  <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Mono_Y</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
  <span class="hljs-keyword">if</span> (MonoClass::Is_Enabled()) {<font></font>
    MonoClass *mono = MonoClass::Get_Current();<font></font>
    <span class="hljs-keyword">if</span> (!mono) {<font></font>
      mono = <span class="hljs-keyword">new</span> MonoClass();<font></font>
      mono-&gt;View();<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span>(<span class="hljs-keyword">short</span>)mono-&gt;Get_X();                  <span class="hljs-comment">// &lt;= Get_Y() ?</span><font></font>
  }<font></font>
  <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein umfangreicherer Code, der mit den Konsequenzen kopiert wurde. </font><font style="vertical-align: inherit;">Stimmen Sie zu, außer mit dem Analysator, dann werden Sie nicht bemerken, dass die Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mono_Y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Funktion </font><i><font style="vertical-align: inherit;">Get_X</font></i><font style="vertical-align: inherit;"> aufgerufen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hat</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , stattdessen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get_Y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MonoClass-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse hat </font><font style="vertical-align: inherit;">wirklich zwei Funktionen, die sich um ein Zeichen unterscheiden. </font><font style="vertical-align: inherit;">Höchstwahrscheinlich haben wir einen echten Fehler gefunden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und unter der Datei befand sich ein identisches Codefragment:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V524 Es ist seltsam, dass der Hauptteil der Funktion 'Mono_Y' dem Hauptteil der Funktion 'Mono_X' vollständig entspricht. </font><font style="vertical-align: inherit;">MONOC.CPP 1083</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehler mit Arrays</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V557 Array-Überlauf ist möglich. </font><font style="vertical-align: inherit;">Der '9'-Index zeigt über die Array-Grenze hinaus. </font><font style="vertical-align: inherit;">FOOT.CPP 232</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  CONQUER_PATH_MAX 9 <span class="hljs-comment">// Number of cells to look ahead for movement.</span></span><font></font>
<font></font>
FacingType Path[CONQUER_PATH_MAX];<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FootClass::Debug_Dump</span><span class="hljs-params">(MonoClass *mono)</span> <span class="hljs-keyword">const</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">if</span> (What_Am_I() != RTTI_AIRCRAFT) {<font></font>
    mono-&gt;Set_Cursor(<span class="hljs-number">50</span>, <span class="hljs-number">3</span>);<font></font>
    mono-&gt;Printf(<span class="hljs-string">"%s%s%s%s%s%s%s%s%s%s%s%s"</span>,<font></font>
      Path_To_String(Path[<span class="hljs-number">0</span>]),<font></font>
      Path_To_String(Path[<span class="hljs-number">1</span>]),<font></font>
      Path_To_String(Path[<span class="hljs-number">2</span>]),<font></font>
      Path_To_String(Path[<span class="hljs-number">3</span>]),<font></font>
      Path_To_String(Path[<span class="hljs-number">4</span>]),<font></font>
      Path_To_String(Path[<span class="hljs-number">5</span>]),<font></font>
      Path_To_String(Path[<span class="hljs-number">6</span>]),<font></font>
      Path_To_String(Path[<span class="hljs-number">7</span>]),<font></font>
      Path_To_String(Path[<span class="hljs-number">8</span>]),<font></font>
      Path_To_String(Path[<span class="hljs-number">9</span>]),<font></font>
      Path_To_String(Path[<span class="hljs-number">10</span>]),<font></font>
      Path_To_String(Path[<span class="hljs-number">11</span>]),<font></font>
      Path_To_String(Path[<span class="hljs-number">12</span>]));<font></font>
    ....<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies scheint eine Debugging-Methode zu sein, aber wie viel Schaden er der Psyche des Entwicklers zufügen könnte, die Geschichte schweigt. </font><font style="vertical-align: inherit;">Hier besteht das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Path-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><font style="vertical-align: inherit;">aus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Elementen, und alle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden gedruckt </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insgesamt 4 Speicherzugriffe im Ausland Array:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V557 Array-Überlauf ist möglich. </font><font style="vertical-align: inherit;">Der '9'-Index zeigt über die Array-Grenze hinaus. </font><font style="vertical-align: inherit;">FOOT.CPP 232</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V557 Array-Überlauf ist möglich. </font><font style="vertical-align: inherit;">Der '10'-Index zeigt über die Array-Grenze hinaus. </font><font style="vertical-align: inherit;">FOOT.CPP 233</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V557 Array-Überlauf ist möglich. </font><font style="vertical-align: inherit;">Der '11'-Index zeigt über die Array-Grenze hinaus. </font><font style="vertical-align: inherit;">FOOT.CPP 234</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V557 Array-Überlauf ist möglich. </font><font style="vertical-align: inherit;">Der '12'-Index zeigt über die Array-Grenze hinaus. </font><font style="vertical-align: inherit;">FOOT.CPP 235</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V557 Array-Unterlauf ist möglich. </font><font style="vertical-align: inherit;">Der Wert des Index '_SpillTable [index]' kann -1 erreichen. </font><font style="vertical-align: inherit;">COORD.CPP 149</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> FacingType : <span class="hljs-keyword">char</span> {<font></font>
  ....<font></font>
  FACING_COUNT,  <span class="hljs-comment">// 8</span>
  FACING_FIRST=<span class="hljs-number">0</span><font></font>
} FacingType;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">short</span> <span class="hljs-keyword">const</span> * <span class="hljs-title">Coord_Spillage_List</span><span class="hljs-params">(COORDINATE coord, <span class="hljs-keyword">int</span> maxsize)</span>
</span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">const</span> _MoveSpillage[(<span class="hljs-keyword">int</span>)FACING_COUNT+<span class="hljs-number">1</span>][<span class="hljs-number">5</span>] = {<font></font>
    ....<font></font>
  };<font></font>
<font></font>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> _SpillTable[<span class="hljs-number">16</span>] = {<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>};<font></font>
<font></font>
  ....<font></font>
  <span class="hljs-keyword">return</span>(&amp;_MoveSpillage[_SpillTable[index]][<span class="hljs-number">0</span>]);<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf den ersten Blick ist das Beispiel komplex, aber es ist leicht, es nach einer kleinen Analyse herauszufinden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf das zweidimensionale </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MoveSpillage-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><i><font style="vertical-align: inherit;">wird</font></i><font style="vertical-align: inherit;"> über den Index zugegriffen, der aus dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_SpillTable-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><i><font style="vertical-align: inherit;">entnommen wurde</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Und es enthält plötzlich negative Werte. </font><font style="vertical-align: inherit;">Möglicherweise wird der Zugriff auf Daten nach einer speziellen Formel organisiert, und dies hat der Entwickler beabsichtigt. </font><font style="vertical-align: inherit;">Aber da bin ich mir nicht so sicher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V512 Ein Aufruf der Funktion 'sprintf' führt zum Überlaufen des Puffers '(char *) ptr'. </font><font style="vertical-align: inherit;">SOUNDDLG.CPP 250</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SoundControlsClass::Process</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">void</span> * ptr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span> [<span class="hljs-keyword">sizeof</span>(<span class="hljs-number">100</span>)];                                <span class="hljs-comment">// &lt;=</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span> (ptr) {
    <span class="hljs-built_in">sprintf</span>((<span class="hljs-keyword">char</span> *)ptr, <span class="hljs-string">"%cTrack %d\t%d:%02d\t%s"</span>,                   <span class="hljs-comment">// &lt;=</span>
      index, listbox.Count()+<span class="hljs-number">1</span>, length / <span class="hljs-number">60</span>, length % <span class="hljs-number">60</span>, fullname);<font></font>
    listbox.Add_Item((<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *)ptr);<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein aufmerksamer Leser wird sich fragen, warum eine so lange Zeile in einem Puffer von 4 Bytes gespeichert ist. </font><font style="vertical-align: inherit;">Aber weil der Programmierer dachte, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sizeof (100)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> etwas mehr zurückgeben würde (mindestens </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Der Operator </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sizeof</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gibt jedoch die Größe des Typs zurück und zählt niemals Ausdrücke. </font><font style="vertical-align: inherit;">Sie mussten nur die Konstante </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schreiben </font><font style="vertical-align: inherit;">und noch besser benannte Konstanten oder einen anderen Typ für Zeichenfolgen oder Zeiger verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V512 Ein Aufruf der Funktion 'memset' führt zum Unterlauf des Puffers 'Buffer'. </font><font style="vertical-align: inherit;">KEYBOARD.CPP 96</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> Buffer[<span class="hljs-number">256</span>];<font></font>
<font></font>
WWKeyboardClass::WWKeyboardClass(<span class="hljs-keyword">void</span>)<font></font>
{<font></font>
  ....<font></font>
  <span class="hljs-built_in">memset</span>(Buffer, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Puffer werden für 256 Bytes gelöscht, obwohl die volle Größe des ursprünglichen Puffers </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">256 * sizeof (unsigned short)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beträgt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fehler </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können dies weiterhin beheben:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">memset</span>(Buffer, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(Buffer));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V557 Array-Überlauf ist möglich. Die Funktion 'QuantityB' verarbeitet den Wert '[0..86]'. Überprüfen Sie das erste Argument. Überprüfen Sie die Zeilen: 'HOUSE.H: 928', 'CELL.CPP: 2337'. HOUSE.H 928</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> StructType : <span class="hljs-keyword">char</span> {<font></font>
  STRUCT_NONE=<span class="hljs-number">-1</span>,<font></font>
  ....<font></font>
  STRUCT_COUNT,                                       <span class="hljs-comment">// &lt;= 87</span>
  STRUCT_FIRST=<span class="hljs-number">0</span><font></font>
} StructType;<font></font>
<font></font>
<span class="hljs-keyword">int</span> BQuantity[STRUCT_COUNT<span class="hljs-number">-3</span>];                        <span class="hljs-comment">// &lt;= [0..83]</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">QuantityB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{<span class="hljs-keyword">return</span>(BQuantity[index]);}  <span class="hljs-comment">// &lt;= [0..86]</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CellClass::Goodie_Check</span><span class="hljs-params">(FootClass * object)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">int</span> bcount = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>; j &lt; STRUCT_COUNT; j++) {<font></font>
    bcount += hptr-&gt;QuantityB(j);                     <span class="hljs-comment">// &lt;= [0..86]</span><font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code enthält viele globale Variablen, und es ist offensichtlich, dass sie leicht verwechselt werden können. Die Analysatorwarnung zum Verlassen der Array-Grenze wird an der Stelle ausgegeben, an der über den </font><font style="vertical-align: inherit;">Index </font><font style="vertical-align: inherit;">auf das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BQuantity-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><i><font style="vertical-align: inherit;">zugegriffen</font></i><font style="vertical-align: inherit;"> wird. Die Größe des Arrays beträgt 84 Elemente. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mithilfe der</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmen zur Datenflussanalyse im Analysator konnte festgestellt werden, dass der Indexwert von einer anderen Funktion stammt - </font><i><font style="vertical-align: inherit;">Goodie_Check</font></i><font style="vertical-align: inherit;"> . Dort wird eine Schleife mit einem Endwert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">86 ausgeführt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Daher werden an dieser Stelle ständig 12 Bytes "fremder" Speicher gelesen (3 Elemente vom Typ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V575 Die Funktion 'memset' verarbeitet '0'-Elemente. Untersuchen Sie das dritte Argument. DLLInterface.cpp 1103</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* __cdecl <span class="hljs-title">memset</span><span class="hljs-params">(
  _Out_writes_bytes_all_(_Size) <span class="hljs-keyword">void</span>*  _Dst,
  _In_                          <span class="hljs-keyword">int</span>    _Val,
  _In_                          <span class="hljs-keyword">size_t</span> _Size
)</span></span>;<font></font>
<font></font>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> __declspec(dllexport) <span class="hljs-function"><span class="hljs-keyword">bool</span> __cdecl <span class="hljs-title">CNC_Read_INI</span><span class="hljs-params">(....)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-built_in">memset</span>(ini_buffer, _ini_buffer_size, <span class="hljs-number">0</span>);<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meiner Meinung nach habe ich diesen Fehler in modernen Projekten wiederholt gesehen. </font><font style="vertical-align: inherit;">Programmierer verwechseln immer noch das 2. und 3. Argument mit der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein anderer solcher Ort:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V575 Die Funktion 'memset' verarbeitet '0'-Elemente. </font><font style="vertical-align: inherit;">Untersuchen Sie das dritte Argument. </font><font style="vertical-align: inherit;">DLLInterface.cpp 1404</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Über Nullzeiger</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V522 Es kann zu einer Dereferenzierung der Nullzeigerliste kommen. </font><font style="vertical-align: inherit;">DISPLAY.CPP 1062</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DisplayClass::Get_Occupy_Dimensions</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp; w, <span class="hljs-keyword">int</span> &amp; h, <span class="hljs-keyword">short</span> <span class="hljs-keyword">const</span> *<span class="hljs-built_in">list</span>)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">list</span>) {
    <span class="hljs-comment">/*
    ** Loop through all cell offsets, accumulating max &amp; min x- &amp; y-coords
    */</span>
    <span class="hljs-keyword">while</span> (*<span class="hljs-built_in">list</span> != REFRESH_EOL) {<font></font>
      ....<font></font>
    }<font></font>
    ....<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der explizite Verweis auf den Nullzeiger sieht sehr seltsam aus. </font><font style="vertical-align: inherit;">Dieser Ort sieht aus wie ein Tippfehler und es gibt noch einige weitere Orte, die es wert sind, überprüft zu werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V522 Es kann zu einer Dereferenzierung der Nullzeigerliste kommen. </font><font style="vertical-align: inherit;">DISPLAY.CPP 951</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V522 Eine Dereferenzierung des Nullzeigers 'unitsptr' kann stattfinden. </font><font style="vertical-align: inherit;">QUEUE.CPP 2362</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V522 Eine Dereferenzierung des Nullzeigers 'unitsptr' kann stattfinden. </font><font style="vertical-align: inherit;">QUEUE.CPP 2699</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V595 Der Zeiger "Feind" wurde verwendet, bevor er gegen nullptr verifiziert wurde. </font><font style="vertical-align: inherit;">Überprüfen Sie die Zeilen: 3689, 3695. TECHNO.CPP 3689</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TechnoClass::Base_Is_Attacked</span><span class="hljs-params">(TechnoClass <span class="hljs-keyword">const</span> *enemy)</span>
</span>{<font></font>
  FootClass *defender[<span class="hljs-number">6</span>];
  <span class="hljs-keyword">int</span> value[<span class="hljs-number">6</span>];
  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> weakest = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> desired = enemy-&gt;Risk() * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">int</span> risktotal = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-comment">/*
  ** Humans have to deal with their own base is attacked problems.
  */</span>
  <span class="hljs-keyword">if</span> (!enemy || House-&gt;Is_Ally(enemy) || House-&gt;IsHuman) {
    <span class="hljs-keyword">return</span>;<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">feindliche</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeiger wird </font><font style="vertical-align: inherit;">dereferenziert und dann überprüft, ob er nicht Null ist. </font><font style="vertical-align: inherit;">Es gibt immer noch ein dringendes Problem, ich habe keine Angst vor dem Wort, bei jedem Open Source-Projekt. </font><font style="vertical-align: inherit;">Ich bin mir sicher, dass in Closed-Source-Projekten die Situation ungefähr gleich ist, es sei denn, natürlich wird PVS-Studio verwendet ;-)</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falsche Kasten</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V551 Der Code unter diesem "Fall" -Label ist nicht erreichbar. </font><font style="vertical-align: inherit;">Der Wert '4109' vom Typ 'char' liegt nicht im Bereich [-128; </font><font style="vertical-align: inherit;">127]. </font><font style="vertical-align: inherit;">WINDOWS.CPP 547</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VK_RETURN 0x0D</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> {<font></font>
  ....<font></font>
  WWKEY_VK_BIT = <span class="hljs-number">0x1000</span>,<font></font>
  ....<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">enum</span> {<font></font>
  ....<font></font>
  KA_RETURN = VK_RETURN | WWKEY_VK_BIT,<font></font>
  ....<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">void</span> Window_Print(<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>[], ...)<font></font>
{<font></font>
  <span class="hljs-keyword">char</span> c; <span class="hljs-comment">// Current character.</span><font></font>
  ....<font></font>
  <span class="hljs-keyword">switch</span>(c) {<font></font>
    ....<font></font>
    <span class="hljs-keyword">case</span> KA_FORMFEED: <span class="hljs-comment">// &lt;= 12</span><font></font>
        New_Window();<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> KA_RETURN:   <span class="hljs-comment">// &lt;= 4109</span><font></font>
      Flush_Line();<font></font>
      ScrollCounter++;<font></font>
      WinCx = <span class="hljs-number">0</span>;<font></font>
      WinCy++;<font></font>
      <span class="hljs-keyword">break</span>;<font></font>
    ....<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion verarbeitet Eingabezeichen. </font><font style="vertical-align: inherit;">Wie Sie wissen, wird ein </font><font style="vertical-align: inherit;">1-Byte-Wert </font><font style="vertical-align: inherit;">in den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeichentyp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eingefügt </font><font style="vertical-align: inherit;">, und die Nummer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4109</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird niemals dort sein. </font><font style="vertical-align: inherit;">Diese </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">switch-Anweisung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enthält also einfach einen nicht erreichbaren Code-Zweig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gab mehrere solcher Orte:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V551 Der Code unter diesem "Fall" -Label ist nicht erreichbar. </font><font style="vertical-align: inherit;">Der Wert '4105' vom Typ 'char' liegt nicht im Bereich [-128; </font><font style="vertical-align: inherit;">127]. </font><font style="vertical-align: inherit;">WINDOWS.CPP 584</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V551 Der Code unter diesem "Fall" -Label ist nicht erreichbar. </font><font style="vertical-align: inherit;">Der Wert '4123' vom Typ 'char' liegt nicht im Bereich [-128; </font><font style="vertical-align: inherit;">127]. </font><font style="vertical-align: inherit;">WINDOWS.CPP 628</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V552 Eine Variable vom Typ Bool wird inkrementiert: gedruckter Text ++. </font><font style="vertical-align: inherit;">Vielleicht sollte stattdessen eine andere Variable inkrementiert werden. </font><font style="vertical-align: inherit;">ENDING.CPP 170</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Nod_Ending</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">bool</span> printedtext = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">while</span> (!done) {
    <span class="hljs-keyword">if</span> (!printedtext &amp;&amp; !Is_Sample_Playing(kanefinl)) {<font></font>
      printedtext++;<font></font>
      Alloc_Object(....);<font></font>
      mouseshown = <span class="hljs-literal">true</span>;<font></font>
      Show_Mouse();<font></font>
    }<font></font>
    ....<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Codeausschnitt fand der Analysator die Anwendung der Inkrementierungsoperation auf eine Variable vom Typ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies ist der richtige Code in Bezug auf die Sprache, aber er sieht jetzt sehr seltsam aus. </font><font style="vertical-align: inherit;">Außerdem wird eine solche Operation ab dem C ++ 17-Standard als veraltet markiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nur 2 solcher Orte wurden identifiziert:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V552 Eine Variable vom Typ Bool wird inkrementiert: done ++. </font><font style="vertical-align: inherit;">Vielleicht sollte stattdessen eine andere Variable inkrementiert werden. </font><font style="vertical-align: inherit;">ENDING.CPP 187</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V556 Die Werte verschiedener Aufzählungstypen werden verglichen. </font><font style="vertical-align: inherit;">Typen: ImpactType, ResultType. </font><font style="vertical-align: inherit;">AIRCRAFT.CPP 742</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ImpactType <span class="hljs-title">FlyClass::Physics</span><span class="hljs-params">(COORDINATE &amp; coord, DirType facing)</span></span>;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> ImpactType : <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> {             <span class="hljs-comment">// &lt;=</span><font></font>
  IMPACT_NONE,<font></font>
  IMPACT_NORMAL,<font></font>
  IMPACT_EDGE<font></font>
} ImpactType;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> ResultType : <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> {             <span class="hljs-comment">// &lt;=</span><font></font>
  RESULT_NONE,<font></font>
  ....<font></font>
} ResultType;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AircraftClass::AI</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">if</span> (Physics(Coord, PrimaryFacing) != RESULT_NONE) { <span class="hljs-comment">// &lt;=</span><font></font>
    Mark();<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Programmierer verband eine Logik mit dem Vergleich der Werte verschiedener Aufzählungen. </font><font style="vertical-align: inherit;">Technisch funktioniert das da </font><font style="vertical-align: inherit;">numerische Darstellungen werden verglichen. </font><font style="vertical-align: inherit;">Ein solcher Code führt jedoch häufig zu logischen Fehlern. </font><font style="vertical-align: inherit;">Es lohnt sich, den Code zu korrigieren (wenn dieses Projekt natürlich noch unterstützt wird). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die gesamte Liste der Warnungen für diese Diagnose sieht folgendermaßen aus:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V556 Die Werte verschiedener Aufzählungstypen werden verglichen: SoundEffectName [voc] .Where == IN_JUV. </font><font style="vertical-align: inherit;">DLLInterface.cpp 402</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V556 Die Werte verschiedener Aufzählungstypen werden verglichen: SoundEffectName [voc] .Where == IN_VAR. </font><font style="vertical-align: inherit;">DLLInterface.cpp 405</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V556 Die Werte verschiedener Aufzählungstypen werden verglichen: Map.Theater == CNC_THEATER_DESERT. </font><font style="vertical-align: inherit;">Typen: TheaterType, CnCTheaterType. </font><font style="vertical-align: inherit;">DLLInterface.cpp 2805</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V556 Die Werte verschiedener Aufzählungstypen werden verglichen. </font><font style="vertical-align: inherit;">Typen: ImpactType, ResultType. </font><font style="vertical-align: inherit;">AIRCRAFT.CPP 4269</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V556 Die Werte verschiedener Aufzählungstypen werden verglichen: SoundEffectName [voc] .Where == IN_VAR. </font><font style="vertical-align: inherit;">DLLInterface.cpp 429</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V716 Verdächtige Typkonvertierung im Zuweisungsausdruck: 'HRESULT = BOOL'. </font><font style="vertical-align: inherit;">GBUFFER.H 780</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">BOOL __cdecl <span class="hljs-title">Linear_Blit_To_Linear</span><span class="hljs-params">(...)</span></span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">inline</span> HRESULT <span class="hljs-title">GraphicViewPortClass::Blit</span><span class="hljs-params">(....)</span>
</span>{<font></font>
  HRESULT return_code=<span class="hljs-number">0</span>;<font></font>
  ....<font></font>
  return_code=(Linear_Blit_To_Linear(<span class="hljs-keyword">this</span>, &amp;dest, x_pixel, y_pixel<font></font>
                      , dx_pixel, dy_pixel<font></font>
                      , pixel_width, pixel_height, trans));<font></font>
  ....<font></font>
<font></font>
  <span class="hljs-keyword">return</span> ( return_code );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch ein sehr altes Problem, das heute relevant ist. </font><font style="vertical-align: inherit;">Es gibt spezielle Makros für die Arbeit mit dem HRESULT-Typ, und Casts in BOOL und umgekehrt werden nicht verwendet. </font><font style="vertical-align: inherit;">Diese beiden Datentypen sind sich sprachlich sehr ähnlich, aber logisch nicht kompatibel. </font><font style="vertical-align: inherit;">Die im Code vorhandene Operation der impliziten Typkonvertierung ist bedeutungslos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser und ein paar weitere Orte wären eine Umgestaltung wert:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V716 Verdächtige Typkonvertierung im Zuweisungsausdruck: 'HRESULT = BOOL'. </font><font style="vertical-align: inherit;">GBUFFER.H 817</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V716 Verdächtige Typkonvertierung im Zuweisungsausdruck: 'HRESULT = BOOL'. </font><font style="vertical-align: inherit;">GBUFFER.H 857</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V716 Verdächtige Typkonvertierung im Zuweisungsausdruck: 'HRESULT = BOOL'. </font><font style="vertical-align: inherit;">GBUFFER.H 773</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V716 Verdächtige Typkonvertierung im Zuweisungsausdruck: 'HRESULT = BOOL'. </font><font style="vertical-align: inherit;">GBUFFER.H 810</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V716 Verdächtige Typkonvertierung im Zuweisungsausdruck: 'HRESULT = BOOL'. </font><font style="vertical-align: inherit;">GBUFFER.H 850</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V610 Undefiniertes Verhalten. </font><font style="vertical-align: inherit;">Überprüfen Sie den Schichtführer '&lt;&lt;'. </font><font style="vertical-align: inherit;">Der linke Operand '(~ 0)' ist negativ. </font><font style="vertical-align: inherit;">MP.CPP 2410</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">XMP_Randomize</span><span class="hljs-params">(digit * result, Straw &amp; rng, <span class="hljs-keyword">int</span> total_bits, <span class="hljs-keyword">int</span> precision)</span>
</span>{<font></font>
  ....<font></font>
  ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)result)[nbytes<span class="hljs-number">-1</span>] &amp;=<font></font>
    (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(~((~<span class="hljs-number">0</span>) &lt;&lt; (total_bits % <span class="hljs-number">8</span>)));<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier verschiebt sich eine negative Zahl nach links, was ein undefiniertes Verhalten ist. Eine negative Zahl wird von Null erhalten, wenn der Inversionsoperator angewendet wird. weil Das Ergebnis der Operation wird in den Typ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eingefügt </font><font style="vertical-align: inherit;">, der Compiler verwendet es zum Speichern des Werts und es wird signiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Jahr 2020 hat der Compiler auch einen solchen Fehler festgestellt: </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warnung C26453: Arithmetischer Überlauf: Die Linksverschiebung einer negativ vorzeichenbehafteten Zahl ist ein undefiniertes Verhalten.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Compiler sind jedoch keine vollwertigen statischen Analysatoren andere Probleme lösen. Daher ist hier ein weiteres Beispiel für undefiniertes Verhalten, das nur mit PVS-Studio erkannt wird:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V610 Undefiniertes Verhalten. </font><font style="vertical-align: inherit;">Überprüfen Sie den Schichtführer '&lt;&lt;'. </font><font style="vertical-align: inherit;">Der rechte Operand ('(32 - bits_to_shift)' = [1..32]) ist größer oder gleich der Länge in Bits des heraufgestuften linken Operanden. </font><font style="vertical-align: inherit;">MP.CPP 659</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNITSIZE 32</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">XMP_Shift_Right_Bits</span><span class="hljs-params">(digit * number, <span class="hljs-keyword">int</span> bits, <span class="hljs-keyword">int</span> precision)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">int</span> digits_to_shift = bits / UNITSIZE;
  <span class="hljs-keyword">int</span> bits_to_shift = bits % UNITSIZE;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> index;
  <span class="hljs-keyword">for</span> (index = digits_to_shift; index &lt; (precision<span class="hljs-number">-1</span>); index++) {<font></font>
    *number = (*(number + digits_to_shift) &gt;&gt; bits_to_shift) |<font></font>
      (*(number + (digits_to_shift + <span class="hljs-number">1</span>)) &lt;&lt; (UNITSIZE - bits_to_shift));<font></font>
    number++;<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Analysator hat eine Situation erkannt, in der eine Verschiebung der 32-Bit-Zahl um eine größere Anzahl von Bits nach rechts möglicherweise möglich ist. </font><font style="vertical-align: inherit;">So geht's:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> bits_to_shift = bits % UNITSIZE;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNITSIZE-Konstante</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat den Wert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> bits_to_shift = bits % <span class="hljs-number">32</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So wird der Wert der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bits_to_shift</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable </font><font style="vertical-align: inherit;">Null für alle sein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werte , </font><font style="vertical-align: inherit;">die ein </font><font style="vertical-align: inherit;">Vielfaches von sind </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deshalb in diesem Code:</font></font><br>
<br>
<pre><code class="cpp hljs">.... &lt;&lt; (UNITSIZE - bits_to_shift) ....</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine 32-Bit-Verschiebung tritt auf, wenn </font><i><font style="vertical-align: inherit;">0</font></i><font style="vertical-align: inherit;"> von der Konstanten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> subtrahiert wird </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">
Liste aller Warnungen von PVS-Studio über Verschiebungen mit undefiniertem Verhalten:</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V610 Undefiniertes Verhalten. </font><font style="vertical-align: inherit;">Überprüfen Sie den Schichtführer '&lt;&lt;'. </font><font style="vertical-align: inherit;">Der linke Operand '(~ 0)' ist negativ. </font><font style="vertical-align: inherit;">ZIEL.H 66</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V610 Undefiniertes Verhalten. </font><font style="vertical-align: inherit;">Überprüfen Sie den Schichtführer '&lt;&lt;'. </font><font style="vertical-align: inherit;">Der linke Operand '((((- 24) * 256) / 24)' ist negativ. </font><font style="vertical-align: inherit;">ANIM.CPP 160</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V610 Undefiniertes Verhalten. </font><font style="vertical-align: inherit;">Überprüfen Sie den Schichtführer '&lt;&lt;'. </font><font style="vertical-align: inherit;">Der linke Operand '((((- 12) * 256) / 24)' ist negativ. </font><font style="vertical-align: inherit;">BUILDING.CPP 4037</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V610 Undefiniertes Verhalten. </font><font style="vertical-align: inherit;">Überprüfen Sie den Schichtführer '&lt;&lt;'. </font><font style="vertical-align: inherit;">Der linke Operand '(((- - 21) * 256) / 24)' ist negativ. </font><font style="vertical-align: inherit;">DRIVE.CPP 2160</font></font></li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 21) * 256) / 24)' is negative. DRIVE.CPP 2161</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 20) * 256) / 24)' is negative. DRIVE.CPP 2162</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 20) * 256) / 24)' is negative. DRIVE.CPP 2163</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 18) * 256) / 24)' is negative. DRIVE.CPP 2164</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 18) * 256) / 24)' is negative. DRIVE.CPP 2165</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 17) * 256) / 24)' is negative. DRIVE.CPP 2166</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 16) * 256) / 24)' is negative. DRIVE.CPP 2167</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 15) * 256) / 24)' is negative. DRIVE.CPP 2168</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 14) * 256) / 24)' is negative. DRIVE.CPP 2169</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 13) * 256) / 24)' is negative. DRIVE.CPP 2170</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 12) * 256) / 24)' is negative. DRIVE.CPP 2171</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 11) * 256) / 24)' is negative. DRIVE.CPP 2172</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 10) * 256) / 24)' is negative. DRIVE.CPP 2173</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 9) * 256) / 24)' is negative. DRIVE.CPP 2174</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 8) * 256) / 24)' is negative. DRIVE.CPP 2175</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 7) * 256) / 24)' is negative. DRIVE.CPP 2176</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 6) * 256) / 24)' is negative. DRIVE.CPP 2177</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 5) * 256) / 24)' is negative. DRIVE.CPP 2178</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 4) * 256) / 24)' is negative. DRIVE.CPP 2179</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 3) * 256) / 24)' is negative. DRIVE.CPP 2180</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 2) * 256) / 24)' is negative. DRIVE.CPP 2181</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 1) * 256) / 24)' is negative. DRIVE.CPP 2182</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(((- 5) * 256) / 24)' is negative. INFANTRY.CPP 2730</li>
<li>V610 Undefined behavior. Check the shift operator '&gt;&gt;'. The right operand ('(32 — bits_to_shift)' = [1..32]) is greater than or equal to the length in bits of the promoted left operand. MP.CPP 743</li>
<li>V610 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '(~0)' is negative. RANDOM.CPP 102</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V610 Undefiniertes Verhalten. </font><font style="vertical-align: inherit;">Überprüfen Sie den Schichtführer '&lt;&lt;'. </font><font style="vertical-align: inherit;">Der linke Operand '(~ 0L)' ist negativ. </font><font style="vertical-align: inherit;">RANDOM.CPP 164</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoffen wir, dass die zeitgenössischen Electronic Arts-Projekte von höherer Qualität sind. </font><font style="vertical-align: inherit;">Wenn nicht, laden wir Sie ein, </font><font style="vertical-align: inherit;">PVS-Studio für alle Projekte </font><font style="vertical-align: inherit;">auf unserer Website </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">herunterzuladen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und zu testen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jemand könnte einwenden, dass coole Qualitätsspiele zuvor mit solcher Qualität hergestellt wurden, und teilweise können wir dem zustimmen. </font><font style="vertical-align: inherit;">Vergessen Sie jedoch nicht, dass der Wettbewerb bei der Entwicklung von Programmen und Spielen in so vielen Jahren um ein Vielfaches gewachsen ist. </font><font style="vertical-align: inherit;">Die Kosten für Entwicklung, Support und Werbung stiegen ebenfalls. </font><font style="vertical-align: inherit;">Die Korrektur von Fehlern in späteren Entwicklungsstadien bringt daher erhebliche finanzielle und Reputationsverluste mit sich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Folgen Sie unserem Blog, um den zweiten Teil der Rezension für diese Spieleserie nicht zu verpassen.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb2/f9c/3bb/eb2f9c3bb5f32f39239298d36431961c.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie diesen Artikel einem englischsprachigen Publikum zugänglich machen möchten, verwenden Sie bitte den Link zur Übersetzung: Svyatoslav Razmyslov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Code des Command &amp; Conquer-Spiels: Bugs aus den 90ern. </font><font style="vertical-align: inherit;">Band eins</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de507148/index.html">Senden Sie magische Links mit Node.js.</a></li>
<li><a href="../de507150/index.html">Wir zeichnen ein Interferenzbild in JavaScript</a></li>
<li><a href="../de507156/index.html">Tetris auf Bitboards: alte Songs auf neue Weise</a></li>
<li><a href="../de507158/index.html">Antiquitäten: Jahrzehnt des Apple iPad</a></li>
<li><a href="../de507160/index.html">Über die "realistischste" "Interpretation" der Quantenmechanik</a></li>
<li><a href="../de507166/index.html">Erfahrung in der Verwendung der Rutoken-Technologie zur Registrierung und Autorisierung von Benutzern im System (Teil 3)</a></li>
<li><a href="../de507170/index.html">Sehen sich vierzehn Personen dieses Produkt mit Sicherheit an?</a></li>
<li><a href="../de507172/index.html">Was sie an der Fakultät für Niedertemperaturenergie der ITMO-Universität tun</a></li>
<li><a href="../de507174/index.html">Benötigen die Streitkräfte Russlands und andere Strukturen des Verteidigungsministeriums der Russischen Föderation einen Standard zur Beschreibung von Algorithmen?</a></li>
<li><a href="../de507176/index.html">MMS-System im Rechenzentrum: Wie wir das Wartungsmanagement automatisiert haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>