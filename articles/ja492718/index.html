<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥕 🚝 ☄️ ユーザー制限によるセキュリティまたは脆弱性の作成方法 📪 🚁 💔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="2019年に、CPDoSキャッシュポイズニングサービス拒否）脆弱性がCDNネットワークで発見されました。これにより、CDNプロバイダーのHTTPキャッシュをポイズニングし、サービス拒否を引き起こすことができます。この脆弱性は実際の攻撃では確認されていないため、まだ大々的に宣伝されていません。ただし、...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ユーザー制限によるセキュリティまたは脆弱性の作成方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492718/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2019年に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPDoS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ポイズニング</font></a><font style="vertical-align: inherit;">サービス拒否）</font><font style="vertical-align: inherit;">脆弱性が</font><font style="vertical-align: inherit;">CDNネットワークで</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">発見され</font></a><font style="vertical-align: inherit;">ました。これにより、CDNプロバイダーのHTTPキャッシュをポイズニングし、サービス拒否を引き起こすことができます。</font><font style="vertical-align: inherit;">この脆弱性は実際の攻撃では確認されていないため、まだ大々的に宣伝されていません。</font><font style="vertical-align: inherit;">ただし、キャッシュポイズニング手法の1つについて個別に説明したいと思います。</font><font style="vertical-align: inherit;">HTTPメソッドのオーバーライド。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rb/7j/wy/rb7jwy3an79ykaffwer39l297eu.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何らかの方法で脆弱性を悪用する他のバリアントが、仲介者によるリクエストの変更のバグまたは機能に依存している場合、メソッドオーバーライドバリアントは、HTTP標準の一部ではない同じ名前の戦術に基づいており、追加の問題を伴い、不注意により発生して広まりました。セキュリティとの関係。</font><font style="vertical-align: inherit;">ここでそれを考えます。</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたがそれを逃した場合、CPDoSについてショート</font></font></b><div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"> </a> ,         URI  method   .<br>
<br>
      ,       ,       ,         ,      -   .       —            -  -   -,      ,    -     ,      .           ,         .<br>
<br>
            ,    . ,  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">   -</a>.      -   ,       ,      .<br>
<br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントを制限し、できることを減らす-壊れることが少なくなります</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のWebアプリケーションファイアウォールとHTTPクライアントの実装が非常に制限されており、GETとPOST以外のメソッドの実行が許可されていなかったため、リクエスト内のメソッドをオーバーライドする必要が生じました。問題は、それが実装上の制限ではなく、セキュリティポリシーによるHTTPクライアントの意図的な制限であったことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが、通常のHTTPクライアントの標準ではない窮屈なトラフィックを遮断することを意図して実行されたことは明らかです。しかし、セキュリティを追求するために、GETとPOSTを除くすべてのメソッドが遮断されました。おそらくこれらは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプション</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">なく、</font></a><font style="vertical-align: inherit;">汎用サーバーに</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">必要な</font></a><font style="vertical-align: inherit;">唯一の方法である</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ためです</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこのような厳しい制限を導入する必要があったのかは明らかではない。はい、パーサーを混乱させるためにさまざまな文字を導入する攻撃は、テキストプロトコルの趣味にすぎません。しかし、もう少しメソッドを許可することもできます。たとえば、少なくとも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準自体に記述されている</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://www.iana.org/assignments/http-methods/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、IANAに登録</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">され</font></a><font style="vertical-align: inherit;">ているメソッドを使用します</font><font style="vertical-align: inherit;">。メソッドチェックを完全に削除することは価値がありませんでしたが、最も一般的なメソッドの数をダイヤルし、対話プロトコルを変更してプロキシサーバー上の接続での作業を中断するメソッド（CONNECT）をそれらから除外することができました。しかし、いいえ、それは</font><font style="vertical-align: inherit;">顧客に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不必要な</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制限と禁止を</font><font style="vertical-align: inherit;">導入したセキュリティポリシーである</font><font style="vertical-align: inherit;">ことがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、顧客は間違ったものに限定されました。</font><font style="vertical-align: inherit;">彼らは、HTTPクライアントからのメッセージの変動性を制限することを望み、これらのWAFが保護するクライアント、エンドアプリケーションサーバー、およびそれらの開発者を制限しました。</font><font style="vertical-align: inherit;">現在、開発者は、HTTPクライアントのロジックを説明するのに必ずしも十分ではない2つのメソッドしか残されていませんでした。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制約はそれらを克服するために作成されます。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この過度の制限が遅かれ早かれWeb開発者に干渉し始めることが予想されました。皮肉なことに、そのようなWAFを排除しないのは簡単です。特に彼らが顧客やプロバイダーと一緒にいるとき。他の人のセキュリティポリシーに異議を唱えることは悲惨な問題です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTPの柔軟性により、この制限を回避することは難しくありません。リクエストをメソッドにオーバーライドできるものを追加するだけです。厳格なWAFは、要求行（要求の最初の行）でのみメソッドをチェックし、承認されたGETまたはPOSTが表示されることを喜んで確認します。そして、バックエンドは追加された要素を解析し、それから実際のメソッドを抽出することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはできる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://fandry.blogspot.com/2012/03/x-" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グーグル</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の束</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://docs.inpaas.com/docs/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、記事を</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本当に</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://www.infoworld.com/article/3249687/how-to-implement-a-delegatinghandler-for-x-" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たくさん</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのようにして悪いプロキシがRESTアプリケーションを壊したか、そして作者が実際のメソッドを別のヘッダーで渡さなければならなかった方法について。</font><font style="vertical-align: inherit;">それらすべてで、オーバーライドされたメソッドを示すために、ほぼ同じヘッダー（X-HTTP-Method、X-HTTP-Method-OverrideまたはX-Method-Override-スペルは多少異なります）を入力することをお勧めします。</font><font style="vertical-align: inherit;">非常にまれに、同じ目的のクエリコンポーネントURIに使用できる参照を見つけることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの記事に欠けているのは、セキュリティに関する考慮事項のセクションです。</font><font style="vertical-align: inherit;">そして、彼らはただです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドのオーバーライドは安全ですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webアプリケーション開発者は、クライアントとサーバーの間に、HTTPプロトコルを介して対話する中間参加者（プロキシ、プロバイダーWebキャッシュ、CDNおよびWAF）があることを忘れることがあります。 TLSの急増により、クライアントとサーバー間の中間参加者の可能性が大幅に減少します。ほとんどの場合、クライアントとバックエンド間の唯一のプロキシは、Nginxを備えた独自のサーバーになります。また、このような構成は、リリース前に一般的なシナリオでテストするのに十分簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私たちはCDNの時代に移行しており、ユーザートラフィックを読み取って操作するCDNの背後に隠れているアプリケーションが増えています。</font><font style="vertical-align: inherit;">バックエンドは直接ユーザーにサービスを提供することはほとんどなく、リバースプロキシの背後に隠れて応答性とパフォーマンスを向上させます。</font><font style="vertical-align: inherit;">したがって、メソッドをオーバーライドすると、仲介サーバーでの要求の処理にどのように影響するかを覚えておく必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が話したい攻撃は主にHTTP / 1.1に当てはまります。</font><font style="vertical-align: inherit;">HTTP / 2は何らかの方法で古い標準の動作を継承し、いくつかの方法で独自の方法を使用するため、新しい標準に対する各攻撃の適用性は個別に考慮されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュ攻撃</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、中間サーバーはメソッドのオーバーライドを考慮せず、X-HTTP-Method-Overrideファミリーのヘッダーをチェックせず、リクエストラインのメインメソッドを使用してリクエストを処理します。また、オーバーライドされたメソッドはキャッシュ内のリクエストを検索するためのキー（メソッド+ URI）に含まれていないため、そのようなサーバーはPOSTとPOST + X-HTTP-Method-Override：DELETEを区別できません。これは</font><font style="vertical-align: inherit;">、バックエンドがオーバーライドされたメソッドを監視および実行できる場合、特定のURIへのリクエストの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュを許可できないことを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意味し</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CPDoSドキュメントには、そのようなリクエストをキャッシュした場合に何が起こるかを示す良い例があります。攻撃者がPOST要求をGET要求に偽装すると、プロキシは置換を認識せず、その要求を正当なGET要求として扱います。ただし、バックエンドはオーバーライドされたメソッドを認識し、X-HTTP-Method-Override-POSTヘッダーに記述されている動詞を実行します。 POSTメソッドは宛先URIに対して定義されていないため、サーバーはエラーを生成します。さらに、バックエンド応答は、元のメソッドGETへの応答としてキャッシュに格納されます。これで、同じURIに対する次のGET要求は、キャッシュされたエラーを返します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/0r/bv/_q/0rbv_qeocdxi9b4ctw2rschthgw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、攻撃はドキュメントで提示されているよりも少し広いです。作成者は、エラーをキャッシュに保存することに焦点を当てましたが、どこでも（すでに）再現できるわけではありません。ただし、選択したURIに対して要求されたメソッドが定義され、正常に実行される場合、プロキシはステータスが200の応答を受信して​​キャッシュします。次に、同じURIの後続のリクエストで、完全に間違ったメソッドへの応答を受け取ります。このシナリオでは、元のCPDoSの説明のように、4XX応答のキャッシュエラーの要件はなくなりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
逆の問題が発生することがあります。適切なHTTPクライアントがリクエストGET + X-HTTP-Method-Override：PATCH（これは悪いですが、後で詳しく説明します）を送信し、キャッシュがすでにGETへの応答を持っている場合、クライアントはこのキャッシュされた応答を受け取ります。この場合、バックエンドはPATCHリクエストを受信しないため、クライアントとサーバーの両方でアプリケーションロジックに違反する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正しいキャッシュポリシーを構築し、リソースを2つのグループに分割することで、キャッシュへの影響を減らすことができます。メソッドオーバーライド操作が受け入れられない、または不要なもの、それらへの応答をキャッシュできる、メソッドオーバーライド操作が必要なもの、そのような回答のキャッシュが受け入れられない。ただし、キャッシュされるリソースが少ないほど、CDNの有用性は低くなり、バックエンドに到達するトラフィックが増えるほど、アプリケーションがHTTPフラッドにさらされるようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、可能な限りHTTPキャッシュを使用することをお勧めします。これには、キャッシュサーバーが、オーバーライドされたメソッドが異なるリクエストを区別できる必要があります。最初の方法は、クエリコンポーネントのメソッドオーバーライドをURIに転送することです。</font></font><br>
<br>
<pre><code class="plaintext hljs">POST /some-uri HTTP/1.1<font></font>
X-HTTP-Method-Override: DELETE<font></font>
   ↓  ↓   ↓<font></font>
POST /some-uri?method=DELETE HTTP/1.1<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異なるメソッドを持つリクエストは、異なるキーを取得するため、キャッシュに対して異なるように見えます。一部のプロキシは、URIにクエリコンポーネントを含むリクエストへの応答をキャッシュしないことを好みます。ただし、これはキャッシング効率にのみ影響します。この方法は、正しくないキャッシングに関する問題を常に解決します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の方法は、メソッドのオーバーライドを別のヘッダーに残し、セカンダリキーを入力してキャッシュ内の回答を見つけることです。これは、Varyヘッダーで可能です。リクエストを処理するとき、サーバーはメソッドオーバーライドを使用してヘッダーを繰り返し、このヘッダーの名前をVaryヘッダーに反映します。次に、次のリクエストで、キャッシュサーバーは、キャッシュ内のリクエストを検索するときに、オーバーライドされたメソッドの値をセカンダリキーとして使用します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/oh/1n/rd/oh1nrdf3x18yktd6moekwlr01-w.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法は、中間サーバーがセカンダリキーを処理できる場合に機能します。</font><font style="vertical-align: inherit;">これは通常のケースですが、GETとPOST以外のすべてのメソッドをカットするプロキシの信頼レベルは通常低く、これを確認することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエスト本文内のエンティティを介してメソッドをオーバーライドすることには、追加のヘッダーをオーバーライドすることとまったく同じ欠点があります-キャッシュの可視性の範囲外です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージキュー攻撃</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャッシュ攻撃が閉じられたとしても、それだけではありません。</font><font style="vertical-align: inherit;">攻撃者は、メソッドをオーバーライドすることにより、応答のフレームを変更しようとする可能性があり、それにより、他のクライアントの要求と応答のペアの対応に違反する可能性があります。</font><font style="vertical-align: inherit;">または、アプリケーションのサーバー側で同じリクエストを数回処理するように強制します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これに必要な最も重要なことは、リバースプロキシモードで動作する中間サーバーです。つまり、キャッシュまたはCDNサーバーです。このようなプロキシは、バックエンドへの比較的少数の接続をサポートし、それぞれの多数のクライアントからの要求を乗算します。これは、クライアントとの多数の接続をサポートする負荷をバックエンドからプロキシサーバーに取り込むためと、バックエンド間で負荷のバランスを取るために必要です。 TLS接続の終了もプロキシで行われ、クライアント接続がバックエンドに直接接続されることはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異なるクライアントからのリクエストはバックエンドとプロキシの間の同じ接続にあるため、リクエストとレスポンスのペア間の明確な対応を維持する必要があります。ほとんどのプロキシ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はパイプラインしません</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（パイプライン）バックエンドへのリクエスト。リクエスト/レスポンスモードでそれを処理します。要求/応答モードはより単純で、事実上1つの脅威、つまり接続のブロックの影響を受けます。単一の要求と応答のペアで接続をハングさせると、遅延が発生したり、次の要求の処理が拒否されたりすることがあります（たとえば、プロキシ要求のキューのオーバーフローに成功した場合）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より生産的なプロキシがバックエンドへのリクエストをパイプライン処理します。これにより、リクエストのパケットをすぐにサーバーに送信し、その実行を待つことができます。パフォーマンスは高くなりますが、脅威は増えます。第一に、行頭ブロッキングの問題はどこにも消えません-バックエンドがリクエストのパイプラインをレイクして並列に実行できても、最初のリクエストがハングした場合は送信できません。次に、応答フレームを壊すと、プロキシを混乱させ、要求と応答のペアの対応を壊す可能性があります。その場合、一部のクライアントは他の人の回答を受け取るか、少なくともバックエンドとの接続を即座に閉じることができます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/td/wn/rj/tdwnrjiw4ekrsl7l1aqda-hhyzi.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドの最も単純で最も楽しい再定義は、GETを動詞HEADで置き換えることです。最初の回答に本文がある場合、2番目の回答にはありません。さらに、リクエストのフレーミングを提供するものを含め、他のすべてのヘッダーは同じです。プロキシがこのようなオーバーライドされたHEADをサーバーにリダイレクトする場合、サーバーからの応答ヘッダーだけでなく、バ​​ックエンドが送信しない応答本文も期待されます。プロキシとサーバーが要求/応答モードで対話する場合、接続はタイムアウトによって中断するまで「ハング」します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーが次の応答を送信する場合（パイプラインモード）、それらは独立した応答としてではなく、GETに対する以前の不完全な応答の一部として解析できます。プロキシは、それら（またはその一部）を「GET」応答の本文に配置し、攻撃者に送信して読み取ります。このような疑似GETを作成して大きなファイルを受信し、プロキシとバックエンド間のトラフィックをダンプできます。成功は、バックエンドがContent-LengthおよびTransfer-Encoding：チャンクヘッダーをフレームメッセージに配置する方法に依存します。 1つ目はほとんど常にダンプを取得することを許可し、2つ目はしばしば解析エラーを生成し、バックエンドからの切断を引き起こします。運が悪い場合は、疑似GETでいくつかの回答全体をカバーし、次の回答の直前で終了できます。プロキシはこの問題をまったく認識できなくなり、この接続でさらに回答が得られると、要求と応答の対応に違反します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ee/ds/h9/eedsh90uounshmxglkz5aconiim.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドをオーバーライドすることですべてがプロキシとバックエンド間の接続を閉じることで達成されたとしても、これは攻撃には十分かもしれません。</font><font style="vertical-align: inherit;">このようなリクエストでサービスリクエストをスローできます。バックエンドとの接続は常に切断されます。</font><font style="vertical-align: inherit;">それらの数はそれほど多くなく、再検出には時間がかかるため、結果としてプロキシバックエンドの通信パフォーマンスが大幅に低下し、サービスのスループットが低下する可能性があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動スパム再生</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GET + X-HTTP-Method-Override：PATCHの形式の要求は、立派なクライアントからは悪いと上記で述べました。また、メソッドには</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セキュリティ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">べき等性の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2つのプロパティがあるため、これは悪いこと</font><font style="vertical-align: inherit;">です。セキュリティとは、メソッドがサーバーの状態を変更しないこと（読み取り専用）であり、この記事のコンテキストには関係ありません。このメソッドのべき等性により、リクエストが繰り返されても、1つのリクエストと同じ効果が得られます。あなたは類推を描くことができます：</font></font><code>(a = 5)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">べき</font><font style="vertical-align: inherit;">等の要求、</font></font><code>(a += 2) </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-非べき等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この特性は私たちが興味を持っているものです。クライアントとサーバー間の接続が突然切断された場合、クライアントはメソッドがべき等であることを認識しているため、自動的にリクエストを再送信できます。プロキシは同じように動作します。非べき等の要求は、サーバーにどのように影響するか、クライアントが最終的に何を受信するかわからないため、自動的に繰り返されません。ブラウザーのポップアップは誰もが知っていると思います。「本当に要求を繰り返してもよろしいですか？」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
べき等でないメソッドをべき等としてマスクすると、エラーが発生しても破棄されず、サーバーに再度リダイレクトされます。クライアントがリクエストを再送信する前に実際のリクエストメソッドを検討する場合でも、プロキシサーバーはメソッドのオーバーライドを認識せず、そのようなリクエストを繰り返すため、これはあまり役に立ちません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
攻撃者がバックエンドとクライアント間の切断を強制できる場合、攻撃者はサーバーに非べき等のリクエストを繰り返し実行させ、アプリケーションの信頼性と予測可能性を低下させる可能性があります。</font><font style="vertical-align: inherit;">前のセクションでは、同じメソッドのオーバーライドで接続を切断する方法を見つけました。</font><font style="vertical-align: inherit;">ただし、インターネットは本質的に信頼性の低いネットワークであり、アプリケーション自体が危険にさらされていることを忘れないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この攻撃から保護するには、リクエストにトランスポートとして新しいプロパティを追加しないメソッドのみを使用する必要があります。</font><font style="vertical-align: inherit;">POSTは、デフォルトでは安全でもべき等でもないため、良い候補です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その古代のHTTP / 1.1は、HTTP / 2と同じですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP / 2は、リクエストがノード間で転送される方法を変更しましたが、それらの語彙の意味は変更していません。したがって、要求値に関連する攻撃では、HTTP / 2は同じように動作します。ただし、「トランスポート」攻撃は標準ですでに考慮されているため、再現されません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュへの攻撃は、</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HTTP / 1と同様に再現され、保護も同様です。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージキュー攻撃は</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HTTP / 2には適用されません。その中のHTTPメッセージは、メッセージの長さとメッセージの終わりを明示的に決定する個別のフレームヘッダーを使用して、個別のフレームに分割されます。攻撃者がメソッドを変更してHTTPヘッダーを変更しない場合と同様に、これはメッセージフレームには影響しません。答えを盗むことは失敗します。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">べき等ではないメッセージの繰り返しに対する攻撃は、</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HTTP / 2に存在するという事実を考慮に入れても適用可能です</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後に処理されたリクエストの通知メカニズム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">HTTP / 2では、複数のリクエストが同じTCPで乗算され、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が作成され</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">各スレッドには独自の番号があります。</font><font style="vertical-align: inherit;">HTTP / 2サーバーが切断された場合、GOAWAYで最後に処理されたリクエストの数を示している可能性があります。</font><font style="vertical-align: inherit;">番号が大きいリクエストはリダイレクトしても常に安全です。番号が小さいリクエストは、べき等である場合にのみリダイレクトされます。</font><font style="vertical-align: inherit;">オーバーライドされたメソッドを含むリクエストがプロキシサーバーのべき等のように見える場合、プロキシはそれをサーバーに転送します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを安全にオーバーライドする方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短い答えは仕方がない。メソッドのオーバーライドはまったく使用しないことをお勧めします。そして、もしあれば、バックエンドのサポートを完全に無効にします。メソッドをオーバーライドするHTTPクライアントをブロックします。 「余分な」メソッドを削減するプロキシ/ WAFを拒否します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドの再定義に何らかの形で対処する必要がある場合は、バックエンドへの十分な編集を防止します。まず、URIのクエリコンポーネントを介してのみメソッドをオーバーライドすることをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、メソッドの変換のホワイトリストが必要です。これは、「トランスポート」として許容され、結果として得られるものです。</font><font style="vertical-align: inherit;">メソッドをどれでもオーバーライドできる場合は、一般化された変換関数を使用しないでください。</font><font style="vertical-align: inherit;">「トランスポート」メソッドには、結果として得られたものにない場合、セキュリティとべき等性のプロパティが含まれていてはなりません。</font><font style="vertical-align: inherit;">危険な変換は禁止されるべきであり、同じ置換GET-&gt; HEADです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題のあるプロキシ/ WAFにパッチを適用する必要がありますか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロキシがGETメソッドとPOSTメソッドのみを実装し、何らかの理由で他のメソッドをブロックする場合、間違いなくそうです。</font><font style="vertical-align: inherit;">主にGETおよびPOST用に最適化できますが、他のメソッドをブロックすることはお勧めできません。</font><font style="vertical-align: inherit;">それでも、製品に不信の溝ができます。基本的なものがブロックされている場合、より複雑な問題の実装から何を期待できますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
保護されたWebアプリケーションのセキュリティが心配な場合は、アプリケーションを安全でないメソッドオーバーライドポリシーから保護することは価値があるかもしれません。</font><font style="vertical-align: inherit;">もちろん、一般的なケースでは、Webアプリケーションの実装の詳細を知らなければ、アプリケーションを誤ったオーバーライドから完全に保護することは不可能ですが、単に問題を知らないユーザーを部分的にカバーすることができます。</font><font style="vertical-align: inherit;">自分のキャッシュの汚染を防ぐだけでなく、保護された各アプリケーションのオーバーライドを有効または無効にできるようにする必要もあります。</font><font style="vertical-align: inherit;">これを行うには</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">一般的に使用されるヘッダーを</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">追跡し</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X-HTTP-Method、X-HTTP-Method-Override、およびX-Method-Override。</font><font style="vertical-align: inherit;">URIのクエリコンポーネントで再定義を追跡することはあまり意味がありません。キャッシュはそのような要求を害することはなく、クエリは非常に長くなり、完全に任意の形式になる可能性があります。</font></font><br>
<br>
<h2>      ?</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セキュリティ開発者は、アプリケーション開発者をセキュリティポリシーに限定しないでください。</font><font style="vertical-align: inherit;">彼らはまだそれらを回避する方法を見つけるでしょう、そしてプロトコルがより柔軟であればあるほど、それを行うのがより簡単になります。</font><font style="vertical-align: inherit;">彼らがあなたを蹴るのではなく、あなたが制限をより合理的にするまで待つのではなく、単にそれらをバイパスする可能性が非常に高いです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロトコルに何かを実装する方法を見つけたが、それが</font><font style="vertical-align: inherit;">標準の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主要な概念の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1つをオーバーライドまたは実行する</font><font style="vertical-align: inherit;">場合、互換性とセキュリティの問題が確実に発生します。</font><font style="vertical-align: inherit;">そして、それらは決定と同時にカバーされる必要があります。</font><font style="vertical-align: inherit;">毎回。</font><font style="vertical-align: inherit;">このようなアドバイスに出会い、セキュリティ警告が表示されなかった場合は、インターネット全体でアドバイスを複製しないでください。</font><font style="vertical-align: inherit;">常に決定に対して批判的であり、何が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">うまくいか</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ないかを理解し</font><i><font style="vertical-align: inherit;">てください</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あとがきの代わりに</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロキシサーバーのどのような問題が発生しましたか？</font><font style="vertical-align: inherit;">何を回避する必要がありましたか？</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja492706/index.html">メモリアーカイブ：脳がどのようにメモリをエンコードおよび再現するか</a></li>
<li><a href="../ja492708/index.html">グローバル衛星インターネット-現場からのニュースはありますか？</a></li>
<li><a href="../ja492710/index.html">さまざまなHRMシステムによる候補者の厄介な経路</a></li>
<li><a href="../ja492712/index.html">UIテストを使用したAndroidでのテストによる開発の習得</a></li>
<li><a href="../ja492714/index.html">自宅からの効果的な仕事：一般的および個人的な</a></li>
<li><a href="../ja492720/index.html">diskussion：プロジェクトファイルサービス</a></li>
<li><a href="../ja492724/index.html">BjörnStraustrupがStack OverflowでC ++の質問トップ5に回答</a></li>
<li><a href="../ja492726/index.html">OS Sivelkiriya：ソフトウェア開発プロセス</a></li>
<li><a href="../ja492728/index.html">Telegram / Slack / E-mailでアスタリスクと送信を見逃した</a></li>
<li><a href="../ja492730/index.html">米国国防総省：AIと無人車両の倫理</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>