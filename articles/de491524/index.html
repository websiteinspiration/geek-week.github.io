<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎐 👵🏻 👩‍👩‍👧‍👧 Stas Afanasyev. Juno. Pipelines basierend auf io.Reader / io.Writer. Teil 2 🌷 👩🏿‍🔧 📤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In dem Bericht werden wir über das Konzept von io.Reader / io.Writer sprechen, warum sie benötigt werden, wie sie korrekt implementiert werden und wel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Stas Afanasyev. Juno. Pipelines basierend auf io.Reader / io.Writer. Teil 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/491524/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dem Bericht werden wir über das Konzept von io.Reader / io.Writer sprechen, warum sie benötigt werden, wie sie korrekt implementiert werden und welche Fallstricke diesbezüglich bestehen, sowie über das Erstellen von Pipelines basierend auf Standard- und benutzerdefinierten io.Reader / io.Writer-Implementierungen .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rd/nv/uj/rdnvujcjwsukejxq_6a9syayawu.jpeg"><a name="habracut"></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stas Afanasyev. </font><font style="vertical-align: inherit;">Juno. </font><font style="vertical-align: inherit;">Pipelines basierend auf io.Reader / io.Writer. </font><font style="vertical-align: inherit;">Teil 1</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehler "auf Vertrauen"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere Nuance: In dieser Implementierung gibt es einen „Bagul“. </font><font style="vertical-align: inherit;">Dieser Fehler wird von den Entwicklern bestätigt (ich habe ihnen darüber geschrieben). </font><font style="vertical-align: inherit;">Vielleicht weiß jemand, was dieser "Bagul" ist? </font><font style="vertical-align: inherit;">Es auf der Folie ist die vorletzte Zeile: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c9/kc/xj/c9kcxjodwjtycg7o2n62tfavto0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist mit zu viel Vertrauen in den umschlossenen Reader verbunden: Wenn der Reader eine negative Anzahl von Bytes zurückgibt, erhöht sich das Limit, das wir durch die Anzahl der subtrahierten Bytes erhalten möchten. </font><font style="vertical-align: inherit;">In einigen Fällen handelt es sich um einen ziemlich schwerwiegenden Fehler, den Sie nicht sofort verstehen können.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich schrieb in der Ausgabe: Lass uns etwas tun, lass es uns reparieren! Und dann wurde eine Schicht von Problemen aufgedeckt ... Zuerst sagten sie mir, wenn Sie diesen Scheck jetzt hier hinzufügen, müssen Sie diesen Scheck überall hinzufügen, und es gibt ein Dutzend dieser Orte. Wenn wir dies auf die Clientseite verschieben möchten, müssen wir eine Reihe von Regeln festlegen, nach denen der Client die Daten validiert (und es können auch fünf oder zwei davon sein). Es stellt sich heraus, dass all dies kopiert werden muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich bin damit einverstanden, dass dies nicht optimal ist. Dann kommen wir zu einer konsistenten Version! Warum haben wir eine Implementierung der Standardbibliothek, die nichts vertraut, während andere absolut alles vertrauen?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während ich meine bürgerliche Meinung schrieb und darüber nachdachte, schlossen wir das Thema im Allgemeinen mit Kommentaren ab: „Wir werden nichts tun. </font><font style="vertical-align: inherit;">Auf Wiedersehen"! </font><font style="vertical-align: inherit;">Sie haben mich wie eine Art Dummkopf aussehen lassen ... Politisch kann man natürlich keinen Fehler finden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen haben wir jetzt ein Problem. </font><font style="vertical-align: inherit;">Es besteht darin, dass nicht klar ist, wer die Daten des umschlossenen Readers validieren soll. </font><font style="vertical-align: inherit;">Entweder der Kunde oder wir vertrauen voll und ganz dem Vertrag ... Wir haben eine Lösung! </font><font style="vertical-align: inherit;">Wenn noch Zeit ist, werde ich davon erzählen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fahren wir mit dem nächsten Fall fort.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teereader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben uns ein Beispiel für das Umschließen von Reader-Daten angesehen. Das nächste Beispiel für Pipes ist das Überholen von Reader-Daten in Writer. Es gibt zwei Situationen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erste Situation. Wir müssen die Daten aus Reader lesen, sie irgendwie (transparent) in Writer kopieren und damit arbeiten wie mit Reader. Hierfür gibt es eine Implementierung von TeeReader. Es wird im oberen Implementierungs-Snippet vorgestellt: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ef/rl/jy/efrljy0zmyzxqk-7cbsbdkqialw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktioniert wie das Tee-Team unter Unix. Ich denke, viele von Ihnen haben davon gehört.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass diese Implementierung die Anzahl der Bytes überprüft, die vom umschlossenen Reader gelesen werden. Sehen Sie die Bedingungen in der zweiten Zeile? Denn wenn Sie eine solche Implementierung schreiben, ist intuitiv klar: Bei einer negativen Zahl geraten Sie in Panik. Und dies ist ein weiterer Ort, an dem wir dem verpackten Reader vertrauen! Ich erinnere Sie daran, dass dies alles Standardbibliotheken sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kommen wir zum Beispiel zu einem Fall, wie man ihn benutzt. Was machen wir mit dem unteren Snippet? Wir werden die robot.txt-Datei von golang.org mit dem Standard-http-Client herunterladen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie wissen, gibt der http-Client eine Antwortstruktur an uns zurück, in der das Body-Feld eine Implementierung der Reader-Schnittstelle ist. </font><font style="vertical-align: inherit;">Es sollte klargestellt werden, dass dies eine Implementierung der ReadCloser-Schnittstelle ist. </font><font style="vertical-align: inherit;">ReadCloser ist jedoch nur eine Schnittstelle, die aus Reader und Closer besteht. </font><font style="vertical-align: inherit;">Das heißt, dies ist ein Reader, der im Allgemeinen geschlossen werden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel (im unteren Snippet) sammeln wir TeeReader, der Daten aus diesem Body liest und in eine Datei schreibt. </font><font style="vertical-align: inherit;">Die Erstellung der Datei blieb heute leider hinter den Kulissen, da nicht alles passte. </font><font style="vertical-align: inherit;">Wenn Sie sich jedoch das Dendrogramm ansehen, implementiert der Dateityp die Writer-Schnittstelle, dh wir können darauf schreiben. </font><font style="vertical-align: inherit;">Es ist offensichtlich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben unseren TeeReader zusammengebaut und mit ReadAll gelesen. </font><font style="vertical-align: inherit;">Alles funktioniert wie erwartet: Wir subtrahieren den resultierenden Body, schreiben ihn in eine Datei und sehen ihn in Assad out.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfänger Weg</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite Situation. </font><font style="vertical-align: inherit;">Wir müssen nur die Daten aus dem Reader lesen und in den Writer schreiben. </font><font style="vertical-align: inherit;">Die Lösung liegt auf der Hand ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als ich gerade mit Go angefangen habe, habe ich Probleme wie auf einer Folie gelöst: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yu/yh/wx/yuyhwxfzki71ar1yp2myfgjffdc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe den Puffer gefunden, ihn mit Daten aus dem Reader gefüllt und das gefüllte Slice an Writer übertragen. </font><font style="vertical-align: inherit;">Alles ist einfach. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zwei Punkte. </font><font style="vertical-align: inherit;">Erstens gibt es keine Garantie dafür, dass der gesamte Reader in einem Aufruf der Read-Methode subtrahiert wird, da möglicherweise noch Daten übrig sind (dies sollte in einer Schleife erfolgen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Punkt ist, dass dieser Weg nicht optimal ist. </font><font style="vertical-align: inherit;">Hier ist hübscher Boilerplate-Code, der vor uns geschrieben wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu diesem Zweck gibt es in der Standardbibliothek eine spezielle Familie von Helfern: Copy, CopyN und CopyBuffer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Copy. </font><font style="vertical-align: inherit;">WriterTo und ReaderFrom</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
io.Copy macht im Grunde das, was es auf der vorherigen Folie war: Es weist einen Standardpuffer von 32 KB zu und schreibt Daten vom Reader zum Writer (die Signatur dieser Kopie wird im oberen Snippet angezeigt): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lx/wi/bd/lxwibd_hiz09op5baq0-d77ukrk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zu dieser Vorlagenroutine enthält es auch eine Reihe kniffliger Optimierungen. </font><font style="vertical-align: inherit;">Bevor wir über diese Optimierungen sprechen, müssen wir uns mit zwei weiteren Schnittstellen vertraut machen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WriterTo;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReadFrom.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hypothetische Situation. Ihr Reader arbeitet mit einem Speicherpuffer. Er hat es bereits verlegt, schreibt, liest etwas von dort, das heißt, ein Ort darunter wurde bereits verlegt. Sie möchten diesen Reader irgendwo von außen lesen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben bereits gesehen, wie dies geschieht: Ein Puffer wird erstellt, der Puffer wird übergeben, der an die Read-Methode übergeben wird; Der Reader, der mit dem Gedächtnis arbeitet, wirft es aus dem replizierten Stück heraus ... Aber das ist nicht mehr optimal - der Ort wurde neu positioniert. Warum nochmal? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/0h/sd/0b/0hsd0ba3ikgudka2q1ujxt9rtbc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor 5-6 Jahren (es gibt einen Link zur Änderungsliste) wurden zwei Schnittstellen erstellt: WriteTo und ReadFrom, die lokal implementiert sind. Reader implementiert WriteTo und Writer implementiert ReadFrom. Es stellt sich heraus, dass Reader mit einem Slice mit bereits replizierten Daten einen zusätzlichen Speicherort vermeiden und Write To Writer-Methoden akzeptieren und einen darin verfügbaren Puffer übergeben kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So funktioniert die Implementierung von bytes.Buffer und bufio. </font><font style="vertical-align: inherit;">Und wenn Sie sich das Dendrogramm noch einmal ansehen, werden Sie feststellen, dass diese beiden Schnittstellen nicht sehr beliebt sind. </font><font style="vertical-align: inherit;">Sie werden nur für diejenigen Typen implementiert, die mit dem internen Puffer arbeiten - wo der Speicher bereits verschoben ist. </font><font style="vertical-align: inherit;">Dies hilft Ihnen nicht, Beredsamkeit jedes Mal zu vermeiden, sondern nur, wenn Sie bereits mit einem umgesiedelten Stück arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReaderFrom funktioniert ähnlich (es wird nur von Writer implementiert). </font><font style="vertical-align: inherit;">ReaderFrom liest den gesamten Reader, der als Argument (vor EOF) dient, und schreibt irgendwo in die interne Implementierung von Writer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CopyBuffer-Implementierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Snippet zeigt die Implementierung des copyBuffer-Hilfsprogramms. Dieser nicht exportierbare copyBuffer wird unter der Haube von io.Copy, CopyN und CopyBuffer verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier gibt es eine kleine Nuance, die es wert ist, erwähnt zu werden. CopyN wurde kürzlich optimiert - unabhängig von dieser Logik. Dies ist genau die Optimierung, über die ich zuvor gesprochen habe: Bevor ein zusätzlicher Puffer von 32 KB erstellt wird, wird eine Überprüfung durchgeführt - möglicherweise implementiert die Datenquelle die WriterTo-Schnittstelle, und dieser zusätzliche Puffer wird nicht benötigt? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn dies nicht geschieht, überprüfen wir: Vielleicht implementiert Writer ReaderFrom, um sie ohne diesen Vermittler zu verbinden? Wenn dies nicht geschieht, bleibt die letzte Hoffnung: Vielleicht haben wir eine Art verschobenen Puffer erhalten, den wir verwenden könnten? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lz/yr/3q/lzyr3qrkehj5qudwoerwitlr6uq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So funktioniert io.Copy.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein Problem, nämlich einen Halbvorschlag, einen Halbfehler - es ist nicht klar, was. </font><font style="vertical-align: inherit;">Es hängt seit anderthalb Jahren. </font><font style="vertical-align: inherit;">Es klingt so: CopyBuffer ist semantisch falsch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider gibt es keine Signatur für diesen copyBuffer, aber es sieht genauso aus wie bei dieser nicht exportierbaren Methode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie copyBuffer aufrufen, um einen zusätzlichen Speicherort zu vermeiden, übertragen Sie dort eine Art verschobenes Slice-Byte. Die folgende Logik funktioniert: Wenn Reader oder Writer die Schnittstellen WriterTo und ReaderFrom implementieren, gibt es keine Garantie dafür, dass Sie diesen Speicherort vermeiden können. </font><font style="vertical-align: inherit;">Dies wurde als Vorschlag angenommen und versprochen, in Go 2.0 darüber nachzudenken. </font><font style="vertical-align: inherit;">Im Moment müssen Sie nur wissen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeiten Sie mit io.Pipe. </font><font style="vertical-align: inherit;">PipeReader und pipeWriter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein anderer Fall: Sie müssen Daten von Writer irgendwie in Reader erhalten. Hübscher Lebensfall. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich vor, Sie haben bereits einige Daten, sie implementieren die Reader-Oberfläche - damit ist alles klar. Sie müssen diese Daten komprimieren, optimieren und an S3 senden. Was ist die Nuance? .. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wer mit dem gzip-Typ im Compess-Paket gearbeitet hat, weiß, dass der gzip'er selbst nur ein Proxy ist: Er nimmt Daten in sich auf, implementiert die Writer-Schnittstelle, schreibt die Daten, etwas wird mit ihnen tun, und dann muss ich sie irgendwo fallen lassen. Auf dem Konstruktor ist eine Implementierung der Writer-Schnittstelle erforderlich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dementsprechend benötigen wir hier eine Art Zwischenschreiber, in dem wir die bereits komprimierten Daten löschen, die in der ersten Stufe archiviert werden. Unser nächster Schritt ist das Hochladen dieser Daten in S3. Der Standard-AWS-Client akzeptiert die io.Reader-Schnittstelle als Datenquelle. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-u/ai/hl/-uaihlpfwlyjeil6iorgelvue2a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Folie zeigt die Pipeline - sie zeigt, wie sie aussieht: Wir müssen die Daten überholen, um von Reader zu Writer, von Writer zu Reader zu überholen. Wie kann man das machen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Standardbibliothek hat eine coole Funktion - io.Pipe. Es werden zwei Werte zurückgegeben: pipeReader und pipeWriter. Dieses Paar ist untrennbar miteinander verbunden. Stellen Sie sich ein „Baby-Telefon“ in Tassen mit Seilen vor: Es macht keinen Sinn, in einer Tasse zu sprechen, während am anderen Ende niemand zuhört ...</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/zm/kj/rfzmkj2jivwatxxbukwdesrxvoe.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was macht diese io.Pipe? </font><font style="vertical-align: inherit;">Es wird nicht gelesen, bis niemand die Daten schreibt. </font><font style="vertical-align: inherit;">Und umgekehrt wird er nichts schreiben, bis niemand diese Daten am anderen Ende liest. </font><font style="vertical-align: inherit;">Hier ist eine Beispielimplementierung: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fk/qa/ze/fkqazendof7z_uoop8kbfzmtxuk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden das Gleiche hier tun. </font><font style="vertical-align: inherit;">Wir werden die zuvor gelesene Datei robot.txt lesen, sie mit unserem gzip komprimieren und an S3 senden.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der ersten Zeile wird ein Paar erstellt - pipeReader, pipeWriter. </font><font style="vertical-align: inherit;">Als nächstes müssen wir mindestens eine Goroutine ausführen, die Daten von einem Ende liest (eine Art Pipe). </font><font style="vertical-align: inherit;">Führen Sie in diesem Gorutin den Uploader mit einer Datenquelle (source - pipeReader) aus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im nächsten Schritt müssen wir die Daten komprimieren. </font><font style="vertical-align: inherit;">Wir komprimieren die Daten und schreiben sie in pipeWriter (es wird das andere Ende der Pipe sein), und bereits laufende Goroutine empfängt die Daten am anderen Ende der Pipe und liest sie. </font><font style="vertical-align: inherit;">Wenn dieses ganze Sandwich fertig ist, bleibt nur noch, den Docht in Brand zu setzen ...</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siehe: io.Copy in der letzten Zeile schreibt Daten vom Body in das von uns erstellte gzip (d. H. Vom Reader zum Writer). </font><font style="vertical-align: inherit;">All dies funktioniert wie erwartet.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Beispiel kann auf andere Weise gelöst werden. </font><font style="vertical-align: inherit;">Wenn Sie eine Implementierung verwenden, die sowohl Reader als auch Writer implementiert. </font><font style="vertical-align: inherit;">Sie schreiben zuerst Daten hinein und lesen sie dann. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es war eine klare Demonstration der Arbeit mit io.Pipe.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Implementierungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist im Grunde alles für mich. Wir kommen zu interessanten Implementierungen, über die ich sprechen möchte. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ei/9n/wd/ei9nwdzzrqc7ynwdvghvlokaujo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe weder zu MultiReader noch zu MultiWriter etwas gesagt. Und dies ist eine weitere coole Implementierung der Standardbibliothek, mit der Sie verschiedene Implementierungen verbinden können. Beispielsweise schreibt MultiWriter gleichzeitig in alle Writer und MultiReader liest die Reader nacheinander. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine andere Implementierung heißt limio. Hier können Sie ein Limit für die Subtraktion festlegen. Sie können die Geschwindigkeit in Bytes pro Sekunde einstellen, mit der Ihr Reader gelesen werden muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere interessante Implementierung ist nur eine Visualisierung des Lesefortschritts - der Fortschrittsbalken (von einem Typen). Es heißt ioprogress. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum habe ich das alles gesagt? Was habe ich damit gemeint?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ha/eq/hq/haeqhquljxa3dyvbxvhpdgn0cvu.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie plötzlich die Reader- und Writer-Schnittstellen implementieren müssen, machen Sie es richtig. </font><font style="vertical-align: inherit;">Es gibt noch keine einzige Entscheidung, wer für die Implementierung verantwortlich ist - wir gehen davon aus, dass jeder dem Vertrag vertraut. </font><font style="vertical-align: inherit;">Sie müssen sich also tadellos daran halten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Ihr Fall mit einem neu positionierten Puffer arbeitet, vergessen Sie nicht die Schnittstellen ReaderFrom und WriterTo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich in einer Sackgasse befinden und Beispiele benötigen - siehe Standardbibliothek - gibt es viele coole Implementierungen, auf die Sie sich verlassen können. </font><font style="vertical-align: inherit;">Dort gibt es Dokumentation.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Ihnen etwas völlig unverständlich ist, können Sie gerne Probleme schreiben. </font><font style="vertical-align: inherit;">Die Leute dort sind angemessen, reagieren schnell, sehr höflich und helfen Ihnen kompetent.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/vf/0y/cy/vf0ycy0f6kuyuyuygxoulwpy538.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles für mich. </font><font style="vertical-align: inherit;">Danke fürs Kommen!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frage des Publikums (B): - Ich habe eine einfache Frage, denke ich. Bitte erzählen Sie uns etwas über einige Anwendungsfälle aus dem Leben: Welche wurden verwendet und warum? Sie sagten, dass Reader / Writer die Länge zurückgibt, die es gelesen hat. Haben Sie jemals Probleme damit gehabt? Wann haben Sie nach Lesen gefragt (nicht nur ReadAll existiert), aber etwas hat nicht funktioniert? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ich muss ehrlich zugeben, dass ich solche Fälle nie hatte, weil ich immer mit Implementierungen der Standardbibliothek gearbeitet habe. Aber hypothetisch ist eine solche Situation natürlich möglich. In bestimmten Fällen sammeln wir häufig mehrschichtige Rohre. Wenn Sie einen solchen Fehler hypothetisch zulassen, fällt das gesamte Rohr auseinander ... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Das ist kein Fehler. Dann erzählen wir Ihnen von meiner kleinen Erfahrung. Ich hatte ein Problem mit Booking.com: Sie verwendeten den von mir geschriebenen Treiber und hatten ein Problem - etwas funktionierte nicht. Es gibt ein Standard-Binärprotokoll, das wir erstellt haben. lokal funktioniert alles gut, allen geht es gut, aber es stellte sich heraus, dass sie ein sehr schlechtes Netzwerk mit einem Rechenzentrum haben. Dann hat Reader nicht wirklich alles zurückgegeben (schlechte Netzwerkkarten, etwas anderes). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Aber wenn er nicht alles zurückgegeben hat, hätte er das Zeichen des Endes (des Endes) nicht zurückgeben sollen, und der Kunde sollte wiederkommen. Unter dem beschriebenen Vertrag sollte der Leser nicht ... Sagen wir einfach, dass der Leser natürlich entscheidet, wann er kommen möchte, wann er nicht möchte, aber wenn er alles lesen möchte, muss er auf EOF warten. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEIM:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Aber genau das liegt an der Verbindung." Dies ist genau das Problem, das im Standardnetzpaket aufgetreten ist. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Und er hat die EOF zurückgegeben? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Er hat nicht alles zurückgegeben - er hat einfach nicht alles gelesen. Ich sagte ihm: "Lies die nächsten 20 Bytes." Er liest. Und ich lese nicht alles. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Hypothetisch ist dies möglich, da es sich nur um eine Schnittstelle handelt, die ein Kommunikationsprotokoll beschreibt. Es ist notwendig, den Fall zu beobachten und speziell zu zerlegen. Hier kann ich Ihnen nur antworten, dass der Kunde theoretisch wieder hätte kommen sollen, wenn er nicht alles erhalten hätte, was er wollte. Sie haben ihn um eine Scheibe von 20 Bytes gebeten, er hat 15 für Sie abgezogen, aber EOF ist nicht gekommen - Sie sollten noch einmal gehen ... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Für diese Situation gibt es io.ReadFull. Es wurde speziell entwickelt, um die Scheibe bis zum Ende zu lesen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ja. Ich habe nichts über ReadFull gesagt. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Dies ist eine völlig normale Situation, wenn Read nicht den gesamten Slice ausfüllt. Sie müssen darauf vorbereitet sein. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Dies ist ein sehr erwarteter Fall! </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Danke für den Bericht - es war interessant. Ich verwende Readers in einem kleinen, einfachen Proxy, der http liest und in die andere Richtung schreibt. Ich benutze Close Reader, um ein Problem zu lösen - um das zu schließen, was ich ständig lese. Muss ich einem Vertrag blind vertrauen? Sie sagten, dass es Probleme geben könnte. Oder zusätzliche Schecks hinzufügen? Es ist theoretisch möglich, dass etwas auf dieser Seite nicht vollständig kommt. Muss ich diese zusätzlichen Überprüfungen durchführen und dem Vertrag nicht vertrauen? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ich würde Folgendes sagen: Wenn Ihre Anwendung diese Fehler toleriert (z. B. wenn Sie dem Vertrag voll vertrauen), dann möglicherweise nicht. Aber wenn Sie keine „Panik“ in sich haben möchten (wie ich bei einem negativen Messwert in Byte.Buffer gezeigt habe), würde ich trotzdem nachsehen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber das liegt ganz bei Ihnen. Was kann ich Ihnen empfehlen? Ich denke, nur die Vor- und Nachteile abwägen. Was passiert, wenn Sie plötzlich eine negative Anzahl von Bytes erhalten? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Danke für den Bericht. Leider weiß ich nichts in Go. Wenn eine „Panik“ aufgetreten ist, gibt es eine Möglichkeit, diese Informationen abzufangen und Informationen darüber zu erhalten, was, wo und wie man voreingenommen ist, um Probleme am Freitagabend zu vermeiden? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ja. Der Wiederherstellungsmechanismus ermöglicht es Ihnen, eine Panik zu "fangen" und sie zu beseitigen, ohne zu fallen, relativ gesehen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q_/xq/37/q_xq37jx6hjicmvwwhfhqdmyl7e.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEIM:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Wie stimmen Ihre Empfehlungen für die Verwendung von Implementierungen von Writer und Reader mit den Fehlern überein, die bei der Implementierung von Web-Sockets zurückgegeben werden? Ich werde kein konkretes Beispiel nennen, aber wird dort immer das Dateiende verwendet? Soweit ich mich erinnere, endet die Nachricht mit einigen anderen Bedeutungen ... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Dies ist eine gute Frage, weil ich einfach nichts zu beantworten habe. Müssen beobachten! Wenn EOF nicht kommt, muss der Kunde, wenn er alles bekommen will, wieder gehen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wie lange konnte das Rohr zusammengebaut werden? Gibt es interne Überzeugungen, dass es sich nicht lohnt, mehr als fünf Teilnehmer oder Zweigstellen zu sammeln? Wie lange haben Sie es geschafft, aus diesen Rohren einen Baum zu bauen (Lesen, Schreiben)? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- In meiner Praxis sind ungefähr fünf aufeinanderfolgende Anrufe optimal, da das Debuggen schwieriger ist. Denken Sie daran, was fließt und wohin es geht. Man erhält eine ziemlich verzweigte Struktur. Aber ich würde irgendwo maximal 5-7 sagen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 5-7 - in welchem ​​Fall? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Dies liest zum Beispiel einige Daten. Sie müssen versprechen, und was Sie anmelden, müssen Sie trimmen. Verpfändet - dann lesen Sie diese Daten - müssen Sie sie an einen Speicher zurücksenden (na ja, hypothetisch). In jedem Speicher, den die Writer-Schnittstelle implementiert. Bei dieser Pipe treten 5-6 Schritte auf, obwohl sie bei einem der Schritte immer noch zur Seite abzweigt und Sie weiterhin mit Reader arbeiten. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEIM:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Nach dem Anfängerweg hatten Sie eine interessante Folie. Können Sie weitere 2-3 interessante Punkte angeben, die es gab, aber jetzt ist es besser, sie nicht zu tun, sondern jetzt anders zu machen? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Mit dieser Folie wollte ich genau zeigen, wie es geht, ohne Reader lesen zu müssen. Mir ist nie in den Sinn gekommen, dass so etwas wie der Anfänger-Weg ... Dies ist wahrscheinlich der Hauptfehler, das Hauptmuster, das bei der Arbeit mit Lesern vermieden werden sollte. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Moderator: - Ich möchte selbst hinzufügen, dass es für Anfänger sehr wichtig ist, die gesamte Dokumentation des io-Pakets auf allen vorhandenen Schnittstellen zu lesen und zu verstehen. Denn tatsächlich gibt es viele davon, und Sie beginnen oft, etwas Eigenes zu tun, obwohl es dort bereits vorhanden und korrekt implementiert ist („richtig“ - unter Berücksichtigung aller Funktionen). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frage des Führers: - Wie kann man weiter leben?</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Gute Frage! Ich habe versprochen zu sagen, ob wir Zeit haben. Als Ergebnis der Diskussion des Fehlers traf LimitedReader die folgende Entscheidung: Um ein Reader-Kondom herzustellen, das in gewisser Weise vor externen Bedrohungen schützt, wickeln Sie einen Reader ein, dem Sie nicht vertrauen - um zu verhindern, dass eine Infektion in Ihr System eindringt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und in diesem Reader implementieren Sie alle Überprüfungen, die Sie nicht durchführen können: zum Beispiel negatives Lesen, Experimente mit der Anzahl der Bytes (Nehmen wir an, Sie haben einen Slice von 10 Bytes gesendet und 15 zurückbekommen - wie sollen Sie darauf reagieren?) ... Reader und Sie können eine Reihe solcher Überprüfungen implementieren. Ich sagte: "Vielleicht wollen wir die Standardbibliothek erweitern, weil es für alle nützlich wäre, sie zu verwenden."</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mir wurde die Antwort gegeben, dass dies keinen Sinn zu haben scheint - dies ist eine einfache Sache, die Sie selbst implementieren können. Alle. Wir leben weiter. Wir vertrauen den Vertragsleuten. Aber ich würde nicht vertrauen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gj/e0/_c/gje0_c2o6hhots_d3d5hvnfhgnm.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wenn wir mit Lesern, Schriftstellern zusammenarbeiten und die Möglichkeit besteht, auf eine gzip-Bombe zu stoßen ... Wie sehr vertrauen wir auf ReadAll und WriteAll? Oder trotzdem Pufferlesung implementieren und nur mit dem Puffer arbeiten? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ReadAll selbst verwendet nur Bytes. Puffer unter der Haube. </font><font style="vertical-align: inherit;">Wenn Sie dieses oder jenes Ding verwenden möchten, ist es ratsam, einzusteigen und zu sehen, wie diese "Eingeweide" umgesetzt werden. </font><font style="vertical-align: inherit;">Auch dies hängt von Ihren Anforderungen ab: Wenn Sie solche Fehler, die ich gezeigt habe, nicht tolerieren, müssen Sie prüfen, ob überprüft wird, was vom verpackten Reader kommt. </font><font style="vertical-align: inherit;">Wenn es nicht aktiviert ist, verwenden Sie zum Beispiel bufio (dort ist alles aktiviert). </font><font style="vertical-align: inherit;">Oder tun Sie, was ich gerade gesagt habe: einen bestimmten Proxy-Reader, der diese Daten gemäß Ihrer Anforderungsliste überprüft und entweder an den Client oder an den Client zurückgibt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ye/of/v1/yeofv1zmhlx3zoyv26wsh5mxway.jpeg"><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/kuyjuGk1USY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen Werbung :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielen Dank für Ihren Aufenthalt bei uns. Gefällt dir unser Artikel? Möchten Sie weitere interessante Materialien sehen? Unterstützen Sie uns, indem Sie eine Bestellung </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">aufgeben</font></a><font style="vertical-align: inherit;"> oder Ihren Freunden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud-basiertes VPS für Entwickler ab 4,99 US-Dollar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> empfehlen </font><font style="vertical-align: inherit;">, ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einzigartiges Analogon von Einstiegsservern, das von uns für Sie erfunden wurde: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ganze Wahrheit über VPS (KVM) E5-2697 v3 (6 Kerne) 10 GB DDR4 480 GB SSD 1 Gbit / s ab 19 $ oder wie teilt man den Server?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verfügbar). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2-mal günstiger im Equinix Tier IV-Rechenzentrum in Amsterdam?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nur wir haben </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2,6 GHz 14C 64 GB DDR4 4 x 960 GB SSD 1 Gbit / s 100 TV von 199 US-Dollar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in den Niederlanden!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2,2 GHz 6C 128 GB DDR3 2x960 GB SSD 1 Gbit / s 100 TB - ab 99 US-Dollar! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr über</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Aufbau eines Infrastrukturgebäudes. </font><font style="vertical-align: inherit;">Klasse C mit Dell R730xd E5-2650 v4-Servern für 9.000 Euro für einen Cent?</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491510/index.html">Erstellen Sie Ihr Bild mit reinem CentOS 8.1 in der Amazon Cloud</a></li>
<li><a href="../de491512/index.html">Warum Mr. Robot die beste Serie über die IT-Branche ist</a></li>
<li><a href="../de491518/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 501 (18.02.2020, 24.02.2020)</a></li>
<li><a href="../de491520/index.html">Konvertieren Sie xls in xlsx und xml in C #</a></li>
<li><a href="../de491522/index.html">Warum leben Frauen länger?</a></li>
<li><a href="../de491528/index.html">Meine Erfahrung ist die Durchführung von 1000 Interviews. Zusammenfassung des Berichts von Yegor Bugaenko</a></li>
<li><a href="../de491530/index.html">Nochmals ca. 433 MHz Sender und Empfänger</a></li>
<li><a href="../de491532/index.html">Laravel + Docker + Gitlab. Wo soll ich anfangen?</a></li>
<li><a href="../de491534/index.html">Eine kurze Anleitung zur Verwendung von GDB</a></li>
<li><a href="../de491536/index.html">YouTube - Fehler. Bitte versuchen Sie es später noch einmal. Wiedergabe-ID: <...></a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>