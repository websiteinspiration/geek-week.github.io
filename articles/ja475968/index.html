<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏿 👨🏻‍🌾 🥂 興味深いニュースVue 3 ✌🏼 👸🏼 🧘🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="序文の代わりに
 VueはすべてのFunCorpプロジェクトで使用されます。私たちはフレームワークの開発を注意深く監視し、開発プロセスを常に改善し、ベストプラクティスを実装します。そしてもちろん、VueStorefrontの共同創設者であるPhilip Rakovskyによる、コードの記述に深刻な影...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>興味深いニュースVue 3</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/475968/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序文の代わりに</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VueはすべてのFunCorpプロジェクトで使用されます。私たちはフレームワークの開発を注意深く監視し、開発プロセスを常に改善し、ベストプラクティスを実装します。そしてもちろん、VueStorefrontの共同創設者であるPhilip Rakovskyによる、コードの記述に深刻な影響を与える新しいVue 3機能についての記事は、通すことも翻訳することもできませんでした。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ta/6z/aq/ta6zaqz4kxyqh_wh0zoo4zayqeo.png" alt="画像"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、Vue 3のパフォーマンスに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">影響を与える機能について説明しました</font><font style="vertical-align: inherit;">。新しいバージョンのフレームワークで作成されたアプリケーションは非常に高速に動作しますが、パフォーマンスは最も重要な変更ではありません。ほとんどの開発者にとって、Vue 3がコードの記述方法にどのように影響するかは、はるかに重要です。</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご想像のとおり、Vue 3には多くの優れた機能があります。</font><font style="vertical-align: inherit;">幸いなことに、Vueチームは重大な変更よりも多くの機能強化と追加を行いました。</font><font style="vertical-align: inherit;">このため、Vue 2を知っているほとんどの開発者は、新しい構文にすぐに慣れるはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの人が聞いたことのあるAPIから始めましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポジションAPI</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポジションAPIは、Vueの次のメジャーバージョンで最も話題になり、言及されている機能です。コンポジションAPI構文は、コードを整理して再利用するためのまったく新しいアプローチを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプションAPIと呼ばれる構文でコンポーネントを作成しています。ロジックを追加するために、コンポーネントオブジェクトにプロパティ（オプション）を作成します（データ、メソッド、計算など）。このアプローチの主な欠点は、それ自体がJavaScriptコードではないことです。テンプレートで使用できるオプションとこれがどのようになるかを正確に知る必要があります。 Vueコンパイラーは、プロパティーを機能するJavaScriptコードに変換します。この機能のため、オートコンプリートまたはタイプチェックを完全には使用できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポジションAPIはこの問題を解決し、通常のJavaScript関数を使用するオプションを通じて利用可能なメカニズムを使用できるようにします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vueチームは、Composition APIを「コンポーネントロジックでのコンポジションの柔軟な使用を可能にする機能ベースのオプションのAPI」と説明しています。</font><font style="vertical-align: inherit;">新しいAPIを使用して記述されたコードは読みやすく、理解しやすくなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい構文の仕組みを理解するために、単純なコンポーネントの例を考えてみましょう。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"increment"</span>&gt;</span><font></font>
    Count is: {{ count }}, double is {{ double }}, click to increment.<font></font>
  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref, computed, onMounted } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  setup() {
    <span class="hljs-keyword">const</span> count = ref(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">const</span> double = computed(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> count.value * <span class="hljs-number">2</span>)

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>{
      count.value++
    }

    onMounted(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'component mounted!'</span>))

    <span class="hljs-keyword">return</span> {
      count,
      double,
      increment
    }
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードを部分に分割し、ここで何が起こっているかを分析します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { ref, computed, onMounted } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先に述べたように、Composition APIはコンポーネントオプションを関数として提示するため、まず必要な関数をインポートする必要があります。</font><font style="vertical-align: inherit;">この例では、computeを使用して計算されたrefを使用してリアクティブプロパティを作成し、onMounted関数を使用してマウントされたライフサイクルフックにアクセスする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
質問があるかもしれません：この不可解なセットアップ方法は何ですか？</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {<font></font>
  setup() {}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、セットアップはプロパティと関数をテンプレートに渡す関数にすぎません。</font><font style="vertical-align: inherit;">すべての反応プロパティと計算プロパティ、ライフサイクルフック、およびすべてのオブザーバーをセットアップ関数で記述し、それらをテンプレートで使用するために返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セットアップから戻るわけではないため、テンプレートにはアクセスできません。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> count = ref(<span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
count反応性プロパティは、ref関数を使用して初期化されます。</font><font style="vertical-align: inherit;">プリミティブまたはオブジェクトを取り、リアクティブリンクを返します。</font><font style="vertical-align: inherit;">渡された値は、作成されたリンクのvalueプロパティに格納されます。</font><font style="vertical-align: inherit;">たとえば、countの値にアクセスする場合は、count.valueに明示的にアクセスする必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> double = computed(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> count.value * <span class="hljs-number">2</span>)<font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>{<font></font>
  count.value++<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、計算されたdoubleプロパティとインクリメント関数を宣言します。 </font></font><br>
<br>
<pre><code class="javascript hljs">onMounted(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'component mounted!'</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
onMountedフックを使用して、コンポーネントのマウント後にメッセージをコンソールに出力し、この可能性を示します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">return</span> {<font></font>
  count,<font></font>
  double,<font></font>
  increment<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
countプロパティとdoubleプロパティ、およびincrementメソッドがテンプレートで使用できるように、それらをsetupメソッドから返します。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"increment"</span>&gt;</span><font></font>
    Count is: {{ count }}, double is {{ double }}. Click to increment.<font></font>
  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして出来上がり！</font><font style="vertical-align: inherit;">古いオプションAPIを通じて宣言されたかのように、セットアップからプロパティとメソッドにアクセスできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは単純な例であり、同様のものはオプションAPIを使用して簡単に記述できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、新しいComposition APIの利点は、異なるスタイルでコードを作成できることではなく、ロジックを再利用する可能性が開かれたことです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポジションAPIでコードを再利用する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードを再利用する場合など、新しいComposition APIの利点を詳しく見てみましょう。さて、いくつかのコードでいくつかのコードを使用したい場合、ミックスインとスコープスロットの2つのオプションがあります。どちらのオプションにも欠点があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カウンターの機能を抽出し、他のコンポーネントで再利用したいと考えています。これは、既存のAPIと新しいAPIを使用してこれを行う方法の例です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、ミックスインを使用した実装を見てみましょう。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> CounterMixin <span class="hljs-keyword">from</span> <span class="hljs-string">'./mixins/counter'</span><font></font>
 <font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">mixins</span>: [CounterMixin]<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの最大の問題は、コンポーネントに何が追加されるかについて何も知らないことです。</font><font style="vertical-align: inherit;">これは理解を困難にし、既存のプロパティやメソッドとの競合につながる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、スコープが制限されたスロットについて考えます。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"{ count, increment }"</span>&gt;</span><font></font>
     {{ count }}<font></font>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"increment"</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> 
  <span class="hljs-tag">&lt;/<span class="hljs-name">Counter</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スロットを使用すると、v-slotディレクティブを介してアクセスできるプロパティを正確に把握できます。これは非常に簡単に理解できます。</font><font style="vertical-align: inherit;">このアプローチの欠点は、Counterコンポーネントのデータにしかアクセスできないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Composition APIを使用した実装を検討します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useCounter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> count = ref(<span class="hljs-number">0</span>)
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span> (<span class="hljs-params"></span>) </span>{ count.value++ }<font></font>
 <font></font>
  <span class="hljs-keyword">return</span> {<font></font>
    count,<font></font>
    incrememt<font></font>
  }<font></font>
}<font></font>
 <font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {<font></font>
  setup () {<font></font>
    <span class="hljs-keyword">const</span> { count, increment } = useCounter()
    <span class="hljs-keyword">return</span> {<font></font>
      count,<font></font>
      increment<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はるかにエレガントに見えますよね？テンプレートやスコープに制限されることはなく、どのカウンタープロパティが利用できるかは確かです。また、useCounterはデータを返す関数にすぎないため、エディターでコードを補完できます。ここには魔法はありません。そのため、エディターは型チェックを助け、ヒントを与えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サードパーティのライブラリを使用することも見栄えが良くなります。たとえば、Vuexを使用したい場合は、useStore関数を明示的にインポートして、これでVueプロトタイプを詰まらせないようにすることができます。このアプローチにより、プラグインの追加操作を取り除くことができます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> { commit, dispatch } = useStore()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Composition APIとそのアプリケーションについて詳しく知りたい場合は、Vueチームが新しいAPIを作成する理由を説明し、それが役立つケースを提供しているドキュメントを読むことをお勧めします。</font><font style="vertical-align: inherit;">Vueコアチームのメンバーの1つであるThorstenLünborgの構成APIの使用例が収められた素晴らしいリポジトリもあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成とマウントの変更</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいVueには、アプリケーションの構築および構成方法に他の重要な変更があります。</font><font style="vertical-align: inherit;">例を見てみましょう。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span><font></font>
 <font></font>
Vue.config.ignoredElements = [<span class="hljs-regexp">/^app-/</span>]<font></font>
Vue.use(<span class="hljs-comment">/* ... */</span>)<font></font>
Vue.mixin(<span class="hljs-comment">/* ... */</span>)<font></font>
Vue.component(<span class="hljs-comment">/* ... */</span>)<font></font>
Vue.directive(<span class="hljs-comment">/* ... */</span>)<font></font>
 <font></font>
<span class="hljs-keyword">new</span> Vue({
  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)<font></font>
}).$mount(<span class="hljs-string">'#app'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、Vueグローバルオブジェクトを使用して、新しいVueインスタンスを構成および作成しています。</font><font style="vertical-align: inherit;">Vueオブジェクトに加えた変更は、最終的なインスタンスとコンポーネントに影響します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがVue 3でどのように機能するか見てみましょう。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span><font></font>
 <font></font>
<span class="hljs-keyword">const</span> app = createApp(App)<font></font>
 <font></font>
app.config.ignoredElements = [<span class="hljs-regexp">/^app-/</span>]<font></font>
app.use(<span class="hljs-comment">/* ... */</span>)<font></font>
app.mixin(<span class="hljs-comment">/* ... */</span>)<font></font>
app.component(<span class="hljs-comment">/* ... */</span>)<font></font>
app.directive(<span class="hljs-comment">/* ... */</span>)<font></font>
 <font></font>
app.mount(<span class="hljs-string">'#app'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでにお気づきのとおり、この構成はcreateAppを使用して作成された特定のVueインスタンスを参照しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、コードが読みやすくなり、サードパーティのプラグインで予期しない問題が発生する可能性が減少します。</font><font style="vertical-align: inherit;">現在、Vueグローバルオブジェクトを変更するサードパーティライブラリは、予期しない場所（特にグローバルミックスインの場合）でアプリケーションに影響を与える可能性があります。これは、Vue 3では不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの変更</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RFCで</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">議論さ</font></a><font style="vertical-align: inherit;">れており、将来的には実装が異なる可能性があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグメント</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vue 3で期待できるもう1つの優れた機能</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
は、フラグメントとは何ですか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、コンポーネントはルート要素を1つしか持つことができません。つまり、以下のコードは機能しません。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>World<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その理由は、各コンポーネントの背後に隠れているVueインスタンスは、1つのDOM要素にしかアタッチできないためです。これで、いくつかのルート要素を持つコンポーネントを作成する方法があります。そのためには、独自のVueインスタンスを必要としない機能的なスタイルでコンポーネントを作成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ問題がReactコミュニティーにも存在することがわかりました。仮想Fragmentエレメントを使用して解決されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Columns</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{<font></font>
  render() {<font></font>
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>World<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span><font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fragmentは通常のDOM要素のように見えるという事実にもかかわらず、それは仮想であり、DOMツリーで作成されません。</font><font style="vertical-align: inherit;">このアプローチでは、DOMに追加の要素を作成せずに、単一のルート要素の機能を使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vue 2でフラグメントを使用できるようになりましたが、Vue-fragmentsライブラリーを使用すると、Vue 3ではそのまま使用できます！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サスペンス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vue 3に実装されるReactエコシステムのもう1つの素晴らしいアイデアは、サスペンスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suspenseはコンポーネントのレンダリングを一時停止し、特定の条件が満たされるまでスタブを表示します。</font><font style="vertical-align: inherit;">Vue Londonで、Ewan YuがさりげなくSuspenseに触れ、将来期待できるAPIを明らかにしました。</font><font style="vertical-align: inherit;">サスペンスコンポーネントには、コンテンツ用とスタブ用の2つのスロットがあります。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> &gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Suspended-component</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span><font></font>
    Loading...<font></font>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタブは、&lt;Suspended-component /&gt;コンポーネントの準備ができるまで表示されます。</font><font style="vertical-align: inherit;">サスペンスコンポーネントは、非同期コンポーネントをロードしたり、セットアップ機能でいくつかの非同期アクションを実行したりすることもできます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数のvモデル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
v-modelは、双方向バインディングを使用できるディレクティブです。</font><font style="vertical-align: inherit;">リアクティブプロパティを渡して、コンポーネント内で変更できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォーム要素の操作でよく知られています。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"property"</span> /&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、v-modelはどのコンポーネントでも使用できることをご存知ですか？</font><font style="vertical-align: inherit;">内部的には、v-modelはvalueパラメータを転送し、入力イベントをリッスンしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この構文を使用して前の例を次のように書き換えることができます。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
  <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">"property"</span>
  <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">"property = $event.target.value"</span>
/&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルオプションを使用して、デフォルトのプロパティ名とイベントを変更することもできます。</font></font><br>
<br>
<pre><code class="javascript hljs">model: {
  <span class="hljs-attr">prop</span>: <span class="hljs-string">'checked'</span>,
  <span class="hljs-attr">event</span>: <span class="hljs-string">'change'</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、コンポーネントで双方向バインディングを使用する場合、v-modelディレクティブは非常に便利な「構文上の砂糖」になります。</font><font style="vertical-align: inherit;">残念ながら、コンポーネントごとに存在できるvモデルは1つだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、Vue 3ではこの問題は解決されます。</font><font style="vertical-align: inherit;">名前をv-modelに渡し、必要なだけv-modelを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用例：</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">InviteeForm</span>
  <span class="hljs-attr">v-model:name</span>=<span class="hljs-string">"inviteeName"</span>
  <span class="hljs-attr">v-model:email</span>=<span class="hljs-string">"inviteeEmail"</span>
/&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの変更</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RFCで</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">議論さ</font></a><font style="vertical-align: inherit;">れており、将来的には実装が異なる可能性があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポータル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポータルは、現在のコンポーネントの階層外にあるコンテンツをレンダリングするために作成されたコンポーネントです。これも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reactに実装されて</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いる機能の1つです</font><font style="vertical-align: inherit;">。 Reactのドキュメントでは、ポータルは次のように説明されています。「ポータルを使用すると、親コンポーネントのDOM階層の外にあるDOMノードで子をレンダリングできます。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポータルは、モーダルウィンドウ、ポップアップ、およびページの上部に表示する必要があるすべてのコンポーネントなどのコンポーネントを実装するのに最適です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポータルを使用する場合、親コンポーネントのスタイルが子コンポーネントに影響を及ぼさないようにすることができます。また、汚いz-indexハックからあなたを救います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポータルごとに、ポータルコンテンツの表示先を指定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、ポータルをVue 2に追加するportal-vueライブラリの実装オプションです。 </font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">portal</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"destination"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This slot content will be rendered wherever the portal-target with name 'destination'<font></font>
    is  located.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">portal</span>&gt;</span><font></font>
 <font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">portal-target</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"destination"</span>&gt;</span>
  <span class="hljs-comment">&lt;!--
  This component can be located anywhere in your App.
  The slot content of the above portal component wilbe rendered here.
  --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">portal-target</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vue 3では、この機能はそのまま使用できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいカスタムディレクティブAPI</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カスタムディレクティブAPIは、コンポーネントのライフサイクルによりよく一致するようにVue 3のビットを少し変更します。</font><font style="vertical-align: inherit;">ディレクティブを作成すると、より直感的になるため、初心者にとって理解と学習が容易になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、カスタムディレクティブ宣言は次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> MyDirective = {<font></font>
  bind(el, binding, vnode, prevVnode) {},<font></font>
  inserted() {},<font></font>
  update() {},<font></font>
  componentUpdated() {},<font></font>
  unbind() {}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vue 3では、次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> MyDirective = {<font></font>
  beforeMount(el, binding, vnode, prevVnode) {},<font></font>
  mounted() {},<font></font>
  beforeUpdate() {},<font></font>
  updated() {},<font></font>
  beforeUnmount() {}, <span class="hljs-comment">// new</span><font></font>
  unmounted() {}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは重大な変更ですが、互換性のあるVueビルドで使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このAPIについても</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明されて</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おり、将来変更される可能性があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大幅な革新-コンポジションAPI-の次に、いくつかの小さな改善点を見つけることができます。</font><font style="vertical-align: inherit;">明らかに、Vueは、開発者エクスペリエンスの向上、シンプルで直感的なAPIの方に向かっています。</font><font style="vertical-align: inherit;">また、Vueチームが、サードパーティのライブラリにすでに実装されているフレームワークのコアに多くのアイデアを追加することを決定したこともクールです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のリストには、最も重要なAPIの改善と変更のみが含まれています。</font><font style="vertical-align: inherit;">他について知りたい場合は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、RFCリポジトリを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェックし</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">て</font></a><font style="vertical-align: inherit;">ください</font><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja475944/index.html">ランニングは、よりリモートな人にとって理想的なスポーツです。パート2：物理学と材料</a></li>
<li><a href="../ja475948/index.html">JHレインウォーター「猫の放牧方法」（パート2）：習得する必要のあるすべてのこと</a></li>
<li><a href="../ja475950/index.html">ロボットがゴルフボールの収集に限定するのはなぜですか？テニスもあります</a></li>
<li><a href="../ja475956/index.html">光学式テキスト認識技術をどのように作成したか。YandexのOCR</a></li>
<li><a href="../ja475958/index.html">ITの少女が集まった物語</a></li>
<li><a href="../ja475974/index.html">電車でハッカソンを作った方法とそれから来たもの</a></li>
<li><a href="../ja475978/index.html">電車の本部は何のためですか？</a></li>
<li><a href="../ja475980/index.html">接続性、アーキテクチャ、チーム編成が低い</a></li>
<li><a href="../ja475982/index.html">外国語を学ぶ方法</a></li>
<li><a href="../ja475986/index.html">PocketBook 740 Proリーダーの概要：7.8インチ、オーディオおよびIPX8保護</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>