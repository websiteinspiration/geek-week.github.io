<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘†ğŸ¿ ğŸ‘¨ğŸ¾ â” Pengembangan firmware untuk kamera video analog EVR-Y2022F ğŸ‘©ğŸ»â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ‘« ğŸ‰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya, perangkat kamera video analog diperiksa dengan sangat rinci untuk membuat firmware sendiri. Seperti yang telah disebutkan, k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pengembangan firmware untuk kamera video analog EVR-Y2022F</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499546/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam artikel sebelumnya, perangkat kamera video analog diperiksa dengan sangat rinci untuk membuat firmware sendiri. Seperti yang telah disebutkan, kamera memiliki mikrokontroler yang tidak diketahui asalnya. Ini jauh lebih kaya daripada AVR biasa: ia memiliki dua tegangan suplai 3.3V dan 1.8V, dan juga, ia memiliki fungsi DSP. Saya sampai pada kesimpulan ini ketika saya berpikir tentang implementasi algoritma autofocus. Namun demikian, saya tidak suka MK kompleks seperti STM32 dan yang lainnya, kalau saja karena saya tidak pernah bekerja dengan mereka sama sekali. Saya pasti membuat keputusan bahwa saya akan menggunakan salah satu AVR MK untuk mengimplementasikan firmware saya. Oleh karena itu, sudah pada tahap ini saya mulai menyadari bahwa implementasi fungsi autofocus tidak akan mudah ditangani, atau lebih tepatnya, tidak mungkin.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pilihan saya jatuh pada ATmega128 MK, karena dialah yang jatuh ke lenganku. ATmega8 MK jelas tidak akan cukup dalam hal jumlah kesimpulan, terutama karena, untuk berjaga-jaga, saya memutuskan untuk memesan seluruh port MK untuk input aliran video digital dari prosesor video. Pertama-tama, saya mencari tahu fungsi apa yang akan ada dalam firmware saya sendiri, khususnya, fungsi yang tidak ada dalam firmware asli, dan fungsi mana yang harus diabaikan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita pertimbangkan varian dari algoritma autofokus untuk menganalisis aliran video digital. Saya berhasil menemukan bahwa data aliran video adalah pergantian byte yang disinkronkan dengan pulsa "CK". Byte dari stream video mengkodekan level komponen Y, Cr, Cb dari sinyal video dengan gradasi 8-bit (level 256). Artinya, output video digital dari prosesor video kamera ini adalah komponen-multiplexed. Informasi tentang kecerahan (Y) terkandung dalam setiap byte kedua dari aliran video, dan informasi tentang warna dua kali lebih jarang. Artinya, informasi tentang sinyal perbedaan warna Cr merah terkandung dalam setiap byte keempat, serta informasi tentang sinyal perbedaan warna biru. Dengan demikian, aliran mewakili urutan berikut: Cb0, Y0, Cr0, Y1, Cb2, Y2, Cr2, Y3, Cb4, Y4, Cr4, Y5, .... Yaitu,sementara informasi tentang kecerahan setiap piksel datang tanpa celah, informasi tentang warna piksel masuk secara komponen secara berurutan. Penipisan ini disebabkan oleh sifat tidak sensitif terhadap warna detail kecil dan pengurangan pita warna pada sinyal video. Properti ini digunakan dalam digitalisasi televisi dan video analog. "Kompresi" di atas (subsampling warna) memiliki rasio komponen 4: 2: 2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar algoritma fokus otomatis berfungsi, cukup menganalisis hanya komponen kecerahan, yang juga mudah dicapai dengan menyadap aliran video "byte demi byte". Jika frekuensi CK adalah sekitar 18 MHz, maka CK / 2 adalah 9 MHz, yang tampaknya cukup mungkin untuk ATmega128 MK. Denyut sinkronisasi horizontal dan vertikal memungkinkan pengontrol untuk "menghitung" dan menganalisis area gambar apa pun. Mungkin, untuk algoritma autofocus, cukup menganalisis hanya pusat raster. Jelas, semakin baik fokus, semakin tajam gambar, dan karenanya semakin lebar pita frekuensi sinyal video (lebih banyak komponen RF). Artinya, dimungkinkan (bahkan perlu) untuk menerapkan algoritma Fast Fourier Transform (FFT) ke fragmen aliran video digital dan menganalisis komponen RF. Dalam hal ini, Anda perlu memutar fokus fokus setiap kali,menggunakan metode "setengah divisi" sebagai metode optimasi matematika. Dengan demikian, Anda dapat mencapai hasil terbaik.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak repot dengan fungsi autofokus, mengingat bahwa tidak mungkin pada MK dengan arsitektur sederhana, meskipun, dalam hal apa pun, saya memesan port untuk video digital. Alih-alih fokus otomatis, saya memutuskan untuk mengimplementasikan sejumlah fungsi lain yang tidak tersedia di firmware asli. Tetapi untuk ini, kamera video harus dibatasi pada kondisi stasioner, yang khas untuk pengawasan video. Diasumsikan bahwa kamera selanjutnya akan dapat berputar pada bidang horizontal dan vertikal menggunakan mekanisme khusus, baik secara otomatis maupun manual. Ketika kamera secara otomatis diarahkan ke objek tertentu, koordinat bola yang akan disimpan sebelumnya dalam memori perangkat kontrol, "koordinat" zoom dan fokus juga akan berubah, yang juga akan dipilih sebelumnya dan disimpan dalam memori.Manajemen dapat diatur sesuai dengan protokol PELCO-D, apalagi, dalam spesifikasi protokol ini ada tim khusus untuk bisnis ini. Koordinat zoom dan fokus, tentu saja, akan "dipasangkan" untuk jarak tertentu. Artinya, objek yang akan ditempatkan pada jarak tertentu akan fokus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum Anda mulai menulis program firmware, Anda perlu memikirkan peripheral MK mana dan kesimpulan apa yang akan terlibat. Maka Anda perlu berpikir tentang cara menempatkan dan memperbaiki papan dengan MK sendiri di dalam kamera. Dan agar itu senyaman dan terpelihara mungkin. Saya memutuskan untuk menggunakan papan dengan MK, yang kesimpulannya akan sepenuhnya dialihkan ke sisi kiri dan kanan. Papan akan terletak di bagian bawah kamera, di mana ada sedikit ruang, dan akan diadakan pada koneksi yang dapat dilepas. Pada saat yang sama, akan ada "pin" konektor pada papan itu sendiri, dan akan ada soket kawin di sisi kamera. Untuk soket respons, saya memutuskan untuk membuat dua papan adaptor lagi, seukuran sisi kamera. Lama kartu-kartu ini menuju ke sisi atas kamera, langsung ke papan utama. Diasumsikan bahwa setiap lamella akan ditransfer ke titik yang diinginkan di papan utama kamera.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selama pengembangan papan dengan MK, saya punya ide untuk melengkapi camcorder dengan jam (RTC), dan saya menyoroti garis I2C, ditempatkan di papan RTC DS1307 (saya sudah tahu apa-apa) dengan kuarsa dan baterai dan, untuk berjaga-jaga, EEPROM 24AA512, yang merupakan dengan tangan. Juga di papan di tepi atas adalah konektor untuk menghubungkan programmer SPI dan JTAG. Pada motherboard asli, MK clock dari 12 MHz kuarsa. Itu sama bagi saya. Secara umum, lebih baik untuk meletakkan kuarsa di 11,0592 MHz di sana untuk operasi UART yang jelas. Jarak antara "sisir" sambungan yang bisa dilepas dengan hati-hati saya perhitungkan sebelumnya. Saya memutuskan untuk memberi makan MK dari lima volt "Krenka", yang akan disekrup ke bingkai di bawah papan utama (itu juga akan berfungsi sebagai pendingin). Daya akan diambil dari tegangan input 12V segera setelah sekering FB801, seperti yang ditunjukkan pada gambar.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pk/rs/q8/pkrsq8mtjjredo8w2mfne5goziy.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 1. Manajemen daya mikrokontroler.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Saat menggambar papan di "SprintLayout", saya bertanya-tanya tujuan masing-masing pin dari MK, yang merupakan output "keluar" ke konektor. Hasilnya adalah gambar seperti itu. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/95/xg/bm95xgf-akgycofwc_mdsjp8rki.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 2. Sketsa papan sirkuit cetak tambahan.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sejujurnya, saya menggambar papan samping (di sepanjang tepi) pada tahap penulisan artikel ini. Tapi sebenarnya, saya membuatnya dengan pemotong. Ternyata bukan opsi yang paling sukses. Dan papan itu sendiri dengan MK dibuat bengkok. Saya entah bagaimana memasang papan bantu samping ke sisi bingkai kamera, menyolder mur fluks ke permukaan tembaga PCB. Faktanya adalah ada sangat sedikit ruang di samping, dan tutup kamera praktis "dikencangkan" kembali ke belakang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angka-angka di bawah ini menunjukkan distribusi kesimpulan dari MK, serta tujuannya.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cc/ry/d2/ccryd2b_viknimo-w0asy0j8fuy.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 3. Tujuan dari kesimpulan mikrokontroler.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ada banyak poin untuk dikomentari. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk programmer SPI (STK200 +), output "PEN" tidak diperlukan. Aktivasi berlangsung dengan "RESET", seperti biasa. Tetapi bukannya "MISO" dan "MOSI", MK memiliki antarmuka yang terpisah (PDI / PDO), dan garis "CLK" digabungkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai tegangan referensi untuk ADC, saya memilih 5V yang sama, dari mana MK itu sendiri bertenaga. Saya mencoba untuk mendapatkan 3.3V secara terpisah (seperti di sirkuit asli), tetapi pada saat yang sama ada jebakan. Dan untuk beralih ke tegangan referensi 5V, Anda perlu sedikit mengubah rangkaian, seperti yang ditunjukkan pada gambar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mn/od/wr/mnodwrbakf5xlxkq1qskzeuhmkc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 4. Terjemahan tombol pada tegangan referensi 5V.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Artinya, Anda perlu melepas satu sisi resistor R505 dari sisi pasokan 3.3V, dan alih-alih menerapkan 5V untuknya dari saluran listrik MK.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari kesimpulan MK, yang hanya digunakan di dalam papan yang dirancang, hanya tiga yang terlibat. Sinyal pulsa 1 Hz dengan RTC tiba di PB7 untuk memperbarui waktu. Pin PD0 dan PD1 dialokasikan ke bus I2C. Ini akan diimplementasikan secara terprogram menggunakan pustaka CVAVR "i2c.h", terlepas dari kenyataan bahwa antarmuka perangkat keras i2c (TWI) melekat pada output ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pin MC "RESET" adalah output, tetapi reset MK akan terjadi dengan sendirinya tanpa rantai reset eksternal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dipahami bahwa pulsa clock HD dan VD akan tiba di MK melalui port interupsi eksternal untuk akurasi membaca bidang video. Namun, tidak termasuk fungsi autofokus, mereka tidak lagi diperlukan. Sinyal dari zoom dan sakelar batas fokus datang ke porta gangguan eksternal yang berdekatan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Port "A" MK dicadangkan untuk streaming video digital. Port "C" sepenuhnya dicadangkan untuk SD.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pin PD4 digunakan untuk beralih TX / RX RS-485. Tidak ada pergantian di sirkuit asli: kaki ke-2 dan ke-3 dari chip MAX485 berada di tanah. MK asli hanya dapat menerima data untuk mengendalikan kamera melalui PELCO-D. Saya memutuskan untuk melakukan upgrade kecil. Idenya adalah ini. Jika camcorder menggantung tinggi dan dalam casing tertutup, tidak mungkin untuk dengan cepat memperbarui firmware. Dan kebutuhan seperti itu pasti akan muncul: menghilangkan berbagai bug dan meningkatkan fungsionalitas akan menjadi praktik rutin untuk pertama kalinya. Oleh karena itu, saya muncul dengan ide untuk mengimplementasikan bootloader untuk MK, dan sudah menggunakannya memperbarui firmware dari jarak jauh melalui RS-485. Dan dalam hal ini, pertukaran dua arah sangat diinginkan. Tentang bootloader akan menjadi bagian terpisah dari artikel ini. Dan untuk menghubungkan MAX485 (2 dan 3 kaki) ke pin MK ini,Anda perlu melakukan sedikit perubahan pada papan pertama dan kedua. Papan ini dihubungkan dengan kabel loop, pada konektor yang ada kontak "IRL" yang tidak digunakan untuk kontrol lampu latar. Pada papan (utama) kedua, Anda perlu melepas resistor R520 dan solder alih-alih kabel yang melewati papan adaptor ke ATmega128 MK ke output yang sesuai. Dan pada papan pertama, Anda perlu melepas dan menekuk 2 dan 3 kaki U202, menyatukannya dan menariknya dari kabel ke output gratis 1 konektor J302. Operasi-operasi untuk mengubah sirkuit ditunjukkan pada gambar.yang akan melewati papan adaptor ke ATmega128 MK ke output yang sesuai. Dan pada papan pertama, Anda perlu melepas dan menekuk 2 dan 3 kaki U202, menyatukannya dan menariknya dari kabel ke output gratis 1 konektor J302. Operasi-operasi untuk mengubah sirkuit ditunjukkan pada gambar.yang akan melewati papan adaptor ke ATmega128 MK ke output yang sesuai. Dan pada papan pertama, Anda perlu melepas dan menekuk 2 dan 3 kaki U202, menyatukannya dan menariknya dari kabel ke output gratis 1 konektor J302. Operasi-operasi untuk mengubah sirkuit ditunjukkan pada gambar.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qu/20/oe/qu20oe_mzvupcc4mpsbtg4omwma.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 5. Organisasi jalur TRX untuk mengendalikan TX / RX MAX485.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ada dua antarmuka UART di papan ATmega128. Dalam hal ini, Anda harus menggunakan antarmuka kedua (pin 27, 28), karena antarmuka pertama pada pin (pin 2, 3) dikombinasikan dengan antarmuka untuk programmer SPI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di papan, hampir semua kesimpulan dari MK terlibat. Kesimpulan dari port â€œGâ€ ternyata tidak digunakan. Omong-omong, adalah mungkin untuk mengimplementasikan jam secara terprogram berdasarkan MK. Ini menyediakan mode tidur dengan penggunaan baterai untuk menghitung waktu saat daya utama mati. Bahkan ada kesimpulan untuk menghubungkan kuarsa frekuensi rendah yang terpisah. Namun, saya tidak repot dengan ini, menampar DS1307.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gambar di bawah ini menunjukkan tujuan setiap output papan dengan MK. Selain itu, ditandai secara kondisional apa dan di sisi mana papan utama kabel dari setiap pin akan disolder. Juga perlu memberikan beberapa komentar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i0/fd/df/i0fddfrritx4bjzwqgsfl3bu1r4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 6. Penugasan kesimpulan dari pembayaran tambahan dengan MK.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sinyal dari zoom dan sakelar batas fokus tidak hanya datang ke port interupsi, tetapi juga ke input ADC. Faktanya adalah bahwa bahkan pada tahap studi SD, saya melihat fitur seperti itu. Jika zoom atau mekanisme fokus berada pada "nol", sinyal output dari trailer dapat menjadi "perantara". Untuk lebih menangkap kasus langka seperti itu, saya memutuskan untuk menggunakan ADC. Tentu saja, ini bukan pendekatan yang sangat kompeten, tetapi dengan melakukan ini saya dengan cepat keluar dari masalah yang terkadang muncul pada tahap inisialisasi dalam firmware pengujian saya. Jadi, saya meningkatkan stabilitas algoritma. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sinyal SDA / SCL dari I2C hanya dicolokkan ke konektor, untuk berjaga-jaga, dan mereka tidak digunakan di luar papan ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nama-nama setiap pin untuk kontrol ID ditandatangani sesuai dengan koneksi yang sebenarnya. Menghubungkan data, melihat ke depan, akhirnya diperbaiki pada tahap debugging. Ada banyak kebingungan, tetapi kesalahannya hanya pada pergantian fase yang akurat ke sebaliknya, dan tidak dalam urutannya. Alternatif "4-1-2-3" (untuk zoom) dan "2-3-4-1" (untuk fokus) adalah satu dan sama, serta "1-2-3-4", yang dan diambil sebagai dasar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di akhir artikel </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(agar tidak mempermalukan)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dua foto disajikan. Yang pertama adalah tampilan bawah camcorder dengan tampilan papan sirkuit tambahan. Yang kedua adalah pandangan dari atas dari atas pada papan utama kamera video dengan standar MK tertutup (mikroprosesor, lebih tepatnya), sekelompok jumper kawat dan ingus lainnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menulis program (firmware) bersamaan dengan pengujian pendahuluan dalam program ISIS 7 Professional (Proteus). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/qr/f7/mtqrf7iej-6e3adbtcg-bgghokq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 7. Pandangan proyek di Proteus.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Alih-alih chip unik dari generator karakter dan prosesor video (yang, tentu saja, tidak di Proteus), saya menginstal debugger SPI. Dengan bantuan mereka, akan lebih mudah untuk mengontrol byte yang dikirim oleh MK oleh SPI. Tetapi reaksi nyata untuk byte ini dikendalikan langsung pada perangkat keras. Dengan Proteus, Anda dapat memantau dan men-debug perintah PELCO-D yang berasal dari DVR nyata. Untuk melakukan ini, sebagai opsi, Anda harus menghubungkan DVR ke port COM komputer melalui adaptor satu arah RS485-&gt; RS232 yang paling sederhana. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian saya mulai mengembangkan dan membuat model. Excel banyak membantu dalam hal ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, Anda perlu memutuskan timer dan konfigurasinya. Satu pengatur waktu - untuk mewujudkan rotasi motor stepper dan penerapan operasi berulang tombol sambil menahannya. Saat menahan tombol ini atau itu selama pengaturan melalui menu, operasi SD akan dikecualikan. Dan ketika Anda memegang salah satu tombol zoom atau kontrol fokus di luar menu, SD berputar dengan parameter waktu yang sesuai. Dengan demikian, tidak ada konflik. Saya berencana menggunakan timer kedua untuk mengimplementasikan PWM untuk SD, tetapi seiring waktu saya memutuskan untuk mengabaikannya. Memang, dalam kasus saya, ketika tidak ada autofocus, tidak perlu untuk PWM. Selain itu, mekanisme transmisi memiliki struktur heliks, oleh karena itu, saat istirahat, Anda tidak dapat "memegang" SD dengan arus searah, mekanisme tidak akan merayap di mana pun.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian Anda perlu merevisi alfabet karakter dari generator karakter, sesuai dengan lembar data, dan membandingkannya dengan alfabet ASCII standar. Alfabet generator karakter terdiri dari 128 karakter, yang merupakan setengah dari ukuran karakter terakhir. Sebagai contoh, karakter Cyrillic dalam generator karakter sama sekali tidak ada, tetapi ada karakter khusus yang merupakan karakteristik penerapannya (matahari, jam pasir, pria kecil, catatan, telepon, dll.). Saya membuat array "seseorang [256]" dari 256 elemen, menempatkannya di EEPROM MK. Notasi smb [i] = adr berarti bahwa pada alamat adr di generator karakter terdapat karakter dengan kode ASCII i. Dan jika simbol i tidak ada dalam alfabet generator karakter, maka nilai elemen array merujuk ke "spasi" dengan alamat 0x7E. Artinya, hampir setengah dari elemen dalam array memiliki nilai "0x7E". Array ini disajikan dalam bentuk tabel pada gambar di bawah ini.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yo/_b/_g/yo_b_gqswkjfk1smuefynrwgs0e.png"><br>
<i>. 8.    ASCII    PD6464A.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, Anda perlu mempertimbangkan cara memproses tombol melalui ADC. Menurut hukum Ohm, mudah untuk menghitung nilai tegangan pada input ADC ketika Anda mengklik tombol. Setelah itu, mudah untuk menghitung batas interval, yang tengahnya akan menjadi nilai tegangan yang sama. Secara total, enam interval diperoleh: lima di antaranya sesuai dengan setiap tombol dan satu dengan tidak adanya penekanan (tidak ada tombol yang ditekan). Pada tingkat perangkat keras, ADC MK secara berkala menganalisis nilai tegangan dari tombol. Timer untuk anti-bouncing dapat diimplementasikan berdasarkan pada perhitungan siklus clock ADC, yang saya lakukan. Pada tahap debugging, bagian dari program ini memiliki kekurangan. Saya pikir itu tidak layak untuk menulis rincian. Untuk mencapai kerja yang jelas dari fungsi ini, saya harus mengotak-atik waktu yang lama. Fungsi pengenalan tombol ditempatkan di bagian interupsi ADC, dan pada outputnya adalah nomor tombol,bendera depresi dan lepaskan bendera. Pemrosesan tombol lebih lanjut terjadi dalam siklus program utama. Frekuensi tombol polling (frekuensi ADC) adalah 12000/128 = 93,75 (kHz), di mana 128 adalah pembagi maksimum yang mungkin.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian saya mengkompilasi susunan nilai register UART UBRR1 dari konfigurasi UART, tergantung pada satu atau lebih baud rate PELCO-D, yang dapat dipilih dari daftar dalam pengaturan melalui menu. </font><font style="vertical-align: inherit;">Nilai-nilai ini dapat dihitung menggunakan rumus dari lembar data pada MK, dan juga bisa diperoleh menggunakan konfigurasi otomatis AVR Wizard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lalu saya mulai memodelkan menu. </font><font style="vertical-align: inherit;">Ini adalah tahap utama dan memakan waktu menulis program. </font><font style="vertical-align: inherit;">Pada prinsipnya, saya tidak akan mengulangi menu firmware standar, kecuali untuk ini, saya memutuskan untuk menyulitkannya ke struktur hierarkis (bagian dalam bagian ini). </font><font style="vertical-align: inherit;">Di bawah ini adalah deskripsi model dan definisi menu yang saya buat sendiri.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak bisa membaca</font></font></b>
                        <div class="spoiler_text">     .<br>
          .<br>
      .<br>
          .<br>
       Â«MENUÂ».<br>
<br>
    Â«Â»    .<br>
    Â«Â»  Â«Â»       .<br>
  Â«Â»       .<br>
  Â«Â»       .<br>
  (   )   ,         .<br>
   Â« Â»,     .<br>
<br>
   :<br>
 â€” ;<br>
 â€” ;<br>
 â€” ;<br>
 â€” .<br>
<br>
    ,   ,   .<br>
    &lt;&gt;.<br>
     .<br>
         "&lt;..&gt;".<br>
      Â«Â».<br>
      ,   .<br>
        ( ) .<br>
    "&lt;..&gt;"      .<br>
        ,    .<br>
           .<br>
<br>
      .<br>
     .<br>
        .<br>
     "&lt;â€¢&gt;" ( ).<br>
     "&lt; &gt;" ().<br>
      Â«Â».<br>
<br>
    .<br>
           .<br>
     Â«l*lÂ» (,   Â«lÂ»).<br>
     Â«l lÂ» (,   Â«lÂ»).<br>
        Â«Â».<br>
<br>
  ,       .<br>
     .<br>
           .<br>
            .<br>
       : Â«000Â», Â«00Â», Â«0Â».<br>
        .<br>
         : ": ".<br>
  â€”      (    )       .<br>
 ,   ,     Â«Â»  Â«Â».<br>
    Â«Â»     1.<br>
    Â«Â»     1.<br>
<br>
         .<br>
         .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, navigasi menu agak mirip dengan navigasi melalui file dan folder melalui "Total Commander". Kode implementasi untuk model menu ini tidak terlalu rumit, tetapi sangat rumit. Ada dua variabel kunci: jumlah halaman aktif dan jumlah posisi aktif pada halaman. Untuk kedua variabel, dua fungsi "sakelar" berfungsi satu sama lain. Pasangan fungsi ini terlibat dalam proses menekan tombol "Kiri", "Kanan" dan "Menu". Di setiap tempat (untuk setiap tombol, halaman, dan item saat ini) tindakan tertentu terdaftar. Setiap halaman menu memiliki fungsi yang mengimplementasikan tampilan halaman pada layar dengan semua prasasti dan parameter. Sebelum menerapkan fungsi output halaman, saya sebelumnya memodelkannya di Excel, seperti yang mereka katakan, "oleh sel".Jadi koordinat sel masing-masing simbol pada bidang layar disajikan lebih jelas, dan informasi ini diperlukan pada tahap pemrograman. Pada gambar di bawah ini, sebagai contoh, saya memberikan tampilan halaman 9, di mana baudrate PELCO-D dipilih dari daftar. Elemen antarmuka pada halaman adalah tombol radio. Selain itu, paragraf pertama &lt;..&gt; adalah untuk keluar dari bagian ini.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c0/s1/uy/c0s1uyuaoh9dawm-bqpf5g4pmjg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 9. Memodelkan OSD di Excel.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Saya juga membuat array yang mencerminkan jumlah titik pada setiap halaman. Ini digunakan dalam pemrosesan menekan tombol Atas dan Bawah. Ini dilakukan untuk mengurangi kode dan menghindari penggunaan fungsi sakelar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menekan virtual berulang-ulang sambil menahan tombol-tombol diimplementasikan dalam tubuh penghenti waktu oleh fungsi "saklar-case", yang bekerja pada variabel integer, yang merupakan sebuah bendera. Nilai bendera unik untuk setiap aksi tombol pada halaman tertentu dan item menu tertentu. Itu ditugaskan ke bendera sebagai nomor seri hanya di tempat-tempat di mana klik virtual diperlukan. Pada saat yang sama, di dalam fungsi â€œsakelar kasusâ€ (di badan penghenti waktu) ditempatkan salinan fungsi yang menerapkan tindakan tombol. Untuk menghemat memori, dimungkinkan untuk menempatkan "pintasan" (tautan) pada panggilan biasa ke fungsi pemrosesan tombol. Ini bahkan lebih masuk akal, tetapi pada saat itu saya tidak memiliki kesabaran untuk memikirkan bagaimana melakukannya dengan lebih baik, karena saya ingin menyelesaikan proyek sesegera mungkin. Dan memori dalam ATmega128 ternyata cukup banyak.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akhirnya, saya menerapkan "perpustakaan" untuk bekerja dengan prosesor video, generator karakter, dan RTC DS1307 dengan fungsi yang diperlukan. Setelah itu, saya menentukan alamat EEPROM MK untuk menyimpan informasi ini atau itu. 32 byte pertama dicadangkan untuk menyimpan informasi pengaturan menu. 32 byte berikutnya dicadangkan untuk menyimpan teks yang dapat ditampilkan di layar atau diubah menggunakan perintah standar â€œPelco-D Write Char. Ke Layar. " 256 byte berikutnya dari area EEPROM disediakan untuk alfabet (konversi karakter dari ASCII ke alamat untuk generator karakter, seperti yang disebutkan di atas). Akhirnya, 128 byte berikutnya dicadangkan untuk menyimpan "preset" (templat) zoom / fokus. Saya memperkenalkan fitur ini karena kurangnya autofokus. Saya menulis tentang ini di awal artikel. Sebanyak 32 template. Koordinat zoom atau fokus dikodekan dalam dua byte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara terpisah, ada baiknya menulis tentang implementasi manajemen SD. Rotasi SD dicapai dengan memanggil fungsi StepF () dan StepZ () di blok interupsi timer. Kecepatan rotasi ditentukan oleh konfigurasi timer ini. Dan implementasi fungsi-fungsi di atas mengimplementasikan promosi fokus atau zoom (masing-masing) pada langkah minimum. Selama rotasi lensa zoom dan fokus, posisi akhir mereka dikontrol. Posisi fokus maksimum dan posisi zoom minimum diwakili dalam program oleh konstanta (masing-masing 280 dan -600). Tetapi posisi fokus minimum dan posisi zoom maksimum - dalam bentuk variabel F_min dan Z_max (lebih tepatnya, fungsi). Pendekatan ini difasilitasi oleh area kerja non-persegi panjang dengan sudut kanan bawah cut-off. Untuk menghitung nilai-nilai F_min dan Z_max, digunakan fungsi-fungsi yang didefinisikan secara terpisah F_min (Z) dan Z_max (F). Selain,ketika zoom SD berputar ke arah positif pada Z (koordinat zoom)&gt; 500, fokus SD berputar secara bersamaan dalam arah yang sama jika yang terakhir memiliki koordinat &lt;(- 180). Artinya, posisi zoom maksimum, pada prinsipnya, tidak dibatasi oleh posisi fokus saat ini, tetapi terbatas pada 600. Ini hanya terjadi bahwa dua SD berputar secara bersamaan ketika batas sudut yang sesuai dari wilayah pentagonal tercapai, dan gerakan pada tahap ini terjadi di sepanjang "sisi potong" (jika ditafsirkan secara grafis) ) Dari sudut pandang mekanika, ini setara dengan proses yang dijelaskan dalam artikel sebelumnya, ketika, dengan tidak adanya SD dan ketika memindahkan zoom dan node fokus secara manual, simpul zoom di ujung jalan â€œmenarikâ€ simpul fokus. Karena fakta bahwa koordinat zoom mendominasi koordinat fokus (itulah sebabnya saya menganggap ketergantungan F (Z),tetapi tidak sebaliknya), saya tidak mulai menerapkan prosedur zoom "scrolling" yang serupa dalam fungsi Step_F ().</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam firmware asli, kecepatan mengubah zoom dan fokus memiliki nilai tetap. Ini tidak selalu nyaman. Dalam firmware saya, saya memberikan empat nilai zoom dan kecepatan fokus (secara terpisah), yang dapat dipilih melalui menu dan menggunakan perintah PELCO-D yang ditugaskan untuk fungsi ini. Keempat nilai ini telah dipilih sebelumnya pada tahap debugging berdasarkan kenyamanan, kemudian dimasukkan ke dalam firmware.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi inisialisasi BD init_MR () diperlukan untuk mengikat mekanisme zoom dan fokus ke sistem koordinat. Ini dilakukan sekali setiap kali Anda menghidupkan camcorder. Algoritma karyanya kira-kira sebagai berikut. Pertama-tama, diasumsikan bahwa zoom atau fokus berada pada titik nol, dan upaya dilakukan untuk menangkap pantulan sinyal dari sakelar batas oleh fungsi interupsi eksternal. Saya akan segera mencatat bahwa jika zoom atau fokus "di nol" (di batas partisi trailer optik), sinyal pada output trailer memiliki "perantara" antara logika "0" dan "1". Kasus-kasus seperti itu sangat tidak mungkin, tetapi tidak dapat dikesampingkan. Namun, fungsi interupsi tidak menafsirkan sinyal seperti pantulan. Itu sebabnya saya datang untuk menggunakan ADC MK, memicu sinyal dari limit dan zoom limit switch pada dua saluran gratisnya. Begitu,langkah pertama adalah "digitalisasi" sinyal dari limit switch dengan akurasi 8-bit. Ini dilakukan dengan menggunakan konversi analog-ke-digital tunggal. Perlu diingat bahwa tegangan referensi dalam kasus kami adalah 5V, dan level logis "1" dari sakelar batas adalah 3.3V. Untuk "0" yang logis, nilai ADC akan menjadi nol, dan untuk "1" - 3.3 / 5 * 255 = 168. Jika nilai sinyal dari satu atau lain trailer jatuh ke dalam rentang, katakanlah, dari 2 hingga 165 (interval fuzzy diambil), ini berarti bahwa node yang sesuai sudah "di nol", dan prosedur inisialisasi untuk node ini dapat dihentikan. Jika tidak, dengan nilai logis dari sinyal trailer ("0" atau "1"), Anda perlu menentukan di bagian mana (setengah) node berada. Arah rotasi SD akan tergantung pada ini. Dengan satu atau lain cara, SD harus diputar ke arah ini,sehingga simpul yang sesuai bergerak ke arah "nol" (limit switch). Dengan demikian, rotasi penggerak motor dimulai dengan perhitungan simultan dari jumlah langkah hingga sakelar batas tercapai. Segera setelah sakelar batas yang sesuai tercapai, yang menentukan fungsi gangguan eksternal sesuai dengan perbedaan tingkat logis, akan ada rotasi mundur dari penggerak motor. Ini akan berputar dalam arah yang berlawanan dengan jumlah langkah yang sama, sehingga kembali ke posisi semula. Nilai jumlah langkah untuk setiap BD dengan tanda yang sesuai akan disalin ke variabel yang sesuai sebelum keluar dari fungsi inisialisasi. Prosedur yang dijelaskan di atas terjadi secara independen untuk fokus dan memperbesar dalam fungsi yang sama (tidak pada gilirannya).Kecepatan rotasi penggerak motor pada tahap inisialisasi ditentukan oleh konstanta terpisah dan sesuai dengan kecepatan maksimum untuk putaran SM yang benar dan percaya diri.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan contoh di mana, sebelum menyalakan daya kamera, zoom berada di wilayah negatif, dan fokus berada di wilayah positif. Gambar ini secara skematis menunjukkan lintasan titik (Z; F) selama prosedur inisialisasi motor stepper. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1p/59/6d/1p596dlrqriwqff1jh4jfrtvu-8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 10. Proses inisialisasi zoom dan fokus.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Titik A adalah posisi awal zoom dan fokus. Pergerakan kedua node terjadi ke arah "nol" dengan kecepatan yang sama (kecepatan inisialisasi). Pada titik B, fokus mencapai nol, karena lebih dekat ke nol daripada zoom. Kemudian fokus dibalik. Pada titik C, fokus menyelesaikan proses inisialisasi, kembali ke posisi semula. Pada saat yang sama, zoom masih bergerak ke arah "nol". Pada titik D, ia mencapai "nol" dan kembali ke posisi semula (titik A).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain fungsi inisialisasi init_MR (), ada fungsi goto_zf (z, f). </font><font style="vertical-align: inherit;">Berdasarkan namanya, ini dimaksudkan untuk beralih dari satu preset ke preset lainnya, yang saya tulis di awal artikel. </font><font style="vertical-align: inherit;">Kecepatan putaran motor stepper selama transisi sama dengan selama inisialisasi. </font><font style="vertical-align: inherit;">Proses transisi dalam zoom dan fokus dilakukan secara bersamaan. </font><font style="vertical-align: inherit;">Yaitu, jika diperlukan untuk beralih dari titik (z1; f1) ke titik (z2; f2), rotasi simultan dua SD dimulai. </font><font style="vertical-align: inherit;">Jika, misalnya, | f2-f1 | &lt;| z2-z1 |, maka SD fokus akan berhenti sebelumnya. </font><font style="vertical-align: inherit;">Ini ditunjukkan pada gambar di bawah ini. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fb/-y/ya/fb-yyanbovlb6i3pe6rxsfh0ax8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. </font><font style="vertical-align: inherit;">11. Proses mengubah zoom dan fokus saat memilih preset.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sepanjang seluruh waktu operasi motor stepper selama lewatnya tanda nol batas, koordinat yang sesuai adalah nol. </font><font style="vertical-align: inherit;">Dan ini terlepas dari kenyataan bahwa secara teoritis ini tidak dapat dilakukan. </font><font style="vertical-align: inherit;">Namun, dalam praktiknya, masih ada kesalahan 1-2 langkah dari SD.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu ditambahkan bahwa, tidak seperti firmware asli, dalam kasus saya, ketika mengontrol zoom dan fokus (baik dari tombol dan melalui PELCO-D), saya menyediakan kemungkinan gerakan langkah-demi-langkah. Ini berfungsi sebagai berikut. Saat Anda mengklik salah satu dari 4 tombol untuk mengontrol zoom atau fokus, SD terkait diputar satu langkah, sehingga meminimalkan pergerakan zoom atau node fokus. Jika Anda tidak melepas tombol, maka rotasi normal motor stepper akan dimulai setelah periode waktu yang singkat. Penundaan ini dipilih secara empiris terlebih dahulu. Fitur ini mirip dengan penekanan berulang virtual sambil menahan tombol. Berkat fitur ini, masalah "menempel" tombol saat mengontrol zoom atau fokus pada perangkat jarak jauh PELCO-D melalui koneksi internet yang buruk dihilangkan. Lebih tepatnya, peluang muncul sebagai kasar,dan menyempurnakan zoom atau fokus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interpreter dari perintah PELCO-D dibuat dengan analogi yang sama seperti pada perangkat untuk mengalihkan beban melalui PTZ. Saya sebelumnya mengabdikan artikel kecil terpisah tentang HabrÃ© ke perangkat sederhana ini. Berbeda dengan firmware asli, zoom dan perintah kontrol fokus sepenuhnya merujuk pada menekan tombol yang sesuai. Artinya, dimungkinkan untuk "memanjat" menu menggunakan tombol zoom dan fokus PELCO-D. Dan untuk memanggil menu dari jarak jauh melalui PELCO-D, atau lebih tepatnya, tekan tombol "MENU", saya membandingkan tombol pembuka aperture dengannya, karena fungsi ini tidak digunakan dalam model kamera ini. Dengan demikian, ada lima perintah dasar PELCO-D untuk menekan, serta lima perintah dasar untuk melepaskan tombol. Selain itu, karena saya sudah menulis dengan santai di seluruh artikel, perintah tambahan diproses: "Set Preset", "Clear Preset","Go To Preset", "Tulis Char. Ke Layar â€,â€œ Hapus Layar â€,â€œ Atur Kecepatan Zoom â€,â€œ Atur Kecepatan Fokus â€.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tanggal dan waktu dengan RTC ditampilkan di sudut kiri bawah gambar dengan analogi dengan kamera VHS lama, jika opsi ini diaktifkan di menu. Selain itu, di menu Anda dapat memilih format output, yang juga saya sediakan sebelumnya. Juga di layar di sebelah tanggal dan waktu dimungkinkan untuk menampilkan hari dalam seminggu. Selain jam, koordinat zoom dan fokus saat ini ditampilkan di layar sebagai informasi tambahan. Opsi ini diperlukan terutama pada tahap debugging.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan memberi tahu Anda tentang fungsi menu yang saya implementasikan. Seiring waktu, jika perlu, menu akan direvisi: beberapa fungsi dapat dihapus, dan beberapa ditambahkan. Struktur menu yang saya gambar di SPlan, dengan tampilan halaman, ditunjukkan pada gambar di bawah ini. Panah merah - masuk ke bagian. Panah biru - keluar dari bagian. Saya tidak menggambar panah biru di setiap halaman menu, saya hanya menggambar dua misalnya. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/vs/mp/rlvsmpdeoixbmwlg-jmf2uwj51m.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 12. Struktur menu di layar.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beberapa bagian dari menu saya agak mirip dengan bagian aslinya. Pertama-tama, ini adalah dua bagian pertama: white balance dan exposure. Di bagian ketiga, Anda dapat menentukan alamat kamera PELCO-D dan memilih kecepatan data (baudrate) dari daftar. Bagian keempat dikhususkan untuk tanggal dan waktu. Anda dapat mengatur tanggal, waktu, hari dalam seminggu, memilih satu dari empat format tampilan, dan memilih metode tampilan. Bagian kelima - bekerja dengan preset (templat) zoom dan fokus, di mana Anda dapat memanggilnya dengan nomor, serta menghapus atau menimpa. Juga di bagian menu ini, Anda dapat memilih satu dari empat kecepatan untuk mengubah fokus atau zoom. Bagian kelima memungkinkan Anda untuk mengedit parameter prosesor video, yang terletak di byte 9 dari kategori 3. Ini adalah level dan inversi dari komponen burst sinyal video, dan mirroring video. Bagian terakhir dari menu adalah untuk debugging.Dengan menggunakannya, Anda dapat menulis ke prosesor video berapa pun nilai byte apa pun dalam kategori apa pun. Nilai dapat diatur dalam bentuk desimal dan biner.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang saya akan mengatakan beberapa kata tentang bootloader. Seperti yang sudah saya tulis, bootloader diperlukan untuk mem-flash camcorder dari jauh melalui RS-485. Awalnya, saya berpikir untuk sepenuhnya mengimplementasikan bootloader sendiri. Namun, untuk menghemat waktu, saya memutuskan untuk melakukannya dengan salah satu pengunduh siap pakai yang sudah diterapkan yang dapat ditemukan di Internet. Selain itu, saya belum pernah menggunakannya, hanya memiliki gagasan tentang mereka pada tingkat teoritis. Salah satu kriteria penting untuk memilih bootloader adalah dukungan RS-485. Biasanya, pengunduh AVR beroperasi pada UART RS-232. Dan bootloader dengan dukungan RS-485 hanya berbeda karena output tambahan dialokasikan pada sisi MK untuk beralih transceiver RS-485 (misalnya, MAX485) selama transfer data dari MK ke PC. Saat menginstal MK, bootloader mentransmisikan informasi tentang perekaman yang berhasil atau tidak berhasil ke komputer. Bootloader pertamayang saya temukan memungkinkan Anda untuk merekam tidak hanya memori FLASH MK dengan firmware, tetapi juga EEPROM. Selain menulis, Anda juga bisa membaca data. Tetapi proyek ini dengan kode sumber assembler cukup membingungkan dan saya tidak memahaminya. Selain itu, penekanan utama dari bootloader ini ditujukan pada kemampuan untuk mem-flash beberapa perangkat secara terpisah, tanpa memutusnya dari jaringan RS-485, mengakses setiap perangkat di alamat yang sebelumnya terhubung ke dalamnya. Saya tidak memerlukan fitur fungsional seperti itu, karena saya menggunakan topologi berbeda dari jaringan RS-485, dan dimungkinkan untuk dengan cepat mengganti camcorder dari DVR ke PC. Bootloader kedua adalah Chip45 Jerman. Kode sumber tidak dalam domain publik, dapat dibeli dari pembuatnya. Sebaliknya, ada beberapa ratus file HEX untuk AVR MK yang berbeda, antarmuka UART yang berbeda (jika ada beberapa, seperti dalam kasus saya),RS-485 atau RS-232 untuk dipilih. Singkatnya, untuk semua kesempatan. Pada saat yang sama, penulis mencatat bahwa dalam kasus RS-485, pin switching TX / RX diperbaiki dan sesuai dengan pin XCK UART dari antarmuka pengontrol, yang secara praktis tidak digunakan di UART. Dalam kasus saya, pin ke-30 dari XCK dari antarmuka UART kedua dari Atmega128 MK adalah PORTD.5 â€‹â€‹dan digunakan untuk mengaktifkan sakelar zoom dan batas fokus. Pada prinsipnya, fungsi ini tidak diperlukan, karena, seperti yang ditunjukkan oleh penelitian, limit switch selalu aktif, seperti yang sudah saya tulis. Dan jika perlu, Anda dapat mentransfer fungsi ini ke output MK gratis lainnya. Tetapi, bagaimanapun juga, bootloader ini juga tidak membuat saya terkesan, terutama karena saya menemukan bootloader yang lebih menarik yang disebut "AVR Universal Bootloader" dari desain Cina. Seperti Chip45, ia hanya dapat menulis dan hanya dalam memori FLASH dari MK.Tetapi dia memiliki banyak kemungkinan, dan karena itu saya dengan tegas memutuskan untuk tetap menggunakannya. Itu datang sebagai proyek AVR Studio dengan kode sumber C. Karena saya bekerja di CodeVisionAVR, saya harus menginstal AVR Studio bersama dengan WinAVR. Untuk mendapatkan file HEX untuk firmware bootloader, Anda perlu mengkompilasi proyek dengan membuat perubahan awal pada kode sumber untuk konfigurasi perangkat Anda sendiri dan Anda membutuhkannya sendiri. Kompilasi proyek terdiri dari meluncurkan file bat (file batch), di mana perintah kompilasi ditulis. Dengan demikian, proyek di AVR Studio tidak perlu dibuka. Perubahan dalam kode sumber dapat dilakukan secara manual (di tingkat programmer), atau menggunakan konfigurator. Peran yang terakhir adalah jendela tambahan dari utilitas yang berfungsi dengan bootloader, yang juga dilampirkan.Di konfigurator, Anda dapat menentukan pin MK untuk pengalihan TX / RX RS-485, pin MK untuk LED berkedip kontrol, pin MK untuk memasuki bootloader, cara bootloader dimasukkan, nama dan frekuensi MK, dll., Tidak dapat didaftar. Selain itu, program standar terkenal "HyperTerminal" dapat bertindak sebagai utilitas untuk memuat program pengguna di MK, yaitu, untuk bekerja dengan bootloader. Ia menggunakan protokol "Xmodem" untuk mengunduh firmware. Dan agar dapat bekerja dengan mudah dan secara visual dengan bootloader melalui terminal teks, fungsi khusus "Mode Verbose" disediakan di konfigurator. Namun terlepas dari daya tarik hyperterminal, saya memutuskan untuk menggunakan utilitas yang menyertai bootloader. Faktanya adalah bahwa dengan fungsi Verbose yang nyaman diaktifkan di konfigurator, bekerja melalui terminal, saya menemukan situasi berikut.Kadang-kadang itu terjadi ketika lalu lintas data di garis "bertabrakan" (kedua perangkat dalam mode TX), akibatnya MAX485 dalam camcorder menjadi sangat panas dan gagal, atau lebih tepatnya, tidak sepenuhnya, tetapi hanya bagian RX (mentransmisikan data melalui RS-485 ke kamera) . Karena itu, saya meninggalkan HyperTerminal. Dan ada satu lagi ketidaknyamanan. HyperTerminal tidak berfungsi dengan file teks HEX dan hanya menerima file biner. Karena itu, saya harus menerapkan konversi tambahan dari hex ke bin. Setelah file HEX bootloader dibuat oleh saya, saya menjahitnya ke dalam MK menggunakan program PonyProg dan programmer SPI biasa. Hasilnya, bootloader berfungsi sebagai berikut. Saat Anda menghidupkan camcorder, bootloader segera diaktifkan. Dia menunggu koneksi dari utilitas selama satu detik, kemudian firmware utama mulai berfungsi. Jika koneksi berhasil dibuat,maka proses flashing dimulai. Pada saat yang sama, ujung lain saluran RS-485 harus diputuskan dari DVR terlebih dahulu dan terhubung ke PC melalui RS485 &lt;-&gt; RS232 atau RS485 &lt;-&gt; adaptor USB. Omong-omong, tentang adaptor. Pertanyaan muncul tentang bagaimana membuat adaptor seperti itu sendiri, karena adaptor yang dibeli mahal. Mengaduk-aduk di Internet, saya menemukan RS485 &lt;-&gt; RS232 rangkaian adaptor sederhana. Itu ditunjukkan pada gambar di bawah ini. Ini terutama terdiri dari mikrosirkuit MAX232 dan MAX485 yang terkenal, dan TX / RX diaktifkan oleh sinyal dari output 3 port COM komputer melalui rantai dengan dioda zener. Yaitu, MAX485 diaktifkan oleh lalu lintas data yang ditransmisikan PC. Semuanya sederhana dan cerdik.RS232 atau RS485 &lt;-&gt; USB. Omong-omong, tentang adaptor. Pertanyaan muncul tentang bagaimana membuat adaptor seperti itu sendiri, karena adaptor yang dibeli mahal. Mengaduk-aduk di Internet, saya menemukan RS485 &lt;-&gt; RS232 rangkaian adaptor sederhana. Itu ditunjukkan pada gambar di bawah ini. Ini terutama terdiri dari mikrosirkuit MAX232 dan MAX485 yang terkenal, dan TX / RX diaktifkan oleh sinyal dari output 3 port COM komputer melalui rantai dengan dioda zener. Yaitu, MAX485 diaktifkan oleh lalu lintas data yang ditransmisikan PC. Semuanya sederhana dan cerdik.RS232 atau RS485 &lt;-&gt; USB. Omong-omong, tentang adaptor. Pertanyaan muncul tentang bagaimana membuat adaptor seperti itu sendiri, karena adaptor yang dibeli mahal. Mengaduk-aduk di Internet, saya menemukan RS485 &lt;-&gt; RS232 rangkaian adaptor sederhana. Itu ditunjukkan pada gambar di bawah ini. Ini terutama terdiri dari mikrosirkuit MAX232 dan MAX485 yang terkenal, dan TX / RX diaktifkan oleh sinyal dari output 3 port COM komputer melalui rantai dengan dioda zener. Yaitu, MAX485 diaktifkan oleh lalu lintas data yang ditransmisikan PC. Semuanya sederhana dan cerdik.Ini terutama terdiri dari mikrosirkuit MAX232 dan MAX485 yang terkenal, dan TX / RX diaktifkan oleh sinyal dari output 3 port COM komputer melalui rantai dengan dioda zener. Yaitu, MAX485 diaktifkan oleh lalu lintas data yang ditransmisikan PC. Semuanya sederhana dan cerdik.Ini terutama terdiri dari mikrosirkuit MAX232 dan MAX485 yang terkenal, dan TX / RX diaktifkan oleh sinyal dari output 3 port COM komputer melalui rantai dengan dioda zener. Yaitu, MAX485 diaktifkan oleh lalu lintas data yang ditransmisikan PC. Semuanya sederhana dan cerdik.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dg/_j/xg/dg_jxg5vy5h-i32yee8szg8urho.png"><br>
<i>. 13.   RS-232 &lt;-&gt; RS-485.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menguasai bootloader, di waktu luang saya, saya memutuskan untuk meneliti optik camcorder. Lebih tepatnya, menjadi menarik bagi saya apa kombinasi zoom dan nilai fokus yang akan menghasilkan gambar fokus pada jarak yang berbeda dari lensa ke subjek. Biarkan saya mengingatkan Anda bahwa wilayah berbagai nilai saling zoom dan fokus dijelaskan oleh wilayah pentagonal (hampir empat persegi panjang). Misalnya, ambil jarak dari lensa ke subjek 10 cm. Argumen (sepanjang sumbu absis) zoom memiliki kisaran nilai dari -600 hingga 600. Anda perlu memilih nilai fokus pada setiap nilai zoom di mana subjek di depan lensa pada gambar video akan berada dalam fokus. Maka Anda perlu membuat meja. Tentu saja, tidak masuk akal untuk memilah-milah semua 1200 nilai zoom, cukup untuk mengambil beberapa lusin nilai dengan langkah yang sama. Sebagai langkah seperti itu, saya memilih nilai 50.Pada setiap nilai zoom dengan langkah ini (-600, -550, -500, ...) Saya memilih nilai fokus dan mencatat hasil pengukuran. Saya melakukan prosedur serupa dengan jarak lain dari lensa ke subjek: 50 cm, 1 m, 10 m, 100 m. Hasilnya adalah keluarga kurva yang saya tampilkan di Excel.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5o/_4/qi/5o_4qikxragcwmdaeespjactaoi.png"><br>
<i>. 14.  Z-F   .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Melihat grafiknya, saya ingin memberikan banyak komentar. Pada zoom minimum, nilai fokus sedikit kurang dari "tengah" (nol) untuk hampir semua jarak. Kurva merah muda untuk jarak 10 cm berakhir pada nilai zoom sekitar 250, yang sesuai dengan nilai fokus minimum. Kurva ini memiliki karakter yang menurun dan cembung ke atas. Kurva merah untuk jarak 1 m memiliki bentuk yang sama sekali berbeda. Pertama, itu tidak monoton, dan kedua, sehubungan dengan sifat cembung, ada titik belok. Kurva untuk jarak 10 m dan 100 m memiliki sifat yang sama.Yang terakhir, praktis, bertepatan, yang sudah saya ketahui sebelumnya. Karena itu, jarak yang diukur 10 dan 100 meter, tentu saja, saya ambil kira-kira. Apa yang mengayunkan kurva biru untuk jarak setengah meter - awalnya saya tidak akan melakukan pengukuran.Saya memilih jarak ini berdasarkan pada prinsip bahwa sedekat mungkin dengan sebuah fragmen dari kurva yang sesuai mendekati batas sudut wilayah (potong). Dan begitulah yang terjadi: perbatasan ini praktis menyentuh sepotong kurva. Secara umum, perlu dicatat bahwa bagian atas wilayah (nilai fokus positif) praktis tidak digunakan. Pengecualian berada pada jarak yang sangat jauh dari subjek ke lensa dan pada zoom terbesar. Namun, untuk hampir semua jarak (kecuali jarak terdekat, kurang dari setengah meter), pada zoom rendah (150 atau kurang), nilai fokusnya hampir sama. Secara umum, semua fakta pengukuran yang dinyatakan harus memiliki interpretasi teoretis, berdasarkan hukum optik. Tetapi pada saat ini, saya tidak tahu tentang perangkat lensa semacam ini. Maksimum,apa yang saya temui di bidang optik adalah pembangunan teleskop refraktor dua lensa sederhana. Dan dalam kasus camcorder ini - saya tidak mengerti mekanisme optik. Pada output, hanya dua node yang bergerak tidak tersedia: node fokus (bertanggung jawab untuk fokus) dan node zoom. Dan saya tidak tahu berapa banyak total lensa di dalamnya. Saya kira dua yang terhubung dengan node bergerak ini. Perlu juga dicatat bahwa ketika mengatur fokus, zoom juga sedikit berubah secara visual, bahkan jika node yang sesuai diperbaiki.terhubung ke node bergerak ini. Perlu juga dicatat bahwa ketika mengatur fokus, zoom juga sedikit berubah secara visual, bahkan jika node yang sesuai diperbaiki.terhubung ke node bergerak ini. Perlu juga dicatat bahwa ketika mengatur fokus, zoom juga sedikit berubah secara visual, bahkan jika node yang sesuai diperbaiki.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di akhir artikel, kami beralih ke pengujian praktis camcorder. Saya memutuskan untuk tidak mengambil banyak gambar diam, tetapi segera unggah seluruh video. Saya merekam pengambilan video melalui perangkat, suara ditulis secara terpisah ke perekam audio. Resolusi aslinya adalah 720 kali 576. Setelah mengunggah video ke YouTube, kualitasnya telah berubah secara nyata.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/H4agAlZlWW8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat Anda menghidupkan kamera, hal pertama yang terjadi adalah inisialisasi motor stepper zoom dan fokus pada latar belakang gambar video. Gambar ini hitam putih dan tanpa AGC, karena prosedur inisialisasi prosesor video belum berlalu. Di kiri bawah, tanggal dan waktu saat ini akan menampilkan tanggal dan waktu penyusunan firmware kamera saat ini. Dalam kode sumber firmware, saya membuat variabel terkait yang terletak di alamat tetap dalam kode HEX. Diasumsikan bahwa pada tahap kompilasi, lebih tepatnya setelah itu, sebuah program akan dieksekusi secara otomatis yang mengambil nilai-nilai variabel dari waktu sistem dan memasukkannya ke dalam file HEX di alamat yang diinginkan. Selain itu, masih perlu menghitung ulang checksum. Mungkin ada cara yang lebih sederhana. Dalam contoh di video, variabel-variabel ini sama dengan nol, karena saya belum mengimplementasikan fungsi ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah inisialisasi SD, prosesor video diinisialisasi dan salam segera ditampilkan di latar belakang gambar video. Saat mengatur zoom dan fokus, koordinatnya ditampilkan di kanan bawah. Dalam video, saya mendemonstrasikan penggunaan fungsi menyimpan dan mengingat templat (preset) zoom dan fokus di berbagai bagian gambar. Saat menghapus preset, variabel yang sesuai memperoleh nilai 0xFFFF, yang sesuai dengan nilai -1. Fungsi ini, pada prinsipnya, berlebihan, dapat dikecualikan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bagian terakhir menu, yang digunakan untuk debugging, saya mendemonstrasikan catatan kategori 9 byte 3. Fungsi-fungsi yang sesuai dengan byte ini ada di bagian menu sebelumnya, saya menulis tentang mereka berkali-kali. Karena kenyataan bahwa byte saat ini tidak dibaca dari prosesor video, saya secara manual mengaturnya ke "48" sebagai salah satu yang dapat diterima. Setelah itu, saya mengubah bit individual dari byte ini, dengan demikian menunjukkan fungsi "Mirror" dan "Inverse Burst". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat menyesuaikan level "Burst" di bagian kedua dari belakang menu, Anda akan melihat bug firmware kecil yang mudah diperbaiki. Dari kekurangan lain - kadang-kadang, saat memperbarui waktu, kesenjangan dalam karakter terjadi. Saya pikir ini disebabkan oleh instalasi elektronik yang â€œbengkokâ€ di dalam camcorder.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, saat mengoperasikan kamera, ketidaknyamanan kecil yang terkait dengan navigasi menu ditemukan. </font><font style="vertical-align: inherit;">Karena itu, sangat mungkin revisi yang diperlukan akan dilakukan seiring waktu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, saya hampir lupa. </font><font style="vertical-align: inherit;">Seperti yang dijanjikan, saya membawa dua foto tentang bagaimana pengisian camcorder berubah setelah pengembangan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m-/0-/ah/m-0-ahq2z2xqxpr988ndcfae5uu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. </font><font style="vertical-align: inherit;">15. Pandangan yang diperbarui dari camcorder di bagian bawah. </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/gs/8_/bw/gs8_bwxf2yy1mqyrt2gmbgzoyu8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. </font><font style="vertical-align: inherit;">16. Tampilan camcorder yang telah diperbarui di bagian dalam.</font></font></i><br>
<br></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id499534/index.html">Panduan pengembangan layanan backend Python</a></li>
<li><a href="../id499536/index.html">Growbox sebagai metode untuk mengenal diri sendiri</a></li>
<li><a href="../id499540/index.html">Cara kerja rendering game 3D: tekstur dan pemfilteran tekstur</a></li>
<li><a href="../id499542/index.html">Fakapov Cyan Teratas</a></li>
<li><a href="../id499544/index.html">Pelajari jaringan saraf di Google Sheets</a></li>
<li><a href="../id499548/index.html">Topeng - merawat orang lain atau ilusi keamanan?</a></li>
<li><a href="../id499550/index.html">Solusi Kode Rendah Ekosistem</a></li>
<li><a href="../id499556/index.html">Server Game di MS Orleans - Bagian 3: Ringkasan</a></li>
<li><a href="../id499560/index.html">Korektor tata letak Xswitcher untuk linux: langkah kedua</a></li>
<li><a href="../id499562/index.html">Artikel yang gagal tentang percepatan refleksi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>