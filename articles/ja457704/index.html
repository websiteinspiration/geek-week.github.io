<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤭 🤴🏿 🌴 GPUが分岐を処理する方法 🏳️‍🌈 🧒🏻 👾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="記事について
 この投稿は、GPUが分岐を処理する方法について詳しく知りたいプログラマ向けに書かれた短いメモです。あなたはそれをこのトピックへの導入と考えることができます。GPU実行モデルが一般的にどのように見えるかを理解するために、[ 1 ]、[ 2 ]、および[ 8 ]から始めることをお勧めしま...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GPUが分岐を処理する方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457704/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6cb/f33/e39/6cbf33e39c393986a3a26bd44b9777e8.png" alt="画像"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事について</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この投稿は、GPUが分岐を処理する方法について詳しく知りたいプログラマ向けに書かれた短いメモです。</font><font style="vertical-align: inherit;">あなたはそれをこのトピックへの導入と考えることができます。</font><font style="vertical-align: inherit;">GPU実行モデルが一般的にどのように見えるかを理解するために、</font><font style="vertical-align: inherit;">[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]、[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]、および[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]から始めること</font><font style="vertical-align: inherit;">をお勧め</font><font style="vertical-align: inherit;">します。これは、1つの個別の詳細のみを検討するためです。</font><font style="vertical-align: inherit;">好奇心の強い読者のために、投稿の最後にすべてのリンクがあります。</font><font style="vertical-align: inherit;">エラーを見つけたら、私に連絡してください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事について</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">辞書</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUコアとCPUコアの違いは何ですか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整合性/不一致とは何ですか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行マスク処理の例</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">架空のISA</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD GCN ISA</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX512</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">矛盾に対処するにはどうすればよいですか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></li>
</ul><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">辞書</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU-グラフィックスプロセッシングユニット、GPU</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フリンの分類</font></font><br>
 <ul>
<li>SIMD — Single instruction multiple data,   ,   </li>
<li>SIMT — Single instruction multiple threads,   ,  </li>
</ul></li>
<li> (wave) SIMD — ,    SIMD</li>
<li> (lane) —      SIMD</li>
<li>SMT — Simultaneous multi-threading,   (Intel Hyper-threading)[<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">2</a>]<br>
 <ul>
<li>      </li>
</ul></li>
<li>IMT — Interleaved multi-threading,  [<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">2</a>]<br>
 <ul>
<li>      ,      </li>
</ul></li>
<li>BB — Basic Block,   —        </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ILP-命令レベルの並列処理、命令レベルでの並列処理[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISA-命令セットアーキテクチャ、コマンド/命令セットアーキテクチャ</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の投稿では、この発明された分類に従います。</font><font style="vertical-align: inherit;">それは、現代のGPUがどのように編成されているかにほぼ似ています。</font></font><br>
<br>
<blockquote><code>:<br>
GPU -+<br>
 |-  0 -+<br>
 | |-  0 +<br>
 | | |-  0<br>
 | | |-  1<br>
 | | |- ...<br>
 | | +-  Q-1<br>
 | |<br>
 | |- ...<br>
 | +-  M-1<br>
 | <br>
 |- ...<br>
 +-  N-1<br>
<br>
*  -  SIMD<br>
<br>
 :<br>
 +<br>
 |-  0<br>
 |- ...<br>
 +-  N-1</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の名前：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コアはCU、SM、EUと呼ばれることがあります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウェーブは、ウェーブフロント、ハードウェアスレッド（HWスレッド）、ワープ、コンテキストと呼ばれます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行をプログラムスレッド（SWスレッド）と呼ぶことができます。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUコアとCPUコアの違いは何ですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在の世代のGPUコアは、中央プロセッサよりも強力ではありません。単純なILP /マルチ発行[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]およびプリフェッチ[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]で、遷移の予測や予測/リターンはありません。これらすべては、小さなキャッシュとともに、多くのコアで埋め尽くされているチップ上のかなり大きな領域を解放します。メモリのロード/ストレージメカニズムは、従来のCPUよりも1桁大きい（これは統合された/モバイルGPUには適用されません）チャネル幅に対応できますが、これには高いレイテンシを支払う必要があります。 GPUはSMTを使用して遅延を隠します[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]-1つのWaveがアイドル状態のとき、他のWaveはカーネルの無料のコンピューティングリソースを使用します。通常、1つのコアで処理されるウェーブの数は、使用されるレジスターに依存し、固定レジスターファイルを割り当てることによって動的に決定されます[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]。命令の実行計画は、ハイブリッド-動的静的[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.4]です。 SIMDモードで実行されるSMTカーネルは、高いFLOPS値（1秒あたりの浮動小数点演算、フロップ、1秒あたりの浮動小数点演算の数）を達成します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fb8/059/770/fb8059770b3653b65c5e2cc30f5fee16.png" alt="図1"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凡例チャート。黒-非アクティブ、白-アクティブ、灰色-オフ、青-アイドル、赤-保留</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12e/fc7/5d9/12efc75d90a064410b1632c2be710235.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図1.実行履歴4：2</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この図は実行マスクの履歴を示しています。x軸は左から右への時間を示し、y軸は上から下へ向かう線の識別子を示しています。それでも理解できない場合は、次のセクションを読んでから図面に戻ってください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、GPUコアの実行履歴が架空の構成でどのように見えるかを示しています。4つの波が1つのサンプラーと2つのALUを共有しています。各サイクルのウェーブプランナーは、2つのウェーブから2つの命令を発行します。メモリへのアクセスまたは長いALU操作の実行中にWaveがアイドル状態になると、スケジューラは別のWaveのペアに切り替わります。これにより、ALUは常にほぼ100％使用されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/433/54a/ea2/43354aea2bb0a351048a196808d6a06a.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2.実行履歴4：1</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
同じロードの例ですが、今回は命令の各サイクルで1つの波のみが発行されます。</font><font style="vertical-align: inherit;">2番目のALUが不足していることに注意してください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6cb/f33/e39/6cbf33e39c393986a3a26bd44b9777e8.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3.実行履歴4：4</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
今回は、各サイクルで4つの命令が発行されます。</font><font style="vertical-align: inherit;">ALUへのリクエストが多すぎるため、2つのウェーブがほぼ常に待機していることに注意してください（実際、これは計画アルゴリズムの誤りです）。</font></font><br>
<br>
<strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令の実装計画の難しさの詳細については、[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]を</font><font style="vertical-align: inherit;">参照してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現実の世界では、GPUのコア構成は異なります。コアあたり最大40のウェーブと4つのALUを持つものもあれば、7つの固定ウェーブと2つのALUを持つものもあります。</font><font style="vertical-align: inherit;">これはすべて多くの要因に依存し、アーキテクチャシミュレーションの骨の折れるプロセスのおかげで決定されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、実際のSIMD ALUは、提供するウェーブよりも幅が狭い場合があり、発行された1つの命令を処理するのに数サイクルかかります。</font><font style="vertical-align: inherit;">この要素は、長さ「チャイム」と呼ばれ</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整合性/不一致とは何ですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のコードスニペットを見てみましょう。</font></font><br>
<br>
<h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例1</font></font></h6><br>
<pre><code class="cpp hljs">uint lane_id = get_lane_id();
<span class="hljs-keyword">if</span> (lane_id &amp; <span class="hljs-number">1</span>) {
    <span class="hljs-comment">// Do smth</span><font></font>
}<font></font>
<span class="hljs-comment">// Do some more</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、実行パスが実行されている行の識別子に依存する命令のストリームが表示されます。</font><font style="vertical-align: inherit;">明らかに、異なる行には異なる意味があります。</font><font style="vertical-align: inherit;">何が起こりますか？</font><font style="vertical-align: inherit;">この問題を解決するにはさまざまなアプローチがあります[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]、しかし結局のところ、それらはすべてほぼ同じことを行います。そのようなアプローチの1つが実行マスクです。これについては、後で説明します。このアプローチは、Volta以前のNvidia GPUとAMD GCN GPUで使用されていました。実行マスクの主なポイントは、ウェーブの各ラインにビットを格納することです。対応するライン実行ビットが0の場合、発行される次の命令に対してレジスタは影響を受けません。実際、実行ビットが0であるため、ラインは実行された命令全体の影響を感じないはずです。これは次のように機能します。波は深さ検索順序で制御フローグラフに沿って進み、ビットが設定されるまで選択された遷移の履歴を保存します。例で示した方がいいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幅が8の波があるとします。コードフラグメントの実行マスクは次のようになります。</font></font><br>
<br>
<h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例1.実行マスクの履歴</font></font></h6><br>
<pre><code class="cpp hljs">                                  <span class="hljs-comment">// execution mask</span>
uint lane_id = get_lane_id();     <span class="hljs-comment">// 11111111</span>
<span class="hljs-keyword">if</span> (lane_id &amp; <span class="hljs-number">1</span>) {                <span class="hljs-comment">// 11111111</span>
    <span class="hljs-comment">// Do smth                    // 01010101</span><font></font>
}<font></font>
<span class="hljs-comment">// Do some more                   // 11111111</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、より複雑な例を考えます。</font></font><br>
<br>
<h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例2</font></font></h6><br>
<pre><code class="cpp hljs">uint lane_id = get_lane_id();
<span class="hljs-keyword">for</span> (uint i = lane_id; i &lt; <span class="hljs-number">16</span>; i++) {
    <span class="hljs-comment">// Do smth</span>
}</code></pre><br>
<h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例3</font></font></h6><br>
<pre><code class="cpp hljs">uint lane_id = get_lane_id();
<span class="hljs-keyword">if</span> (lane_id &lt; <span class="hljs-number">16</span>) {
    <span class="hljs-comment">// Do smth</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Do smth else</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは歴史が必要であることに気づくかもしれません。</font><font style="vertical-align: inherit;">実行マスクアプローチを使用する場合、機器は通常、ある種のスタックを使用します。</font><font style="vertical-align: inherit;">素朴なアプローチは、タプルのスタック（exec_mask、address）を格納し、スタックからマスクを取得してウェーブの命令ポインターを変更する収束命令を追加することです。</font><font style="vertical-align: inherit;">この場合、ウェーブには、各ラインのCFG全体をバイパスするのに十分な情報があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パフォーマンスに関しては、このすべてのデータストレージのため、制御フロー命令を処理するために必要なループは数回です。</font><font style="vertical-align: inherit;">スタックの深さが限られていることを忘れないでください。</font></font><br>
<br>
<strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新。</font></font></em></strong><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@craigkolbの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おかげで</font><font style="vertical-align: inherit;">、記事を読みました[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]では、AMD GCNのfork / join命令が最初にスレッド数の少ないパスを選択することに注意してください[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.6]。これにより、マスクスタックの深さがlog2に等しいことが保証されます。</font></font><br>
<br>
<strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新。</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明らかに、シェーダーのすべてのシェーダー/構造CFGにすべてを埋め込むことがほぼ可能であるため、実行マスクの履歴全体をレジスターに格納し、CFGを静的にバイパス/収束する計画を立て</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]。</font><font style="vertical-align: inherit;">AMDGPUのLLVMバックエンドを調べた後、コンパイラーによって常に発行された処理スタックの証拠は見つかりませんでした。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランタイムマスクハードウェアのサポート</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィキペディアからこれらの制御フローグラフを見てみましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f9/f04/a1a/5f9f04a1a89b36ad0908dee0e90542f3.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図4.一部のタイプの制御フローグラフ。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
すべてのケースを処理するために必要なマスク制御命令の最小セットは何ですか？</font><font style="vertical-align: inherit;">これは、暗黙的な並列化、明示的なマスク制御、およびデータ競合の完全に動的な同期を備えた人工ISAでの様子です。</font></font><br>
<br>
<pre><code class="cpp hljs">push_mask BRANCH_END         ; Push current mask <span class="hljs-keyword">and</span> reconvergence pointer<font></font>
pop_mask                     ; Pop mask <span class="hljs-keyword">and</span> jump to reconvergence instruction<font></font>
mask_nz r0.x                 ; Set execution bit, pop mask <span class="hljs-keyword">if</span> all bits are zero<font></font>
<font></font>
; Branch instruction is more complicated<font></font>
; Push current mask <span class="hljs-keyword">for</span> reconvergence<font></font>
; <span class="hljs-function">Push mask <span class="hljs-title">for</span> <span class="hljs-params">(r0.x == <span class="hljs-number">0</span>)</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">else</span> block, <span class="hljs-keyword">if</span> any lane takes the path
</span>; <span class="hljs-function">Set mask <span class="hljs-title">with</span> <span class="hljs-params">(r0.x != <span class="hljs-number">0</span>)</span>, fallback to <span class="hljs-keyword">else</span> in <span class="hljs-keyword">case</span> no bit is 1
br_push r0.x, ELSE, CONVERGE </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ケースd）を見てみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs">A:<font></font>
    br_push r0.x, C, D<font></font>
B:<font></font>
C:<font></font>
    mask_nz r0.y<font></font>
    jmp B<font></font>
D:<font></font>
    ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は制御フローの分析やISAの設計の専門家ではないので、私の人工ISAが処理できない場合があると確信していますが、構造化されたCFGで十分なので、これは重要ではありません。</font></font><br>
<br>
<strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新。</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制御フロー命令のGCNサポートの詳細については</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] ch.4を参照してください。LLVMの実装については、[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]を参照してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発散-同じ波の異なるラインによって選択されたパスの結果として生じる差異</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一貫性-矛盾はありません。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行マスク処理の例</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">架空のISA</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前のコードスニペットを人工ISAでコンパイルし、SIMD32のシミュレータで実行しました。</font><font style="vertical-align: inherit;">実行マスクの処理方法を確認してください。</font></font><br>
<br>
<strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新。</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人工シミュレータは常に真のパスを選択することに注意してください。これは最善の方法ではありません。</font></font><br>
<br>
<h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例1</font></font></h6><br>
<pre><code class="lisp hljs"><span class="hljs-comment">; uint lane_id = get_lane_id();</span><font></font>
    mov r0.x, lane_id<font></font>
<span class="hljs-comment">; if (lane_id &amp; 1) {</span><font></font>
    push_mask BRANCH_END<font></font>
    and r0.y, r0.x, u(<span class="hljs-number">1</span>)<font></font>
    mask_nz r0.y<font></font>
LOOP_BEGIN:<font></font>
    <span class="hljs-comment">; // Do smth</span>
    pop_mask                <span class="hljs-comment">; pop mask and reconverge</span><font></font>
BRANCH_END:<font></font>
    <span class="hljs-comment">; // Do some more</span>
    ret</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/d40/30c/fdb/d4030cfdb754b9a663c03ae46b31efc7.png" alt="図5"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図5.例1の実行履歴</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
黒い領域に気づきましたか？</font><font style="vertical-align: inherit;">今回は無駄になりました。</font><font style="vertical-align: inherit;">一部の行は、他の行が反復を完了するのを待ちます。</font></font><br>
<br>
<h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例2</font></font></h6><br>
<pre><code class="lisp hljs"><span class="hljs-comment">; uint lane_id = get_lane_id();</span><font></font>
    mov r0.x, lane_id<font></font>
<span class="hljs-comment">; for (uint i = lane_id; i &lt; 16; i++) {</span>
    push_mask LOOP_END        <span class="hljs-comment">; Push the current mask and the pointer to reconvergence instruction</span><font></font>
LOOP_PROLOG:<font></font>
    lt.u32 r0.y, r0.x, u(<span class="hljs-number">16</span>)  <span class="hljs-comment">; r0.y &lt;- r0.x &lt; 16</span>
    add.u32 r0.x, r0.x, u(<span class="hljs-number">1</span>)  <span class="hljs-comment">; r0.x &lt;- r0.x + 1</span>
    mask_nz r0.y              <span class="hljs-comment">; exec bit &lt;- r0.y != 0 - when all bits are zero next mask is popped</span><font></font>
LOOP_BEGIN:<font></font>
    <span class="hljs-comment">; // Do smth</span><font></font>
    jmp LOOP_PROLOG<font></font>
LOOP_END:<font></font>
    <span class="hljs-comment">; // }</span>
    ret</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/fe3/259/b17/fe3259b179e832553900c7cb22487e03.png" alt="図6"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図6.例2の履歴</font></font></i><br>
<br>
<h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例3</font></font></h6><br>
<pre><code class="lisp hljs">    mov r0.x, lane_id<font></font>
    lt.u32 r0.y, r0.x, u(<span class="hljs-number">16</span>)
    <span class="hljs-comment">; if (lane_id &lt; 16) {</span>
        <span class="hljs-comment">; Push (current mask, CONVERGE) and (else mask, ELSE)</span>
        <span class="hljs-comment">; Also set current execution bit to r0.y != 0</span><font></font>
    br_push r0.y, ELSE, CONVERGE<font></font>
THEN:<font></font>
    <span class="hljs-comment">; // Do smth</span><font></font>
    pop_mask<font></font>
    <span class="hljs-comment">; } else {</span><font></font>
ELSE:<font></font>
    <span class="hljs-comment">; // Do smth else</span><font></font>
    pop_mask<font></font>
    <span class="hljs-comment">; }</span><font></font>
CONVERGE:<font></font>
    ret</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/27e/d1b/2a9/27ed1b2a99db4ab917d661946ed7c705.png" alt="図7"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図7.例3の実行履歴</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD GCN ISA</font></font></h3><br>
<strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新。</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GCNは明示的なマスク処理も使用します。これについて詳しくは、[</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.x]を参照してください。</font><font style="vertical-align: inherit;">これは簡単にできる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェーダープレイグラウンドの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おかげで、私は彼らのISAからいくつかの例を示す</font><font style="vertical-align: inherit;">ことにしました。たぶんいつか私はシミュレーターを見つけて、なんとかダイアグラムを取得するでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーはスマートなので、他の結果を得ることができます。ポインターループを配置してアセンブラーコードをクリーンアップすることで、ブランチを最適化しないようにコンパイラーをだまそうとしました。私はGCNの専門家ではないため、いくつかの重要な専門家は</font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スキップされる場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、S_CBRANCH_I / G_FORKおよびS_CBRANCH_JOIN命令は単純であり、コンパイラーがそれらをサポートしていないため、これらのフラグメントでは使用されないことにも注意してください。</font><font style="vertical-align: inherit;">したがって、残念ながら、マスクのスタックを考慮することはできませんでした。</font><font style="vertical-align: inherit;">コンパイラにスタック処理をさせる方法を知っているなら教えてください。</font></font><br>
<br>
<strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新。</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMDを使用したLLVMバックエンドでのベクトル化された制御フローの実装については、</font><font style="vertical-align: inherit;">この</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レポート</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@ SiNGUL4RiTY</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">参照してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例1</font></font></h6><br>
<pre><code class="lisp hljs"><span class="hljs-comment">; uint lane_id = get_lane_id();</span>
<span class="hljs-comment">; GCN uses 64 wave width, so lane_id = thread_id &amp; 63</span>
<span class="hljs-comment">; There are scalar s* and vector v* registers</span>
<span class="hljs-comment">; Executon mask does not affect scalar or branch instructions</span>
    v_mov_b32     v1, <span class="hljs-number">0</span>x00000400      <span class="hljs-comment">; 1024 - group size</span>
    v_mad_u32_u24  v0, s12, v1, v0    <span class="hljs-comment">; thread_id calculation</span>
    v_and_b32     v1, <span class="hljs-number">63</span>, v0
<span class="hljs-comment">; if (lane_id &amp; 1) {</span>
    v_and_b32     v2, <span class="hljs-number">1</span>, v0<font></font>
    s_mov_b64     s[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>], exec        <span class="hljs-comment">; Save the execution mask</span>
    v_cmpx_ne_u32  exec, v2, <span class="hljs-number">0</span>        <span class="hljs-comment">; Set the execution bit</span>
    s_cbranch_execz  ELSE             <span class="hljs-comment">; Jmp if all exec bits are zero</span>
<span class="hljs-comment">; // Do smth</span><font></font>
ELSE:<font></font>
<span class="hljs-comment">; }</span>
<span class="hljs-comment">; // Do some more</span>
    s_mov_b64     exec, s[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]        <span class="hljs-comment">; Restore the execution mask</span>
    s_endpgm</code></pre><br>
<h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例2</font></font></h6><br>
<pre><code class="lisp hljs"><span class="hljs-comment">; uint lane_id = get_lane_id();</span>
    v_mov_b32     v1, <span class="hljs-number">0</span>x00000400<font></font>
    v_mad_u32_u24  v0, s8, v1, v0     <span class="hljs-comment">; Not sure why s8 this time and not s12</span>
    v_and_b32     v1, <span class="hljs-number">63</span>, v0
<span class="hljs-comment">; LOOP PROLOG</span>
    s_mov_b64     s[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>], exec        <span class="hljs-comment">; Save the execution mask</span><font></font>
    v_mov_b32     v2, v1<font></font>
    v_cmp_le_u32  vcc, <span class="hljs-number">16</span>, v1<font></font>
    s_andn2_b64   exec, exec, vcc     <span class="hljs-comment">; Set the execution bit</span>
    s_cbranch_execz  LOOP_END         <span class="hljs-comment">; Jmp if all exec bits are zero</span>
<span class="hljs-comment">; for (uint i = lane_id; i &lt; 16; i++) {</span><font></font>
LOOP_BEGIN:<font></font>
    <span class="hljs-comment">; // Do smth</span>
    v_add_u32     v2, <span class="hljs-number">1</span>, v2<font></font>
    v_cmp_le_u32  vcc, <span class="hljs-number">16</span>, v2<font></font>
    s_andn2_b64   exec, exec, vcc     <span class="hljs-comment">; Mask out lanes which are beyond loop limit</span>
    s_cbranch_execnz  LOOP_BEGIN      <span class="hljs-comment">; Jmp if non zero exec mask</span><font></font>
LOOP_END:<font></font>
    <span class="hljs-comment">; // }</span>
    s_mov_b64     exec, s[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]        <span class="hljs-comment">; Restore the execution mask</span>
    s_endpgm</code></pre><br>
<h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例3</font></font></h6><br>
<pre><code class="lisp hljs"><span class="hljs-comment">; uint lane_id = get_lane_id();</span>
    v_mov_b32     v1, <span class="hljs-number">0</span>x00000400<font></font>
    v_mad_u32_u24  v0, s12, v1, v0<font></font>
    v_and_b32     v1, <span class="hljs-number">63</span>, v0<font></font>
    v_and_b32     v2, <span class="hljs-number">1</span>, v0<font></font>
    s_mov_b64     s[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>], exec        <span class="hljs-comment">; Save the execution mask</span>
<span class="hljs-comment">; if (lane_id &lt; 16) {</span>
    v_cmpx_lt_u32  exec, v1, <span class="hljs-number">16</span>       <span class="hljs-comment">; Set the execution bit</span>
    s_cbranch_execz  ELSE             <span class="hljs-comment">; Jmp if all exec bits are zero</span>
<span class="hljs-comment">; // Do smth</span>
<span class="hljs-comment">; } else {</span><font></font>
ELSE:<font></font>
    s_andn2_b64   exec, s[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>], exec  <span class="hljs-comment">; Inverse the mask and &amp; with previous</span>
    s_cbranch_execz  CONVERGE         <span class="hljs-comment">; Jmp if all exec bits are zero</span>
<span class="hljs-comment">; // Do smth else</span>
<span class="hljs-comment">; }</span><font></font>
CONVERGE:<font></font>
    s_mov_b64     exec, s[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]        <span class="hljs-comment">; Restore the execution mask</span>
<span class="hljs-comment">; // Do some more</span>
    s_endpgm</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX512</font></font></h3><br>
<strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新。</font></font></em></strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@tom_forsyth</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、AVX512拡張にも明示的なマスク処理があることを指摘したので、ここにいくつかの例を示します。</font><font style="vertical-align: inherit;">この詳細については、[</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]、15.x、および15.6.1を参照してください。</font><font style="vertical-align: inherit;">それは厳密にはGPUではありませんが、32ビットの実際のSIMD16がまだあります。</font><font style="vertical-align: inherit;">コードスニペットはISPC（–target = avx512knl-i32x16）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> godbolt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して作成さ</font><font style="vertical-align: inherit;">れ、大幅に再設計されたため、100％真とは限りません。</font></font><br>
<br>
<h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例1</font></font></h6><br>
<pre><code class="lisp hljs">    <span class="hljs-comment">; Imagine zmm0 contains 16 lane_ids</span>
    <span class="hljs-comment">; AVXZ512 comes with k0-k7 mask registers</span>
    <span class="hljs-comment">; Usage:</span>
    <span class="hljs-comment">; op reg1 {k[7:0]}, reg2, reg3</span>
    <span class="hljs-comment">; k0 can not be used as a predicate operand, only k1-k7</span>
<span class="hljs-comment">; if (lane_id &amp; 1) {</span>
    vpslld       zmm0 {k1}, zmm0, <span class="hljs-number">31</span>  <span class="hljs-comment">; zmm0[i] = zmm0[i] &lt;&lt; 31</span>
    kmovw        eax, k1              <span class="hljs-comment">; Save the execution mask</span>
    vptestmd     k1 {k1}, zmm0, zmm0  <span class="hljs-comment">; k1[i] = zmm0[i] != 0</span><font></font>
    kortestw     k1, k1<font></font>
    je           ELSE                 <span class="hljs-comment">; Jmp if all exec bits are zero</span>
<span class="hljs-comment">; // Do smth</span>
    <span class="hljs-comment">; Now k1 contains the execution mask</span>
    <span class="hljs-comment">; We can use it like this:</span>
    <span class="hljs-comment">; vmovdqa32 zmm1 {k1}, zmm0</span><font></font>
ELSE:<font></font>
<span class="hljs-comment">; }</span>
    kmovw        k1, eax              <span class="hljs-comment">; Restore the execution mask</span>
<span class="hljs-comment">; // Do some more</span>
    ret</code></pre><br>
<h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例2</font></font></h6><br>
<pre><code class="lisp hljs"> <span class="hljs-comment">; Imagine zmm0 contains 16 lane_ids</span>
    kmovw         eax, k1               <span class="hljs-comment">; Save the execution mask</span>
    vpcmpltud     k1 {k1}, zmm0, <span class="hljs-number">16</span>     <span class="hljs-comment">; k1[i] = zmm0[i] &lt; 16</span><font></font>
    kortestw      k1, k1<font></font>
    je            LOOP_END              <span class="hljs-comment">; Jmp if all exec bits are zero</span>
    vpternlogd    zmm1 {k1}, zmm1, zmm1, <span class="hljs-number">255</span>   <span class="hljs-comment">; zmm1[i] = -1</span>
<span class="hljs-comment">; for (uint i = lane_id; i &lt; 16; i++) {</span><font></font>
LOOP_BEGIN:<font></font>
<span class="hljs-comment">; // Do smth</span>
    vpsubd        zmm0 {k1}, zmm0, zmm1 <span class="hljs-comment">; zmm0[i] = zmm0[i] + 1</span>
    vpcmpltud     k1 {k1}, zmm0, <span class="hljs-number">16</span>     <span class="hljs-comment">; masked k1[i] = zmm0[i] &lt; 16</span><font></font>
    kortestw      k1, k1<font></font>
    jne           LOOP_BEGIN            <span class="hljs-comment">; Break if all exec bits are zero</span><font></font>
LOOP_END:<font></font>
<span class="hljs-comment">; // }</span>
    kmovw        k1, eax                <span class="hljs-comment">; Restore the execution mask</span>
<span class="hljs-comment">; // Do some more</span>
    ret</code></pre><br>
<h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例3</font></font></h6><br>
<pre><code class="lisp hljs"> <span class="hljs-comment">; Imagine zmm0 contains 16 lane_ids</span>
<span class="hljs-comment">; if (lane_id &amp; 1) {</span>
    vpslld       zmm0 {k1}, zmm0, <span class="hljs-number">31</span>  <span class="hljs-comment">; zmm0[i] = zmm0[i] &lt;&lt; 31</span>
    kmovw        eax, k1              <span class="hljs-comment">; Save the execution mask</span>
    vptestmd     k1 {k1}, zmm0, zmm0  <span class="hljs-comment">; k1[i] = zmm0[i] != 0</span><font></font>
    kortestw     k1, k1<font></font>
    je           ELSE                 <span class="hljs-comment">; Jmp if all exec bits are zero</span><font></font>
THEN:<font></font>
<span class="hljs-comment">; // Do smth</span>
<span class="hljs-comment">; } else {</span><font></font>
ELSE:<font></font>
    kmovw        ebx, k1<font></font>
    andn         ebx, eax, ebx<font></font>
    kmovw        k1, ebx              <span class="hljs-comment">; mask = ~mask &amp; old_mask</span><font></font>
    kortestw     k1, k1<font></font>
    je           CONVERGE             <span class="hljs-comment">; Jmp if all exec bits are zero</span>
<span class="hljs-comment">; // Do smth else</span>
<span class="hljs-comment">; }</span><font></font>
CONVERGE:<font></font>
kmovw            k1, eax              <span class="hljs-comment">; Restore the execution mask</span>
<span class="hljs-comment">; // Do some more</span>
    ret</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">矛盾に対処するにはどうすればよいですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は、発散する線を組み合わせることによって非効率がどのように発生するかを示す、単純で完全な図を作成しようとしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単なコードを想像してください：</font></font><br>
<br>
<pre><code class="lisp hljs">uint thread_id = get_thread_id()<span class="hljs-comment">;</span>
uint iter_count = memory[thread_id]<span class="hljs-comment">;</span>
for (<span class="hljs-name">uint</span> i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; iter_count; i++) {</span><font></font>
    // Do smth<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256のスレッドを作成して、その実行時間を測定してみましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c2/2da/c5d/7c22dac5d75a77156a60c510a655309a.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図8.発散スレッドのランタイム</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
。x軸はプログラムストリームの識別子、y軸はクロックサイクルです。異なる列は、シングルスレッド実行と比較して、異なる波長でフローをグループ化するときにどれだけの時間が無駄になっているかを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウェーブの実行時間は、ウェーブに含まれるライン間の最大実行時間と同じです。 SIMD8ではすでにパフォーマンスが劇的に低下していることがわかります。さらに拡張すると、パフォーマンスが少し悪くなります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0d/c9a/be6/a0dc9abe6a7a0e12515d4c88c36aaa21.png" alt="図9"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図9.一致したフローのランタイム</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この図は同じ列を示していますが、今回は反復数がフローIDでソートされています。つまり、反復数が類似するフローが1つの波に送信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、実行が約半分に加速される可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、例は単純すぎますが、要点を理解していただければ幸いです。実行時の不一致はデータの不一致に起因するため、CFGは単純でデータの一貫性が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、レイトレーサーを作成している場合、BVHの同じノードを通過する可能性が最も高いため、光線を同じ方向と位置でグループ化するとメリットが得られる可能性があります。詳細については、[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]およびその他の関連記事を</font><font style="vertical-align: inherit;">参照してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ハードウェアレベルでの不一致に対処するための手法があることにも言及する価値があります。たとえば、ダイナミックワープ形成[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]や、小さなブランチの予測実行などです。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[1] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラフィックパイプラインを介してトリップ</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
[2] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kayvon Fatahalian：並列計算</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
[3] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンピュータアーキテクチャA定量的アプローチ</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
[4] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低コストでスタックレスSIMTの再コンバージェンス</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
[5] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">microbenchmarking介して解剖GPUメモリ階層</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
[6] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解剖</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">マイクロベンチマークによる</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">NVIDIA Volta GPUアーキテクチャ</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
[7] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">効率的なGPU制御フローのための動的ワープ形成とスケジューリング</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
[8] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maurizio Cerrato：GPUアーキテクチャ</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
[9] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おもちゃのGPUシミュレーター</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
[10] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUプログラムでの分岐の分岐の削減</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
[11] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ベガ」命令セットアーキテクチャ</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
[12]</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Joshua Barczak：GCNのシェーダー実行のシミュレーション</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
[13] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タンジェントベクトル：分岐に関する余談</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
[14] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インテル64およびIA-32アーキテクチャー</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ソフトウェア</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">開発者向けマニュアル</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
[15] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIMDアプリケーションの分岐制御フローのベクトル化</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457692/index.html">全国のNB-Fi標準と請求システムに関する考察</a></li>
<li><a href="../ja457696/index.html">﻿複数文字定数を使用することの危険性</a></li>
<li><a href="../ja457698/index.html">実験：DoS攻撃に対抗するツールとしてプロキシを使用する</a></li>
<li><a href="../ja457700/index.html">passport.jsとサードパーティサービスを含まないNode.js認証ガイド</a></li>
<li><a href="../ja457702/index.html">KOMPAS-3D APIの操作→レッスン16→制御文字</a></li>
<li><a href="../ja457706/index.html">ロボットはSAP ERPをテストします</a></li>
<li><a href="../ja457710/index.html">2019年のニューラルネットワークのすばらしい機能</a></li>
<li><a href="../ja457712/index.html">VerizonとBGP Optimizerが大規模なオフラインを実現した方法</a></li>
<li><a href="../ja457714/index.html">英語のスタックオーバーフロー：コミュニティキルガイド</a></li>
<li><a href="../ja457718/index.html">ハイパーカード、ウェブの進化における失われたリンク</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>