<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÄ üî® üë©‚Äçüëß Ventanas multicolores: constructor virtual, CRTP y plantillas complejas üë®üèΩ‚Äçü§ù‚Äçüë®üèº üõÄüèª üåó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desde hace bastante tiempo, se conoce un patr√≥n de dise√±o no trivial cuando se pasa una clase derivada en el par√°metro base:
 

template<class T> clas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Ventanas multicolores: constructor virtual, CRTP y plantillas complejas</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/507146/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde hace bastante tiempo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conoce </font><font style="vertical-align: inherit;">un </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">patr√≥n de dise√±o no trivial</font></a><font style="vertical-align: inherit;"> cuando se pasa una clase derivada en el par√°metro base:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">Base</span>
{</span><font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base&lt;Derived&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta plantilla tiene su propio nombre: CRTP: Patr√≥n de plantilla curiosamente recurrente, que se traduce como "patr√≥n extra√±amente repetitivo". Agregu√© a√∫n m√°s rarezas a esta construcci√≥n ya extra√±a: la generalic√© a toda una cadena de herencias. S√≠, realmente se puede hacer, pero para esto hay que </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dar el alma</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para pagar un gran precio. Para saber c√≥mo lo hice y qu√© precio debo pagar, lo invito a leer m√°s este art√≠culo para obtener m√°s detalles.</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ trataremos </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con perversiones terribles mediante</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> varios m√©todos extra√±os y otras cosas malas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quiero advertirle de inmediato: no tome el material descrito aqu√≠ como algo serio. Estoy seguro de que en el 95-99% de los casos, todo esto nunca te ser√° √∫til en la pr√°ctica. Este es un tipo de matem√°tica entretenida, un entrenamiento para la mente. En la pr√°ctica, es poco probable que sea √∫til, pero es interesante dedicar tiempo a esto. Solo en este caso el lenguaje C ++ y sus capacidades act√∫an como matem√°ticas. Te advierto de antemano, porque Si est√° buscando algo serio y pr√°cticamente orientado aqu√≠, puede sentirse decepcionado.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sintonice inmediatamente lo ex√≥tico, como si de repente se encontrara en un pa√≠s donde dos lunas, tres soles, hojas de plantas son azules o lilas, y de hecho, muchas cosas habituales aqu√≠ son algo ... extra√±as e inusuales ... Si est√° sumido en la vida cotidiana gris y no hace mucho tiempo le√≠ algo as√≠, luego llegaste a la direcci√≥n ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ventanas multicolores</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fue hace mucho tiempo. </font><font style="vertical-align: inherit;">Hace casi tres a√±os. </font><font style="vertical-align: inherit;">Luego me </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sent√© en una hierba pesada que</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solo comprend√≠a la </font><font style="vertical-align: inherit;">base </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zen</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de C ++ 11/14 del libro Meyers S. - "C ++ eficaz y moderno". </font><font style="vertical-align: inherit;">Tambi√©n menciona este patr√≥n. </font><font style="vertical-align: inherit;">Despu√©s de eso, cuando sent√≠ que hab√≠a </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alcanzado la iluminaci√≥n</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><s><font style="vertical-align: inherit;">hab√≠a</font></s><font style="vertical-align: inherit;"> dominado los conceptos b√°sicos del nuevo est√°ndar y estaba listo para mirar las cosas viejas de una manera nueva, comenc√© a actualizar un libro en la API de Windows: Schupak Y. - "Win32 API. </font><font style="vertical-align: inherit;">Desarrollo efectivo de aplicaciones ". </font><font style="vertical-align: inherit;">Al principio, describe un programa m√≠nimo de lenguaje C para crear y mostrar una ventana:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><font></font>
<font></font>
HWND hMainWnd;<font></font>
TCHAR szClassName[] = TEXT(<span class="hljs-string">"MyClass"</span>);<font></font>
MSG msg;<font></font>
WNDCLASSEX *wc;<font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{<font></font>
	HDC hDC;<font></font>
	PAINTSTRUCT ps;<font></font>
	RECT rect;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span>(uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		SetClassLongPtr(hWnd, <span class="hljs-number">-10</span>, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"Hello, world!"</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		DestroyWindow(hWnd);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="hljs-keyword">int</span> nCmdShow)</span>
</span>{	
	<span class="hljs-keyword">if</span>(!(wc = <span class="hljs-keyword">new</span> WNDCLASSEX))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"  !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	wc-&gt;cbSize = <span class="hljs-keyword">sizeof</span>(WNDCLASSEX);<font></font>
	wc-&gt;style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wc-&gt;lpfnWndProc = WndProc;<font></font>
	wc-&gt;cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;hInstance = hInstance;<font></font>
	wc-&gt;hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wc-&gt;hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wc-&gt;hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wc-&gt;lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wc-&gt;lpszClassName = szClassName;<font></font>
	wc-&gt;hIconSm = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">if</span>(!RegisterClassEx(wc))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"     !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">delete</span> wc;<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	hMainWnd = CreateWindow(szClassName, TEXT(<span class="hljs-string">"A Hello1 Application"</span>), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, <span class="hljs-number">0</span>, CW_USEDEFAULT, <span class="hljs-number">0</span>, (HWND)<span class="hljs-literal">NULL</span>, (HMENU)<span class="hljs-literal">NULL</span>, (HINSTANCE)hInstance, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(!hMainWnd)<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"   !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
	ShowWindow(hMainWnd, nCmdShow);<font></font>
	<span class="hljs-comment">//UpdateWindow(hMainWnd);</span><font></font>
<font></font>
	<span class="hljs-comment">//      </span>
	<span class="hljs-keyword">while</span>(GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<font></font>
	{<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//MessageBox(NULL, TEXT("Application is going to quit."), TEXT("Exit"), MB_OK);</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya lo he hecho muchas veces, mostrando diferentes ventanas en el modelo de este libro. </font><font style="vertical-align: inherit;">Y de repente pens√©: ¬°acabo de leer sobre C ++ ayer mismo! </font><font style="vertical-align: inherit;">¬°Puedo escribir mi propia clase para mostrar esta ventana! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dicho y hecho:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;					<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La estructura de la clase es trivial: se declaran varios constructores (con la transferencia de los par√°metros principales y los enlaces a la estructura WNDCLASSEX m√°s detallada), la funci√≥n CreateWnd de registrar la clase de ventana y crear la ventana, llamada desde los constructores, as√≠ como un conjunto de funciones miembro virtuales que realizan acciones procesando cada uno de los mensajes de Windows dentro del procedimiento de devoluci√≥n de llamada de la ventana. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los miembros de los datos de la clase tambi√©n son m√≠nimos: identificador de ventana hWnd; Estructura WNDCLASSEX utilizada para crear la clase; y la barra de t√≠tulo de la ventana.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El procedimiento de devoluci√≥n de llamada de ventana se declara como est√°tico para evitar pasar impl√≠citamente el puntero this al objeto de clase y, por lo tanto, viola el acuerdo sobre el tipo (firma) de la funci√≥n del procedimiento de ventana aceptado en Windows (recuerde que no llamaremos a esta funci√≥n nosotros mismos, sino Windows, porque los par√°metros y el tipo de retorno de esta funci√≥n est√°n estrictamente especificados).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procedimiento de ventana y este puntero</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se sabe por C ++: si una funci√≥n miembro se define como est√°tica, se debe pasar expl√≠citamente un puntero a un objeto de clase. Sin embargo, no podemos pasar un puntero a un objeto de clase a un procedimiento de ventana est√°tica, ya que el formato de esta funci√≥n no permite esta transferencia. A este respecto, surge un problema fundamental: si hay varios objetos de la clase WindowClass, ¬øc√≥mo sabe un √∫nico procedimiento de ventana est√°tica qu√© objeto de clase en particular ha recibido un mensaje? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solo hay una salida: debe establecer esta conexi√≥n de una forma u otra.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows identifica una ventana por su identificador HWND hWnd. El objeto de clase correspondiente a esta ventana puede identificarse mediante un puntero a este objeto. Por lo tanto, debe establecer la conexi√≥n hWnd &lt;-&gt; puntero al objeto WindowClass. Por ejemplo, un procedimiento de ventana, al ser al mismo tiempo miembro de una clase, podr√≠a tener un enlace o un puntero a alguna estructura de datos tambi√©n est√°tica, estableciendo una conexi√≥n entre hWnd y un puntero a un objeto para cada ventana y actualizada cada vez que se crea un objeto de la clase. La estructura de datos debe ser est√°tica para que, en primer lugar, se pueda acceder desde un procedimiento de ventana est√°tica sin puntero a ning√∫n objeto de clase, y en segundo lugar, que debe ser √∫nica para todos los objetos de la clase (que l√≥gicamente se deduce de su prop√≥sito ), y en tercer lugar,de modo que todav√≠a est√° vinculado a una clase con el nivel de acceso apropiado y no a ser una variable global externa.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, despu√©s de descubrir c√≥mo describir esta estructura y por qu√© es necesaria, queda por descubrir cu√°l deber√≠a ser esta estructura. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se pueden declarar dos matrices din√°micas: una para identificadores de ventana HWND y la segunda para punteros a objetos WindowClass. Sin embargo, esta no es la mejor soluci√≥n: no est√° claro c√≥mo elegir el tama√±o de la matriz, cu√°les ser√°n los escenarios para usar Windows, si las matrices estar√°n casi vac√≠as si su tama√±o se selecciona incorrectamente, lo que provocar√° un desbordamiento de memoria. O, por el contrario, cuando al crear ventanas se agota su volumen, ser√° necesario aumentar su tama√±o, etc. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una soluci√≥n mejor (e incluso dir√≠a que es ideal) en esta situaci√≥n es una lista ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°lista!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Una lista es una estructura de datos din√°mica que consiste en un conjunto de nodos conectados en pares. Cada nodo (en el caso de una lista doblemente vinculada) tiene punteros a los nodos anteriores y siguientes de la lista, as√≠ como datos almacenados adicionales. En nuestra situaci√≥n, cada nodo de ventana corresponde a cada una de las ventanas, y los datos √∫tiles son un identificador de ventana y un puntero a un objeto de la clase WindowClass. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, cada vez que se crea una nueva ventana, se crea un nuevo nodo de lista y se agrega a su final (se convierte en el √∫ltimo). Al cerrar, el nodo se elimina y los punteros de los nodos anterior y siguiente se ajustan entre s√≠ para reemplazar el nodo remoto. Al mismo tiempo, no hay desbordamiento de memoria: se crean exactamente tantos nodos como ventanas creadas, y tambi√©n se eliminan al mismo tiempo que se cierra la ventana.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, tambi√©n se debe agregar un nuevo miembro est√°tico a la clase WindowClass:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> List wndList;	<span class="hljs-comment">// ,    </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y declararlo privilegiado para permitirle acceder a los miembros de WindowClass:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">friend</span> List;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Ahora no dar√© una definici√≥n de la clase de lista y la clase de nodo, sus funciones, ya que esto no se aplica directamente a la clase WindowClass, y la l√≥gica de implementaci√≥n de esta clase es conocida y bastante trivial). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, el procedimiento de ventana cuando llega un nuevo mensaje en caso de que pertenece al n√∫mero que procesa, de acuerdo con el descriptor de ventana que hWnd le pas√≥ desde Windows, accede a la lista, busca un nodo en √©l de acuerdo con el hWnd especificado y, al encontrarlo, obtiene el puntero requerido a un objeto de la clase WindowClass. Luego, por puntero, llama a una funci√≥n virtual correspondiente al mensaje que se est√° procesando: para una clase anulada, una funci√≥n virtual con el mismo nombre puede realizar otras acciones.</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowClass::WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{
	<span class="hljs-comment">// 	</span>
	ListElement * pListElem = <span class="hljs-literal">nullptr</span>;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span> (uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		{<font></font>
			<span class="hljs-comment">//lParam      CREATESTRUCT,         WindowClass,  </span>
			<span class="hljs-comment">// (.  WindowClass::CreateWnd)</span>
			CREATESTRUCT *cs = <span class="hljs-keyword">reinterpret_cast</span>&lt;CREATESTRUCT *&gt;(lParam);<font></font>
			WindowClass *p_wndClass = <span class="hljs-keyword">reinterpret_cast</span>&lt;WindowClass *&gt;(cs-&gt;lpCreateParams);<font></font>
			p_wndClass-&gt;hWnd = hWnd;		<span class="hljs-comment">// hWnd   ,    </span>
			<span class="hljs-comment">//    </span><font></font>
			pListElem = wndList.add(p_wndClass);<font></font>
			<span class="hljs-keyword">if</span> (pListElem)<font></font>
				pListElem-&gt;p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//  ,   </span><font></font>
		}<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)	<font></font>
			pListElem-&gt;p_wndClass-&gt;OnPaint(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnClose(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnDestroy(hWnd);  <span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un punto sutil aqu√≠. Se trata de la inicializaci√≥n de la clase y el procesamiento del mensaje WM_CREATE. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al crear una ventana con la funci√≥n CreateWindow, en el momento de su invocaci√≥n, el identificador de la ventana hWnd a√∫n no se conoce: ¬°la ventana a√∫n no se ha creado! Por lo tanto, para poder llamar a OnCreate virtual, debe conocer el puntero al objeto de clase. Esto se hace pasando bastante arriesgado el puntero this de la funci√≥n WindowClass :: CreateWnd a la funci√≥n CreateWindow a trav√©s del puntero lParam. Al procesar WM_CREATE, el procedimiento de ventana recibe este puntero del par√°metro, con su ayuda inicializa el miembro hWnd dentro del objeto, y luego crea un nuevo nodo de lista para esta ventana usando el puntero al objeto de clase. Luego llama a OnCreate virtual por puntero.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para los mensajes restantes, se realiza la l√≥gica descrita anteriormente: busque el nodo de la lista mediante el identificador de ventana actual hWnd transferido desde Windows, y luego llame a la funci√≥n virtual deseada por el puntero al objeto de clase desde el nodo de la lista. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de compilar el programa y asegurarme de que todo funciona correctamente, yo, frot√°ndome las manos </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ante la sensaci√≥n de mi propia grandeza</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por el trabajo realizado, comenc√© a leer m√°s. </font><font style="vertical-align: inherit;">Y all√≠, en la p√°gina siguiente, se indica la funci√≥n de cambiar las propiedades de la ventana:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">DWORD <span class="hljs-title">SetClassLong</span><span class="hljs-params">(HWND hWnd, <span class="hljs-keyword">int</span> nIndex, LONG dwNewLong)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inmediatamente decid√≠ crear una nueva ventana basada en la anterior:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass		<span class="hljs-comment">//         </span><font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La clase derivada difiere de la clase base al agregar un contador de ventana est√°tico, as√≠ como al cambiar OnCreate, OnPaint y OnDestroy: la funci√≥n OnCreate cambia el color de fondo de la ventana, OnPaint muestra un mensaje diferente y OnDestroy disminuye el contador de ventana est√°tico. </font><font style="vertical-align: inherit;">Todo es muy simple y claro. </font><font style="vertical-align: inherit;">Montado y lanzado. </font><font style="vertical-align: inherit;">El texto del mensaje se ha vuelto diferente ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... pero el color de la ventana no ha cambiado.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constructor virtual</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces me di cuenta de que ya hab√≠a puesto un pie en hielo delgado. </font><font style="vertical-align: inherit;">No todos los matices se describen en el material b√°sico de los libros principales. </font><font style="vertical-align: inherit;">Uno de ellos es un constructor virtual. </font><font style="vertical-align: inherit;">Pens√© que llamar a la funci√≥n virtual de la clase derivada desde el constructor es exactamente lo mismo que en cualquier otra parte del programa. </font><font style="vertical-align: inherit;">Result√≥ que esto no se pod√≠a hacer.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema es que la funci√≥n virtual llamada desde el constructor se llama como no virtual: solo se crea el objeto de la clase base, y luego no hasta el final, y el objeto derivado a√∫n no se ha creado, y la tabla de funciones virtuales no se ha generado. En nuestro caso, obtenemos la cadena: constructor derivado -&gt; constructor base -&gt; CreateWnd -&gt; CreateWindow -&gt; procedimiento de ventana -&gt; OnCreate, es decir, OnCreate se llama realmente desde el constructor. El objeto derivado a√∫n no se ha creado, por lo tanto, se llama a OnCreate para la clase base. Resulta que su redefinici√≥n en la derivada no tiene sentido. ¬øQu√© hacer?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se sabe por C ++ que cualquier funci√≥n anulada se puede llamar por su nombre completo: class_name :: function_name. Un nombre de clase no es solo un nombre: se identifica, de hecho, el tipo de objeto. Tambi√©n se sabe por C ++ que una clase (y funci√≥n) se puede convertir en plantilla (plantilla) pas√°ndola (her) como par√°metro. Por lo tanto, si crea la plantilla de funci√≥n de procedimiento de ventana y le pasa el tipo de la clase derivada de alguna manera, puede llamar a la funci√≥n anulada deseada directamente en el constructor de la </font><font style="vertical-align: inherit;">clase </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par√° par√° par√° !!! ¬°No puedes hacer lo mismo! A√∫n no se ha creado una clase derivada, sus datos no se han inicializado: ¬øa qu√© funciones va a llamar aqu√≠? </font></font><br>
<s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si no puedes, pero realmente quieres, entonces puedes.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, no apunt√© a una apelaci√≥n completa a la clase derivada. </font><font style="vertical-align: inherit;">Ten√≠a la intenci√≥n de llamar a una </font><font style="vertical-align: inherit;">funci√≥n de WinAPI </font><font style="vertical-align: inherit;">completamente de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terceros</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que no tiene nada que ver con la clase. </font><font style="vertical-align: inherit;">"¬°Pero esto se puede hacer de maneras completamente diferentes y mucho m√°s f√°cil!" </font><font style="vertical-align: inherit;">- tu dices. </font><font style="vertical-align: inherit;">Si. </font><font style="vertical-align: inherit;">Lata. </font><font style="vertical-align: inherit;">Y escribir√© sobre eso al final del art√≠culo. </font><font style="vertical-align: inherit;">Pero en ese momento dej√© todo esto a un lado y me concentr√© en el lado puramente t√©cnico de la pregunta: pero a√∫n as√≠, ¬øes posible, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en principio,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> llamar a algo derivado del constructor de la clase base? </font><font style="vertical-align: inherit;">Era un inter√©s puramente deportivo, si lo desea. </font><font style="vertical-align: inherit;">No pens√© en ning√∫n lado pr√°ctico en ese momento. </font><font style="vertical-align: inherit;">Era una tarea no trivial, y me preguntaba si podr√≠a resolverlo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clase de plantilla de ventana - M√©todo 1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, la dificultad es: ¬øc√≥mo pasar el tipo de la clase derivada al procedimiento de ventana? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No quer√≠a convertir toda la clase base de WindowClass en una clase de plantilla a la vez: para cada clase derivada se generar√° su propia clase base. Adem√°s, dado que WindowClass se convertir√° en plantilla, tanto los nodos de la lista como la lista en s√≠ misma tambi√©n tendr√°n que hacerse plantillas: tienen punteros a los objetos de clase y, para usar estos punteros, deben conocer su tipo, es decir, WindowClass y con qu√© se parametrizar√°. . En el momento de definir la clase de lista y la clase de nodo, esto es desconocido; por lo tanto, este tipo tambi√©n debe pasarse como un par√°metro (de WindowClass). Se deduce que para cada clase derivada crear√° su propia lista correspondiente a </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta clase derivada</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(y solo a √©l)! Y ahora no puede poner punteros a las clases base correspondientes a diferentes derivados en una matriz: tienen diferentes tipos.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces comenc√© a buscar una manera de pasar el tipo de la clase derivada, sin parametrizar toda la clase. Un tipo se puede pasar a la clase base solo a trav√©s del constructor: esta es la √∫nica funci√≥n a la que se accede al crear el objeto. Por lo tanto, debe ser repetitivo. Sin embargo, result√≥ que obviamente no pod√≠a especificar los par√°metros de la plantilla: parecer√≠a pasar par√°metros a la clase de plantilla en s√≠, y no a su constructor. Por lo tanto, el tipo solo se puede inferir de los par√°metros pasados ‚Äã‚Äãal constructor. Pero no quer√≠a agregar un par√°metro de constructor especial, que sirve solo para la inferencia de tipos: saturar la lista de argumentos con un par√°metro puramente √∫til. Y si el usuario olvida transferirlo, por ejemplo,a trav√©s de al menos el nullptr trivial (DerivedClass *)? Esto a√∫n no da miedo: el compilador mostrar√° un mensaje de error que indica que la clase no puede ser instanciada. Peor a√∫n, si el usuario crea una jerarqu√≠a de clases y pasa un puntero a la clase derivada incorrecta: todo ser√° correcto desde el punto de vista de la compilaci√≥n, pero obtendremos un programa que funciona incorrectamente con un error incomprensible.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En resumen, este error de c√°lculo de dise√±o es una soluci√≥n. </font><font style="vertical-align: inherit;">Por lo tanto, la responsabilidad de la instanciaci√≥n correcta ni siquiera se transfiere al creador de la clase derivada, ¬°sino a quien la usar√°! </font><font style="vertical-align: inherit;">Y √©l no puede ser ni un sue√±o, ni un esp√≠ritu con respecto a tales matices y sinceramente no entender d√≥nde est√° el error. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, al rendirme, decid√≠ sin embargo, sin cambiar los par√°metros del constructor, parametrizar WindowClass y al mismo tiempo la lista asociada y las clases de nodo de lista. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Clase de plantilla WindowClass:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">struct</span> <span class="hljs-title">ListElement</span>				// 
{</span>
	<span class="hljs-comment">// </span>
	HWND hWnd;					<span class="hljs-comment">//  Windows</span>
	WindowClass&lt;WndCls&gt; *p_wndClass;	<span class="hljs-comment">//    WindowClass</span><font></font>
<font></font>
	ListElement *pNext;			<span class="hljs-comment">//    </span>
	ListElement *pPrev;			<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-keyword">using</span> WndProcCallback = LRESULT (*)(HWND, UINT, WPARAM, LPARAM);		<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List&lt;WndCls&gt; wndList;					<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//	</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T, <span class="hljs-keyword">typename</span> </span>= T::OnCreate&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//! .  FirstWin32CPP_DerivedTemplate2</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span><font></font>
		T::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//  OnCreate         </span>
	</span>{<font></font>
		p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List&lt;WndCls&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
	<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Clase derivada:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WindowClassDerived&amp;);		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un procedimiento de ventana, al ser un miembro de plantilla de una clase de plantilla y tener acceso al tipo pasado de la clase derivada, llama a OnCreate de la clase derivada. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces llegamos naturalmente a la plantilla CRTP. Aqu√≠ result√≥ por s√≠ solo. Solo mucho m√°s tarde descubr√≠ que este dise√±o es una plantilla conocida con el nombre correspondiente. Pero entonces no sab√≠a esto, y me pareci√≥ que lo recib√≠ por primera vez.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me di cuenta de inmediato de que esta es solo la mitad de la soluci√≥n. </font><font style="vertical-align: inherit;">Puedo querer crear f√°cilmente otra clase basada en esta derivada. </font><font style="vertical-align: inherit;">Y eso es todo: no es una plantilla repetitiva y ya no acepta ning√∫n par√°metro. </font><font style="vertical-align: inherit;">Entonces se me ocurri√≥ la idea de pasar la segunda clase derivada a trav√©s de la primera derivada a la base. </font><font style="vertical-align: inherit;">(El hielo bajo mis pies comenz√≥ a resquebrajarse ... ya estaba yendo a donde no hay retorno). Pero si lo hago una vez, puedo hacerlo tanto como quiera: incluso si tengo diez clases derivadas, puedo tomar el d√©cimo consecutivo ( la √∫ltima) para pasar a lo largo de la cadena a la base, y llamar√° all√≠ la funci√≥n de esta √∫ltima derivada que necesito (y, en t√©rminos generales, cualquier intermedia, si se desea). </font><font style="vertical-align: inherit;">La tarea estaba clara. </font><font style="vertical-align: inherit;">Todo lo que quedaba era hacerlo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clase de ventana parametrizada - M√©todo 2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la segunda carrera, me puse tres tareas:</font></font><br>
<ul>
<li>-     ;</li>
<li>   ;</li>
<li>   ,   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, para cumplir con estos requisitos, deber√° crear una plantilla para el dise√±ador y agregarle un par√°metro especial. Sin embargo, esto significa una violaci√≥n de otro requisito. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øCu√°l es la soluci√≥n aqu√≠? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede dividir la clase base WindowClass original en dos componentes: WindowClass en s√≠ (llam√©mosla WindowClassBase ahora), que es una base √∫nica inquebrantable y que complementa su clase derivada (que se puede llamar el mismo nombre WindowClass original). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La clase complementaria es responsable de la implementaci√≥n de OnCreate y, adem√°s, se puede parametrizar como un todo. Y √©l en su constructor pasar√° el tipo que se le pas√≥ a trav√©s de un par√°metro especial al constructor de la clase WindowClassBase.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cualquier caso, en WindowClassBase en relaci√≥n con la fuente ahora tiene que hacer algunos cambios. Primero, adem√°s de eliminar realmente OnCreate de √©l, deber√° agregar un miembro de puntero a la clase que lo complementa (y, en el futuro, derivados de √©l), as√≠ como una funci√≥n de llamada que llame a OnCreate por este puntero: no podemos llamar al puntero al base, porque OnCreate ya no est√° en √©l, y OnCreate de las clases que son complementarias y derivadas de √©l es mejor llamarlo por el puntero correcto a la clase deseada, en lugar de intentar algo con este puntero de la base. En √∫ltima instancia, el par√°metro especial del constructor WindowClassBase ser√° necesario no solo para la inferencia de tipos, sino tambi√©n para guardar y luego llamar a la clase necesaria a trav√©s de OnCreate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desafortunadamente, el tipo de este puntero tuvo que quedar vac√≠o:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la clase no es plantilla, y no puede decirle al compilador que cree un puntero con un tipo desconocido;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muchos derivados se heredan de la clase base, todos tienen diferentes tipos: ¬øqu√© tipo de puntero debo usar?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final, lo acabo de declarar en estilo C: en cualquier situaci√≥n extra√±a, use un puntero para anular. </font><font style="vertical-align: inherit;">El puntero se almacena f√≠sicamente como sin tipo, pero en el momento de la llamada, OnCreate se convierte al tipo de la clase llamada. </font><font style="vertical-align: inherit;">Esto se realiza en una funci√≥n de llamada de plantilla especial que pertenece a WindowClassBase y cuyo tipo de par√°metro se conoce en el momento de la llamada:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
</span>{
	<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span>
	<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
		(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Inicialmente, std :: true_type o std :: false_type se us√≥ como el segundo par√°metro para seleccionar la opci√≥n deseada para anular la funci√≥n. Usando el m√©todo SFINAE, se determin√≥ en la etapa de compilaci√≥n si la clase WndCls tiene una funci√≥n miembro OnCreate. Si es as√≠, se llama a la funci√≥n anterior. Si no es as√≠, la llamada a OnCreate se realiz√≥ de la siguiente manera:</font></font><br>
<pre><code class="cpp hljs">(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;OnCreate(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Posteriormente, result√≥ que SFINAE no era necesario: una clase que complementa WindowClassBase, en cualquier caso, tiene una funci√≥n miembro OnCreate, por lo tanto, incluso si la clase de par√°metro WndCls aprobada no tiene OnCreate definido, est√° en una de las clases base con respecto a ella , y la comprobaci√≥n dar√° verdadero en todos los casos. Si, por alg√∫n milagro, la clase complementaria se cambia para que OnCreate se elimine de ella, y tampoco existe en todas sus clases derivadas, entonces no tiene sentido invocarla de la segunda manera: dicho c√≥digo simplemente no se compilar√°. Por lo tanto, al final, la opci√≥n anterior se da aqu√≠.)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La l√≥gica de aceptar y usar el tipo de clase base en WindowClassBase es bastante simple: el tipo se deriva del puntero al objeto de la clase derivada pasado al constructor WindowClassBase, este puntero se almacena en este constructor, y el puntero al procedimiento de ventana de plantilla se instancia por el tipo pasado, y se accede al LaunchOnCreate anterior. . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, la clase WindowClassBase ahora se ver√° as√≠:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassBase</span>				//  <span class="hljs-title">Windows</span>
{</span>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span>
	<span class="hljs-keyword">void</span> *p_drvWndCls;								<span class="hljs-comment">//   ,    (..  -  </span>
													<span class="hljs-comment">//,   ( )   , ..   void</span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls</span>
		<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
			(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">friend</span> List;
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">friend</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//     </span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassBase(WindowClassBase&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassBase();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, aqu√≠ est√° el c√≥digo para el constructor m√°s corto:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase::WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle)</span>
</span>{
	<span class="hljs-comment">// ,   ,   wc</span>
	<span class="hljs-comment">// : p_wndClass -    ,        , wc -    </span>
	<span class="hljs-comment">//    Windows, szWndTitle -   </span><font></font>
<font></font>
	WindowClassBase::wc = wc;<font></font>
	WindowClassBase::wc.lpfnWndProc = WndProc&lt;WndCls&gt;;<font></font>
	WindowClassBase::szWndTitle = szWndTitle;<font></font>
<font></font>
	p_drvWndCls = p_wndClass;		<span class="hljs-comment">//    ,   OnCreate()      WM_CREATE</span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	CreateWnd(WindowClassBase::wc, <span class="hljs-literal">false</span>, szWndTitle);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dentro del procedimiento de la ventana, la llamada a LaunchOnCreate es la siguiente:</font></font><br>
<pre><code class="cpp hljs">p_wndClass-&gt;LaunchOnCreate&lt;WndCls&gt;(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decidi√≥ eliminar el procedimiento de la ventana de la clase externa, declar√°ndolo privilegiado en la clase WindowClassBase. Quiz√°s esto no ten√≠a mucho sentido: ¬øqu√© diferencia hace, d√≥nde producir sus instancias, fuera o dentro de la clase? ¬°El segmento de c√≥digo es uno! Aunque, lo admito, desde el punto de vista de la misma encapsulaci√≥n, quiz√°s deber√≠a dejarla est√°tica dentro de la clase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Queda por definir la clase complementaria:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase			<span class="hljs-comment">//,  WindowClassBase    </span><font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La clase tiene un constructor que se ve igual que el WindowClass original antes de dividirse, es decir, sin un par√°metro especial, y este par√°metro especial se genera internamente cuando se accede al constructor WindowClassBase al pasar este puntero. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta WindowClass en este formulario es casi el equivalente de la WindowClass original. </font><font style="vertical-align: inherit;">Como tal, no admite la herencia con anulaciones de OnCreate. </font><font style="vertical-align: inherit;">Sin embargo, este es el punto de partida para respaldar la herencia (como se mostrar√° a continuaci√≥n). </font><font style="vertical-align: inherit;">Ene sta forma:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la clase base WindowClassBase no es gen√©rica en s√≠ misma, lo que significa que ser√° la √∫nica para todas las clases derivadas, sean las que sean; </font><font style="vertical-align: inherit;">la Lista para garantizar que todos los dem√°s mensajes de Windows se procesen correctamente tambi√©n ser√° el √∫nico;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el constructor WindowClass no tiene un par√°metro especial adicional.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, se cumplen dos de los tres requisitos. </font><font style="vertical-align: inherit;">Queda por tratar con esto √∫ltimo: con la herencia.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encadenamiento de tipo de clase derivada en WindowClassBase, tipo de control</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comenzar, consideraremos la herencia de una sola vez, cuando la l√≥gica de inicializaci√≥n de WindowClass no nos conviene, y queremos cambiarla mediante la creaci√≥n de una clase derivada (por ahora, al menos una). </font><font style="vertical-align: inherit;">¬øQu√© se debe cambiar en WindowClass para garantizar esto? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una nueva variante de la clase complementaria se convierte en repetitivo. </font><font style="vertical-align: inherit;">Esto no da miedo, ya que en realidad no contiene ning√∫n dato, sino solo la funci√≥n y los constructores OnCreate:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta clase toma un par√°metro de tipo DerWndCls y, al convertir este puntero en √©l, lo pasa a WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Presta atenci√≥n a static_cast. Esto es importante porque mi conversi√≥n se escribi√≥ originalmente en estilo C como este:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de traducirlo a static_cast en todas partes, la mitad del c√≥digo (ver m√°s abajo) no se compil√≥. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este tambi√©n es un punto sutil: la conversi√≥n se realiza en la etapa de compilaci√≥n, pero esta clase en s√≠ tiene la funci√≥n OnCreate, y despu√©s de la conversi√≥n, DerWndCls se puede usar para llamar a OnCreate de la clase DerWndCls. </font><font style="vertical-align: inherit;">Esta es la diferencia con el caso de conversi√≥n descrito anteriormente dentro de WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, puede crear una determinada clase WindowClassDerived, anular OnCreate en ella e instanciarla con WindowClassTemplate descrita anteriormente, nuevamente implementando la misma plantilla de repetici√≥n extra√±a original indicada al comienzo del art√≠culo:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y OnCreate de este WindowClassDerived se llamar√° dentro de WindowClassBase, seg√∫n sea necesario.</font></font><br>
<pre><code class="cpp hljs">WindowClassDerived::WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle) : WindowClassTemplate(hInstance, szClassName, szWndTitle)<font></font>
{<font></font>
	usiWndNum++;		<span class="hljs-comment">//    </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero esta es una herencia de una sola vez. </font><font style="vertical-align: inherit;">En el caso de herencia m√∫ltiple, en lugar de WindowClassDerived, a su vez, debe declarar una nueva plantilla, potencialmente llevando a la clase un nivel m√°s alto en la jerarqu√≠a y pas√°ndola a WindowClassTemplate. </font><font style="vertical-align: inherit;">Destaco espec√≠ficamente dos puntos clave:</font></font><br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Potencialmente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> host clase arriba en la jerarqu√≠a. </font><font style="vertical-align: inherit;">Esto significa que puede no aceptar ninguna clase, es decir, ser la clase superior de la jerarqu√≠a para que se pueda crear un objeto a partir de ella.</font></font></li>
<li><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par√°metro de </font><b><font style="vertical-align: inherit;">transmisi√≥n</font></b><font style="vertical-align: inherit;"> WindowClassTemplate. </font><font style="vertical-align: inherit;">Esto significa que el argumento de plantilla aceptado debe pasarse m√°s lejos de una clase a otra a trav√©s de toda la cadena de herencia hasta el final, en WindowClassTemplate y desde all√≠ a WindowClassBase.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, por un lado, la clase debe ser una plantilla y tomar una clase determinada como par√°metro. Por otro lado, debe monitorear la situaci√≥n de que es en s√≠ misma una clase finita (en el momento de la instanciaci√≥n) e instanciar la clase base por s√≠ misma, y ‚Äã‚Äãno por el tipo transferido. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con todo esto, me gustar√≠a que el compilador lo hiciera autom√°ticamente: definir una nueva clase basada en una ya creada no requerir√° ninguna modificaci√≥n de esta √∫ltima, entonces se pierde toda la esencia del polimorfismo de herencia. Es decir: creo una clase que actualmente est√° en la parte superior de la jerarqu√≠a, pero </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tal vez se</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> crear√° una nueva clase basada en esto, que reemplazar√° a la actual sin cambiar su definici√≥n. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo implementar esta funcionalidad?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver el problema de la automatizaci√≥n y la toma inteligente de decisiones, el argumento predeterminado para la plantilla se sugiere a s√≠ mismo: si la clase actual que se est√° creando es la principal y el par√°metro de la plantilla no se le pasa, entonces debemos asignarle este par√°metro. Esto se logra utilizando el argumento predeterminado. Luego surgen las siguientes preguntas: ¬øc√≥mo elegirlo y c√≥mo relacionarlo con la situaci√≥n del par√°metro pasado expl√≠citamente, as√≠ como transferirse a s√≠ mismo si el par√°metro no se pasa? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desafortunadamente, no puede escribir su propia clase definida como un par√°metro predeterminado. El compilador simplemente no perder√° el c√≥digo del formulario:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">WindowClassDerived</span>&lt;&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√âl informa que una dependencia de tipo recursiva es demasiado compleja. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vayamos al otro lado. </font><font style="vertical-align: inherit;">Presentemos una clase ficticia que no hace nada funcionalmente y no almacena nada, desempe√±a el papel de enchufes ficticios y le indica al compilador que, en caso de que aparezca, nada se transferir√° "desde arriba":</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};	<span class="hljs-comment">//-,     </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y en el argumento predeterminado, sustituya esta mordaza por nosotros mismos:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con esta opci√≥n, en la situaci√≥n con el argumento predeterminado, esta clase se pasa a WindowClassTemplate. </font><font style="vertical-align: inherit;">La clase thisclass no tiene una funci√≥n miembro OnCreate, por lo que esta opci√≥n simplemente no se compila. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intentemos entonces introducir un segundo par√°metro de control auxiliar, en base al cual decidiremos qu√© tipo pasar. </font><font style="vertical-align: inherit;">Para hacer esto, por supuesto, debe cambiar WindowClassTemplate, por ejemplo, as√≠:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassControlBaseTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//  ControlType == thisclass,      DerWndCls,    ,   WindowClassBase</span>
	<span class="hljs-comment">//  ControlType != thisclass,    ControlType,        ( </span>
	<span class="hljs-comment">//    ControlType     )</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;ControlType, thisclass&gt;::value, DerWndCls, ControlType&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassControlBaseTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassControlBaseTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No se le transmite un tipo, sino dos. Seg√∫n la combinaci√≥n de estos dos tipos, el tipo final se determina utilizando las herramientas &lt;type_traits&gt;: std :: conditional_t ‚Äã‚Äãy std :: is_same. Es este tipo el que se pasa a WindowClassBase. La l√≥gica de selecci√≥n se describe en los comentarios: si esta clase se pasa a ControlType, entonces seleccionamos DerWndCls, de lo contrario se selecciona ControlType. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora construyamos una plantilla que la use al heredar:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsDerivedTemplateClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassControlBaseTemplate&lt;WndClsDerivedTemplateClass&lt;DerWndCls&gt;, ControlType&gt;		<span class="hljs-comment">//      </span><font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WndClsDerivedTemplateClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WndClsDerivedTemplateClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WndClsDerivedTemplateClass(WndClsDerivedTemplateClass&amp;);	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WndClsDerivedTemplateClass() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primer par√°metro se inicializa de forma predeterminada a trav√©s de thisclass, y ControlType se calcula en funci√≥n de DerWndCls: si DerWndCls = thisclass, entonces ControlType: = thisclass, de lo contrario ControlType: = DerWndCls (asignaci√≥n de estilo Pascal espec√≠ficamente especificada para distinguir de la comparaci√≥n). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, la clase WndClsDerivedTemplateClass, parametrizada por DerWndCls, se pasar√° junto con el tipo de control calculado (en la etapa de compilaci√≥n).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si creamos un objeto de esta clase, es decir, WndClsDerivedTemplateClass en s√≠ es la parte superior de la jerarqu√≠a, luego DerWndCls = ControlType = thisclass y luego &lt;WndClsDerivedTemplateClass, thisclass&gt; pasa. El hecho de que WndClsDerivedTemplateClass est√© parametrizado por un dummy no importa: este tipo, y de hecho cualquier DerWndCls pasado en su lugar, no se usa dentro de la clase de ninguna manera: no se crea ning√∫n objeto a partir de √©l y no se llama a ninguna funci√≥n a trav√©s de √©l. Por lo tanto, formalmente WndClsDerivedTemplateClass se puede instanciar literalmente con cualquier cosa: el tipo de par√°metro solo sirve para pasar m√°s all√° de la l√≠nea de herencia. Pero aqu√≠, en lugar de DerWndCls, se pas√≥ WndClsDerivedTemplateClass &lt;thisclass o cualquier otro tipo&gt;, es importante: WndClsDerivedTemplateClass tiene una funci√≥n OnCreate,que se llamar√° dentro de WindowClassBase.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con esta opci√≥n, esta clase llega a WindowClassControlBaseTemplate en lugar de ControlType, y el tipo final se muestra como DerWndCls = WndClsDerivedTemplateClass, que tiene la funci√≥n OnCreate necesaria. Que es lo que necesitamos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora considere la opci√≥n cuando se crea una nueva clase basada en WindowClassControlBaseTemplate (m√°s herencia):</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, en WndClsDerivedTemplateClass, algo que no sea thisclass toma el lugar de DerWndCls, y ControlType, al ver esta diferencia, toma el valor pasado a DerWndCls. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, en WindowClassControlBaseTemplate, la siguiente opci√≥n de parametrizaci√≥n va: &lt;WndClsDerivedTemplateClass &lt;WindowClassDerivedTemplateNext&gt;, WindowClassDerivedTemplateNext&gt;. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En WindowClassControlBaseTemplate, a su vez, dado que ControlType! = Thisclass, utiliza el ControlType en s√≠, que es igual a WindowClassDerivedTemplateNext, que es la clase correcta para seleccionar OnCreate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primera vista, con tal esquema, todo parece estar bien. Pero esto no es as√≠. Construimos otra clase basada en lo √∫ltimo:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedTemplateNext&lt;WindowClassDerivedTemplateNext2&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En WindowClassDerivedTemplateNext, WindowClassDerivedTemplateNext2 reemplazar√° DerWndCls. ControlType tambi√©n se genera como WindowClassDerivedTemplateNext2. Luego </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;WindowClassDerivedTemplateNext2&gt; se </font><font style="vertical-align: inherit;">pasar√° a </font><b><font style="vertical-align: inherit;">WndClsDerivedTemplateClass</font></b><font style="vertical-align: inherit;"> , y ControlType mostrar√° el mismo WindowClassDerivedTemplateNext &lt;WindowClassDerivedTemplateNext2&gt; en √©l. A continuaci√≥n, los mismos valores se transferir√°n a WindowClassControlBaseTemplate, y all√≠, en lugar de la correcta WindowClassDerivedTemplateNext2 &lt;WindowClassDerivedTemplateNext&gt;, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;WindowClassDerivedTemplateNextTerplateDiveTerplateDiveTlassDimeTextDementer </font><font style="vertical-align: inherit;">se utiliza </font><b><font style="vertical-align: inherit;">la</font></b><font style="vertical-align: inherit;"> funci√≥n de </font><b><font style="vertical-align: inherit;">la</font></b><font style="vertical-align: inherit;"> ventana.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le recuerdo que con este esquema de heredar y pasar par√°metros, el tipo de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> clase en </font><b><font style="vertical-align: inherit;">s√≠</font></b><font style="vertical-align: inherit;"> , que lleg√≥ a WindowClassControlBaseTemplate como resultado, es importante, y no con lo que est√° parametrizado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, para que el tipo para el que se llamar√° a OnCreate se muestre correctamente, debe cambiar la definici√≥n de la clase WindowClassDerivedTemplateNext:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, en WndClsDerivedTemplateClass, el valor correcto igual a WindowClassDerivedTemplateNext2 se pasar√° al ControlType en lugar de mostrarse all√≠ en el valor incorrecto. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, la √∫ltima clase que estamos construyendo no debe pasar ControlType, permitiendo que la base m√°s cercana la env√≠e de forma independiente, y esta base y todas las subyacentes deben pasar ControlType expl√≠citamente, prohibiendo su salida autom√°tica al valor incorrecto. Este enfoque implica un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cambio en la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definici√≥n de la clase base m√°s cercana, que es posible solo si tenemos el c√≥digo fuente disponible o si lo hemos construido nosotros mismos antes.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si olvidamos hacer esto y violamos esta regla, cuando usamos static_cast obtenemos un error de compilaci√≥n, y si convertimos punteros de estilo C dentro de WindowClassControlBaseTemplate, obtenemos un </font><font style="vertical-align: inherit;">programa que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funciona </font><b><font style="vertical-align: inherit;">correctamente</font></b><font style="vertical-align: inherit;"> . Por ejemplo, si intentamos crear un objeto para una clase</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
entonces el compilador dar√° un error: no podr√° convertir los tipos de puntero dentro de WindowClassControlBaseTemplate debido al hecho de que el tipo era incorrecto y no se puede convertir (dado que vamos a crear un objeto de la clase WindowClassDerivedTemplateNext, suponemos que la clase WindowClassDerivedTemplateNext est√° en la parte superior jerarqu√≠a, y en este caso, como se muestra arriba, ControlType no debe pasarse). Sin static_cast, el c√≥digo se compilar√° y solo llamar√° a OnCreate de la clase incorrecta. Sin embargo, al eliminar la transmisi√≥n ControlType, el programa se vuelve a compilar.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, todo esto es demasiado complicado, poco confiable y requiere la disponibilidad de c√≥digos fuente de todas las clases. </font><font style="vertical-align: inherit;">Adem√°s, solo podemos crear objetos de la √∫ltima clase derivada, y una de sus clases base no se puede crear debido a la transferencia ControlType (o podemos hacerlo si se pasa el puntero en el estilo C, pero estos objetos se inicializar√°n incorrectamente). </font><font style="vertical-align: inherit;">Necesitamos una soluci√≥n diferente, m√°s simple y m√°s confiable.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plantilla variable</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, la variante anterior de herencia de plantilla y pasar el tipo del objeto creado a la clase WindowClassBase, donde se crea la ventana y se llama a OnCreate, tiene serios inconvenientes. Necesitamos alguna otra opci√≥n m√°s confiable y eficiente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 11 presenta un nuevo tipo de plantilla: una plantilla con un n√∫mero variable de argumentos, o una plantilla variable. Sus par√°metros son una secuencia de tipos de longitud previamente desconocida. En lugar de manipulaciones arriesgadas con el tipo de control en el ejemplo anterior, decid√≠ ir por el otro lado: para evitar situaciones en las que la clase intermedia en la jerarqu√≠a reemplaza a la clase principal en la jerarqu√≠a a trav√©s de una parametrizaci√≥n incorrecta (en el ejemplo anterior, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt;), generalmente puede evitar este tipo de parametrizaci√≥n simplemente colocando estas clases en secuencia una al lado de la otra. Por ejemplo, con tres herencias sucesivas en los par√°metros de la plantilla, finalmente se formar√° la siguiente lista: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;WndCls3 &lt;&gt;, WndCls2 &lt;&gt;, WndCls1 &lt;&gt;&gt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Procesando esta lista, m√°s precisamente, uno de sus elementos finales (dependiendo de c√≥mo la haya compuesto), Puede extraer la clase deseada en la jerarqu√≠a y trabajar con ella. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, en lugar de las plantillas WindowClassTemplate y WindowClassControlBaseTemplate descritas anteriormente, que est√°n m√°s cerca de la ventana WindowClassBase ra√≠z y forman la base de todas las dem√°s herencias, debe escribir una nueva clase de plantilla variable. En su versi√≥n m√°s simple, ser√° as√≠:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,      </span>
<span class="hljs-keyword">template</span>&lt;class... Classes&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>;</span>		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-comment">//,          </span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span>... <span class="hljs-title">OtherWindowClasses</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>&lt;DerWndCls, OtherWindowClasses...&gt; :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//      :    - DerWndCls</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = DerWndCls;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadicTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadicTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, se declara una descripci√≥n general de la plantilla de clase sin el cuerpo. Luego, se determina su especializaci√≥n, en la que el primer tipo se separa del resto. Es √©l quien nos interesa. Esto es cierto para el caso cuando cada clase subsiguiente se coloca </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al final de la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lista de par√°metros </font><font style="vertical-align: inherit;">cuando se mueve por la cadena de jerarqu√≠a a WindowClassBase </font><font style="vertical-align: inherit;">. Entonces la clase que necesitamos estar√° al principio, y es muy simple separarla del resto. Puedes hacerlo de manera diferente: cada nueva clase se pondr√° </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al principio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lista de opciones de plantilla. Entonces la clase en la parte superior de la jerarqu√≠a ser√° la √∫ltima en la lista, y extraerla de all√≠ es mucho m√°s dif√≠cil. En este caso particular, estos dos enfoques son completamente id√©nticos, pero el primero es mucho m√°s f√°cil de implementar (incluso durante la compilaci√≥n: no tendr√° que procesar toda la lista extrayendo el √∫ltimo elemento de √©l), y es √©l quien se da arriba. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primer elemento, que es la clase m√°s alta en la jerarqu√≠a, se recupera de la lista y se pasa a WindowClassBase. Si OnCreate est√° definido para ello, se llamar√°. De lo contrario, se llamar√° a OnCreate de la clase base m√°s cercana en relaci√≥n con ella. Si la lista de par√°metros variables est√° vac√≠a (estamos tratando de crear un objeto desde WindowClassVariadicTemplate), la compilaci√≥n fallar√°, requiriendo al menos un tipo en la lista de par√°metros.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La primera clase basada en WindowClassVariadicTemplate ser√° as√≠:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic1</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadicTemplate&lt;PrevWndClasses..., WindowClassVariadic1&lt;&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadic1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(hInstance, szClassName, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadic1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(wc, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	WindowClassVariadic1(WindowClassVariadic1&amp; wcObj) : WindowClassVariadicTemplate(wcObj)			<span class="hljs-comment">// </span><font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassVariadic1() <span class="hljs-keyword">override</span>		<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);		<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_DESTROY   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta clase, habiendo aceptado una lista indefinida de par√°metros PrevWndClasses, la pasa m√°s all√° a la clase base, insert√°ndose antes como el primer elemento con una lista vac√≠a de par√°metros. </font><font style="vertical-align: inherit;">Dado que esta clase WindowClassVariadic1 en s√≠ misma es variable, WindowClassVariadic1 &lt;&gt; tambi√©n ser√° variable, aunque sin par√°metros, y toda esta secuencia de clases es en realidad una plantilla variable, cada elemento del cual tambi√©n es una plantilla variable. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La siguiente clase derivada es:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic2</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic1&lt;PrevWndClasses..., WindowClassVariadic2&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con la excepci√≥n de cambiar el nombre de la derivada y la base, la clase tiene exactamente la misma forma que la anterior. </font><font style="vertical-align: inherit;">La siguiente clase es similar:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic3</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic2&lt;PrevWndClasses..., WindowClassVariadic3&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es el significado de la herencia m√∫ltiple polim√≥rfica: al declarar una clase de esta manera, garantizamos no solo la creaci√≥n de objetos de este tipo, sino tambi√©n todos los objetos de todas las dem√°s clases derivadas de ella, sin importar cu√°nto y lo que sean en el futuro. En este caso, el OnCreate correcto siempre se llamar√° en WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, esta plantilla variable es la primera forma de trabajo para resolver el problema de llamar a OnCreate al crear una ventana que cumpla todos los requisitos establecidos previamente.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mirando hacia el futuro, donde finalmente se encontr√≥ el mejor m√©todo en la situaci√≥n dada, la implementaci√≥n de la herencia a trav√©s de una plantilla variable le permite implementar una l√≥gica de compilaci√≥n m√°s compleja en WindowClassBase: al tener acceso a todos los tipos por los cuales se produjo la herencia, puede elegir con flexibilidad entre ellos el necesario o criterios y llame a la funci√≥n miembro definida en √©l. </font><font style="vertical-align: inherit;">Pero este sigue siendo un caso ligeramente diferente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clase de inicializaci√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin darme cuenta de la reacci√≥n de static_cast a los tipos derivados, segu√≠ buscando otras formas de implementar la transferencia de la clase de v√©rtice de la jerarqu√≠a a WindowClassBase. </font><font style="vertical-align: inherit;">En alg√∫n momento, pens√© en llevar la implementaci√≥n de OnCreate a una clase separada, especialmente creada para ello:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassInit1</span>
{</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta clase parametriza otra clase que implementa todas las dem√°s anulaciones para funciones virtuales. </font><font style="vertical-align: inherit;">Se deriva del ya descrito WindowClassTemplate:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsInit</span> = <span class="hljs-title">WindowClassInit1</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedI1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WndClsInit&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De este modo:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la herencia de clase ocurre como de costumbre para las funciones virtuales;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo la clase de inicializaci√≥n especialmente definida para la implementaci√≥n de OnCreate se transfiere de una clase a otra a lo largo de la cadena de herencia.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si esta clase se encuentra en la parte superior de la jerarqu√≠a, entonces el par√°metro WndClsInit ser√° igual a WindowClassInit1, la clase de inicializaci√≥n definida para esta clase, y se transferir√° m√°s a lo largo de la cadena de la jerarqu√≠a. Si esta clase es intermedia en la cadena, entonces simplemente aceptar√° la clase que le pas√≥ y la pasar√°. Luego, que esta opci√≥n se compara favorablemente con las anteriores en que las plantillas no se transfieren a s√≠ mismas, sino que transfieren alguna clase de terceros, que se implementa (y parece) mucho m√°s f√°cil. Una plantilla en este formulario tambi√©n es adecuada sin cambios para la implementaci√≥n de toda la cadena de herencia: solo se producir√° el cambio de los nombres de clase.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, static_cast, a diferencia de la conversi√≥n de estilo C, dentro de WindowClassTemplate no perder√° esta forma de herencia: simplemente no puede convertir al pasar esto de (WindowClassTemplate *) a (WindowClassInit1 *). </font><font style="vertical-align: inherit;">Y esto es l√≥gico: WindowClassInit1 es en realidad una clase extra√±a, simplemente se pasa como un tipo a este punto, no est√° conectado de ninguna manera con WindowClassTemplate y toda la cadena de derivados de √©l, por lo tanto, la conversi√≥n del puntero a ella es inaceptable.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encadenamiento de tipo de clase derivada en WindowClassBase, transferencia condicional</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y finalmente, se encontr√≥ la mejor manera para esta situaci√≥n de transferir el tipo de la clase derivada a la base ra√≠z WindowClassBase a trav√©s de toda la cadena de herencia, sin los inconvenientes de los anteriores y al mismo tiempo m√°s simple que la plantilla variable. </font><font style="vertical-align: inherit;">Defina la siguiente clase de plantilla basada en WindowClassTemplate:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassDerivedAlternative1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerivedAlternative1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerivedAlternative1() <span class="hljs-keyword">override</span>	<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);	<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>			<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>	<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{
		<span class="hljs-comment">//  WM_PAINT   </span><font></font>
		HDC hDC;<font></font>
		PAINTSTRUCT ps;<font></font>
		RECT rect;<font></font>
<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"       ( )."</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta clase acepta DerWndCls como par√°metro, que por defecto es igual a esta clase. </font><font style="vertical-align: inherit;">Durante la transferencia, DerWndCls se compara con esta clase: en caso de igualdad (el valor predeterminado, es decir, la clase dada est√° en la parte superior de la jerarqu√≠a), se pasa con una lista vac√≠a de par√°metros. </font><font style="vertical-align: inherit;">De lo contrario, el DerWndCls recibido se pasa. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considero que esta soluci√≥n es la mejor en esta situaci√≥n en todos los aspectos:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una √∫nica forma de definici√≥n de clase para toda la cadena de herencia;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l√≥gica simple y transparente de transferencia de clase a lo largo de toda la cadena de herencia;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sin gastos generales debido a la plantilla variable (en esos casos, como en este caso, cuando no es necesario).</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retribuci√≥n terrible</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© significa todo esto? </font><font style="vertical-align: inherit;">Esto significa que si desea utilizar una forma de herencia tan poco convencional, debe formalizar todas sus clases de una manera estrictamente definida para que permitan la transferencia a trav√©s de usted de una posible nueva derivada. </font><font style="vertical-align: inherit;">Este es un requisito muy f√°cil, y si lo desea, es f√°cil de seguir. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero hay otra pregunta mucho m√°s no trivial: la relaci√≥n entre tipos y punteros. </font><font style="vertical-align: inherit;">Las personas inteligentes escribieron: no juegues con esas cosas en el constructor e ir en contra de los principios del lenguaje y la l√≥gica del compilador. </font><font style="vertical-align: inherit;">Pero no obedec√≠ y lo hice de todos modos. </font><font style="vertical-align: inherit;">Ahora viene la retribuci√≥n natural. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, tenemos 4 clases:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative2&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative3</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative2&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative3&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative4</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative3&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative4&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como escrib√≠ anteriormente, su contenido espec√≠fico y su l√≥gica de trabajo no tienen importancia. </font><font style="vertical-align: inherit;">Lo √∫nico importante es que en el t√≠tulo de la definici√≥n de clase. </font><font style="vertical-align: inherit;">En base a estas clases, creamos 4 objetos:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">WindowClassDerivedAlternative1&lt;&gt; <span class="hljs-title">w1</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative2&lt;&gt; <span class="hljs-title">w2</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative3&lt;&gt; <span class="hljs-title">w3</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative4&lt;&gt; <span class="hljs-title">w4</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>))</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Expandimos las definiciones de sus tipos ocultos entre par√©ntesis vac√≠os utilizando los argumentos predeterminados. El tipo w1 es WindowClassDerivedAlternative1. El tipo w2 es WindowClassDerivedAlternative2, y su clase base es WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative2&gt;. El tipo w3 es WindowClassDerivedAlternative3, su clase base es WindowClassDerivedAlternative2 &lt;WindowClassDerivedAlternative3&gt;, y su clase base es WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative3&gt;. Del mismo modo, para el cuarto objeto. Echa un vistazo al siguiente diagrama:</font></font><br>
<img src="https://habrastorage.org/webt/bu/b5/nn/bub5nnsttowpw1lhstypwm-3vfc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al crear cada nueva clase derivada sobre la base de una determinada clase base que se define de esta manera, usted define no solo una nueva clase, sino al mismo tiempo toda la cadena de sus bases de nuevo. Ser√° paralelo a la cadena de su propia clase base. Su clase tendr√° sus propias clases base, y ninguna de ellas podr√° conducir a ninguna de las clases base originales, ¬°a pesar de que el c√≥digo de generaci√≥n para todas estas clases es el mismo! Parece una verdadera fantas√≠a, ¬°pero realmente lo es! ¬°Esto significa que todas las formas habituales de manipular clases heredadas y punteros no funcionar√°n! En esta arquitectura particular, solo la base WindowClassBase guarda la situaci√≥n, de lo contrario tambi√©n ser√≠a imposible crear una matriz a partir de las clases base (por ejemplo, basadas en WindowClassTemplate),porque todas esas clases tienen diferentes tipos.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, la definici√≥n conocida y comprensible de la forma:</font></font><br>
<pre><code class="cpp hljs">WindowClassDerivedAlternative1&lt;&gt; *p2 = &amp;w2;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... dejar√° de compilar porque est√° intentando crear un puntero de tipo que sea incompatible con el tipo del objeto w2 a pesar de que hace media hora usted mismo escribi√≥ una clase derivada de la clase WindowClassDerivedAlternative1 &lt;&gt; y en funci√≥n de la cual se cre√≥ el objeto w2.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando las leyes habituales dejan de funcionar, puede causar conmoci√≥n. </font><font style="vertical-align: inherit;">Y con todo esto, en realidad no hay hacks de compilaci√≥n sucios, conversiones de tipo forzado y otras cosas realmente malas. </font><font style="vertical-align: inherit;">Todo es extremadamente limpio y legal: plantillas, par√°metros predeterminados y herramientas de biblioteca de tipos. </font><font style="vertical-align: inherit;">Solo los m√©todos familiares de escritura de c√≥digo dejan de funcionar. </font><font style="vertical-align: inherit;">Usar esto en un proyecto real significa declarar all√≠ una zona de peligro, a la que solo puede ingresar personal especializado calificado con las medidas de protecci√≥n adecuadas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Experimentos de c√≥digo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que sea m√°s f√°cil para todos los interesados ‚Äã‚Äãen experimentar y ahorrar tiempo en escribir, publiqu√© en GitHub todos los proyectos que sirvieron de base para este art√≠culo: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ECRTP</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Simplemente elija un proyecto por turno como su inicio, de lo contrario se ahogar√° en un mar de ventanas coloridas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚ÄúSi todo esto es una broma, entonces, dados los esfuerzos realizados, parece demasiado serio y natural. </font><font style="vertical-align: inherit;">Y si no es una broma, entonces ning√∫n desarrollador normal en su sano juicio realmente usar√° algo as√≠. </font><font style="vertical-align: inherit;">Y de todos modos, amigo, ¬øno terminar√≠as sufriendo tonter√≠as y no har√≠as algo </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que trae dinero? Es</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √∫til ". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tienes raz√≥n si piensas eso. </font><font style="vertical-align: inherit;">En este art√≠culo, acabo de demostrar que C ++ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La cuesti√≥n de la aplicaci√≥n pr√°ctica de estas estructuras permanece abierta. Y en general, es m√°s probable que esto se aplique a la generalizaci√≥n y la metaprogramaci√≥n. Es posible que no necesite crear ning√∫n objeto de estas clases, pero las clases en s√≠ pueden ser necesarias por alguna raz√≥n. S√≠, y nunca se sabe qu√© soluciones √∫tiles puede encontrar sobre esta base ... ¬°Se utiliza el CRTP original! ¬°Y ni siquiera se usa en ninguna parte, sino directamente en la biblioteca est√°ndar! Quien no cree o no recuerda, google std :: en_shared_from_this. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Volviendo a la tarea original con Windows ... Especialmente ahora, con sobriedad </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y sin c√©sped,</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mirando hacia atr√°s todo esto despu√©s de tres a√±os ... Incluso si descartamos el hecho de que toqu√© un tema banal que ya se ha recorrido un mill√≥n de veces, y esto no ha sido de inter√©s para nadie, porque de </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verdad Ni√±os</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la gente normal tiene </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MFC</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qt, solo me asegurar√≠a de que alg√∫n objeto funcional se pase a la clase de ventana. </font><font style="vertical-align: inherit;">No es dif√≠cil garantizar su transferencia a trav√©s de la cadena de herencia, pero har√° todo de manera simple, clara y sin distorsiones, y obtendr√° una clase predecible completamente normal sin efectos secundarios, que puede acompa√±ar y desarrollar para dar a absolutamente cualquier persona. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo que sucedi√≥ en este art√≠culo es solo una interesante tarea no trivial, que a√∫n logr√© resolver. </font><font style="vertical-align: inherit;">Espero que esto haya sido interesante para ti tambi√©n.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es507114/index.html">Oda Excel: 34 a√±os de magia</a></li>
<li><a href="../es507116/index.html">"Udalenka". Notas del desarrollador de la oficina de ayer. Parte 2</a></li>
<li><a href="../es507124/index.html">PDB no es solo piel valiosa</a></li>
<li><a href="../es507132/index.html">Vladimir Kitov: "¬°Es imposible entender c√≥mo los cient√≠ficos pioneros previeron la informatizaci√≥n universal en la d√©cada de 1950!"</a></li>
<li><a href="../es507138/index.html">La geolog√≠a del siglo XXI como la ciencia de datos de la Tierra</a></li>
<li><a href="../es507148/index.html">Enviar enlaces m√°gicos usando Node.js</a></li>
<li><a href="../es507150/index.html">Dibujamos una imagen de interferencia en JavaScript</a></li>
<li><a href="../fr486176/index.html">M√©mo de correspondance par e-mail d'entreprise</a></li>
<li><a href="../fr486178/index.html">FOSS News No. 1 - revue des nouvelles gratuites et open source du 27 janvier au 2 f√©vrier 2020</a></li>
<li><a href="../fr486180/index.html">Conseils et sources pour cr√©er des applications sans serveur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>