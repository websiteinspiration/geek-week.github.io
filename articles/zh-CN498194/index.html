<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🍳 🕵🏿 🗞️ 服务定位器-消除神话 🎑 👨🏿 👨🏻‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="令人惊讶的是，在一个平台的拥护者阵营中展示了一个平台表现出良好性能和可用性的实践。服务定位器（Service Locator）模式充分感受到了这种命运，该模式在.Net中非常流行，在iOS中声誉不佳。
 
 在某些文章中，ServiceLocator被忽略，称其为“自行车”。其他人则认为这是反模式。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>服务定位器-消除神话</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498194/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/q0/yb/tf/q0ybtf5xhq0ygzxuevhduuup9k0.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
令人惊讶的是，在一个平台的拥护者阵营中展示了一个平台表现出良好性能和可用性的实践。</font><font style="vertical-align: inherit;">服务定位器（Service Locator）模式充分感受到了这种命运，该模式在.Net中非常流行，在iOS中声誉不佳。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在某些文章中，ServiceLocator被忽略，称其为“自行车”。</font><font style="vertical-align: inherit;">其他人则认为这是反模式。</font><font style="vertical-align: inherit;">有些人试图通过描述定位器的正反两面来保持中立。</font><font style="vertical-align: inherit;">Habrahabr自己在很大程度上为这些迫害做出了贡献，其中包含几篇类似的参考文献。</font><font style="vertical-align: inherit;">每个遇到实施Latitude的新开发人员几乎都会立即被疏忽所感染-好吧，许多开发人员在没有客观原因的情况下也无法批评同一件事。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章</font></font></b>
                        <div class="spoiler_text"><ul>
<li>2010: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">https://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern</a>/</li>
<li>2015 :<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> https://habr.com/ru/company/rambler-co/blog/258325/</a></li>
<li>2015: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/ru/post/270005/</a></li>
<li>2016: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/ru/company/jugru/blog/300886/</a></li>
<li>2017: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/ru/company/badoo/blog/344506/</a></li>
<li>2018: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/ru/company/redmadrobot/blog/352088</a></li>
</ul><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
真的吗？用一个著名人物的话说：“你不喜欢猫吗？是的，你只是没有它们！”实际上，您是否尝试过吃无盐的肉？和生生？您不必费力找出吃什么猪肉是不好的，尤其是在星期五晚上。因此，使用服务定位器模式-原始信息的普及率越高-对其的偏见就越大。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c-/gf/0d/c-gf0dpfbeujk8--liho9lp_wwm.jpeg" align="left" width="300"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">泰特斯·卢克修蒂斯·卡尔（Titus Lucretius Car）是古代最伟大的思想家之一，尽管他的书《论事物的本质》的其余部分与公元前一世纪有关，但太阳仍然围绕地球旋转。从重力到核物理，已经做出了许多准确的科学预测。在不质疑权威力量的情况下，我们表明，使用适当长度的杠杆可以轻松地消除某些偏见。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，回顾一下服务定位符是什么以及它可以用于什么。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
服务是一个自治对象，在其内部封装了业务逻辑，并且可以具有指向其他对象的链接。实际上，任何类的实例都可以充当服务。很多时候，代替服务的概念，而是使用“经理”的概念。但是，常见的情况是静态类充当管理器，该管理器操作存储库数据。服务的实质是它是该类的实例，并具有随之而来的所有后果。这意味着它不能在真空中存在-在应用程序的生命周期中，必须具有与其连接的载体。这样的载体是服务定位器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用户（应用程序或开发人员）从服务定位器请求指定类型的服务，并接收准备使用的实例。与抽象工厂非常相似，对吗？不同之处在于，每次您从服务定位器请求指定类型的实例时，都会一次又一次收到相同的实例，该实例存储已使用的数据。服务看起来像一个典型的单例，但是事实并非如此。您可以根据需要创建任意数量的服务实例，并自行决定使用它们。同时，它们中的每一个都将封装您一生中发布在其中的数据。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/e0/yp/wf/e0ypwfrqeyyykocycqh6lz8gtjy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么这有必要？最明显和最受欢迎的示例是用户个人资料。如果您不使用UserSettings或CoreData形式的任何存储，则在应用程序的生存期内，您将必须保留指向UserProfile类实例的链接的某个位置，以便在应用程序的各个屏幕上使用它。此外，如果这样的实例不是单例，则必须将其从一种形式转移到另一种形式。当您在应用程序的某个开发周期中必须创建一个临时用户或一个独立的其他用户时，不可避免地会出现困难。 Sington立即成为瓶颈。而且，独立实例开始使应用程序逻辑过载，随着越来越多的对实例感兴趣的控制器的加入，其复杂度呈指数级增长。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hk/pm/yf/hkpmyf9gnih2yltehozvkdqdbew.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
服务定位器很好地解决了这个问题：如果您有一个抽象的UserProfile类，并且从类继承了特定的类DefaultUserPrifile和TemporatyUserProfile（使用一个完全空的实现，实际上是相同的），那么访问服务定位器将返回两个相同的独立对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定位器的另一个应用是通过一系列控制器传输数据实例：在第一个控制器上，创建（接收）对象并对其进行修改，最后，使用在第一个对象上输入的数据。如果控制器的数量很大并且位于堆栈上，那么使用委托来实现这些目的将非常困难。同样，通常在堆栈的根部需要显示最小化堆栈后立即在其顶部更改的信息（我们记住，堆栈喜欢删除在其副本中创建的所有实例）。但是，如果在堆栈的顶部获得了服务并对其进行了修改，然后启动了堆栈的折叠，则当根控制器对用户可用时，修改后的数据将被保存并可供显示。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般来说，如果您使用“ Coordinator”模式（如大多数教程中所述）（例如，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">here</font></a><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），则需要将其类的实例放置在AppDelegate中或将指向协调器的链接传递给所有将使用它。必要？为什么呢？</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/e0/yp/wf/e0ypwfrqeyyykocycqh6lz8gtjy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就我个人而言，我更喜欢AppDelegate保持整洁。</font><font style="vertical-align: inherit;">从ICoordinatable继承并设置协调器字段-不仅花费时间（众所周知，这相当于金钱），而且还剥夺了通过故事板进行人为声明式编程的可能性。</font><font style="vertical-align: inherit;">不，这不是我们的方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
优雅地创建协调器即服务会带来以下优点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您无需关心维护协调器的完整性；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协调器在整个应用程序中都可用，即使在那些不是从ICoordinatable继承的控制器中也是如此；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅在需要时才启动协调器。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以按任何顺序将协调器与情节提要一起使用（方便您使用）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将协调器与情节提要一起使用，可以创建不明显但有效的导航机制。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是协调器只是“导航器”模式的一半（使用路由器通过计算出的路径在应用程序中移动的机制）。</font><font style="vertical-align: inherit;">当实施时，复杂度增加了一个数量级。</font><font style="vertical-align: inherit;">导航器与服务定位器结合使用的功能-这是一个单独的主题。</font><font style="vertical-align: inherit;">让我们回到定位器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
导致服务定位器损坏的原因的客观原因包括其维护特定服务的复杂性以及无法控制定位器的内存状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建服务的传统机制是以下代码：</font></font><br>
<br>
<pre><code class="swift hljs">...
 <span class="hljs-type">ServiceLocator</span>.shared.addService(<span class="hljs-type">CurrentUserProvider</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">CurrentUserProviding</span>)<font></font>
...<font></font>
<span class="hljs-keyword">let</span> userProvider: <span class="hljs-type">UserProviding?</span> =  <span class="hljs-type">ServiceLocator</span>.shared.getService()
<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> provider =  userProvider <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
<span class="hljs-keyword">self</span>.user = provider.currentUser()
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
或像这样：</font></font><br>
<br>
<pre><code class="swift hljs">&nbsp;<span class="hljs-keyword">if</span> let_:<span class="hljs-type">ProfileService</span> = <span class="hljs-type">ServiceLocator</span>.service() {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">ServiceLocator</span>.addService(<span class="hljs-type">ProfileService</span>())<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; }<font></font>
&nbsp;<span class="hljs-keyword">let</span> service:<span class="hljs-type">ProfileService</span> = <span class="hljs-type">ServiceLocator</span>.service()!<font></font>
&nbsp; service.update(name: <span class="hljs-string">"MyName"</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他可怕吗？</font><font style="vertical-align: inherit;">首先，您需要注册服务，然后解压缩它才能使用它。</font><font style="vertical-align: inherit;">在第一种情况下，可以保证它在被请求时将存在。</font><font style="vertical-align: inherit;">但是第二个并没有在需要之前创建服务。</font><font style="vertical-align: inherit;">如果您需要在许多地方拉服务，那么选择的替代方法会让您发疯。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是将所有这些转换成这样的代码很容易：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">ProfileService</span>.service.update(name: <span class="hljs-string">"MyName"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里保证服务实例存在，因为如果不存在，则由服务本身创建。</font><font style="vertical-align: inherit;">没什么。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对该定位器的第二个要求显然是由于以下事实：使用C＃进行模式跟踪的开发人员会忘记垃圾收集器的工作，并且不会费心地提供从不必要的实例中清除定位器的能力，尽管这一点都不困难：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">ProfileService</span>.service.remove()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您不这样做，那么当您转到ProfileService.service（）时，我们将在应用程序中的任意位置获取一个先前已经使用过的服务的实例。但是，如果您确实要删除（），则在访问服务时，您将获得干净的副本。在某些情况下，您可以通过清除数据的预定义部分并继续使用同一实例来使方法成为clear（），而不是remove（）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该测试应用程序演示了两个服务的协调工作：用户配置文件和协调器。协调员不是本文的目的，而只是一个方便的示例。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d3/n5/pi/d3n5pivlyhibh_g6b9yoqrmpvpu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
视频显示，在字段中输入的值将传输到应用程序的每个后续屏幕。</font><font style="vertical-align: inherit;">然后在最后一个屏幕上，调用协调器，以便从第一个屏幕启动应用程序。</font><font style="vertical-align: inherit;">请注意，此处不会发生传统的导航堆栈折叠-将其完全从内存中推出，然后从其位置开始新的堆栈。</font><font style="vertical-align: inherit;">如果您注释掉删除个人资料服务的行，则用户名将被转移到第一个屏幕，就像我们最小化了导航堆栈一样。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">ProfileService</span>.service.remove()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
整个应用程序由两个视图控制器组成，并进行最少的准备工作。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/no/k_/sd/nok_sdvjddqny_nnk-v5te7tkhm.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
StartViewController：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> UIKit<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StartViewController</span>: <span class="hljs-title">UIViewController</span> </span>{<font></font>
<font></font>
&nbsp; &nbsp; <span class="hljs-meta">@IBOutlet</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> nameField: <span class="hljs-type">UITextField!</span><font></font>
<font></font>
&nbsp; &nbsp; <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">super</span>.viewDidLoad()
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">self</span>.nameField.text = <span class="hljs-type">ProfileService</span>.service.info.name<font></font>
&nbsp; &nbsp; }<font></font>
<font></font>
&nbsp; &nbsp; <span class="hljs-meta">@IBAction</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startAction</span><span class="hljs-params">(<span class="hljs-number">_</span> sender: UIButton)</span></span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">ProfileService</span>.service.update(name: <span class="hljs-keyword">self</span>.nameField.text ?? <span class="hljs-string">""</span>)
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">CoordinatorService</span>.service.coordinator.startPageController()<font></font>
&nbsp; &nbsp; }<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PageViewController：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> UIKit<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageViewController</span>: <span class="hljs-title">UIViewController</span> </span>{<font></font>
<font></font>
&nbsp; &nbsp; <span class="hljs-meta">@IBOutlet</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> nameLabel: <span class="hljs-type">UILabel!</span><font></font>
<font></font>
&nbsp; &nbsp; <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">super</span>.viewDidLoad()
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">self</span>.nameLabel.text = <span class="hljs-type">ProfileService</span>.service.info.name<font></font>
&nbsp; &nbsp; }<font></font>
<font></font>
<font></font>
&nbsp; &nbsp; <span class="hljs-meta">@IBAction</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">finishAction</span><span class="hljs-params">(<span class="hljs-number">_</span> sender: UIButton)</span></span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">ProfileService</span>.service.remove()
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">CoordinatorService</span>.service.coordinator.start()<font></font>
&nbsp; &nbsp; }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一个控制器中，在viewDidLoad（）方法中创建一个配置文件实例，并将用户名信息加载到输入字段中。在单击“登录”按钮后，服务数据将再次更新。之后，将强制转换到向导的第一页。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在向导内部，数据显示在屏幕上。但是该事件仅在情节提要的最后一个屏幕上绑定到按钮。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看起来可能很复杂？但是在过去的5年中，我不断遇到不了解其全部工作原理的开发人员。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，所有主要工作都在定位器和服务本身中进行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定位器：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> Foundation<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">IService</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> service: <span class="hljs-type">Self</span> {<span class="hljs-keyword">get</span>}<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span><font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">IServiceLocator</span> </span>{
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">service</span>&lt;T&gt;<span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">T?</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceLocator</span>: <span class="hljs-title">IServiceLocator</span> </span>{<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> instance = <span class="hljs-type">ServiceLocator</span>()
&nbsp; &nbsp; <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> services: [<span class="hljs-type">String</span>: <span class="hljs-type">Any</span>] = [:]<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-comment">// MARK: - Public methods</span>
&nbsp; &nbsp; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">func</span> <span class="hljs-title">service</span>&lt;<span class="hljs-title">T</span>&gt;() -&gt; <span class="hljs-title">T</span>? </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> instance.service()<font></font>
&nbsp; &nbsp; }<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">func</span> <span class="hljs-title">addService</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-title">_</span> <span class="hljs-title">service</span>: <span class="hljs-title">T</span>) </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> instance.addService(service)<font></font>
&nbsp; &nbsp; }<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">func</span> <span class="hljs-title">clear</span>() </span>{<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; instance.services.removeAll()<font></font>
&nbsp; &nbsp; }<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">func</span> <span class="hljs-title">removeService</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-title">_</span> <span class="hljs-title">service</span>: <span class="hljs-title">T</span>) </span>{<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; instance.removeService(service)<font></font>
&nbsp; &nbsp; }<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">service</span>&lt;T&gt;<span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">T?</span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> key = typeName(<span class="hljs-type">T</span>.<span class="hljs-keyword">self</span>)
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> services[key] <span class="hljs-keyword">as</span>? <span class="hljs-type">T</span><font></font>
&nbsp; &nbsp; }<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-comment">// MARK: - Private methods</span>
&nbsp; &nbsp; <span class="hljs-keyword">private</span> fun caddService&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-number">_</span> service: <span class="hljs-type">T</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> key = typeName(<span class="hljs-type">T</span>.<span class="hljs-keyword">self</span>)<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; services[key] = service<font></font>
&nbsp; &nbsp; }<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeService</span>&lt;T&gt;<span class="hljs-params">(<span class="hljs-number">_</span> service: T)</span></span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> key = typeName(<span class="hljs-type">T</span>.<span class="hljs-keyword">self</span>)<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; services.removeValue(forKey: key)<font></font>
&nbsp; &nbsp; }<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">typeName</span><span class="hljs-params">(<span class="hljs-number">_</span> some: <span class="hljs-keyword">Any</span>)</span></span> -&gt; <span class="hljs-type">String</span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> (some isAny.<span class="hljs-type">Type</span>) ? <span class="hljs-string">"\(some)"</span> : <span class="hljs-string">"\(type(of: some))"</span><font></font>
&nbsp; &nbsp; }<font></font>
}</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果仔细观察，您会发现可以通过以下操作清除整个定位器数据区域：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ServiceLocator.clear（）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
服务配置文件并不复杂：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> UIKit<font></font>
<font></font>
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileService</span>: <span class="hljs-title">IService</span> </span>{<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-keyword">private</span> (<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> info = <span class="hljs-type">ProfileInfo</span>()<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">var</span> <span class="hljs-title">service</span>: <span class="hljs-title">ProfileService</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> service: <span class="hljs-type">ProfileService</span> = <span class="hljs-type">ServiceLocator</span>.service() {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> service<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; }<font></font>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> service = <span class="hljs-type">ProfileService</span>()
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">ServiceLocator</span>.addService(service)
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> service<font></font>
&nbsp; &nbsp; }<font></font>
<font></font>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">self</span>.info = <span class="hljs-type">ProfileInfo</span>()<font></font>
&nbsp; &nbsp; }<font></font>
<font></font>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">ServiceLocator</span>.removeService(<span class="hljs-keyword">self</span>)<font></font>
&nbsp; &nbsp; }<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(name: String)</span></span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">self</span>.info.name = name<font></font>
&nbsp; &nbsp; }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProfileInfo</span> </span>{<font></font>
&nbsp; &nbsp; varname = <span class="hljs-string">""</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过在服务本身内部移动数据区域，可以进一步简化此操作。</font><font style="vertical-align: inherit;">但是以这种形式，数据模型和服务的责任范围变得很清楚。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于服务的工作，您可能需要执行一些准备操作，就像创建协调器服务一样。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> UIKit<font></font>
<font></font>
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoordinatorService</span>: <span class="hljs-title">IService</span> </span>{<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-keyword">private</span> (<span class="hljs-keyword">set</span>)<span class="hljs-keyword">var</span> coordinator: <span class="hljs-type">MainCoordinator!</span><font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-keyword">var</span> navController: <span class="hljs-type">UINavigationController</span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.coordinator.navigationController<font></font>
&nbsp; &nbsp; }<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">var</span> <span class="hljs-title">service</span>: <span class="hljs-title">CoordinatorService</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> service: <span class="hljs-type">CoordinatorService</span> = <span class="hljs-type">ServiceLocator</span>.service() {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> service<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; }<font></font>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> service = <span class="hljs-type">CoordinatorService</span>()<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; service.load()<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">ServiceLocator</span>.addService(service)
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> service<font></font>
&nbsp; &nbsp; }<font></font>
<font></font>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span> {<font></font>
&nbsp; &nbsp; }<font></font>
<font></font>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">ServiceLocator</span>.removeService(<span class="hljs-keyword">self</span>)<font></font>
&nbsp; &nbsp; }<font></font>
&nbsp;&nbsp; &nbsp;<font></font>
&nbsp; &nbsp; <span class="hljs-comment">// MARK - Private</span>
&nbsp; &nbsp; <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> nc&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = <span class="hljs-type">UINavigationController</span>()<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; nc.navigationBar.isHidden = <span class="hljs-literal">true</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">self</span>.coordinator&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = <span class="hljs-type">MainCoordinator</span>(navigationController:nc)<font></font>
&nbsp; &nbsp; }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，您可以看到在将服务放置在定位器中的时刻，创建了导航堆栈并将其传递给协调器类实例。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您使用的是iOS 13（显然在上面），那么请确保修改SceneDelegate类。</font><font style="vertical-align: inherit;">有必要确保执行以下代码：</font></font><br>
<br>
<pre><code class="swift hljs">&nbsp;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scene</span><span class="hljs-params">(<span class="hljs-number">_</span> scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)</span></span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> scene = (scene <span class="hljs-keyword">as</span>? <span class="hljs-type">UIWindowScene</span>) <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> window = <span class="hljs-type">UIWindow</span>(windowScene: scene)<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; window.rootViewController = <span class="hljs-type">CoordinatorService</span>.service.navController
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">self</span>.window = window
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">CoordinatorService</span>.service.coordinator.start()<font></font>
&nbsp; &nbsp; &nbsp; &nbsp; window.makeKeyAndVisible()<font></font>
&nbsp; &nbsp; }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们提取默认导航堆栈并将其与主应用程序窗口关联，然后使用StartViewController控制器打开应用程序启动窗口。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">测试用例</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
的源代码</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可在GitHub上找到</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN498174/index.html">如何停止担心并开始相信A / B测试</a></li>
<li><a href="../zh-CN498178/index.html">我们在家工作：照片传播</a></li>
<li><a href="../zh-CN498180/index.html">使用PVS-Studio静态分析器重新检查牛顿游戏动力学</a></li>
<li><a href="../zh-CN498186/index.html">基于神经网络的设计人员服务</a></li>
<li><a href="../zh-CN498192/index.html">类固醇化妆品袋：XD设计城市腰包审查</a></li>
<li><a href="../zh-CN498196/index.html">FunCorp正在寻找质量检查工程师：接受采访并在同一天收到报价</a></li>
<li><a href="../zh-CN498200/index.html">法规报告数据平台</a></li>
<li><a href="../zh-CN498202/index.html">登陆文摘。信息安全专员</a></li>
<li><a href="../zh-CN498206/index.html">在Golang上创建一个graphql后端</a></li>
<li><a href="../zh-CN498208/index.html">安全周17：Linux服务器攻击的影响</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>