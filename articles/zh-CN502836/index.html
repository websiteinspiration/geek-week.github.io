<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⬅️ 👨🏻‍🎤 👃🏼 Unity编辑器历险记：序列化的Matryoshka 🐡 🍤 🐼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="简短介绍
 通常，为了进入我们感兴趣的序列化属性领域，手动疗法建议我们使用FindPropertyRelative（）方法，在该方法中添加变量名。
 
 由于某些原因，这种方法并不总是很方便。原因可能非常多样。例如，变量的名称可以更改，我们需要对非序列化的属性进行流鼻血的访问，我们需要对getter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unity编辑器历险记：序列化的Matryoshka</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502836/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简短介绍</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，为了进入我们感兴趣的序列化属性领域，手动疗法建议我们使用FindPropertyRelative（）方法，在该方法中添加变量名。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于某些原因，这种方法并不总是很方便。原因可能非常多样。例如，变量的名称可以更改，我们需要对非序列化的属性进行流鼻血的访问，我们需要对getter-setter或什至是序列化对象的方法的访问。我们不会问“为什么您根本需要这个”和“为什么没有传统方式就不能做”的问题。假设我们需要-就是这样。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，让我们弄清楚如何从序列化属性中获取正在使用的对象及其所有父对象，而不会陷入充满陷阱的序列化道路上。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文意味着您已经知道如何使用UnityEditor，至少一次编写了自定义PropertyDrawers，并且至少通俗地了解了序列化属性与序列化对象的区别。</font></font><br>
<br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序列化路径</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，将所有点都放在O上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在最原始的情况下，我们有MonoBehaviour的某个继承人类别，并且它具有某个属于序列化类别的字段，显然不是A.K.A.神圣unit牛的继承人。</font><font style="vertical-align: inherit;">UnityEngine.Object。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExamplePulsar</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
...<font></font>
        [<span class="hljs-meta">Space</span>][Header(<span class="hljs-string">"Example Sandbox Inspector Field"</span>)]
        <span class="hljs-keyword">public</span> SandboxField sandboxField;<font></font>
...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在上面的代码中，SandboxField是具有Seri​​alizable属性的类。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要访问所有者的MonoBehaviour并不是问题：</font></font><br>
<br>
<pre><code class="cs hljs">UnityEngine.Object serializationRoot = property.serializedObject.targetObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您愿意，可以按as进行操作，但是现在我们不需要它了。</font><font style="vertical-align: inherit;">我们对序列化字段本身很感兴趣，以便使用所有二十一点来绘制它，如下图所示。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/-w/3n/th/-w3nthkn0gmcdeuvpqlw2zctxhy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以采用如下序列化路径：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">string</span> serializationPath = property.propertyPath;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的例子中，序列化路径将包含我们的一个字段，并将返回“ sandboxField”，从中我们既不冷也不热，因为对于第一层嵌套，我们只需要知道变量的名称（顺便说一下，变量的名称已返回给我们）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，途中没有父MonoBehaviour。</font><font style="vertical-align: inherit;">现在没关系，但是当我们开始拆卸看起来像这样的俄罗斯玩偶时，它将变得很重要：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nestedClassVariable.exampleSandboxesList.Array.data [0] .evenMoreNested.Array.data [0]</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了以后不会被捕获，在嵌套属性时，我们将提前执行​​以下操作：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">string</span>[] path = property.propertyPath.Split(<span class="hljs-string">'.'</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们有了序列化路径的所有节点。</font><font style="vertical-align: inherit;">但是在最原始的情况下，我们只需要零节点。</font><font style="vertical-align: inherit;">拿着：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">string</span> pathNode = path[<span class="hljs-number">0</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
打开一点反射，然后从这里获得视野：</font></font><br>
<br>
<pre><code class="cs hljs">Type objectType = serializationRoot.GetType();<font></font>
FieldInfo objectFieldInfo = objectType.GetField(pathNode);<font></font>
<span class="hljs-keyword">object</span> field = objectFieldInfo.GetValue(serializationRoot);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们把这个项目的速度问题抛之脑后。对于少量此类字段和少量嵌套，反射的成本将大大低于渲染期间UnityEditor进行的所有操作。如果您需要证明-在github上，Unity开发人员有一个有趣的东西，UnityCsReference，看看您的闲暇时间，例如ObjectField渲染的实现方式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，这</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还不是（哈哈）</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一切。我们有了这个领域，我们很高兴，我们可以用它做任何我们想做的事情，甚至尝试编写所有影响我们领域的所有按钮和重要动作的自定义UnityEvent，无论它挂在什么对象上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至少，虽然它挂在该对象的根部，但一切都会好起来的，但现在已经不那么多了。</font><font style="vertical-align: inherit;">在序列化的过程中，我们正在等待数组和各种列表，其主要目的是将我们放入拖鞋中，及时向上更改元素数量。</font><font style="vertical-align: inherit;">但是，对此，我们首先要在数组本身下进行挖掘。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的目标是抵抗这种玩偶</font></font></b>
                        <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/l7/do/h3/l7doh3b9j_da24zsw9rc-7xefjs.png"></div></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果序列化路径中没有数组，那么任务将变得微不足道：我们将遍历序列化节点，直到到达链的末端。</font><font style="vertical-align: inherit;">类似于以下代码：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">object</span> currentObject = serializationRoot;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; directSearchDepth; i++)<font></font>
{<font></font>
       <span class="hljs-keyword">string</span> pathNode = path[i];<font></font>
       Type objectType = currentObject.GetType();<font></font>
       FieldInfo objectFieldInfo = objectType.GetField(pathNode);<font></font>
       <span class="hljs-keyword">object</span> nextObject = objectFieldInfo.GetValue(currentObject);<font></font>
       currentObject = nextObject;<font></font>
}<font></font>
<span class="hljs-keyword">return</span> currentObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们正在等待两个令人不快的消息。</font><font style="vertical-align: inherit;">我将从第二个开始。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
采取nextObject的步骤可能突然返回null而不是预期的对象。</font><font style="vertical-align: inherit;">通常，这是在我们首先在检查器中创建父对象时发生的，并且序列化路径已经存在，但是相应的字段不存在（这将为我们带来更多便利）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，最好立即使用return null从方法中添加出口：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">object</span> nextObject = objectFieldInfo.GetValue(currentObject);
<span class="hljs-keyword">if</span> (nextObject == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
currentObject = nextObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“等一下！</font><font style="vertical-align: inherit;">- 你说。</font><font style="vertical-align: inherit;">“如果返回零，那么在OnGUI中该怎么办？” </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
答：没有。</font><font style="vertical-align: inherit;">没什么。</font><font style="vertical-align: inherit;">只需返回即可跳过此绘制步骤，等待创建字段。</font><font style="vertical-align: inherit;">一切都不会发生。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>(<span class="hljs-params">Rect position, SerializedProperty property, GUIContent label</span>)</span><font></font>
{<font></font>
       SandboxField sandboxField = GetTarget&lt;T&gt;(property);<font></font>
       <span class="hljs-keyword">if</span> (sandboxField == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<font></font>
…<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里的GetTarget（）是相应的函数，它从属性中获取序列化的对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说一句，我建议您不要将我们感兴趣的领域带入GetPropertyHeight中。如果我们根据内容编写不同大小的可折叠可扩展字段，则将需要此字段。 GetPropertyHeight（）在OnGUI（）之前被调用，因此，如果我们在此处获取一个字段并将其写入PropertyDrawer的字段中，则无需再次将其带到OnGUI。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，将单独创建自定义PropertyDrawer的实例以绘制所有当前可见的序列化属性，然后从上到下依次向其抛出新属性。应该考虑到这一点，以免影响下一个属性的高度的计算，否则，当您单击折叠并扩展期望的字段时，可能会遇到不愉快的情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，所有负责在编辑器中显示该字段并要进行序列化的金属丝，都应该在可序列化类（而不是PropertyDrawer）的一侧进行序列化，并且出于准确性的考虑，请附上条件编译括号，以免所有此类西班牙耻辱都不会尝试进行构建：</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SandboxField</span><font></font>
{<font></font>
…<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> UNITY_EDITOR</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> editorFoldout;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
…<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里等待着我们的另一个陷阱：通过编辑器创建的所有字段都想吐给类构造函数和类中指定的默认值。</font><font style="vertical-align: inherit;">例如，如果您这样做（例如，在我的项目中，它是水面节点的值）：</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">SerializeField</span>]<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m_nodesPerUnit = <span class="hljs-number">5</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将新项目添加到列表后，该值将被忽略。</font><font style="vertical-align: inherit;">调用构造函数来寻求帮助也无济于事：您在此处编写的所有内容都会被忽略。</font><font style="vertical-align: inherit;">新对象是一个像猎鹰一样的目标，它的所有值实际上都是默认值，不是您想要在其中看到的值，而是各种各样的null，false，0，Color.clear和其他淫秽的东西。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">肉拐杖</font></font></b>
                        <div class="spoiler_text">  .   NonUnitySerializableClass,       .      , DefaultEditorObject(),    . <br>
<br>
  - :<br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NonUnitySerializableClass</span><font></font>
{<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DefaultEditorObject</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-comment">// virtually do nothing</span><font></font>
        }<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> validated = <span class="hljs-literal">false</span>;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EditorCreated</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> force = <span class="hljs-literal">false</span></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (validated &amp;&amp; !force) <span class="hljs-keyword">return</span>;<font></font>
            DefaultEditorObject();<font></font>
            validated = <span class="hljs-literal">true</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NonUnitySerializableClass</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            EditorCreated(<span class="hljs-literal">true</span>);<font></font>
        }<font></font>
}</code></pre><br>
        DefaultEditorObject(),    ,   EditorCreated     .<br>
<br>
 :       .<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fg/dh/dr/fgdhdrfczfhhcki7dw6plxzj7vi.png"></div><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们回到绵羊，或者说数组。</font><font style="vertical-align: inherit;">在更早的阶段可能会出现的另一个问题是：</font></font><br>
<br>
<pre><code class="cs hljs">FieldInfo objectFieldInfo = objectType.GetField(pathNode);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果右侧遇到序列化路径中的数组，则右侧可以将我们返回零（并且任何“ IList”对象都将是“ Array”数组）。</font><font style="vertical-align: inherit;">不愉快。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该怎么办？</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编写处理程序，</font><s><font style="vertical-align: inherit;">尽量不要陷入这种情况</font></s><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pathNode.Length; i++)<font></font>
{<font></font>
        <span class="hljs-keyword">string</span> pathNode = path[i];<font></font>
        Type objectType = currentObject.GetType();<font></font>
        FieldInfo objectFieldInfo = objectType.GetField(pathNode);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (objectFieldInfo == <span class="hljs-literal">null</span>)<font></font>
        {<font></font>
                <span class="hljs-keyword">if</span> (pathNode == <span class="hljs-string">"Array"</span>)<font></font>
                {<font></font>
                        i++;<font></font>
                        <span class="hljs-keyword">string</span> nextNode = path[i];
                        <span class="hljs-keyword">string</span> idxstr = nextNode.Substring(nextNode.IndexOf(<span class="hljs-string">"["</span>) + <span class="hljs-number">1</span>);<font></font>
                        idxstr = idxstr.Replace(<span class="hljs-string">"]"</span>, <span class="hljs-string">""</span>);
                        <span class="hljs-keyword">int</span> arrayNumber = Convert.ToInt32(idxstr);<font></font>
                        IList collection = currentObject <span class="hljs-keyword">as</span> IList;
                        <span class="hljs-keyword">if</span> (collection.Count &lt;= arrayNumber) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
                        currentObject = collection[arrayNumber];<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span><font></font>
                {<font></font>
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(<span class="hljs-string">"   "</span>);<font></font>
                }<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-comment">//  ,     </span><font></font>
        {<font></font>
                <span class="hljs-keyword">object</span> nextObject = objectFieldInfo.GetValue(currentObject);
                <span class="hljs-keyword">if</span> (nextObject == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
                currentObject = nextObject;<font></font>
        }<font></font>
}<font></font>
<span class="hljs-keyword">return</span> currentObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的，当串行化路径已具有例如data [0]或data [1]元素，而数组尚未实现它时，我们甚至可以陷入一种不愉快的境地。</font><font style="vertical-align: inherit;">例如，我们创建了一个空列表。</font><font style="vertical-align: inherit;">我们问他N个元素-没有这个漂亮的线条：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">if</span> (collection.Count &lt;= arrayNumber) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...我们会收到很多异常的声音。</font><font style="vertical-align: inherit;">而所有需要做的就是跳过渲染步骤，直到创建了我们感兴趣的字段。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我还没有遇到objectFieldInfo == null的其他情况，但是未将序列化节点指定为Array，因此在这种假设的特殊情况下抛出可怕的异常是随后对其进行破解。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，我们有一个或多或少的工作函数，使我们能够通过其序列化属性提取字段。</font><font style="vertical-align: inherit;">将来，可以通过强制提取序列化路径中的所有对象以及搜索最接近的“父对象”（包括或排除沿该路径的数组）来修改此功能。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生活黑客绘制嵌套属性</font></font></b>
                        <div class="spoiler_text">      -  ,   Rect position  Rect indentedPosition = EditorGUI.IndentedRect(position).     ,         EditorGUI,      position ,       GUI –    indentedPosition.   EditorGUILayout  OnGUI,       (   ,   ).<br>
<br>
    ,   MonoScript   (     -,   ),     static-,      AssetDatabase,        <i></i>         .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
谢谢您的关注。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN502818/index.html">Y Messenger：区块链上的分散Messenger *</a></li>
<li><a href="../zh-CN502826/index.html">3D Creaform MetraSCAN 3D扫描仪概述</a></li>
<li><a href="../zh-CN502830/index.html">在线黑客马拉松“ New Reality” VirusHack。它怎么样</a></li>
<li><a href="../zh-CN502832/index.html">在线提供ISTQB认证：个人经验</a></li>
<li><a href="../zh-CN502834/index.html">如何在六个月甚至更快的时间内成为一名DevOps工程师。第5部分。部署</a></li>
<li><a href="../zh-CN502838/index.html">IT和数字职业之间的区别是：数字化转型和专家意见</a></li>
<li><a href="../zh-CN502840/index.html">闪亮的3D EinScan Pro 2X Plus 3D扫描仪评论</a></li>
<li><a href="../zh-CN502842/index.html">如何保护用户生物特征数据免受犯罪使用</a></li>
<li><a href="../zh-CN502844/index.html">[第2/2部分] FFmpeg和SDL指南或如何编写少于1000行的视频播放器</a></li>
<li><a href="../zh-CN502846/index.html">扎克伯格开设了商店。Instagram和Facebook逐渐成为商店。</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>