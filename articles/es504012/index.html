<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📔 🕺🏼 🤰🏽 Ordenar invertido 👧🏼 👨🏽‍🌾 👎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un programador de la India muestra claramente Zig-Zag, Zig-Zig y Zig utilizados en el algoritmo SplaySort:
 
 
 Esta temporada estamos explorando una ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Ordenar invertido</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/504012/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un programador de la India muestra claramente Zig-Zag, Zig-Zig y Zig utilizados en el algoritmo SplaySort:</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><div style="text-align:center;"><img width="780" height="590" src="https://habrastorage.org/webt/0j/qa/l0/0jqal0merugvc0u93nolsk_l0i0.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta temporada estamos explorando una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variedad de montones y cómo se pueden usar para la clasificación</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sin embargo, esta vez nos alejaremos del tema principal. </font><font style="vertical-align: inherit;">La estructura actual, el árbol de separación, no es un montón. </font><font style="vertical-align: inherit;">Pero lo necesitamos para prepararnos mentalmente para el estudio de la próxima pila: la próxima semana habrá una conferencia sobre la clasificación por un árbol cartesiano.</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="Software EDISON - desarrollo web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Software EDISON - desarrollo web"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artículo fue preparado con el apoyo de EDISON. </font><font style="vertical-align: inherit;">
Una de las direcciones de nuestra actividad es la </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">automatización de mediciones y sistemas expertos</font></a><font style="vertical-align: inherit;"> , por lo que llevamos a cabo proyectos de alta tecnología utilizando un enfoque científico estricto. </font><font style="vertical-align: inherit;">
¡Amamos la informática! </font><font style="vertical-align: inherit;">;-)</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img align="right" width="340" height="228" src="https://habrastorage.org/webt/y8/hs/tt/y8hsttfexnxawirmy1ysw7rg-3q.png"></a><br clear="left"><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><div style="text-align:center;"><img width="770" height="1" src="https://habrastorage.org/webt/mw/wy/cu/mwwycuqpta7m96dxifyx9if7mu8.gif"></div></blockquote><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Árbol de búsqueda binaria</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Splay Tree es un árbol de búsqueda binario mejorado. </font><font style="vertical-align: inherit;">Primero, recordemos cómo ordenar usando el árbol binario "no mejorado" habitual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como bien sabe, en un árbol binario, cualquier hijo izquierdo es menor que el padre, cualquier hijo derecho no es menor (es decir, mayor o igual) que el padre.</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="511" src="https://habrastorage.org/webt/2e/ie/2b/2eie2b53zaztn8ixd0wgqf5hlqu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La clasificación es generalmente sencilla:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 1. Basado en la matriz, construya un árbol de búsqueda binario. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ponemos el primer elemento de la matriz en la raíz, primero comparamos los elementos restantes con la raíz, luego, según la comparación, nos movemos hacia abajo de las ramas izquierda o derecha (y en el camino comparamos el elemento de la matriz con los nodos de árbol existentes). </font><font style="vertical-align: inherit;">Al final, el siguiente elemento llega al final de una rama y se convierte en un nodo en sí mismo.</font></font></li>
<li><b> 2.         .</b>   ,      (    ,       )            .          .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La construcción de un árbol es bastante tolerable en términos de complejidad algorítmica: en promedio, insertar un nuevo nodo cuesta </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por lo que la complejidad temporal de la primera etapa es </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero en la segunda etapa, no todo es tan color de rosa. </font><font style="vertical-align: inherit;">Un paseo recursivo por el árbol puede convertirse fácilmente en un largo viaje a través de un laberinto extremadamente sinuoso, y la complejidad del tiempo a menudo se degrada a </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></b><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Árbol de separación</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver este problema, solo hace unos 35-37 años, dos científicos científicos Robert Tarjan y Daniel Slitor desarrollaron esta estructura de árbol. Sugirieron que para cualquier operación (insertar, buscar, eliminar) con cualquier nodo de árbol, reequilibre inmediatamente el árbol, haciendo que el nodo sea la raíz de toda la estructura.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><div style="text-align:center;"><img width="780" height="313" src="https://habrastorage.org/webt/8s/vj/ac/8svjacb-n4jgxpjbbaxjv-fh-h0.jpeg"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la foto de la izquierda está Robert Tarjan (primera fila, segunda a la derecha) en compañía del Matrix Architect e inventor de Pascal. </font><font style="vertical-align: inherit;">En la foto de la derecha está Daniel Slitor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al hacer clic en la imagen, se abrirá una versión de formato completo. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ruso, el nombre fallido "árbol en expansión" se pegó, con menos frecuencia, "árbol oblicuo". </font><font style="vertical-align: inherit;">Aunque si simplemente se tradujera literalmente, entonces el "árbol expandido" (o, mejor aún, "convertido") suena bien y refleja con mayor precisión la esencia de esta estructura algorítmica. </font><font style="vertical-align: inherit;">Pero eso es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para empujar el nodo a la raíz, se utilizan operaciones simples especiales, los llamados giros:</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Giro en zig</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el elemento que desea hacer una raíz está en el segundo nivel de anidamiento, entonces todo es extremadamente simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denotamos este elemento como </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y su padre (que es también la raíz del árbol) - como el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son subárboles. ¿Cuánto hay en estos subárboles nodos no importa, sólo está interesado en las raíces de estos subárboles que tienen relaciones "padre-hijo" con </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si falta alguno de los subárboles (es decir, si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no tienen descendientes), esto no afecta el orden de las acciones.</font></font><br>
<br>
<div style="text-align:center;"><img width="450" height="208" src="https://habrastorage.org/webt/v3/kg/i0/v3kgi01dbf_nluirdgnsaylmn6y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> raíz del árbol, debe revertir la relación padre-hijo entre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y también superar al subárbol </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : fue el descendiente derecho de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , se convirtió en el descendiente izquierdo de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><font style="vertical-align: inherit;">no necesita hacer nada </font><font style="vertical-align: inherit;">con </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Y es todo! </font><font style="vertical-align: inherit;">Como resultado de estas manipulaciones simples, la estructura, como era un árbol de búsqueda binario, permaneció igual: el principio "el niño izquierdo es menor que el padre, el niño derecho es mayor o igual que el padre" no se violará en ninguna parte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La imagen anterior </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un descendiente izquierda de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> era un descendiente correcto, solo necesitas reflejar la situación: </font></font><br>
<br>
<div style="text-align:center;"><img width="450" height="208" src="https://habrastorage.org/webt/em/n6/z9/emn6z9kik0em1i03xpc5k7egrkq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no tiene el segundo nivel de dificultad, sino el tercero, entonces todo es más complicado, pero no mucho. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiene un padre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que a su vez tiene un padre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , entonces tenemos solo dos situaciones diferentes: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descendiente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font></b><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">en el mismo lado</font></i><font style="vertical-align: inherit;"> que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descendientes versátiles</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para sus padres. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, considere el primer caso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZigZig Turn</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deje que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sea ​​el descendiente izquierdo para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P el</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> descendiente izquierdo para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (la opción cuando </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son simultáneamente descendientes derechos se resuelve de manera similar).</font></font><br>
<br>
<div style="text-align:center;"><img width="770" height="251" src="https://habrastorage.org/webt/sh/f3/ev/shf3evyiypukr9y08kvtiidhrvy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se puede ver, es necesario cambiar la relación entre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , así como compensar adecuadamente subárboles </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Y nuestro árbol de búsqueda binario no sufrirá esto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Giro en zigzag</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X es el</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> descendiente correcto, y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P está a la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> izquierda (o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X está a la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> izquierda, y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P está a la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> derecha, no la esencia), entonces espero que ya entiendas todo de esta imagen:</font></font><br>
<br>
<div style="text-align:center;"><img width="642" height="251" src="https://habrastorage.org/webt/rz/v1/p2/rzv1p25jwly-sz6lrv_o2alzlyc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el árbol todavía está en un nivel inferior de anidación, entonces para elevarlo, debe aplicar ZigZig o ZigZag (si es necesario, hacer esto varias veces) a ese padre en la rama, que está en el tercer nivel de anidación.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordenar Invertir :: Ordenar Splay</font></font></h2><img align="right" width="396" height="590" src="https://habrastorage.org/webt/ig/xb/3c/igxb3c-v8_la--ej_irmsze7dai.gif"><br clear="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En realidad, aquí realizamos los mismos puntos que en la clasificación de árboles: primero construimos un árbol de clasificación binario, luego lo rodeamos. Pero cada vez que insertamos un nuevo nudo en el árbol, usando crestas y zags, lo convertimos en la raíz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la primera etapa de ganar, esto no da, la inserción de un nodo (teniendo en cuenta que tiene que zigzaguear para convertirlo en raíz) cuesta en promedio </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y por lo tanto la complejidad de esta etapa es </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, como resultado, se producen transformaciones sorprendentes con el árbol: se endereza y se mantiene en un estado tan enderezado todo el tiempo. Y esto acelera decisivamente la segunda etapa (transversal del árbol), ya que la escalera final resultante se procesa con complejidad O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, la complejidad total del algoritmo (peor, medio, mejor) en el tiempo es </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la práctica, esta clasificación es más lenta que MergeSort, QuickSort y otros HeapSort, pero demuestra claramente cómo puede acelerar las operaciones con el árbol de búsqueda binario.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La moraleja de esta fábula es la siguiente: si tienes que lidiar con un árbol de búsqueda binario, si es posible, haz que se equilibre. </font><font style="vertical-align: inherit;">Como una opción posible, trabaje con él como con un árbol de despliegue, es decir </font><font style="vertical-align: inherit;">En cualquier acción con cualquier nodo en el árbol, haga que este nodo sea la raíz. </font><font style="vertical-align: inherit;">Por supuesto, hay otros árboles de búsqueda alternativos de equilibrio automático (árbol rojo-negro, árbol AVL, etc.), que pueden ser más preferibles.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código C</font></font></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no parecer nervioso</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">/*
 *------------------------------------------------------------
 *
 *      File..........: $RCSfile: splaysort.c,v $
 *      Revision......: $Revision: 1.2 $
 *      Author........: Gary Eddy (gary@cs.mu.OZ.AU)
 *			Alistair Moffat (alistair@cs.mu.OZ.AU)
 *      Date..........: $Date: 1995/09/07 06:19:17 $
 *
 *	Description:
 *		Sorts by repeated insertion into a splay tree.
 *		Insertions are done top down
 *
 *------------------------------------------------------------
 */</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>	<span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>	<span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>	<span class="hljs-meta-string">&lt;malloc.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>	<span class="hljs-meta-string">&lt;alloca.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">char</span>	*sort_name = <span class="hljs-string">"Splaysort"</span>;
<span class="hljs-keyword">char</span>	*sort_version = <span class="hljs-string">"$Revision: 1.2 $"</span>;<font></font>
<font></font>
<span class="hljs-comment">/*
** Define DATAPTR for the 12 byte per record version of the program.
** Otherwise only 8 extra bytes per record are used and data
** references are done by indexing the data array.
** Different compiler/architecture combinations can cause wild
** variation in the ratio of speeds between these variations.
*/</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DATAPTR</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DATAPTR</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DATA(p) ((p)-&gt;data)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DATA(p) (A+size*(p-T))</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-comment">/*
** With the fast copy option enabled a more intelligent copy is used
** depending on the size of the items being copied.
** This approach adopted from the nqsort program of Bentley and McIlroy,
** see Software Practice and Experience, v23, n11, November 1993, 1249-65.
*/</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTCOPY</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> FASTCOPY</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> COPYCODE(TYPE, parmi, parmj, n) { \
        long i = (n) / sizeof (TYPE); \
        register TYPE *pi = (TYPE *) (parmi); \
        register TYPE *pj = (TYPE *) (parmj); \
        do { \
                *pi++ = *pj++;                    \
        } while (--i &gt; 0);      \
}</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">copyfunc</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *d, <span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> copytype)</span>
</span>{
        <span class="hljs-keyword">if</span>(copytype &lt;= <span class="hljs-number">1</span>)<font></font>
                COPYCODE(<span class="hljs-keyword">long</span>, d, s, size)
        <span class="hljs-keyword">else</span>
                COPYCODE(<span class="hljs-keyword">char</span>, d, s, size)
	<span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> COPY(d,s,size) \
        <span class="hljs-meta-keyword">if</span> (copytype == 0) { \
                *(long *)(d) = *(long *)(s); \
        } <span class="hljs-meta-keyword">else</span> \
                copyfunc(d, s, size, copytype)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> COPY(d,s,size)	memcpy(d,s,size)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">node_rec</span> <span class="hljs-title">node</span>;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span>	<span class="hljs-title">node_rec</span> {</span><font></font>
	node	*left, *rght;<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DATAPTR</span>
	<span class="hljs-keyword">char</span>	*data;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/*
 *	sort():
 *		The entire sort code 
 *
 *	Accesses outside variables:	none
 *
 *	Return value...:		none
 */</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *A, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> (*cmp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *))</span>
</span>{
	<span class="hljs-keyword">register</span> node *next, *curr, *prnt;
	<span class="hljs-keyword">char</span> 	*item;<font></font>
	node	*l, *r, *ch;<font></font>
	node	root, *T, *<span class="hljs-keyword">new</span>, *end, *move;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DATAPTR</span>
	<span class="hljs-keyword">char</span>	*p;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-comment">/*
** Determine which copying method will be used.
*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> FASTCOPY</span>
	<span class="hljs-keyword">int</span>	copytype=((<span class="hljs-keyword">char</span> *)A - (<span class="hljs-keyword">char</span> *)<span class="hljs-number">0</span>) % <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>) ||<font></font>
		size % <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>) ? <span class="hljs-number">2</span> : size == <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>)
		<span class="hljs-keyword">return</span>;
	<span class="hljs-keyword">if</span>((T = <span class="hljs-keyword">new</span> = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*T)*n)) == <span class="hljs-literal">NULL</span>) {
		<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't allocate space for structure\n"</span>);<font></font>
	}<font></font>
	<span class="hljs-comment">/* 
	** Do the first insertion manually to avoid the empty tree
	** case in the main loop.
	*/</span>
	curr = <span class="hljs-keyword">new</span>++;<font></font>
	item = A;<font></font>
	curr-&gt;left = curr-&gt;rght = <span class="hljs-literal">NULL</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DATAPTR</span><font></font>
	curr-&gt;data = item;<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
	item += size;<font></font>
	end = T+n;<font></font>
	<span class="hljs-comment">/*
	** For each item move down the tree dividing it into
	** two subtrees, one containing items less than the new
	** element and the other those which are greater.
	** The pointers l and r refer to the greatest element in the
	** smaller subtree and the smallest element in the large
	** subtree respectively. During the splitting of the tree
	** l and r retain children that may be incorrect in the final
	** tree but these false links are cut at the end of the
	** insertion.
	*/</span><font></font>
<font></font>
	<span class="hljs-keyword">for</span>( ; <span class="hljs-keyword">new</span>&lt;end; ) {<font></font>
		l = r = &amp;root;<font></font>
		<span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">NULL</span>) {
			<span class="hljs-keyword">if</span>(cmp(item, DATA(curr)) &lt; <span class="hljs-number">0</span>) {
				<span class="hljs-comment">/* Left root case */</span>
				<span class="hljs-keyword">if</span>((ch = curr-&gt;left) == <span class="hljs-literal">NULL</span>) {<font></font>
					r = r-&gt;left = curr;<font></font>
					<span class="hljs-keyword">break</span>;<font></font>
				}<font></font>
				<span class="hljs-comment">/* Left zig-zig */</span>
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp(item, DATA(ch)) &lt; <span class="hljs-number">0</span>) {<font></font>
					curr-&gt;left = ch-&gt;rght;<font></font>
					ch-&gt;rght = curr;<font></font>
					r = r-&gt;left = ch;<font></font>
					curr = ch-&gt;left;<font></font>
				}<font></font>
				<span class="hljs-comment">/* Left zig-zag */</span>
				<span class="hljs-keyword">else</span> {<font></font>
					r = r-&gt;left = curr;<font></font>
					l = l-&gt;rght = ch;<font></font>
					curr = ch-&gt;rght;<font></font>
				}<font></font>
			}<font></font>
			<span class="hljs-keyword">else</span> {
				<span class="hljs-comment">/* Right root case */</span>
				<span class="hljs-keyword">if</span>((ch = curr-&gt;rght) == <span class="hljs-literal">NULL</span>) {<font></font>
					l = l-&gt;rght = curr;<font></font>
					<span class="hljs-keyword">break</span>;<font></font>
				}<font></font>
				<span class="hljs-comment">/* Right zig-zag */</span>
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp(item, DATA(ch)) &lt; <span class="hljs-number">0</span>) {<font></font>
					l = l-&gt;rght = curr;<font></font>
					r = r-&gt;left = ch;<font></font>
					curr = ch-&gt;left;<font></font>
				}<font></font>
				<span class="hljs-comment">/* Right zig-zig */</span>
				<span class="hljs-keyword">else</span> {<font></font>
					curr-&gt;rght = ch-&gt;left;<font></font>
					ch-&gt;left = curr;<font></font>
					l = l-&gt;rght = ch;<font></font>
					curr = ch-&gt;rght;<font></font>
				}<font></font>
			}<font></font>
		}<font></font>
		<span class="hljs-comment">/* Cut false links */</span>
		r-&gt;left = l-&gt;rght = <span class="hljs-literal">NULL</span>;
		<span class="hljs-keyword">new</span>-&gt;rght = root.left;
		<span class="hljs-keyword">new</span>-&gt;left = root.rght;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DATAPTR</span>
		<span class="hljs-keyword">new</span>-&gt;data = item;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
		curr = <span class="hljs-keyword">new</span>++;<font></font>
		item += size;<font></font>
	}<font></font>
	<span class="hljs-comment">/* Now copy all of the data back into the input array.
	** Uses an iterative destructive inorder traversal.
	** Last item inserted is the current root.
	*/</span>
	prnt = <span class="hljs-literal">NULL</span>;<font></font>
	move = T;<font></font>
	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
		<span class="hljs-keyword">if</span> ((next = curr-&gt;left) != <span class="hljs-literal">NULL</span>) {
			<span class="hljs-comment">/* left subtree exists */</span><font></font>
			curr-&gt;left = prnt;<font></font>
			prnt = curr;<font></font>
			curr = next;<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span> {<font></font>
			next = curr-&gt;rght;<font></font>
			curr-&gt;rght = move++;<font></font>
			<span class="hljs-keyword">if</span> (next != <span class="hljs-literal">NULL</span>) {
				<span class="hljs-comment">/* and arrange for a visit */</span>
				<span class="hljs-keyword">if</span>((curr = next-&gt;left) != <span class="hljs-literal">NULL</span>) {<font></font>
					next-&gt;left = prnt;<font></font>
					prnt = next;<font></font>
					<span class="hljs-keyword">continue</span>;<font></font>
				}<font></font>
				<span class="hljs-keyword">else</span> {<font></font>
					curr = next;<font></font>
					<span class="hljs-keyword">continue</span>;<font></font>
				}<font></font>
			}<font></font>
			<span class="hljs-comment">/* no right subtree either, turn around*/</span>
			<span class="hljs-keyword">if</span> (prnt != <span class="hljs-literal">NULL</span>) {<font></font>
				curr = prnt;<font></font>
				prnt = prnt-&gt;left;<font></font>
				curr-&gt;left = <span class="hljs-literal">NULL</span>;
				<span class="hljs-keyword">continue</span>;<font></font>
			}<font></font>
			<span class="hljs-comment">/* nothing left to be done */</span>
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
	}<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DATAPTR</span>
	<span class="hljs-comment">/*
	** Change the goes-to array in rght to a comes_from in left.
	** Note the kludge on pointers, where left points into the 
	** character array containing the elements.
	*/</span>
	<span class="hljs-keyword">for</span>(next = T, p = A; next &lt; end; p += size, next++)<font></font>
		next-&gt;rght-&gt;left = (node *)p;<font></font>
	<span class="hljs-comment">/* and use the `comes from' array to unscramble the permutation */</span>
	item = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(size);
        <span class="hljs-keyword">for</span> (next=T; next&lt;end; next++) {
                <span class="hljs-keyword">char</span> *datacurr, *dataleftcurr, *<span class="hljs-keyword">final</span>;
                <span class="hljs-keyword">if</span> (next-&gt;left == <span class="hljs-literal">NULL</span>)
                        <span class="hljs-keyword">continue</span>;<font></font>
                curr = next;<font></font>
                <span class="hljs-keyword">final</span> = datacurr = DATA(curr);<font></font>
                COPY(item, datacurr, size);<font></font>
                <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">char</span> *)(curr-&gt;left) != <span class="hljs-keyword">final</span>) {<font></font>
                        dataleftcurr = (<span class="hljs-keyword">char</span> *)(curr-&gt;left);<font></font>
                        COPY(datacurr, dataleftcurr, size);<font></font>
                        prnt = curr;<font></font>
                        curr = T + (((<span class="hljs-keyword">char</span> *)(curr-&gt;left)-A)/size);<font></font>
                        prnt-&gt;left = <span class="hljs-literal">NULL</span>;<font></font>
                        datacurr = dataleftcurr;<font></font>
                }<font></font>
                COPY(datacurr, item, size);<font></font>
                curr-&gt;left = <span class="hljs-literal">NULL</span>;<font></font>
        }<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
	<span class="hljs-comment">/* Change the goes-to array in rght to a comes_from in left */</span>
	<span class="hljs-keyword">for</span>(next = T; next &lt; end; next++)<font></font>
		next-&gt;rght-&gt;left = next;<font></font>
	<span class="hljs-comment">/* and use the `comes from' array to unscramble the permutation */</span>
	<span class="hljs-comment">/*
	** This 12 byte version uses the presence of the data pointer
	** by making it the flag for already placed items. This means
	** that left pointers can point to nodes, eliminating the
	** calculation to find the next node.
	*/</span>
	item = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(size);
	<span class="hljs-keyword">for</span> (next=T; next&lt;end; next++) {
		<span class="hljs-keyword">char</span> *datacurr, *dataleftcurr, *<span class="hljs-keyword">final</span>;
		<span class="hljs-comment">/* second condition guarantees at least one iteration
		** of while loop.
		*/</span>
		<span class="hljs-keyword">if</span> (DATA(next) == (<span class="hljs-keyword">char</span> *) <span class="hljs-literal">NULL</span> || next-&gt;left == next)
			<span class="hljs-keyword">continue</span>;
		<span class="hljs-keyword">final</span> = datacurr = DATA(next);<font></font>
		curr = next-&gt;left;<font></font>
		COPY(item, datacurr, size);<font></font>
		<span class="hljs-keyword">while</span> ((dataleftcurr = DATA(curr)) != <span class="hljs-keyword">final</span>) {<font></font>
			COPY(datacurr, dataleftcurr, size);<font></font>
			prnt = curr;<font></font>
			curr = curr-&gt;left;<font></font>
			DATA(prnt) = (<span class="hljs-keyword">char</span> *) <span class="hljs-literal">NULL</span>;<font></font>
			datacurr = dataleftcurr;<font></font>
		}<font></font>
		COPY(datacurr, item, size);<font></font>
		DATA(curr) = (<span class="hljs-keyword">char</span> *) <span class="hljs-literal">NULL</span>;<font></font>
	}<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	<span class="hljs-built_in">free</span>(item);
	<span class="hljs-built_in">free</span>(T);<font></font>
} <span class="hljs-comment">/* sort() */</span></code></pre></div>
                    </div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trailer de la próxima serie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y volvemos a los montones. </font><font style="vertical-align: inherit;">La próxima cosita será más interesante que la que examinamos hoy. </font><font style="vertical-align: inherit;">Este híbrido es una estructura de datos en forma de árbol que es tanto un árbol de búsqueda dinámico como binario.</font></font><br>
<br>
<img height="498" src="https://habrastorage.org/webt/gf/96/5w/gf965wv0ih9ugz1ur98ywqe4oaq.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referencias</font></font></h2><br>
 <img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Árbol de búsqueda binaria</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">árbol </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/jw/w-/qu/jww-queszzqnwmoa2hm-kfwu-9o.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Splay Árboles Splay</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artículos de la serie:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplicación Excel AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clases de intercambio</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clases de inserción</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliotecario Ordenar</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solitario Ordenar</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordenar "Torre de Hanoi"</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordenar invertido</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Joven mesa de clasificación</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordenar por selección</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combinar clasificaciones</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordenar por distribución</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clasificación híbrida</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ordenar agregado a AlgoLab. </font><font style="vertical-align: inherit;">Entonces, si actualiza el archivo de Excel con macros, puede alterar personalmente el árbol de búsqueda binario.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es503998/index.html">Datos de todos los países, no unir</a></li>
<li><a href="../es504000/index.html">Mikrosha Capitulo dos ROM y BSVV</a></li>
<li><a href="../es504002/index.html">Cómo usar Yandex.Wordstat para publicidad contextual [guía detallada]</a></li>
<li><a href="../es504006/index.html">Seis maneras de acelerar significativamente los pandas con un par de líneas de código. Parte 2</a></li>
<li><a href="../es504008/index.html">¿Qué es un algoritmo? Parte uno</a></li>
<li><a href="../es504014/index.html">Los anglicismos capturan el idioma ruso: por qué sucede esto</a></li>
<li><a href="../es504016/index.html">El atractivo del estoicismo para los ricos e influyentes.</a></li>
<li><a href="../es504022/index.html">Especialista en Seguridad de la Información. Qué gana y cuánto gana</a></li>
<li><a href="../es504026/index.html">¿Por qué está tan obsesionado Silicon Valley con la virtud del sufrimiento?</a></li>
<li><a href="../es504030/index.html">La historia de cómo configuré Azure AD B2C en React and React Native Part 2 (Tutorial)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>