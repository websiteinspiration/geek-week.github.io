<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏽 🏇🏽 👨🏾‍🔬 Nuevas características de TypeScript para una usabilidad mejorada 🆘 ❕ 👩🏽‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TypeScript, en muchos aspectos, ya no es más como un lenguaje de programación, sino una herramienta poderosa para alinear y documentar código que lo a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Nuevas características de TypeScript para una usabilidad mejorada</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/493712/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScript, en muchos aspectos, ya no es más como un lenguaje de programación, sino una herramienta poderosa para alinear y documentar código que lo ayuda a escribir mejores programas JavaScript.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una de las fortalezas más notables de TypeScript es su soporte para algunas de las últimas características descritas en la especificación ECMAScript. Cuando un desarrollador actualiza a una nueva versión de TypeScript, significa que tiene nuevas funciones de JavaScript. Además, el uso de estas características no significa posibles problemas de compatibilidad. TypeScript, además de presentar las últimas funciones de JavaScript, también es notable por el hecho de que los creadores del lenguaje constantemente presentan algo nuevo a la comunidad de programadores de TS, diseñado para aumentar la usabilidad. Esto incluye, por ejemplo, herramientas auxiliares para la refactorización de código, herramientas para renombrar entidades y para encontrar lugares donde se usan en programas.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ik/dc/io/ikdcio3bkdkuvgg4h-lplk9lvpm.jpeg"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El material, cuya traducción publicamos hoy, analizará algunas características nuevas e interesantes de TypeScript. </font><font style="vertical-align: inherit;">Para obtener una lista completa de las innovaciones de TypeScript, eche un vistazo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objetos y matrices inmutables</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer que las matrices utilizadas en forma de variables ordinarias y parámetros de función sean inmutables durante la compilación, puede usar tipos auxiliares </font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font><font style="vertical-align: inherit;">en TypeScript </font></font><code>ReadonlyArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sin embargo, su uso puede causar una sensación de heterogeneidad en la anotación de tipo, especialmente al declarar matrices que usan caracteres </font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">después de especificar un tipo. </font><font style="vertical-align: inherit;">TypeScript 3.4 presenta una nueva forma de etiquetar parámetros que son matrices de solo lectura. </font><font style="vertical-align: inherit;">Inmediatamente apareció una nueva forma de declarar variables que deberían ser inmutables.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mejora de la usabilidad con parámetros de solo lectura</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al declarar los parámetros de las funciones con las que necesita trabajar como matrices de solo lectura, ahora puede usar la palabra clave </font></font><code>readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En el siguiente ejemplo, las firmas de los dos métodos son idénticas:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">s: ReadonlyArray&lt;string&gt;</span>) </span>{ <span class="hljs-comment">/* ... */</span> }<font></font>
&nbsp;<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">s: readonly string[]</span>) </span>{ <span class="hljs-comment">/* ... */</span> }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ambos casos, cualquier intento de modificar la matriz (por ejemplo, usando su método </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dará como resultado un error. </font><font style="vertical-align: inherit;">Esta innovación elimina la necesidad de un tipo genérico auxiliar, lo que significa que el código es más fácil de leer. </font><font style="vertical-align: inherit;">Los tipos de objetos también se pueden etiquetar como entidades de solo lectura, pero aún necesitan un tipo auxiliar </font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mejora de la usabilidad de variables inmutables utilizando la construcción as const</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tipo de una variable declarada usando una palabra clave </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se puede cambiar. Este concepto existe en JavaScript. También se adopta en TypeScript en aras de organizar un trabajo más estricto con los tipos. Pero cuando se trabaja con tipos de datos de objetos, como objetos o matrices, resulta que tales estructuras no son realmente inmutables. El uso de una palabra clave </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significa que una instancia específica de un objeto o matriz permanecerá sin cambios cuando se trabaja con una constante, sin embargo, el contenido de este objeto o matriz se puede cambiar fácilmente. Por ejemplo, sin violar las reglas para trabajar con entidades constantes, puede agregar nuevos valores a la matriz utilizando el método </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puede cambiar los valores de las propiedades de los objetos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usando </font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font><code>ReadonlyArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede decirle a TypeScript que el sistema debe tratar a las entidades como si fueran realmente inmutables. </font><font style="vertical-align: inherit;">Esto significa que cada vez que se realiza un intento en el código para cambiar dicha entidad, se emitirá un mensaje de error.</font></font><br>
<br>
<pre><code class="javascript hljs">interface Person {&nbsp;
&nbsp;&nbsp;<span class="hljs-attr">name</span>: string;&nbsp;<font></font>
}<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> person = {&nbsp;
&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">'Will'</span>&nbsp;
} <span class="hljs-keyword">as</span> Readonly&lt;Person&gt;;<font></font>
person.name = <span class="hljs-string">'Diana'</span>; <span class="hljs-comment">// !</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En TypeScript 3.4, entre otras innovaciones, apareció el concepto de aserción constante (enunciado constante), que proporciona el uso de una construcción </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este es un método simplificado para declarar constantes que contienen objetos y matrices inmutables. </font><font style="vertical-align: inherit;">Dichas declaraciones se crean agregando </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una constante al final de la declaración. </font><font style="vertical-align: inherit;">Este método tiene una ventaja adicional, que es que cuando lo usa, no necesita especificar explícitamente el tipo en la declaración </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">'Will'</span>&nbsp;
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<font></font>
&nbsp;<font></font>
person.name = <span class="hljs-string">'Diana'</span>; <span class="hljs-comment">// !</span><font></font>
&nbsp;<font></font>
<span class="hljs-comment">//      as const</span>
<span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;&nbsp;<font></font>
array.push(<span class="hljs-number">4</span>); <span class="hljs-comment">// !</span>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo de ayuda Omitir</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existen varios tipos de ayuda en TypeScript que facilitan la asignación de los tipos existentes a los nuevos, o la configuración condicional de un tipo basado en otros tipos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tipo auxiliar </font></font><code>Partial</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permite marcar todas las propiedades del objeto como opcional. </font><font style="vertical-align: inherit;">Antes del lanzamiento de TypeScript 3.5, resultó que constantemente usaba un mecanismo interesante en mis proyectos. </font><font style="vertical-align: inherit;">Esto es lo mismo que el uso del tipo auxiliar ahora permite lograr </font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este tipo, como su nombre lo indica, le permite excluir algo de otros tipos. </font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acepta el tipo y la combinación de claves, y luego devuelve un nuevo tipo del que se excluyen las propiedades descritas por las claves. </font><font style="vertical-align: inherit;">Atrás han quedado los días en que he tenido que utilizar </font></font><code>Pick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que </font></font><code>Exclude</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para la aplicación independiente de la funcionalidad</font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     TypeScript 3.5</span><font></font>
type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;<font></font>
&nbsp;<font></font>
interface A {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propA?: string;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propB?: string;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propC?: string;&nbsp;<font></font>
}<font></font>
&nbsp;<font></font>
type B = Omit&lt;A, <span class="hljs-string">'propA'</span> | <span class="hljs-string">'propC'</span>&gt;;&nbsp;
<span class="hljs-keyword">const</span> b: B = { <span class="hljs-attr">propA</span>: <span class="hljs-string">'hi'</span> }; <span class="hljs-comment">// ;</span>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuevas funciones de JavaScript compatibles con TypeScript</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando las sugerencias para nuevas funciones de JavaScript alcanzan 4 etapas de coordinación, se consideran parte de la próxima versión del lenguaje. </font><font style="vertical-align: inherit;">Es cierto que esto no significa que tales capacidades puedan usarse inmediatamente en JavaScript, ya que su soporte debe implementarse en entornos apropiados. </font><font style="vertical-align: inherit;">La aplicación debe tener acceso a tales oportunidades donde sea que se suponga su funcionamiento normal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El soporte para nuevas características de JavaScript se agrega regularmente al compilador TypeScript. </font><font style="vertical-align: inherit;">Por lo general, el código que implementa estas características se puede convertir a código JavaScript que sea compatible con todos los navegadores que admitan el objetivo de compilación del proyecto especificado en </font></font><code>tsconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Verificar nulo e indefinido</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los desarrolladores de JavaScript están familiarizados con el concepto de verdad y falsedad. Cuando la comprobación de la verdad puede ser identificado 6 valores, que son siempre falsas: </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>«»</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>NaN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y, por supuesto, </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La mayoría de las veces, el desarrollador solo necesita averiguar si el valor es verdadero o falso, pero en algunos casos solo necesita averiguar si el valor que se está investigando es un valor real </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o no </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por ejemplo, en el caso si es necesario distinguir entre código </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ||     ,  index  0</span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index || <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 1 &lt;-- </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este código funcionará estableciendo </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el valor escrito </font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en todos los casos, excepto en aquellos en los que el valor </font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es igual </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para que este código funcione correctamente en cualquier situación, debe reescribirse usando un esquema de prueba más complejo para descubrir el tipo de valor real.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   ,    </span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index !== <span class="hljs-literal">null</span> &amp;&amp; index !== <span class="hljs-literal">undefined</span> ? : <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora el código funciona, pero requiere el uso de controles más complejos. </font><font style="vertical-align: inherit;">El nuevo operador para verificar el valor </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(parece dos signos de interrogación </font></font><code>??</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) simplifica dichas comprobaciones al devolver el valor ubicado en su parte izquierda, si no es igual a </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De lo contrario, devuelve lo que está en su lado derecho.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// !</span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index ?? <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>
getValueOrOne(<span class="hljs-number">2</span>); <span class="hljs-comment">// 2</span>
getValueOrOne(); <span class="hljs-comment">// 1</span>
</code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Secuencias opcionales</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra nueva característica de JavaScript disponible en TypeScript 3.7 es el operador para organizar secuencias opcionales ( </font></font><code>?.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Conocí a un operador de este tipo en el lenguaje de programación Groovy. Desde entonces, también quería que apareciera en JavaScript. Este operador le permite organizar el acceso a las propiedades incrustadas de los objetos sin la necesidad de verificar constantemente su existencia. Si, al acceder a una propiedad, este operador encuentra un valor </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, simplemente devolverá este valor sin arrojar un error </font></font><code>TypeError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> value = foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz;<font></font>
&nbsp;<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> value = foo?.bar?.baz;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El operador de secuencia opcional combinado con el operador de verificación de los valores </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le da al desarrollador aún más posibilidades, permitiendo, por ejemplo, escribir en la variable el valor de alguna propiedad anidada del objeto o, si tal propiedad no existe, algún valor estándar. </font><font style="vertical-align: inherit;">Así es como se ve:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> value = foo?.bar?.baz ?? <span class="hljs-string">'default value'</span>;
</code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Campos de clase privada</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript, desde la aparición de este lenguaje, tiene su propio concepto de campos de clase privada declarados con un modificador de acceso </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este concepto apareció en TypeScript incluso antes de que las clases se describieran en el estándar ECMAScript. Pero en TypeScript, este concepto se refiere a los mecanismos que funcionan durante la compilación de código. El compilador arrojará un error si se accede al campo privado de la clase no desde los propios métodos de la clase. Ahora en JavaScript, ahora puede declarar propiedades privadas y métodos de una clase. Pero esta característica es semántica y sintácticamente diferente de lo que todavía existía en TypeScript. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los campos privados en JavaScript no se declaran utilizando un modificador de acceso </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En cambio, se declaran poniendo un símbolo al comienzo de sus nombres </font></font><code>#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fan</span> </span>{&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;#on = <span class="hljs-literal">false</span>;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;private name = <span class="hljs-string">'fan'</span>;<font></font>
&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;turnOn() {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.#on = <span class="hljs-literal">true</span>;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;isTurnedOn() {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.#on;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> fan = <span class="hljs-keyword">new</span> Fan();&nbsp;<font></font>
fan.isTurnedOn(); <span class="hljs-comment">// false&nbsp;&nbsp;</span><font></font>
fan.turnOn();&nbsp;<font></font>
fan.isTurnedOn(); <span class="hljs-comment">// true</span><font></font>
&nbsp;<font></font>
fan.on; <span class="hljs-comment">//  </span>
fan.#on; <span class="hljs-comment">// </span>
fan.name; <span class="hljs-comment">//   ,    JS</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript ahora admite campos privados, la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propuesta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de métodos privados se encuentra en la tercera etapa de aprobación. </font><font style="vertical-align: inherit;">Actualmente, el modificador </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el carácter </font></font><code>#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el nombre del campo no se pueden usar juntos. </font><font style="vertical-align: inherit;">Ambos enfoques pueden ser útiles durante el desarrollo, y cuál elegir depende del programador. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí hay un</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> podcast que analiza la nueva sintaxis para declarar campos privados.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍Utilizando la palabra clave de espera en el nivel superior del código</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los mecanismos de programación asincrónica amplían enormemente las capacidades de JavaScript y TypeScript. Al principio aparecieron promesas en esta área, luego, un diseño </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que le permite escribir un código asincrónico más limpio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uno de los casos donde se usan promesas, y no, </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es una llamada de método asincrónico fuera de la función asincrónica. Por ejemplo, en el nivel superior del módulo o código de aplicación. Como solución alternativa en esta situación, puede proponer la creación de una expresión asincrónica inmediatamente llamada Function Expression (IIFE, Inmediately Invocated Function Expression) y ejecutar código asincrónico dentro de dicha expresión.</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-keyword">async</span> () =&gt; {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/users/sitepen'</span>);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Check out the blog at <span class="hljs-subst">${data.blog}</span>`</span>);&nbsp;<font></font>
})();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript ahora admite la capacidad de JavaScript para usar palabras clave </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el nivel superior del código. </font><font style="vertical-align: inherit;">Esto significa que esperar puede usarse fuera de las funciones declaradas con la palabra clave </font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto es muy bueno para escribir código compacto y claro. </font><font style="vertical-align: inherit;">Es cierto que las expresiones </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el nivel superior del código son criticadas por el hecho de que pueden ralentizar la carga de módulos y crear una situación en la que cierto módulo puede ralentizar la carga de toda la aplicación, ya que el sistema tiene que esperar la finalización de la operación asincrónica y luego ejecutar todo el código del módulo.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/users/sitepen'</span>);&nbsp;
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> { ...data };
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entorno de experimentación de TypeScript mejorado</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto no se puede llamar una nueva característica de TypeScript, pero dado que estamos hablando de TypeScript como una herramienta, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScript Playground</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se puede llamar una herramienta efectiva para verificar rápidamente cualquier construcción de TypeScript y ver el código JavaScript en el que se convierten estas construcciones. </font><font style="vertical-align: inherit;">La mayoría de los ejemplos aquí se prueban específicamente en TypeScript Playground. </font><font style="vertical-align: inherit;">Ahora este entorno admite la capacidad de seleccionar una versión específica de TypeScript (incluida la compatibilidad con versiones beta). </font><font style="vertical-align: inherit;">Incluye varios ejemplos que ayudarán a los principiantes a comenzar con TypeScript.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumen</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript es una herramienta que le ayuda a escribir un código JavaScript mejor y más expresivo. </font><font style="vertical-align: inherit;">Las herramientas auxiliares de TypeScript facilitan la resolución de tareas complejas, como la refactorización y el cambio de nombre de entidades, que son mucho más complicadas en JavaScript ordinario. </font><font style="vertical-align: inherit;">TypeScript está constantemente introduciendo nuevos mecanismos, como </font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En el lenguaje, se puede observar una mejora continua en el soporte de tipos complejos. </font><font style="vertical-align: inherit;">TypeScript implementa rápidamente las últimas funciones de JavaScript. </font><font style="vertical-align: inherit;">Es por eso que muchas personas eligen TypeScript, percibiéndolo como una herramienta, lenguaje y ecosistema. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Queridos lectores! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué nuevas características de TypeScript te parecen más interesantes?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es493700/index.html">Uso de malware en Azure para obtener acceso a inquilinos de Microsoft 365</a></li>
<li><a href="../es493702/index.html">Transición masiva al trabajo remoto: problemas técnicos y amenazas a la seguridad.</a></li>
<li><a href="../es493704/index.html">Usar TypeScript en JavaScript sin escribir TypeScript</a></li>
<li><a href="../es493706/index.html">Conoce a tu enemigo: crea una puerta trasera Node.js</a></li>
<li><a href="../es493708/index.html">Anatomía de mi hogar Kubernetes cluster</a></li>
<li><a href="../es493714/index.html">Hojas de trucos de seguridad: Nodejs</a></li>
<li><a href="../es493716/index.html">Escriba inferencia con TypeScript utilizando la construcción as const y la palabra clave inferir</a></li>
<li><a href="../es493718/index.html">Discusión: utilidades estándar de UNIX que pocos han usado y están usando actualmente</a></li>
<li><a href="../es493720/index.html">La tormenta perfecta: cómo la tecnología está cambiando la industria del servicio de alimentos</a></li>
<li><a href="../es493724/index.html">RPA | Robotización de procesos a través de los ojos de un analista</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>