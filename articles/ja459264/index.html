<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐭 👰 😪 Tarantoolネットワークから抜け出す。トラフィックをフィルタリングする際のノードの同期 🔭 👩🏾‍⚕️ 📃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="VaritiはボットおよびDDoS攻撃に対する保護を専門としており、ストレスおよび負荷テストも実施しています。私たちは国際的なサービスを提供しているため、サーバーとクラスター間でリアルタイムに情報を中断なく交換できるようにすることが非常に重要です。サンHighLoad ++ 2019会議で、私たちは...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Tarantoolネットワークから抜け出す。トラフィックをフィルタリングする際のノードの同期</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/variti/blog/459264/"><img src="https://habrastorage.org/getpro/habr/post_images/479/4d3/c95/4794d3c95e7b9d2fe9155a3083f674eb.jpg" alt="画像"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VaritiはボットおよびDDoS攻撃に対する保護を専門としており、ストレスおよび負荷テストも実施しています。</font><font style="vertical-align: inherit;">私たちは国際的なサービスを提供しているため、サーバーとクラスター間でリアルタイムに情報を中断なく交換できるようにすることが非常に重要です。</font><font style="vertical-align: inherit;">サンHighLoad ++ 2019会議で、私たちは、このような束を取った理由Varitiの開発者アントンBarabanovは、我々はUDPとTarantoolをどのように使用するかを告げ、そしてどのように我々はCへのLuaからTarantoolモジュールを書き換えなければならなかった</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
あなたも読むことができる</font><font style="vertical-align: inherit;">レポートは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下、及びスポイラーの下に以下を参照してくださいビデオ。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオを報告する</font></font></b><div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/R0-POaXC0lI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トラフィックフィルタリングサービスの作成を開始したとき、私たちはすぐにIPトランジットを扱うのではなく、HTTP、API、およびゲームサービスを保護することにしました。</font><font style="vertical-align: inherit;">したがって、TCPプロトコルのL7レベルでトラフィックを終端し、それを渡します。</font><font style="vertical-align: inherit;">L3＆4の保護は同時に自動的に行われます。</font><font style="vertical-align: inherit;">以下の図はサービスダイアグラムを示しています。人々からのリクエストはクラスタを通過します。つまり、サーバーとネットワーク機器、およびボット（ゴーストとして表示）がフィルタリングされます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/g0/eg/qd/g0egqdye_eghswvgjsdpkek9cda.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィルタリングするには、トラフィックを個別のリクエストに分割し、セッションを正確かつ迅速に分析する必要があります。IPアドレスでブロックしないため、同じIPアドレスから接続内のボットとユーザーを定義します。</font></font><a name="habracut"></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスター内で何が起こるか</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスター内には、独立したフィルターノードがあります。つまり、各ノードは独自に動作し、独自のトラフィックでのみ機能します。ノード間では、トラフィックはランダムに分散されます。たとえば、1人のユーザーから10個の接続が受信された場合、それらはすべて異なるサーバーで分岐します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
お客様がさまざまな国にいるため、パフォーマンス要件は非常に厳しくなっています。たとえば、スイスのユーザーがフランスのサイトにアクセスした場合、トラフィックルートの増加により、すでに15ミリ秒のネットワーク遅延に直面しています。したがって、処理センター内にさらに15〜20ミリ秒を追加することはできません。リクエストは非常に長く続きます。さらに、各HTTPリクエストを15〜20ミリ秒間処理すると、2万RPSの単純な攻撃でクラスター全体が追加されます。もちろん、これは受け入れられません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのもう1つの要件は、要求を追跡するだけでなく、コンテキストを理解することでもありました。ユーザーがWebページを開き、スラッシュ要求を送信するとします。その後、ページがロードされ、HTTP / 1.1の場合、ブラウザーはバックエンドへの10個の接続を開き、10個のストリームで静的および動的要求を要求し、ajax要求とサブクエリを作成します。サブクエリをプロキシする代わりに、ページを送信するプロセスで、ブラウザとのやり取りを開始し、たとえばサブクエリにJSチャレンジを指定しようとすると、ページが破損する可能性が高くなります。最初のリクエストで、CAPTCHA（これは悪いことですが）またはJSチャレンジを提供し、リダイレクトを行うと、すべてのブラウザーがすべてを正しく処理します。テスト後、セッションが正当であるすべてのクラスターに関する情報を広める必要があります。クラスタ間で情報の交換がない場合、その後、他のノードは中間からセッションを受信し、それをスキップするかどうかがわかりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、すべての負荷の急増やトラフィックの変化に迅速に対応することも重要です。</font><font style="vertical-align: inherit;">1つのノードで何かがジャンプした場合、50〜100ミリ秒後に他のすべてのノードでジャンプが発生します。</font><font style="vertical-align: inherit;">したがって、他のすべてのノードでジャンプが発生しないように、ノードが事前に変更を認識し、事前に保護パラメータを設定することをお勧めします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボットから保護するための追加のサービスは、ポストマークアップサービスでした。ピクセルをサイトに配置し、ボット/個人情報を書き込んで、このデータをAPI経由で送信します。</font><font style="vertical-align: inherit;">これらの評決はどこかに保管する必要があります。</font><font style="vertical-align: inherit;">つまり、以前にクラスター内の同期について話していた場合は、クラスター間の情報の同期も追加しています。</font><font style="vertical-align: inherit;">以下に、L7レベルでのサービスのスキームを示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_t/lj/ah/_tljahe28yfpufxw6suxf9ay14y.jpeg"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスター間</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスタを作成した後、スケーリングを開始しました。私たちはBGPエニーキャストを使用して作業します。つまり、サブネットはすべてのクラスターから通知され、トラフィックは最も近いクラスターに到達します。簡単に言えば、リクエストはフランスからフランクフルトのクラスターに送信され、サンクトペテルブルクからモスクワのクラスターに送信されます。クラスターは独立している必要があります。ネットワークストリームは独立して許可されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どうしてそれが重要ですか？人が車で旅行し、モバイルインターネットからサイトを操作して特定のRubiconを通過した後、トラフィックが突然別のクラスターに切り替わったとします。または別のケース：スイッチの焼損またはルーターのどこかで何かが落ち、ネットワークセグメントが切断されたため、トラフィックルートが再構築されました。この場合、ブラウザー（Cookieなど）に十分な情報を提供するため、別のクラスターに切り替えるときに、成功したテストまたは失敗したテストに関する必要なパラメーターを通知できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、クラスター間で保護モードを同期する必要があります。これは、洪水のカバーの下で実行されることが最も多い、少量の攻撃の場合に重要です。攻撃は並行して実行されるので、人々は自分のサイトが洪水を壊していると思っており、少量の攻撃は見ていません。 1つのクラスターでボリュームが少なくなり、別のクラスターにフラッディングする場合は、保護モードの同期が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてすでに述べたように、私たちはクラスター間で同期し、蓄積され、APIによって与えられる非常に高い判定を行います。さらに、多くの評決があり、それらは確実に同期されなければなりません。保護モードでは、クラスター内ではなく、クラスター間で何かを失う可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスター間に大きな遅延があることは注目に値します。モスクワとフランクフルトの場合、これは20ミリ秒です。</font><font style="vertical-align: inherit;">ここでは同期要求を行うことはできません。すべての対話は非同期モードでなければなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に、クラスター間の相互作用を示します。</font><font style="vertical-align: inherit;">M、l、pは取引所のいくつかの技術パラメータです。</font><font style="vertical-align: inherit;">U1、u2は、非合法および合法としてのユーザーマークアップです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/a1/xl/si/a1xlsi20avhzuiv_s1uljdmubic.jpeg"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノード間の内部相互作用</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初、サービスを実行したとき、L7レベルでのフィルタリングは1つのノードでのみ開始されました。これは2つのクライアントでうまく機能しましたが、それ以上は機能しませんでした。スケーリングするとき、最大の応答性と最小のレイテンシを実現したいと考えました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パケットの処理に費やされるCPUリソースを最小限に抑えることが重要でした。そのため、たとえばHTTPを介した相互作用は適切ではありません。また、コンピューティングリソースだけでなく、パケットレートのオーバーヘッド消費も最小限に抑える必要がありました。それにもかかわらず、攻撃のフィルタリングについて話しており、これらは明らかに十分なパフォーマンスがない状況です。通常、Webプロジェクトを構築する場合、x3またはx4で十分ですが、大規模な攻撃が常に発生する可能性があるため、常にx1を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対話インターフェースのもう1つの要件は、情報を書き込む場所があり、そこから現在の状態を検討できる場所があることです。フィルタリングシステムの開発にC ++がよく使用されることは秘密ではありません。しかし、残念なことに、C ++で書かれたプログラムは時々クラッシュします。時々、そのようなプログラムを更新するために再起動する必要があります。たとえば、構成が再読み取りされなかったためです。攻撃を受けているノードを再起動する場合は、このノードが存在していたコンテキストをどこかに移動する必要があります。つまり、サービスはステートレスであってはならず、特定の数のユーザーがブロックし、確認していることを覚えておく必要があります。サービスが主要な情報セットを受信できるように、同じ内部通信が必要です。 SQLiteなど、特定のデータベースの近くに配置することを考えていました。しかし、このような解決策はすぐに破棄しました。各サーバーで入出力を書き込むのはおかしいので、これはメモリ内ではうまく機能しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、私たちはたった3つの操作で作業しています。</font><font style="vertical-align: inherit;">最初の機能は、すべてのノードへの「送信」です。</font><font style="vertical-align: inherit;">これは、たとえば、現在の負荷の同期に関するメッセージに適用されます。各ノードは、ピークを追跡するために、クラスター内のリソースの総負荷を知る必要があります。</font><font style="vertical-align: inherit;">2番目の操作は「保存」することであり、検証の判定に関係します。</font><font style="vertical-align: inherit;">3番目の操作は、「全員に送信」と「保存」の組み合わせです。</font><font style="vertical-align: inherit;">ここでは、すべてのノードに送信し、差し引くことができるように保存する状態変更メッセージについて説明しています。</font><font style="vertical-align: inherit;">以下は、結果の相互作用スキームです。保存するためのパラメーターを追加する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s7/__/8c/s7__8c-cnmitihkranlrso0ukza.jpeg"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプションと結果</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
評決を維持するためにどのようなオプションを見てきましたか？まず、クラシック、RabbitMQ、RedisMQ、および独自のTCPベースのサービスについて考えていました。これらの決定はゆっくりと機能するため、拒否しました。同じTCPがパケットレートにx2を追加します。さらに、1つのノードから他のすべてのノードにメッセージを送信する場合、多数の送信ノードが必要か、このノードが16台のマシンが送信できるメッセージの1/16をポイズニングする可能性があります。これが受け入れられないことは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、送信センターはネットワーク機器であり、パフォーマンスに制限がなく、送受信の速度に関する問題を完全に解決できるUDPマルチキャストを採用しました。 UDPの場合、テキスト形式は考慮せず、バイナリデータを送信することは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、パッケージとデータベースをすぐに追加しました。</font><font style="vertical-align: inherit;">Tarantoolを採用した理由は、1つ目は、会社の3人の創設者全員がこのデータベースを使用した経験があり、2つ目は、可能な限り柔軟であること、つまり、一種のアプリケーションサービスでもあることです。</font><font style="vertical-align: inherit;">さらに、TarantoolにはCAPIがあり、DDoSから保護するには最大のパフォーマンスが必要であるため、Cで書き込む機能は原則として問題です。</font><font style="vertical-align: inherit;">Cとは異なり、インタープリター言語では十分なパフォーマンスを提供できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下の図では、内部通信の状態が保存されるデータベースをクラスターに追加しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k3/py/60/k3py60c1-_z4uirabzit7-otlri.jpeg"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースを追加</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースには、呼び出しのログの形式で状態を保存します。情報を保存する方法を思いついたとき、2つのオプションがありました。一定の更新と変更で状態を保存することは可能でしたが、実装するのはかなり困難です。したがって、別のアプローチを使用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際のところ、UDPを介して送信されるデータの構造は統一されています。タイミング、ある種のコード、3つまたは4つのデータフィールドがあります。そこで、この構造を空間Tarantoolに書き始め、そこにTTLレコードを追加しました。これにより、構造が古く、削除する必要があることが明らかになります。したがって、メッセージログはTarantoolに蓄積され、指定されたタイミングでクリアされます。古いデータを削除するために、最初は有効期限が切れていました。その後、特定の問題が発生したため、それを放棄する必要がありました。これについては、以下で説明します。これまでのところ、このスキームでは、2つのデータベースが構造に追加されています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p-/li/-m/p-li-mkvdsa7ks9bxqz00ywlrey.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに述べたように、クラスターの状態を保存することに加えて、判定を同期することも必要です。</font><font style="vertical-align: inherit;">クラスター間で同期する判定。</font><font style="vertical-align: inherit;">したがって、Tarantoolのインストールを追加する必要がありました。</font><font style="vertical-align: inherit;">Tarantoolはすでに存在しており、サービスに最適であるため、別のソリューションを使用するのはおかしいでしょう。</font><font style="vertical-align: inherit;">新しいインストールでは、判定を記述し、それらを他のクラスターに複製し始めました。</font><font style="vertical-align: inherit;">この場合、マスター/スレーブではなく、マスター/マスターを使用します。</font><font style="vertical-align: inherit;">現在、Tarantoolには非同期マスター/マスターしかありません。多くの場合、これは適切ではありませんが、このモデルは最適です。</font><font style="vertical-align: inherit;">クラスター間のレイテンシが最小限の場合、同期レプリケーションは邪魔になりますが、非同期レプリケーションは問題を引き起こしません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私たちは多くの問題を抱えていました。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複雑さの最初のブロックはUDPに関連してい</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。プロトコルがパケットを打ち負かすことができることは秘密ではありません。私たちはこれらの問題をダチョウ法で解決しました。つまり、単に頭を砂に隠しました。それにもかかわらず、1つのスイッチのフレームワーク内で通信が行われ、不安定な接続や不安定なネットワーク機器がないため、パケットの損傷や場所の再配置は不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マシンがフリーズしたり、入出力がどこかで発生したり、ノードが過負荷になったりすると、パケット損失の問題が発生する可能性があります。このようなハングが短時間、たとえば50ミリ秒発生した場合、これはひどいものですが、sysctlキューを増やすことで解決します。つまり、sysctlを取得し、キューのサイズを構成して、ノードが再び動作し始めるまですべてが存在するバッファーを取得します。より長いフリーズが発生した場合、問題は接続の損失ではなく、ノードに送信されるトラフィックの一部です。これまでのところ、そのようなケースはありません。</font><i><font style="vertical-align: inherit;">Tarantool非同期レプリケーションの問題</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
は、はるかに複雑</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でした。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。最初は、マスター/マスターではなく、マスター/スレーブを操作するためのより伝統的なモデルを採用しました。そして、スレーブがマスターロードを長時間引き継ぐまで、すべてが正確に機能しました。その結果、有効期限が切れるとマスターではデータが削除されましたが、スレーブではそうではありませんでした。したがって、マスターからスレーブに何度か切り替えたとき、スレーブに大量のデータが蓄積され、ある時点ですべてが壊れました。したがって、完全なフォールトトレランスを実現するには、非同期マスター/マスターレプリケーションに切り替える必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ここで再び困難が生じました。まず、キーは異なるレプリカ間で交差する場合があります。クラスター内で、1つのマスターにデータを書き込み、この時点で接続が切断され、すべてを2番目のマスターに書き込んだとします。非同期レプリケーションを実行した後、同じプライマリキーが空間にあり、レプリケーションがバラバラになっていることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を簡単に解決しました。主キーに、書き込み先のTarantoolノードの名前が必ず含まれているモデルを採用しました。これにより、競合は発生しなくなりましたが、ユーザーデータが重複する状況が発生する可能性があります。これは非常にまれなケースであるため、ここでも単に無視しました。重複が頻繁に発生する場合、Tarantoolにはさまざまなインデックスがあるため、いつでも重複排除を実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の問題は、判定の保持に関係し、あるマスターに記録されたデータがまだ別のマスターに表示されておらず、要求がすでに最初のマスターに到着している場合に発生します。正直なところ、私たちはまだこの問題を解決しておらず、単に評決を遅らせています。これが受け入れられない場合、データの準備について一種のプッシュを整理します。これがマスター/マスターレプリケーションとその問題への対処方法です。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarantoolに直接関連する問題のブロックがありました</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そのドライバと期限切れのモジュール。起動後しばらくして、それぞれ攻撃が毎日発生し始め、同期とコンテキストの保存のためにデータベースに保存するメッセージの数が非常に多くなりました。また、ストリッピング中に大量のデータが削除され始めたため、ガベージコレクターは処理を停止しました。この問題を解決するには、IExpireと呼ばれる独自の期限切れモジュールをCで記述しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、有効期限が切れると、まだ対処できていない問題がもう1つあります。これは、有効期限が1つのマスターでしか機能しないという事実にあります。また、有効期限が切れたノードが落ちると、クラスターは重要な機能を失います。 1時間より古いすべてのデータをクリーンアップするとします。たとえば、ノードが5時間ある場合、データ量は通常の5倍になります。そして、その瞬間に大きな攻撃が来た場合、つまり2つの悪いケースが一致した場合、クラスターは落下します。これに対処する方法はまだわかりません。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、CのTarantoolドライバーには引き続き問題がありました。（競合状態などが原因で）サービスを停止すると、理由を見つけてデバッグするのに長い時間がかかりました。</font><font style="vertical-align: inherit;">したがって、Tarantoolドライバーを作成しただけです。</font><font style="vertical-align: inherit;">プロトコルの実装とテスト、デバッグ、本番環境での実行に5日かかりましたが、ネットワークを操作するための独自のコードはすでにありました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外の問題</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでにTarantoolレプリケーションの準備ができていることを思い出してください。判定を同期する方法はすでにわかっていますが、攻撃やクラスター間の問題に関するメッセージを送信するためのインフラストラクチャはまだありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インフラストラクチャについては、独自のTCPサービスを作成するなど、さまざまな考えがありました。ただし、TarantoolチームのTarantool Queueモジュールがまだあります。さらに、クラスター間レプリケーションを備えたTarantoolがすでにあり、「穴」がねじれていました。つまり、管理者のところに行ってポートを開いたりトラフィックを駆動したりする必要はありませんでした。ここでも、ソフトウェアフィルタリングへの統合の準備が整いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ホストノードに問題が発生しました。</font><font style="vertical-align: inherit;">クラスター内にn個の独立したノードがあり、書き込みキューと相互作用するノードを選択する必要があるとします。</font><font style="vertical-align: inherit;">それ以外の場合は、16個のメッセージが送信されるか、16回同じメッセージがキューから差し引かれます。</font><font style="vertical-align: inherit;">この問題を簡単に解決しました。責任のあるノードをスペースTarantoolに登録し、ノードが燃え尽きてしまった場合は、忘れない限りスペースを変更するだけです。</font><font style="vertical-align: inherit;">でも忘れてしまうと、これもまた解決したい問題です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、相互作用インターフェースを備えたクラスターのすでに詳細な図です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8f/f3/9o/8ff39og9opl3e4rjwydmtpdsola.jpeg"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改善して追加したいこと</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、オープンソースのIExpireに投稿します。これは便利なモジュールのようです。有効期限が切れているものと同じようにすべてを実行できますが、オーバーヘッドはほとんどありません。そこで、最も古いタプルのみを削除するために、ソートインデックスを追加する必要があります。これまでのところ、Tarantoolの主な操作は「書き込み」であるため、これを行っていません。インデックスを追加すると、そのサポートのために追加の負荷が発生します。また、データベースの折りたたみを回避するために、CAPIのほとんどのメソッドを書き直したいと考えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は論理マスターの選択にありますが、この問題を完全に解決することはできないようです。</font><font style="vertical-align: inherit;">つまり、有効期限が切れたノードが落ちた場合、手動で別のノードを選択して有効期限が切れたノードで実行するだけです。</font><font style="vertical-align: inherit;">レプリケーションは非同期であるため、これが自動的に行われることはほとんどありません。</font><font style="vertical-align: inherit;">私たちはおそらくこれについてTarantoolチームと相談しますが。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指数関数的なクラスターの成長の場合は、Tarantoolチームにも支援を求める必要があります。</font><font style="vertical-align: inherit;">実際のところ、Tarantool Queueとクラスター間保存判定では、全対全レプリケーションが使用されます。</font><font style="vertical-align: inherit;">たとえば、3つのクラスターがある場合、これはうまく機能しますが、それらが100ある場合、監視される接続の数は信じられないほど大きくなり、何かが常に壊れます。</font><font style="vertical-align: inherit;">第二に、Tarantoolがそのような負荷に耐えられることは事実ではありません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の結論は、UDPマルチキャストとTarantoolに関するものです。マルチキャストはそれを恐れる必要はありません。クラスター内での使用は適切で正確で高速です。状態が常に同期している場合が多く、50ミリ秒後は、以前に何が起こったかは問題になりません。そしてこの場合、ほとんどの場合、1つの状態の損失は問題になりません。したがって、パフォーマンスを制限せずに最適なパケットレートを得ることができるため、UDPマルチキャストの使用が正当化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のポイントはTarantoolです。外出先でのサービスやphpなどがある場合は、Tarantoolがそのまま適用できる可能性が高いです。ただし、負荷が大きい場合は、ファイルが必要になります。しかし、正直に言うと、この場合、ファイルはOracleとPostgeSQLの両方のすべてに必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、ホイールを再発明する必要はないという意見もあります。小規模なチームの場合は、既製のソリューションを使用する必要があります。同期用のRedis、標準的なgo、pythonなどです。</font><font style="vertical-align: inherit;">それは本当ではない。</font><font style="vertical-align: inherit;">新しいソリューションが必要だと確信している場合、オープンソースを使用していて、自分に適していないことがわかった場合、または試してみても意味がないことが事前にわかっている場合は、判断に目を通すと役に立ちます。</font><font style="vertical-align: inherit;">時間どおりに停止することが重要である別の会話。</font><font style="vertical-align: inherit;">つまり、Tarantoolを作成する必要はなく、メッセージングを実装する必要もありません。ブローカーだけが必要な場合は、すでにRedisを使用すれば幸せになります。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja459252/index.html">セキュリティウィーク28：スマートホームのハッキング</a></li>
<li><a href="../ja459254/index.html">さらに良いジップボム</a></li>
<li><a href="../ja459256/index.html">テーマ病院をさまざまなプラットフォームに最適化した方法</a></li>
<li><a href="../ja459258/index.html">フックしない14,000マイル</a></li>
<li><a href="../ja459262/index.html">22歳で引退</a></li>
<li><a href="../ja459272/index.html">Reactコンポーネント用のAPIを作成する、パート1：競合する小道具を作成しない</a></li>
<li><a href="../ja459274/index.html">Astra Linux Special Edition（スモレンスク）の画面ロックの脆弱性</a></li>
<li><a href="../ja459276/index.html">エピックフェイルレジスタンス2、またはFireFoxプラグインでプライバシーに関与すべきでない理由</a></li>
<li><a href="../ja459286/index.html">セミメタルテルル化タングステン-ナノテクノロジーの日のスイスナイフ</a></li>
<li><a href="../ja459288/index.html">ECSライブラリのネイティブ実装</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>