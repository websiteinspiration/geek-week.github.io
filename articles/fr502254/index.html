<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçπ üï∫üèæ ‚ôëÔ∏è PostgreSQL: programmation c√¥t√© serveur en langage humain (PL / Perl, PL / Python, PL / v8) üë©üèº‚Äçüé® ‚òùüèª üëΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Postgres est connu pour son extensibilit√©, qui s'applique √©galement √† la prise en charge des langages proc√©duraux (PL). Personne ne peut se vanter d'u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL: programmation c√¥t√© serveur en langage humain (PL / Perl, PL / Python, PL / v8)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/502254/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postgres est connu pour son extensibilit√©, qui s'applique √©galement √† la prise en charge des langages proc√©duraux (PL). Personne ne peut se vanter d'une </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">langue avec une</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> liste de langues de cette longueur, et potentiellement cette liste n'est pas du tout limit√©e: pour connecter la langue au serveur, aucun effort suppl√©mentaire n'est requis. Vous pouvez m√™me cr√©er votre propre langue et en faire un langage proc√©dural pour le serveur. Les modifications dans le SGBD ne l'exigeront pas. Comme tant d'autres, cette extensibilit√© a √©t√© int√©gr√©e √† l'architecture Postgres d√®s le d√©but. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est possible et parfois n√©cessaire d'√©crire des langages PL pour les t√¢ches. Mieux encore, si quelqu'un √©crit un tel cadre pour √©crire des langages afin que vous puissiez √©crire non pas en C, mais pour choisir un langage plus confortable pour un d√©veloppeur de langage. Comme avec FDW, qui </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut √™tre √©crit en Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article a √©t√© r√©dig√© sur la base d'un certain nombre de rapports et de master classes sur ce sujet r√©alis√©s par l'auteur lors des conf√©rences </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PgConf.Russia 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PgConf.Russia 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DevConf 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il ne s'agit pas d'exotisme, mais des langages proc√©duraux les plus courants PL / Perl, PL / Python et PL / V8 (c'est-√†-dire JavaScript) et de la comparaison de leurs capacit√©s avec PL / pgSQL.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quand ces langues valent-elles la peine d'√™tre utilis√©es? </font><font style="vertical-align: inherit;">Quand SQL et PL / pgSQL sont-ils manquants?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, lorsque vous devez travailler avec des structures complexes, avec des algorithmes: traverser des arbres, par exemple, ou quand une analyse HTML ou XML est requise, en particulier lors de leur extraction √† partir d'archives;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous devez g√©n√©rer dynamiquement du SQL complexe (rapports, ORM). </font><font style="vertical-align: inherit;">Sur PL / pgSQL, ce n'est pas seulement g√™nant, mais cela fonctionnera aussi plus lentement dans certains cas;</font></font></li>
<li>         Perl  Python,        C/C++,      Perl  Python    .         . ,    Oracle.     ,    Postgres   .    Perl  Python  .</li>
<li>   ‚Äî    .   , ,   untrusted- (  ‚Äî . ),    Perlu  Python(3)u,    PL/V8.   Postgres  ,     ,   FDW,    ,         .       .  !</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et encore une chose: si vous allez √©crire quelque chose en C, vous pouvez faire un prototype dans ces langages plus adapt√©s √† un d√©veloppement rapide.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment int√©grer une langue dans Postgres</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour impl√©menter le langage dont vous avez besoin: √©crivez en C de une √† trois fonctions:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HANDLER - un gestionnaire d'appels qui ex√©cutera une fonction dans le langage (c'est une partie obligatoire);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INLINE - gestionnaire de blocs anonymes (si vous voulez que la langue prenne en charge les blocs anonymes);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VALIDATOR - fonction de v√©rification de code lors de la cr√©ation d'une fonction (si vous souhaitez que cette v√©rification soit effectu√©e).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est d√©crit en d√©tail dans la documentation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬´Langues pr√™tes √† l'emploi¬ª et autres langues</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'y a que quatre langues prises en charge ¬´ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√™tes √† l'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> emploi </font><font style="vertical-align: inherit;">¬ª: </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">PL / pgSQL</font></a><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Tcl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais le chatouillement est plut√¥t un hommage √† l'histoire: peu de gens l'utilisent maintenant, nous n'en parlerons plus. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Perl, PL / Python et, bien s√ªr, PL / pgSQL sont pris en charge par la communaut√© Postgres. La prise en charge d'autres langues autres que celles de la bo√Æte incombe √† leurs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">responsables</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - entreprises, communaut√©s ou d√©veloppeurs sp√©cifiques int√©ress√©s √† faire fonctionner la langue √† l'int√©rieur du SGBD. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fait la promotion de Google. Mais de temps en temps, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il y a des raisons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doute de l'avenir sans nuage du PL / V8. Le responsable actuel du projet PL / V8 de Google, Jerry Sievert, envisage la prise en charge JS sur serveur postgres bas√©e sur un moteur diff√©rent (tel que QuickJS), car PL / V8 est difficile √† construire et n√©cessite 3 √† 5 Go toutes sortes de choses sur Linux lors de la construction, ce qui entra√Æne souvent des probl√®mes sur diff√©rents syst√®mes d'exploitation. Mais le PL / V8 est largement utilis√© et soigneusement test√©. Il est possible que PL / JS apparaisse comme une alternative √† un autre moteur JS, ou pour l'instant juste comme un nom, auquel nous nous habituerons pendant la p√©riode de transition. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est rarement utilis√©. Personnellement, je n'avais pas besoin d'√©crire en PL / Java car en PL / Perl et en PL / V8 il y a suffisamment de fonctionnalit√©s pour presque toutes les t√¢ches. M√™me Python n'ajoute pas particuli√®rement de fonctionnalit√©s. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / R</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utile pour ceux qui aiment les statistiques et aiment cette langue. Nous ne parlerons pas de lui ici non plus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les langages populaires ne sont pas n√©cessairement populaires avec les stockages d'√©criture: il y a PL / PHP, mais maintenant il n'est pratiquement pris en charge par personne - rares sont ceux qui veulent y √©crire des proc√©dures serveur. Pour le langage PL / Ruby, l'image est en quelque sorte la m√™me, bien que le langage semble √™tre plus moderne. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un langage proc√©dural bas√© sur Go est en cours de d√©veloppement, voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Go</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et aussi, semble-t-il, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Lua</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il faudra les √©tudier. Pour les fans obstin√©s de la coque, il y a m√™me </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Sh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il est m√™me difficile d'imaginer √† quoi cela pourrait servir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe au moins un langage proc√©dural sp√©cifique au domaine (DSL) qui est √©troitement sp√©cialis√© pour sa t√¢che - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Proxy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui √©tait tr√®s populaire pour le proxy et l'√©quilibrage de la charge du serveur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous couvrirons les principales langues les plus utilis√©es. Il s'agit bien s√ªr de PL / PgSQL, PL / Perl, PL / Python et PL / V8, nous les appellerons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ci-dessous </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les langues ¬´pr√™tes √† l'emploi¬ª sont vraiment install√©es presque litt√©ralement hors de la bo√Æte - g√©n√©ralement l'installation est indolore. Mais pour installer PL / V8, si vous n'avez pas trouv√© de package avec la version n√©cessaire dans le r√©f√©rentiel de votre syst√®me d'exploitation, c'est presque un exploit, car pour cela, vous devrez r√©ellement construire l'int√©gralit√© du V8, ou, en d'autres termes, Chromium. Dans le m√™me temps, l'int√©gralit√© de l'infrastructure de d√©veloppement sera t√©l√©charg√©e sur google.com avec la V8 elle-m√™me - comptez sur quelques gigaoctets de trafic. Pour Postgres 11 sous Ubuntu, le package PL / V8 n'est pas encore apparu, seul V8 pour PG 10 est disponible dans le r√©f√©rentiel jusqu'√† pr√©sent. Si vous le souhaitez, assemblez-le √† la main. Il est √©galement important que la version que vous trouverez dans le r√©f√©rentiel soit probablement assez ancienne. Au moment de la publication de l'article, la derni√®re version est la 2.3.14.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois la langue install√©e, vous devez √©galement ¬´cr√©er¬ª la langue - enregistrez-la dans le r√©pertoire syst√®me. </font><font style="vertical-align: inherit;">Cela devrait √™tre fait par l'√©quipe.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> plperl;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(au lieu de plperl, vous pouvez remplacer le nom d'une autre langue, il y a certaines nuances, voir ci-dessous). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous regardons ce qui s'est pass√©:</font></font><br>
<br>
<pre><code class="plaintext hljs">test_langs=# \x<font></font>
test_langs=# \dL+<font></font>
List of languages<font></font>
-[ RECORD 1 ]-----+---------------------------------<font></font>
Name              | plperl<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plperl_call_handler()<font></font>
Validator         | plperl_validator(oid)<font></font>
Inline handler    | plperl_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       | PL/Perl procedural language<font></font>
-[ RECORD 2 ]-----+---------------------------------<font></font>
Name              | plpgsql<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plpgsql_call_handler()<font></font>
Validator         | plpgsql_validator(oid)<font></font>
Inline handler    | plpgsql_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       | PL/pgSQL procedural language<font></font>
[ RECORD 3 ]-----+---------------------------------<font></font>
Name              | plv8<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plv8_call_handler()<font></font>
Validator         | plv8_call_validator(oid)<font></font>
Inline handler    | plv8_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       |</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / pgSQL n'a pas besoin d'√™tre sp√©cialement cr√©√©, il est toujours d√©j√† dans la base de donn√©es. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attention! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL ne doit pas √™tre confondu avec SQL. </font><font style="vertical-align: inherit;">Ceci est une langue diff√©rente. </font><font style="vertical-align: inherit;">Cependant, Postgres peut √©galement √©crire des fonctions en SQL simple.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le monde du SGBD, ils parlent souvent de la conformit√© aux normes SQL. </font><font style="vertical-align: inherit;">Les langages proc√©duraux ont √©galement des normes, m√™me si on n'en parle pas si souvent. </font><font style="vertical-align: inherit;">La </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">norme SQL / PSM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est hautement compatible avec le langage proc√©dural DB2. </font><font style="vertical-align: inherit;">Son impl√©mentation est loin d'√™tre PL / pgSQL, bien que conceptuellement elles soient proches. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL / JRT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la norme pour les proc√©dures Java et PL / Java est une bonne correspondance.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langues fiables et non fiables</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les langages proc√©duraux PostgreSQL sont approuv√©s (TRUSTED) et non fiables (UNTRUSTED). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les langages de CONFIANCE, il n'y a aucune possibilit√© de travail direct avec les E / S, y compris le r√©seau, et m√™me avec les ressources syst√®me. Par cons√©quent, de telles fonctions peuvent √™tre cr√©√©es par n'importe quel utilisateur de base de donn√©es, g√¢cher quelque chose et il ne pourra pas en apprendre trop. Les fonctions dans les langues NON CONTR√îL√âES ne peuvent √™tre cr√©√©es que par un superviseur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si l'interpr√©teur de langue prend en charge de telles restrictions, il peut √™tre utilis√© pour cr√©er des langues TRUSTED et UNTRUSTED. Donc, avec Perl, il y a donc diff√©rentes langues </font></font><code>plperl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>plperlu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lettre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la fin, il donne le caract√®re non fiable de la langue. </font><font style="vertical-align: inherit;">Python n'existe que dans une version non fiable. </font><font style="vertical-align: inherit;">PL / v8 - au contraire, uniquement en confiance. </font><font style="vertical-align: inherit;">Par cons√©quent, PL / v8 ne peut charger aucun module ou biblioth√®que √† partir du disque, uniquement √† partir de la base de donn√©es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fonction dans le langage UNTRUSTED peut tout faire: envoyer un e-mail, envoyer une requ√™te ping √† un site, se connecter √† une base de donn√©es √©trang√®re et ex√©cuter une requ√™te HTTP. </font><font style="vertical-align: inherit;">Les langues de confiance sont limit√©es au traitement des donn√©es de la base de donn√©es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En comprennent TRUSTED: </font></font><code>plpgsql, plperl, plv8, pljava</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En UNTRUSTED comprennent: </font></font><code>plperlu, pljavau, plpython2u, plpython3u</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remarque: il n'y a pas de PL / Python comme TRUSTED (car vous ne pouvez pas y d√©finir de restrictions d'acc√®s aux ressources), et PLpgSQL et PL / V8 sont l'inverse: ils ne sont pas INTRUSTR√âS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais Perl et Java sont disponibles dans les deux versions.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL vs PL / *</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code PL / pgSQL fonctionne nativement avec tous les types de donn√©es de Postgres. Les autres langues n'ont pas beaucoup de types Postgres, et l'interpr√®te de langue se charge de convertir les donn√©es en une repr√©sentation interne de la langue, en rempla√ßant les types obscurs par du texte. Cependant, il peut √™tre aid√© avec l'aide de TRANSFORM, dont je parlerai plus pr√®s de la fin de l'article.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les appels de fonction en PL / pgSQL sont souvent plus chers. Les fonctions dans d'autres langues peuvent acc√©der √† leurs biblioth√®ques sans consulter le catalogue syst√®me. PL / pgSQL ne peut pas fonctionner comme √ßa. Certaines requ√™tes en PL / pgSQL fonctionnent depuis longtemps en raison du fait que de nombreux types sont pris en charge: pour ajouter deux entiers, l'interpr√©teur doit se rendre compte qu'il traite des entiers et non d'autres types exotiques, puis d√©cider comment les plier, et seulement apr√®s cela, les plier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√âtant donn√© que PL / pgSQL est TRUSTED, vous ne pouvez pas travailler avec le r√©seau et les disques de celui-ci. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'il s'agit de travailler avec des structures de donn√©es imbriqu√©es, PL / pgSQL ne dispose que d'outils Postgres pour travailler avec JSON, qui sont tr√®s encombrants et improductifs, dans d'autres langues, travailler avec des structures imbriqu√©es est beaucoup plus simple et plus √©conomique.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / * poss√®de sa propre gestion de la m√©moire, et vous devez surveiller la m√©moire, ou peut-√™tre la limiter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez surveiller attentivement la gestion des erreurs, qui est √©galement diff√©rente pour tout le monde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais dans PL / *, il existe un contexte d'interpr√©teur global, et il peut √™tre utilis√©, par exemple, pour mettre en cache des donn√©es, y compris des plans de requ√™te. </font><font style="vertical-align: inherit;">Si la langue est NON CONFI√âE, le r√©seau et les lecteurs sont disponibles. </font><font style="vertical-align: inherit;">Toutes ces langues fonctionnent avec la base de donn√©es, en r√®gle g√©n√©rale, via le SPI, mais plus √† ce sujet plus tard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinons plus en d√©tail les fonctionnalit√©s des langages PL / *.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'interpr√©teur Perl est un morceau de code lourd en m√©moire, mais heureusement, il n'est pas cr√©√© lorsque la connexion est ouverte, mais uniquement lorsque la premi√®re proc√©dure / fonction stock√©e PL / Perl est lanc√©e. </font><font style="vertical-align: inherit;">Une fois initialis√©, le code sp√©cifi√© dans les param√®tres de configuration Postgres est ex√©cut√©. </font><font style="vertical-align: inherit;">Habituellement, les modules sont charg√©s et des pr√©calculs sont effectu√©s. </font><font style="vertical-align: inherit;">
Si vous avez ajout√© au fichier de configuration pendant que la base de donn√©es est en cours d'ex√©cution, demandez √† Postgres de relire la configuration. </font><font style="vertical-align: inherit;">Dans cet article, les exemples utilisent un module </font><font style="vertical-align: inherit;">pour visualiser les structures de donn√©es. </font><font style="vertical-align: inherit;">
Il existe des param√®tres pour l'initialisation s√©par√©e de Perl TRUSTED et UNTRUSTED et, bien s√ªr, un param√®tre </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ceux qui programment en Perl savent que sans lui </font><font style="vertical-align: inherit;">ce n'est pas une langue, mais un malentendu.</font></font><br>
<br>
<code>plperl.on_init= 'use Data::Dumper;'<br>
plperl.on_plperl_init= ' ... '<br>
plperl.on_plperlu_init= ' ... '<br>
plperl.use_strict= on</code><br>
<br><font style="vertical-align: inherit;"></font><code>Data::Dumper</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>use_strict=on</code><font style="vertical-align: inherit;"></font><code>strict</code><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans celui-ci, l'interpr√©teur est cr√©√© de la m√™me mani√®re lors du premier acc√®s. Et ici, il est important de d√©cider imm√©diatement quel python vous voulez: deuxi√®me ou troisi√®me. Comme vous le savez, Python existe en deux versions populaires (Python 2 et Python 3), mais le probl√®me est que leurs so-shki ne s'entendent pas en un seul processus: il y a un conflit de nom. Si vous avez travaill√© avec v2 en une seule session puis appel√© v3, Postgres se bloquera et pour le processus serveur (backend), ce sera une erreur fatale. Pour acc√©der √† une autre version, vous devez ouvrir une autre session. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contrairement √† Perl, python ne peut pas savoir quoi faire pendant l'initialisation. Autre inconv√©nient: les lignes simples ne sont pas pratiques √† faire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans toutes les fonctions Python, deux dictionnaires sont d√©finis - statique </font></font><code>SD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et global </font></font><code>GD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Global </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©changer des donn√©es avec toutes les fonctions dans un seul backend - ce qui est √† la fois attrayant et dangereux. </font><font style="vertical-align: inherit;">Chaque fonction poss√®de un dictionnaire statique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En PL / Python, vous pouvez effectuer des sous-transactions, dont nous discuterons ci-dessous.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce n'est que de la CONFIANCE. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De mani√®re pratique, les donn√©es JSON sont automatiquement converties en une structure JS. En PL / V8, comme en PL / Python, vous pouvez effectuer des sous-transactions. Il existe une interface pour les appels de fonction simplifi√©s. C'est le seul langage proc√©dural en question dans lequel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des fonctions de fen√™tre peuvent √™tre d√©finies</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ils sugg√®rent qu'ils </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peuvent √™tre d√©finis sur PL / R</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais ce langage sort du cadre de cet article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et ce n'est que dans PL / V8 qu'il y a un d√©lai d'ex√©cution. Certes, il n'est pas activ√© par d√©faut, et si vous construisez PL / V8 √† la main, vous devez dire qu'il a √©t√© activ√© lors de l'assemblage, puis vous pouvez d√©finir des d√©lais d'expiration pour les appels de fonction avec le param√®tre de configuration.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'initialisation dans PL / V8 semble int√©ressante: puisqu'elle est fiable, elle ne peut pas lire la biblioth√®que √† partir du disque, elle ne peut rien charger de n'importe o√π. </font><font style="vertical-align: inherit;">Il ne peut prendre tout ce dont il a besoin qu'√† la base. </font><font style="vertical-align: inherit;">Par cons√©quent, une fonction d'initialisation stock√©e est d√©finie et appel√©e au d√©marrage de l'interpr√©teur de langue. </font><font style="vertical-align: inherit;">Le nom de la fonction est sp√©cifi√© dans un param√®tre de configuration sp√©cial:</font></font><br>
<br>
<pre><code class="pgsql hljs">plv8.start_proc=my_init # ( PL/V8-)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant l'initialisation, des variables et fonctions globales peuvent √™tre cr√©√©es en affectant leurs valeurs aux attributs de cette variable. </font><font style="vertical-align: inherit;">Par exemple, comme ceci:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> my_init()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span> <span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span> $$<span class="php">
     this.get_57 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">57</span>; }; <span class="hljs-comment">//   </span>
     this.pi_square = <span class="hljs-number">9.8696044</span>;  <span class="hljs-comment">//   </span>
$$</span>;
<span class="hljs-keyword">SET</span> plv8.start_proc = <span class="hljs-string">'my_init'</span>;
<span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, pi_square, get_57() );
$$</span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparaison de PL / Perl vs PL / Python vs PL / V8 en pratique</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour le monde!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faisons un exercice simple avec la sortie de cette phrase dans les trois langues, d'abord en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Et laissez-le faire autre chose d'utile, par exemple, raconte sa version:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     elog(<span class="hljs-keyword">NOTICE</span>,"Hello World! $]");
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  Hello World!<font></font>
DO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez √©galement utiliser les fonctions Perl habituelles </font></font><code>warn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Plus pr√©cis√©ment sur PL / Python3u (non approuv√©) - pour plus de pr√©cision.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">import</span> sys
     plpy.<span class="hljs-keyword">notice</span>(<span class="hljs-string">'Hello World! '</span> , hint=" ", detail=sys.version_info)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
NOTICE:  Hello World! <font></font>
DETAIL:  sys.version_info(major=3, minor=6, micro=9, releaselevel='final', serial=0)<font></font>
HINT:   <font></font>
DO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peut utiliser </font></font><code>throw 'Errmsg'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il y a beaucoup de choses que vous pouvez extraire des messages Postgres: ils contiennent Hint, Details, num√©ro de ligne et de nombreux autres param√®tres. </font><font style="vertical-align: inherit;">En PL / Python, ils peuvent √™tre pass√©s, mais pas dans les autres langages consid√©r√©s: leurs moyens ne peuvent √™tre maudits qu'avec une ligne de texte brut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En PL / Python, chaque niveau de journalisation postgres a sa propre fonction: AVIS, AVERTISSEMENT, DEBUG, LOG, INFO, FATAL. </font><font style="vertical-align: inherit;">Si c'est ERREUR, alors la transaction a chut√©, si FATAL, le backend entier est tomb√©. </font><font style="vertical-align: inherit;">Heureusement, l'affaire n'a pas atteint la PANIQUE. </font><font style="vertical-align: inherit;">Vous pouvez </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lire ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans cette langue, Hello world est tr√®s similaire √† la perle. </font><font style="vertical-align: inherit;">Vous pouvez arr√™ter d' </font></font><code>exception</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliser </font></font><code>throw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et ce sera √©galement la gestion des erreurs, bien que les outils ne soient pas aussi avanc√©s qu'en Python. </font><font style="vertical-align: inherit;">Si vous √©crivez</font></font><code>plv8.elog(ERROR)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, l'effet sera d'ailleurs le m√™me.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, <span class="hljs-string">'Hello World!'</span>, plv8.<span class="hljs-keyword">version</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  Hello World! 2.3.14<font></font>
DO<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travailler avec la base</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant comment travailler avec une base de donn√©es √† partir de proc√©dures stock√©es. Postgres dispose d'une SPI (Server Programming Interface). Il s'agit d'un ensemble de fonctions C disponibles pour tous les auteurs d'extensions. Presque tous les langages PL fournissent des wrappers pour SPI, mais chaque langue le fait un peu diff√©remment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fonction √©crite en C mais utilisant SPI est peu susceptible de donner un gain significatif par rapport √† PL / PgSQL et √† d'autres langages proc√©duraux. Mais une fonction C qui contourne SPI et fonctionne avec des donn√©es sans interm√©diaires (par exemple </font></font><code>table_beginscan/heap_getnext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) fonctionnera beaucoup plus rapidement.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Java utilise √©galement SPI. Mais travailler avec la base de donn√©es se fait toujours dans le style de JDBC et de la norme JDBC. Pour le cr√©ateur de code en PL / Java, tout se passe comme si vous travailliez √† partir d'une application cliente, mais JNI (Java Native Interface) traduit les appels √† la base de donn√©es dans les m√™mes fonctions SPI. C'est pratique, et il n'y a pas d'obstacles fondamentaux pour traduire ce principe en PL / Perl et PL / Python, mais pour une raison quelconque, cela n'a pas √©t√© fait, et jusqu'√† pr√©sent, il n'est pas visible dans les plans. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr, si vous le souhaitez, vous pouvez vous rendre dans des bases √©trang√®res de la mani√®re habituelle - via DBI ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Psycopg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il est possible de cr√©er une base de donn√©es locale, mais pourquoi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous n'entrez pas dans le sujet holistique ¬´processus dans la base vs processus sur le client¬ª, et passez imm√©diatement du traitement maximal au plus pr√®s des donn√©es (au moins afin de ne pas conduire d'√©chantillons g√©ants sur le r√©seau), alors la solution pour utiliser les fonctions stock√©es sur le serveur semble naturellement. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performances</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : gardez √† l'esprit que SPI a des frais g√©n√©raux et que les requ√™tes SQL dans les fonctions peuvent √™tre plus lentes que sans fonctions. Le 13e postgres comprenait un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patch de Konstantin Knizhnik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui r√©duit ces co√ªts. Mais, bien s√ªr, le traitement des r√©sultats de la requ√™te dans une fonction stock√©e ne n√©cessite pas le transfert du r√©sultat au client, et peut donc √™tre b√©n√©fique en termes de performances. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√©curit√©</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: un ensemble de fonctions d√©bogu√©es et test√©es isole la structure de la base de donn√©es de l'utilisateur, prot√®ge contre les injections SQL et autres m√©faits. </font><font style="vertical-align: inherit;">Sinon, cela restera un casse-t√™te pour tous les d√©veloppeurs d'applications. </font><font style="vertical-align: inherit;">R√©utilisation du </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : si un grand nombre d'applications complexes fonctionnent avec la base de donn√©es, il est pratique de stocker des fonctions utiles sur le serveur, plut√¥t que de les r√©√©crire dans chaque application.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment et sous quelle forme obtenons-nous les donn√©es de la base de donn√©es</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tout est simple et clair. </font><font style="vertical-align: inherit;">L'appel </font></font><code>spi_exec_query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie le nombre de lignes trait√©es, l'√©tat et le tableau de lignes s√©lectionn√©s par la requ√™te SQL:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="ruby"> 
     warn Data::Dumper::Dumper(
          spi_exec_query(<span class="hljs-string">'SELECT 57 AS x'</span>)
     )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  $VAR1 = {<font></font>
          'rows' =&gt; [<font></font>
                    {<font></font>
                      'x' =&gt; '57'<font></font>
                    }<font></font>
                  ],<font></font>
          'processed' =&gt; 1,<font></font>
          'status' =&gt; 'SPI_OK_SELECT'<font></font>
        };<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python, la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requ√™te et le r√©sultat ressemblent √† ceci, mais ici la fonction ne renvoie pas une structure de donn√©es, mais un objet sp√©cial avec lequel vous pouvez travailler de diff√©rentes mani√®res. </font><font style="vertical-align: inherit;">Habituellement, il pr√©tend √™tre un tableau et, en cons√©quence, vous pouvez en extraire des cha√Ænes.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plpy.<span class="hljs-keyword">notice</span>(
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 AS x'</span>)
     )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  &lt;PLyResult status=5 nrows=1 rows=[{'x': 57}]&gt;<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant, nous prenons la 1√®re ligne, sortons de l√† X et obtenons la valeur - le nombre.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plpy.<span class="hljs-keyword">notice</span>(
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 AS x'</span>)[<span class="hljs-number">0</span>][<span class="hljs-string">'x'</span>]
      )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  57<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, <span class="hljs-type">JSON</span>.stringify(
          plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 as x'</span>))
     );
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  [{"x":57}]<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour voir la structure, nous avons utilis√© la fonction de biblioth√®que JSON.stringify, qui n'a pas besoin d'√™tre charg√©e sp√©cifiquement, elle est d√©j√† pr√™te √† √™tre utilis√©e par d√©faut dans PL / v8. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blindage</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour √©viter les injections SQL malveillantes, certains caract√®res des requ√™tes doivent √™tre √©chapp√©s. Pour ce faire, tout d'abord, il existe des fonctions SPI et des fonctions correspondantes (√©crites en C) dans des langages qui fonctionnent comme des wrappers SPI. Par exemple, en PL / Perl: </font></font><br>
<br>
<code>quote_literal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- prend les apostrophes et les doubles 'et \. Con√ßu pour filtrer les donn√©es de texte. </font></font><br>
<code>quote_nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- identique, mais </font></font><code>undef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">converti en NULL. </font></font><br>
<code>quote_ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- cite le nom de la table ou du champ, si n√©cessaire. Utile dans le cas o√π vous cr√©ez une requ√™te SQL et remplacez-y les noms des objets de base de donn√©es. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> <span class="hljs-string">"macy's"</span>;
     <span class="hljs-keyword">warn</span> quote_literal(<span class="hljs-string">"macy's"</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  macy's at line 2.<font></font>
WARNING:  'macy''s' at line 3.<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gardez √† l'esprit: le nom de la table ne doit pas √™tre √©chapp√© comme une ligne de texte. </font><font style="vertical-align: inherit;">C'est pourquoi il y a une fonction </font></font><code>quote_ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais dans PL / Perl, il existe d'autres fonctions pour le blindage des donn√©es de types post-gres individuels: </font><font style="vertical-align: inherit;">
Une fonction </font><font style="vertical-align: inherit;">doit accepter n'importe quel type et transformer les caract√®res douteux atypiques en quelque chose de √©videmment s√ªr. </font><font style="vertical-align: inherit;">Il fonctionne avec un grand nombre de types, mais pas avec tous. </font><font style="vertical-align: inherit;">Elle, par exemple, ne comprend pas les </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">types de plage</font></a><font style="vertical-align: inherit;"> et ne les per√ßoit que comme des cha√Ænes de texte.</font></font><br>
<br>
<code>encode_bytea<br>
decode_bytea<br>
encode_array_literal<br>
encode_typed_literal<br>
encode_array_constructor</code><br>
<br><font style="vertical-align: inherit;"></font><code>quote_typed_literal</code><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> encode_typed_literal(
          [<span class="hljs-string">""</span>, <span class="hljs-string">" "</span>], <span class="hljs-string">"text[]"</span>
     );
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  {," "} at line 2.<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il </font><font style="vertical-align: inherit;">existe trois fonctions similaires </font><font style="vertical-align: inherit;">dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et elles fonctionnent de la m√™me mani√®re:</font></font><br>
<br>
<code>plpy.quote_literal<br>
plpy.quote_nullable<br>
plpy.quote_ident</code><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> plpy.<span class="hljs-keyword">notice</span>(
     plpy.quote_literal("Macy's"));
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><pre><code class="plaintext hljs">NOTICE:  'Macy''s'<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les fonctions de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8 sont-elles les</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√™mes </font><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr! </font><font style="vertical-align: inherit;">Tout est le m√™me jusqu'aux fonctionnalit√©s syntaxiques.</font></font><br>
<br>
<code>plv8.quote_literal<br>
plv8.quote_nullable<br>
plv8.quote_ident</code><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
    plv8.elog(<span class="hljs-keyword">NOTICE</span>, plv8.quote_nullable("Macy's"));
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  'Macy''s'</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle langue est la plus rapide? Habituellement, ils r√©pondent: C. Mais la bonne r√©ponse est C </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SQL. Pourquoi SQL? Le fait est qu'une fonction dans ce langage n'est pas toujours ex√©cut√©e explicitement. Il peut √™tre int√©gr√© dans la requ√™te (le planificateur incorporera la fonction dans le corps de la requ√™te principale), s'optimisera bien avec la requ√™te et le r√©sultat sera plus rapide. Mais dans quelles conditions le code peut-il √™tre int√©gr√© dans une requ√™te? Il y a quelques conditions simples que vous pouvez lire, par </font><font style="vertical-align: inherit;">exemple, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Par exemple, une fonction ne doit pas √™tre ex√©cut√©e avec les droits du propri√©taire (√™tre SECURITY DEFINER). La plupart des fonctions simples r√©pondent √† ces conditions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article nous mesurerons "sur le genou", pas s√©rieusement. Nous avons besoin d'une comparaison grossi√®re. Allumez d'abord le timing:</font></font><br>
<br>
<pre><code class="plaintext hljs">\timing</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Les temps d'ex√©cution des commandes ci-dessous sont les valeurs moyennes arrondies que l'auteur a re√ßues sur un PC d√©charg√© de six ans. Ils peuvent √™tre compar√©s entre eux, mais ils ne pr√©tendent pas √™tre scientifiques):</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">FROM</span> pg_class;
<span class="hljs-number">0.5</span> ms
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela fonctionne tr√®s rapidement. </font><font style="vertical-align: inherit;">Dans d'autres langues, le temps est perdu √† appeler des fonctions de la langue. </font><font style="vertical-align: inherit;">Bien s√ªr, la premi√®re fois que la requ√™te s'ex√©cutera plus lentement en raison de l'initialisation de l'interpr√©teur. </font><font style="vertical-align: inherit;">Ensuite, il se stabilise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">int</span>;
     <span class="hljs-keyword">BEGIN</span>
          <span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> pg_class;
     <span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">0.7</span> ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $x = spi_exec_query(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">0.7</span> ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python:</font></font></b><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     x = plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpythonu;
<span class="hljs-number">0.8</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'√©tait Python 2. Maintenant </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (rappel: Python2 et Python3 ne vivent pas paisiblement dans la m√™me session, un conflit de noms est possible):</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     x = plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">0.9</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et enfin, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     var x = plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8 ;
<span class="hljs-number">0.9</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais c'est en quelque sorte tr√®s rapide. </font><font style="vertical-align: inherit;">Essayons d'ex√©cuter la requ√™te 1000 fois ou 1 million de fois, soudain la diff√©rence sera plus sensible: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">int</span>; i <span class="hljs-type">int</span>;
     <span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">0.</span><span class="hljs-number">.999999</span> <span class="hljs-keyword">LOOP</span>
          <span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> pg_class;
    <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
<span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">53</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="ruby">
     <span class="hljs-keyword">for</span> (<span class="hljs-number">0</span>..<span class="hljs-number">999999</span>) {
          spi_exec_query(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     }
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">102</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>,<span class="hljs-number">1000000</span>) :
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">98</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)
          plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;
<span class="hljs-number">100</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notez qu'avec PL / V8, l'exp√©rience a √©t√© faite avec mille, pas un million d'it√©rations. Avec des ressources mod√©r√©es, le PL / V8 dans un cycle de 1 million d'op√©rations mangera toute la m√©moire et accrochera compl√®tement la voiture. D√©j√† √† mille it√©rations, le processus postgres s√©lectionne 3,5 Go de m√©moire et 100% d'√©criture sur le disque. En fait, postgres lance l'environnement V8, et bien s√ªr, il mange de la m√©moire. Apr√®s avoir ex√©cut√© la requ√™te, ce monstre turbo ne va pas rendre de m√©moire. Pour lib√©rer de la m√©moire, vous devez mettre fin √† la session. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On voit que PL / pgSQL est d√©j√† 2 fois plus rapide que PL / Perl et PL / Python. PL / V8 est encore l√©g√®rement derri√®re eux, mais vers la fin de l'article, il est partiellement r√©habilit√©.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En g√©n√©ral, Perl avec Python dans ces exp√©riences montre approximativement les m√™mes r√©sultats. </font><font style="vertical-align: inherit;">Perl √©tait l√©g√®rement inf√©rieur √† Python; dans les versions modernes, il est l√©g√®rement plus rapide. </font><font style="vertical-align: inherit;">Le troisi√®me python est l√©g√®rement plus lent que le second. </font><font style="vertical-align: inherit;">La diff√©rence totale se situe √† moins de 15%.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance avec PREPARE</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les gens qui savent comprendront: quelque chose ne va pas. </font><font style="vertical-align: inherit;">PL / pgSQL peut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">automatiquement mettre en cache les plans de requ√™te</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et dans PL / *, chaque fois que la requ√™te a √©t√© planifi√©e √† nouveau. </font><font style="vertical-align: inherit;">Dans le bon sens, vous devez pr√©parer des demandes, cr√©er un plan de demande, puis selon ce plan, elles doivent √™tre ex√©cut√©es autant de fois que n√©cessaire. </font><font style="vertical-align: inherit;">Dans PL / *, vous pouvez explicitement travailler avec des plans de requ√™te, que nous allons essayer de commencer avec </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     <span class="hljs-keyword">for</span> (<span class="hljs-number">0</span>..<span class="hljs-number">999999</span>) {
          spi_exec_prepared($h);
     }
     spi_freeplan($h);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">60</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     h = plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>)
     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>,<span class="hljs-number">1000000</span>): plpy.<span class="hljs-keyword">execute</span>(h)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">62</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     var h=plv8.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++) h.<span class="hljs-keyword">execute</span>();
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;
<span class="hljs-number">53</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec </font></font><code>prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nos deux langues, nous avons presque rattrap√© PL / pgSQL, tandis que le troisi√®me le voulait aussi, mais n'a pas atteint la ligne d'arriv√©e en raison de la demande croissante de m√©moire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais si vous ne tenez pas compte de la m√©moire, il est clair que toutes les langues vont presque de pair - et pas par hasard. </font><font style="vertical-align: inherit;">Leur goulot d'√©tranglement est maintenant commun - travailler avec la base de donn√©es via SPI.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performances informatiques</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous voyons que la performance du langage repose sur le travail avec la base de donn√©es. </font><font style="vertical-align: inherit;">Pour comparer les langues entre elles, essayons de calculer quelque chose sans avoir recours √† la base de donn√©es, par exemple, la somme des carr√©s. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">bigint</span>; a <span class="hljs-type">bigint</span>;
     <span class="hljs-keyword">BEGIN</span> a=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">0.</span><span class="hljs-number">.1000000</span> <span class="hljs-keyword">LOOP</span>
          a=a+i*i::<span class="hljs-type">bigint</span>;
     <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
<span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">280</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $a=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> $i (<span class="hljs-number">0</span>..<span class="hljs-number">1000000</span>) { $a+=$i*$i; };
     <span class="hljs-keyword">warn</span> $a;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">63</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
a=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">1000001</span>): a=a+i*i
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">73</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="plaintext hljs">DO $$<font></font>
     var a=0;<font></font>
     for(var i=0;i&lt;=1000000;i++) a+=i*i;<font></font>
     plv8.elog(NOTICE, a);<font></font>
$$ language plv8;<font></font>
7.5ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On voit que PL / Perl et PL / Python ont d√©pass√© et d√©pass√© PL / pgSQL, ils sont 4 fois plus rapides. </font><font style="vertical-align: inherit;">Et le huit d√©chire tout le monde! </font><font style="vertical-align: inherit;">Mais est-ce vraiment pour rien? </font><font style="vertical-align: inherit;">Ou allons-nous l'obtenir pour la t√™te? </font><font style="vertical-align: inherit;">Oui nous le ferons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le nombre en JavaScript est un flottant, et le r√©sultat est rapide, mais pas pr√©cis: 333333833333127550 au lieu de 333333833333500000. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici la formule par laquelle le r√©sultat exact est </font><font style="vertical-align: inherit;">calcul√© </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">‚àë = n*(n+1)*(2n+1)/6
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme exercice, vous pouvez le prouver en utilisant l'induction math√©matique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'ordre du rire</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
plv8.elog(<span class="hljs-keyword">NOTICE</span>, parseInt(<span class="hljs-number">33333383333312755033</span>)) $$</span>;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:<font></font>
33333383333312754000</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Javascript, </font></font><code>parseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il fait toujours un float, pas un Int. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√©anmoins, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BigInt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est apparu dans V8 en 2018 </font><font style="vertical-align: inherit;">, et il peut maintenant √™tre compt√© avec certitude, mais au d√©triment de la vitesse, car il ne s'agit pas d'un entier 64 bits, mais d'un entier de profondeur de bits arbitraire. </font><font style="vertical-align: inherit;">Cependant, en PL / V8, cette innovation n'a pas encore frapp√©. </font><font style="vertical-align: inherit;">Dans d'autres langages proc√©duraux, les nombres de bits arbitraires (analogues de SQL </font></font><code>numeric</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) sont pris en charge via des biblioth√®ques sp√©ciales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Perl, il existe un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">module Math :: BigFloat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour l'arithm√©tique avec une pr√©cision arbitraire, et en Python le package </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bigfloat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un wrapper </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cython</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> autour de la biblioth√®que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU MPFR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonctions de performance pour le tri</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un exemple pratique, qui montre la diff√©rence dans les performances de tri par fonction, si cette fonction est √©crite dans diff√©rentes langues. </font><font style="vertical-align: inherit;">T√¢che: trier les champs de texte contenant les num√©ros des num√©ros de la revue, qui peuvent √™tre les suivants:</font></font><br>
<br>
<pre><code class="plaintext hljs">1<font></font>
2<font></font>
3<font></font>
4-5<font></font>
6<font></font>
6A<font></font>
6<font></font>
11<font></font>
12<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceux. </font><font style="vertical-align: inherit;">c'est en fait une cha√Æne, mais elle commence par un nombre, et vous devez trier par ces nombres. </font><font style="vertical-align: inherit;">Par cons√©quent, afin de trier correctement en tant que cha√Ænes, nous compl√©tons la partie num√©rique avec des z√©ros √† gauche pour obtenir:</font></font><br>
<br>
<pre><code class="plaintext hljs">0000000001<font></font>
0000000002<font></font>
0000000003<font></font>
0000000004-5<font></font>
0000000006<font></font>
0000000006A<font></font>
0000000006<font></font>
0000000011<font></font>
0000000012<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, je sais que ce n'est pas la seule solution au probl√®me (et m√™me pas tout √† fait raison). </font><font style="vertical-align: inherit;">Mais par exemple, cela suffira. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour demander un type, </font></font><code>SELECT ... ORDER BY nsort(n)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous √©crivons des fonctions en PL / Perl, SQL, PL / Python et PL / V8 qui convertissent les num√©ros de journal sous cette forme:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> nsort(<span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> PLPERL <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="perl">
    <span class="hljs-keyword">my</span> $x = <span class="hljs-keyword">shift</span>;
    <span class="hljs-keyword">return</span> ($x =~ <span class="hljs-regexp">/^\s*(\d+)(.*)$/</span>)
        ? <span class="hljs-keyword">sprintf</span>(<span class="hljs-string">"%010d"</span>, $1).$2
        : $x;
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> _nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span>
     <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">SQL</span>  <span class="hljs-keyword">IMMUTABLE</span>  <span class="hljs-keyword">AS</span> $$<span class="pgsql">
 <span class="hljs-keyword">WITH</span> y <span class="hljs-keyword">AS</span> (
    <span class="hljs-keyword">SELECT</span> regexp_match(x,<span class="hljs-string">'^\s*(\d*)(.*)$'</span>) <span class="hljs-keyword">as</span> z
 )
 <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> z[<span class="hljs-number">1</span>] = <span class="hljs-string">''</span> <span class="hljs-keyword">THEN</span> x <span class="hljs-keyword">ELSE</span> lpad(z[<span class="hljs-number">1</span>],<span class="hljs-number">10</span>,<span class="hljs-string">'0'</span>) || z[<span class="hljs-number">2</span>] <span class="hljs-keyword">END</span> <span class="hljs-keyword">FROM</span> y;
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> py_nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> plpython2u <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
<span class="hljs-keyword">import</span> re
r = re.match(<span class="hljs-string">'^\s*(\d+)(.*)$'</span>, x)
<span class="hljs-keyword">return</span> x <span class="hljs-keyword">if</span> r == <span class="hljs-keyword">None</span> <span class="hljs-keyword">else</span> (<span class="hljs-string">'%010d'</span> % <span class="hljs-type">int</span>(r.<span class="hljs-keyword">group</span>(<span class="hljs-number">1</span>))) + r.<span class="hljs-keyword">group</span>(<span class="hljs-number">2</span>)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> js_nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="ruby">
var m = x.match(<span class="hljs-regexp">/^\s*(\d+)(.*)$/</span>);
<span class="hljs-keyword">if</span>(m) { <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>].padStart(<span class="hljs-number">10</span>-m[<span class="hljs-number">1</span>].length,<span class="hljs-string">'0'</span>) + m[<span class="hljs-number">2</span>]; }
<span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> x; } 
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ma biblioth√®que de 15,5 mille articles de journaux, une requ√™te utilisant une fonction en PL / Perl prend environ 64 ms contre 120 ms en PL / Python et 200 ms en PL / PgSQL. </font><font style="vertical-align: inherit;">Mais le plus rapide - PL / v8: 54 ms. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lors de l'exp√©rimentation du tri, fournissez la quantit√© de m√©moire de travail n√©cessaire pour que le tri soit enregistr√© en m√©moire (EXPLAIN s'affiche alors </font></font><code>Sort Method: quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">La quantit√© de m√©moire est d√©finie par le param√®tre </font></font><code>work_mem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">set</span> work_mem = <span class="hljs-string">'20MB'</span>;
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©moire</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perl n'aime pas les structures en boucle, il ne sait pas comment les nettoyer. </font><font style="vertical-align: inherit;">Si vous </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avez un pointeur vers </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et un </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointeur vers </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le compteur de r√©f√©rence ne sera jamais r√©initialis√© et la m√©moire ne sera pas lib√©r√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les langues de r√©cup√©ration de place ont d'autres probl√®mes. </font><font style="vertical-align: inherit;">On ne sait pas, par exemple, quand la m√©moire sera lib√©r√©e ou si elle sera lib√©r√©e du tout. </font><font style="vertical-align: inherit;">Ou - si vous ne vous en occupez pas expr√®s - les collecteurs iront ramasser les ordures au moment le plus inopportun. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il existe √©galement des fonctionnalit√©s de gestion de la m√©moire directement li√©es √† Postgres. </font><font style="vertical-align: inherit;">Il existe des structures que SPI alloue, et Perl ne se rend pas toujours compte qu'elles doivent √™tre lib√©r√©es. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ce n'est PAS comme √ßa que √ßa se passe:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">return</span> spi_exec_query(
           <span class="hljs-string">'SELECT count(*) FROM pg_class'</span>
     )-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et il en va ainsi:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(
          <span class="hljs-string">'SELECT count(*) FROM pg_class'</span>
     );
     <span class="hljs-keyword">return</span> spi_exec_prepared($h)-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s l'ex√©cution, le gestionnaire </font></font><code>$h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">restera en vie, malgr√© le fait qu'il ne reste aucun lien vivant avec lui. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est bon, il vous suffit de vous rappeler la n√©cessit√© de lib√©rer explicitement les ressources avec </font></font><code>spi_freeplan($h)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     <span class="hljs-keyword">my</span> $res = spi_exec_prepared($h)-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
     spi_freeplan($h);
     <span class="hljs-keyword">return</span> $res;
$$</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Python </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne coule jamais</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le plan est automatiquement publi√©:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr3() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plpythonu <span class="hljs-keyword">as</span>
$$<span class="pgsql">
     <span class="hljs-keyword">return</span> plpy.<span class="hljs-keyword">execute</span>(
           <span class="hljs-string">'select count(*) from pg_class'</span>
     )[<span class="hljs-number">0</span>][<span class="hljs-string">'count'</span>]
$$</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
M√™me histoire que Perl. </font><font style="vertical-align: inherit;">√áa ne coule pas comme √ßa:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     <span class="hljs-keyword">return</span> plv8.<span class="hljs-keyword">execute</span>(
          <span class="hljs-string">'select count(*) from pg_class‚Äò
     )[0].count;
$$</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et il en va ainsi:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     var h = plv8.<span class="hljs-keyword">prepare</span>(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     <span class="hljs-keyword">return</span> h.<span class="hljs-keyword">execute</span>()[<span class="hljs-number">0</span>].count;
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encore une fois: n'oubliez pas de lib√©rer des ressources. </font><font style="vertical-align: inherit;">√áa y est, </font></font><code>h.free();</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√ßa ne coule pas:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     var h = plv8.<span class="hljs-keyword">prepare</span>(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     var r = h.<span class="hljs-keyword">execute</span>()[<span class="hljs-number">0</span>].count;
     h.free();
     <span class="hljs-keyword">return</span> r;
$$</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Param√®tres</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est temps de comprendre comment les arguments sont pass√©s aux fonctions. </font><font style="vertical-align: inherit;">Dans les exemples, nous passerons 4 param√®tres avec des types √† la fonction:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entier;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un tableau;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytea et</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsonb</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment </font><font style="vertical-align: inherit;">
entrent-ils dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ?</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq(a <span class="hljs-type">int</span>, b
<span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span> ) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
    <span class="hljs-keyword">warn</span> Dumper(@_);
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> crq(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  $VAR1 = '1';<font></font>
$VAR2 = '\\x61626364';<font></font>
$VAR3 = bless( {<font></font>
                 'array' =&gt; [<font></font>
                              '1',<font></font>
                              '2',<font></font>
                              '3'<font></font>
                            ],<font></font>
                 'typeoid' =&gt; 1007<font></font>
               }, 'PostgreSQL::InServer::ARRAY' );<font></font>
$VAR4 = '{"a": 2, "b": 3}';<font></font>
 crq <font></font>
-----<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sera-ce JSON ou JSONB - dans ce cas, cela ne fait aucune diff√©rence: ils se pr√©sentent toujours sous la forme d'une cha√Æne. Il s'agit d'une redevance pour la polyvalence: Postgres a beaucoup de types, de diff√©rents degr√©s de ¬´int√©gr√©¬ª. Demander au d√©veloppeur qu'avec le nouveau type il fournit imm√©diatement des fonctions de conversion pour tous les PL / * serait trop. Par d√©faut, de nombreux types sont transmis sous forme de cha√Ænes. Mais ce n'est pas toujours pratique, vous devez analyser ces termes. Bien s√ªr, j'aimerais que les donn√©es Postgres se transforment imm√©diatement en structures Perl appropri√©es. Par d√©faut, cela ne se produit pas, mais √† partir de 9.6, le m√©canisme TRANSFORM est apparu - la possibilit√© de d√©finir des fonctions de conversion de type: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CREATE TRANSFORM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour cr√©er TRANSFORM, vous devez √©crire deux fonctions en C: l'une convertira les donn√©es d'un certain type d'un c√¥t√©, de l'autre en arri√®re. </font><font style="vertical-align: inherit;">Veuillez noter que TRANSFORM fonctionne √† quatre endroits:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du passage de param√®tres √† une fonction;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du retour d'une valeur de fonction;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du passage de param√®tres √† un appel SPI √† l'int√©rieur d'une fonction;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√®s r√©ception du r√©sultat de l'appel SPI √† l'int√©rieur de la fonction.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TRANSFORM JSONB pour Perl et Python, d√©velopp√© par Anton Bykov, est apparu dans la 11e version de Postgres. </font><font style="vertical-align: inherit;">Maintenant, vous n'avez pas besoin d'analyser JSONB, il p√©n√®tre imm√©diatement dans Perl en tant que structure correspondante. </font><font style="vertical-align: inherit;">Vous devez cr√©er l'extension jsonb_plperl, puis vous pouvez utiliser TRANSFORM:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> jsonb_plperl;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq2(d <span class="hljs-type">jsonb</span>)
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span> <span class="hljs-keyword">LANGUAGE</span> plperl
<span class="hljs-keyword">TRANSFORM</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">jsonb</span> <span class="hljs-keyword">AS</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> Dumper(@_);
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez appeler cette fonction pour v√©rifier que JSONB est devenu un hachage perl√©:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> crq2( <span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  $VAR1 = {<font></font>
          'a' =&gt; '2',<font></font>
          'b' =&gt; '3'<font></font>
        };<font></font>
 crq2 <font></font>
------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une toute autre affaire! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'auteur de cet article a √©galement contribu√© au d√©veloppement de TRANSFORM. Il s'est av√©r√© qu'un type de donn√©es aussi simple, tel que </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transmis √† PL / Perl sous une forme incommode, comme des cha√Ænes de texte </font></font><code>'t'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>'f'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mais d'apr√®s Perl, la cha√Æne ¬´f¬ª est vraie. Pour √©liminer l'inconv√©nient, un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patch a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √©t√© invent√© </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">qui d√©finit la conversion pour le type bool√©en</font></a><font style="vertical-align: inherit;"> . Ce correctif a frapp√© PostgreSQL 13 et sera bient√¥t disponible. En raison de sa simplicit√©, bool_plperl peut servir de mod√®le de d√©part minimal pour √©crire toute autre conversion. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'esp√®re que quelqu'un d√©veloppera TRANSFORM pour d'autres types de donn√©es (bytea, tableaux, dates, num√©riques). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant comment les param√®tres sont pass√©s en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> jsonb_plpython3u;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> pdump(a <span class="hljs-type">int</span>, b <span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span> ) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plpython3u
<span class="hljs-keyword">TRANSFORM</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">jsonb</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
      plpy.<span class="hljs-built_in">warning</span>(a,b,c,d)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> pdump(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  (1, b'abcd', [1, 2, 3], {'a': Decimal('2'), 'b': Decimal('3')})<font></font>
 pdump <font></font>
-------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un tableau est converti en tableau - c'est bien (puisque les tableaux multidimensionnels de la version PG10 sont √©galement correctement transf√©r√©s vers python). </font><font style="vertical-align: inherit;">En Perl, un tableau a √©t√© converti en un objet d'une classe sp√©ciale. </font><font style="vertical-align: inherit;">Eh bien, </font></font><code>jsonb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transform√©. </font><font style="vertical-align: inherit;">Sans TRANSFORM, jsonb sera transmis sous forme de cha√Æne. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant sous quelle forme les param√®tres entrent dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> jsdump(a <span class="hljs-type">int</span>, b <span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span> $$<span class="pgsql">
     plv8.elog(<span class="hljs-built_in">WARNING</span>,a,b,c,d)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> jsdump(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  1 97,98,99,100 1,2,3 [object Object]<font></font>
jsdump <font></font>
-------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSONB converti en un objet JavaScript sans aucune TRANSFORMATION! </font><font style="vertical-align: inherit;">Les types Postgres temporaires sont √©galement convertis en type Date JS. </font><font style="vertical-align: inherit;">M√™me chose avec bool√©en. </font><font style="vertical-align: inherit;">Toutes les transformations sont d√©j√† int√©gr√©es dans PL / V8.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travaillez √† l'infini</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La constante INFINITY n'est pas utilis√©e tr√®s souvent, mais un travail b√¢cl√© avec elle est dangereux. </font><font style="vertical-align: inherit;">Dans PostgreSQL, Infinity et -Infinity existent en tant que valeurs sp√©ciales pour certains types temporaires et √† virgule flottante. </font><font style="vertical-align: inherit;">Mais le transfert d'Infinity vers les langages proc√©duraux et vice versa doit √™tre discut√© en d√©tail, car travailler avec eux peut d√©pendre non seulement de la langue, mais aussi des biblioth√®ques, du syst√®me d'exploitation et m√™me du mat√©riel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python poss√®de un module Numpy qui d√©finit l'infini num√©rique:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> nm<font></font>
a = nm.inf<font></font>
b = -nm.inf<font></font>
print(a, b)</code></pre><br>
<pre><code class="plaintext hljs">inf -inf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perl a √©galement l'infini, il utilise une cha√Æne </font></font><code>"infinity"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui peut √™tre raccourcie </font></font><code>"inf"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Par exemple, vous pourriez dire:</font></font><br>
<br>
<pre><code class="perl hljs">perl -e <span class="hljs-string">'print 1 * "inf"'</span></code></pre><br>
<pre><code class="plaintext hljs">Inf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ou</font></font><br>
<br>
<pre><code class="perl hljs">perl -e <span class="hljs-string">'print 1/"inf"'</span></code></pre><br>
<pre><code class="plaintext hljs">0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans PL / Perl, PL / Python, PL / v8, l'infini num√©rique de Postgres est pass√© correctement, mais la date infinie n'est pas tout √† fait correcte. </font><font style="vertical-align: inherit;">Au contraire, dans PL / Perl et PL / Python, il n'y a pas de type de donn√©es int√©gr√© pour l'heure, une cha√Æne vient l√†. </font><font style="vertical-align: inherit;">Dans PL / V8, il existe un type int√©gr√© Date, et la date habituelle d'un postgres se transforme en elle. </font><font style="vertical-align: inherit;">Mais le V8 ne conna√Æt pas la date sans fin, et une fois transf√©r√©, il se transforme en </font></font><code>Invalid Date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passer des param√®tres aux requ√™tes pr√©par√©es</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revenons √† </font></font><code>prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, consid√©rez comment les param√®tres y sont pass√©s. </font><font style="vertical-align: inherit;">Diff√©rentes langues ont beaucoup en commun, car elles sont toutes bas√©es sur SPI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous pr√©parez une requ√™te dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous devez d√©terminer le type de param√®tres transmis et lorsque vous ex√©cutez la requ√™te, vous sp√©cifiez uniquement les valeurs de ces param√®tres (les param√®tres sont transmis √† PL / pgSQL de la m√™me mani√®re).</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plperl $$<span class="perl">
     <span class="hljs-keyword">my</span> $h= spi_prepare(<span class="hljs-string">'SELECT * FROM pg_class WHERE
          relname ~ $1'</span>, <span class="hljs-string">'text'</span> );                     <span class="hljs-comment">#   </span>
     <span class="hljs-keyword">warn</span> Dumper(spi_exec_prepared($h, <span class="hljs-string">'pg_language'</span>)); <span class="hljs-comment">#   </span>
     spi_freeplan($h);
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python, l'</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> essence est la m√™me, mais la syntaxe est l√©g√®rement diff√©rente:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u $$<span class="pgsql">
     h= plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT relname FROM pg_class WHERE relname ~ $1'</span>, [<span class="hljs-string">'text'</span>] )
     plpy.<span class="hljs-keyword">notice</span>(.<span class="hljs-keyword">execute</span> ([<span class="hljs-string">'pg_language'</span>]))
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8, les</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diff√©rences sont minimes:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
    var h= plv8.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT relname FROM pg_class WHERE relname ~ $1'</span>, [<span class="hljs-string">'text'</span>] );
    plv8.elog(<span class="hljs-keyword">NOTICE</span>, h.<span class="hljs-keyword">execute</span> ([<span class="hljs-string">'pg_language'</span>]));
    h.free();
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Java,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tout est diff√©rent. </font><font style="vertical-align: inherit;">L√†, SPI n'est clairement pas utilis√©, mais une connexion pseudo-JDBC √† la base de donn√©es est √©tablie. </font><font style="vertical-align: inherit;">Pour un programmeur PL / Java, tout se passe comme s'il cr√©ait une application client. </font><font style="vertical-align: inherit;">C'est pratique, et on pourrait √©galement aborder la conception de PL / Perl et PL / Python, mais pour une raison quelconque, cela n'a pas √©t√© fait (cependant, personne n'interdit de cr√©er quelques impl√©mentations suppl√©mentaires de PL / Perl et PL / Python).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travailler avec le curseur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toutes les fonctions SPI que nous avons utilis√©es lorsque nous sommes all√©s dans la base de donn√©es - </font></font><code>spi_exec_query()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et d'autres - ont un param√®tre qui limite le nombre de lignes renvoy√©es. </font><font style="vertical-align: inherit;">Si vous avez besoin d'un grand nombre de lignes renvoy√©es, vous ne pouvez pas vous passer d'un curseur pour les remonter un peu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les curseurs travaillent dans toutes ces langues. </font><font style="vertical-align: inherit;">Dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl,</font></font></b> <br>
<code>spi_exec_query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> renvoie un curseur √† partir duquel vous pouvez extraire les cha√Ænes une √† la fois. </font><font style="vertical-align: inherit;">Il n'est pas n√©cessaire de fermer le curseur, il se fermera automatiquement. </font><font style="vertical-align: inherit;">Mais si vous souhaitez le red√©couvrir √† nouveau, vous pouvez le fermer explicitement avec une commande </font></font><code>close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plperl $$<span class="perl">
    <span class="hljs-keyword">my</span> $cursor = spi_query(<span class="hljs-string">'SELECT * FROM pg_class'</span>);
    <span class="hljs-keyword">my</span> $row;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">defined</span>($row = spi_fetchrow($cursor))) {
         <span class="hljs-keyword">warn</span> $row-&gt;{relname};
    }
$$</span>;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  pg_statistic at line 5.<font></font>
WARNING:  pg_toast_2604 at line 5.<font></font>
WARNING:  pg_toast_2604_index at line 5.<font></font>
WARNING:  pg_toast_2606 at line 5.<font></font>
WARNING:  pg_toast_2606_index at line 5.<font></font>
WARNING:  pg_toast_2609 at line 5.<font></font>
WARNING:  pg_toast_2609_index at line 5.<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tout est tr√®s similaire, mais le curseur est pr√©sent√© comme un objet que vous pouvez parcourir:</font></font><br>
<br>
<pre><code class="pgsql hljs">h = plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT ...'</span>);
<span class="hljs-keyword">cursor</span> = plpy.<span class="hljs-keyword">cursor</span>(h);
<span class="hljs-keyword">for</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">cursor</span>:<font></font>
...<font></font>
<span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>() //  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / v8,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tout est √©galement tr√®s similaire, mais n'oubliez pas de lib√©rer le plan de requ√™te pr√©par√©:</font></font><br>
<br>
<pre><code class="pgsql hljs">var h = plv.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT ...'</span>);<font></font>
var <span class="hljs-keyword">cursor</span> = h.<span class="hljs-keyword">cursor</span>();<font></font>
var <span class="hljs-keyword">row</span>;
<span class="hljs-keyword">while</span>(<span class="hljs-keyword">row</span> = <span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">fetch</span>()) {<font></font>
...<font></font>
}<font></font>
<span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>();<font></font>
h.free();</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8: Acc√®s rapide aux fonctionnalit√©s</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans PL / V8, vous pouvez appeler une fonction non pas √† partir d'un SELECT ordinaire, mais la trouver par son nom et la lancer imm√©diatement avec </font></font><code>plv8.find_function(name);</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais gardez √† l'esprit que dans JS, une fonction ne peut pas √™tre polymorphe, comme dans PostgreSQL, dans laquelle des fonctions portant le m√™me nom mais avec des param√®tres diff√©rents peuvent coexister. </font><font style="vertical-align: inherit;">En PL / v8, bien s√ªr, nous pouvons cr√©er des fonctions polymorphes, mais il y </font></font><code>find_function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aura une erreur </font><font style="vertical-align: inherit;">lors de la tentative d'utilisation </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="plaintext hljs">ERROR:  Error: more than one function named "jsdump"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si une fonction par son nom est sans ambigu√Øt√©, elle peut √™tre appel√©e sans SPI et conversions de type, c'est-√†-dire </font><font style="vertical-align: inherit;">Plus vite. </font><font style="vertical-align: inherit;">Par exemple, comme ceci:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="ruby">
plv8.find_function(<span class="hljs-string">'jsdump'</span>)(<span class="hljs-number">1</span>, <span class="hljs-string">'abc'</span>);
$$</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transactions</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres 11 a beaucoup de plaisir: de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vraies</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proc√©dures </font><font style="vertical-align: inherit;">sont apparues </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Postgres n'avait auparavant que des fonctionnalit√©s. </font><font style="vertical-align: inherit;">La joie n'est pas seulement due √† la compatibilit√© et au respect de la norme SQL, mais pourquoi: dans les proc√©dures, vous pouvez valider et annuler des transactions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Perl et PL / Python ont d√©j√† des fonctions SPI pour g√©rer les transactions, alors que PL / V8 n'en a pas encore. </font><font style="vertical-align: inherit;">Dans PL / Perl, ces fonctions sont appel√©es </font></font><code>spi_commit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>spi_rollback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et un exemple d'utilisation se trouve </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En PL / Python, c'est </font></font><code>plpy.commit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>plpy.rollback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sous-transaction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les sous-transactions sont pratiques pour la gestion correcte des erreurs dans une logique complexe √† plusieurs niveaux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL √† l'</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> int√©rieur d'une transaction, chaque bloc avec le mot-cl√© EXCEPTION est une sous-transaction. Vous pouvez lire sur certains probl√®mes de performances et de fiabilit√© qui peuvent survenir dans ce cas, par exemple, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'y a </font><font style="vertical-align: inherit;">pas de sous-transactions explicites </font><font style="vertical-align: inherit;">dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais elles peuvent √™tre simul√©es via des points de sauvegarde. Apparemment, si vous le souhaitez, il est facile d'√©crire un module Pearl qui impl√©mente les sous-transactions sous une forme explicite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python, les</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sous-transactions sont apparues il y a longtemps: de 9.5 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explicites</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , avant il y en avait </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implicitement</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Vous pouvez d√©finir une transaction, envelopper</font></font><code>try-</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ex√©cuter. </font><font style="vertical-align: inherit;">Si la sous-transaction tombe, alors nous tombons dans le bloc </font></font><code>except</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; si elle ne tombe pas, alors dans le bloc </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et continuons.</font></font><br>
<br>
<pre><code class="pgsql hljs">try:
     <span class="hljs-keyword">with</span> plpy.subtransaction():<font></font>
          plpy.<span class="hljs-keyword">execute</span>("...")<font></font>
          plpy.<span class="hljs-keyword">execute</span>("...")
<span class="hljs-keyword">except</span> plpy.SPIError, e:<font></font>
. . .<font></font>
<span class="hljs-keyword">else</span>:<font></font>
. . .</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une conception similaire existe en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , uniquement dans la syntaxe JS.</font></font><br>
<br>
<pre><code class="pgsql hljs">try {<font></font>
plv8.subtransaction(<span class="hljs-keyword">function</span>() {<font></font>
plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'UPDATE...'</span>);<font></font>
plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'UPDATE...'</span>);<font></font>
});<font></font>
}<font></font>
catch(e) {<font></font>
...<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayez, mais n'abusez pas :) La connaissance de PL / * peut apporter certains avantages. </font><font style="vertical-align: inherit;">Comme tout outil, ils adorent √™tre utilis√©s conform√©ment √† leur destination. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / v8 est tr√®s prometteur, mais il se comporte parfois de mani√®re inattendue et pr√©sente un certain nombre de probl√®mes. </font><font style="vertical-align: inherit;">Par cons√©quent, il est pr√©f√©rable de sortir les langues de la bo√Æte si elles conviennent √† votre t√¢che. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je remercie Igor Levshin (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Igor_Le</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), qui m'a beaucoup aid√© √† pr√©parer le mat√©riel pour l'article et a propos√© quelques id√©es utiles, ainsi que Yevgeny Sergeyev et Alexey Fadeev pour les corrections qu'ils ont propos√©es.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr502236/index.html">Mod√©lisation d'avions pour enfants - √† un niveau d√©cent</a></li>
<li><a href="../fr502246/index.html">Qu'est-ce que les r√©ponses audacieuses d'Alice ont en commun avec les drones?</a></li>
<li><a href="../fr502248/index.html">Un nouveau GOST pour les ressources num√©riques est entr√© en vigueur: toutes les plateformes doivent √™tre accessibles aux personnes handicap√©es</a></li>
<li><a href="../fr502250/index.html">L'aviation civile aujourd'hui: aspects et d√©fis importants de la formation</a></li>
<li><a href="../fr502252/index.html">T√©l√©commande et drones</a></li>
<li><a href="../fr502256/index.html">Comment visualiser un graphique d'int√©gration Spring √† l'aide de Neo4j?</a></li>
<li><a href="../fr502260/index.html">ESP-NOW est un protocole de communication alternatif pour ESP8266 et ESP32. Concepts de base</a></li>
<li><a href="../fr502262/index.html">Pourquoi les AIOps et la surveillance parapluie pour la banque, ou sur quoi se construisent les relations avec la client√®le</a></li>
<li><a href="../fr502264/index.html">Infrastructure √† cl√© publique. D√©livrance de certificats dans des conditions d'auto-isolement</a></li>
<li><a href="../fr502266/index.html">Aurora sur la plate-forme Intel. L'aube de l'√®re des exaflops</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>