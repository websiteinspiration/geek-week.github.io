<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍹 🕺🏾 ♑️ PostgreSQL: programmation côté serveur en langage humain (PL / Perl, PL / Python, PL / v8) 👩🏼‍🎨 ☝🏻 👽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Postgres est connu pour son extensibilité, qui s'applique également à la prise en charge des langages procéduraux (PL). Personne ne peut se vanter d'u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL: programmation côté serveur en langage humain (PL / Perl, PL / Python, PL / v8)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/502254/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postgres est connu pour son extensibilité, qui s'applique également à la prise en charge des langages procéduraux (PL). Personne ne peut se vanter d'une </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">langue avec une</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> liste de langues de cette longueur, et potentiellement cette liste n'est pas du tout limitée: pour connecter la langue au serveur, aucun effort supplémentaire n'est requis. Vous pouvez même créer votre propre langue et en faire un langage procédural pour le serveur. Les modifications dans le SGBD ne l'exigeront pas. Comme tant d'autres, cette extensibilité a été intégrée à l'architecture Postgres dès le début. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est possible et parfois nécessaire d'écrire des langages PL pour les tâches. Mieux encore, si quelqu'un écrit un tel cadre pour écrire des langages afin que vous puissiez écrire non pas en C, mais pour choisir un langage plus confortable pour un développeur de langage. Comme avec FDW, qui </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut être écrit en Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article a été rédigé sur la base d'un certain nombre de rapports et de master classes sur ce sujet réalisés par l'auteur lors des conférences </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PgConf.Russia 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PgConf.Russia 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DevConf 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il ne s'agit pas d'exotisme, mais des langages procéduraux les plus courants PL / Perl, PL / Python et PL / V8 (c'est-à-dire JavaScript) et de la comparaison de leurs capacités avec PL / pgSQL.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quand ces langues valent-elles la peine d'être utilisées? </font><font style="vertical-align: inherit;">Quand SQL et PL / pgSQL sont-ils manquants?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, lorsque vous devez travailler avec des structures complexes, avec des algorithmes: traverser des arbres, par exemple, ou quand une analyse HTML ou XML est requise, en particulier lors de leur extraction à partir d'archives;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous devez générer dynamiquement du SQL complexe (rapports, ORM). </font><font style="vertical-align: inherit;">Sur PL / pgSQL, ce n'est pas seulement gênant, mais cela fonctionnera aussi plus lentement dans certains cas;</font></font></li>
<li>         Perl  Python,        C/C++,      Perl  Python    .         . ,    Oracle.     ,    Postgres   .    Perl  Python  .</li>
<li>   —    .   , ,   untrusted- (  — . ),    Perlu  Python(3)u,    PL/V8.   Postgres  ,     ,   FDW,    ,         .       .  !</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et encore une chose: si vous allez écrire quelque chose en C, vous pouvez faire un prototype dans ces langages plus adaptés à un développement rapide.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment intégrer une langue dans Postgres</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour implémenter le langage dont vous avez besoin: écrivez en C de une à trois fonctions:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HANDLER - un gestionnaire d'appels qui exécutera une fonction dans le langage (c'est une partie obligatoire);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INLINE - gestionnaire de blocs anonymes (si vous voulez que la langue prenne en charge les blocs anonymes);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VALIDATOR - fonction de vérification de code lors de la création d'une fonction (si vous souhaitez que cette vérification soit effectuée).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est décrit en détail dans la documentation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Langues prêtes à l'emploi» et autres langues</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'y a que quatre langues prises en charge « </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prêtes à l'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> emploi </font><font style="vertical-align: inherit;">»: </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">PL / pgSQL</font></a><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Tcl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais le chatouillement est plutôt un hommage à l'histoire: peu de gens l'utilisent maintenant, nous n'en parlerons plus. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Perl, PL / Python et, bien sûr, PL / pgSQL sont pris en charge par la communauté Postgres. La prise en charge d'autres langues autres que celles de la boîte incombe à leurs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">responsables</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - entreprises, communautés ou développeurs spécifiques intéressés à faire fonctionner la langue à l'intérieur du SGBD. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fait la promotion de Google. Mais de temps en temps, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il y a des raisons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doute de l'avenir sans nuage du PL / V8. Le responsable actuel du projet PL / V8 de Google, Jerry Sievert, envisage la prise en charge JS sur serveur postgres basée sur un moteur différent (tel que QuickJS), car PL / V8 est difficile à construire et nécessite 3 à 5 Go toutes sortes de choses sur Linux lors de la construction, ce qui entraîne souvent des problèmes sur différents systèmes d'exploitation. Mais le PL / V8 est largement utilisé et soigneusement testé. Il est possible que PL / JS apparaisse comme une alternative à un autre moteur JS, ou pour l'instant juste comme un nom, auquel nous nous habituerons pendant la période de transition. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est rarement utilisé. Personnellement, je n'avais pas besoin d'écrire en PL / Java car en PL / Perl et en PL / V8 il y a suffisamment de fonctionnalités pour presque toutes les tâches. Même Python n'ajoute pas particulièrement de fonctionnalités. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / R</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utile pour ceux qui aiment les statistiques et aiment cette langue. Nous ne parlerons pas de lui ici non plus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les langages populaires ne sont pas nécessairement populaires avec les stockages d'écriture: il y a PL / PHP, mais maintenant il n'est pratiquement pris en charge par personne - rares sont ceux qui veulent y écrire des procédures serveur. Pour le langage PL / Ruby, l'image est en quelque sorte la même, bien que le langage semble être plus moderne. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un langage procédural basé sur Go est en cours de développement, voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Go</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et aussi, semble-t-il, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Lua</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il faudra les étudier. Pour les fans obstinés de la coque, il y a même </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Sh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il est même difficile d'imaginer à quoi cela pourrait servir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe au moins un langage procédural spécifique au domaine (DSL) qui est étroitement spécialisé pour sa tâche - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Proxy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui était très populaire pour le proxy et l'équilibrage de la charge du serveur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous couvrirons les principales langues les plus utilisées. Il s'agit bien sûr de PL / PgSQL, PL / Perl, PL / Python et PL / V8, nous les appellerons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ci-dessous </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les langues «prêtes à l'emploi» sont vraiment installées presque littéralement hors de la boîte - généralement l'installation est indolore. Mais pour installer PL / V8, si vous n'avez pas trouvé de package avec la version nécessaire dans le référentiel de votre système d'exploitation, c'est presque un exploit, car pour cela, vous devrez réellement construire l'intégralité du V8, ou, en d'autres termes, Chromium. Dans le même temps, l'intégralité de l'infrastructure de développement sera téléchargée sur google.com avec la V8 elle-même - comptez sur quelques gigaoctets de trafic. Pour Postgres 11 sous Ubuntu, le package PL / V8 n'est pas encore apparu, seul V8 pour PG 10 est disponible dans le référentiel jusqu'à présent. Si vous le souhaitez, assemblez-le à la main. Il est également important que la version que vous trouverez dans le référentiel soit probablement assez ancienne. Au moment de la publication de l'article, la dernière version est la 2.3.14.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois la langue installée, vous devez également «créer» la langue - enregistrez-la dans le répertoire système. </font><font style="vertical-align: inherit;">Cela devrait être fait par l'équipe.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> plperl;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(au lieu de plperl, vous pouvez remplacer le nom d'une autre langue, il y a certaines nuances, voir ci-dessous). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous regardons ce qui s'est passé:</font></font><br>
<br>
<pre><code class="plaintext hljs">test_langs=# \x<font></font>
test_langs=# \dL+<font></font>
List of languages<font></font>
-[ RECORD 1 ]-----+---------------------------------<font></font>
Name              | plperl<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plperl_call_handler()<font></font>
Validator         | plperl_validator(oid)<font></font>
Inline handler    | plperl_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       | PL/Perl procedural language<font></font>
-[ RECORD 2 ]-----+---------------------------------<font></font>
Name              | plpgsql<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plpgsql_call_handler()<font></font>
Validator         | plpgsql_validator(oid)<font></font>
Inline handler    | plpgsql_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       | PL/pgSQL procedural language<font></font>
[ RECORD 3 ]-----+---------------------------------<font></font>
Name              | plv8<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plv8_call_handler()<font></font>
Validator         | plv8_call_validator(oid)<font></font>
Inline handler    | plv8_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       |</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / pgSQL n'a pas besoin d'être spécialement créé, il est toujours déjà dans la base de données. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attention! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL ne doit pas être confondu avec SQL. </font><font style="vertical-align: inherit;">Ceci est une langue différente. </font><font style="vertical-align: inherit;">Cependant, Postgres peut également écrire des fonctions en SQL simple.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le monde du SGBD, ils parlent souvent de la conformité aux normes SQL. </font><font style="vertical-align: inherit;">Les langages procéduraux ont également des normes, même si on n'en parle pas si souvent. </font><font style="vertical-align: inherit;">La </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">norme SQL / PSM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est hautement compatible avec le langage procédural DB2. </font><font style="vertical-align: inherit;">Son implémentation est loin d'être PL / pgSQL, bien que conceptuellement elles soient proches. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL / JRT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la norme pour les procédures Java et PL / Java est une bonne correspondance.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langues fiables et non fiables</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les langages procéduraux PostgreSQL sont approuvés (TRUSTED) et non fiables (UNTRUSTED). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les langages de CONFIANCE, il n'y a aucune possibilité de travail direct avec les E / S, y compris le réseau, et même avec les ressources système. Par conséquent, de telles fonctions peuvent être créées par n'importe quel utilisateur de base de données, gâcher quelque chose et il ne pourra pas en apprendre trop. Les fonctions dans les langues NON CONTRÔLÉES ne peuvent être créées que par un superviseur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si l'interpréteur de langue prend en charge de telles restrictions, il peut être utilisé pour créer des langues TRUSTED et UNTRUSTED. Donc, avec Perl, il y a donc différentes langues </font></font><code>plperl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>plperlu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lettre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la fin, il donne le caractère non fiable de la langue. </font><font style="vertical-align: inherit;">Python n'existe que dans une version non fiable. </font><font style="vertical-align: inherit;">PL / v8 - au contraire, uniquement en confiance. </font><font style="vertical-align: inherit;">Par conséquent, PL / v8 ne peut charger aucun module ou bibliothèque à partir du disque, uniquement à partir de la base de données. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fonction dans le langage UNTRUSTED peut tout faire: envoyer un e-mail, envoyer une requête ping à un site, se connecter à une base de données étrangère et exécuter une requête HTTP. </font><font style="vertical-align: inherit;">Les langues de confiance sont limitées au traitement des données de la base de données. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En comprennent TRUSTED: </font></font><code>plpgsql, plperl, plv8, pljava</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En UNTRUSTED comprennent: </font></font><code>plperlu, pljavau, plpython2u, plpython3u</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remarque: il n'y a pas de PL / Python comme TRUSTED (car vous ne pouvez pas y définir de restrictions d'accès aux ressources), et PLpgSQL et PL / V8 sont l'inverse: ils ne sont pas INTRUSTRÉS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais Perl et Java sont disponibles dans les deux versions.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL vs PL / *</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code PL / pgSQL fonctionne nativement avec tous les types de données de Postgres. Les autres langues n'ont pas beaucoup de types Postgres, et l'interprète de langue se charge de convertir les données en une représentation interne de la langue, en remplaçant les types obscurs par du texte. Cependant, il peut être aidé avec l'aide de TRANSFORM, dont je parlerai plus près de la fin de l'article.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les appels de fonction en PL / pgSQL sont souvent plus chers. Les fonctions dans d'autres langues peuvent accéder à leurs bibliothèques sans consulter le catalogue système. PL / pgSQL ne peut pas fonctionner comme ça. Certaines requêtes en PL / pgSQL fonctionnent depuis longtemps en raison du fait que de nombreux types sont pris en charge: pour ajouter deux entiers, l'interpréteur doit se rendre compte qu'il traite des entiers et non d'autres types exotiques, puis décider comment les plier, et seulement après cela, les plier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que PL / pgSQL est TRUSTED, vous ne pouvez pas travailler avec le réseau et les disques de celui-ci. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'il s'agit de travailler avec des structures de données imbriquées, PL / pgSQL ne dispose que d'outils Postgres pour travailler avec JSON, qui sont très encombrants et improductifs, dans d'autres langues, travailler avec des structures imbriquées est beaucoup plus simple et plus économique.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / * possède sa propre gestion de la mémoire, et vous devez surveiller la mémoire, ou peut-être la limiter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez surveiller attentivement la gestion des erreurs, qui est également différente pour tout le monde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais dans PL / *, il existe un contexte d'interpréteur global, et il peut être utilisé, par exemple, pour mettre en cache des données, y compris des plans de requête. </font><font style="vertical-align: inherit;">Si la langue est NON CONFIÉE, le réseau et les lecteurs sont disponibles. </font><font style="vertical-align: inherit;">Toutes ces langues fonctionnent avec la base de données, en règle générale, via le SPI, mais plus à ce sujet plus tard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinons plus en détail les fonctionnalités des langages PL / *.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'interpréteur Perl est un morceau de code lourd en mémoire, mais heureusement, il n'est pas créé lorsque la connexion est ouverte, mais uniquement lorsque la première procédure / fonction stockée PL / Perl est lancée. </font><font style="vertical-align: inherit;">Une fois initialisé, le code spécifié dans les paramètres de configuration Postgres est exécuté. </font><font style="vertical-align: inherit;">Habituellement, les modules sont chargés et des précalculs sont effectués. </font><font style="vertical-align: inherit;">
Si vous avez ajouté au fichier de configuration pendant que la base de données est en cours d'exécution, demandez à Postgres de relire la configuration. </font><font style="vertical-align: inherit;">Dans cet article, les exemples utilisent un module </font><font style="vertical-align: inherit;">pour visualiser les structures de données. </font><font style="vertical-align: inherit;">
Il existe des paramètres pour l'initialisation séparée de Perl TRUSTED et UNTRUSTED et, bien sûr, un paramètre </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ceux qui programment en Perl savent que sans lui </font><font style="vertical-align: inherit;">ce n'est pas une langue, mais un malentendu.</font></font><br>
<br>
<code>plperl.on_init= 'use Data::Dumper;'<br>
plperl.on_plperl_init= ' ... '<br>
plperl.on_plperlu_init= ' ... '<br>
plperl.use_strict= on</code><br>
<br><font style="vertical-align: inherit;"></font><code>Data::Dumper</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>use_strict=on</code><font style="vertical-align: inherit;"></font><code>strict</code><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans celui-ci, l'interpréteur est créé de la même manière lors du premier accès. Et ici, il est important de décider immédiatement quel python vous voulez: deuxième ou troisième. Comme vous le savez, Python existe en deux versions populaires (Python 2 et Python 3), mais le problème est que leurs so-shki ne s'entendent pas en un seul processus: il y a un conflit de nom. Si vous avez travaillé avec v2 en une seule session puis appelé v3, Postgres se bloquera et pour le processus serveur (backend), ce sera une erreur fatale. Pour accéder à une autre version, vous devez ouvrir une autre session. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contrairement à Perl, python ne peut pas savoir quoi faire pendant l'initialisation. Autre inconvénient: les lignes simples ne sont pas pratiques à faire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans toutes les fonctions Python, deux dictionnaires sont définis - statique </font></font><code>SD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et global </font></font><code>GD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Global </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">échanger des données avec toutes les fonctions dans un seul backend - ce qui est à la fois attrayant et dangereux. </font><font style="vertical-align: inherit;">Chaque fonction possède un dictionnaire statique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En PL / Python, vous pouvez effectuer des sous-transactions, dont nous discuterons ci-dessous.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce n'est que de la CONFIANCE. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De manière pratique, les données JSON sont automatiquement converties en une structure JS. En PL / V8, comme en PL / Python, vous pouvez effectuer des sous-transactions. Il existe une interface pour les appels de fonction simplifiés. C'est le seul langage procédural en question dans lequel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des fonctions de fenêtre peuvent être définies</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ils suggèrent qu'ils </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peuvent être définis sur PL / R</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais ce langage sort du cadre de cet article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et ce n'est que dans PL / V8 qu'il y a un délai d'exécution. Certes, il n'est pas activé par défaut, et si vous construisez PL / V8 à la main, vous devez dire qu'il a été activé lors de l'assemblage, puis vous pouvez définir des délais d'expiration pour les appels de fonction avec le paramètre de configuration.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'initialisation dans PL / V8 semble intéressante: puisqu'elle est fiable, elle ne peut pas lire la bibliothèque à partir du disque, elle ne peut rien charger de n'importe où. </font><font style="vertical-align: inherit;">Il ne peut prendre tout ce dont il a besoin qu'à la base. </font><font style="vertical-align: inherit;">Par conséquent, une fonction d'initialisation stockée est définie et appelée au démarrage de l'interpréteur de langue. </font><font style="vertical-align: inherit;">Le nom de la fonction est spécifié dans un paramètre de configuration spécial:</font></font><br>
<br>
<pre><code class="pgsql hljs">plv8.start_proc=my_init # ( PL/V8-)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant l'initialisation, des variables et fonctions globales peuvent être créées en affectant leurs valeurs aux attributs de cette variable. </font><font style="vertical-align: inherit;">Par exemple, comme ceci:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> my_init()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span> <span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span> $$<span class="php">
     this.get_57 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">57</span>; }; <span class="hljs-comment">//   </span>
     this.pi_square = <span class="hljs-number">9.8696044</span>;  <span class="hljs-comment">//   </span>
$$</span>;
<span class="hljs-keyword">SET</span> plv8.start_proc = <span class="hljs-string">'my_init'</span>;
<span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, pi_square, get_57() );
$$</span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparaison de PL / Perl vs PL / Python vs PL / V8 en pratique</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour le monde!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faisons un exercice simple avec la sortie de cette phrase dans les trois langues, d'abord en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Et laissez-le faire autre chose d'utile, par exemple, raconte sa version:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     elog(<span class="hljs-keyword">NOTICE</span>,"Hello World! $]");
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  Hello World!<font></font>
DO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez également utiliser les fonctions Perl habituelles </font></font><code>warn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Plus précisément sur PL / Python3u (non approuvé) - pour plus de précision.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">import</span> sys
     plpy.<span class="hljs-keyword">notice</span>(<span class="hljs-string">'Hello World! '</span> , hint=" ", detail=sys.version_info)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
NOTICE:  Hello World! <font></font>
DETAIL:  sys.version_info(major=3, minor=6, micro=9, releaselevel='final', serial=0)<font></font>
HINT:   <font></font>
DO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peut utiliser </font></font><code>throw 'Errmsg'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il y a beaucoup de choses que vous pouvez extraire des messages Postgres: ils contiennent Hint, Details, numéro de ligne et de nombreux autres paramètres. </font><font style="vertical-align: inherit;">En PL / Python, ils peuvent être passés, mais pas dans les autres langages considérés: leurs moyens ne peuvent être maudits qu'avec une ligne de texte brut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En PL / Python, chaque niveau de journalisation postgres a sa propre fonction: AVIS, AVERTISSEMENT, DEBUG, LOG, INFO, FATAL. </font><font style="vertical-align: inherit;">Si c'est ERREUR, alors la transaction a chuté, si FATAL, le backend entier est tombé. </font><font style="vertical-align: inherit;">Heureusement, l'affaire n'a pas atteint la PANIQUE. </font><font style="vertical-align: inherit;">Vous pouvez </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lire ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans cette langue, Hello world est très similaire à la perle. </font><font style="vertical-align: inherit;">Vous pouvez arrêter d' </font></font><code>exception</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliser </font></font><code>throw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et ce sera également la gestion des erreurs, bien que les outils ne soient pas aussi avancés qu'en Python. </font><font style="vertical-align: inherit;">Si vous écrivez</font></font><code>plv8.elog(ERROR)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, l'effet sera d'ailleurs le même.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, <span class="hljs-string">'Hello World!'</span>, plv8.<span class="hljs-keyword">version</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  Hello World! 2.3.14<font></font>
DO<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travailler avec la base</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant comment travailler avec une base de données à partir de procédures stockées. Postgres dispose d'une SPI (Server Programming Interface). Il s'agit d'un ensemble de fonctions C disponibles pour tous les auteurs d'extensions. Presque tous les langages PL fournissent des wrappers pour SPI, mais chaque langue le fait un peu différemment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fonction écrite en C mais utilisant SPI est peu susceptible de donner un gain significatif par rapport à PL / PgSQL et à d'autres langages procéduraux. Mais une fonction C qui contourne SPI et fonctionne avec des données sans intermédiaires (par exemple </font></font><code>table_beginscan/heap_getnext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) fonctionnera beaucoup plus rapidement.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Java utilise également SPI. Mais travailler avec la base de données se fait toujours dans le style de JDBC et de la norme JDBC. Pour le créateur de code en PL / Java, tout se passe comme si vous travailliez à partir d'une application cliente, mais JNI (Java Native Interface) traduit les appels à la base de données dans les mêmes fonctions SPI. C'est pratique, et il n'y a pas d'obstacles fondamentaux pour traduire ce principe en PL / Perl et PL / Python, mais pour une raison quelconque, cela n'a pas été fait, et jusqu'à présent, il n'est pas visible dans les plans. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, si vous le souhaitez, vous pouvez vous rendre dans des bases étrangères de la manière habituelle - via DBI ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Psycopg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il est possible de créer une base de données locale, mais pourquoi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous n'entrez pas dans le sujet holistique «processus dans la base vs processus sur le client», et passez immédiatement du traitement maximal au plus près des données (au moins afin de ne pas conduire d'échantillons géants sur le réseau), alors la solution pour utiliser les fonctions stockées sur le serveur semble naturellement. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performances</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : gardez à l'esprit que SPI a des frais généraux et que les requêtes SQL dans les fonctions peuvent être plus lentes que sans fonctions. Le 13e postgres comprenait un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patch de Konstantin Knizhnik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui réduit ces coûts. Mais, bien sûr, le traitement des résultats de la requête dans une fonction stockée ne nécessite pas le transfert du résultat au client, et peut donc être bénéfique en termes de performances. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sécurité</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: un ensemble de fonctions déboguées et testées isole la structure de la base de données de l'utilisateur, protège contre les injections SQL et autres méfaits. </font><font style="vertical-align: inherit;">Sinon, cela restera un casse-tête pour tous les développeurs d'applications. </font><font style="vertical-align: inherit;">Réutilisation du </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : si un grand nombre d'applications complexes fonctionnent avec la base de données, il est pratique de stocker des fonctions utiles sur le serveur, plutôt que de les réécrire dans chaque application.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment et sous quelle forme obtenons-nous les données de la base de données</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tout est simple et clair. </font><font style="vertical-align: inherit;">L'appel </font></font><code>spi_exec_query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie le nombre de lignes traitées, l'état et le tableau de lignes sélectionnés par la requête SQL:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="ruby"> 
     warn Data::Dumper::Dumper(
          spi_exec_query(<span class="hljs-string">'SELECT 57 AS x'</span>)
     )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  $VAR1 = {<font></font>
          'rows' =&gt; [<font></font>
                    {<font></font>
                      'x' =&gt; '57'<font></font>
                    }<font></font>
                  ],<font></font>
          'processed' =&gt; 1,<font></font>
          'status' =&gt; 'SPI_OK_SELECT'<font></font>
        };<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python, la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requête et le résultat ressemblent à ceci, mais ici la fonction ne renvoie pas une structure de données, mais un objet spécial avec lequel vous pouvez travailler de différentes manières. </font><font style="vertical-align: inherit;">Habituellement, il prétend être un tableau et, en conséquence, vous pouvez en extraire des chaînes.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plpy.<span class="hljs-keyword">notice</span>(
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 AS x'</span>)
     )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  &lt;PLyResult status=5 nrows=1 rows=[{'x': 57}]&gt;<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant, nous prenons la 1ère ligne, sortons de là X et obtenons la valeur - le nombre.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plpy.<span class="hljs-keyword">notice</span>(
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 AS x'</span>)[<span class="hljs-number">0</span>][<span class="hljs-string">'x'</span>]
      )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  57<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, <span class="hljs-type">JSON</span>.stringify(
          plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 as x'</span>))
     );
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  [{"x":57}]<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour voir la structure, nous avons utilisé la fonction de bibliothèque JSON.stringify, qui n'a pas besoin d'être chargée spécifiquement, elle est déjà prête à être utilisée par défaut dans PL / v8. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blindage</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour éviter les injections SQL malveillantes, certains caractères des requêtes doivent être échappés. Pour ce faire, tout d'abord, il existe des fonctions SPI et des fonctions correspondantes (écrites en C) dans des langages qui fonctionnent comme des wrappers SPI. Par exemple, en PL / Perl: </font></font><br>
<br>
<code>quote_literal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- prend les apostrophes et les doubles 'et \. Conçu pour filtrer les données de texte. </font></font><br>
<code>quote_nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- identique, mais </font></font><code>undef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">converti en NULL. </font></font><br>
<code>quote_ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- cite le nom de la table ou du champ, si nécessaire. Utile dans le cas où vous créez une requête SQL et remplacez-y les noms des objets de base de données. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> <span class="hljs-string">"macy's"</span>;
     <span class="hljs-keyword">warn</span> quote_literal(<span class="hljs-string">"macy's"</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  macy's at line 2.<font></font>
WARNING:  'macy''s' at line 3.<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gardez à l'esprit: le nom de la table ne doit pas être échappé comme une ligne de texte. </font><font style="vertical-align: inherit;">C'est pourquoi il y a une fonction </font></font><code>quote_ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais dans PL / Perl, il existe d'autres fonctions pour le blindage des données de types post-gres individuels: </font><font style="vertical-align: inherit;">
Une fonction </font><font style="vertical-align: inherit;">doit accepter n'importe quel type et transformer les caractères douteux atypiques en quelque chose de évidemment sûr. </font><font style="vertical-align: inherit;">Il fonctionne avec un grand nombre de types, mais pas avec tous. </font><font style="vertical-align: inherit;">Elle, par exemple, ne comprend pas les </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">types de plage</font></a><font style="vertical-align: inherit;"> et ne les perçoit que comme des chaînes de texte.</font></font><br>
<br>
<code>encode_bytea<br>
decode_bytea<br>
encode_array_literal<br>
encode_typed_literal<br>
encode_array_constructor</code><br>
<br><font style="vertical-align: inherit;"></font><code>quote_typed_literal</code><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> encode_typed_literal(
          [<span class="hljs-string">""</span>, <span class="hljs-string">" "</span>], <span class="hljs-string">"text[]"</span>
     );
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  {," "} at line 2.<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il </font><font style="vertical-align: inherit;">existe trois fonctions similaires </font><font style="vertical-align: inherit;">dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et elles fonctionnent de la même manière:</font></font><br>
<br>
<code>plpy.quote_literal<br>
plpy.quote_nullable<br>
plpy.quote_ident</code><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> plpy.<span class="hljs-keyword">notice</span>(
     plpy.quote_literal("Macy's"));
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><pre><code class="plaintext hljs">NOTICE:  'Macy''s'<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les fonctions de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8 sont-elles les</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mêmes </font><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr! </font><font style="vertical-align: inherit;">Tout est le même jusqu'aux fonctionnalités syntaxiques.</font></font><br>
<br>
<code>plv8.quote_literal<br>
plv8.quote_nullable<br>
plv8.quote_ident</code><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
    plv8.elog(<span class="hljs-keyword">NOTICE</span>, plv8.quote_nullable("Macy's"));
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  'Macy''s'</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle langue est la plus rapide? Habituellement, ils répondent: C. Mais la bonne réponse est C </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SQL. Pourquoi SQL? Le fait est qu'une fonction dans ce langage n'est pas toujours exécutée explicitement. Il peut être intégré dans la requête (le planificateur incorporera la fonction dans le corps de la requête principale), s'optimisera bien avec la requête et le résultat sera plus rapide. Mais dans quelles conditions le code peut-il être intégré dans une requête? Il y a quelques conditions simples que vous pouvez lire, par </font><font style="vertical-align: inherit;">exemple, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Par exemple, une fonction ne doit pas être exécutée avec les droits du propriétaire (être SECURITY DEFINER). La plupart des fonctions simples répondent à ces conditions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article nous mesurerons "sur le genou", pas sérieusement. Nous avons besoin d'une comparaison grossière. Allumez d'abord le timing:</font></font><br>
<br>
<pre><code class="plaintext hljs">\timing</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Les temps d'exécution des commandes ci-dessous sont les valeurs moyennes arrondies que l'auteur a reçues sur un PC déchargé de six ans. Ils peuvent être comparés entre eux, mais ils ne prétendent pas être scientifiques):</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">FROM</span> pg_class;
<span class="hljs-number">0.5</span> ms
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela fonctionne très rapidement. </font><font style="vertical-align: inherit;">Dans d'autres langues, le temps est perdu à appeler des fonctions de la langue. </font><font style="vertical-align: inherit;">Bien sûr, la première fois que la requête s'exécutera plus lentement en raison de l'initialisation de l'interpréteur. </font><font style="vertical-align: inherit;">Ensuite, il se stabilise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">int</span>;
     <span class="hljs-keyword">BEGIN</span>
          <span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> pg_class;
     <span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">0.7</span> ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $x = spi_exec_query(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">0.7</span> ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python:</font></font></b><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     x = plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpythonu;
<span class="hljs-number">0.8</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'était Python 2. Maintenant </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (rappel: Python2 et Python3 ne vivent pas paisiblement dans la même session, un conflit de noms est possible):</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     x = plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">0.9</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et enfin, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     var x = plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8 ;
<span class="hljs-number">0.9</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais c'est en quelque sorte très rapide. </font><font style="vertical-align: inherit;">Essayons d'exécuter la requête 1000 fois ou 1 million de fois, soudain la différence sera plus sensible: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">int</span>; i <span class="hljs-type">int</span>;
     <span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">0.</span><span class="hljs-number">.999999</span> <span class="hljs-keyword">LOOP</span>
          <span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> pg_class;
    <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
<span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">53</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="ruby">
     <span class="hljs-keyword">for</span> (<span class="hljs-number">0</span>..<span class="hljs-number">999999</span>) {
          spi_exec_query(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     }
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">102</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>,<span class="hljs-number">1000000</span>) :
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">98</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)
          plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;
<span class="hljs-number">100</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notez qu'avec PL / V8, l'expérience a été faite avec mille, pas un million d'itérations. Avec des ressources modérées, le PL / V8 dans un cycle de 1 million d'opérations mangera toute la mémoire et accrochera complètement la voiture. Déjà à mille itérations, le processus postgres sélectionne 3,5 Go de mémoire et 100% d'écriture sur le disque. En fait, postgres lance l'environnement V8, et bien sûr, il mange de la mémoire. Après avoir exécuté la requête, ce monstre turbo ne va pas rendre de mémoire. Pour libérer de la mémoire, vous devez mettre fin à la session. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On voit que PL / pgSQL est déjà 2 fois plus rapide que PL / Perl et PL / Python. PL / V8 est encore légèrement derrière eux, mais vers la fin de l'article, il est partiellement réhabilité.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, Perl avec Python dans ces expériences montre approximativement les mêmes résultats. </font><font style="vertical-align: inherit;">Perl était légèrement inférieur à Python; dans les versions modernes, il est légèrement plus rapide. </font><font style="vertical-align: inherit;">Le troisième python est légèrement plus lent que le second. </font><font style="vertical-align: inherit;">La différence totale se situe à moins de 15%.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance avec PREPARE</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les gens qui savent comprendront: quelque chose ne va pas. </font><font style="vertical-align: inherit;">PL / pgSQL peut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">automatiquement mettre en cache les plans de requête</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et dans PL / *, chaque fois que la requête a été planifiée à nouveau. </font><font style="vertical-align: inherit;">Dans le bon sens, vous devez préparer des demandes, créer un plan de demande, puis selon ce plan, elles doivent être exécutées autant de fois que nécessaire. </font><font style="vertical-align: inherit;">Dans PL / *, vous pouvez explicitement travailler avec des plans de requête, que nous allons essayer de commencer avec </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     <span class="hljs-keyword">for</span> (<span class="hljs-number">0</span>..<span class="hljs-number">999999</span>) {
          spi_exec_prepared($h);
     }
     spi_freeplan($h);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">60</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     h = plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>)
     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>,<span class="hljs-number">1000000</span>): plpy.<span class="hljs-keyword">execute</span>(h)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">62</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     var h=plv8.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++) h.<span class="hljs-keyword">execute</span>();
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;
<span class="hljs-number">53</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec </font></font><code>prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nos deux langues, nous avons presque rattrapé PL / pgSQL, tandis que le troisième le voulait aussi, mais n'a pas atteint la ligne d'arrivée en raison de la demande croissante de mémoire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais si vous ne tenez pas compte de la mémoire, il est clair que toutes les langues vont presque de pair - et pas par hasard. </font><font style="vertical-align: inherit;">Leur goulot d'étranglement est maintenant commun - travailler avec la base de données via SPI.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performances informatiques</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous voyons que la performance du langage repose sur le travail avec la base de données. </font><font style="vertical-align: inherit;">Pour comparer les langues entre elles, essayons de calculer quelque chose sans avoir recours à la base de données, par exemple, la somme des carrés. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">bigint</span>; a <span class="hljs-type">bigint</span>;
     <span class="hljs-keyword">BEGIN</span> a=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">0.</span><span class="hljs-number">.1000000</span> <span class="hljs-keyword">LOOP</span>
          a=a+i*i::<span class="hljs-type">bigint</span>;
     <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
<span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">280</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $a=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> $i (<span class="hljs-number">0</span>..<span class="hljs-number">1000000</span>) { $a+=$i*$i; };
     <span class="hljs-keyword">warn</span> $a;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">63</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
a=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">1000001</span>): a=a+i*i
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">73</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="plaintext hljs">DO $$<font></font>
     var a=0;<font></font>
     for(var i=0;i&lt;=1000000;i++) a+=i*i;<font></font>
     plv8.elog(NOTICE, a);<font></font>
$$ language plv8;<font></font>
7.5ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On voit que PL / Perl et PL / Python ont dépassé et dépassé PL / pgSQL, ils sont 4 fois plus rapides. </font><font style="vertical-align: inherit;">Et le huit déchire tout le monde! </font><font style="vertical-align: inherit;">Mais est-ce vraiment pour rien? </font><font style="vertical-align: inherit;">Ou allons-nous l'obtenir pour la tête? </font><font style="vertical-align: inherit;">Oui nous le ferons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le nombre en JavaScript est un flottant, et le résultat est rapide, mais pas précis: 333333833333127550 au lieu de 333333833333500000. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici la formule par laquelle le résultat exact est </font><font style="vertical-align: inherit;">calculé </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">∑ = n*(n+1)*(2n+1)/6
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme exercice, vous pouvez le prouver en utilisant l'induction mathématique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'ordre du rire</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
plv8.elog(<span class="hljs-keyword">NOTICE</span>, parseInt(<span class="hljs-number">33333383333312755033</span>)) $$</span>;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:<font></font>
33333383333312754000</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Javascript, </font></font><code>parseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il fait toujours un float, pas un Int. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Néanmoins, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BigInt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est apparu dans V8 en 2018 </font><font style="vertical-align: inherit;">, et il peut maintenant être compté avec certitude, mais au détriment de la vitesse, car il ne s'agit pas d'un entier 64 bits, mais d'un entier de profondeur de bits arbitraire. </font><font style="vertical-align: inherit;">Cependant, en PL / V8, cette innovation n'a pas encore frappé. </font><font style="vertical-align: inherit;">Dans d'autres langages procéduraux, les nombres de bits arbitraires (analogues de SQL </font></font><code>numeric</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) sont pris en charge via des bibliothèques spéciales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Perl, il existe un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">module Math :: BigFloat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour l'arithmétique avec une précision arbitraire, et en Python le package </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bigfloat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un wrapper </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cython</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> autour de la bibliothèque </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU MPFR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonctions de performance pour le tri</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un exemple pratique, qui montre la différence dans les performances de tri par fonction, si cette fonction est écrite dans différentes langues. </font><font style="vertical-align: inherit;">Tâche: trier les champs de texte contenant les numéros des numéros de la revue, qui peuvent être les suivants:</font></font><br>
<br>
<pre><code class="plaintext hljs">1<font></font>
2<font></font>
3<font></font>
4-5<font></font>
6<font></font>
6A<font></font>
6<font></font>
11<font></font>
12<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceux. </font><font style="vertical-align: inherit;">c'est en fait une chaîne, mais elle commence par un nombre, et vous devez trier par ces nombres. </font><font style="vertical-align: inherit;">Par conséquent, afin de trier correctement en tant que chaînes, nous complétons la partie numérique avec des zéros à gauche pour obtenir:</font></font><br>
<br>
<pre><code class="plaintext hljs">0000000001<font></font>
0000000002<font></font>
0000000003<font></font>
0000000004-5<font></font>
0000000006<font></font>
0000000006A<font></font>
0000000006<font></font>
0000000011<font></font>
0000000012<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, je sais que ce n'est pas la seule solution au problème (et même pas tout à fait raison). </font><font style="vertical-align: inherit;">Mais par exemple, cela suffira. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour demander un type, </font></font><code>SELECT ... ORDER BY nsort(n)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous écrivons des fonctions en PL / Perl, SQL, PL / Python et PL / V8 qui convertissent les numéros de journal sous cette forme:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> nsort(<span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> PLPERL <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="perl">
    <span class="hljs-keyword">my</span> $x = <span class="hljs-keyword">shift</span>;
    <span class="hljs-keyword">return</span> ($x =~ <span class="hljs-regexp">/^\s*(\d+)(.*)$/</span>)
        ? <span class="hljs-keyword">sprintf</span>(<span class="hljs-string">"%010d"</span>, $1).$2
        : $x;
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> _nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span>
     <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">SQL</span>  <span class="hljs-keyword">IMMUTABLE</span>  <span class="hljs-keyword">AS</span> $$<span class="pgsql">
 <span class="hljs-keyword">WITH</span> y <span class="hljs-keyword">AS</span> (
    <span class="hljs-keyword">SELECT</span> regexp_match(x,<span class="hljs-string">'^\s*(\d*)(.*)$'</span>) <span class="hljs-keyword">as</span> z
 )
 <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> z[<span class="hljs-number">1</span>] = <span class="hljs-string">''</span> <span class="hljs-keyword">THEN</span> x <span class="hljs-keyword">ELSE</span> lpad(z[<span class="hljs-number">1</span>],<span class="hljs-number">10</span>,<span class="hljs-string">'0'</span>) || z[<span class="hljs-number">2</span>] <span class="hljs-keyword">END</span> <span class="hljs-keyword">FROM</span> y;
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> py_nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> plpython2u <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
<span class="hljs-keyword">import</span> re
r = re.match(<span class="hljs-string">'^\s*(\d+)(.*)$'</span>, x)
<span class="hljs-keyword">return</span> x <span class="hljs-keyword">if</span> r == <span class="hljs-keyword">None</span> <span class="hljs-keyword">else</span> (<span class="hljs-string">'%010d'</span> % <span class="hljs-type">int</span>(r.<span class="hljs-keyword">group</span>(<span class="hljs-number">1</span>))) + r.<span class="hljs-keyword">group</span>(<span class="hljs-number">2</span>)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> js_nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="ruby">
var m = x.match(<span class="hljs-regexp">/^\s*(\d+)(.*)$/</span>);
<span class="hljs-keyword">if</span>(m) { <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>].padStart(<span class="hljs-number">10</span>-m[<span class="hljs-number">1</span>].length,<span class="hljs-string">'0'</span>) + m[<span class="hljs-number">2</span>]; }
<span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> x; } 
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ma bibliothèque de 15,5 mille articles de journaux, une requête utilisant une fonction en PL / Perl prend environ 64 ms contre 120 ms en PL / Python et 200 ms en PL / PgSQL. </font><font style="vertical-align: inherit;">Mais le plus rapide - PL / v8: 54 ms. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lors de l'expérimentation du tri, fournissez la quantité de mémoire de travail nécessaire pour que le tri soit enregistré en mémoire (EXPLAIN s'affiche alors </font></font><code>Sort Method: quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">La quantité de mémoire est définie par le paramètre </font></font><code>work_mem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">set</span> work_mem = <span class="hljs-string">'20MB'</span>;
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mémoire</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perl n'aime pas les structures en boucle, il ne sait pas comment les nettoyer. </font><font style="vertical-align: inherit;">Si vous </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avez un pointeur vers </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et un </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointeur vers </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le compteur de référence ne sera jamais réinitialisé et la mémoire ne sera pas libérée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les langues de récupération de place ont d'autres problèmes. </font><font style="vertical-align: inherit;">On ne sait pas, par exemple, quand la mémoire sera libérée ou si elle sera libérée du tout. </font><font style="vertical-align: inherit;">Ou - si vous ne vous en occupez pas exprès - les collecteurs iront ramasser les ordures au moment le plus inopportun. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il existe également des fonctionnalités de gestion de la mémoire directement liées à Postgres. </font><font style="vertical-align: inherit;">Il existe des structures que SPI alloue, et Perl ne se rend pas toujours compte qu'elles doivent être libérées. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ce n'est PAS comme ça que ça se passe:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">return</span> spi_exec_query(
           <span class="hljs-string">'SELECT count(*) FROM pg_class'</span>
     )-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et il en va ainsi:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(
          <span class="hljs-string">'SELECT count(*) FROM pg_class'</span>
     );
     <span class="hljs-keyword">return</span> spi_exec_prepared($h)-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après l'exécution, le gestionnaire </font></font><code>$h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">restera en vie, malgré le fait qu'il ne reste aucun lien vivant avec lui. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est bon, il vous suffit de vous rappeler la nécessité de libérer explicitement les ressources avec </font></font><code>spi_freeplan($h)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     <span class="hljs-keyword">my</span> $res = spi_exec_prepared($h)-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
     spi_freeplan($h);
     <span class="hljs-keyword">return</span> $res;
$$</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Python </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne coule jamais</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le plan est automatiquement publié:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr3() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plpythonu <span class="hljs-keyword">as</span>
$$<span class="pgsql">
     <span class="hljs-keyword">return</span> plpy.<span class="hljs-keyword">execute</span>(
           <span class="hljs-string">'select count(*) from pg_class'</span>
     )[<span class="hljs-number">0</span>][<span class="hljs-string">'count'</span>]
$$</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Même histoire que Perl. </font><font style="vertical-align: inherit;">Ça ne coule pas comme ça:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     <span class="hljs-keyword">return</span> plv8.<span class="hljs-keyword">execute</span>(
          <span class="hljs-string">'select count(*) from pg_class‘
     )[0].count;
$$</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et il en va ainsi:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     var h = plv8.<span class="hljs-keyword">prepare</span>(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     <span class="hljs-keyword">return</span> h.<span class="hljs-keyword">execute</span>()[<span class="hljs-number">0</span>].count;
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encore une fois: n'oubliez pas de libérer des ressources. </font><font style="vertical-align: inherit;">Ça y est, </font></font><code>h.free();</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ça ne coule pas:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     var h = plv8.<span class="hljs-keyword">prepare</span>(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     var r = h.<span class="hljs-keyword">execute</span>()[<span class="hljs-number">0</span>].count;
     h.free();
     <span class="hljs-keyword">return</span> r;
$$</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paramètres</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est temps de comprendre comment les arguments sont passés aux fonctions. </font><font style="vertical-align: inherit;">Dans les exemples, nous passerons 4 paramètres avec des types à la fonction:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entier;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un tableau;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytea et</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsonb</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment </font><font style="vertical-align: inherit;">
entrent-ils dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ?</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq(a <span class="hljs-type">int</span>, b
<span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span> ) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
    <span class="hljs-keyword">warn</span> Dumper(@_);
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> crq(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  $VAR1 = '1';<font></font>
$VAR2 = '\\x61626364';<font></font>
$VAR3 = bless( {<font></font>
                 'array' =&gt; [<font></font>
                              '1',<font></font>
                              '2',<font></font>
                              '3'<font></font>
                            ],<font></font>
                 'typeoid' =&gt; 1007<font></font>
               }, 'PostgreSQL::InServer::ARRAY' );<font></font>
$VAR4 = '{"a": 2, "b": 3}';<font></font>
 crq <font></font>
-----<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sera-ce JSON ou JSONB - dans ce cas, cela ne fait aucune différence: ils se présentent toujours sous la forme d'une chaîne. Il s'agit d'une redevance pour la polyvalence: Postgres a beaucoup de types, de différents degrés de «intégré». Demander au développeur qu'avec le nouveau type il fournit immédiatement des fonctions de conversion pour tous les PL / * serait trop. Par défaut, de nombreux types sont transmis sous forme de chaînes. Mais ce n'est pas toujours pratique, vous devez analyser ces termes. Bien sûr, j'aimerais que les données Postgres se transforment immédiatement en structures Perl appropriées. Par défaut, cela ne se produit pas, mais à partir de 9.6, le mécanisme TRANSFORM est apparu - la possibilité de définir des fonctions de conversion de type: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CREATE TRANSFORM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour créer TRANSFORM, vous devez écrire deux fonctions en C: l'une convertira les données d'un certain type d'un côté, de l'autre en arrière. </font><font style="vertical-align: inherit;">Veuillez noter que TRANSFORM fonctionne à quatre endroits:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du passage de paramètres à une fonction;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du retour d'une valeur de fonction;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du passage de paramètres à un appel SPI à l'intérieur d'une fonction;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dès réception du résultat de l'appel SPI à l'intérieur de la fonction.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TRANSFORM JSONB pour Perl et Python, développé par Anton Bykov, est apparu dans la 11e version de Postgres. </font><font style="vertical-align: inherit;">Maintenant, vous n'avez pas besoin d'analyser JSONB, il pénètre immédiatement dans Perl en tant que structure correspondante. </font><font style="vertical-align: inherit;">Vous devez créer l'extension jsonb_plperl, puis vous pouvez utiliser TRANSFORM:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> jsonb_plperl;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq2(d <span class="hljs-type">jsonb</span>)
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span> <span class="hljs-keyword">LANGUAGE</span> plperl
<span class="hljs-keyword">TRANSFORM</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">jsonb</span> <span class="hljs-keyword">AS</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> Dumper(@_);
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez appeler cette fonction pour vérifier que JSONB est devenu un hachage perlé:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> crq2( <span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  $VAR1 = {<font></font>
          'a' =&gt; '2',<font></font>
          'b' =&gt; '3'<font></font>
        };<font></font>
 crq2 <font></font>
------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une toute autre affaire! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'auteur de cet article a également contribué au développement de TRANSFORM. Il s'est avéré qu'un type de données aussi simple, tel que </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transmis à PL / Perl sous une forme incommode, comme des chaînes de texte </font></font><code>'t'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>'f'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mais d'après Perl, la chaîne «f» est vraie. Pour éliminer l'inconvénient, un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patch a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> été inventé </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">qui définit la conversion pour le type booléen</font></a><font style="vertical-align: inherit;"> . Ce correctif a frappé PostgreSQL 13 et sera bientôt disponible. En raison de sa simplicité, bool_plperl peut servir de modèle de départ minimal pour écrire toute autre conversion. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'espère que quelqu'un développera TRANSFORM pour d'autres types de données (bytea, tableaux, dates, numériques). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant comment les paramètres sont passés en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> jsonb_plpython3u;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> pdump(a <span class="hljs-type">int</span>, b <span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span> ) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plpython3u
<span class="hljs-keyword">TRANSFORM</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">jsonb</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
      plpy.<span class="hljs-built_in">warning</span>(a,b,c,d)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> pdump(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  (1, b'abcd', [1, 2, 3], {'a': Decimal('2'), 'b': Decimal('3')})<font></font>
 pdump <font></font>
-------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un tableau est converti en tableau - c'est bien (puisque les tableaux multidimensionnels de la version PG10 sont également correctement transférés vers python). </font><font style="vertical-align: inherit;">En Perl, un tableau a été converti en un objet d'une classe spéciale. </font><font style="vertical-align: inherit;">Eh bien, </font></font><code>jsonb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transformé. </font><font style="vertical-align: inherit;">Sans TRANSFORM, jsonb sera transmis sous forme de chaîne. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant sous quelle forme les paramètres entrent dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> jsdump(a <span class="hljs-type">int</span>, b <span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span> $$<span class="pgsql">
     plv8.elog(<span class="hljs-built_in">WARNING</span>,a,b,c,d)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> jsdump(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  1 97,98,99,100 1,2,3 [object Object]<font></font>
jsdump <font></font>
-------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSONB converti en un objet JavaScript sans aucune TRANSFORMATION! </font><font style="vertical-align: inherit;">Les types Postgres temporaires sont également convertis en type Date JS. </font><font style="vertical-align: inherit;">Même chose avec booléen. </font><font style="vertical-align: inherit;">Toutes les transformations sont déjà intégrées dans PL / V8.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travaillez à l'infini</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La constante INFINITY n'est pas utilisée très souvent, mais un travail bâclé avec elle est dangereux. </font><font style="vertical-align: inherit;">Dans PostgreSQL, Infinity et -Infinity existent en tant que valeurs spéciales pour certains types temporaires et à virgule flottante. </font><font style="vertical-align: inherit;">Mais le transfert d'Infinity vers les langages procéduraux et vice versa doit être discuté en détail, car travailler avec eux peut dépendre non seulement de la langue, mais aussi des bibliothèques, du système d'exploitation et même du matériel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python possède un module Numpy qui définit l'infini numérique:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> nm<font></font>
a = nm.inf<font></font>
b = -nm.inf<font></font>
print(a, b)</code></pre><br>
<pre><code class="plaintext hljs">inf -inf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perl a également l'infini, il utilise une chaîne </font></font><code>"infinity"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui peut être raccourcie </font></font><code>"inf"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Par exemple, vous pourriez dire:</font></font><br>
<br>
<pre><code class="perl hljs">perl -e <span class="hljs-string">'print 1 * "inf"'</span></code></pre><br>
<pre><code class="plaintext hljs">Inf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ou</font></font><br>
<br>
<pre><code class="perl hljs">perl -e <span class="hljs-string">'print 1/"inf"'</span></code></pre><br>
<pre><code class="plaintext hljs">0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans PL / Perl, PL / Python, PL / v8, l'infini numérique de Postgres est passé correctement, mais la date infinie n'est pas tout à fait correcte. </font><font style="vertical-align: inherit;">Au contraire, dans PL / Perl et PL / Python, il n'y a pas de type de données intégré pour l'heure, une chaîne vient là. </font><font style="vertical-align: inherit;">Dans PL / V8, il existe un type intégré Date, et la date habituelle d'un postgres se transforme en elle. </font><font style="vertical-align: inherit;">Mais le V8 ne connaît pas la date sans fin, et une fois transféré, il se transforme en </font></font><code>Invalid Date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passer des paramètres aux requêtes préparées</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revenons à </font></font><code>prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, considérez comment les paramètres y sont passés. </font><font style="vertical-align: inherit;">Différentes langues ont beaucoup en commun, car elles sont toutes basées sur SPI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous préparez une requête dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous devez déterminer le type de paramètres transmis et lorsque vous exécutez la requête, vous spécifiez uniquement les valeurs de ces paramètres (les paramètres sont transmis à PL / pgSQL de la même manière).</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plperl $$<span class="perl">
     <span class="hljs-keyword">my</span> $h= spi_prepare(<span class="hljs-string">'SELECT * FROM pg_class WHERE
          relname ~ $1'</span>, <span class="hljs-string">'text'</span> );                     <span class="hljs-comment">#   </span>
     <span class="hljs-keyword">warn</span> Dumper(spi_exec_prepared($h, <span class="hljs-string">'pg_language'</span>)); <span class="hljs-comment">#   </span>
     spi_freeplan($h);
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python, l'</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> essence est la même, mais la syntaxe est légèrement différente:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u $$<span class="pgsql">
     h= plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT relname FROM pg_class WHERE relname ~ $1'</span>, [<span class="hljs-string">'text'</span>] )
     plpy.<span class="hljs-keyword">notice</span>(.<span class="hljs-keyword">execute</span> ([<span class="hljs-string">'pg_language'</span>]))
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8, les</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> différences sont minimes:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
    var h= plv8.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT relname FROM pg_class WHERE relname ~ $1'</span>, [<span class="hljs-string">'text'</span>] );
    plv8.elog(<span class="hljs-keyword">NOTICE</span>, h.<span class="hljs-keyword">execute</span> ([<span class="hljs-string">'pg_language'</span>]));
    h.free();
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Java,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tout est différent. </font><font style="vertical-align: inherit;">Là, SPI n'est clairement pas utilisé, mais une connexion pseudo-JDBC à la base de données est établie. </font><font style="vertical-align: inherit;">Pour un programmeur PL / Java, tout se passe comme s'il créait une application client. </font><font style="vertical-align: inherit;">C'est pratique, et on pourrait également aborder la conception de PL / Perl et PL / Python, mais pour une raison quelconque, cela n'a pas été fait (cependant, personne n'interdit de créer quelques implémentations supplémentaires de PL / Perl et PL / Python).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travailler avec le curseur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toutes les fonctions SPI que nous avons utilisées lorsque nous sommes allés dans la base de données - </font></font><code>spi_exec_query()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et d'autres - ont un paramètre qui limite le nombre de lignes renvoyées. </font><font style="vertical-align: inherit;">Si vous avez besoin d'un grand nombre de lignes renvoyées, vous ne pouvez pas vous passer d'un curseur pour les remonter un peu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les curseurs travaillent dans toutes ces langues. </font><font style="vertical-align: inherit;">Dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl,</font></font></b> <br>
<code>spi_exec_query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> renvoie un curseur à partir duquel vous pouvez extraire les chaînes une à la fois. </font><font style="vertical-align: inherit;">Il n'est pas nécessaire de fermer le curseur, il se fermera automatiquement. </font><font style="vertical-align: inherit;">Mais si vous souhaitez le redécouvrir à nouveau, vous pouvez le fermer explicitement avec une commande </font></font><code>close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plperl $$<span class="perl">
    <span class="hljs-keyword">my</span> $cursor = spi_query(<span class="hljs-string">'SELECT * FROM pg_class'</span>);
    <span class="hljs-keyword">my</span> $row;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">defined</span>($row = spi_fetchrow($cursor))) {
         <span class="hljs-keyword">warn</span> $row-&gt;{relname};
    }
$$</span>;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  pg_statistic at line 5.<font></font>
WARNING:  pg_toast_2604 at line 5.<font></font>
WARNING:  pg_toast_2604_index at line 5.<font></font>
WARNING:  pg_toast_2606 at line 5.<font></font>
WARNING:  pg_toast_2606_index at line 5.<font></font>
WARNING:  pg_toast_2609 at line 5.<font></font>
WARNING:  pg_toast_2609_index at line 5.<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tout est très similaire, mais le curseur est présenté comme un objet que vous pouvez parcourir:</font></font><br>
<br>
<pre><code class="pgsql hljs">h = plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT ...'</span>);
<span class="hljs-keyword">cursor</span> = plpy.<span class="hljs-keyword">cursor</span>(h);
<span class="hljs-keyword">for</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">cursor</span>:<font></font>
...<font></font>
<span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>() //  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / v8,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tout est également très similaire, mais n'oubliez pas de libérer le plan de requête préparé:</font></font><br>
<br>
<pre><code class="pgsql hljs">var h = plv.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT ...'</span>);<font></font>
var <span class="hljs-keyword">cursor</span> = h.<span class="hljs-keyword">cursor</span>();<font></font>
var <span class="hljs-keyword">row</span>;
<span class="hljs-keyword">while</span>(<span class="hljs-keyword">row</span> = <span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">fetch</span>()) {<font></font>
...<font></font>
}<font></font>
<span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>();<font></font>
h.free();</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8: Accès rapide aux fonctionnalités</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans PL / V8, vous pouvez appeler une fonction non pas à partir d'un SELECT ordinaire, mais la trouver par son nom et la lancer immédiatement avec </font></font><code>plv8.find_function(name);</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais gardez à l'esprit que dans JS, une fonction ne peut pas être polymorphe, comme dans PostgreSQL, dans laquelle des fonctions portant le même nom mais avec des paramètres différents peuvent coexister. </font><font style="vertical-align: inherit;">En PL / v8, bien sûr, nous pouvons créer des fonctions polymorphes, mais il y </font></font><code>find_function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aura une erreur </font><font style="vertical-align: inherit;">lors de la tentative d'utilisation </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="plaintext hljs">ERROR:  Error: more than one function named "jsdump"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si une fonction par son nom est sans ambiguïté, elle peut être appelée sans SPI et conversions de type, c'est-à-dire </font><font style="vertical-align: inherit;">Plus vite. </font><font style="vertical-align: inherit;">Par exemple, comme ceci:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="ruby">
plv8.find_function(<span class="hljs-string">'jsdump'</span>)(<span class="hljs-number">1</span>, <span class="hljs-string">'abc'</span>);
$$</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transactions</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres 11 a beaucoup de plaisir: de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vraies</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> procédures </font><font style="vertical-align: inherit;">sont apparues </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Postgres n'avait auparavant que des fonctionnalités. </font><font style="vertical-align: inherit;">La joie n'est pas seulement due à la compatibilité et au respect de la norme SQL, mais pourquoi: dans les procédures, vous pouvez valider et annuler des transactions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Perl et PL / Python ont déjà des fonctions SPI pour gérer les transactions, alors que PL / V8 n'en a pas encore. </font><font style="vertical-align: inherit;">Dans PL / Perl, ces fonctions sont appelées </font></font><code>spi_commit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>spi_rollback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et un exemple d'utilisation se trouve </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En PL / Python, c'est </font></font><code>plpy.commit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>plpy.rollback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sous-transaction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les sous-transactions sont pratiques pour la gestion correcte des erreurs dans une logique complexe à plusieurs niveaux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL à l'</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> intérieur d'une transaction, chaque bloc avec le mot-clé EXCEPTION est une sous-transaction. Vous pouvez lire sur certains problèmes de performances et de fiabilité qui peuvent survenir dans ce cas, par exemple, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'y a </font><font style="vertical-align: inherit;">pas de sous-transactions explicites </font><font style="vertical-align: inherit;">dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais elles peuvent être simulées via des points de sauvegarde. Apparemment, si vous le souhaitez, il est facile d'écrire un module Pearl qui implémente les sous-transactions sous une forme explicite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python, les</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sous-transactions sont apparues il y a longtemps: de 9.5 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explicites</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , avant il y en avait </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implicitement</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Vous pouvez définir une transaction, envelopper</font></font><code>try-</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et exécuter. </font><font style="vertical-align: inherit;">Si la sous-transaction tombe, alors nous tombons dans le bloc </font></font><code>except</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; si elle ne tombe pas, alors dans le bloc </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et continuons.</font></font><br>
<br>
<pre><code class="pgsql hljs">try:
     <span class="hljs-keyword">with</span> plpy.subtransaction():<font></font>
          plpy.<span class="hljs-keyword">execute</span>("...")<font></font>
          plpy.<span class="hljs-keyword">execute</span>("...")
<span class="hljs-keyword">except</span> plpy.SPIError, e:<font></font>
. . .<font></font>
<span class="hljs-keyword">else</span>:<font></font>
. . .</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une conception similaire existe en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , uniquement dans la syntaxe JS.</font></font><br>
<br>
<pre><code class="pgsql hljs">try {<font></font>
plv8.subtransaction(<span class="hljs-keyword">function</span>() {<font></font>
plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'UPDATE...'</span>);<font></font>
plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'UPDATE...'</span>);<font></font>
});<font></font>
}<font></font>
catch(e) {<font></font>
...<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayez, mais n'abusez pas :) La connaissance de PL / * peut apporter certains avantages. </font><font style="vertical-align: inherit;">Comme tout outil, ils adorent être utilisés conformément à leur destination. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / v8 est très prometteur, mais il se comporte parfois de manière inattendue et présente un certain nombre de problèmes. </font><font style="vertical-align: inherit;">Par conséquent, il est préférable de sortir les langues de la boîte si elles conviennent à votre tâche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je remercie Igor Levshin (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Igor_Le</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), qui m'a beaucoup aidé à préparer le matériel pour l'article et a proposé quelques idées utiles, ainsi que Yevgeny Sergeyev et Alexey Fadeev pour les corrections qu'ils ont proposées.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr502236/index.html">Modélisation d'avions pour enfants - à un niveau décent</a></li>
<li><a href="../fr502246/index.html">Qu'est-ce que les réponses audacieuses d'Alice ont en commun avec les drones?</a></li>
<li><a href="../fr502248/index.html">Un nouveau GOST pour les ressources numériques est entré en vigueur: toutes les plateformes doivent être accessibles aux personnes handicapées</a></li>
<li><a href="../fr502250/index.html">L'aviation civile aujourd'hui: aspects et défis importants de la formation</a></li>
<li><a href="../fr502252/index.html">Télécommande et drones</a></li>
<li><a href="../fr502256/index.html">Comment visualiser un graphique d'intégration Spring à l'aide de Neo4j?</a></li>
<li><a href="../fr502260/index.html">ESP-NOW est un protocole de communication alternatif pour ESP8266 et ESP32. Concepts de base</a></li>
<li><a href="../fr502262/index.html">Pourquoi les AIOps et la surveillance parapluie pour la banque, ou sur quoi se construisent les relations avec la clientèle</a></li>
<li><a href="../fr502264/index.html">Infrastructure à clé publique. Délivrance de certificats dans des conditions d'auto-isolement</a></li>
<li><a href="../fr502266/index.html">Aurora sur la plate-forme Intel. L'aube de l'ère des exaflops</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>