<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëº üôçüèº üé¢ GPU Computing - Pourquoi, quand et comment. Plus quelques tests üõÄüèº üöú ‚ò£Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tout le monde sait depuis longtemps que sur les cartes vid√©o, vous pouvez non seulement jouer √† des jouets, mais aussi effectuer des choses qui ne son...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GPU Computing - Pourquoi, quand et comment. Plus quelques tests</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dbtc/blog/498374/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout le monde sait depuis longtemps que sur les cartes vid√©o, vous pouvez non seulement jouer √† des jouets, mais aussi effectuer des choses qui ne sont pas li√©es aux jeux, par exemple, former un r√©seau de neurones, vous souvenir de la crypto-monnaie ou effectuer des calculs scientifiques. Comment cela s'est pass√©, vous pouvez le lire </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais je voulais aborder la question de </font></font><i><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">savoir pourquoi le GPU peut √™tre int√©ressant pour le</font></font></strong></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> programmeur moyen (non li√© √† GameDev) </font></font><i><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comment aborder le</font></font></strong></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©veloppement sur le GPU sans y consacrer beaucoup de temps, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©cider</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si regardez dans cette direction, et " </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©terminez sur vos doigts" quel profit vous pouvez obtenir.</font></font></strong>&nbsp;<br>
<br>
<div style="text-align:center;"><img width="800" src="https://habrastorage.org/getpro/habr/post_images/3ee/2ac/893/3ee2ac8936a685e6993966cfa40f53fd.jpg"></div><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'article a √©t√© √©crit sur la base de ma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√©sentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en HighLoad ++. </font><font style="vertical-align: inherit;">Il aborde principalement les technologies propos√©es par NVIDIA. </font><font style="vertical-align: inherit;">Je n'ai aucun but de faire la publicit√© de produits, je les donne simplement √† titre d'exemple, et √† coup s√ªr, quelque chose de similaire peut √™tre trouv√© chez les fabricants concurrents.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi compter sur le GPU?</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deux processeurs peuvent √™tre compar√©s selon diff√©rents crit√®res, les plus populaires √©tant probablement la fr√©quence et le nombre de c≈ìurs, la taille des caches, etc., mais au final, nous nous int√©ressons au nombre d'op√©rations qu'un processeur peut effectuer par unit√© de temps, de quel type d'op√©ration il s'agit, mais une question distincte Une m√©trique commune est le nombre d'op√©rations en virgule flottante par seconde - flops. Et lorsque nous voulons comparer le chaud au doux, et dans notre cas le GPU avec le CPU, cette m√©trique est tr√®s pratique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le graphique ci-dessous montre la croissance de ces m√™mes flops au fil du temps pour les processeurs et les cartes vid√©o.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e2/048/3f5/5e20483f59e87b0a395b0fae0e6495c5.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Les donn√©es sont collect√©es √† partir de sources ouvertes, il n'y a pas de donn√©es pour 2019-20 ans, car tout n'est pas si beau l√†-bas, mais les GPU gagnent toujours)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Eh bien, c'est tentant, n'est-ce pas? </font><font style="vertical-align: inherit;">Nous d√©pla√ßons tous les calculs du CPU vers le GPU et obtenons huit fois les meilleures performances! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais, bien s√ªr, tout n'est pas si simple. </font><font style="vertical-align: inherit;">Vous ne pouvez pas tout prendre et tout transf√©rer sur le GPU, pourquoi, nous parlerons plus loin.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Architecture GPU et sa comparaison avec le CPU</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'apporte √† beaucoup une image famili√®re de l'architecture du CPU et des √©l√©ments de base:</font></font><br>
<br>
<div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/df0/8c2/4c3/df08c24c3fe92cd97356670729c318cd.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU Core</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Qu'est-ce qui est si sp√©cial? </font><font style="vertical-align: inherit;">Un c≈ìur et un tas de blocs auxiliaires. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant l'architecture GPU:</font></font><br>
<br>
<div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/0fe/138/0cc/0fe1380ccbb321b289d16e39a499009a.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU Core</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Une carte vid√©o a beaucoup de c≈ìurs de traitement, g√©n√©ralement plusieurs milliers, mais ils sont combin√©s en blocs; pour les cartes vid√©o NVIDIA, g√©n√©ralement 32 chacune, et ont des √©l√©ments communs, y compris et registres. L'architecture du noyau GPU et des √©l√©ments logiques est beaucoup plus simple que sur le CPU, √† savoir, il n'y a pas de prefetchers, de pr√©dicteurs de brunch et bien plus encore. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, ce sont les points cl√©s de la diff√©rence dans l'architecture du CPU et du GPU, et, en fait, ils imposent des restrictions ou, inversement, ouvrent les possibilit√©s de ce que nous pouvons lire efficacement sur le GPU.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'ai pas mentionn√© un autre point important, g√©n√©ralement la carte vid√©o et le processeur ne ¬´fouinent¬ª pas entre eux et n'√©crivent pas de donn√©es sur la carte vid√©o et ne lisent pas le r√©sultat - ce sont des op√©rations distinctes et peuvent se r√©v√©ler √™tre un ¬´goulot d'√©tranglement¬ª dans votre syst√®me, un graphique du temps de pompage par rapport √† la taille les donn√©es sont donn√©es plus loin dans l'article.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limitations et fonctionnalit√©s du GPU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelles limitations cette architecture impose-t-elle aux algorithmes ex√©cutables:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous calculons sur un GPU, alors nous ne pouvons pas s√©lectionner un seul c≈ìur, un bloc entier de c≈ìurs sera allou√© (32 pour NVIDIA).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous les c≈ìurs ex√©cutent les m√™mes instructions, mais avec des donn√©es diff√©rentes (nous en parlerons plus tard), ces calculs sont appel√©s Single-Instruction-Multiple-Data ou SIMD (bien que NVIDIA introduise son raffinement).&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En raison de l'ensemble relativement simple de blocs logiques et de registres g√©n√©raux, le GPU n'aime vraiment pas la ramification, et en fait la logique complexe dans les algorithmes.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelles opportunit√©s ouvre-t-il:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, l'acc√©l√©ration de ces m√™mes calculs SIMD. </font><font style="vertical-align: inherit;">L'exemple le plus simple est l'ajout √©l√©mentaire de matrices, et analysons-le.</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©duction des algorithmes classiques √† la repr√©sentation SIMD</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transformation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons deux tableaux, A et B, et nous voulons ajouter un √©l√©ment du tableau B √† chaque √©l√©ment du tableau A. Ci-dessous est un exemple en C, bien que j'esp√®re qu'il sera clair pour ceux qui ne parlent pas ce langage:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, size)</span>
</span>{ 
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) <font></font>
   { <font></font>
       A[i] += B[i]<font></font>
   } <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bouclage classique des √©l√©ments dans une boucle et ex√©cution lin√©aire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant √† quoi ressemblera ce code pour le GPU:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, size)</span> 
</span>{ 
   <span class="hljs-keyword">int</span> i = threadIdx.x; 
   <span class="hljs-keyword">if</span> (i &lt; size) <font></font>
      A[i] += B[i] <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et ici, c'est d√©j√† int√©ressant, la variable threadIdx est apparue, que nous ne semblions d√©clarer nulle part. Oui, son syst√®me nous fournit. Imaginez que dans l'exemple pr√©c√©dent, le tableau se compose de trois √©l√©ments et que vous souhaitez l'ex√©cuter dans trois threads parall√®les. Pour ce faire, vous devez ajouter un autre param√®tre - le num√©ro d'index ou de flux. C'est ce que la carte vid√©o fait pour nous, bien qu'elle passe l'index en tant que variable statique et peut fonctionner avec plusieurs dimensions √† la fois - x, y, z. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autre nuance, si vous souhaitez d√©marrer un grand nombre de flux parall√®les √† la fois, les flux devront √™tre divis√©s en blocs (une caract√©ristique architecturale des cartes vid√©o). La taille de bloc maximale d√©pend de la carte vid√©o, et l'indice de l'√©l√©ment pour lequel nous effectuons les calculs devra √™tre obtenu comme suit:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x; <span class="hljs-comment">// blockIdx ‚Äì  , blockDim ‚Äì  , threadIdx ‚Äì    </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cons√©quence, ce que nous avons: beaucoup de threads ex√©cut√©s en parall√®le qui ex√©cutent le m√™me code, mais avec des indices diff√©rents, et, par cons√©quent, des donn√©es, c'est-√†-dire </font><font style="vertical-align: inherit;">le m√™me SIMD. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est l'exemple le plus simple, mais si vous souhaitez travailler avec le GPU, vous devez amener votre t√¢che sous la m√™me forme. </font><font style="vertical-align: inherit;">Malheureusement, ce n'est pas toujours possible et dans certains cas peut faire l'objet d'une th√®se de doctorat, mais n√©anmoins, les algorithmes classiques peuvent encore √™tre amen√©s √† cette forme.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agr√©gation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant √† quoi ressemblera l'agr√©gation cast√©e en repr√©sentation SIMD:</font></font><br>
&nbsp;<br>
<div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/ecd/78a/bba/ecd78abbaff0c1be8799c1337f7652f8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons un tableau de n √©l√©ments. </font><font style="vertical-align: inherit;">√Ä la premi√®re √©tape, nous d√©marrons n / 2 threads et chaque thread ajoute deux √©l√©ments, √† savoir </font><font style="vertical-align: inherit;">en une seule it√©ration, nous additionnons la moiti√© des √©l√©ments du tableau. </font><font style="vertical-align: inherit;">Et puis dans la boucle, nous r√©p√©tons la m√™me chose pour le tableau nouvellement cr√©√©, jusqu'√† ce que nous agr√©gions les deux derniers √©l√©ments. </font><font style="vertical-align: inherit;">Comme vous pouvez le voir, plus la taille du tableau est petite, moins nous pouvons d√©marrer de threads parall√®les, c'est-√†-dire </font><font style="vertical-align: inherit;">sur un GPU, il est logique d'agr√©ger des tableaux d'une taille suffisamment grande. </font><font style="vertical-align: inherit;">Un tel algorithme peut √™tre utilis√© pour calculer la somme des √©l√©ments (en passant, n'oubliez pas le d√©bordement possible du type de donn√©es avec lequel vous travaillez), rechercher le maximum, le minimum ou simplement la recherche.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais le tri semble d√©j√† beaucoup plus compliqu√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les deux algorithmes de tri les plus populaires sur le GPU sont:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri bitonique</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Radix-sort</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais radix-sort est toujours utilis√© plus souvent, et une impl√©mentation pr√™te pour la production peut √™tre trouv√©e dans certaines biblioth√®ques. </font><font style="vertical-align: inherit;">Je n'analyserai pas en d√©tail le fonctionnement de ces algorithmes; ceux qui sont int√©ress√©s peuvent trouver une description de radix-sort sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.codeproject.com/Articles/543451/Parallel-Radix-Sort-on-the-GPU-using-Cplusplus- AMP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://stackoverflow.com/a/26229897</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mais l'id√©e est que m√™me un algorithme non lin√©aire tel que le tri peut √™tre r√©duit √† une vue SIMD. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant, avant de regarder les vrais chiffres qui peuvent √™tre obtenus √† partir du GPU, essayons de comprendre comment programmer pour ce miracle de la technologie?</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O√π commencer</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les deux technologies les plus courantes pouvant √™tre utilis√©es pour la programmation sous le GPU:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opencl</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuda</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenCL est une norme prise en charge par la plupart des fabricants de cartes vid√©o, notamment </font><font style="vertical-align: inherit;">et sur les appareils mobiles, le code √©crit en OpenCL peut √©galement √™tre ex√©cut√© sur le CPU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez utiliser OpenCL √† partir de C / C ++, il existe des liants vers d'autres langages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour OpenCL, j'ai le plus appr√©ci√© le livre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCL en action</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il d√©crit √©galement diff√©rents algorithmes sur le GPU, notamment </font><font style="vertical-align: inherit;">Tri bitonique et tri Radix. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA est la technologie et le SDK exclusifs de NVIDIA. </font><font style="vertical-align: inherit;">Vous pouvez √©crire en C / C ++ ou utiliser des liaisons vers d'autres langages.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comparer OpenCL et CUDA n'est pas correct, car </font><font style="vertical-align: inherit;">l'un est la norme, l'autre est l'ensemble du SDK. </font><font style="vertical-align: inherit;">N√©anmoins, beaucoup de gens choisissent CUDA pour le d√©veloppement de cartes vid√©o, malgr√© le fait que la technologie est propri√©taire, bien que gratuite et ne fonctionne que sur les cartes NVIDIA. </font><font style="vertical-align: inherit;">Il y a plusieurs raisons √† cela:</font></font><br>
<br>
<ul>
<li>  API</li>
<li>    </li>
<li>,   GPU,      (host) </li>
<li> ,  ..  </li>
<li>   </li>
<li>  </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les particularit√©s incluent le fait que CUDA est livr√© avec son propre compilateur, qui peut √©galement compiler du code C / C ++ standard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le livre CUDA le plus complet que j'ai rencontr√© √©tait </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Professional CUDA C Programming</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bien qu'il soit d√©j√† un peu d√©pass√©, il aborde n√©anmoins de nombreuses nuances techniques de programmation pour les cartes NVIDIA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais que faire si je ne veux pas passer quelques mois √† lire ces livres, √©crire mon propre programme pour une carte vid√©o, tester et d√©boguer, puis d√©couvrir que ce n'est pas pour moi?&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme je l'ai dit, il existe un grand nombre de biblioth√®ques qui cachent la complexit√© du d√©veloppement sous le GPU: XGBoost, cuBLAS, TensorFlow, PyTorch et autres, nous consid√©rerons la biblioth√®que de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pouss√©e</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car il est moins sp√©cialis√© que les autres biblioth√®ques ci-dessus, mais en m√™me temps il impl√©mente des algorithmes de base, par exemple, le tri, la recherche, l'agr√©gation et, avec une forte probabilit√©, il peut √™tre applicable √† vos t√¢ches. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thrust est une biblioth√®que C ++ qui vise √† "remplacer" les algorithmes STL standard par des algorithmes bas√©s sur GPU. </font><font style="vertical-align: inherit;">Par exemple, le tri d'un tableau de nombres √† l'aide de cette biblioth√®que sur une carte vid√©o ressemblerait √† ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">thrust::host_vector&lt;DataType&gt; <span class="hljs-title">h_vec</span><span class="hljs-params">(size)</span></span>; <span class="hljs-comment">//    </span>
<span class="hljs-built_in">std</span>::generate(h_vec.begin(), h_vec.end(), rand); <span class="hljs-comment">//   </span>
thrust::device_vector&lt;DataType&gt; d_vec = h_vec; <span class="hljs-comment">//        &nbsp;</span>
thrust::sort(d_vec.begin(), d_vec.end()); <span class="hljs-comment">//    </span>
thrust::copy(d_vec.begin(), d_vec.end(), h_vec.begin()); <span class="hljs-comment">//   ,     </span>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(n'oubliez pas que l'exemple doit √™tre compil√© par un compilateur de NVIDIA)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, thrust :: sort est tr√®s similaire √† un algorithme similaire de STL. Cette biblioth√®que cache de nombreuses difficult√©s, en particulier le d√©veloppement d'un sous-programme (plus pr√©cis√©ment, le noyau), qui sera ex√©cut√© sur la carte vid√©o, mais en m√™me temps prive de flexibilit√©. Par exemple, si nous voulons trier plusieurs gigaoctets de donn√©es, il serait logique d'envoyer une donn√©e √† la carte pour commencer le tri, et pendant le tri, envoyez plus de donn√©es √† la carte. Cette approche est appel√©e masquage de latence et permet une utilisation plus efficace des ressources de mappage de serveur, mais, malheureusement, lorsque nous utilisons des biblioth√®ques de haut niveau, ces opportunit√©s restent cach√©es. Mais pour le prototypage et la mesure des performances, ce sont les m√™mes, en particulier avec la pouss√©e, vous pouvez mesurer les frais g√©n√©raux fournis par le transfert de donn√©es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai √©crit une petite </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©f√©rence</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en utilisant cette biblioth√®que, qui ex√©cute plusieurs algorithmes populaires avec diff√©rentes quantit√©s de donn√©es sur le GPU, voyons quels sont les r√©sultats.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©sultats de l'algorithme GPU</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour tester le GPU, j'ai pris une instance dans AWS avec une carte vid√©o Tesla k80, ce n'est pas la carte serveur la plus puissante √† ce jour (la Tesla v100 la plus puissante), mais la plus abordable et embarqu√©e:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4992 CUDA Kernels</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24 Go de m√©moire</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">480 Gb / s - bande passante m√©moire&nbsp;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et pour les tests sur le CPU, j'ai pris une instance avec un processeur Intel Xeon CPU E5-2686 v4 @ 2.30GHz</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transformation</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/930/6e1/687/9306e1687be5ee95c29c8aac7b2ae337.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temps d'ex√©cution de la transformation sur le GPU et le CPU en ms</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Comme vous pouvez le voir, la transformation habituelle des √©l√©ments du tableau est approximativement la m√™me dans le temps, √† la fois sur le GPU et sur le CPU. </font><font style="vertical-align: inherit;">Et pourquoi? </font><font style="vertical-align: inherit;">Parce que le surco√ªt pour l'envoi de donn√©es vers la carte et le dos absorbe toute l'augmentation des performances (nous parlerons du surco√ªt s√©par√©ment), et il y a relativement peu de calculs sur la carte. </font><font style="vertical-align: inherit;">De plus, n'oubliez pas que les processeurs prennent √©galement en charge les instructions SIMD et que les compilateurs dans des cas simples peuvent les utiliser efficacement.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant l'efficacit√© de l'agr√©gation sur le GPU.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agr√©gation</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c92/d0e/cb9/c92d0ecb96c32866000e6948f5da61f9.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temps d'ex√©cution d'agr√©gation sur GPU et CPU en ms</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans l'exemple d'agr√©gation, nous constatons d√©j√† une augmentation significative des performances avec une augmentation du volume de donn√©es. </font><font style="vertical-align: inherit;">Il convient √©galement de pr√™ter attention au fait que nous pompons une grande quantit√© de donn√©es dans la m√©moire de la carte, et qu'une seule valeur agr√©g√©e est reprise, c'est-√†-dire </font><font style="vertical-align: inherit;">Les frais g√©n√©raux pour le transfert de donn√©es de la carte vers la RAM sont minimes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons √† l'exemple le plus int√©ressant - le tri.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fde/504/8da/fde5048da5084d1f0902c9362b21d939.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temps de tri vers le GPU et le CPU en ms</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Malgr√© le fait que nous envoyons l'int√©gralit√© du tableau de donn√©es √† la carte vid√©o et vice versa, le tri vers le GPU 800 Mo de donn√©es est environ 25 fois plus rapide que sur le processeur.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frais g√©n√©raux de transfert de donn√©es</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme le montre l'exemple de transformation, il n'est pas toujours √©vident que le GPU sera efficace m√™me dans les t√¢ches qui sont bien parall√®les. </font><font style="vertical-align: inherit;">La raison en est un surco√ªt pour le transfert de donn√©es de la RAM de l'ordinateur vers la m√©moire de la carte vid√©o (dans les consoles de jeu, en passant, la m√©moire est partag√©e entre le CPU et le GPU, et il n'est pas n√©cessaire de transf√©rer des donn√©es). </font><font style="vertical-align: inherit;">Une des caract√©ristiques d'une carte vid√©o est la bande passante m√©moire ou bande passante m√©moire, qui d√©termine la bande passante th√©orique de la carte. </font><font style="vertical-align: inherit;">Pour Tesla k80, elle est de 480 Go / s, pour Tesla v100, elle est d√©j√† de 900 Go / s. </font><font style="vertical-align: inherit;">De plus, la version PCI Express et l'impl√©mentation de la fa√ßon dont vous transf√©rerez les donn√©es sur la carte affecteront le d√©bit, par exemple, cela peut √™tre fait dans plusieurs flux parall√®les.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinons les r√©sultats pratiques obtenus pour la carte graphique Tesla k80 dans le cloud Amazon:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/798/fb5/613/798fb56139f6158566232bc6283b24e7.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temps de transfert des donn√©es vers le GPU, tri et transfert des donn√©es vers la RAM en ms </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HtoD - transfert des donn√©es vers la carte vid√©o </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPU Ex√©cution - tri sur la carte vid√©o </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DtoH - copie des donn√©es de la carte vid√©o vers la RAM</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
La premi√®re chose √† noter est que la lecture des donn√©es de la carte vid√©o est plus rapide que √©crivez-les l√†-bas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La seconde - lorsque vous travaillez avec une carte vid√©o, vous pouvez obtenir une latence de 350 microsecondes, et cela peut d√©j√† √™tre suffisant pour certaines applications √† faible latence. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le graphique ci-dessous montre une surcharge pour plus de donn√©es:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/653/b96/d18653b96af325f35fade713bdaa8dae.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temps de transfert des donn√©es vers le GPU, tri et transfert des donn√©es vers la RAM en ms</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation du serveur</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La question la plus courante est de savoir en quoi une carte vid√©o de jeu diff√®re d'une carte serveur? </font><font style="vertical-align: inherit;">Selon les caract√©ristiques, ils sont tr√®s similaires, mais les prix diff√®rent consid√©rablement.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/01b/741/20301b7418ee616d9611f42d2b4a8f5d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les principales diff√©rences entre le serveur (NVIDIA) et la carte de jeu:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garantie du fabricant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (la carte de jeu n'est pas con√ßue pour une utilisation sur serveur)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probl√®mes de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtualisation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> possibles </font><font style="vertical-align: inherit;">pour une carte graphique grand public</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disponibilit√© du m√©canisme de correction d'erreur sur la carte serveur</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le nombre de threads parall√®les (pas les c≈ìurs CUDA) ou la prise en charge d'Hyper-Q, qui vous permet de travailler avec la carte √† partir de plusieurs threads sur le CPU, par exemple, t√©l√©charger des donn√©es sur la carte √† partir d'un thread et d√©marrer les calculs √† partir d'un autre</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce sont peut-√™tre les principales diff√©rences importantes que j'ai trouv√©es.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multithreading</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s avoir compris comment ex√©cuter l'algorithme le plus simple sur la carte vid√©o et quels r√©sultats peuvent √™tre attendus, la prochaine question logique est de savoir comment la carte vid√©o se comportera lors du traitement de plusieurs demandes parall√®les. En r√©ponse, j'ai deux graphiques de calcul sur le GPU et un processeur √† 4 et 32 ‚Äã‚Äãc≈ìurs:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a1/1f6/022/0a11f6022198a582929f384be357fe43.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temps n√©cessaire pour effectuer des calculs math√©matiques sur le GPU et le CPU avec des matrices de 1000 x 60 en ms</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
. Ce graphique effectue des calculs avec des matrices de 1000 x 60 √©l√©ments. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les calculs sont</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lanc√©s √† </font><font style="vertical-align: inherit;">partir de plusieurs flux de programme, un flux s√©par√© est cr√©√© pour le GPU pour chaque flux CPU (le tr√®s Hyper-Q est utilis√©).&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, le processeur g√®re tr√®s bien cette charge, tandis que la latence pour une demande par GPU augmente consid√©rablement avec une augmentation du nombre de demandes parall√®les.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e09/22c/7fb/e0922c7fba0ef001cca97c7a99817c83.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le temps pour effectuer des calculs math√©matiques sur le GPU et le CPU avec des matrices 10 000 x 60 en ms.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sur le deuxi√®me graphique, les m√™mes calculs, mais avec des matrices 10 fois plus longues, et le GPU se comporte beaucoup mieux sous une telle charge. Ces graphiques sont tr√®s indicatifs, et nous pouvons conclure: le comportement sous charge d√©pend de la nature de la charge elle-m√™me. Un processeur peut √©galement g√©rer les calculs matriciels assez efficacement, mais dans une certaine mesure. Pour une carte vid√©o, il est caract√©ristique que pour une petite charge de calcul, les performances chutent de fa√ßon approximativement lin√©aire. Avec une augmentation de la charge et du nombre de threads parall√®les, la carte vid√©o s'adapte mieux.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est difficile de supposer comment le GPU se comportera dans diverses situations, mais comme vous pouvez le voir, dans certaines conditions, une carte serveur peut traiter les demandes de plusieurs flux parall√®les assez efficacement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous discuterons de quelques autres questions que vous pourriez avoir si vous d√©cidez toujours d'utiliser le GPU dans vos projets.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limite de ressources</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous l'avons d√©j√† dit, les deux principales ressources d'une carte vid√©o sont le calcul des c≈ìurs et de la m√©moire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, nous avons plusieurs processus ou conteneurs utilisant une carte vid√©o, et nous aimerions pouvoir partager la carte vid√©o entre eux. </font><font style="vertical-align: inherit;">Malheureusement, il n'y a pas d'API simple pour cela. </font><font style="vertical-align: inherit;">NVIDIA propose la technologie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vGPU</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais je n'ai pas trouv√© la carte Tesla k80 dans la liste des cartes prises en charge, et d'apr√®s ce que je peux comprendre de la description, la technologie est plus ax√©e sur les √©crans virtuels que sur les calculs. </font><font style="vertical-align: inherit;">AMD propose peut-√™tre quelque chose de plus appropri√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par cons√©quent, si vous pr√©voyez d'utiliser le GPU dans vos projets, vous devez vous fier au fait que l'application utilisera exclusivement la carte vid√©o, ou vous contr√¥lerez par programme la quantit√© de m√©moire allou√©e et le nombre de c≈ìurs utilis√©s pour les calculs.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conteneurs et GPU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous avez d√©termin√© la limite de ressources, alors la question logique suivante: que faire s'il y a plusieurs cartes vid√©o sur le serveur? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encore une fois, vous pouvez d√©cider au niveau de l'application quel GPU il utilisera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les conteneurs Docker sont un autre moyen plus pratique. </font><font style="vertical-align: inherit;">Vous pouvez utiliser des conteneurs r√©guliers, mais NVIDIA propose ses conteneurs </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NGC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , avec des versions optimis√©es de divers logiciels, biblioth√®ques et pilotes. </font><font style="vertical-align: inherit;">Pour un conteneur, vous pouvez limiter le nombre de GPU utilis√©s et leur visibilit√© sur le conteneur. </font><font style="vertical-align: inherit;">Les frais g√©n√©raux li√©s √† l'utilisation des conteneurs sont d'environ 3%.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travailler en cluster</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre question, que faire si vous souhaitez effectuer une t√¢che sur plusieurs GPU au sein du m√™me serveur ou cluster? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous avez choisi une biblioth√®que similaire √† Thrust ou une solution de niveau inf√©rieur, la t√¢che devra √™tre r√©solue manuellement. </font><font style="vertical-align: inherit;">Les cadres de haut niveau, tels que pour l'apprentissage automatique ou les r√©seaux de neurones, prennent g√©n√©ralement en charge la possibilit√© d'utiliser plusieurs cartes pr√™tes √† l'emploi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, je voudrais noter que, par exemple, NVIDIA propose une interface pour l'√©change direct de donn√©es entre les cartes - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVLINK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est nettement plus rapide que PCI Express. </font><font style="vertical-align: inherit;">Et il existe une technologie pour l'acc√®s direct √† la m√©moire de la carte √† partir d'autres p√©riph√©riques PCI Express - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUDirect RDMA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , incl. </font><font style="vertical-align: inherit;">et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©seau</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recommandations</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous envisagez d'utiliser le GPU dans vos projets, le GPU vous convient probablement si:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Votre t√¢che peut √™tre r√©duite √† une vue SIMD</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est possible de charger la plupart des donn√©es sur la carte avant les calculs (cache)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le d√©fi passe par l'informatique intensive</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez √©galement poser des questions √† l'avance:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combien de requ√™tes parall√®les seront&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle latence attendez-vous</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avez-vous besoin d'une carte pour votre charge? Avez-vous besoin d'un serveur avec plusieurs cartes ou d'un cluster de serveurs GPU&nbsp;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout, j'esp√®re que le mat√©riel vous sera utile et vous aidera √† prendre la bonne d√©cision!</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©f√©rences</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Benchmark et r√©sultats sur github - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/tishden/gpu_benchmark/tree/master/cuda</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En plus du sujet, un enregistrement du rapport </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬´GPU Databases - Architecture, Performance and Prospects for Use¬ª</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
NVIDIA NGC Containers Webinar Webinaires - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http : //bit.ly/2UmVIVt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bit.ly/2x4vJKF</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr498362/index.html">Kingston conserve son leadership dans les livraisons de SSD: comment faire?</a></li>
<li><a href="../fr498366/index.html">Quels algorithmes les d√©veloppeurs Yandex impl√©mentent-ils chaque jour</a></li>
<li><a href="../fr498368/index.html">L'histoire d'un interrupteur</a></li>
<li><a href="../fr498370/index.html">SAP UI5 et Windows de confirmation: encore une fois sur le contexte</a></li>
<li><a href="../fr498372/index.html">Tutoriel de simulateur de r√©seau ns-3. Chapitre 5</a></li>
<li><a href="../fr498378/index.html">Annonce de l'√©cole du soir de Slurm par Agile</a></li>
<li><a href="../fr498380/index.html">La fen√™tre d'Overton en action: comment une pand√©mie est utilis√©e pour limiter notre libert√©</a></li>
<li><a href="../fr498390/index.html">IAR + Clion = amiti√©</a></li>
<li><a href="../fr498392/index.html">18 Les fonctionnalit√©s de GitLab deviennent open source</a></li>
<li><a href="../fr498394/index.html">7 analogues gratuits de Screaming Frog et Netpeak Spider</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>