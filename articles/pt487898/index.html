<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí∑ üìâ üï¶ Medindo a largura de banda da mem√≥ria no joelho ‚ù§Ô∏è üíáüèº üíÉüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algumas semanas atr√°s, em uma conversa durante o jantar, um colega reclamou de algum tipo de processo lento. Ele calculou o n√∫mero de bytes gerados, o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Medindo a largura de banda da mem√≥ria no joelho</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487898/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algumas semanas atr√°s, em uma conversa durante o jantar, um colega reclamou de algum tipo de processo lento. Ele calculou o n√∫mero de bytes gerados, o n√∫mero de ciclos de processamento e, finalmente, a quantidade de RAM. Um colega disse que uma GPU moderna com uma largura de banda de mem√≥ria superior a 500 GB / s iria cumprir sua tarefa e n√£o sufocar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pareceu-me que esta √© uma abordagem interessante. Pessoalmente, n√£o avaliei anteriormente os objetivos de desempenho dessa perspectiva. Sim, eu sei sobre a diferen√ßa no desempenho do processador e da mem√≥ria. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2de/d86/182/2ded861823d832e2e382d1e97e0ec147.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu sei escrever c√≥digo que faz uso pesado do cache. Conhe√ßo os n√∫meros aproximados de atraso. Mas isso n√£o √© suficiente para avaliar imediatamente a largura de banda da mem√≥ria.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° um experimento mental. </font><font style="vertical-align: inherit;">Imagine na mem√≥ria uma matriz cont√≠nua de bilh√µes de n√∫meros inteiros de 32 bits. </font><font style="vertical-align: inherit;">S√£o 4 gigabytes. </font><font style="vertical-align: inherit;">Quanto tempo levar√° para percorrer essa matriz e adicionar os valores? </font><font style="vertical-align: inherit;">Quantos bytes por segundo a CPU pode ler da RAM? </font><font style="vertical-align: inherit;">Dados cont√≠nuos? </font><font style="vertical-align: inherit;">Acesso aleat√≥rio? </font><font style="vertical-align: inherit;">Qu√£o bem esse processo pode ser paralelo? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ dir√° que estas s√£o perguntas in√∫teis. </font><font style="vertical-align: inherit;">Programas reais s√£o complexos demais para tornar um marco t√£o ing√™nuo. </font><font style="vertical-align: inherit;">E aqui est√°! </font><font style="vertical-align: inherit;">A resposta real √© "dependendo da situa√ß√£o". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, acho que vale a pena explorar essa quest√£o. </font><font style="vertical-align: inherit;">N√£o estou tentando encontrar a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resposta</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mas acho que podemos definir alguns limites superiores e inferiores, alguns pontos interessantes no meio e aprender alguma coisa no processo.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os n√∫meros que todo programador deve saber</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ l√™ blogs de programa√ß√£o, provavelmente encontrou "n√∫meros que todo programador deveria conhecer". </font><font style="vertical-align: inherit;">Eles se parecem com isso:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link para o cache L1 0,5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Previs√£o incorreta de 5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link para cache L2 7 ns 14x para cache L1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Captura / libera√ß√£o Mutex 25 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link para a mem√≥ria principal 100 ns 20x para cache L2, 200x para cache L1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comprima 1000 bytes com Zippy 3000 ns 3 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Envio de 1000 bytes em uma rede de 1 Gbps 10.000 ns 10 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leitura aleat√≥ria 4000 com SSD 150.000 ns 150 Œºs ~ 1GB / s SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leia 1 MB sequencialmente de 250.000 ns 250 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pacote de ida e volta dentro do data center 500.000 ns 500 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leitura sequencial de 1 MB no SSD 1.000.000 ns 1.000 Œºs 1 ms ~ 1 GB / s SSD, mem√≥ria 4x</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pesquisa em disco 10.000.000 ns 10.000 Œºs 10 ms 20x para o data center</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leia 1 MB sequencialmente do disco 20.000.000 ns 20.000 Œºs 20 ms 80x para a mem√≥ria, 20x para SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Envio de pacote CA-&gt; Holanda-&gt; CA 150.000.000 ns 150.000 Œºs 150 ms</font></font></pre> <br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonte: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonas Boner</font></font></a></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
√ìtima lista. </font><font style="vertical-align: inherit;">Ele aparece no HackerNews pelo menos uma vez por ano. </font><font style="vertical-align: inherit;">Todo programador deve conhecer esses n√∫meros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas esses n√∫meros s√£o sobre outra coisa. </font><font style="vertical-align: inherit;">Lat√™ncia e largura de banda n√£o s√£o a mesma coisa.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atraso em 2020</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa lista foi compilada em 2012 e, neste artigo de 2020, os tempos mudaram. </font><font style="vertical-align: inherit;">Aqui est√£o os n√∫meros para o Intel i7 com o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StackOverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acerto no cache L1, ~ 4 ciclos (2,1 - 1,2 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acerto no cache L2, ~ 10 ciclos (5,3 - 3,0 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acerto no cache L3, para um √∫nico n√∫cleo ~ 40 ciclos (21,4 - 12,0 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acerto no cache L3, juntos por outro kernel ~ 65 ciclos (34,8 - 19,5 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bata no cache L3, com uma altera√ß√£o para outro kernel ~ 75 ciclos (40,2 - 22,5 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAM local ~ 60 ns</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interessante! </font><font style="vertical-align: inherit;">O que mudou?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 tornou-se mais lento; </font></font><code>0,5 ‚Üí 1,5 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L2 mais r√°pido; </font></font><code>7 ‚Üí 4,2 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A propor√ß√£o de L1 e L2 √© muito reduzida; </font></font><code>2,5x  14</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Uau!)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O cache L3 agora se tornou o padr√£o; </font></font><code> 12  40 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM tornou-se mais r√°pida; </font></font><code>100 ‚Üí 60 </code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o tiraremos conclus√µes de longo alcance. </font><font style="vertical-align: inherit;">N√£o est√° claro como os n√∫meros originais foram calculados. </font><font style="vertical-align: inherit;">N√£o vamos comparar ma√ß√£s com laranjas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√£o alguns dados da </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wikichip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre a largura de banda e o tamanho do cache do meu processador.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Largura de banda da mem√≥ria: 39,74 Gigabytes por segundo</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cache L1: 192 kilobytes (32 KB por n√∫cleo)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cache L2: 1,5 megabytes (256 KB por n√∫cleo)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cache L3: 12 megabytes (compartilhado; 2 MB por n√∫cleo)</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que eu quero saber:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limite superior do desempenho da RAM</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limite inferior</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limites de cache L1 / L2 / L3</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmarking ing√™nuo</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos fazer alguns testes. </font><font style="vertical-align: inherit;">Para medir a largura de banda, escrevi um programa C ++ simples. </font><font style="vertical-align: inherit;">Muito aproximadamente, ela se parece com isso.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Generate random elements</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; ++i) <span class="hljs-comment">// one billion ints</span>
    nums.push_back(rng() % <span class="hljs-number">1024</span>); <span class="hljs-comment">// small nums to prevent overflow</span><font></font>
<font></font>
<span class="hljs-comment">// Run test with 1 to 12 threads</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> thread_count = <span class="hljs-number">1</span>; thread_count &lt;= MAX_THREADS; ++thread_count) {
    <span class="hljs-keyword">auto</span> slice_len = nums.size() / thread_count;<font></font>
    <font></font>
    <span class="hljs-comment">// for-each thread</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> thread = <span class="hljs-number">0</span>; thread &lt; thread_count; ++thread) {<font></font>
        <font></font>
        <span class="hljs-comment">// partition data</span>
        <span class="hljs-keyword">auto</span> begin = nums.begin() + thread * slice_len;
        <span class="hljs-keyword">auto</span> end = (thread == thread_count - <span class="hljs-number">1</span>)<font></font>
            ? nums.end() : begin + slice_len;<font></font>
<font></font>
        <span class="hljs-comment">// spawn threads</span>
        futures.push_back(<span class="hljs-built_in">std</span>::async([begin, end] { <font></font>
            <font></font>
            <span class="hljs-comment">// sum ints sequentially</span>
            <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = begin; ptr &lt; end; ++ptr)<font></font>
                sum += *ptr;<font></font>
            <span class="hljs-keyword">return</span> sum;<font></font>
        }));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// combine results</span>
    <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; <span class="hljs-built_in">future</span> : futures)<font></font>
        sum += <span class="hljs-built_in">future</span>.get();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns detalhes s√£o omitidos. Mas voc√™ entendeu a ideia. Crie uma matriz grande e cont√≠nua de elementos. Divida a matriz em fragmentos separados. Processe cada fragmento em um thread separado. Acumule resultados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ tamb√©m precisa medir o acesso aleat√≥rio. √â muito dif√≠cil. Eu tentei de v√°rias maneiras, finalmente decidi misturar √≠ndices pr√©-computados. Cada √≠ndice existe exatamente uma vez. Em seguida, o loop interno itera sobre os √≠ndices e calcula </font></font><code>sum += nums[index]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt; indices = <span class="hljs-comment">/* shuffled */</span>;<font></font>
<font></font>
<span class="hljs-comment">// random access</span>
<span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = indices.begin(); ptr &lt; indices.end(); ++ptr) {
    <span class="hljs-keyword">auto</span> idx = *ptr;<font></font>
    sum += nums[idx];<font></font>
}<font></font>
<span class="hljs-keyword">return</span> sum;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao calcular a taxa de transfer√™ncia, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> considero a mem√≥ria da matriz de √≠ndices. </font><font style="vertical-align: inherit;">Somente bytes que contribuem para o total s√£o contados </font></font><code>sum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">N√£o comparo meu hardware, mas avalio a capacidade de trabalhar com conjuntos de dados de tamanhos diferentes e com esquemas de acesso diferentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Realizaremos testes com tr√™s tipos de dados: </font></font><br>
<br>
<code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- o principal inteiro de 32 bits </font></font><br>
<code>matri4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- cont√©m </font></font><code>int[16]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">se encaixa em uma linha de cache de 64 bytes </font></font><br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- usa ferramentas internas</font></font><code>__m256i</code><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grande bloco</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meu primeiro teste funciona com um grande bloco de mem√≥ria. Um bloco de </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itens </font><font style="vertical-align: inherit;">de 1 GB </font><font style="vertical-align: inherit;">√© destacado e preenchido com pequenos valores aleat√≥rios. Um loop simples itera sobre uma matriz N vezes, para acessar a mem√≥ria com um volume </font></font><code>N </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para calcular a soma </font></font><code>int64_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. V√°rios segmentos dividem a matriz e cada um obt√©m acesso ao mesmo n√∫mero de elementos. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d36/45d/2d1/d3645d2d119e28f1306945258d1b422b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Surpresa! Neste gr√°fico, pegamos o tempo m√©dio de execu√ß√£o da opera√ß√£o de soma e convertemos de </font></font><code>runtime_in_nanoseconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>gigabytes_per_second</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resultado muito bom. </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ler sequencialmente 11 GB / s em um √∫nico fluxo. Escala linearmente at√© atingir 38 GB / s. Testes </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais r√°pido, mas descanse no mesmo teto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existe um limite claro e √≥bvio para a quantidade de dados que podemos ler da RAM por segundo. </font><font style="vertical-align: inherit;">No meu sistema, isso √© aproximadamente 40 GB / s. </font><font style="vertical-align: inherit;">Isso est√° em conformidade com as especifica√ß√µes atuais listadas acima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A julgar pelos tr√™s gr√°ficos inferiores, o acesso aleat√≥rio √© lento. </font><font style="vertical-align: inherit;">Muito, muito devagar. </font><font style="vertical-align: inherit;">O desempenho de thread √∫nico </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© desprez√≠vel 0,46 GB / s. </font><font style="vertical-align: inherit;">Isso √© 24 vezes mais lento que o empilhamento seq√ºencial a 11,03 GB / s! </font><font style="vertical-align: inherit;">O teste </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mostra o melhor resultado, porque √© executado em linhas de cache completas. </font><font style="vertical-align: inherit;">Mas ainda √© quatro a sete vezes mais lento que o acesso seq√ºencial e atinge um pico de apenas 8 GB / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloco pequeno: leitura sequencial</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No meu sistema, o tamanho do cache L1 / L2 / L3 para cada fluxo √© de 32 KB, 256 KB e 2 MB. O que acontece se voc√™ pegar um bloco de 32 kilobytes de elementos e iter√°-lo 125.000 vezes? S√£o 4 GB de mem√≥ria, mas sempre iremos para o cache. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2bd/662/3dd/2bd6623dd63d0eae81548f4b5e6d4599.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Impressionante! O desempenho de thread √∫nico √© semelhante √† leitura de um bloco grande, cerca de 12 GB / s. S√≥ que desta vez, o multithreading ultrapassa o limite de 40 GB / s. Faz sentido. Os dados permanecem no cache, portanto, o gargalo da RAM n√£o aparece. Para dados que n√£o couberam no cache L3, o mesmo teto de cerca de 38 GB / s se aplica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O teste </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mostra resultados semelhantes ao circuito, mas ainda mais r√°pido; 31 GB / s no modo single-thread, 171 GB / s no multi-thread. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/929/9ab/ceb/9299abceb2e779406f598b76c00beba5.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos olhar </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Preste aten√ß√£o ao eixo y.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f96/7b2/9c6/f967b29c6f839f0536667b9918fabd70.png"><br>
<br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excepcionalmente r√°pido. </font><font style="vertical-align: inherit;">√â 10 vezes mais r√°pido que </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em um bloco de 16 KB, ele ainda ultrapassa 1000 GB / s! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, este √© um teste sint√©tico de superf√≠cie. </font><font style="vertical-align: inherit;">A maioria dos aplicativos n√£o executa a mesma opera√ß√£o com os mesmos dados um milh√£o de vezes seguidas. </font><font style="vertical-align: inherit;">O teste n√£o mostra desempenho no mundo real. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas a li√ß√£o √© clara. </font><font style="vertical-align: inherit;">Dentro do cache, os dados s√£o processados </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rapidamente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Com um teto muito alto ao usar o SIMD: mais de 100 GB / s no modo de rosca √∫nica, mais de 1000 GB / s em multithread. </font><font style="vertical-align: inherit;">A grava√ß√£o de dados no cache √© lenta e com um limite r√≠gido de cerca de 40 GB / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloco pequeno: leitura aleat√≥ria</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos fazer o mesmo, mas agora com acesso aleat√≥rio. </font><font style="vertical-align: inherit;">Esta √© a minha parte favorita do artigo. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/983/854/ef8/983854ef856e17e37493e9c8b928d318.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A leitura de valores aleat√≥rios da RAM √© lenta, apenas 0,46 GB / s. </font><font style="vertical-align: inherit;">A leitura de valores aleat√≥rios do cache L1 √© muito r√°pida: 13 GB / s. </font><font style="vertical-align: inherit;">Isso √© mais r√°pido do que ler dados seriais </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da RAM (11 GB / s). </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/59a/7bf/b72/59a7bfb728445b69a7947523ab9b0900.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O teste </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mostra um resultado semelhante para o mesmo modelo, mas duas vezes mais r√°pido que </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d99/bc2/f70/d99bc2f70c2f7bda177f70ec166bd74a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O acesso aleat√≥rio √© </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incrivelmente r√°pido.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Achados de acesso aleat√≥rio</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A leitura livre da mem√≥ria √© lenta. </font><font style="vertical-align: inherit;">Catastroficamente lento. </font><font style="vertical-align: inherit;">Menos de 1 GB / s para os dois casos de teste </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ao mesmo tempo, as leituras aleat√≥rias do cache s√£o surpreendentemente r√°pidas. </font><font style="vertical-align: inherit;">√â compar√°vel √† </font><font style="vertical-align: inherit;">leitura </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq√ºencial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da RAM. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dde/0a4/52b/dde0a452b8f293758c2efe1760115306.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele precisa ser digerido. </font><font style="vertical-align: inherit;">O acesso aleat√≥rio ao cache √© compar√°vel em velocidade ao acesso seq√ºencial √† RAM. </font><font style="vertical-align: inherit;">A queda de L1 16 KB para L2 256 KB √© apenas metade ou menos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu acho que isso ter√° consequ√™ncias profundas.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listas vinculadas s√£o consideradas prejudiciais</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perseguir um ponteiro (pular em ponteiros) √© ruim. </font><font style="vertical-align: inherit;">Muito muito mal. </font><font style="vertical-align: inherit;">Quanto est√° diminuindo o desempenho? </font><font style="vertical-align: inherit;">Veja por si mesmo. </font><font style="vertical-align: inherit;">Eu fiz um teste extra que envolve </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em </font></font><code>std::unique_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cada acesso passa por um ponteiro. </font><font style="vertical-align: inherit;">Aqui est√° um resultado terr√≠vel, apenas catastr√≥fico.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">     1 fio | </font><font style="vertical-align: inherit;">matrix4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">diff |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloco grande - Seq | </font><font style="vertical-align: inherit;">14,8 GB / s | </font><font style="vertical-align: inherit;">0,8 GB / s | </font><font style="vertical-align: inherit;">19x</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Seq | </font><font style="vertical-align: inherit;">31,6 GB / s | </font><font style="vertical-align: inherit;">2,2 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Seq | </font><font style="vertical-align: inherit;">22,2 GB / s | </font><font style="vertical-align: inherit;">1,9 GB / s | </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloco grande - Rand | </font><font style="vertical-align: inherit;">2,2 GB / s | </font><font style="vertical-align: inherit;">0,1 GB / s | </font><font style="vertical-align: inherit;">22x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Rand | </font><font style="vertical-align: inherit;">23,2 GB / s | </font><font style="vertical-align: inherit;">1,7 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Rand | </font><font style="vertical-align: inherit;">15,2 GB / s | </font><font style="vertical-align: inherit;">0,8 GB / s | </font><font style="vertical-align: inherit;">19x</font></font><font></font>
<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
     6 t√≥picos | </font><font style="vertical-align: inherit;">matrix4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">diff |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloco grande - Seq | </font><font style="vertical-align: inherit;">34,4 GB / s | </font><font style="vertical-align: inherit;">2,5 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Seq | </font><font style="vertical-align: inherit;">154,8 GB / s | </font><font style="vertical-align: inherit;">8,0 GB / s | </font><font style="vertical-align: inherit;">19x</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Seq | </font><font style="vertical-align: inherit;">111,6 GB / s | </font><font style="vertical-align: inherit;">5,7 GB / s | </font><font style="vertical-align: inherit;">20x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloco grande - Rand | </font><font style="vertical-align: inherit;">7,1 GB / s | </font><font style="vertical-align: inherit;">0,4 GB / s | </font><font style="vertical-align: inherit;">18x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Rand | </font><font style="vertical-align: inherit;">95,0 GB / s | </font><font style="vertical-align: inherit;">7,8 GB / s | </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Rand | </font><font style="vertical-align: inherit;">58,3 GB / s | </font><font style="vertical-align: inherit;">1,6 GB / s | </font><font style="vertical-align: inherit;">36x |</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A soma sequencial dos valores atr√°s do ponteiro √© realizada a uma velocidade inferior a 1 GB / s. </font><font style="vertical-align: inherit;">A velocidade de acesso aleat√≥rio ignorado do cache √© de apenas 0,1 GB / s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perseguir um ponteiro diminui a execu√ß√£o do c√≥digo de 10 a 20 vezes. </font><font style="vertical-align: inherit;">N√£o deixe seus amigos usarem listas vinculadas. </font><font style="vertical-align: inherit;">Por favor, pense sobre o cache.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estimativa de or√ßamento para quadros</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â comum que os desenvolvedores de jogos definam um limite (or√ßamento) para a carga na CPU e a quantidade de mem√≥ria. Mas nunca vi um or√ßamento de largura de banda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos jogos modernos, o FPS continua a crescer. Agora √© de 60 FPS. VR opera a uma frequ√™ncia de 90 Hz. Eu tenho um monitor de jogos de 144 Hz. √â incr√≠vel, ent√£o os 60 FPS parecem uma merda. Eu nunca voltarei ao monitor antigo. Esportes e serpentinas Twitch monitora 240 Hz. Este ano, a Asus lan√ßou um monstro de 360 ‚Äã‚ÄãHz na CES. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meu processador tem um limite superior de cerca de 40 GB / s. Parece um grande n√∫mero! No entanto, a uma frequ√™ncia de 240 Hz, apenas 167 MB por quadro s√£o obtidos. Um aplicativo realista pode gerar tr√°fego de 5 GB / s a ‚Äã‚Äã144 Hz, que √© de apenas 69 MB por quadro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° uma tabela com alguns n√∫meros.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        | </font><font style="vertical-align: inherit;">1 | </font><font style="vertical-align: inherit;">10 </font><font style="vertical-align: inherit;">30 </font><font style="vertical-align: inherit;">60 </font><font style="vertical-align: inherit;">90 </font><font style="vertical-align: inherit;">144 </font><font style="vertical-align: inherit;">240 </font><font style="vertical-align: inherit;">360</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------- | ------- | -------- | -------- | -------- | ------ - | -------- | -------- | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
40 GB / s | </font><font style="vertical-align: inherit;">40 GB | </font><font style="vertical-align: inherit;">4 GB | </font><font style="vertical-align: inherit;">1,3 GB | </font><font style="vertical-align: inherit;">667 MB | </font><font style="vertical-align: inherit;">444 MB | </font><font style="vertical-align: inherit;">278 MB | </font><font style="vertical-align: inherit;">167 MB | </font><font style="vertical-align: inherit;">111 MB |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 GB / s | </font><font style="vertical-align: inherit;">10 GB | </font><font style="vertical-align: inherit;">1 GB | </font><font style="vertical-align: inherit;">333 MB | </font><font style="vertical-align: inherit;">166 MB | </font><font style="vertical-align: inherit;">111 MB | </font><font style="vertical-align: inherit;">69 MB | </font><font style="vertical-align: inherit;">42 MB | </font><font style="vertical-align: inherit;">28 MB |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 1 GB / s | </font><font style="vertical-align: inherit;">1 GB | </font><font style="vertical-align: inherit;">100 MB | </font><font style="vertical-align: inherit;">33 MB | </font><font style="vertical-align: inherit;">17 MB | </font><font style="vertical-align: inherit;">11 MB | </font><font style="vertical-align: inherit;">7 MB | </font><font style="vertical-align: inherit;">4 MB | </font><font style="vertical-align: inherit;">3 MB |</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece-me que √© √∫til avaliar problemas dessa perspectiva. </font><font style="vertical-align: inherit;">Isso deixa claro que algumas id√©ias n√£o s√£o vi√°veis. </font><font style="vertical-align: inherit;">Atingir 240 Hz n√£o √© f√°cil. </font><font style="vertical-align: inherit;">Isso n√£o vai acontecer por si s√≥.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os n√∫meros que todo programador deve saber (2020)</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A lista anterior est√° desatualizada. </font><font style="vertical-align: inherit;">Agora, ele precisa ser atualizado e colocado em conformidade at√© 2020. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√£o alguns n√∫meros para o meu computador dom√©stico. </font><font style="vertical-align: inherit;">Esta √© uma mistura de AIDA64, Sandra e meus benchmarks. </font><font style="vertical-align: inherit;">As figuras n√£o d√£o uma imagem completa e s√£o apenas um ponto de partida.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lat√™ncia L1: 1 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atraso L2: 2,5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atraso L3: 10 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lat√™ncia RAM: 50 ns</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(por segmento)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banda L1: 210 GB / s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banda L2: 80 GB / s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banda L3: 60 GB / s</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(todo sistema)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banda RAM: 45 GB / s</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seria bom criar um pequeno e simples benchmark de c√≥digo aberto. </font><font style="vertical-align: inherit;">Algum arquivo C que pode ser executado em computadores desktop, servidores, dispositivos m√≥veis, consoles etc. Mas eu n√£o sou o tipo de pessoa que escreve essa ferramenta.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nega√ß√£o de responsabilidade</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Medir a largura de banda da mem√≥ria √© dif√≠cil. </font><font style="vertical-align: inherit;">Muito dif√≠cil. </font><font style="vertical-align: inherit;">Provavelmente h√° erros no meu c√≥digo. </font><font style="vertical-align: inherit;">Muitos fatores n√£o contabilizados. </font><font style="vertical-align: inherit;">Se voc√™ tem alguma cr√≠tica por minha t√©cnica, provavelmente est√° certo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em √∫ltima an√°lise, acho que isso √© normal. </font><font style="vertical-align: inherit;">Este artigo n√£o √© sobre o desempenho exato da minha √°rea de trabalho. </font><font style="vertical-align: inherit;">Esta √© uma declara√ß√£o de problema de um certo ponto de vista. </font><font style="vertical-align: inherit;">E sobre como aprender a fazer alguns c√°lculos matem√°ticos.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclus√£o</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um colega compartilhou comigo uma opini√£o interessante sobre a largura de banda da mem√≥ria da GPU e o desempenho do aplicativo. </font><font style="vertical-align: inherit;">Isso me levou a estudar o desempenho da mem√≥ria em computadores modernos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para c√°lculos aproximados, aqui est√£o alguns n√∫meros para uma √°rea de trabalho moderna:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desempenho RAM</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√°ximo: </font></font><code>45 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em m√©dia, aproximadamente: </font></font><code>5 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√≠nimo: </font></font><code>1 /</code></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desempenho de cache L1 / L2 / L3 (por n√∫cleo)</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√°ximo (c simd): </font></font><code>210 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>80 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>60 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em m√©dia, aproximadamente: </font></font><code>25 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>15 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>9 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√≠nimo: </font></font><code>13 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>8 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>3,5 /</code></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As classifica√ß√µes de amostra est√£o relacionadas ao desempenho </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">C√≥digo real nunca ser√° t√£o simples. </font><font style="vertical-align: inherit;">Mas para c√°lculos em um guardanapo, este √© um ponto de partida razo√°vel. </font><font style="vertical-align: inherit;">Voc√™ precisa ajustar esta figura com base nos padr√µes de acesso √† mem√≥ria do seu programa, nas caracter√≠sticas do seu equipamento e no c√≥digo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, o mais importante √© uma nova maneira de pensar sobre os problemas. </font><font style="vertical-align: inherit;">Apresentar o problema em bytes por segundo ou bytes por quadro √© outra lente a ser examinada. </font><font style="vertical-align: inherit;">Esta √© uma ferramenta √∫til por precau√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obrigado pela leitura.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonte</font></font></h1><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√°fico de </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">refer√™ncia C ++ </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Python </font></a></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data.json</font></font></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais pesquisa</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artigo tocou apenas ligeiramente no t√≥pico. </font><font style="vertical-align: inherit;">Eu provavelmente n√£o vou entrar nisso. </font><font style="vertical-align: inherit;">Mas, se o fizesse, ele poderia cobrir alguns dos seguintes aspectos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desempenho de grava√ß√£o</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compartilhamento falso</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desempenho </font></font><code>std::atomic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ou falta dele)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contadores de desempenho</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desempenho TLB</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocolos de cache</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Especifica√ß√µes do sistema</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os testes foram realizados no meu PC em casa. </font><font style="vertical-align: inherit;">Somente configura√ß√µes de estoque, sem overclock.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SO: Windows 10 v1903 compila√ß√£o 18362</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU: Intel i7-8700k a 3,70 GHz</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mem√≥ria RAM: 2x16 GSkill Ripjaw DDR4-3200 (16-18-18-38 @ 1600 MHz)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Placa-m√£e: Asus TUF Z370-Plus Gaming</font></font></li>
</ul></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt487884/index.html">5 coisas que eu gostaria de saber antes de desenvolver o interc√¢mbio</a></li>
<li><a href="../pt487888/index.html">CSRF na Umbraco CMS</a></li>
<li><a href="../pt487890/index.html">Traduzir fala para texto no iOS usando a estrutura de fala</a></li>
<li><a href="../pt487894/index.html">BarsUP.AM: como desenvolvemos uma ferramenta para proteger informa√ß√µes de aplicativos da web</a></li>
<li><a href="../pt487896/index.html">Quando a morte se transforma em arte: epit√°fios de pessoas famosas com um significado profundo em ingl√™s</a></li>
<li><a href="../pt487900/index.html">pyqtdeploy, ou empacotamos o programa Python em exe'shnik ... da maneira mais dif√≠cil</a></li>
<li><a href="../pt487902/index.html">Do fogo ao fogo: eletr√≥lito de estado s√≥lido refrat√°rio para baterias de √≠ons de l√≠tio</a></li>
<li><a href="../pt487906/index.html">O livro "Redes de computadores. Princ√≠pios, tecnologias, protocolos: edi√ß√£o de anivers√°rio ¬ª</a></li>
<li><a href="../pt487908/index.html">O in√≠cio da guerra dos processos tecnol√≥gicos: 5 nm e 3 nm</a></li>
<li><a href="../pt487910/index.html">Leis naturais e matem√°tica elegante: problemas e solu√ß√µes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>