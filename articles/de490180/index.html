<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☠️ 📊 👨🏿 Kubernetes Speichermuster 🐺 🙇🏽 🔼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 
 
 Wir erinnern Sie daran, dass wir ein weiteres äußerst interessantes und nützliches Buch über Kubernetes-Muster veröffentlicht haben. A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kubernetes Speichermuster</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/490180/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ku/xh/fw/kuxhfwyrk51o4xpq6d1km-gpfbg.png"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hallo Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erinnern Sie daran, dass wir ein weiteres äußerst interessantes und nützliches </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> über Kubernetes-Muster veröffentlicht haben. </font><font style="vertical-align: inherit;">Alles begann mit </font><font style="vertical-align: inherit;">Brendan Burns ' </font><font style="vertical-align: inherit;">„ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patterns</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “, und die Arbeit in diesem Segment ist übrigens in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vollem Gange</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Heute laden wir Sie ein, einen Artikel aus dem MinIO-Blog zu lesen, der die Trends und Besonderheiten der Datenspeichermuster in Kubernetes zusammenfasst.</font></font><br>
<a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes hat die traditionellen Muster der Anwendungsentwicklung und -bereitstellung grundlegend geändert. </font><font style="vertical-align: inherit;">Jetzt kann das Team Tage brauchen, um die Anwendung zu entwickeln, zu testen und bereitzustellen - in verschiedenen Umgebungen und all dies innerhalb der Kubernetes-Cluster. </font><font style="vertical-align: inherit;">Solche Arbeiten mit Technologien früherer Generationen dauerten normalerweise Wochen, wenn nicht Monate.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine solche Beschleunigung wurde durch die von Kubernetes bereitgestellte Abstraktion ermöglicht - das heißt, dass Kubernetes selbst mit Details auf niedriger Ebene von physischen oder virtuellen Maschinen interagiert und es Benutzern ermöglicht, unter anderem den gewünschten Prozessor, den erforderlichen Speicher und die Anzahl der Containerinstanzen zu deklarieren. Da Kubernetes von einer riesigen Community unterstützt wird und der Umfang von Kubernetes ständig erweitert wird, führt es bei allen Container-Orchestrierungsplattformen mit großem Abstand. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der zunehmenden Verwendung von Kubernetes wächst auch die Verwirrung über die darin verwendeten Speichermuster</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der allgemeinen Konkurrenz um ein Stück Kubernetes-Kuchen (dh zur Datenspeicherung) ertrinkt das Signal in lautem Rauschen, wenn es um Datenspeicherung geht. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes verkörpert ein modernes Modell für die Entwicklung, Bereitstellung und Verwaltung von Anwendungen. Ein solches modernes Modell trennt die Datenspeicherung von der Datenverarbeitung. Um diese Trennung im Kontext von Kubernetes vollständig zu verstehen, müssen Sie auch verstehen, was statusbehaftete und zustandslose Anwendungen sind und wie Datenspeicherung damit kombiniert wird. Hier hat der von S3 verwendete REST-API-Ansatz klare Vorteile gegenüber dem für andere Lösungen typischen POSIX / CSI-Ansatz.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werden wir über Speichermuster in Kubernetes sprechen und die Debatte über staatsichere und zustandslose Anwendungen separat diskutieren, damit wir den Unterschied zwischen ihnen und warum es wichtig ist, klar verstehen können. </font><font style="vertical-align: inherit;">Im weiteren Verlauf des Textes werden Anwendungen und die darin verwendeten Datenspeichermuster im Lichte der Best Practices für die Arbeit mit Containern und Kubernetes betrachtet.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Staatenlose Container</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Container sind von Natur aus leicht und kurzlebig. </font><font style="vertical-align: inherit;">Sie können einfach gestoppt, gelöscht oder auf einem anderen Knoten bereitgestellt werden - dies dauert nur wenige Sekunden. </font><font style="vertical-align: inherit;">In einem Orchestrierungssystem für große Container finden solche Vorgänge kontinuierlich statt, und Benutzer bemerken solche Änderungen nicht einmal. </font><font style="vertical-align: inherit;">Bewegungen sind jedoch nur möglich, wenn der Container keine Abhängigkeiten von dem Knoten aufweist, auf dem er sich befindet. </font><font style="vertical-align: inherit;">Diese Behälter sollen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ohne staatliche Erhaltung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktionieren </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stateful Container</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Container Daten auf lokal verbundenen Geräten (oder auf einem Blockgerät) speichert, muss das Data Warehouse, auf dem er sich befindet, zusammen mit dem Container selbst auf einen neuen Knoten verschoben werden - im Fehlerfall. Dies ist wichtig, da sonst die im Container ausgeführte Anwendung nicht ordnungsgemäß funktionieren kann, da sie auf Daten zugreifen muss, die auf lokalen Medien gespeichert sind. Diese Behälter sollen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zustandsbehaftet sein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus rein technischer Sicht können Stateful Container auch auf andere Knoten verschoben werden. In der Regel wird dies mithilfe verteilter Dateisysteme oder Blocknetzwerkspeichern erreicht, die an alle Knoten angeschlossen sind, auf denen Container ausgeführt werden. Auf diese Weise erhalten Container Zugriff auf Volumes zur dauerhaften Datenspeicherung, und Informationen werden auf Datenträgern im gesamten Netzwerk gespeichert. Ich werde eine solche Methode als " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zustandserhaltenden Container-Ansatz</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " bezeichnen, und im Rest des Artikels werde ich sie aus Gründen der Einheitlichkeit nennen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y1/cs/6z/y1cs6zoudpecfzs6ww-aw8ocxyg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einem typischen Stateful-Container-Ansatz werden alle Anwendungs-Pods an ein verteiltes Dateisystem angehängt. Es wird eine Art gemeinsamer Speicher erhalten, in dem alle Anwendungsdaten erfasst werden. </font><font style="vertical-align: inherit;">Während einige Variationen möglich sind, ist dies ein Ansatz auf hoher Ebene. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns nun an, warum der Stateful-Container-Ansatz in der Cloud-basierten Welt Antipattern ist.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud-basiertes Anwendungsdesign</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Traditionell verwendeten Anwendungen Datenbanken zur strukturierten Speicherung von Informationen und lokalen Datenträgern oder verteilten Dateisystemen, in denen alle unstrukturierten oder sogar halbstrukturierten Daten gespeichert wurden. Als das Volumen unstrukturierter Daten zunahm, stellten die Entwickler fest, dass POSIX zu gesprächig war, mit erheblichen Kosten verbunden war und letztendlich die Anwendung störte, wenn es zu einem wirklich großen Umfang überging.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies trug hauptsächlich zur Entstehung eines neuen Standards für die Datenspeicherung bei, dh Cloud-basierte Speicher, die hauptsächlich auf der Basis der REST-API arbeiten und die Anwendung von der aufwändigen Wartung des lokalen Data Warehouse befreien. In diesem Fall wechselt die Anwendung tatsächlich in den Betriebsmodus, ohne den Status zu speichern (da sich der Status im Remotespeicher befindet). Moderne Anwendungen werden bereits unter Berücksichtigung dieses Faktors von Grund auf neu erstellt. In der Regel basiert jede moderne Anwendung, die Daten der einen oder anderen Art (Protokolle, Metadaten, Blobs usw.) verarbeitet, auf einem Cloud-orientierten Paradigma, bei dem der Status an ein speziell für seine Speicherung zugewiesenes Softwaresystem übertragen wird.</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Stateful-Container-Ansatz lässt dieses ganze Paradigma genau dahin zurückrollen, wo es begonnen hat!</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bei Verwendung von POSIX-Schnittstellen zum Speichern von Daten funktionieren Anwendungen so, als ob sie den Status beibehalten würden, und weichen daher von den wichtigsten Postulaten des Cloud-basierten Designs ab, dh von der Möglichkeit, die Größe der Anwendungsworkflows je nach Eingang zu variieren Laden Sie, wechseln Sie zu einem neuen Knoten, sobald der aktuelle Knoten ausfällt, und so weiter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein genauerer Blick auf diese Situation zeigt, dass wir bei der Auswahl eines Data Warehouse immer wieder vor dem Dilemma „POSIX versus REST API“ stehen, ABER mit einer zusätzlichen Verschärfung der POSIX-Probleme, die durch die verteilte Natur von Kubernetes-Umgebungen verursacht werden. Insbesondere,</font></font><br>
<br>
<ul>
<li><b>POSIX </b>:  POSIX         ,     .     ,     . API   ,  , S3 API,    ,   ,   «»  .     ,       .        .</li>
<li><b> </b>:    ,     ,          . ,  ,            (    ),         ,     . -  POSIX       .   , S3 API       ,      ,  ,     .</li>
<li><b></b>:   POSIX     :          .      - .      ,   API,       ,   ,     ..</li>
<li><b></b>:       ,   .       ,    ,     ,      .  ,     ,      ,   .</li>
</ul><br>
<h4>   </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während die Container Data Storage Interface (CSI) bei der Verteilung des Kubernetes-Volumens sehr hilfreich war und diese teilweise an Drittanbieter von Data Warehouse weitergab, trug sie versehentlich dazu bei, dass der Stateful Container-Ansatz die empfohlene Methode zur Datenspeicherung in Kubernetes war. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSI wurde als Standard für die Bereitstellung beliebiger Block- und Dateispeichersysteme für Legacy-Anwendungen bei der Arbeit mit Kubernetes entwickelt. Und wie in diesem Artikel gezeigt wurde, ist die einzige Situation, in der ein Stateful-Container-Ansatz (und CSI in seiner aktuellen Form) angemessen ist, wenn die Anwendung selbst ein Legacy-System ist, in dem es unmöglich ist, Unterstützung für die Objektdatenspeicher-API hinzuzufügen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wichtig zu verstehen, dass bei Verwendung von CSI in der aktuellen Form, dh beim Mounten von Volumes bei der Arbeit mit modernen Anwendungen, ungefähr dieselben Probleme auftreten wie bei Systemen, bei denen die Datenspeicherung im POSIX-Stil organisiert ist.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besserer Ansatz</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall ist es wichtig zu verstehen, dass die meisten Anwendungen von Natur aus nicht speziell für Arbeiten mit oder ohne Zustandserhaltung geschärft werden. </font><font style="vertical-align: inherit;">Dieses Verhalten hängt von der Gesamtarchitektur des Systems und von den spezifischen Optionen ab, die während des Entwurfs ausgewählt wurden. </font><font style="vertical-align: inherit;">Lassen Sie uns ein wenig über zustandsbehaftete Anwendungen sprechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grundsätzlich können alle Anwendungsdaten in mehrere große Typen unterteilt werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logdaten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitstempeldaten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaktionsdaten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metadaten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Containerbilder</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blob-Daten (Blobs)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle diese Datentypen werden auf modernen Datenspeicherplattformen sehr gut unterstützt, und es gibt mehrere Cloud-basierte Plattformen, die für die Bereitstellung von Daten in jedem dieser spezifischen Formate angepasst sind. Beispielsweise können sich Transaktionsdaten und Metadaten in einer modernen Cloud-basierten Datenbank wie CockroachDB, YugaByte usw. befinden. Container-Images oder Blob-Daten können in der Docker-Registrierung basierend auf MinIO gespeichert werden. Zeitstempeldaten können in einer Zeitreihendatenbank wie InfluxDB usw. gespeichert werden. Wir werden nicht auf Details der einzelnen Datentypen und verwandten Anwendungen eingehen, aber die allgemeine Idee besteht darin, eine dauerhafte Datenspeicherung auf der Grundlage der lokalen Festplattenmontage zu vermeiden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/us/gk/li/usgklihtry8ddkgmpkumtziiv3y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus ist es häufig effektiv, eine temporäre Caching-Schicht bereitzustellen, die als eine Art temporärer Dateispeicher für Anwendungen dient. Anwendungen sollten jedoch nicht von dieser Ebene als Quelle der Wahrheit abhängen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stateful Application Storage</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während es in den meisten Fällen nützlich ist, Anwendungen zustandslos zu halten, sollten Anwendungen, die zum Speichern von Daten bestimmt sind, z. B. Datenbanken, Objektspeicher, Schlüssel- und Wertspeicher, den Status beibehalten. </font><font style="vertical-align: inherit;">Mal sehen, warum diese Anwendungen auf Kubernetes bereitgestellt werden. </font><font style="vertical-align: inherit;">Nehmen Sie als Beispiel MinIO, aber ähnliche Prinzipien gelten auch für andere große Cloud-basierte Speichersysteme.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cloud-zentrierte Anwendungen wurden entwickelt, um die Flexibilität der Container zu maximieren. Dies bedeutet, dass sie keine Annahmen über die Umgebung treffen, in der sie bereitgestellt werden. Beispielsweise verwendet MinIO einen internen Löschcodierungsmechanismus, der dem System eine ausreichende Stabilität bietet, sodass es auch dann betriebsbereit bleibt, wenn die Hälfte der Laufwerke ausfällt. MinIO verwaltet auch die Datenintegrität und -sicherheit mithilfe seines eigenen serverseitigen Hashings und seiner eigenen Verschlüsselung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für solche Cloud-basierten Anwendungen sind lokale persistente Volumes (PV) als Backup-Speicher am bequemsten. </font><font style="vertical-align: inherit;">Lokale PV bietet die Möglichkeit, Rohdaten zu speichern, während Anwendungen, die auf diesen PVs ausgeführt werden, unabhängig voneinander Informationen sammeln, um Daten zu skalieren und wachsende Datenanforderungen zu verwalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Ansatz ist viel einfacher und wesentlich besser skalierbar als CSI-basierte PV, die dem System ein eigenes Maß an Datenverwaltung und Redundanz verleihen. </font><font style="vertical-align: inherit;">Tatsache ist, dass diese Ebenen normalerweise im Widerspruch zu Anwendungen stehen, die nach dem Prinzip der staatlichen Bewahrung konzipiert sind.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuversichtlich, Daten aus dem Computing zu entfernen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel haben wir darüber gesprochen, wie Anwendungen neu ausgerichtet werden, um zu funktionieren, ohne den Status zu speichern, oder mit anderen Worten, die Datenspeicherung wird von der Berechnung auf ihnen begrenzt. Betrachten Sie abschließend einige Beispiele aus der Praxis für einen solchen Trend. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die bekannte Datenanalyseplattform, wurde traditionell für die zustandsbehaftete Bereitstellung und Bereitstellung im HDFS-Dateisystem verwendet. Mit dem Übergang von Spark zu einer Cloud-basierten Welt wird diese Plattform jedoch zunehmend ohne Zustandserhaltung mit "s3a" verwendet. Spark verwendet s3a, um den Status auf andere Systeme zu übertragen, während Spark-Container selbst vollständig ohne Statuserhaltung arbeiten. Andere große Unternehmen im Bereich der Big-Data-Analyse, insbesondere </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teradata</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Greenplum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> geht auch mit der Aufteilung der Datenspeicherung zu arbeiten und die </font><font style="vertical-align: inherit;">Berechnung über sie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ähnliche Muster sind auch auf anderen großen Analyseplattformen zu sehen, einschließlich Presto, Tensorflow to R, Jupyter. </font><font style="vertical-align: inherit;">Das Hochladen des Status auf Remote-Cloud-Speichersysteme erleichtert die Verwaltung und Skalierung Ihrer Anwendung erheblich. </font><font style="vertical-align: inherit;">Darüber hinaus unterstützt es die Portabilität der Anwendung auf eine Vielzahl von Umgebungen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de490162/index.html">Die Macken der Evolution: die Entdeckung eines Organismus, der ohne Sauerstoff lebt</a></li>
<li><a href="../de490168/index.html">Analyse der Qualität des Chatbots im IBM Watson Assistant</a></li>
<li><a href="../de490170/index.html">Projektmanager in einem Laster. Warum so und was dagegen zu tun ist</a></li>
<li><a href="../de490174/index.html">DNS-Suche in Kubernetes</a></li>
<li><a href="../de490178/index.html">Während alle nach Westen fahren, bin ich nach Armenien gezogen</a></li>
<li><a href="../de490184/index.html">Alphabet hat eine zweite, geheime Gruppe von Quantencomputerentwicklern</a></li>
<li><a href="../de490186/index.html">Woraus wir JET BI gemacht haben. Architektur Business Intelligence System ohne lyrische Abweichungen</a></li>
<li><a href="../de490190/index.html">Ich werde suchen: Host-Geopositionierung nach IP-Adresse im globalen Internet am Beispiel des Binance-Krypto-Austauschs</a></li>
<li><a href="../de490194/index.html">Verwenden von RabbitMQ mit MonsterMQ Teil 4</a></li>
<li><a href="../de490196/index.html">[Flipper Zero] lehne Raspberry Pi ab, mache unser eigenes Board von Grund auf neu. Den richtigen WiFi-Chip finden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>