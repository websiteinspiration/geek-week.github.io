<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò†Ô∏è üìä üë®üèø Kubernetes Speichermuster üê∫ üôáüèΩ üîº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 
 
 Wir erinnern Sie daran, dass wir ein weiteres √§u√üerst interessantes und n√ºtzliches Buch √ºber Kubernetes-Muster ver√∂ffentlicht haben. A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kubernetes Speichermuster</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/490180/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ku/xh/fw/kuxhfwyrk51o4xpq6d1km-gpfbg.png"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hallo Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erinnern Sie daran, dass wir ein weiteres √§u√üerst interessantes und n√ºtzliches </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ºber Kubernetes-Muster ver√∂ffentlicht haben. </font><font style="vertical-align: inherit;">Alles begann mit </font><font style="vertical-align: inherit;">Brendan Burns ' </font><font style="vertical-align: inherit;">‚Äû </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patterns</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äú, und die Arbeit in diesem Segment ist √ºbrigens in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vollem Gange</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Heute laden wir Sie ein, einen Artikel aus dem MinIO-Blog zu lesen, der die Trends und Besonderheiten der Datenspeichermuster in Kubernetes zusammenfasst.</font></font><br>
<a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes hat die traditionellen Muster der Anwendungsentwicklung und -bereitstellung grundlegend ge√§ndert. </font><font style="vertical-align: inherit;">Jetzt kann das Team Tage brauchen, um die Anwendung zu entwickeln, zu testen und bereitzustellen - in verschiedenen Umgebungen und all dies innerhalb der Kubernetes-Cluster. </font><font style="vertical-align: inherit;">Solche Arbeiten mit Technologien fr√ºherer Generationen dauerten normalerweise Wochen, wenn nicht Monate.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine solche Beschleunigung wurde durch die von Kubernetes bereitgestellte Abstraktion erm√∂glicht - das hei√üt, dass Kubernetes selbst mit Details auf niedriger Ebene von physischen oder virtuellen Maschinen interagiert und es Benutzern erm√∂glicht, unter anderem den gew√ºnschten Prozessor, den erforderlichen Speicher und die Anzahl der Containerinstanzen zu deklarieren. Da Kubernetes von einer riesigen Community unterst√ºtzt wird und der Umfang von Kubernetes st√§ndig erweitert wird, f√ºhrt es bei allen Container-Orchestrierungsplattformen mit gro√üem Abstand. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der zunehmenden Verwendung von Kubernetes w√§chst auch die Verwirrung √ºber die darin verwendeten Speichermuster</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der allgemeinen Konkurrenz um ein St√ºck Kubernetes-Kuchen (dh zur Datenspeicherung) ertrinkt das Signal in lautem Rauschen, wenn es um Datenspeicherung geht. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes verk√∂rpert ein modernes Modell f√ºr die Entwicklung, Bereitstellung und Verwaltung von Anwendungen. Ein solches modernes Modell trennt die Datenspeicherung von der Datenverarbeitung. Um diese Trennung im Kontext von Kubernetes vollst√§ndig zu verstehen, m√ºssen Sie auch verstehen, was statusbehaftete und zustandslose Anwendungen sind und wie Datenspeicherung damit kombiniert wird. Hier hat der von S3 verwendete REST-API-Ansatz klare Vorteile gegen√ºber dem f√ºr andere L√∂sungen typischen POSIX / CSI-Ansatz.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werden wir √ºber Speichermuster in Kubernetes sprechen und die Debatte √ºber staatsichere und zustandslose Anwendungen separat diskutieren, damit wir den Unterschied zwischen ihnen und warum es wichtig ist, klar verstehen k√∂nnen. </font><font style="vertical-align: inherit;">Im weiteren Verlauf des Textes werden Anwendungen und die darin verwendeten Datenspeichermuster im Lichte der Best Practices f√ºr die Arbeit mit Containern und Kubernetes betrachtet.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Staatenlose Container</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Container sind von Natur aus leicht und kurzlebig. </font><font style="vertical-align: inherit;">Sie k√∂nnen einfach gestoppt, gel√∂scht oder auf einem anderen Knoten bereitgestellt werden - dies dauert nur wenige Sekunden. </font><font style="vertical-align: inherit;">In einem Orchestrierungssystem f√ºr gro√üe Container finden solche Vorg√§nge kontinuierlich statt, und Benutzer bemerken solche √Ñnderungen nicht einmal. </font><font style="vertical-align: inherit;">Bewegungen sind jedoch nur m√∂glich, wenn der Container keine Abh√§ngigkeiten von dem Knoten aufweist, auf dem er sich befindet. </font><font style="vertical-align: inherit;">Diese Beh√§lter sollen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ohne staatliche Erhaltung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktionieren </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stateful Container</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Container Daten auf lokal verbundenen Ger√§ten (oder auf einem Blockger√§t) speichert, muss das Data Warehouse, auf dem er sich befindet, zusammen mit dem Container selbst auf einen neuen Knoten verschoben werden - im Fehlerfall. Dies ist wichtig, da sonst die im Container ausgef√ºhrte Anwendung nicht ordnungsgem√§√ü funktionieren kann, da sie auf Daten zugreifen muss, die auf lokalen Medien gespeichert sind. Diese Beh√§lter sollen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zustandsbehaftet sein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus rein technischer Sicht k√∂nnen Stateful Container auch auf andere Knoten verschoben werden. In der Regel wird dies mithilfe verteilter Dateisysteme oder Blocknetzwerkspeichern erreicht, die an alle Knoten angeschlossen sind, auf denen Container ausgef√ºhrt werden. Auf diese Weise erhalten Container Zugriff auf Volumes zur dauerhaften Datenspeicherung, und Informationen werden auf Datentr√§gern im gesamten Netzwerk gespeichert. Ich werde eine solche Methode als " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zustandserhaltenden Container-Ansatz</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " bezeichnen, und im Rest des Artikels werde ich sie aus Gr√ºnden der Einheitlichkeit nennen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y1/cs/6z/y1cs6zoudpecfzs6ww-aw8ocxyg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einem typischen Stateful-Container-Ansatz werden alle Anwendungs-Pods an ein verteiltes Dateisystem angeh√§ngt. Es wird eine Art gemeinsamer Speicher erhalten, in dem alle Anwendungsdaten erfasst werden. </font><font style="vertical-align: inherit;">W√§hrend einige Variationen m√∂glich sind, ist dies ein Ansatz auf hoher Ebene. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns nun an, warum der Stateful-Container-Ansatz in der Cloud-basierten Welt Antipattern ist.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud-basiertes Anwendungsdesign</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Traditionell verwendeten Anwendungen Datenbanken zur strukturierten Speicherung von Informationen und lokalen Datentr√§gern oder verteilten Dateisystemen, in denen alle unstrukturierten oder sogar halbstrukturierten Daten gespeichert wurden. Als das Volumen unstrukturierter Daten zunahm, stellten die Entwickler fest, dass POSIX zu gespr√§chig war, mit erheblichen Kosten verbunden war und letztendlich die Anwendung st√∂rte, wenn es zu einem wirklich gro√üen Umfang √ºberging.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies trug haupts√§chlich zur Entstehung eines neuen Standards f√ºr die Datenspeicherung bei, dh Cloud-basierte Speicher, die haupts√§chlich auf der Basis der REST-API arbeiten und die Anwendung von der aufw√§ndigen Wartung des lokalen Data Warehouse befreien. In diesem Fall wechselt die Anwendung tats√§chlich in den Betriebsmodus, ohne den Status zu speichern (da sich der Status im Remotespeicher befindet). Moderne Anwendungen werden bereits unter Ber√ºcksichtigung dieses Faktors von Grund auf neu erstellt. In der Regel basiert jede moderne Anwendung, die Daten der einen oder anderen Art (Protokolle, Metadaten, Blobs usw.) verarbeitet, auf einem Cloud-orientierten Paradigma, bei dem der Status an ein speziell f√ºr seine Speicherung zugewiesenes Softwaresystem √ºbertragen wird.</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Stateful-Container-Ansatz l√§sst dieses ganze Paradigma genau dahin zur√ºckrollen, wo es begonnen hat!</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bei Verwendung von POSIX-Schnittstellen zum Speichern von Daten funktionieren Anwendungen so, als ob sie den Status beibehalten w√ºrden, und weichen daher von den wichtigsten Postulaten des Cloud-basierten Designs ab, dh von der M√∂glichkeit, die Gr√∂√üe der Anwendungsworkflows je nach Eingang zu variieren Laden Sie, wechseln Sie zu einem neuen Knoten, sobald der aktuelle Knoten ausf√§llt, und so weiter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein genauerer Blick auf diese Situation zeigt, dass wir bei der Auswahl eines Data Warehouse immer wieder vor dem Dilemma ‚ÄûPOSIX versus REST API‚Äú stehen, ABER mit einer zus√§tzlichen Versch√§rfung der POSIX-Probleme, die durch die verteilte Natur von Kubernetes-Umgebungen verursacht werden. Insbesondere,</font></font><br>
<br>
<ul>
<li><b>POSIX </b>:  POSIX         ,     .     ,     . API   ,  , S3 API,    ,   ,   ¬´¬ª  .     ,       .        .</li>
<li><b> </b>:    ,     ,          . ,  ,            (    ),         ,     . -  POSIX       .   , S3 API       ,      ,  ,     .</li>
<li><b></b>:   POSIX     :          .      - .      ,   API,       ,   ,     ..</li>
<li><b></b>:       ,   .       ,    ,     ,      .  ,     ,      ,   .</li>
</ul><br>
<h4>   </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend die Container Data Storage Interface (CSI) bei der Verteilung des Kubernetes-Volumens sehr hilfreich war und diese teilweise an Drittanbieter von Data Warehouse weitergab, trug sie versehentlich dazu bei, dass der Stateful Container-Ansatz die empfohlene Methode zur Datenspeicherung in Kubernetes war. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSI wurde als Standard f√ºr die Bereitstellung beliebiger Block- und Dateispeichersysteme f√ºr Legacy-Anwendungen bei der Arbeit mit Kubernetes entwickelt. Und wie in diesem Artikel gezeigt wurde, ist die einzige Situation, in der ein Stateful-Container-Ansatz (und CSI in seiner aktuellen Form) angemessen ist, wenn die Anwendung selbst ein Legacy-System ist, in dem es unm√∂glich ist, Unterst√ºtzung f√ºr die Objektdatenspeicher-API hinzuzuf√ºgen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wichtig zu verstehen, dass bei Verwendung von CSI in der aktuellen Form, dh beim Mounten von Volumes bei der Arbeit mit modernen Anwendungen, ungef√§hr dieselben Probleme auftreten wie bei Systemen, bei denen die Datenspeicherung im POSIX-Stil organisiert ist.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besserer Ansatz</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall ist es wichtig zu verstehen, dass die meisten Anwendungen von Natur aus nicht speziell f√ºr Arbeiten mit oder ohne Zustandserhaltung gesch√§rft werden. </font><font style="vertical-align: inherit;">Dieses Verhalten h√§ngt von der Gesamtarchitektur des Systems und von den spezifischen Optionen ab, die w√§hrend des Entwurfs ausgew√§hlt wurden. </font><font style="vertical-align: inherit;">Lassen Sie uns ein wenig √ºber zustandsbehaftete Anwendungen sprechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grunds√§tzlich k√∂nnen alle Anwendungsdaten in mehrere gro√üe Typen unterteilt werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logdaten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitstempeldaten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaktionsdaten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metadaten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Containerbilder</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blob-Daten (Blobs)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle diese Datentypen werden auf modernen Datenspeicherplattformen sehr gut unterst√ºtzt, und es gibt mehrere Cloud-basierte Plattformen, die f√ºr die Bereitstellung von Daten in jedem dieser spezifischen Formate angepasst sind. Beispielsweise k√∂nnen sich Transaktionsdaten und Metadaten in einer modernen Cloud-basierten Datenbank wie CockroachDB, YugaByte usw. befinden. Container-Images oder Blob-Daten k√∂nnen in der Docker-Registrierung basierend auf MinIO gespeichert werden. Zeitstempeldaten k√∂nnen in einer Zeitreihendatenbank wie InfluxDB usw. gespeichert werden. Wir werden nicht auf Details der einzelnen Datentypen und verwandten Anwendungen eingehen, aber die allgemeine Idee besteht darin, eine dauerhafte Datenspeicherung auf der Grundlage der lokalen Festplattenmontage zu vermeiden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/us/gk/li/usgklihtry8ddkgmpkumtziiv3y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus ist es h√§ufig effektiv, eine tempor√§re Caching-Schicht bereitzustellen, die als eine Art tempor√§rer Dateispeicher f√ºr Anwendungen dient. Anwendungen sollten jedoch nicht von dieser Ebene als Quelle der Wahrheit abh√§ngen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stateful Application Storage</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend es in den meisten F√§llen n√ºtzlich ist, Anwendungen zustandslos zu halten, sollten Anwendungen, die zum Speichern von Daten bestimmt sind, z. B. Datenbanken, Objektspeicher, Schl√ºssel- und Wertspeicher, den Status beibehalten. </font><font style="vertical-align: inherit;">Mal sehen, warum diese Anwendungen auf Kubernetes bereitgestellt werden. </font><font style="vertical-align: inherit;">Nehmen Sie als Beispiel MinIO, aber √§hnliche Prinzipien gelten auch f√ºr andere gro√üe Cloud-basierte Speichersysteme.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cloud-zentrierte Anwendungen wurden entwickelt, um die Flexibilit√§t der Container zu maximieren. Dies bedeutet, dass sie keine Annahmen √ºber die Umgebung treffen, in der sie bereitgestellt werden. Beispielsweise verwendet MinIO einen internen L√∂schcodierungsmechanismus, der dem System eine ausreichende Stabilit√§t bietet, sodass es auch dann betriebsbereit bleibt, wenn die H√§lfte der Laufwerke ausf√§llt. MinIO verwaltet auch die Datenintegrit√§t und -sicherheit mithilfe seines eigenen serverseitigen Hashings und seiner eigenen Verschl√ºsselung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr solche Cloud-basierten Anwendungen sind lokale persistente Volumes (PV) als Backup-Speicher am bequemsten. </font><font style="vertical-align: inherit;">Lokale PV bietet die M√∂glichkeit, Rohdaten zu speichern, w√§hrend Anwendungen, die auf diesen PVs ausgef√ºhrt werden, unabh√§ngig voneinander Informationen sammeln, um Daten zu skalieren und wachsende Datenanforderungen zu verwalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Ansatz ist viel einfacher und wesentlich besser skalierbar als CSI-basierte PV, die dem System ein eigenes Ma√ü an Datenverwaltung und Redundanz verleihen. </font><font style="vertical-align: inherit;">Tatsache ist, dass diese Ebenen normalerweise im Widerspruch zu Anwendungen stehen, die nach dem Prinzip der staatlichen Bewahrung konzipiert sind.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuversichtlich, Daten aus dem Computing zu entfernen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel haben wir dar√ºber gesprochen, wie Anwendungen neu ausgerichtet werden, um zu funktionieren, ohne den Status zu speichern, oder mit anderen Worten, die Datenspeicherung wird von der Berechnung auf ihnen begrenzt. Betrachten Sie abschlie√üend einige Beispiele aus der Praxis f√ºr einen solchen Trend. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die bekannte Datenanalyseplattform, wurde traditionell f√ºr die zustandsbehaftete Bereitstellung und Bereitstellung im HDFS-Dateisystem verwendet. Mit dem √úbergang von Spark zu einer Cloud-basierten Welt wird diese Plattform jedoch zunehmend ohne Zustandserhaltung mit "s3a" verwendet. Spark verwendet s3a, um den Status auf andere Systeme zu √ºbertragen, w√§hrend Spark-Container selbst vollst√§ndig ohne Statuserhaltung arbeiten. Andere gro√üe Unternehmen im Bereich der Big-Data-Analyse, insbesondere </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teradata</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Greenplum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> geht auch mit der Aufteilung der Datenspeicherung zu arbeiten und die </font><font style="vertical-align: inherit;">Berechnung √ºber sie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ñhnliche Muster sind auch auf anderen gro√üen Analyseplattformen zu sehen, einschlie√ülich Presto, Tensorflow to R, Jupyter. </font><font style="vertical-align: inherit;">Das Hochladen des Status auf Remote-Cloud-Speichersysteme erleichtert die Verwaltung und Skalierung Ihrer Anwendung erheblich. </font><font style="vertical-align: inherit;">Dar√ºber hinaus unterst√ºtzt es die Portabilit√§t der Anwendung auf eine Vielzahl von Umgebungen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de490162/index.html">Die Macken der Evolution: die Entdeckung eines Organismus, der ohne Sauerstoff lebt</a></li>
<li><a href="../de490168/index.html">Analyse der Qualit√§t des Chatbots im IBM Watson Assistant</a></li>
<li><a href="../de490170/index.html">Projektmanager in einem Laster. Warum so und was dagegen zu tun ist</a></li>
<li><a href="../de490174/index.html">DNS-Suche in Kubernetes</a></li>
<li><a href="../de490178/index.html">W√§hrend alle nach Westen fahren, bin ich nach Armenien gezogen</a></li>
<li><a href="../de490184/index.html">Alphabet hat eine zweite, geheime Gruppe von Quantencomputerentwicklern</a></li>
<li><a href="../de490186/index.html">Woraus wir JET BI gemacht haben. Architektur Business Intelligence System ohne lyrische Abweichungen</a></li>
<li><a href="../de490190/index.html">Ich werde suchen: Host-Geopositionierung nach IP-Adresse im globalen Internet am Beispiel des Binance-Krypto-Austauschs</a></li>
<li><a href="../de490194/index.html">Verwenden von RabbitMQ mit MonsterMQ Teil 4</a></li>
<li><a href="../de490196/index.html">[Flipper Zero] lehne Raspberry Pi ab, mache unser eigenes Board von Grund auf neu. Den richtigen WiFi-Chip finden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>