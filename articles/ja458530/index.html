<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✂️ 👨🏻‍🚒 👩🏽‍🌾 Zabbix、時系列、TimescaleDB ✍️ 📁 🏸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="各監視システムは、3種類のパフォーマンスの問題に直面しています。
 
 まず、優れた監視システムは、外部からのデータを非常に迅速に受信、処理、および記録する必要があります。アカウントはマイクロ秒になります。これは明らかではないように思われるかもしれませんが、システムが十分に大きくなると、これらの秒の...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Zabbix、時系列、TimescaleDB</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/zabbix/blog/458530/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各監視システムは、3種類のパフォーマンスの問題に直面しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、優れた監視システムは、外部からのデータを非常に迅速に受信、処理、および記録する必要があります。</font><font style="vertical-align: inherit;">アカウントはマイクロ秒になります。</font><font style="vertical-align: inherit;">これは明らかではないように思われるかもしれませんが、システムが十分に大きくなると、これらの秒の端数がすべて加算され、明らかに顕著な遅延に変わります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s6/fy/mx/s6fymxoyf5_f9n0hwidv8q6qsh4.png" alt="画像"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のタスクは、以前に収集されたメトリックの大規模な配列（つまり、履歴データ）への便利なアクセスを提供することです。</font><font style="vertical-align: inherit;">履歴データは、さまざまな状況で使用されます。</font><font style="vertical-align: inherit;">たとえば、レポートとグラフはそれらから生成され、集計チェックはそれらに基づいて構築され、トリガーはそれらに依存します。</font><font style="vertical-align: inherit;">履歴へのアクセスに遅延がある場合、システム全体の速度に直ちに影響します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第三に、履歴データは多くのスペースを使用します。比較的控えめな監視構成でも、確実な履歴をすばやく取得できます。ただし、5年前のプロセッサの負荷履歴を手元に残したいと考える人はほとんどいないため、監視システムは履歴を適切に記録できるだけでなく、履歴も削除できるはずです（Zabbixでは、このプロセスは「ハウスキーピング」と呼ばれます）。古いデータを削除することは、新しいデータを収集して分析するほど効率的である必要はありませんが、大量の削除操作は貴重なDBMSリソースを使用し、より重要な操作を遅くする可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の2つの問題はキャッシングによって解決されます。</font><font style="vertical-align: inherit;">Zabbixは、データの読み取りおよび書き込み操作を高速化するために、いくつかの特殊なキャッシュをサポートしています。</font><font style="vertical-align: inherit;">ここでは、DBMSメカニズム自体は適していません。</font><font style="vertical-align: inherit;">最も高度な汎用のキャッシュアルゴリズムでさえ、特定の時点でどのデータ構造が即時アクセスを必要とするかはわかりません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">監視と時系列データ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データがZabbixサーバーのメモリにある限り、すべてが正常です。</font><font style="vertical-align: inherit;">ただし、メモリは無限ではなく、ある時点でデータベースにデータを書き込む（または読み取る）必要があります。</font><font style="vertical-align: inherit;">また、データベースのパフォーマンスがメトリックの収集速度に大きく遅れている場合は、最も高度な特別なキャッシュアルゴリズムを使用しても、長期間は役に立ちません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目の問題は、データベースのパフォーマンスにも影響します。これを解決するには、他のデータベース操作に干渉しない信頼できる削除戦略を選択する必要があります。デフォルトでは、Zabbixは1時間あたり数千レコードのバッチで履歴データを削除します。データ収集の速度とデータベース内の場所で可能な場合は、より長いハウスキーピング期間またはより大きなパケットサイズを構成できます。ただし、非常に多数のメトリックやそれらを収集する頻度が高い場合、データ削除のスケジュールが新しいものを記録するペースに追いつかない可能性があるため、適切なハウスキーピング設定は困難な作業になる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要約すると、監視システムは3つの方向でパフォーマンスの問題を解決します-SQL INSERTクエリを使用して新しいデータを収集してデータベースに書き込む、SELECTクエリを使用してデータにアクセスする、DELETEを使用してデータを削除する。</font><font style="vertical-align: inherit;">一般的なSQLクエリの実行方法を見てみましょう。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DBMSはクエリを分析し、構文エラーをチェックします。</font><font style="vertical-align: inherit;">リクエストが構文的に正しい場合、エンジンはさらに処理するための構文ツリーを構築します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリプランナーは構文ツリーを分析し、クエリを実行するためのさまざまな方法（パス）を計算します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケジューラーは最も安い方法を計算します。</font><font style="vertical-align: inherit;">このプロセスでは、多くのことが考慮されます-テーブルの大きさ、結果の並べ替えが必要か、クエリに適用できるインデックスがあるかなどです。</font></font></li>
<li>   ,          (     ),     ,      .</li>
<li>  ,           .         ,     .</li>
<li> ,            .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、多くの作業があります。</font><font style="vertical-align: inherit;">ほとんどのDBMSは、クエリの最適化のために多くの設定を提供しますが、通常、レコードの挿入と削除が変更とほぼ同じ頻度で発生する、いくつかの平均的なワークフローに重点を置いています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、前述のとおり、監視システムの場合、最も一般的な操作は、バッチモードでの追加と定期的な削除です。</font><font style="vertical-align: inherit;">以前に追加されたデータの変更はほとんど発生せず、データへのアクセスには集約関数の使用が含まれます。</font><font style="vertical-align: inherit;">さらに、通常、追加されたメトリックの値は時間順に並べられます。</font><font style="vertical-align: inherit;">このようなデータは通常、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列は、一時的な順序でインデックスが付けられた（またはリストされた、または落書きされた）一連のデータポイントです。</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースの観点から、時系列には次のプロパティがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列は、時系列のブロックのシーケンスとしてディスク上に配置できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列テーブルには、時間列を使用してインデックスを付けることができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどのSQL SELECTクエリは、時間を示す列でWHERE、GROUP BY、またはORDER BY句を使用します。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常、時系列データには有効期限があり、それ以降は削除できます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然のことながら、汎用の最適化ではこれらの品質が考慮されていないため、従来のSQLデータベースはそのようなデータの格納には適していません。したがって、近年では、たとえばInfluxDBなど、時間を重視した新しいDBMSがかなり存在します。しかし、時系列でよく使用されるすべてのDBMSには、重大な欠点が1つあります-完全なSQLサポートがないことです。さらに、それらのほとんどはCRUD（作成、読み取り、更新、削除）でもありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZabbixはこれらのDBMSを何らかの方法で使用できますか？</font><font style="vertical-align: inherit;">可能なアプローチの1つは、時系列に特化した外部データベースに保存用の履歴データを転送することです。</font><font style="vertical-align: inherit;">Zabbixアーキテクチャが履歴データを格納するための外部バックエンドをサポートしている（たとえば、ZabbixがElasticsearchをサポートしている）場合、一見すると、このオプションは非常に合理的に見えます。</font><font style="vertical-align: inherit;">しかし、時系列で1つまたは複数のDBMSを外部サーバーとしてサポートした場合、ユーザーは次の点を考慮する必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査、構成、保守が必要な別のシステム。</font><font style="vertical-align: inherit;">設定、ディスク容量、ストレージポリシー、パフォーマンスなどを追跡するもう1つの場所</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">監視のためのシステム復元力の低下 </font><font style="vertical-align: inherit;">関連するコンポーネントのチェーンに新しいリンクが表示されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のユーザーにとって、履歴データ専用の専用ストレージの利点は、別のシステムを心配する必要がある不便さを上回ります。</font><font style="vertical-align: inherit;">しかし、多くの人にとって、これは不必要な複雑化です。</font><font style="vertical-align: inherit;">これらの特殊なソリューションのほとんどが独自のAPIを持っているため、Zabbixデータベースを操作するためのユニバーサルレイヤーの複雑さが著しく増大することも覚えておく価値があります。</font><font style="vertical-align: inherit;">そして、理想的には、他の人のAPIと戦うのではなく、新しい関数を作成することを好みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題が発生します-時系列にDBMSを利用する方法はありますが、SQLの柔軟性と利点を失うことはありませんか？</font><font style="vertical-align: inherit;">当然、普遍的な答えは存在しませんが、1つの特定のソリューションが答えに非常に近づきました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-TimescaleDB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TimescaleDBとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TimescaleDB（TSDB）は、通常のPostgreSQL（PG）データベースで時系列での作業を最適化するPostgreSQL拡張機能です。上記のように、市場には十分にスケーラブルな時系列ソリューションが不足しているわけではありませんが、TimescaleDBの独自の機能は、従来のCRUDリレーショナルデータベースの互換性と利点を犠牲にすることなく時系列でうまく機能することです。実際には、これは私たちが両方の世界のベストを手に入れることを意味します。データベースは、時系列と見なす必要があるテーブルを認識しています（必要なすべての最適化を適用します）が、通常のテーブルと同じ方法でそれらを操作できます。さらに、アプリケーションはデータがTSDBによって制御されていることを知る必要はありません！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テーブルを時系列テーブルとしてマークするには（TSDBではこれをハイパーテーブルと呼びます）、create_ hypertable（）TSDBプロシージャを呼び出すだけです。</font><font style="vertical-align: inherit;">内部的には、TSDBは指定された条件に従ってこのテーブルをいわゆるフラグメント（英語の用語はチャンク）に分割します。</font><font style="vertical-align: inherit;">フラグメントは、テーブルの自動的に制御されるセクションとして表すことができます。</font><font style="vertical-align: inherit;">各フラグメントには、対応する時間範囲があります。</font><font style="vertical-align: inherit;">TSDBはフラグメントごとに特別なインデックスも設定し、1つのデータ範囲での作業が他のデータ範囲へのアクセスに影響を与えないようにします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qu/d0/9s/qud09swu7nrhn2e6d6thqhfbgjw.png" alt="画像"><br>
<br>
<oembed><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">timescaledb.comのハイパーテーブルイメージ</font></font></oembed><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションが時系列の新しい値を追加すると、拡張機能はこの値を目的のフラグメントに送信します。新しい値の時間の範囲が定義されていない場合、TSDBは新しいフラグメントを作成し、それに目的の範囲を割り当て、そこに値を挿入します。アプリケーションがハイパーテーブルからデータを要求する場合、要求を実行する前に、拡張機能はこの要求に関連付けられているフラグメントをチェックします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それだけではありません。 TSDBは、多くのパフォーマンスとスケーラビリティの変更により、堅牢で実績のあるPostgreSQLエコシステムを補完します。これには、新しいレコードの迅速な追加、迅速なクエリ、実質的に無料のバッチ削除が含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述のように、データベースのサイズを制御し、保持ポリシーに準拠する（つまり、必要以上にデータを保存しない）ために、優れた監視ソリューションは大量の履歴データを効果的に削除する必要があります。</font><font style="vertical-align: inherit;">TSDBを使用すると、ハイパーテーブルから特定のフラグメントを削除するだけで、目的のストーリーを削除できます。</font><font style="vertical-align: inherit;">この場合、アプリケーションは名前やその他のリンクでフラグメントを追跡する必要はありません。TSDBは、指定された時間条件に従って必要なフラグメントをすべて削除します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TimescaleDBとPostgreSQLのパーティション分割 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見すると、TSDBはPGテーブルの標準的なパーティション分割（PG10 </font><font style="vertical-align: inherit;">で公式に呼ばれている</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣言型パーティション分割</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">美しいラッパーのように見えるかもしれません</font><font style="vertical-align: inherit;">。実際、履歴データを格納するために、標準のパーティション分割PG10を使用できます。しかし、よく見ると、TSDBフラグメントとPG10セクションはまったく同じ概念とはほど遠いものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、PGでパーティショニングを設定するには、詳細への洞察が必要です。これは、アプリケーション自体またはDBMSが適切に行う必要があります。まず、セクション階層を計画し、ネストされたパーティションを使用するかどうかを決定する必要があります。次に、セクションの命名スキームを考え出し、それを何らかの方法でスクリプトを作成して、スキームを作成する必要があります。最も可能性が高いのは、命名スキームに日付と時刻、あるいはその両方が含まれるため、そのような名前は何らかの方法で自動化する必要があるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、期限切れのデータを削除する方法について考える必要があります。 TSDBでは、drop_chunks（）コマンドを呼び出すだけで、特定の期間に削除するフラグメントを決定できます。 PG10では、標準のPGセクションから特定の範囲の値を削除する必要がある場合、この範囲のセクション名のリストを自分で計算する必要があります。選択したパーティション構成にネストされたセクションが含まれる場合、これにより削除がさらに複雑になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決しなければならないもう1つの問題は、現在の時間範囲を超えるデータをどうするかです。たとえば、データは、セクションがまだ作成されていない将来のものである場合があります。または、すでに削除されたセクションの過去から。 PG10のデフォルトでは、そのようなレコードを追加しても機能せず、データが失われるだけです。 PG11では、そのようなデータのデフォルトセクションを定義できますが、これは一時的に問題を覆い隠すだけで、解決しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、上記の問題はすべて、何らかの方法で解決できます。トリガーやcron-jabsでベースを吊り下げ、スクリプトで自由に振りかけることができます。醜いが機能的だろう。確かに、PGセクションは巨大なモノリシックテーブルよりも優れていますが、スクリプトとトリガーで解決できないのは、PGにはない時系列の改善です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。</font><font style="vertical-align: inherit;">PGセクションと比較して、TSDBハイパーテーブルは、DB管理者の神経を節約するだけでなく、データへのアクセスと新しいアクセスの両方を最適化することによっても区別されます。</font><font style="vertical-align: inherit;">たとえば、TSDBのフラグメントは常に1次元配列です。</font><font style="vertical-align: inherit;">これにより、フラグメント管理が簡素化され、挿入と選択が高速化されます。</font><font style="vertical-align: inherit;">新しいデータを追加するために、TSDBは独自のルーティングアルゴリズムを目的のフラグメントで使用します。これは、標準のPGとは異なり、すべてのセクションをすぐには開きません。</font><font style="vertical-align: inherit;">セクションの数が多いと、パフォーマンスの違いが大幅に異なる可能性があります。</font><font style="vertical-align: inherit;">PGとTSDBの標準的なパーティション分割の違いに関する技術的な詳細は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事に記載</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">され</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ています</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZabbixとTimescaleDB</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのオプションの中で、TimescaleDBはZabbixとそのユーザーにとって最も安全な選択肢のようです。</font></font><br>
<br>
<ul>
<li>TSDB    PostgreSQL,     .      ,    -    .         PostgreSQL.</li>
<li>TSDB           Zabbix  .</li>
<li>TSDB    history syncer  housekeeper.</li>
<li>   —   TSDB   .</li>
<li>         Zabbix —        .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しくインストールされたZabbixでTSDBを起動するために何が必要か見てみましょう。 Zabbixをインストールし、PostgreSQLデータベースを作成するためのスクリプトを実行した後、目的のプラットフォームにTSDBをダウンロードしてインストールする必要があります。インストール手順を参照してください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。拡張機能をインストールしたら、Zabbixベースで有効にし、Zabbixに付属のtimecaledb.sqlスクリプトを実行する必要があります。インストールがソースからの場合は、database / postgresql / timecaledb.sqlにあり、パッケージからのインストールの場合は/usr/share/zabbix/database/timecaledb.sql.gzにあります。それで全部です！これで、Zabbixサーバーを起動でき、TSDBで動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
timescaledb.sqlスクリプトは簡単です。彼が行うのは、通常のZabbix履歴テーブルをTSDBハイパーテーブルに変換し、デフォルトの設定を変更することです。[アイテムの履歴の上書き]および[アイテムのトレンド期間の上書き]パラメーターを設定します。現在（バージョン4.2）、次のZabbixテーブルがTSDB制御下で機能します-履歴、history_uint、history_str、history_log、history_text、trends、trends_uint。同じスクリプトを使用して、これらのテーブルを移行できます（migrate_dataパラメーターがtrueに設定されていることに注意してください）。データの移行は非常に長いプロセスであり、数時間かかる可能性があることを覚えておく必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
chunk_time_interval =&gt; 86400パラメータも、timecaledb.sqlを実行する前に変更が必要な場合があります。Chunk_time_intervalは、このフラグメントに入る値の時間を制限する間隔です。たとえば、chunk_time_interval間隔を3時間に設定すると、1日のデータは8つのフラグメントに分散され、最初のフラグメントNo. 1は最初の3時間（0：00-2：59）、2番目のフラグメントは2番目-2番目の3時間（ 3：00-5：59）など最後のフラグメント番号8には、21：00-23：59の時間を持つ値が含まれます。 86400秒（1日）が平均デフォルト値ですが、ロードされたシステムのユーザーはそれを減らしたい場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリ要件を概算するには、1つのピースが平均してどれだけのスペースを占有できるかを理解することが重要です。一般的な原則は、各ハイパーテーブルから少なくとも1つのフラグメントを配置するのに十分なメモリがシステムに必要であることです。もちろん、この場合、フラグメントサイズの合計は、マージンを持ってメモリに収まるだけでなく、postgresql.confのshared_buffersパラメータの値よりも小さくなければなりません。このトピックの詳細については、TimescaleDBのドキュメントを参照してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、主に整数メトリックを収集するシステムがあり、history_uintテーブルを2時間のフラグメントに分割し、残りのテーブルを1日のフラグメントに分割する場合、timecaledb.sqlでこの行を変更する必要があります。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> create_hypertable(<span class="hljs-string">'history_uint'</span>, <span class="hljs-string">'clock'</span>, chunk_time_interval =&gt; <span class="hljs-number">7200</span>, migrate_data =&gt; <span class="hljs-keyword">true</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一定量の履歴データが蓄積されたら、chunk_relation_size（）を呼び出して、history_uintテーブルのフラグメントサイズを確認できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">zabbix=&gt; SELECT chunk_table,total_bytes FROM chunk_relation_size('history_uint');<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chunk_table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| total_bytes<font></font>
-----------------------------------------+-------------<font></font>
_timescaledb_internal._hyper_2_6_chunk&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;13287424<font></font>
_timescaledb_internal._hyper_2_7_chunk&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;13172736<font></font>
_timescaledb_internal._hyper_2_8_chunk&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;13344768<font></font>
_timescaledb_internal._hyper_2_9_chunk&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;13434880<font></font>
_timescaledb_internal._hyper_2_10_chunk |&nbsp;&nbsp;&nbsp;&nbsp;13230080<font></font>
_timescaledb_internal._hyper_2_11_chunk |&nbsp;&nbsp;&nbsp;&nbsp;13189120</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この呼び出しを繰り返して、すべてのハイパーテーブルのフラグメントサイズを見つけることができます。</font><font style="vertical-align: inherit;">たとえば、フラグメントサイズhistory_uintが13MB、他の履歴テーブルのフラグメント、たとえば20MB、トレンドテーブルのフラグメントが10MBであることが判明した場合、合計メモリ要件は13 + 4 x 20 + 2 x 10 = 113MBです。</font><font style="vertical-align: inherit;">他のデータを保存するために、shared_buffersからスペースを残さなければなりません（たとえば20％）。</font><font style="vertical-align: inherit;">次に、shared_buffersの値を113MB / 0.8 =〜140MBに設定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TSDBの微調整のために、timescaledb-tuneユーティリティが最近登場しました。 postgresql.confを分析し、システム構成（メモリとプロセッサ）と関連付け、メモリパラメータ、並列処理のパラメータ、WALの設定に関する推奨事項を提供します。ユーティリティはpostgresql.confファイルを変更しますが、-dry-runパラメータを使用して実行し、提案された変更を確認できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zabbixオーバーライドアイテム履歴期間とオーバーライドアイテムトレンド期間パラメーター（管理-&gt;一般-&gt;ハウスキーピングで利用可能）について詳しく見ていきましょう。レコードではなく、TSDBハイパーテーブルのフラグメント全体として履歴データを削除するために必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、Zabbixでは、各データ要素（メトリック）のハウスキーピング期間を個別に設定できます。ただし、この柔軟性は、要素のリストをスキャンし、ハウスキーピングの各反復で個々の期間を計算することによって実現されます。システムに個々の要素の個別のハウスキーピング期間がある場合、システムは明らかにすべてのメトリックに対して単一のカットオフポイントを持つことができず、Zabbixは必要なフラグメントを削除するための正しいコマンドを与えることができません。したがって、メトリックの上書き履歴をオフにすると、Zabbixはhistory_ *テーブルのdrop_chunks（）プロシージャを呼び出して履歴をすばやく削除できなくなります。したがって、上書きトレンドをオフにすると、trends_ *テーブルの同じ機能が失われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、新しいハウスキーピングシステムを最大限に活用するには、両方のオプションをグローバルにする必要があります。</font><font style="vertical-align: inherit;">この場合、ハウスキーピングプロセスはデータ項目設定をまったく読み取りません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TimescaleDBによるパフォーマンス</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のすべてが実際に機能するかどうかを確認します。</font><font style="vertical-align: inherit;">テストベンチは、Zabbix 4.2rc1とPostgreSQL 10.7およびTimescaleDB 1.2.1 for Debian 9です。テストマシンは、16 GBのRAMとSSDに60 GBのストレージスペースを備えた10コアIntel Xeonです。</font><font style="vertical-align: inherit;">今日の標準では、これは非常に控えめな構成ですが、私たちの目標は、実際のTSDBの効果を調べることです。</font><font style="vertical-align: inherit;">予算が無制限の構成では、128〜256 GBのRAMを挿入して、データベースの大部分（すべてではないにしても）をメモリに配置できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト構成は、Zabbixサーバーに直接データを転送する32のアクティブなZabbixエージェントで構成されています。各エージェントは10,000アイテムを提供します。 Zabbix履歴キャッシュは256MBに設定され、shared_buffers PGは2GBに設定されています。この構成はデータベースに十分な負荷を提供しますが、同時にZabbixサーバープロセスに大きな負荷をかけません。データソースとデータベースの間の可動部分の数を減らすために、Zabbix Proxyを使用しませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準のPGシステムから取得した最初の結果は次</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hm/wj/rp/hmwjrp03sittv-f7ay9swag5z5y.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
のとおりです。TSDBの結果はまったく異なります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0-/75/r-/0-75r-lgjnjbwty1wnoniq7az4k.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下のグラフは両方の結果を組み合わせたものです。 170-200Kのかなり高いNVPS値から作業が始まります。データベースとの同期が開始する前に、履歴キャッシュがいっぱいになるまでしばらく時間がかかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qm/ro/p9/qmrop9da6tqvsdlbmaoe00jixxy.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
履歴テーブルが空の場合、TSDBの書き込み速度はPGの書き込み速度に匹敵し、PGのわずかなマージンがあっても同様です。履歴のレコード数が5000万〜6000万に達するとすぐに、PGのスループットは110K NVPSに低下しますが、さらに不愉快なことに、履歴テーブルに蓄積されたレコード数に反比例して変化し続けます。同時に、TSDBはテスト全体で0〜3億レコードの130K NVPSの安定した速度を維持します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体として、この例では、平均パフォーマンスの差が非常に大きくなっています（初期ピークを考慮しない場合、130K対90K）。また、標準的なPGの挿入率は、広範囲にわたって変化していることがわかります。したがって、ワークフローで数千または数億のレコードを履歴に保存する必要があるが、非常に積極的なキャッシュ戦略のためのリソースがない場合、TSDBは標準PGを置き換える強力な候補です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TSDBの利点は、この比較的控えめなシステムではすでに明らかですが、おそらく、履歴データの大規模な配列でその違いがさらに顕著になるでしょう。</font><font style="vertical-align: inherit;">一方、このテストは、Zabbixを使用する場合に考えられるすべてのシナリオを一般化したものではありません。</font><font style="vertical-align: inherit;">当然、ハードウェア構成、オペレーティングシステムの設定、Zabbixサーバーの設定、バックグラウンドで実行されている他のサービスからの追加の負荷など、結果に影響を与える多くの要因があります。</font><font style="vertical-align: inherit;">つまり、走行距離が異なる場合があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TimescaleDBは非常に有望なテクノロジーです。</font><font style="vertical-align: inherit;">すでに本格的な運用環境で運用されています。</font><font style="vertical-align: inherit;">TSDBはZabbixとうまく連携し、標準のPostgreSQLデータベースよりもはるかに優れています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TSDBには、使用を延期する欠陥または理由がありますか？技術的な観点からは、反対意見はありません。ただし、不安定なリリースサイクルと機能開発のための不明確な戦略により、このテクノロジーはまだ新しいことに注意してください。特に、重要な変更が加えられた新しいバージョンが1〜2か月ごとにリリースされます。一部の関数は、たとえばアダプティブチャンキングで発生したように削除される場合があります。それとは別に、不確実性のもう1つの要因として、ライセンスポリシーについて言及する価値があります。ライセンスには3つのレベルがあるため、非常に混乱します。 TSDBカーネルはApacheライセンスの下で作成され、一部の機能は独自のTimescaleライセンスの下でリリースされますが、Enterpriseのクローズドバージョンもあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLでZabbixを使用する場合、少なくともTimescaleDBを試さない理由はありません。</font><font style="vertical-align: inherit;">たぶん、これがあなたを喜ばしく驚かせるでしょう:) ZabbixでのTimescaleDBのサポートはまだ実験段階です-しばらくの間、ユーザーレビューを収集して経験を積んでいることを覚えておいてください。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja458508/index.html">Inside View：EPFLの大学院。パート4.2：財務面</a></li>
<li><a href="../ja458514/index.html">GDPRの違反はより積極的に罰せられます-新鮮な罰金とEU外の規制の影響</a></li>
<li><a href="../ja458516/index.html">Jiraから作業ログを取得</a></li>
<li><a href="../ja458520/index.html">書籍「.NETプラットフォームでの高性能コード。第二版</a></li>
<li><a href="../ja458524/index.html">膝の上のVC単語の雲</a></li>
<li><a href="../ja458532/index.html">新技術のパイオニア：Vadim Artsevは、彼が盲目でなくなった方法を語りました</a></li>
<li><a href="../ja458536/index.html">Python + Pyside2または単に「電卓」</a></li>
<li><a href="../ja458546/index.html">自動化の日、または自動テストレイヤーの構築方法</a></li>
<li><a href="../ja458548/index.html">動的プロキシとSpring IoCを使用して独自のSpring Data Repositoryスタイルライブラリを作成する</a></li>
<li><a href="../ja458550/index.html">DipTrace用のシンボルGOSTライブラリ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>