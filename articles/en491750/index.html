<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëéüèª üë©üèª‚Äçüé§ üë®‚Äçüë¶‚Äçüë¶ We write substring search better than in textbooks üîç üë®üèø üóìÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The life of an engineer is full of surprises: especially when you have to deal with productivity. For example, what happens if you try to run this pie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>We write substring search better than in textbooks</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491750/"><img src="https://habrastorage.org/webt/ri/ei/to/rieitoeutxefbbjts6ag-carfqk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The life of an engineer is full of surprises: especially when you have to deal with productivity. </font><font style="vertical-align: inherit;">For example, what happens if you try to run this piece of Java code? </font><font style="vertical-align: inherit;">It looks pretty innocent:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">//   String.repeat  JDK 11  :</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> needle = <span class="hljs-string">"A"</span>.repeat(<span class="hljs-number">500000</span>) + <span class="hljs-string">"B"</span>;
<span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> haystack = <span class="hljs-string">"A"</span>.repeat(<span class="hljs-number">1000000</span>) + <span class="hljs-string">"B"</span>;<font></font>
System.out.println(haystack.indexOf(needle));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We wait, wait, wait ... At least on my 2015 OpenJDK 13 laptop, finding a needle in a haystack takes about a minute. </font><font style="vertical-align: inherit;">Our good old JVM has gone through decades of performance tuning, it has effectively implemented intrinsics for </font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and so on. </font><font style="vertical-align: inherit;">What could have gone wrong?</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the beginning of a series of several articles courtesy of their author, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linas Med≈æi≈´nas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and originally published on the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WiX Engineering</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> blog </font><font style="vertical-align: inherit;">.</font></font><br>
</blockquote><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Take a closer look at what is input: the data is specially selected so as to achieve quadratic performance in the worst case ( </font></font><code>O(nm)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the length </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the length </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) for the naive substring search algorithm. We run through all the characters in </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and if they coincide with the first characters </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we start running along </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the inner loop - and so on until the first mismatched character. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You may argue that this example is useless, because such input data were designed and filed specially, in practice you will not encounter this. Think twice. What if you are working on a web service whose users can load arbitrary strings, and somewhere in the back of the service there is code that runs</font></font><code>indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on these lines? Then just a few malicious requests like the one above will put your service on its knees. It is worth knowing, at least, about the worst cases for the input data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, there are </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">substring search algorithms</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> having linear complexity ( </font></font><code>O(n+m)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). They have no problems with the data from the above example. For example, the following Scala code does the same thing, but runs in milliseconds on the same computer, the same JVM, and using exactly the same under the hood </font></font><code>java.lang.String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs">val needle = <span class="hljs-string">"A"</span> * <span class="hljs-number">500000</span> + <span class="hljs-string">"B"</span>
val haystack = <span class="hljs-string">"A"</span> * <span class="hljs-number">1000000</span> + <span class="hljs-string">"B"</span>
println(haystack.indexOfSlice(needle))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The secret to the huge difference is inside the method </font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is part of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Scala standard library</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It implements the clever linear </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knut-Morris-Pratt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algorithm </font><font style="vertical-align: inherit;">. And no, I am not saying that the language X is better than the language Y. Unfortunately, everything is much more complicated here! For example, </font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Scala, this is a generalized method that works not only with strings, but also in other sequential collections, and can compare not only characters, but also elements of other types. It should be much slower than</font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from Java in the middle case (we will talk about this later). Thus, we have an efficient algorithm with much better performance in the worst case, but on average it is slower because it has a much larger constant part. Dilemmas like this are a typical problem in tuning performance. There is no magic pill that will solve all problems - you need to carefully analyze the problem and make the right micro-benchmarks.</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Are you still with me Good! You see, this is just an introduction. I wanted to motivate you to deal with the theoretical complexity and practical performance of the algorithms. In the remainder of this article, we will look at some implementations of several substring search algorithms and their benchmarks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will explore three substring search algorithms. All of them work in linear time and require preprocessing, linearly dependent on length </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The calculation of the same </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is required only once, and then it can be reused in several search attempts. This is reasonable, because in many cases we need to search for the same line again and again. And even if we do not do this, precomputing is not a particularly expensive operation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All algorithms below bypass each of the characters in</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only once in a row (no random access by index), so they all work fine in streaming mode. </font><font style="vertical-align: inherit;">This article came about during a real work on a proxy server for production based on the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Netty</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> framework </font><font style="vertical-align: inherit;">, and this influenced some of the API design decisions. </font><font style="vertical-align: inherit;">In addition, since we needed to do a search on byte buffers, the code will work with </font></font><code>Byte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, not with </font></font><code>Char</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<hr><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knut-Morris-Pratt (KMP algorithm)</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a well-known substring search algorithm dating back to the 70s of the last century. </font><font style="vertical-align: inherit;">It is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">well described in the literature</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so I will not describe it here in detail. </font><font style="vertical-align: inherit;">The ILC is based on </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">state machines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - during the preliminary calculation phase, an array of link indices is constructed on the basis of </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">During the search, the machine accepts characters </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one by one </font><font style="vertical-align: inherit;">at the input </font><font style="vertical-align: inherit;">, and updates its internal state accordingly (and the state there is just an index in the relations table). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is an </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementation on Scala</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binary substring search algorithm</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initially, I had to independently invent the name of this algorithm: I have never seen anything like this anywhere in the literature. As a result, I came to the name ‚ÄúShifting Bit Mask‚Äù. Later it turned out that this algorithm and its variations have been known since 1964 under various </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">English names</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> like ‚ÄúBitap‚Äù, ‚ÄúShift-or‚Äù, ‚ÄúShift-and‚Äù, ‚ÄúBaeza-Yates ‚Äì Gonnet‚Äù. Thanks to the readers who have found it for me. This article was written long before this news. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This algorithm is based on a very simple idea and works very well, since there are almost no jumps, and it is based on several primitive binary operations. Because of this, it has a limit on the length </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we are going to look for: it cannot be longer than 64 bytes. This number was taken simply by the number of bits in</font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the JVM. </font><font style="vertical-align: inherit;">This limitation is generous enough for a large number of real tasks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since I originally developed this algorithm myself, I will try to talk about it in more detail. </font><font style="vertical-align: inherit;">First, we pre-compute the search context for the desired one </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">computeBitMasks</span></span>(needle: <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]): <span class="hljs-type">Array</span>[<span class="hljs-type">Long</span>] = {<font></font>
    require(needle.length &lt;= <span class="hljs-number">64</span>, <span class="hljs-string">"Maximum supported search pattern length is 64."</span>)
    <span class="hljs-keyword">val</span> bitMasks = <span class="hljs-type">Array</span>.ofDim[<span class="hljs-type">Long</span>](<span class="hljs-number">256</span>)
    <span class="hljs-keyword">var</span> bit = <span class="hljs-number">1</span>L
    <span class="hljs-keyword">for</span> (c &lt;- needle) {<font></font>
      bitMasks(toUnsignedInt(c)) |= bit<font></font>
      bit &lt;&lt;= <span class="hljs-number">1</span><font></font>
    }<font></font>
    bitMasks<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We pre-compute </font></font><code>bitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(64-bit </font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) for each possible byte value (256 pieces </font></font><code>bitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">For some byte value </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it </font></font><code>bitmask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains contains units in all places where it </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is in </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For example, here's a bit mask for the string "abracadabra": </font><font style="vertical-align: inherit;">
In addition, you need to pre-compute </font><font style="vertical-align: inherit;">, which will help to understand that we found an exact match. </font><font style="vertical-align: inherit;">It looks like a value </font><font style="vertical-align: inherit;">, with a bit </font><font style="vertical-align: inherit;">in position </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<a rel="noopener noreferrer" href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/099/0d9/f95/0990d9f9590612cce258139fb7c287bd.png"></a><br>
<br><font style="vertical-align: inherit;"></font><code>successBitMask</code><font style="vertical-align: inherit;"></font><code>Long</code><font style="vertical-align: inherit;"></font><code>1</code><font style="vertical-align: inherit;"></font><code>needle.length ‚Äî 1</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">computeSuccessBitMask</span></span>(needle: <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]): <span class="hljs-type">Long</span> = {
    <span class="hljs-number">1</span>L &lt;&lt; (needle.length - <span class="hljs-number">1</span>)<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And finally, you need to do, in fact, a search. The only mutable state we want to store is </font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). For each byte in </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we shift </font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">left by a </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit, set its least significant bit in </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and do a bitwise </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">between the result and </font></font><code>bitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, calculated for the current processed byte value from </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(this </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clears all bits in those places </font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that do not match the current processed byte). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, after processing each byte, only those bits that are in suitable positions will survive. And with each byte processed, all bits are shifted to the left by one position. If the bit "survives" during the number of iterations equal to the length</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- we found a match! And we can verify this with </font></font><code>successBitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span></span>(value: <span class="hljs-type">Byte</span>): <span class="hljs-type">Boolean</span> = {<font></font>
    currentMask = ((currentMask &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>) &amp; bitMasks(toUnsignedInt(value))<font></font>
    (currentMask &amp; successBitMask) == <span class="hljs-number">0</span>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note: the method described above returns </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if something is found, and it looks counterintuitive. </font><font style="vertical-align: inherit;">This can be understood so that the value </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">means the need to continue the search, but </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stops it - this is due to the fact that, as I wrote above, the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API was made</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compatible with Netty. </font><font style="vertical-align: inherit;">If you are wondering how to run a search, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is an example. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, all the logic boils down to just a few simple processor instructions. </font><font style="vertical-align: inherit;">Unfortunately, there remains a completely useless check of the bounds of the indexes of the array </font></font><code>bitMasks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which no JDK can remove (and I looked at the assembler generated by several different JDKs). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">full implementation on Scala</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aho korasik</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is another </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">popular algorithm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> known since 1975. Its distinguishing (and sometimes quite useful) feature is the ability to search several </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at </font><font style="vertical-align: inherit;">once </font><font style="vertical-align: inherit;">at the same time, while all the characters from </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are bypassed exactly once (I think it's just great!). The idea that all this works on is an extension of the KMP algorithm, a finite state machine using a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prefix tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (which is built on the basis of several </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), containing links to links (compare with a one-dimensional array from the KMP). Based on these links, the internal state of the automaton is switched between the nodes of the prefix tree after each processed symbol, and some of the nodes indicate a positive search result for a particular</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The precomputation phase here is rather complicated, but the search phase is unexpectedly very simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is a link to a working </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementation on Scala</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This was a completely incomplete list of substring search algorithms. </font><font style="vertical-align: inherit;">We also tried the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rabin-Karp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algorithm and the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boyer-Moore</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algorithm </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Of these two, Boyer-Moore showed comparable performance, but they are both not compatible with </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">streaming</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (using random access </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by index), and so I dropped them from this investigation.</font></font><br>
<br>
<hr><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmarks</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will benchmark the three algorithms described above, and in addition, look at the results for the methods </font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Java) and </font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Scala). To be honest, this is not a completely correct comparison, because it </font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">works with strings, and all other methods are on byte arrays. But this does not seem to invalidate the results of such a comparison. Moreover, I also included the results for </font></font><code>Bytes.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from Guava (v.28.1). This method works on byte arrays. And they wrote it on Google - everything they write there works super fast, right? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Writing benchmarks is always difficult, because you can send completely different data to the input, change it in many different ways - not only in length </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but also by the internal content of these lines (which can greatly affect some algorithms). In practice, it is always worth checking the input data that is most similar to the data from your real tasks (this is what we did in our project). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To shorten this article, I used only 2 types of input. One of them is intended to reflect the real case: </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">approximately 1.5 KB in size (with human-readable text inside) </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 9 bytes, and not in </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this sequence (this is necessary to force the algorithm to perform a full scan). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another type of input is needed to get the worst case behavior of a quadratic algorithm. It is much shorter than the data from the very beginning of this article: otherwise we would have to wait a whole minute, remember? Array</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is set in the format </font></font><code>"AA...AAB"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(the same length as the first data type), and </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 64-byte (especially for the binary substring search algorithm to cope with it) an array of the same type (the match is only at the very end </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A benchmark written in the JMH framework </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be found here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If you have other ideas about what and how to measure here - you can clone this repository, change something and post comments.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the suggestion of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vladimir Sitnikov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , I added benchmark results for </font></font><code>java.util.regex.Pattern</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; he uses the Boyer-Moore algorithm under the hood.</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Translator‚Äôs note: by the way, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vladimir Sitnikov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a member of several program committees at the JUG Ru Group and makes interesting reports himself. For example, a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video from</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> his report from JPoint 2019 entitled ‚ÄúJava slows down: CodeCache edition‚Äù </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">is available on the link</font></a><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmark results</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The results are given in milliseconds, less is better: </font><font style="vertical-align: inherit;">
Here everything is as expected:</font></font><br>
<br>
<code># JMH version: 1.21<br>
# VM version: JDK 13.0.1, OpenJDK 64-Bit Server VM, 13.0.1+9<br>
Benchmark (searchInput) Mode Cnt Score Error Units<br>
javaIndexOf REGULAR avgt 5 0.622 ¬± 0.002 us/op<br>
shiftingBitMask REGULAR avgt 5 1.982 ¬± 0.017 us/op<br>
regexPattern REGULAR avgt 5 2.184 ¬± 0.006 us/op<br>
kmp REGULAR avgt 5 2.635 ¬± 0.016 us/op<br>
scalaIndexOfSlice REGULAR avgt 5 3.202 ¬± 0.009 us/op<br>
guavaIndexOf REGULAR avgt 5 3.696 ¬± 0.095 us/op<br>
ahoCorasic REGULAR avgt 5 7.063 ¬± 0.040 us/op<br>
shiftingBitMask WORST_CASE avgt 5 1.986 ¬± 0.010 us/op<br>
kmp WORST_CASE avgt 5 5.120 ¬± 0.006 us/op<br>
ahoCorasic WORST_CASE avgt 5 6.892 ¬± 0.025 us/op<br>
scalaIndexOfSlice WORST_CASE avgt 5 8.765 ¬± 0.007 us/op<br>
regexPattern WORST_CASE avgt 5 11.566 ¬± 0.086 us/op<br>
javaIndexOf WORST_CASE avgt 5 23.029 ¬± 0.124 us/op<br>
guavaIndexOf WORST_CASE avgt 5 52.927 ¬± 0.275 us/op<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For ordinary data, it dominates </font></font><code>javaIndexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because it uses high-performance intrinsics inside, because of which the constant part is small;</font></font></li>
<li>     ,  :     ,     (<code>O(nm)</code>)   <code>javaIndexOf</code>,           ‚Äî      ,  <code>shiftingBitMask</code> (  )   .</li>
<li><code>guavaIndexOf</code>      ,    <code>javaIndexOf</code>;  ,        2  ,    <code>shiftingBitMask</code>;</li>
<li><code>scalaIndexOfSlice</code>  -  ,  <code>knuthMorrisPratt</code>,   ,      ‚Äî   ,  ;</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">performance is not the strongest feature </font></font><code>ahoCorasic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(or at least of its implementation; I must admit that I did not really try to make microoptimizations in it, because I added it only because of its distinguishing feature: the ability to search across several lines at once, and this similar to the topic for a separate article);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">input data (and length </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) did not affect performance </font></font><code>shiftingBitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>ahoCorasic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findings</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In different cases, benchmarks can work in different ways. </font><font style="vertical-align: inherit;">Despite the fact that the above results seem very indicative, you should always take measurements yourself and on data that reflects your real tasks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Based on the presented data, I made the following conclusions:</font></font><br>
<br>
<ul>
<li>    <code>String</code>-   ,           ,   <code>String.indexOf</code> ( <code>java.util.regex.Pattern</code> ‚Äî      );</li>
<li>,   <code>needle</code>   64 ,    ;</li>
<li> ,   --;</li>
<li>   Scala        - (     ),   <code>indexOfSlice</code>    ‚Äî    ;</li>
<li>    ,  -.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's all! </font><font style="vertical-align: inherit;">If you enjoy reading about algorithms, performance, and the like (and also about Scala, JVM, and Java in general), subscribe to the author of this article, Linas Medziunas ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The github repository with all the code in this article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<hr><br>
<img src="https://habrastorage.org/webt/_f/ku/xn/_fkuxncdimo0rsaeealkeqpe8f0.png" align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Translations of articles are published with the support of the JUG Ru Group and the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JPoint</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conference </font><font style="vertical-align: inherit;">.</font></font><br>
<br clear="all"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en491740/index.html">The Internet of Things in Yandex.Cloud: How Yandex IoT Core and Yandex Cloud Functions Services Are Arranged</a></li>
<li><a href="../en491742/index.html">Sherbet: ergonomic gaming keyboard</a></li>
<li><a href="../en491744/index.html">Iranian hackers exploited vulnerabilities in VPN</a></li>
<li><a href="../en491746/index.html">The history of speech synthesis: the era of electrical solutions</a></li>
<li><a href="../en491748/index.html">Technologies that help the blind learn English</a></li>
<li><a href="../en491760/index.html">Telegram. Taxi for 200 lines of code</a></li>
<li><a href="../en491778/index.html">Looking for footprints in the sand of fathers and children</a></li>
<li><a href="../en491780/index.html">GitLab 12.8 Released with Log Browser, NuGet and Compliance Dashboard</a></li>
<li><a href="../en491782/index.html">LANIT launches Testing School in Moscow, Penza, Sochi and Novorossiysk</a></li>
<li><a href="../en491786/index.html">Create a CRUD API on Express and MySQL: Part Two</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>