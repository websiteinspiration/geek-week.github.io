<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👒 ♥️ 👩🏿 C ++でリモートメモリの表現力豊かなスマートポインタを作成する 👩🏼‍🎓 🧑🏻‍🤝‍🧑🏻 👂🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！
 
 今日、C ++でのメモリとポインタの操作に関する興味深い研究の翻訳を公開しています。資料は少し学術的なものですが、ガロウィッツとウィリアムズの本の読者にとっては明らかに興味深いでしょう。
 
 広告に従ってください！
 
 大学院では、分散データ構造の構築に携わっています...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++でリモートメモリの表現力豊かなスマートポインタを作成する</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/467421/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日、C ++でのメモリとポインタの操作に関する興味深い研究の翻訳を公開しています。</font><font style="vertical-align: inherit;">資料は少し学術的なものですが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガロウィッツ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィリアムズの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本の読者にとっては明らかに興味深いでしょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
広告に従ってください！</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大学院では、分散データ構造の構築に携わっています。</font><font style="vertical-align: inherit;">したがって、リモートポインターを表す抽象化は、クリーンで整頓されたコードを作成するための私の作業において非常に重要です。</font><font style="vertical-align: inherit;">この記事では、スマートポインターが必要な理由を説明し、C ++でライブラリ用のリモートポインターオブジェクトを作成した方法を説明し、それらが通常のC ++ポインターとまったく同じように機能することを確認します。</font><font style="vertical-align: inherit;">これは、リモートリンクオブジェクトを使用して行われます。</font><font style="vertical-align: inherit;">さらに、私自身のポインター（これまでのところ）が通常のポインターが実行できるタスクに対応していないという単純な理由で、この抽象化が失敗するケースについて説明します。</font><font style="vertical-align: inherit;">この記事が、高度な抽象概念の開発に携わる読者の興味を引くことを願っています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低レベルAPI</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分散型コンピュータまたはネットワークハードウェアを使用する場合、C APIを介してメモリへの読み取りおよび書き込みアクセス権を持っていることがよくあります。この種の1つの例は、</font><font style="vertical-align: inherit;">一方向通信用</font><font style="vertical-align: inherit;">の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MPI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API </font><font style="vertical-align: inherit;">です。このAPIは、分散クラスターに配置された他のノードのメモリから直接読み取りおよび書き込みを行う関数を使用します。これは、少し単純化した方法で表示されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">remote_read</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* dst, <span class="hljs-keyword">int</span> target_node, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> size)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remote_write</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* src, <span class="hljs-keyword">int</span> target_node, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> size)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ターゲットノードの共有メモリセグメントへ</font><font style="vertical-align: inherit;">
の指定</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れた</font><i><font style="vertical-align: inherit;">オフセット</font></i><font style="vertical-align: inherit;">で、ノード</font></font><code>remote_read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font></font><code>remote_write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のバイト数を読み取り、特定のバイト数を書き込みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのAPIは、コンピューターのクラスターで実行されるプログラムを実装するために役立つ重要なプリミティブへのアクセスを提供するため、優れています。また、ハードウェアレベルで提供される機能であるリモートダイレクトメモリアクセス（RDMA）を非常に高速かつ正確に反映するため、非常に優れています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cray Aries</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Mellanox EDR</font></a><font style="vertical-align: inherit;">などの最新のスーパーコンピュータネットワーク</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、読み取り/書き込みの遅延が1〜2μsを超えないことを計算してみましょう。このインジケーターは、リモートCPUがウェイクアップしてネットワーク要求に応答するのを待たずに、ネットワークカード（NIC）がRAMに直接読み書きできるために実現できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、そのようなAPIは、アプリケーションプログラミングの観点からはあまり良くありません。</font><font style="vertical-align: inherit;">上記のような単純なAPIの場合でも、メモリに格納されている特定のオブジェクトごとに個別の名前はなく、1つの大きな連続したバッファーしかないため、誤ってデータを消去してもコストはかかりません。</font><font style="vertical-align: inherit;">さらに、インターフェースは型付けされていません。つまり、もう1つの具体的なヘルプがありません。コンパイラーが誓ったとき、間違った型の値を間違った場所に書き留めた場合。</font><font style="vertical-align: inherit;">あなたのコードは単に間違っていることが判明し、エラーは最も神秘的で破滅的な性質のものになります。</font><font style="vertical-align: inherit;">実際には</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのAPI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はもう少し</font><font style="vertical-align: inherit;">複雑なので、状況はさらに</font><font style="vertical-align: inherit;">複雑になり、それらを操作するときに2つ以上のパラメーターを誤って再配置する可能性があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">削除されたポインター</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポインタは、高レベルのプログラミングツールを作成するときに必要な抽象化の重要かつ必要なレベルです。ポインタを直接使用することは時々困難であり、多くのバグを引き起こす可能性がありますが、ポインタはコードの基本的なビルディングブロックです。データ構造やC ++リンクでさえ、内部でポインターを使用することがよくあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記と同様のAPIがあると想定した場合、メモリ内の一意の場所は2つの「座標」で示されます。（1）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランク</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはプロセスID、および（2）このランクのプロセスが占有するリモートメモリの共有部分に加えられたオフセット。そこで立ち止まって本格的な構造を作ることはできません。</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">remote_ptr</span> {</span>
      <span class="hljs-keyword">size_t</span> rank_;
      <span class="hljs-keyword">size_t</span> offset_;<font></font>
    };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、リモートポインタの読み取りと書き込み用のAPIを設計することはすでに可能であり、このAPIは、最初に使用したものよりも安全です。</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function">T <span class="hljs-title">rget</span><span class="hljs-params">(<span class="hljs-keyword">const</span> remote_ptr&lt;T&gt; src)</span> </span>{<font></font>
      T rv;<font></font>
      remote_read(&amp;rv, src.rank_, src.offset_, <span class="hljs-keyword">sizeof</span>(T));
      <span class="hljs-keyword">return</span> rv;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rput</span><span class="hljs-params">(remote_ptr&lt;T&gt; dst, <span class="hljs-keyword">const</span> T&amp; src)</span> </span>{<font></font>
      remote_write(&amp;src, dst.rank_, dst.offset_, <span class="hljs-keyword">sizeof</span>(T));<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロック転送はよく似ていますが、ここでは簡潔にするために省略しています。</font><font style="vertical-align: inherit;">これで、値を読み書きするために、次のコードを書くことができます。</font></font><br>
<br>
<pre><code class="cpp hljs"> remote_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr = ...;
   <span class="hljs-keyword">int</span> rval = rget(ptr);<font></font>
   rval++;<font></font>
   rput(ptr, rval);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは型付きオブジェクトを扱うため、元のAPIよりも優れています。</font><font style="vertical-align: inherit;">現在では、間違った型の値を書き込んだり読み取ったり、オブジェクトの一部のみを書き込んだりすることはそれほど簡単ではありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインター演算</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポインター算術は、プログラマーがメモリ内の値のコレクションを管理できるようにする最も重要な手法です。メモリ内に分散作業用のプログラムを作成すると、おそらく値の大きなコレクションを操作することになります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
削除されたポインタを1つ増加または減少させるとはどういう意味ですか？最も簡単なオプションは、削除されたポインターの計算を通常のポインターの計算と同様であると見なすことです。p+ 1 </font></font><code>sizeof(T)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、元のランクの共有セグメント内のpの次に位置合わせされたメモリ位置を</font><font style="vertical-align: inherit;">指し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはリモートポインタの算術の唯一の可能な定義ではありませんが、最近最も積極的に採用されており、この方法で使用されるリモートポインタは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPC ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などのライブラリに含まれています</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DASH</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびBCL。</font><font style="vertical-align: inherit;">ただし、</font><font style="vertical-align: inherit;">高性能コンピューティング（HPC）コミュニティに豊富なレガシーを残して</font><font style="vertical-align: inherit;">いる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統一並列C</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（UPC）</font><font style="vertical-align: inherit;">言語</font><font style="vertical-align: inherit;">には、ポインター演算のより精巧な定義が含まれています[1]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法でポインター演算を実装するのは簡単で、ポインターオフセットを変更するだけです。</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<font></font>
   remote_ptr&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword">operator</span>+(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">ptrdiff_t</span> diff)<font></font>
   {<font></font>
     <span class="hljs-keyword">size_t</span> new_offset = offset_ + <span class="hljs-keyword">sizeof</span>(T)*diff;
     <span class="hljs-keyword">return</span> remote_ptr&lt;T&gt;{rank_, new_offset};<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、分散メモリ内のデータ配列にアクセスする機会があります。</font><font style="vertical-align: inherit;">そのため、SPMDプログラムの各プロセスが、リモートポインターが向けられている配列内の変数に対して書き込みまたは読み取り操作を実行することを実現できます[2]。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_array</span><span class="hljs-params">(remote_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr, <span class="hljs-keyword">size_t</span> len)</span> </span>{
     <span class="hljs-keyword">if</span> (my_rank() &lt; len) {<font></font>
       rput(ptr + my_rank(), my_rank());<font></font>
     }<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、他の演算子の実装も簡単で、通常のポインター演算で実行される算術演算の完全なセットをサポートします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullptr値を選択</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のポインタの場合</font><font style="vertical-align: inherit;">、メモリ内のこのセクションが使用される可能性は低いため</font><font style="vertical-align: inherit;">、値</font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>NULL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常</font></font><code>#define</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0への</font><font style="vertical-align: inherit;">削減</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">意味するもの</font><font style="vertical-align: inherit;">と同じ</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">リモートポインターを使用するスキームでは、特定のポインター値をqualityとして選択して</font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、メモリ内のこの場所を未使用にするか、ポインターがnullかどうかを示す特別なブール項を含めることができます。</font><font style="vertical-align: inherit;">メモリ内の特定の場所を未使用にするのは良い方法ではありませんが、ブール値を1つだけ追加すると、リモートポインターのサイズがほとんどのコンパイラーの観点から2倍になり、アライメントを維持するために128ビットから256ビットに増えることも考慮します。</font><font style="vertical-align: inherit;">これは特に望ましくありません。</font><font style="vertical-align: inherit;">私のライブラリでは、私は選びました</font></font><code>{0, 0}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、つまり、値としてのランク0のオフセット0 </font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、それ以上</font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悪化しない</font><font style="vertical-align: inherit;">他のオプションを選択することが可能になるでしょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">さらに、UPCなどの一部のプログラミング環境では、それぞれ64ビットに収まるナローポインターが実装されています。</font><font style="vertical-align: inherit;">したがって、それらは交換を伴うアトミック比較操作で使用できます。</font><font style="vertical-align: inherit;">ナローポインターを使用する場合は、妥協する必要があります。オフセット識別子またはランク識別子のいずれかが32ビット以下に収まる必要があり、これによりスケーラビリティが制限されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">削除されたリンク</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonのような言語では、ブラケット文はメソッドを呼び出すためのシンタックスシュガーとして機能</font></font><code>__setitem__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して</font></font><code>__getitem__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、あなたはそれにオブジェクトまたは書き込みを読んでいるかどうかに依存します。 C ++では、</font><font style="vertical-align: inherit;">オブジェクトが</font></font><code>operator[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値カテゴリに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属するか、および戻り値がすぐに読み取りまたは書き込みのどちらに該当するかは</font><font style="vertical-align: inherit;">区別されません</font><font style="vertical-align: inherit;">。この問題を解決するために、C ++データ構造は、コンテナーに含まれるメモリーを指すリンクを返します。これは、書き込みまたは読み取りが可能です。の実装</font></font><code>operator[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のようになります。</font></font><br>
 <br>
 <pre><code class="cpp hljs"> T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">size_t</span> idx) {
     <span class="hljs-keyword">return</span> data_[idx];<font></font>
   }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで最も重要な事実は、タイプのエンティティを返すことです</font></font><code>T&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、C ++の生の参照</font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり、ソースデータの値を表す</font><font style="vertical-align: inherit;">タイプのエンティティではありません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、別のノードにあり、仮想アドレス空間に表されていないメモリを参照しているため、生のC ++リンクを返すことはできません。確かに、独自のカスタム参照オブジェクトを作成できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リンクは、ポインターのラッパーとして機能するオブジェクトであり、2つの重要な機能を実行します。それは、型の値に変換できることと、型の値</font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に割り当てることもできます。</font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、リモート参照の場合は、値を読み取る暗黙の変換演算子を実装し、値に書き込む代入演算子を作成するだけです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">remote_ref</span> {</span><font></font>
    remote_ptr&lt;T&gt; ptr_;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">T</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
      <span class="hljs-keyword">return</span> rget(ptr_);<font></font>
    }<font></font>
<font></font>
    remote_ref&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> T&amp; value) {<font></font>
      rput(ptr_, value);<font></font>
      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
    }<font></font>
  };<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、リモートポインターに新しい強力な機能を追加できます。この機能を使用すると、通常のポインターとまったく同じように逆参照することができます。 </font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<font></font>
  remote_ref&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword">operator</span>*() {
    <span class="hljs-keyword">return</span> remote_ref&lt;T&gt;{*<span class="hljs-keyword">this</span>};<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<font></font>
  remote_ref&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">ptrdiff_t</span> idx) {
    <span class="hljs-keyword">return</span> remote_ref&lt;T&gt;{*<span class="hljs-keyword">this</span> + idx};<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、削除されたポインタを通常どおりに使用する方法を示す全体像が復元されました。</font><font style="vertical-align: inherit;">上記の簡単なプログラムを書き直すことができます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_array</span><span class="hljs-params">(remote_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr, <span class="hljs-keyword">size_t</span> len)</span> </span>{
     <span class="hljs-keyword">if</span> (my_rank() &lt; len) {<font></font>
       ptr[my_rank()] = my_rank();<font></font>
     }<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、新しいポインターAPIを使用すると、たとえば、ツリーに基づいて並列縮小を実行する関数など、より複雑なプログラムを作成できます[3]。</font><font style="vertical-align: inherit;">リモートポインタークラスを使用した実装は、上記のC APIを使用して通常取得される実装よりも安全でクリーンです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行時に発生するコスト（またはその欠如！）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、そのような高レベルの抽象化を使用するのにどのくらいの費用がかかりますか？</font><font style="vertical-align: inherit;">メモリにアクセスするたびに、間接参照メソッドを呼び出し、ポインターをラップする中間オブジェクトを返します。次に、中間オブジェクトに影響を与える変換演算子または代入演算子を呼び出します。</font><font style="vertical-align: inherit;">実行時に何がかかりますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポインタと参照クラスを慎重に指定すると、実行時にこの抽象化によるオーバーヘッドが発生しないことがわかります。最新のC ++コンパイラは、これらの中間オブジェクトとメソッド呼び出しを積極的な埋め込みによって処理します。このような抽象化によってどのようなコストがかかるかを評価するには、簡単なサンプルプログラムをコンパイルして、アセンブリがどのように実行され、実行時にどのオブジェクトとメソッドが存在するかを確認します。リモートポインターと参照のクラスでコンパイルされたツリーベースの削減を使用してここで説明する例では、最新のコンパイラーはツリーベースの削減をいくつかの呼び出し</font></font><code>remote_read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>remote_write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4]に</font><font style="vertical-align: inherit;">削減します</font><font style="vertical-align: inherit;">。クラスメソッドは呼び出されず、実行時に参照オブジェクトは存在しません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ構造ライブラリとの相互作用</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
経験豊富なC ++プログラマーは、標準のC ++テンプレートライブラリに次のように記載されていることを覚えてい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">アロケータを使用すると、メモリを割り当てることができ、このメモリは、私たちが作成したポインタのタイプを使用して参照できます。</font><font style="vertical-align: inherit;">これは、単に「リモートアロケータ」を作成し、それを接続してSTLコンテナを使用してリモートメモリにデータを格納できることを意味しますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念だけど違う。おそらく、パフォーマンス上の理由から、C ++標準ではカスタム参照型のサポートが不要になり、C ++標準ライブラリのほとんどの実装では実際にはサポートされていません。したがって、たとえば、GCCのlibstdc ++を使用する場合、カスタムポインターに頼ることができますが、同時に使用できるのは通常のC ++リンクのみであり、リモートメモリでSTLコンテナーを使用することはできません。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">エージェンシー</font></a><font style="vertical-align: inherit;">などの一部の高レベルC ++テンプレートライブラリ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カスタムポインター型と参照型を使用すると、リモート参照型を実際に操作できるSTLの一部のデータ構造の独自の実装が含まれます。</font><font style="vertical-align: inherit;">この場合、プログラマーは、アロケーター、ポインター、およびリンクのタイプを作成するための創造的なアプローチの自由度が増し、さらに、それらで自動的に使用できるデータ構造のコレクションを取得します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幅広いコンテキスト</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、まだ解決されていない幅広い問題に対処しました。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ割り当て</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">リモートメモリ内のオブジェクトを参照できるようになったので、そのようなリモートメモリをどのように予約または割り当てますか？</font></font></li>
<li><b> </b>.         ,      int?      ?         ,     ? </li>
<li><b>   </b>. ,   ,          ?       ?</li>
</ul><br>
<h3></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[1] UPCでは、ポインターには、1ずつ増加した後のポインターの方向を決定するフェーズがあります。フェーズが原因で、分散配列はポインターにカプセル化でき、それらの分散パターンは大きく異なる場合があります。これらの機能は非常に強力ですが、初心者には不思議に思えるかもしれません。一部のUPCエースはこのアプローチを優先しますが、より合理的なオブジェクト指向のアプローチは、最初に単純なリモートポインタークラスを記述してから、このために特別に設計されたデータ構造に基づいてデータ分散を提供することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[2] HPCのほとんどのアプリケーションは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPMD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のスタイルで記述されてい</font><font style="vertical-align: inherit;">ます。この名前は「1つのプログラム、異なるデータ」を意味します。 SPMD APIは関数または変数を提案します</font></font><code>my_rank()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、プログラムを実行するプロセスに一意のランクまたはIDを通知します。これに基づいて、メインプログラムからの分岐が可能になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[3]これは、リモートポインタークラスを使用してSPMDスタイルで記述された単純なツリー縮小です。</font><font style="vertical-align: inherit;">コードは、私の同僚の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andrew Belt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって最初に書かれたプログラムに基づいて調整されてい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
   <span class="hljs-function">T <span class="hljs-title">parallel_sum</span><span class="hljs-params">(remote_ptr&lt;T&gt; a, <span class="hljs-keyword">size_t</span> len)</span> </span>{
     <span class="hljs-keyword">size_t</span> k = len;<font></font>
<font></font>
     <span class="hljs-keyword">do</span> {<font></font>
       k = (k + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<font></font>
<font></font>
       <span class="hljs-keyword">if</span> (my_rank() &lt; k &amp;&amp; my_rank() + k &lt; len) {<font></font>
         a[my_rank()] += a[my_rank() + k];<font></font>
       }<font></font>
<font></font>
       len = k;<font></font>
       barrier();<font></font>
    } <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">1</span>);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>];<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[4]上記のコードのコンパイルされた結果は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja467401/index.html">テスラモデルSとポルシェタイカンの比較</a></li>
<li><a href="../ja467403/index.html">Webコンポーネントから絞り出すことができるものとできないもの</a></li>
<li><a href="../ja467407/index.html">コボットDobot M1と連携します</a></li>
<li><a href="../ja467409/index.html">シリコンバレーでビジネスを行うには、自分で行動する必要があります</a></li>
<li><a href="../ja467419/index.html">Jakarta EE 8最終リリースがリリースされました</a></li>
<li><a href="../ja467423/index.html">Xamarin.Forms-アプリケーションでのアイコンフォントの便利な使用法</a></li>
<li><a href="../ja467425/index.html">STEM集中学習アプローチ</a></li>
<li><a href="../ja467427/index.html">BudgetTracker-個人の財務会計用のもう1つのオープンソースツール</a></li>
<li><a href="../ja467429/index.html">Habrastatistics：サイトの最も訪問されたセクションと最も訪問されていないセクションの探索</a></li>
<li><a href="../ja467435/index.html">VeeamエージェントLinuxのレポートをメールまたはTelegramで送信します</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>