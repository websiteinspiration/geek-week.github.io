<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍀 😬 🏂🏻 Cómo Gatsby eludió Next.js ⛑️ 👵🏼 ⛳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El autor del artículo, cuya traducción publicamos hoy, trabaja como programador en Antler. Esta compañía es un generador global de startups. Hay días ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Cómo Gatsby eludió Next.js</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/500228/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El autor del artículo, cuya traducción publicamos hoy, trabaja como programador en Antler. </font><font style="vertical-align: inherit;">Esta compañía es un generador global de startups. </font><font style="vertical-align: inherit;">Hay días de demostración en Antler varias veces al año, que reúne a muchos creadores e inversores de todo el mundo. </font><font style="vertical-align: inherit;">La situación en torno a COVID-19 obligó a Antler a traducir sus eventos a un formato en línea.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/hq/r9/an/hqr9anmkfyicv4znlhi2ynk16rm.jpeg"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La compañía quería asegurarse de que los visitantes de sus eventos virtuales, sin distraerse con nada y sin quedarse atascados en ningún lado, vieran lo más importante. </font><font style="vertical-align: inherit;">A saber, las ideas de startups presentadas al público, expresadas como los contenidos de las páginas web. </font><font style="vertical-align: inherit;">Los días de demostración virtual pueden ser de interés para un público bastante amplio. </font><font style="vertical-align: inherit;">Algunos miembros de esta audiencia pueden estar participando por primera vez en algo como esto. </font><font style="vertical-align: inherit;">Por lo tanto, la empresa tuvo que hacer todo de la mejor manera posible y proporcionar una carga de alta velocidad de páginas que representan nuevas empresas. </font><font style="vertical-align: inherit;">Decidieron que este es el caso cuando una aplicación web progresiva de alto rendimiento (PWA, Progressive Web App) puede ser útil. </font><font style="vertical-align: inherit;">El problema principal era encontrar la tecnología adecuada para desarrollar PWA.</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f54/6f9/1fa/f546f91fa52e40c139cc78fe26b1ad06.gif"></div><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Representación del servidor o generador de sitio estático?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comenzar, te presentaré un poco al curso. Todos nuestros proyectos se basan en React y la biblioteca Material-UI. Como resultado, inicialmente decidimos no apartarnos de esta pila de tecnología, lo que nos permitiría garantizar una alta velocidad de desarrollo y hacer que el nuevo proyecto sea compatible con lo que ya tenemos. La diferencia clave entre este nuevo proyecto y nuestras otras aplicaciones React fue que la base de datos para ellos se creó utilizando la aplicación create-react-y que se representaron completamente en el cliente (CSR, Representación del lado del cliente). Esto, en particular, condujo al hecho de que cuando la aplicación se cargó inicialmente, los usuarios se vieron obligados a observar una pantalla en blanco mientras el código JavaScript del proyecto se cargaba, procesaba y ejecutaba.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Necesitábamos un nivel de rendimiento intransigente. Por lo tanto, comenzamos a pensar en usar la representación del lado del servidor (SSR, Representación del lado del servidor) o un generador de sitio estático (SSG, Generador de sitio estático) para que la carga inicial de aplicaciones sea lo más rápida posible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestros datos se almacenan en Cloud Firestore, y accedemos a ellos utilizando Algolia. Esto nos permite controlar, a nivel de campo de la base de datos, el acceso público a los datos con claves API restringidas. Esto también mejora el rendimiento de la consulta. Por experiencia, sabemos que las consultas de Algolia son más rápidas de lo normal y que el SDK de JavaScript de Firestore comprimido tiene un tamaño de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">86 KB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En el caso de Algolia, esto es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.5 Kb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, queríamos que los datos que proporcionamos a los clientes sean lo más actualizados posible. Esto nos ayudaría a corregir rápidamente datos erróneos que podrían publicarse accidentalmente. Si bien la práctica estándar de SSG prevé la implementación de solicitudes de datos relevantes durante el ensamblaje del proyecto, esperábamos que en nuestra base de datos los datos se escriban con bastante frecuencia. En particular, estamos hablando de la grabación de datos iniciada por administradores que usan la interfaz de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">firetable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y por iniciativa de los fundadores de los proyectos utilizando el portal web. Esto lleva a un montaje competitivo del proyecto. Además, debido a las características estructurales de nuestra base de datos, cambios menores pueden conducir a nuevas operaciones de ensamblaje de proyectos. Esto hace que nuestra línea de CI / CD sea extremadamente ineficiente. Por lo tanto, necesitábamos que las solicitudes para recibir datos del repositorio se ejecutaran cada vez que un usuario solicita que se cargue una página. Desafortunadamente, esto significaba que nuestra solución no sería un ejemplo de un proyecto SSG "limpio".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, nuestra aplicación fue creada sobre la base de Gatsby, ya que ya usábamos páginas de aterrizaje creadas en Gatsby, y en una de ellas ya se usaba la biblioteca Material-UI. </font><font style="vertical-align: inherit;">La primera versión del proyecto formó una página que, mientras se cargaban los datos, mostraba un "esqueleto". </font><font style="vertical-align: inherit;">Al mismo tiempo, la primera pintura contenta (FCP) fue en la región de 1 segundo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d75/578/718/d7557871834d0d244f8501327d68810d.gif"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargar el "esqueleto" de la página con la posterior carga de datos</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
La solución resultó ser interesante, pero tenía sus inconvenientes, porque los datos para la salida de la página se descargaron por iniciativa del cliente:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ver el contenido de la página, los usuarios tendrían que esperar la descarga de esta página y los datos que se muestran en ella, obtenidos a través de 4 solicitudes a Algolia.</font></font></li>
<li>    JS-    .   ,  React   «»      .         DOM.</li>
<li>         .  ,  ,    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, durante el largo fin de semana, decidí experimentar con la versión SSR del proyecto creado con Next.js. Afortunadamente para mí, la documentación de Material-UI tenía un proyecto de ejemplo para Next.js. Por lo tanto, no necesitaba aprender todo este marco desde cero. Solo tenía que mirar algunas partes del tutorial y la documentación. Convertí la aplicación a un proyecto que se renderizó en el servidor. Cuando un usuario solicitó una carga de página, el servidor ejecutó las solicitudes de datos necesarios para llenar la página. Este paso nos permitió resolver los tres problemas anteriores. Aquí están los resultados de la prueba para dos opciones de aplicación.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b60/0da/cda/b600dacda702f25e97808ed9f762ff8c.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultados de la búsqueda de aplicaciones con </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google PageSpeed ​​Insights</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A la izquierda está Gatsby (SSG), a la derecha está Next.js (SSR) ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imagen original</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
El FCP para la versión Next.js del proyecto fue aproximadamente 3 veces mayor que para su versión basada en Gatsby. La versión Gatsby del proyecto tenía un índice de velocidad de 3.3 segundos, mientras que la versión Next.js tenía 6.2 segundos. El tiempo hasta el primer byte (TTFB, Tiempo hasta el primer byte) fue de 2.56 segundos cuando se usa Next.js y de 10-20 ms cuando se usa Gatsby.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cabe señalar que la versión Next.js del sitio se implementó en otro servicio (aquí utilizamos los servicios ZEIT Now y Firebase Hosting; esto también podría afectar el aumento de TTFB). Pero, a pesar de esto, estaba claro que la transferencia de operaciones de carga de datos al servidor hacía que el sitio pareciera más lento, a pesar del hecho de que todos los materiales de la página se cargaron aproximadamente al mismo tiempo. El hecho es que en la versión Next.js del proyecto, el usuario por un tiempo solo ve una página en blanco.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e0/8a2/ab3/6e08a2ab3bcb4c06471cc92545848d8a.gif"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Captura de pantalla que muestra la carga de dos versiones de una aplicación. </font><font style="vertical-align: inherit;">La descarga no se completó al mismo tiempo. </font><font style="vertical-align: inherit;">Los registros se sincronizan en el momento en que presiona la tecla Intro.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Todo esto nos brinda una importante lección del campo del desarrollo web: debe brindar a los usuarios comentarios visuales. </font><font style="vertical-align: inherit;">Un</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estudio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> encontró que las aplicaciones que usan pantallas esqueléticas parecen cargarse más rápido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este resultado, además, no se corresponde con el estado de ánimo que podría haber captado si leyó artículos sobre desarrollo web en los últimos años. </font><font style="vertical-align: inherit;">Es decir, estamos hablando del hecho de que no hay nada de malo en usar los recursos del cliente, y que el SSR no es una solución integral para los problemas de rendimiento.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendimiento de generación de sitio estático: comparación de Gatsby y Next.js</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si bien los dos marcos en consideración, Gatsby y Next.js, son conocidos, respectivamente, por su capacidad de generar sitios estáticos y representación de servidores, el </font><font style="vertical-align: inherit;">soporte para SSG se mejoró </font><font style="vertical-align: inherit;">en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next.js 9.3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lo que lo convierte en un competidor de Gatsby. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el momento de escribir este artículo, la capacidad de Next.js para generar sitios estáticos todavía era muy reciente. Ella tenía poco más de un mes. Ella todavía se informa en la primera página del proyecto. Ahora no hay muchas comparaciones de las capacidades de SSG de Gatsby y Next.js (o tal vez aún no haya tales comparaciones). Como resultado, decidí realizar mi propio experimento.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regresé la versión Gatsby del proyecto al estado en que se descargaron los datos en el cliente, y lo hice para que ambas versiones de la aplicación tengan exactamente el mismo conjunto de características. Es decir, tuve que eliminar de qué son responsables los complementos de Gatsby: funciones de SEO, generación de favicons, manifiesto de PWA. Para comparar exclusivamente paquetes de JavaScript creados por frameworks, no incluí imágenes y otro contenido descargado de fuentes externas en los proyectos. Ambas versiones de la aplicación se implementaron en la plataforma Firebase Hosting. Como referencia, se crearon dos versiones de la aplicación basadas en Gatsby 2.20.9 y Next.js 9.3.4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ejecuté Lighthouse en mi computadora 6 veces para cada versión. Los resultados mostraron una ligera ventaja para Gatsby.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82a/522/059/82a522059afba13a70e62df76144b6e6.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valores promedio obtenidos después de 6 lanzamientos de Lighthouse para cada marco ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imagen original</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En términos de evaluación general del rendimiento, la versión Next.js estaba solo ligeramente por detrás de la versión Gatsby. Lo mismo ocurre con FCP y Speed ​​Index. El Retardo de primer ingreso del primer potencial para la versión Next.js de la aplicación es ligeramente mayor que para la versión Gatsby.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comprender mejor lo que está sucediendo, recurrí a la pestaña Red de las herramientas para desarrolladores de Chrome. Al final resultó que, en la versión Next.js del proyecto, el número de fragmentos en los que se divide el código JavaScript es 3 más que en la versión Gatsby (excluyendo los archivos de manifiesto), pero el código comprimido es 20 KB más pequeño. ¿Pueden las solicitudes adicionales necesarias para descargar estos archivos superar los beneficios de un paquete más pequeño que perjudica el rendimiento?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/d84/d9a/27bd84d9aad10ae1f3421a0f829c3fa2.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la versión Gatsby del proyecto, se ejecutan 7 solicitudes para descargar 379 KB de datos. En la versión del proyecto Next.js: 12 solicitudes de descarga de 359 KB de datos ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imagen original</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Si analiza el rendimiento de JavaScript, las herramientas del desarrollador dicen que la versión del proyecto Next.js necesita 300 ms adicionales para la primera representación, y que esta versión pasa más tiempo en la tarea Evaluar secuencia de comandos. En las herramientas del desarrollador, esta tarea incluso se marcó como una "tarea larga".</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24b/1be/11c/24b1be11c62fc6a1561a413555e53c0f.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Análisis del rendimiento de diferentes opciones de proyecto utilizando la pestaña Rendimiento de las herramientas de desarrollador de Chrome ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imagen original</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
. Comparé el código del proyecto para averiguar si existen diferencias en su implementación que pudieran afectar el rendimiento. Con la excepción de eliminar el código innecesario y las correcciones asociadas con los tipos faltantes de TypeScript, la única diferencia fue la implementación de un desplazamiento suave de la página cuando se mueve a sus partes individuales. Esta característica fue introducida previamente por un archivo</font></font><code>gatsby-browser.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y se movió a un</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> componente importado dinámicamente</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Como resultado, este código solo se ejecutaría en un navegador. (Utilizamos el paquete npm de</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> desplazamiento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> suave</font><font style="vertical-align: inherit;">y, al importarlo, necesita un objeto</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.) Este problema puede ser el culpable, pero no sé cómo se maneja en Next.js.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gatsby es más conveniente desde el punto de vista del desarrollador</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final, decidí optar por la versión Gatsby del proyecto. Además, aquí no tomé en cuenta la ventaja de rendimiento muy pequeña que mostró Gatsby en comparación con el mecanismo Next.js SSG (¿no me aferraré seriamente a la ventaja de 0.6 segundos?). El hecho es que en la versión Gatsby del proyecto muchas funciones PWA ya están implementadas, y no vi el punto de tenerlas implementadas nuevamente en la versión Next.js de la aplicación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando estaba creando la primera versión de Gatsby del proyecto, pude agregar rápidamente algunas características útiles de PWA al proyecto. Por ejemplo, para agregar a cada página mis propias metaetiquetas necesarias para SEO, solo tenía que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leer el manual</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para equipar el proyecto con un manifiesto PWA, solo necesitaba usar el </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">complemento</font></a><font style="vertical-align: inherit;"> apropiado</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para equipar el proyecto con favicons que admitieran todas las plataformas disponibles (y en este caso todavía hay un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desastre terrible</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), ni siquiera tuve que hacer nada, ya que el soporte de favicon es parte del complemento responsable del manifiesto. ¡Es muy cómodo!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementar las mismas características en la versión Next.js de la aplicación requeriría más trabajo. Tendría que buscar manuales de capacitación, todo tipo de "mejores prácticas". Y el hecho de que tendría éxito, de todos modos, no me daría ninguna ventaja. Después de todo, sin embargo, la versión Next.js del proyecto no difiere en un rendimiento más alto que su versión Gatsby. Esta, además, fue la razón por la que decidí simplemente deshabilitar las características correspondientes de la versión Gatsby del proyecto, comparándola con la versión Next.js. La documentación de Next.js es más concisa que la documentación de Gatsby (quizás el hecho es que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next.js es</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> más pequeña que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gatsby</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Realmente me gusta el tutorial gamified Next.js. </font><font style="vertical-align: inherit;">Pero la documentación más extensa de Gatsby es más valiosa con el desarrollo real de PWA, aunque a primera vista parece enorme.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/010/138/800/0101388008c84ce2dda5f6f8f522cf6d.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentación de Gatsby</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Es cierto, no puedo guardar silencio sobre las fortalezas de Next.js:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias al tutorial y la brevedad de la documentación de Next.js, parece que este marco se puede aprender más rápido que Gatsby.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El sistema de carga de datos utilizado en Next.js se basa en funciones asincrónicas y la API Fetch. </font><font style="vertical-align: inherit;">Como resultado, al desarrollar Next.js, el desarrollador no tiene la sensación de que necesita aprender GraphQL para aprovechar al máximo las capacidades del marco.</font></font></li>
<li> Next.js    TypeScript,      Gatsby        ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   </a> (    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>).     Next.js      ,     ,        ,        .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gracias al hecho de que Next.js ha mejorado la compatibilidad con SSG, este marco se ha convertido en una herramienta poderosa que permite, a nivel de cada página individual, elegir el método para trabajar con ella. </font><font style="vertical-align: inherit;">Puede ser SSR, SSG o CSR. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, si pudiera generar esta aplicación en una forma completamente estática, Next.js me convendría mejor, ya que podría usar el Algolia JS-API estándar y podría mantener el código para cargar datos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el mismo archivo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que y código de componente. </font><font style="vertical-align: inherit;">Dado que Algolia no tiene una API GraphQL incorporada y no hay un complemento de Gatsby para Algolia, implementar dicho mecanismo en Gatsby requeriría agregar este código </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a un nuevo archivo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Y esto va en contra de la forma declarativa intuitiva de describir páginas.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre formas adicionales de mejorar el rendimiento del proyecto</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de haber resuelto el problema de elegir un marco, se puede observar que hay formas adicionales de mejorar el rendimiento del proyecto que no están relacionadas con el marco. </font><font style="vertical-align: inherit;">Estas mejoras pueden llevar la calificación del proyecto Lighthouse a 100.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lista de correo de marzo de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algolia </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">,</font></a><font style="vertical-align: inherit;"> se recomienda agregar una pista </font></font><code>preconnect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para aumentar aún más la velocidad de ejecución de consultas. </font><font style="vertical-align: inherit;">(Es cierto que, desafortunadamente, el fragmento de código incorrecto aparece en el boletín. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí está el</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> código correcto).</font></font></li>
<li>    .   JS-  CSS-,  webpack- Gatsby.   Gatsby  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>   .  ,       ,   Netlify  Amazon S3. ,  Firebase Hosting,  ,    .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizamos imágenes JPEG y PNG cargadas por creadores de inicio en la aplicación. </font><font style="vertical-align: inherit;">No los comprimimos ni los optimizamos. </font><font style="vertical-align: inherit;">Mejorar este aspecto de nuestra aplicación es todo un desafío y está más allá del alcance de este proyecto. </font><font style="vertical-align: inherit;">Además, sería genial si todas estas imágenes se convirtieran al formato WebP. </font><font style="vertical-align: inherit;">Como resultado, tendríamos que almacenar imágenes usando solo un formato gráfico altamente eficiente. </font><font style="vertical-align: inherit;">Desafortunadamente, como con muchas otras características de PWA, el equipo de desarrollo de Safari WebKit es adictivo con el soporte de WebP. </font><font style="vertical-align: inherit;">Ahora es el único navegador importante que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no admite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> este formato.</font></font></li>
</ul><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumen</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si resumimos brevemente de qué estábamos hablando aquí, entonces podemos decir lo siguiente:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El resultado de la versión "esquelética" de la página durante la carga de datos por parte del cliente crea al usuario una sensación de funcionamiento más rápido del sitio web que cuando el usuario mira una página en blanco mientras el servidor está cargando datos.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La versión gatsby del sitio era solo un poco más rápida que la versión Next.js. </font><font style="vertical-align: inherit;">Sin embargo, el sistema de complemento Gatsby y la documentación del proyecto de alta calidad aumentan la usabilidad de este marco para el desarrollador.</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Queridos lectores! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Utiliza generadores de sitios estáticos o sistemas de representación del lado del servidor para acelerar sus proyectos?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es500216/index.html">Olvida el antropoceno: hemos entrado en la era sintética</a></li>
<li><a href="../es500218/index.html">Modelo epidemiológico Covid-19</a></li>
<li><a href="../es500220/index.html">Discos de vinilo y casetes directamente en tu Android</a></li>
<li><a href="../es500222/index.html">Teléfonos inalámbricos de biplanos británicos de la Primera Guerra Mundial</a></li>
<li><a href="../es500224/index.html">Nariz electrónica de bricolaje</a></li>
<li><a href="../es500232/index.html">Aprendizaje de Akka.NET: servidor de un simple juego en línea</a></li>
<li><a href="../es500234/index.html">¿Por qué hice un proyecto de contabilidad de gastos personales para Git + JS?</a></li>
<li><a href="../es500238/index.html">Dime que te molesta</a></li>
<li><a href="../es500244/index.html">Fuera de la matriz</a></li>
<li><a href="../es500246/index.html">Protección y piratería de la Xbox 360 (Parte 3)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>