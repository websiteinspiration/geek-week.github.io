<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😼 🏧 🗺️ Javaの5つの隠された秘密 ⛎ 🎱 😨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！あなたに私の存在の記事「の翻訳Javaで5つの隠された秘密による」ジャスティン・アルバーノ。
 
 Java Jediになりたいですか？Javaの古代の秘密を暴きます。アノテーション、初期化、コメント、列挙型インターフェースの拡張に焦点を合わせます。
 
 プログラミング言語の開...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Javaの5つの隠された秘密</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480544/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font><font style="vertical-align: inherit;">あなたに私の存在の記事「の翻訳</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javaで5つの隠された秘密</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">による」</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジャスティン・アルバーノ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java Jediになりたいですか？</font><font style="vertical-align: inherit;">Javaの古代の秘密を暴きます。</font><font style="vertical-align: inherit;">アノテーション、初期化、コメント、列挙型インターフェースの拡張に焦点を合わせます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラミング言語の開発に伴い、隠れた関数も出現し始め、創設者が考えたことのない構造がますます一般向けに配布されています。これらの機能の一部は、言語で一般的に受け入れられるようになりますが、他の機能は、言語コミュニティの最も暗い隅に移動します。この記事では、多くのJava開発者が見落としがちな5つの秘密を見ていきます（公平に言うと、これらの秘密のいくつかには、これには十分な理由があります）。これらのオプションの使用方法と、各関数が表示されるようになった理由、およびこれらの関数の使用が推奨される場合を示すいくつかの例を検討します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読者は、これらの機能のすべてが実際に隠されているわけではないことを理解する必要があります。これらの機能は、日常のプログラミングで使用されることはあまりないのです。</font><font style="vertical-align: inherit;">それらのいくつかは適切なタイミングで非常に役立つ可能性がありますが、他のものを使用することはほとんど常に悪い考えであり、読者に興味を持ってもらうために（そしておそらく笑わせるために）この記事に示されています。</font><font style="vertical-align: inherit;">読者は、この記事で説明されている関数をいつ使用するかを決定する必要もあります。「これを実行できるということは、実行する必要があることを意味するものではありません。」</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.注釈を実装する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java Development Kit（JDK）5以降、アノテーションは多くのJavaアプリケーションおよび環境の不可欠な部分です。</font><font style="vertical-align: inherit;">ほとんどの場合、注釈はクラス、フィールド、メソッドなどの構成に適用されます。</font><font style="vertical-align: inherit;">ただし、実装されたインターフェイスとしても使用できます。</font><font style="vertical-align: inherit;">たとえば、次のアノテーションの定義があるとします。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(ElementType.METHOD)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test {
    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に示すように、通常、このアノテーションをメソッドに適用します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestFixure</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">givenFooWhenBarThenBaz</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// ...</span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、「Javaでのアノテーションの作成」で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明されているように、このアノテーションを処理でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">オブジェクトとしてテストを作成できるインターフェイスも作成したい場合は、新しいインターフェイスを作成して、Testではなく、別のインターフェイスを呼び出す必要があります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInstance</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、TestInstanceオブジェクトのインスタンスを作成できます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooTestInstance</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TestInstance</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Foo"</span>;<font></font>
    }<font></font>
}<font></font>
TestInstance myTest = <span class="hljs-keyword">new</span> FooTestInstance();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アノテーションとインターフェースはほぼ同じですが、非常に顕著な重複がありますが、これら2つの構成を組み合わせる方法はないようです。</font><font style="vertical-align: inherit;">幸い、見た目はだまされており、これら2つの構成要素を組み合わせる方法があります。注釈の実装：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Foo"</span>;<font></font>
    }<font></font>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Class&lt;? extends Annotation&gt; annotationType() {
        <span class="hljs-keyword">return</span> Test.class;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはAnnotationインターフェースの暗黙的な部分であるため、annotationTypeメソッドを実装し、注釈のタイプも返す必要があることに注意してください。</font><font style="vertical-align: inherit;">ほとんどすべての場合で、アノテーションの実装は適切な設計上の決定ではありませんが（Javaコンパイラーは、インターフェースの実装時に警告を表示します）、これは、たとえばアノテーション駆動型フレームワークで役立つ場合があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.非静的な初期化ブロック。 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaでは、ほとんどのオブジェクト指向プログラミング言語と同様に、オブジェクトはコンストラクターのみを使用して作成されます（一部の例外はありますが、Javaオブジェクトの逆シリアル化など）。オブジェクトを作成するための静的ファクトリメソッドを作成する場合でも、オブジェクトのコンストラクタで呼び出しをラップしてインスタンス化するだけです。例えば：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;
   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Foo</span><span class="hljs-params">(String name)</span> </span>{
       <span class="hljs-keyword">this</span>.name = name;<font></font>
   }<font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Foo <span class="hljs-title">withName</span><span class="hljs-params">(String name)</span> </span>{
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Foo(name);<font></font>
   }<font></font>
}<font></font>
Foo foo = Foo.withName(<span class="hljs-string">"Bar"</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、オブジェクトを初期化する場合は、オブジェクトのコンストラクターで初期化ロジックを組み合わせます。たとえば、パラメーター化されたコンストラクターでFooクラスの名前フィールドを設定します。すべての初期化ロジックがクラスのコンストラクターまたはコンストラクターのセットにあると想定することは合理的に思えるかもしれませんが、これはJavaの場合ではありません。代わりに、</font><font style="vertical-align: inherit;">オブジェクトを作成するときに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非静的な初期化ブロック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してコードを実行できます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{<font></font>
    {<font></font>
        System.out.println(<span class="hljs-string">"Foo:instance 1"</span>);<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span> </span>{<font></font>
        System.out.println(<span class="hljs-string">"Foo:constructor"</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非静的な初期化ブロックは、クラス定義の一連の中括弧に初期化ロジックを追加することによって指定されます。オブジェクトが作成されると、最初に非静的初期化ブロックが呼び出され、次にオブジェクトのコンストラクターが呼び出されます。複数の非静的初期化ブロックを指定できることに注意してください。その場合、それぞれがクラス定義で指定された順序で呼び出されます。非静的初期化ブロックに加えて、クラスがメモリにロードされたときに実行される静的ブロックも作成できます。静的初期化ブロックを作成するには、staticキーワードを追加するだけです。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{<font></font>
    {<font></font>
        System.out.println(<span class="hljs-string">"Foo:instance 1"</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">static</span> {<font></font>
        System.out.println(<span class="hljs-string">"Foo:static 1"</span>);<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span> </span>{<font></font>
        System.out.println(<span class="hljs-string">"Foo:constructor"</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスに3つの初期化メソッドがすべて存在する場合（コンストラクター、非静的初期化ブロック、静的初期化ブロック）、静的メソッドは常に最初に（クラスがメモリに読み込まれるときに）宣言順に実行され、次に非静的初期化ブロックが宣言された順に実行されます。彼らの後-デザイナー。</font><font style="vertical-align: inherit;">スーパークラスが導入されると、実行の順序が少し変わります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣言の順序での静的スーパークラス初期化ブロック</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣言された順序での静的サブクラス初期化ブロック</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非静的スーパークラス初期化ブロック（宣言された順序）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スーパークラスコンストラクター</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非静的サブクラス初期化ブロック（宣言された順序）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブクラスコンストラクター</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、次のアプリケーションを作成できます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">static</span> {<font></font>
        System.out.println(<span class="hljs-string">"Bar:static 1"</span>);<font></font>
    }<font></font>
    {<font></font>
        System.out.println(<span class="hljs-string">"Bar:instance 1"</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">static</span> {<font></font>
        System.out.println(<span class="hljs-string">"Bar:static 2"</span>);<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bar</span><span class="hljs-params">()</span> </span>{<font></font>
        System.out.println(<span class="hljs-string">"Bar:constructor"</span>);<font></font>
    }<font></font>
    {<font></font>
        System.out.println(<span class="hljs-string">"Bar:instance 2"</span>);<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bar</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;<font></font>
        System.out.println(<span class="hljs-string">"Bar:name-constructor"</span>);<font></font>
    }<font></font>
}<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bar</span> </span>{
    <span class="hljs-keyword">static</span> {<font></font>
        System.out.println(<span class="hljs-string">"Foo:static 1"</span>);<font></font>
    }<font></font>
    {<font></font>
        System.out.println(<span class="hljs-string">"Foo:instance 1"</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">static</span> {<font></font>
        System.out.println(<span class="hljs-string">"Foo:static 2"</span>);<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span> </span>{<font></font>
        System.out.println(<span class="hljs-string">"Foo:constructor"</span>);<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Foo</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">super</span>(name);<font></font>
        System.out.println(<span class="hljs-string">"Foo:name-constructor"</span>);<font></font>
    }<font></font>
    {<font></font>
        System.out.println(<span class="hljs-string">"Foo:instance 2"</span>);<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>{
        <span class="hljs-keyword">new</span> Foo();<font></font>
        System.out.println();<font></font>
        <span class="hljs-keyword">new</span> Foo(<span class="hljs-string">"Baz"</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードを実行すると、次の出力が得られます。</font></font><br>
<br>
<pre><code class="java hljs">Bar:<span class="hljs-keyword">static</span> <span class="hljs-number">1</span>
Bar:<span class="hljs-keyword">static</span> <span class="hljs-number">2</span>
Foo:<span class="hljs-keyword">static</span> <span class="hljs-number">1</span>
Foo:<span class="hljs-keyword">static</span> <span class="hljs-number">2</span>
Bar:instance <span class="hljs-number">1</span>
Bar:instance <span class="hljs-number">2</span><font></font>
Bar:constructor<font></font>
Foo:instance <span class="hljs-number">1</span>
Foo:instance <span class="hljs-number">2</span><font></font>
Foo:constructor<font></font>
Bar:instance <span class="hljs-number">1</span>
Bar:instance <span class="hljs-number">2</span><font></font>
Bar:name-constructor<font></font>
Foo:instance <span class="hljs-number">1</span>
Foo:instance <span class="hljs-number">2</span>
Foo:name-constructor</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのFooオブジェクトが作成された場合でも、静的初期化ブロックは1回だけ実行されたことに注意してください。</font><font style="vertical-align: inherit;">非統計的および静的な初期化ブロックは有用ですが、初期化ロジックはコンストラクターに配置する必要があり、メソッド（または静的メソッド）は、複雑なロジックでオブジェクトの状態の初期化が必要な場合に使用する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.二重括弧の初期化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのプログラミング言語には、詳細なテンプレートコードを使用せずにリストまたはマップ（または辞書）をすばやく簡単に作成するためのある種の構文メカニズムが含まれています。たとえば、C ++には</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">括弧の初期化が</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">含ま</font><font style="vertical-align: inherit;">れているため、開発者は列挙値のリストをすばやく作成できます。また、オブジェクトのコンストラクターがこの関数をサポートしている場合は、オブジェクト全体を初期化することもできます。残念ながら、JDK 9以前は、そのような関数は実装されていませんでした（詳細は後ほど）。オブジェクトのリストを作成するには、次のようにします。</font></font><br>
<br>
<pre><code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<font></font>
myInts.add(<span class="hljs-number">1</span>);<font></font>
myInts.add(<span class="hljs-number">2</span>);<font></font>
myInts.add(<span class="hljs-number">3</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、3つの値で初期化された新しいリストを作成するという目標を満たしますが、冗長すぎて、開発者は追加ごとにリスト変数名を繰り返す必要があります。</font><font style="vertical-align: inherit;">このコードを短縮するには、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二重括弧の初期化を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs">List &lt; Integer &gt;List&lt;Integer&gt; myInts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;() {{<font></font>
    add(<span class="hljs-number">1</span>);<font></font>
    add(<span class="hljs-number">2</span>);<font></font>
    add(<span class="hljs-number">3</span>);<font></font>
}};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
二重括弧の初期化は、2つの開き中括弧と閉じ中括弧のセットからその名前を取得し、実際にはいくつかの構文要素のコレクションです。</font><font style="vertical-align: inherit;">まず、</font><font style="vertical-align: inherit;">ArrayListクラスを拡張</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する匿名の内部クラス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作成します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ArrayListには抽象メソッドがないため、匿名実装の空の本体を作成できます。</font></font><br>
<br>
<pre><code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;() {};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードを使用して、基本的に匿名のサブクラスを作成します。ArrayListは元のArrayListとまったく同じです。</font><font style="vertical-align: inherit;">主な違いの1つは、内部クラスが包含クラスへの暗黙的な参照を（これによってキャプチャされた変数の形式で）持つことです。</font><font style="vertical-align: inherit;">非静的内部クラスを作成します。</font><font style="vertical-align: inherit;">これにより、紛らわしくはないとしても、興味深いロジックを書くことができます。</font><font style="vertical-align: inherit;">たとえば、この変数を二重括弧で初期化された匿名の内部クラスに追加します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Foo&gt; <span class="hljs-title">getListWithMeIncluded</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Foo&gt;() {{<font></font>
            add(Foo.<span class="hljs-keyword">this</span>);<font></font>
        }};<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>{<font></font>
        Foo foo = <span class="hljs-keyword">new</span> Foo();<font></font>
        List&lt;Foo&gt; fooList = foo.getListWithMeIncluded();<font></font>
        System.out.println(foo.equals(fooList.get(<span class="hljs-number">0</span>)));<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この内部クラスが静的として定義されている場合、Foo.thisにアクセスできません。</font><font style="vertical-align: inherit;">たとえば、静的FooArrayList内部クラスを作成する次のコードはFoo.thisリンクにアクセスできないため、コンパイルされません。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Foo&gt; <span class="hljs-title">getListWithMeIncluded</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FooArrayList();<font></font>
    }<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooArrayList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">Foo</span>&gt; </span>{{<font></font>
        add(Foo.<span class="hljs-keyword">this</span>);<font></font>
    }}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ダブルブラケットで初期化されたArrayListで構成を再開することにより、非静的内部クラスが作成されるとすぐに、前述の非静的初期化ブロックを使用して、匿名内部クラスのインスタンスを作成するときに3つの初期要素を追加します。匿名内部クラスが作成され、匿名内部クラスのオブジェクトが1つしかない場合は、作成時に3つの初期要素を追加する非静的内部オブジェクトを作成したと言えます。これは、1つの中括弧が匿名の内部クラスの定義を表し、もう1つの中括弧がインスタンス初期化ロジックの開始を示す、中括弧のペアを分離する場合に見られます。</font></font><br>
<br>
<pre><code class="java hljs">List&lt;Integer&gt; myInts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;() {<font></font>
    {<font></font>
        add(<span class="hljs-number">1</span>);<font></font>
        add(<span class="hljs-number">2</span>);<font></font>
        add(<span class="hljs-number">3</span>);<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このトリックは役立つかもしれませんが、JDK 9（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 269</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は、このトリックの有用性を、List（およびその他の多くのタイプのコレクション）の一連の静的ファクトリーメソッドに置き換えました。たとえば、次に示すように、これらの静的ファクトリメソッドを使用して、以前にリストを作成できます。</font></font><br>
<br>
<pre><code class="java hljs">List&lt;Integer&gt; myInts = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この静的ファクトリー手法は、2つの主な理由で使用されます：（1）匿名の内部クラスが作成されない、（2）リストの作成に必要な標準コードを削減する。この場合、結果のリストの結果は変更されず、作成後に変更できないことに注意してください。初期要素を含む変更可能なリストファイルを作成するには、通常のメソッドまたは二重の初期化ブラケットを持つメソッドを使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純な初期化、ダブルブラケット、およびJDK 9静的ファクトリメソッドは、Listだけで使用できるわけではないことに注意してください。次のスニペットに示すように、これらはSetオブジェクトとMapオブジェクトで使用できます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">//  </span>
Map&lt;String, Integer&gt; myMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<font></font>
myMap.put(<span class="hljs-string">"Foo"</span>, <span class="hljs-number">10</span>);<font></font>
myMap.put(<span class="hljs-string">"Bar"</span>, <span class="hljs-number">15</span>);
<span class="hljs-comment">//     </span>
Map&lt;String, Integer&gt; myMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;() {{<font></font>
    put(<span class="hljs-string">"Foo"</span>, <span class="hljs-number">10</span>);<font></font>
    put(<span class="hljs-string">"Bar"</span>, <span class="hljs-number">15</span>);<font></font>
}};<font></font>
<span class="hljs-comment">//   </span>
Map&lt;String, Integer&gt; myMap = Map.of(<span class="hljs-string">"Foo"</span>, <span class="hljs-number">10</span>, <span class="hljs-string">"Bar"</span>, <span class="hljs-number">15</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用を決定する前に、二重ブラケットがどのように初期化されるかを理解することが重要です。</font><font style="vertical-align: inherit;">これによりコードが読みやすくなりますが、いくつかの副作用が発生する場合があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.実行可能コメント</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コメントは、ほとんどすべてのプログラムに不可欠な部分であり、コメントの主な利点は、コメントが実行されないことです。</font><font style="vertical-align: inherit;">これは、プログラムのコード行をコメントアウトするとさらに明確になります。アプリケーションにコードを保存したいのですが、実行したくありません。</font><font style="vertical-align: inherit;">たとえば、結果として次のプログラムは「5」を表示します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{
    <span class="hljs-keyword">int</span> value = <span class="hljs-number">5</span>;
    <span class="hljs-comment">// value = 8;</span><font></font>
    System.out.println(value);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの人はコメントは決して実行されないと思っていますが、これは完全に真実ではありません。</font><font style="vertical-align: inherit;">たとえば、次のコードは何を出力しますか？</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{
    <span class="hljs-keyword">int</span> value = <span class="hljs-number">5</span>;
    <span class="hljs-comment">// \u000dvalue = 8;</span><font></font>
    System.out.println(value);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これも5であると想定できますが、上記のコードを実行すると、出力に8が表示されます。この「エラー」の原因は、Unicode文字\ u000dです。この文字は実際には</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unicodeキャリッジリターン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり、JavaソースコードはコンパイラによってUnicode形式のテキストファイルとして使用されます。コードに追加すると、コメントの次の行に値= 8が設定され、その実行が保証されます。つまり、上記のコードフラグメントは実際には次のコードと同じです。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{
    <span class="hljs-keyword">int</span> value = <span class="hljs-number">5</span>;
    <span class="hljs-comment">// </span>
value = <span class="hljs-number">8</span>;<font></font>
    System.out.println(value);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはJavaのバグのように見えますが、実際には言語に特別に追加された関数です。最初の目標は、プラットフォームに依存しない言語を作成すること（したがって、JavaまたはJVM仮想マシンを作成すること）であり、ソースコードの相互運用性がこの目標の主要な側面です。 JavaソースコードにUnicode文字を含めることを許可することにより、非ラテン文字を普遍的な方法で使用できます。これにより、世界の1つの領域（コメントなどの非ラテン文字が含まれている可能性がある）で記述されたコードを他の任意の領域で実行できるようになります。詳細について</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、JavaまたはJLS言語仕様のセクション3.3を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを極端にして、アプリケーション全体をUnicodeで書くことさえできます。</font><font style="vertical-align: inherit;">たとえば、次のプログラムは何をしていますか（ソースコード、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から派生</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">：コメントでのコードの実行？！</font></a><font style="vertical-align: inherit;">）</font></font><br>
<br>
<pre><code class="java hljs">\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020\u0020<font></font>
\u0063\u006c\u0061\u0073\u0073\u0020\u0055\u0067\u006c\u0079<font></font>
\u007b\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020<font></font>
\u0020\u0020\u0020\u0020\u0073\u0074\u0061\u0074\u0069\u0063<font></font>
\u0076\u006f\u0069\u0064\u0020\u006d\u0061\u0069\u006e\u0028<font></font>
\u0053\u0074\u0072\u0069\u006e\u0067\u005b\u005d\u0020\u0020<font></font>
\u0020\u0020\u0020\u0020\u0061\u0072\u0067\u0073\u0029\u007b<font></font>
\u0053\u0079\u0073\u0074\u0065\u006d\u002e\u006f\u0075\u0074<font></font>
\u002e\u0070\u0072\u0069\u006e\u0074\u006c\u006e\u0028\u0020<font></font>
\u0022\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u0022\u002b<font></font>
\u0022\u006f\u0072\u006c\u0064\u0022\u0029\u003b\u007d\u007d</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコードをUgly.javaというファイルに入れて実行すると、Hello worldが標準出力に出力されます。</font><font style="vertical-align: inherit;">これらのUnicode文字を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情報交換用アメリカ標準コード（ASCII）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に変換する</font><font style="vertical-align: inherit;">と、次のプログラムが得られます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ugly</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{<font></font>
        System.out.println(<span class="hljs-string">"Hello w"</span>+<span class="hljs-string">"orld"</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、JavaソースコードにUnicode文字を含めることができますが、必要でない場合は使用しないことを強くお勧めします（たとえば、非ラテン文字をコメントに含めるため）。</font><font style="vertical-align: inherit;">それでも必要な場合は、キャリッジリターンなど、予想されるソースコードの動作を変更する文字が含まれていないことを確認してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Enumインターフェースの実装</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaの他のクラスと比較した列挙型（列挙リスト）の制限の1つは、列挙型が別のクラスまたは列挙型自体を拡張できないことです。</font><font style="vertical-align: inherit;">たとえば、次のことはできません。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Speaker</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>{<font></font>
        System.out.println(<span class="hljs-string">"Hi"</span>);<font></font>
    }<font></font>
}<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Person extends Speaker {<font></font>
    JOE(<span class="hljs-string">"Joseph"</span>),<font></font>
    JIM(<span class="hljs-string">"James"</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;<font></font>
    }<font></font>
}<font></font>
Person.JOE.speak();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、次のように列挙型にインターフェイスを実装させ、その抽象メソッドの実装を提供することができます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Speaker</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>;<font></font>
}<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Person implements Speaker {<font></font>
    JOE(<span class="hljs-string">"Joseph"</span>),<font></font>
    JIM(<span class="hljs-string">"James"</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;<font></font>
    }<font></font>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>{<font></font>
        System.out.println(<span class="hljs-string">"Hi"</span>);<font></font>
    }<font></font>
}<font></font>
Person.JOE.speak();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、Speakerオブジェクトが必要な場合はいつでもPersonのインスタンスを使用できます。</font><font style="vertical-align: inherit;">さらに、継続的に抽象インターフェースメソッド（いわゆる定数に固有のメソッド）を確実に実装することもできます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Speaker</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>;<font></font>
}<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Person implements Speaker {<font></font>
    JOE(<span class="hljs-string">"Joseph"</span>) {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>{ System.out.println(<span class="hljs-string">"Hi, my name is Joseph"</span>); }<font></font>
    },<font></font>
    JIM(<span class="hljs-string">"James"</span>){
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>{ System.out.println(<span class="hljs-string">"Hey, what's up?"</span>); }<font></font>
    };<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;<font></font>
    }<font></font>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>{<font></font>
        System.out.println(<span class="hljs-string">"Hi"</span>);<font></font>
    }<font></font>
}<font></font>
Person.JOE.speak();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の他の秘密とは異なり、この手法は必要な場合にのみ使用する必要があります。</font><font style="vertical-align: inherit;">たとえば、スピーカーなどのインターフェイスの代わりにJOEやJIMなどの列挙型定数を使用できる場合、定数を定義する列挙型はこのタイプのインターフェイスを実装する必要があります。</font><font style="vertical-align: inherit;">詳細については、「段落38（p。176-9）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">効果的なJava第3版」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を参照してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、Javaの5つの隠された秘密を調べました。（1）アノテーションを拡張できる、（2）非静的な初期化ブロックを使用してオブジェクトを作成するときに構成できる、（3）二重括弧を使用した初期化を使用して作成時に命令を実行できる匿名の内部クラス、（4）コメントを実行できる、（5）列挙型でインターフェースを実装できる。</font><font style="vertical-align: inherit;">これらの関数は特定のタイプのタスクで使用されますが、一部の関数（たとえば、実行可能コメントの作成）は避ける必要があります。</font><font style="vertical-align: inherit;">これらのシークレットを使用することを決定するときは、ルールを必ず守ってください。「これを実行できるという事実は、実行する必要があることを意味するものではありません。」</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja480532/index.html">別の角度からのEDA</a></li>
<li><a href="../ja480534/index.html">KotlinでのAndroid向けの16の開発のヒント。パート2</a></li>
<li><a href="../ja480538/index.html">ゲームに最適なのはIntel OptaneとSSDのどちらですか？</a></li>
<li><a href="../ja480540/index.html">Umbraco 8.4リリース：CMSがさらに便利に</a></li>
<li><a href="../ja480542/index.html">大人のセキュリティ意識：フィッシングの脆弱性を解決する方法</a></li>
<li><a href="../ja480550/index.html">JVMのバイトコードからのHello World</a></li>
<li><a href="../ja480552/index.html">FirefoxはWebの未来のために戦います</a></li>
<li><a href="../ja480554/index.html">到来しなかったサンのクラウドコンピューティングの未来</a></li>
<li><a href="../ja480556/index.html">NGINX：ロシアのITコミュニティの検証</a></li>
<li><a href="../ja480558/index.html">損益分岐レベルのマイニングでビットコインのピボットポイントを決定する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>