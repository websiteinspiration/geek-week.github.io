<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐞 👨‍⚕️ 🎅🏾 PVS-StudioでのVisual Studio 2019のサポート 👩🏿‍🤝‍👩🏻 🤵🏿 🌝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PVS-StudioでのVisual Studio 2019のサポートは、IDEプラグイン自体、コマンドライン分析アプリケーション、C ++およびC＃アナライザーカーネル、およびいくつかのユーティリティなど、いくつかの異なるコンポーネントにすぐに影響しました。IDEの新しいバージョンのサポート中に発...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PVS-StudioでのVisual Studio 2019のサポート</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/454738/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de3/aea/16e/de3aea16e3b6472a4d5034fd035d8827.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-StudioでのVisual Studio 2019のサポートは、IDEプラグイン自体、コマンドライン分析アプリケーション、C ++およびC＃アナライザーカーネル、およびいくつかのユーティリティなど、いくつかの異なるコンポーネントにすぐに影響しました。</font><font style="vertical-align: inherit;">IDEの新しいバージョンのサポート中に発生した問題とその解決方法について簡単に説明します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
始める前に、以前のバージョンのVisual Studioのサポートの履歴を少し振り返ってみましょう。これにより、問題のビジョンと特定の状況で行われた決定についての理解が深まります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visual Studio環境用のプラグインが登場した最初のバージョンのPVS-Studioアナライザー（それはVisual Studio 2005のバージョンでもありました）から始まり、新しいバージョンのVisual Studioをサポートすることは、私たちにとってかなり単純な作業でした-基本的に、プラグインプロジェクトファイルを更新するために煮詰めましたさまざまなVisual Studio拡張APIの依存関係。 Visual C ++コンパイラが徐々に学習しているC ++言語の新機能を追加でサポートすることが必要な場合もありますが、これも通常、次のVisual Studioのリリースの直前に問題を引き起こすことはありませんでした。そして、PVS-Studioには、CおよびC ++言語用のアナライザーが1つしかありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visual Studio 2017のリリースですべてが変更されました。このバージョンでは、このIDEの拡張APIの多くが大幅に変更されたという事実に加えて、更新後に、当時出現していた新しいC＃アナライザー（および新しいC ++レイヤー）の作業の下位互換性を確保するという問題が発生しました。 MSBuildプロジェクトのアナライザー）、MSBuild \ Visual Studioの古いバージョン。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、この記事を読む前に、Visual Studio 2017のサポートに関する関連記事を読むことを強くお勧めします。「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-StudioでのVisual Studio 2017とRoslyn 2.0のサポート：既製のソリューションを使用することは、一見したほど簡単ではない場合があります。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記の記事では、前回発生した問題と、さまざまなコンポーネント（PVS-Studio、MSBuild、Roslynなど）の相互作用スキームについて説明しています。この相互作用を理解することは、この記事を読む際に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終的には、これらの解決策この問題により、アナライザーに大幅な変更が加えられました。また、期待どおり、次に適用した新しいアプローチにより、Visual Studio \ MSBuildの更新バージョンをより簡単かつ迅速にサポートできるようになり、この前提の一部は、多数のVisual Studio更新プログラムのリリースによって既に確認されています。 2017. Visual Studio 2019のサポートによるこの新しいアプローチは役に立ちましたか？これについては以下で説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visual Studio 2019用PVS-Studioプラグイン</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはすべて始まった、それは悪くはないようだ。プラグインをVisual Studio 2019に移植するのは簡単で、そこで起動して正常に動作しました。それにもかかわらず、2つの問題がすぐに明らかになり、将来の問題が約束されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初-インタフェース</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IVsSolutionWorkspaceService</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ちなみに、Visual Studioの2017年に、まだ以前のアップデートで無効になっていた、政権軽量ソリューションのロードをサポートするために使用さは、属性が施された</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非推奨</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これまでアセンブリで警告のみですが、将来のボード線Bで、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およそ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lshie問題。マイクロソフトはすぐにこのモードを導入し、それを放棄しました...この問題は非常に簡単に対処しました-適切なインターフェースの使用を拒否しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目-プラグインを使用してVisual Studioをロードすると、次のメッセージが表示</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">されました。VisualStudioは、機能VS更新で機能していないか、機能していない1つ以上の拡張機能を検出しました。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Visual Studio起動ログ（ActivityLogファイル）を表示すると、ようやく「i」が点在します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告：拡張機能「PVS-Studio」は、Visual Studioの「同期自動ロード」機能を使用します。この機能は、将来のVisual Studio 2019の更新ではサポートされなくなります。その時点では、この拡張機能は機能しません。アップデートを入手するには、拡張機能のベンダーにお問い合わせください。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちにとって、これは1つのことを意味しました-プラグインが非同期モードにロードされる方法を変更します。 Visual StudioのCOMインターフェイスとのやり取りに関する詳細を説明しすぎないように気を抜かず、変更について簡単に説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイクロソフトは、非同期で読み込まれるプラグインの作成に関する記事を持っています：「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法：バックグラウンドでVSPackageを読み込むためにAsyncPackageを使用する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」。さらに、問題がこれらの変更に限定されないことは誰にとっても明白でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な変更点の1つは、ロードの方法、つまり初期化です。以前は、必要な初期化は、二つの方法で行われた-上書き</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の方法</font><font style="vertical-align: inherit;">私たちの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージの</font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">継承</font></i><font style="vertical-align: inherit;">クラス</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;">および</font><i><font style="vertical-align: inherit;">OnShellPropertyChange</font></i><font style="vertical-align: inherit;">方法</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ロジックの一部を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnShellPropertyChange</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドに転送する必要</font><font style="vertical-align: inherit;">があるのは、プラグインが同期的に読み込まれたときに、Visual Studioがまだ完全に読み込まれて初期化されていない可能性があるためです。その結果、プラグインの初期化段階で必要なすべてのアクションを実行できるとは限りません。この問題を解決するオプションは、Visual Studioが「ゾンビ」状態を終了してこれらのアクションを遅延させるのを待つことです。これはロジックであり</font><font style="vertical-align: inherit;">、「ゾンビ」状態のチェックを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して</font><i><font style="vertical-align: inherit;">OnShellPropertyChange</font></i><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">レンダリングされています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">非同期に読み込まれたプラグインが継承される</font><i><font style="vertical-align: inherit;">AsyncPackage</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
抽象クラス</font><font style="vertical-align: inherit;">では、</font><i><font style="vertical-align: inherit;">Initialize</font></i><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">に</font><i><font style="vertical-align: inherit;">封印された</font></i><font style="vertical-align: inherit;">修飾子があります</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なので、初期化は、オーバーライドされた</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitializeAsync</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">行う必要があります</font><font style="vertical-align: inherit;">。また、プラグインでこの情報の受信を停止したため、Visual Studioの「ゾンビ」状態を追跡してロジックを変更する必要がありました。ただし、プラグインが初期化された後に実行する必要があるいくつかのアクションは消えませんでした。出力は、メソッド</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnPackageLoaded</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェース</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IVsPackageLoadEvents</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の使用であり、</font><font style="vertical-align: inherit;">遅延実行が必要なアクションを実行しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラグインが非同期でロードされたという事実から論理的に明らかになったもう1つの問題は、Visual Studioの起動時にPVS-Studioプラグインコマンドがないことでした。ファイルマネージャーからダブルクリックしてアナライザーログを開くと（Visual Studioで開く必要がある場合）、アナライザーレポートを開くコマンドで必要なバージョンのdevenv.exeが起動されました。起動コマンドは次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\
 2017\Community\Common7\IDE\devenv.exe"</span>
/command <span class="hljs-string">"PVSStudio.OpenAnalysisReport 
C:\Users\vasiliev\source\repos\ConsoleApp\ConsoleApp.plog"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここの「/コマンド」フラグは、Visual Studioに登録されたコマンドを呼び出すために使用されます。プラグインをダウンロードするまでコマンドを使用できないため、この方法は機能しませんでした。その結果、プラグインをロードした後、devenv.exeの起動行を解析し、ログを開くコマンドの文字列表現がある場合は、実際にログをロードして、「松葉杖」で停止する必要がありました。したがって、この場合、コマンドの操作に「正しい」インターフェースを使用することを拒否したため、プラグインが完全にロードされるまでログのロードを遅らせることにより、必要な機能を維持することができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ふー、それは整理されているようで、すべてが機能しています-すべてが正しく読み込まれて開き、警告はありません-最後に。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、予期しないことが起こります-Pavel（こんにちは！）プラグインをインストールしてから、非同期ロードを行わなかった理由を尋ねます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが驚いたと言うために-何も言うことなく-どのように？いいえ、本当に-ここにインストールされているプラ​​グインの新しいバージョンがあります。ここに、パッケージが同期的にダウンロード可能であるというメッセージがあります。私たちはマシンに同じバージョンのプラグインをアレクサンダー（そしてあなたにもこんにちは）を使ってインストールします-すべて問題ありません。明確なものはありません。VisualStudioに読み込まれたPVS-Studioライブラリのバージョンを確認することにしました。そして突然、Visual Studio 2017用のライブラリの正しいバージョンがVSIXパッケージに含まれている間、Visual Studio 2017用のPVS-Studioライブラリのバージョンが使用されていることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VSIXInstallerをいじって、なんとか問題の原因、つまりパッケージキャッシュを見つけました。理論は、キャッシュ内のパッケージ（C：\ ProgramData \ Microsoft \ VisualStudio \ Packages）へのアクセス権を制限するときに、VSIXInstallerがログにエラー情報を書き込んだという事実によっても確認されました。驚いたことに、エラーがなければ、パッケージがキャッシュからインストールされたという情報はログに書き込まれません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 VSIXInstallerと関連ライブラリの動作を調べたところ、RoslynとMSBuildにオープンソースコードがあり、作業のロジックの読み取り、デバッグ、追跡が簡単にできることは非常にすばらしいことだと彼は思いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、次のことが起こりました-プラグインのインストール時に、VSIXInstallerは対応するパッケージがすでにキャッシュにあることを確認し（Visual Studio 2017の.vsixパッケージがあった）、インストール中に実際にインストールされたパッケージの代わりにそれを使用しました。これが.vsixmanifestで説明されている制限/要件を考慮しない理由（たとえば、拡張機能をインストールできるVisual Studioのバージョン）は未解決の問題です。このため、.vsixmanifestには必要な制限が含まれていましたが、Visual Studio 2017用に設計されたプラグインがVisual Studio 2019にインストールされていることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最悪のことは、そのようなインストールはVisual Studioの依存関係グラフを壊し、外見上は開発環境が正常に機能しているように見えるかもしれませんが、実際にはすべてが非常に悪かったです。拡張機能のインストールとアンインストール、更新などはできませんでした。 「回復」のプロセスもかなり不快でした。拡張機能（対応するファイル）を削除し、インストールされたパッケージに関する情報を格納する構成ファイルを手動で編集する必要がありました。一般的に、それは十分に楽しいものではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決し、今後同様の状況を回避するために、Visual Studio 2017パッケージとVisual Studio 2019パッケージを完全に分離するために、新しいパッケージのGUIDを作成することが決定されました（古いパッケージではそのような問題はなく、常に共通のGUIDを使用していました）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不愉快な驚きについて話していたので、もう1つ説明します。プレビュー2に更新した後、メニュー項目が[拡張機能]タブの下に[移動]しました。大丈夫のようですが、プラグインの機能へのアクセスが不便になっています。リリースバージョンを含むVisual Studio 2019の後続のバージョンでは、この動作は維持されています。ドキュメントやブログには、リリース時のこの「機能」についての言及はありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、すべてが機能しているように見え、Visual Studio 2019のプラグインサポートが終了しました。 Visual Studio 2019をサポートするPVS-Studio 7.02のリリースの翌日、これはそうではないことが判明しました-非同期プラグインに別の問題が見つかりました。ユーザーの場合、これは次のようになります。分析の結果を含むウィンドウを開く（または分析を開始する）ときに、ウィンドウが「空」と表示されることがありました。コンテンツが含まれていませんでした：ボタン、アナライザーの警告の表など。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、作業中にこの問題が繰り返されることもありました。ただし、これは1台のマシンでのみ繰り返され、「プレビュー」の最初のバージョンのいずれかでVisual Studioを更新した後にのみ表示され始めました-インストール/更新中に何かが破損した疑いがありました。しかし、時間の経過とともに、このマシンでも問題が繰り返されなくなり、「自分で修復する」と判断しました。それは違う-とても幸運だった。より正確には、運はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、環境ウィンドウ自体（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToolWindowPane</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスの子孫</font><font style="vertical-align: inherit;">）とその内容（実際には、グリッドとボタンを使用したコントロール）</font><font style="vertical-align: inherit;">の初期化の順序であることが</font><i><font style="vertical-align: inherit;">わかりました</font></i><font style="vertical-align: inherit;">。特定の条件下では、ペインが初期化される前にコントロールが初期化され、エラーなしですべてが機能するという事実にもかかわらず、</font><i><font style="vertical-align: inherit;">FindToolWindowAsync</font></i><font style="vertical-align: inherit;">メソッドが</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（最初の呼び出しでウィンドウを作成する）それは正しく機能しましたが、コントロールは非表示のままでした。</font><font style="vertical-align: inherit;">これを修正するには、コントロールの遅延初期化をペインフィルコードに追加します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サポートC＃8.0</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アナライザーのベースとしてRoslynを使用することには大きな利点があります。新しい言語構造を手動でサポートする必要はありません。これはすべて、Microsoft.CodeAnalysisライブラリのフレームワーク内でサポートおよび実装されています。既製の結果を使用しています。したがって、新しい構文のサポートは、ライブラリを更新することで実装されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、静的分析に関する限り、ここでは、特に新しい言語構成要素を処理するために、すでにすべてを自分で行う必要があります。はい、新しいバージョンのRoslynを使用して新しい構文ツリーを自動的に取得しますが、ツリーの新しいノードまたは変更されたノードを認識して処理する方法をアナライザーに教える必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C＃8で最も話題になっているイノベーションはnull可能な参照型だと思います。私はそれらについてここでは書きません-これは別の記事にふさわしい十分に大きなトピックです（すでに書かれている途中です）。一般に、これまでのところ、データフローメカニズムでnullを使用できるアノテーションを無視することで解決しています（つまり、アノテーションを理解、解析、スキップします）。事実は、変数のnull不可の参照型にもかかわらず</font><font style="vertical-align: inherit;">、対応するリンクを逆参照するときにNREにつながる可能性のある</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">非常に簡単に（または誤って）書き込むことができるということです</font><font style="vertical-align: inherit;">。この場合、アナライザーは同様のエラーを表示し、変数のnull不可の参照型にもかかわらず、nullの可能性がある参照の使用について警告を出すことができます（もちろん、コードでそのような割り当てが見つかった場合）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
null可能な参照型とそれに付随する構文を使用すると、非常に興味深いコードを作成できる可能性が生まれます。</font><font style="vertical-align: inherit;">私たちはそれを「感情的な構文」と呼んでいました。</font><font style="vertical-align: inherit;">以下のコードは非常にうまくコンパイルされます：</font></font><br>
<br>
<pre><code class="cpp hljs">obj.Calculate();<font></font>
obj?.Calculate();<font></font>
obj.Calculate();<font></font>
obj!?.Calculate();<font></font>
obj!!!.Calculate();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、私の仕事の過程で、新しい構文を使用してVisual Studioを「埋める」方法がいくつか見つかりました。</font><font style="vertical-align: inherit;">実際には、「！」を入力するときに文字数を1つに制限することはできません。</font><font style="vertical-align: inherit;">つまり、次の形式のコードだけでなく、</font></font><br>
<br>
<pre><code class="cpp hljs">object temp = null!</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だけでなく： </font></font><br>
<br>
<pre><code class="cpp hljs">object temp = null!!!;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは倒錯し、先に進み、次のように書くことができます：</font></font><br>
<br>
<pre><code class="cpp hljs">object temp = null!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<font></font>
                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは正常にコンパイルされます。</font><font style="vertical-align: inherit;">ただし、.NET Compiler Platform SDKのSyntax Visualizerを使用して構文ツリー情報をクエリすると、Visual Studioがクラッシュします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントビューアから問題に関する情報を取得できます。</font></font><br>
<br>
<pre><code class="cpp hljs">Faulting application name: devenv.exe,<font></font>
version: <span class="hljs-number">16.0</span><span class="hljs-number">.28803</span><span class="hljs-number">.352</span>, time stamp: <span class="hljs-number">0x5cc37012</span>
Faulting <span class="hljs-keyword">module</span> name: WindowsBase.ni.dll,<font></font>
version: <span class="hljs-number">4.8</span><span class="hljs-number">.3745</span><span class="hljs-number">.0</span>, time stamp: <span class="hljs-number">0x5c5bab63</span>
Exception code: <span class="hljs-number">0xc00000fd</span>
Fault offset: <span class="hljs-number">0x000c9af4</span>
Faulting process id: <span class="hljs-number">0x3274</span>
Faulting application start time: <span class="hljs-number">0x01d5095e7259362e</span>
Faulting application path: C:\<span class="hljs-function">Program <span class="hljs-title">Files</span> <span class="hljs-params">(x86)</span>\
Microsoft Visual Studio\2019\Community\Common7\IDE\devenv.exe
Faulting <span class="hljs-keyword">module</span> path: C:\WINDOWS\assembly\NativeImages_v4.0.30319_32\
WindowsBase\4480dfedf0d7b4329838f4bbf953027d\WindowsBase.ni.dll
Report Id: 66d41eb2-c658-486d-b417-02961d9c3e4f
Faulting package full name: 
Faulting package-relative application ID:</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに進んで感嘆符の数を数回増やすと、Visual Studio自体が落ちてしまいます-Syntax Visualizerのヘルプは不要になりました。</font><font style="vertical-align: inherit;">Microsoft.CodeAnalysisライブラリとcsc.exeコンパイラもこのコードをダイジェストしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これらは総合的な例ですが、それでも、この事実は私にはおかしく思えました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツールセット</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">もう一度、MSBuildプロジェクトについての会話の中で「評価」という単語を翻訳する問題に直面しました。</font><font style="vertical-align: inherit;">翻訳は意味が最も近いようで、同時に正常に聞こえましたが、「プロジェクトモデルの構築」でした。</font><font style="vertical-align: inherit;">代替の翻訳オプションがある場合-私に書いてもらえれば、読むのは興味深いでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツールセットの更新が最も時間のかかる作業であることは明らかでした。より正確には、それは最初からそうであるように見えましたが、今では最も問題のあるのはプラグインのサポートであると信じる傾向があります。特に、これは既存のツールセットとMSBuildプロジェクトモデルを構築するためのメカニズムによるものでしたが、拡張が必要でしたが、現在は正常に機能しています。アルゴリズムを最初から作成する必要がないため、タスクが大幅に簡略化されました。 Visual Studio 2017をサポートする段階で作成された「私たちの」ツールセットに対する私たちの賭けは、再び正当化されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従来、すべてはNuGetパッケージの更新から始まりました。ソリューションの[NuGetパッケージ管理]タブに、[更新]ボタンがありますが、これは機能しません。すべてのパッケージを更新すると、複数のバージョンの競合が発生し、それらをすべて解決することはあまり正確ではないようです。より苦痛ですが、より信頼できる方法は、Microsoft.Build / Microsoft.CodeAnalysisの更新ターゲットパッケージを「個別に」更新することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
違いの1つは、診断ルールのテストによってすぐに特定されました-既存のノードの構文ツリーの構造が変更されました。大丈夫です、すぐに修正されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業の過程で、オープンソースプロジェクトでアナライザー（C＃、C ++、Java）をテストすることを思い出してください。これにより、診断ルールを適切にテストできます-たとえば、誤検知を見つけるか、他のどのケースが考慮されていなかったかを知る（誤検知の数を減らす）。これらのテストは、ライブラリ/ツールセットの更新の初期段階で起こり得る回帰を追跡するのにも役立ちます。そして、今回も例外ではなく、多くの問題が浮上しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つの問題は、CodeAnalysisライブラリ内の動作の悪化でした。より具体的には、ライブラリコード内のいくつかのプロジェクトで、セマンティック情報の取得、プロジェクトのオープンなど、さまざまな操作中に例外が発生しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visual Studio 2017のサポートに関する記事の注意深い読者は、配布キットにスタブがあることを思い出してください。MSBuild.exeファイルのサイズは0バイトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今回はさらに進めなければなりませんでした-現在、配布キットには空のコンパイラスタブ（csc.exe、vbc.exe、VBCSCompiler.exe）も含まれています。何のために？これへの道は、レポートの差分が表示されたテストベースのプロジェクトの1つを分析することから始まりました。新しいバージョンのアナライザーを使用すると、いくつかの警告が表示されませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は条件付きコンパイルシンボルであることが判明しました。新しいバージョンのアナライザーを使用してプロジェクトを分析すると、一部のシンボルが誤って抽出されました。この問題の原因をよりよく理解するために、Roslynライブラリに飛び込む必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
条件付きコンパイル文字を解析するには、メソッドを使用します</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリ</font><i><font style="vertical-align: inherit;">Microsoft.Build.Tasks.CodeAnalysisの</font></i><i><font style="vertical-align: inherit;">GetDefineConstantsSwitch</font></i><font style="vertical-align: inherit;">クラス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Csc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">解析は</font><font style="vertical-align: inherit;">、いくつかの区切り文字に対して</font><i><font style="vertical-align: inherit;">String.Split</font></i><font style="vertical-align: inherit;">メソッドを使用して実行さ</font><font style="vertical-align: inherit;">れます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">string</span>[] allIdentifiers <font></font>
  = originalDefineConstants.Split(<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[] { <span class="hljs-string">','</span>, <span class="hljs-string">';'</span>, <span class="hljs-string">' '</span> });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この解析方法は正常に機能し、条件付きコンパイルに必要なすべてのシンボルが正常に抽出されます。</font><font style="vertical-align: inherit;">さらに掘り下げる。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の重要なポイント-メソッドは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ComputePathToTool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToolTask​​を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このメソッドは、実行可能ファイル（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">csc.exe</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">へのパスを作成し、</font><font style="vertical-align: inherit;">その存在を確認します。</font><font style="vertical-align: inherit;">ファイルが存在する場合はそのファイルへのパスが返され、それ以外の場合は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
発信者コード：</font></font><br>
<br>
<pre><code class="cpp hljs">....
<span class="hljs-built_in">string</span> pathToTool = ComputePathToTool();
<span class="hljs-keyword">if</span> (pathToTool == null)<font></font>
{<font></font>
    <span class="hljs-comment">// An appropriate error should have been logged already.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}<font></font>
....</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">csc.exe</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ファイルが</font><font style="vertical-align: inherit;">ないように見えるので（</font><i><font style="vertical-align: inherit;">おそらく</font></i><font style="vertical-align: inherit;">必要なのですが）、</font><font style="vertical-align: inherit;">この段階</font><font style="vertical-align: inherit;">での</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PathToTool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり、現在のメソッド（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToolTask​​.Execute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は実行を終了し、結果は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falseに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なり</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">結果として、結果の条件付きコンパイルシンボルを含むタスクの結果は無視されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">csc.exe</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル</font><font style="vertical-align: inherit;">を予想される場所に</font><font style="vertical-align: inherit;">置いた場合に何が起こるか見てみましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pathToTool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は既存のファイルの実際の場所を示し、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToolTask​​.Execute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドの実行が</font><font style="vertical-align: inherit;">続行されます。</font><font style="vertical-align: inherit;">次の重要なポイントは、</font><i><font style="vertical-align: inherit;">ManagedCompiler.ExecuteTool</font></i><font style="vertical-align: inherit;">メソッドの呼び出しです。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そしてそれは次のように始まります：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ExecuteTool</span><span class="hljs-params">(<span class="hljs-built_in">string</span> pathToTool, 
                                   <span class="hljs-built_in">string</span> responseFileCommands, 
                                   <span class="hljs-built_in">string</span> commandLineCommands)</span>
</span>{
  <span class="hljs-keyword">if</span> (ProvideCommandLineArgs)<font></font>
  {<font></font>
    CommandLineArgs = GetArguments(commandLineCommands, responseFileCommands)<font></font>
      .Select(arg =&gt; <span class="hljs-keyword">new</span> TaskItem(arg)).ToArray();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (SkipCompilerExecution)<font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SkipCompilerExecution</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
プロパティ</font><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trueです</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（論理的には、実際にはコンパイルしていません）。</font><font style="vertical-align: inherit;">その結果、呼び出し側のメソッド（前述の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToolTask​​.Execute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExecuteTool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドの戻りコード</font><font style="vertical-align: inherit;">が0で</font><font style="vertical-align: inherit;">あることを確認し、</font><font style="vertical-align: inherit;">0の場合は、値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trueで</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行を完了し</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">csc.exeの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背後に</font><font style="vertical-align: inherit;">あったものはそこにありました-実際のコンパイラーまたはテキスト形式のLeo Tolstoyの「戦争と平和」は問題ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、主な問題は、ステップのシーケンスが次の順序で定義されているという事実から生じます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラの存在を確認してください。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラを起動する必要があるかどうかを確認します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
逆もまた同様です。コンパイラスタブは、この問題を正常に解決します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、csc.exeファイルが検出されなかった（そしてタスクの結果が無視された）場合、コンパイルの成功の特徴はどのようにして生まれましたか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合のメソッドは</font><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">Microsoft.CodeAnalysis.CSharp</font></i><font style="vertical-align: inherit;">ライブラリの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSharpCommandLineParser.ParseConditionalCompilationSymbols</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。解析は</font><font style="vertical-align: inherit;">、いくつかの区切り文字を使用</font><font style="vertical-align: inherit;">して</font><i><font style="vertical-align: inherit;">String.Split</font></i><font style="vertical-align: inherit;">メソッドによっても実行さ</font><font style="vertical-align: inherit;">れます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">string</span>[] values <font></font>
  = value.Split(<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[] { <span class="hljs-string">';'</span>, <span class="hljs-string">','</span> } <span class="hljs-comment">/*, 
                StringSplitOptions.RemoveEmptyEntries*/</span>);</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Csc.GetDefineConstantsSwitch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
メソッドからの区切り文字のセットとの違いに注意してください</font><font style="vertical-align: inherit;">。この場合、空白はセパレータではありません。したがって、条件付きコンパイル文字がスペースで記述されている場合、このメソッドはそれらを正しく解析しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況は問題のあるプロジェクトで発生しました-条件付きコンパイル文字がスペースで記述されており、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetDefineConstantsSwitch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して正常に解析され</font><i><font style="vertical-align: inherit;">ましたが</font></i><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">ParseConditionalCompilationSymbols</font></i><font style="vertical-align: inherit;">では</font><font style="vertical-align: inherit;">解析され</font><font style="vertical-align: inherit;">ません</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でした</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリを更新した後に明らかになったもう1つの問題は、多くの場合、特に収集されなかったプロジェクトでの動作の低下でした。 Microsoft.CodeAnalysisライブラリで問題が発生し、さまざまな例外の形で返されました-</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArgumentNullException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（一部の内部ロガーは初期化されませんでした）、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下でこれらの問題の1つについてお話ししたいと思います-それは私には非常に興味深いようでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Roslynプロジェクトの最新バージョンをチェックしているときにこの問題が発生しました-いずれかのライブラリのコードから</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceExceptionが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スローされました</font><font style="vertical-align: inherit;">。問題の場所に関する詳細な情報が十分にあったため、問題のコードをすばやく見つけ、Visual Studioで作業しているときに問題が再発するかどうかを確認することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ-それをVisual Studioで再現することは可能でした（実験はVisual Studio 16.0.3で行われました）。これを行うには、次の形式のクラス定義が必要です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C1</span>&lt;T1, T2&gt;
{</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
  </span>{<font></font>
    T1 val = <span class="hljs-keyword">default</span>;
    <span class="hljs-keyword">if</span> (val is null)<font></font>
    { }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、Syntax Visualizer（.NETコンパイラプラットフォームSDKの一部）も必要です。</font><font style="vertical-align: inherit;">タイプ</font><i><font style="vertical-align: inherit;">ConstantPatternSyntax</font></i><font style="vertical-align: inherit;">（</font><i><font style="vertical-align: inherit;">null</font></i><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">構文ツリーのノードから</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeSymbol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（メニュー項目「View TypeSymbol（存在する場合）」）</font><font style="vertical-align: inherit;">をリクエストする必要</font><font style="vertical-align: inherit;">があります</font><font style="vertical-align: inherit;">。その後、Visual Studioが再起動し、イベントビューアで問題に関する情報を確認できます。特に、スタックトレースを確認できます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs">Application: devenv.exe<font></font>
Framework Version: v4<span class="hljs-number">.0</span><span class="hljs-number">.30319</span><font></font>
Description: The process was terminated due to an unhandled exception.<font></font>
Exception Info: System.NullReferenceException<font></font>
   at Microsoft.CodeAnalysis.CSharp.ConversionsBase.<font></font>
        ClassifyImplicitBuiltInConversionSlow(<font></font>
          Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, <font></font>
          Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, <font></font>
          System.Collections.Generic.HashSet<span class="hljs-number">'1</span><font></font>
            &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef)<font></font>
   at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyBuiltInConversion(<font></font>
        Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, <font></font>
        Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, <font></font>
        System.Collections.Generic.HashSet<span class="hljs-number">'1</span><font></font>
          &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef)<font></font>
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoForNode(<font></font>
        Microsoft.CodeAnalysis.CSharp.BoundNode,<font></font>
        Microsoft.CodeAnalysis.CSharp.BoundNode,<font></font>
        Microsoft.CodeAnalysis.CSharp.BoundNode)<font></font>
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker(<font></font>
        Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,<font></font>
        System.Threading.CancellationToken)<font></font>
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker(<font></font>
        Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,<font></font>
        System.Threading.CancellationToken)<font></font>
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(<font></font>
        Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, <font></font>
        System.Threading.CancellationToken)<font></font>
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode(<font></font>
        Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken)<font></font>
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore(<font></font>
        Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken)<font></font>
....</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、問題の原因はnull参照の逆参照です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述のとおり、アナライザーのテスト中に同じ問題が発生しました。 Microsoft.CodeAnalysisデバッグライブラリを使用してアナライザーを構築する</font><font style="vertical-align: inherit;">場合は、構文ツリーの目的のノードから</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeSymbol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">要求することにより、デバッグすることで正確な場所に</font><i><font style="vertical-align: inherit;">到達でき</font></i><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のスタックトレースで言及した</font><i><font style="vertical-align: inherit;">ClassifyImplicitBuiltInConversionSlow</font></i><font style="vertical-align: inherit;">メソッドに到達します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> Conversion <span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span><span class="hljs-params">(
  TypeSymbol source,
  TypeSymbol destination,
  ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span>
</span>{<font></font>
  Debug.Assert((object)source != null);<font></font>
  Debug.Assert((object)destination != null);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (source.SpecialType == SpecialType.System_Void ||<font></font>
      destination.SpecialType == SpecialType.System_Void)<font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> Conversion.NoConversion;<font></font>
  }<font></font>
<font></font>
  Conversion conversion <font></font>
    = ClassifyStandardImplicitConversion(source, destination,<font></font>
                                         ref useSiteDiagnostics);<font></font>
  <span class="hljs-keyword">if</span> (conversion.Exists)<font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> conversion;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> Conversion.NoConversion;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この場合、</font><font style="vertical-align: inherit;">
問題は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宛先</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であること</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">したがって、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destination.SpecialType</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外</font><font style="vertical-align: inherit;">を参照すると</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がスローされ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">はい、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug.Assert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式はdereferencingよりも高いですが</font><font style="vertical-align: inherit;">、実際には何も保護しないため、これは十分ではありません。デバッグバージョンのライブラリで問題を特定するのに役立つだけです。</font><font style="vertical-align: inherit;">または助けにはならない。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++プロジェクトのモデル構築の変更</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで特に興味深いことは何も起こりませんでした。古いアルゴリズムでは、重要な変更を必要としなかったので、話をすると興味深いでしょう。</font><font style="vertical-align: inherit;">たぶん、2つの点に住むことが理にかなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、数値形式で記述されるToolsVersionの値に依存するアルゴリズムを変更する必要がありました。</font><font style="vertical-align: inherit;">詳細には触れませんが、ツールセットを比較して、たとえば、より新しいバージョンを選択する必要がある場合がいくつかあります。</font><font style="vertical-align: inherit;">このバージョンは、それぞれより高い数値を持っていました。</font><font style="vertical-align: inherit;">MSBuild / Visual Studioの新しいバージョンに対応するToolsVersionは16.0になるという計算がありました。</font><font style="vertical-align: inherit;">どのような場合でも...興味を引くために、さまざまなバージョンのVisual Studioでさまざまなプロパティの値がどのように変化したかを表に示します。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visual Studio製品名</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visual Studioのバージョン番号</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツールのバージョン</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlatformToolsetバージョン</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジュアルスタジオ2010</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.0</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.0</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジュアルスタジオ2012</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11.0</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.0</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジュアルスタジオ2013</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12.0</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12.0</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">120</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジュアルスタジオ2015</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14.0</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14.0</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">140</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジュアルスタジオ2017</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.0</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.0</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">141</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジュアルスタジオ2019</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16.0</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電流</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">142</font></font><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、ジョークは時代遅れですが、Microsoftの場合、将来の値の予測（名前、バージョンが何であっても）が不安定であることを理解するために、WindowsとXboxのバージョンの変更について覚えておかなければなりません。</font><font style="vertical-align: inherit;">:) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソリューションは十分にシンプルでした-ツールセットの優先順位付けを導入しました（個別の優先エンティティの割り当て）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のポイントは、Visual Studio 2017または隣接する環境（たとえば、</font><i><font style="vertical-align: inherit;">VisualStudioVersion</font></i><font style="vertical-align: inherit;">環境変数の存在）で作業するときの問題です。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）実際、C ++プロジェクトのモデルを構築するために必要なパラメーターの計算は、.NETプロジェクトのモデルを構築するよりもはるかに複雑です。 .NETの場合、独自のツールセットと対応するToolsVersionの値を使用します。 C ++の場合、システム内に独自のツールセットと既存のツールセットの両方を構築できます。 Visual Studio 2017のビルドツール以降、ツールセットは</font><font style="vertical-align: inherit;">レジストリではなく</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSBuild.exe.config</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルに登録され</font><font style="vertical-align: inherit;">ます。したがって、</font><font style="vertical-align: inherit;">レジストリに記録されているツールセット（&lt;= Visual Studio 2015に対応）とは異なり</font><font style="vertical-align: inherit;">、ツールセットの一般的なリストから（たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.Toolsets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を介して</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">それらを取得することはできません。</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のすべての結果として</font><font style="vertical-align: inherit;">、必要なツールセットがシステムに表示されないため、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToolsVersion 15.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してプロジェクトモデルを構築することはできません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最も関連性の高いツールセット- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -は、これが私たち自身のツールセットであるため、同時に利用可能になります。したがって、Visual Studio 2019にはそのような問題はありません。</font><font style="vertical-align: inherit;">加えて、独自のツールセットのリストへの追加-ソリューションは、シンプルかつプロジェクトモデルを構築するための既存のアルゴリズムを変更することなく、問題を解決することができことが判明</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -別の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.0を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C＃.NET Coreプロジェクトのモデル構築の変更</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタスクのフレームワークでは、2つの問題が関連していることが判明したため、一度に解決されました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'Current'ツールセットを追加した後、Visual Studio 2017の.NET Coreプロジェクトの分析が機能しなくなりました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visual Studioの少なくとも1つのバージョンがインストールされていないシステムでの.NET Coreプロジェクトの分析が機能しませんでした。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どちらの場合も問題は同じでした-基本的な.targets / .propsファイルの一部が間違った方法で検索されました。</font><font style="vertical-align: inherit;">そのため、ツールセットを使用してプロジェクトモデルを構築することはできませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visual Studioがない場合、このようなエラーが表示される可能性があります（以前のバージョンのtoolset'a- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.0を使用</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<pre><code class="cpp hljs">The imported project <span class="hljs-string">"C:\Windows\Microsoft.NET\Framework64\
15.0\Microsoft.Common.props"</span> was <span class="hljs-keyword">not</span> found.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visual Studio 2017でプロジェクトのC＃.NET Coreモデルをビルドすると、次の問題が発生する可能性があります（ツールセットの現在のバージョンである</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Currentを使用</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<pre><code class="cpp hljs">The imported project 
<span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\
2017\Community\MSBuild\Current\Microsoft.Common.props"</span> was <span class="hljs-keyword">not</span> found. <font></font>
....</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は似ていますが（そのように見えます）、1つの石で2羽の鳥を殺そうとすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下では、技術的な詳細に触れずに、この問題がどのように解決されたかを説明します。これらの詳細（C＃.NET Coreプロジェクトのモデルの構築、およびツールセットでの構築モデルの変更について）は、今後の記事の1つで待っています。ちなみに、上記のテキストを注意深く読むと、これが将来の記事への2番目の参照であることに気付くでしょう。 :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、どのようにこの問題を解決しましたか？解決策は、.NET Core SDKのメインの.targets / .propsファイル（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sdk.props</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">Sdk.targets）を</font></i><font style="vertical-align: inherit;">犠牲にして独自のツールセットを拡張すること</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でした。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">これにより、状況をより詳細に制御できるようになり、インポートの管理や、一般的な.NET Coreプロジェクトのモデルの構築における柔軟性が高まりました。</font><font style="vertical-align: inherit;">はい、ツールセットは少し成長しました。また、.NET Coreモデルを構築するために必要な環境プロジェクトをセットアップするためのロジックも追加する必要がありましたが、それだけの価値があるようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は、.NET Coreプロジェクトのモデルを構築するときの作業の原則は次のとおりでした。この構築を要求するだけで、すべてがMSBuildを犠牲にして機能しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、私たちが自分の手でより多くの制御を取っているとき、それは少し異なって見えます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Coreプロジェクトのモデルを構築するために必要な環境の準備。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデル構築：</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツールセットの.targets / .propsファイルを使用して構築を開始します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外部ファイルを使用した継続的な構築。</font></font></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の手順から、必要な環境の設定には2つの主な目的があることは明らかです。</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自のツールセットの.targets / .propsファイルを使用してモデルの構築を開始します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以降の操作を外部の.targets / .propsファイルにリダイレクトします。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET Coreプロジェクトのモデルの構築に必要な.targets / .propsファイルを検索するには、特別なライブラリーMicrosoft.DotNet.MSBuildSdkResolverを使用します。</font><font style="vertical-align: inherit;">ツールセットのファイルを使用したビルドの開始は、このライブラリで使用される特別な環境変数を使用することで解決されました-（ツールセットから）必要なファイルをインポートする場所を提案します。</font><font style="vertical-align: inherit;">ライブラリは私たちのディストリビューションの一部なので、ロジックが突然変更されて動作しなくなる恐れはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、Sdkファイルが最初にツールセットからインポートされ、簡単に変更できるため、モデルを構築するためのさらなるロジックの制御が手に入ります。</font><font style="vertical-align: inherit;">したがって、どのファイルをどこからインポートする必要があるかを自分で判断できます。</font><font style="vertical-align: inherit;">これは、上記のMicrosoft.Common.propsにも適用されます。</font><font style="vertical-align: inherit;">このファイルとその他の基本的なファイルは、可用性とコンテンツに自信を持って独自のツールセットからインポートします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、必要なインポートを完了し、いくつかのプロパティを設定したら、モデル構築のさらなる制御を実際の.NET Core SDKに移し、そこで残りの必要なアクションを実行します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、Visual Studio 2019のサポートは、Visual Studio 2017のサポートよりも簡単になりました。これは、私の考えでは、いくつかの要因によるものです。まず、MicrosoftはVisual Studio 2015とVisual Studio 2017の間でそれほど多くのことを変更しませんでした。はい、メインツールセットを変更し、非同期でVisual Studioのプラグインを方向付け始めましたが、それでもなおです。もう1つは、独自のツールセットとビルドプロジェクトモデルを使ってすでにソリューションを準備していたことです。もう一度すべてを発明する必要はなく、既存のソリューションを拡張するだけで十分でした。プロジェクトモデル構築システムの拡張による、.NET Coreプロジェクトの新しい条件の分析（およびVisual Studioインスタンスがインストールされていないマシンでの分析のケース）に対する比較的単純なサポートも、正しい選択をしたことを期待しています。自分を管理することにした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それでも、前回の記事にあった1つの考えをもう一度繰り返したいと思います。既製のソリューションを使用することは、一見したように簡単ではない場合があります。</font></font><br>
<br>
<p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事を英語を話す視聴者と共有したい場合は、翻訳へのリンクを使用してください：セルゲイヴァシリエフ。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-StudioでのVisual Studio 2019のサポート</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja454716/index.html">従業員は新しいソフトウェアを望んでいません-時々行くか、彼らの線を曲げますか？</a></li>
<li><a href="../ja454720/index.html">ドキュメントを復活させる方法は？</a></li>
<li><a href="../ja454728/index.html">インターネットアクセスオープン：視覚障害者を支援するLUWRAINテクノロジー</a></li>
<li><a href="../ja454730/index.html">Allure Serverミートアップ：レポートのビデオ録画</a></li>
<li><a href="../ja454734/index.html">バックアップ、パート4：zbackup、restic、borgbackupの概要とテスト</a></li>
<li><a href="../ja454740/index.html">2019年5月Joomlaダイジェスト</a></li>
<li><a href="../ja454742/index.html">あなたが知らなかった少なくとも1つのVimトリック</a></li>
<li><a href="../ja454744/index.html">RigaDevDaysカンファレンスからのJava Trackレポートの概要</a></li>
<li><a href="../ja454748/index.html">MongoDBサバイバルガイド</a></li>
<li><a href="../ja454750/index.html">Swift UI-ヨーロッパ中を駆け巡る</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>