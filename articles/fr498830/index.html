<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😌 🉑 🈂️ Hash + cache: optimisation du traitement des flux 🌡️ 🎡 👩‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Que dois-je faire si je veux écrire beaucoup de «faits» dans la base de données d'un volume beaucoup plus important qu'il ne peut en supporter? Tout d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Hash + cache: optimisation du traitement des flux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/498830/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que dois-je faire si je veux écrire beaucoup de «faits» dans la base de données d'un volume beaucoup plus important qu'il ne peut en supporter? Tout d'abord, bien sûr, nous amenons les données sous une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forme normale</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plus économique </font><font style="vertical-align: inherit;">et obtenons des «dictionnaires», que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous écrirons une fois</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mais comment le faire le plus efficacement possible? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est exactement la question à laquelle nous avons été confrontés lors du développement de la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">surveillance et de l'analyse des journaux du serveur PostgreSQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lorsque d'autres </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthodes d'optimisation de l'enregistrement dans la base de données</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ont été épuisées.</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/0y/34/cp/0y34cps5t4nqozitxa0xb7urypm.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous </font><font style="vertical-align: inherit;">
réserverons immédiatement que nos collecteurs exécutent </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous n'interagissons donc en aucune façon avec les registres et les caches de processeur. </font><font style="vertical-align: inherit;">Et l'option d'utiliser "cent" ou des services / bases de données de mise en cache externes donne trop de retard pour </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les flux entrants de plusieurs centaines de Mbps</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, nous essayons de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tout mettre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en </font><b><font style="vertical-align: inherit;">cache dans la RAM</font></b><font style="vertical-align: inherit;"> , en particulier dans la mémoire du processus JavaScript. </font><font style="vertical-align: inherit;">Comment organiser cela plus efficacement, et nous irons plus loin.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mise en cache de la disponibilité</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre tâche principale est de nous assurer que la seule instance d'un objet pénètre dans la base de données. Ce sont les textes originaux répétés à plusieurs reprises des requêtes SQL, les modèles de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plans pour leur mise en œuvre</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , les nœuds de ces plans - en bref, certains </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blocs de texte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Historiquement, comme identifiant, nous avons utilisé une </font></font><code>UUID</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur-, qui a été obtenue à la suite du calcul direct du </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hachage MD5 à</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> partir du texte de l'objet. Après cela, nous vérifions la disponibilité d'un tel hachage dans le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"dictionnaire"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> local </font><b><font style="vertical-align: inherit;">dans la mémoire de processus</font></b><font style="vertical-align: inherit;"> , et s'il n'est pas là, alors seulement nous écrivons dans la base de données dans la table "dictionnaire".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, nous n'avons pas besoin de stocker la valeur de texte d'origine elle-même (et cela prend parfois des dizaines de kilo-octets) - le simple </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fait de la présence du hachage correspondant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans le dictionnaire </font><font style="vertical-align: inherit;">suffit </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dictionnaire clé</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un tel dictionnaire peut être conservé </font></font><code>Array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et utilisé </font></font><code>Array.includes()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour vérifier la disponibilité, mais cela est assez redondant - la recherche se dégrade (au moins dans les versions précédentes de V8) de façon linéaire par rapport à la taille du tableau, O (N). </font><font style="vertical-align: inherit;">Et dans les implémentations modernes, malgré toutes les optimisations, il perd à une vitesse de 2-3%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, dans l'ère pré-ES6, le stockage était la solution traditionnelle </font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, avec des valeurs stockées comme clés. </font><font style="vertical-align: inherit;">Mais tout le monde a attribué aux valeurs des clés ce qu'il voulait - par exemple </font></font><code>Boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> dict = {};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">has</span>(<span class="hljs-params">key</span>) </span>{
  <span class="hljs-keyword">return</span> dict[key] !== <span class="hljs-literal">undefined</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">key</span>) </span>{<font></font>
  dict[key] = <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il est bien évident que nous stockons clairement l'excédent ici - la valeur même de la clé dont personne n'a besoin. Mais que se passe-t-il s'il n'est pas stocké du tout? Ainsi, l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objet Set</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est apparu </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les tests montrent que la recherche avec aide est </font></font><code>Set.has()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">environ 20-25% plus rapide que la vérification des clés c </font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mais ce n'est pas son seul avantage. Étant donné que nous stockons moins, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous devons donc avoir besoin de moins de mémoire</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - et cela affecte directement les performances en ce qui concerne des centaines de milliers de ces clés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, </font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans laquelle il y a 100 clés UUID dans une représentation de texte, il occupe </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6216 octets</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en mémoire </font><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1e/n6/ge/1en6gefozucw86wki6odp-j3ria.png"><br>
<br>
<code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec le même contenu - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2632 octets</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/59/cb/ri59cbgqbmmbqhivlopro2gspuu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, il </font></font><code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonctionne plus rapidement et prend en même temps</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,5 fois moins de mémoire</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - le gagnant est évident.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous optimisons le stockage des clés UUID</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, dans la nature des systèmes distribués, les clés UUID sont assez courantes - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans notre VLSI,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elles sont, au minimum, utilisées pour identifier les documents et les réglementations dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la gestion électronique des documents</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , les personnes dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">messagerie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, regardons de plus près l'image ci-dessus - chaque UUID est la clé stockée dans la représentation hexadécimale "nous coûte" </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">56 octets de mémoire</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mais nous en avons des centaines de milliers, il est donc raisonnable de demander: "Est-il possible d'en avoir moins?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, rappelez-vous que l'UUID est un identifiant de 16 octets. Essentiellement un morceau de données binaires. Et pour la transmission par e-mail, par exemple, les données binaires sont encodées en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base64</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - essayez de les appliquer:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> str = Buffer.from(uuidstr, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'base64'</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/pd/jc/ks/pdjckslsoycw92xnx4moahgmweg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Déjà 48 octets chacun est mieux, mais imparfait. </font><font style="vertical-align: inherit;">Essayons de traduire la représentation hexadécimale directement en chaîne:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> str = Buffer.from(uuidstr, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'binary'</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/6i/nn/_5/6inn_5k8y3pnogatsv-r5ntrdzo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu de 56 octets par clé - 40 octets, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">économisez près de 30%</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maître, travailleur - où stocker les dictionnaires?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérant que les données de vocabulaire des travailleurs se croisent assez fortement, nous avons fait le stockage des dictionnaires et les écrire dans la base de données dans le processus maître, et le transfert des données des travailleurs via </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le mécanisme de message IPC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, une grande partie du temps du maître a été consacrée à </font></font><code>channel.onread</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- c'est-à-dire au traitement de la réception des paquets contenant des informations de "dictionnaire" provenant des processus enfants:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/kr/nr/sdkrnrm1c_amswktwm57kl3qsfo.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barrière d'écriture à double réglage</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Réfléchissons maintenant une seconde - les travailleurs envoient et envoient au maître les mêmes données de vocabulaire (fondamentalement, ce sont les modèles de plan et les corps de demande répétitifs), il les analyse avec sa sueur et ... ne fait rien, car ils ont déjà été envoyés à la base de données avant ! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, si nous </font></font><code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«protégions» la base de données du réenregistrement du maître avec un dictionnaire, pourquoi ne pas utiliser la même approche pour «protéger» le maître du transfert du travailleur? .. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, cela a été fait et a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">réduit les coûts directs de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> maintenance du canal d'échange à </font><b><font style="vertical-align: inherit;">trois reprises.</font></b><font style="vertical-align: inherit;"> : </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y1/h4/aj/y1h4ajs-o3hdg1xfoyf9j_kflpc.png"><br>
<br>
<img src="https://habrastorage.org/webt/vl/be/na/vlbenalj_sd_2jk36xdkhaouhp8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais maintenant, les travailleurs semblent faire plus de travail - stocker des dictionnaires et filtrer par eux? </font><font style="vertical-align: inherit;">Ou pas? .. En fait, ils ont commencé à travailler beaucoup moins, car le transfert de gros volumes (même via IPC!) N'est pas bon marché.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/dz/7k/mb/dz7kmbdj5jnirhajahmwrpcwzfw.png"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bon bonus</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors que l'assistant commençait maintenant à recevoir une quantité d'informations beaucoup plus petite, il a commencé à allouer beaucoup moins de mémoire à ces conteneurs - ce qui signifie que le temps consacré au travail du garbage collector a considérablement diminué, ce qui a eu une incidence positive sur la latence du système dans son ensemble.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fg/af/el/fgafel26_6der0h-knhglqckt8k.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un tel système offre une protection contre les entrées répétées au niveau du collecteur, mais que faire si nous avons plusieurs collecteurs? </font><font style="vertical-align: inherit;">Seul le déclencheur avec vous aidera ici </font></font><code>INSERT ... ON CONFLICT DO NOTHING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accélérez le calcul du hachage</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre architecture, l'intégralité du flux de journaux d'un serveur PostgreSQL est traité par un seul travailleur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, un serveur est une tâche pour le travailleur. Dans le même temps, le chargement des travailleurs est équilibré par le but des tâches du serveur, de sorte que la consommation de CPU par les travailleurs de tous les collecteurs est approximativement la même. Il s'agit d'un répartiteur de services distinct. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
«En moyenne», chaque travailleur gère des dizaines de tâches qui produisent approximativement la même charge totale. Cependant, il existe des serveurs qui dépassent considérablement les autres en termes de nombre d'entrées de journal. Et même si le répartiteur laisse cette tâche la seule sur le travailleur, son téléchargement est beaucoup plus élevé que les autres:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/p1/9a/olp19ahpqzn4e5aaek0oyg1tjt0.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons supprimé le profil CPU de ce travailleur: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2q/zk/fs/2qzkfsaqceti_tietxizjhfmioi.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur les premières lignes, le calcul des hachages MD5. </font><font style="vertical-align: inherit;">Et ils sont vraiment calculés en quantité énorme - pour l'ensemble du flux d'objets entrants.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxHash</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment optimiser cette partie, hormis ces hachages, on ne peut pas? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons décidé d'essayer une autre fonction de hachage - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxHash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui implémente </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un algorithme de hachage non cryptographique extrêmement rapide</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Et le module pour Node.js est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxhash-addon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui utilise la dernière bibliothèque xxHash 0.7.3 avec le nouvel algorithme XXH3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vérifiez en exécutant chaque option sur un ensemble de lignes de différentes longueurs:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> { XXHash3, XXHash64 } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'xxhash-addon'</span>);
<span class="hljs-keyword">const</span> hasher3 = <span class="hljs-keyword">new</span> XXHash3(<span class="hljs-number">0xDEADBEAF</span>);
<span class="hljs-keyword">const</span> hasher64 = <span class="hljs-keyword">new</span> XXHash64(<span class="hljs-number">0xDEADBEAF</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> getBinFromHash = <span class="hljs-function">(<span class="hljs-params">hash</span>) =&gt;</span> buf.fill(hash, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'binary'</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> funcs = {
  <span class="hljs-attr">xxhash64</span> : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> hasher64.hash(Buffer.from(str)).toString(<span class="hljs-string">'binary'</span>)<font></font>
, <span class="hljs-attr">xxhash3</span>  : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> hasher3.hash(Buffer.from(str)).toString(<span class="hljs-string">'binary'</span>)<font></font>
, <span class="hljs-attr">md5</span>      : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> getBinFromHash(crypto.createHash(<span class="hljs-string">'md5'</span>).update(str).digest(<span class="hljs-string">'hex'</span>))<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">const</span> check = <span class="hljs-function">(<span class="hljs-params">hash</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> log = [];
  <span class="hljs-keyword">let</span> cnt = <span class="hljs-number">10000</span>;
  <span class="hljs-keyword">while</span> (cnt--) log.push(crypto.randomBytes(cnt).toString(<span class="hljs-string">'hex'</span>));<font></font>
<font></font>
  <span class="hljs-built_in">console</span>.time(hash);<font></font>
  log.forEach(funcs[hash]);<font></font>
  <span class="hljs-built_in">console</span>.timeEnd(hash);<font></font>
};<font></font>
<font></font>
<span class="hljs-built_in">Object</span>.keys(funcs).forEach(check);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Résultats:</font></font><br>
<pre><code class="plaintext hljs">xxhash64 : 148.268ms<font></font>
xxhash3  : 108.337ms<font></font>
md5      : 317.584ms<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prévu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , xxhash3 était </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beaucoup plus rapide que MD5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reste à vérifier la résistance aux collisions. </font><font style="vertical-align: inherit;">Des sections de tables de dictionnaires sont créées chaque jour pour nous, donc en dehors des limites de la journée, nous pouvons en toute sécurité permettre l'intersection des hachages. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais juste au cas où, nous avons vérifié avec une marge dans l'intervalle de trois jours - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas un seul conflit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui nous convient plus que suffisant.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remplacement de hachage</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/rz/ga/3drzgasyjhevujtp-etsjcwlnz8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais nous ne pouvons tout simplement pas prendre et échanger d'anciens champs UUID dans les tables de dictionnaire pour un nouveau hachage, car la base de données et le frontend existant attendent que les objets continuent d'être identifiés par UUID. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, nous ajouterons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un cache supplémentaire</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au collecteur </font><font style="vertical-align: inherit;">- pour MD5 déjà calculé. Maintenant, ce sera une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dans laquelle les clés sont xxhash3, les valeurs sont MD5. Pour des lignes identiques, nous ne recomptons pas le MD5 «cher», mais le prenons dans le cache:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> getHashFromBin = <span class="hljs-function">(<span class="hljs-params">bin</span>) =&gt;</span> Buffer.from(bin, <span class="hljs-string">'binary'</span>).toString(<span class="hljs-string">'hex'</span>);
<span class="hljs-keyword">const</span> dictmd5 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
<span class="hljs-keyword">const</span> getmd5 = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> hash = xxhash(data);
  <span class="hljs-keyword">let</span> md5hash = dictmd5.get(hash);
  <span class="hljs-keyword">if</span> (!md5hash) {<font></font>
    md5hash = md5(data);<font></font>
    dictmd5.set(hash, getBinFromHash(md5hash));<font></font>
    <span class="hljs-keyword">return</span> md5hash;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> getHashFromBin(md5hash);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous supprimons le profil - la fraction du temps de calcul des hachages a considérablement diminué, bravo! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/el/5q/ce/el5qcei3ahbakyyerswutw2rulk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors maintenant, nous comptons xxhash3, puis vérifions le cache MD5 et obtenons le MD5 souhaité, puis vérifions le cache du dictionnaire - si ce md5 n'est pas là, envoyez-le à la base de données pour l'écriture. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelque chose de trop de vérifications ... Pourquoi vérifier le cache du dictionnaire si vous avez déjà vérifié le cache MD5? </font><font style="vertical-align: inherit;">Il s'avère que tous les caches de dictionnaire ne sont plus nécessaires et il suffit d'avoir un seul cache - pour MD5, avec lequel toutes les opérations de base seront effectuées: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wl/e_/uc/wle_ucs0o22wpxmrjlg_2sokzvm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conséquence, nous avons remplacé l'archivage dans plusieurs dictionnaires «objet» par un seul cache MD5, et l'opération gourmande en ressources du calcul de MD5 est Le hachage est effectué uniquement pour les nouvelles entrées, en utilisant le xxhash beaucoup plus efficace pour le flux entrant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
remercier</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kilor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour vous aider à préparer l'article.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr498814/index.html">Vous avez échoué une question théorique sur la sécurité sociale, et ils ont mis fin à vous. C'est normal? // Nous sommes condamnés # 3</a></li>
<li><a href="../fr498816/index.html">La vérité tout d'abord, ou pourquoi le système doit être conçu en fonction du périphérique de base de données</a></li>
<li><a href="../fr498820/index.html">Quelques questions plus délicates sur .NET et C #</a></li>
<li><a href="../fr498826/index.html">SIL et Salesforce</a></li>
<li><a href="../fr498828/index.html">Comment le sel de table et les protéines augmenteront la survie des implants</a></li>
<li><a href="../fr498832/index.html">Présentation des possibilités de Qt Creator 4.12 et QBS 1.16 pour la programmation de microcontrôleurs</a></li>
<li><a href="../fr498834/index.html">33 mitaps en ligne de la semaine. Choisissez-en un ou ayez du temps pour tout?</a></li>
<li><a href="../fr498836/index.html">[Infographie] Les 50 meilleures franchises de jeux avec des revenus de plus d'un milliard</a></li>
<li><a href="../fr498840/index.html">Le bot surveille et contrôle l'ordinateur via des télégrammes</a></li>
<li><a href="../fr498842/index.html">Modération des commentaires: Et pourtant, peut-on faire confiance aux utilisateurs?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>