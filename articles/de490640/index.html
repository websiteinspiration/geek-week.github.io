<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🔬 🤛🏿 😓 Überladen in C ++. Teil III. Überladen neuer / Löschanweisungen ⚓️ 🤰🏽 👴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir setzen die Serie "C ++, Graben in die Tiefe" fort. Der Zweck dieser Reihe ist es, so viel wie möglich über die verschiedenen Merkmale der Sprache ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Überladen in C ++. Teil III. Überladen neuer / Löschanweisungen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490640/"><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir setzen die Serie "C ++, Graben in die Tiefe" fort. </font><font style="vertical-align: inherit;">Der Zweck dieser Reihe ist es, so viel wie möglich über die verschiedenen Merkmale der Sprache zu erzählen, möglicherweise ganz besonders. </font><font style="vertical-align: inherit;">In diesem Artikel geht es um das Überladen von Bedienern </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist der dritte Artikel in der Reihe, der erste für Überladungsfunktionen und -vorlagen, der sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier befindet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der zweite für Überladungsoperatoren, der sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier befindet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dieser Artikel schließt eine Serie mit drei Artikeln zum Überladen in C ++ ab.</font></font><br>
<hr><a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhaltsverzeichnis</font></font></h1><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhaltsverzeichnis</font></font></b><div class="spoiler_text">&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.    new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.1.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.3.     </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.1.     </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.1.      new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.3.  </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.4. </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.5.    operator delete()</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.   new/delete</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.    </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. -  </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a><br>
</div></div><br>
<a name="id-1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Standardformulare für neue / gelöschte Operatoren</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ unterstützt mehrere Operatoroptionen </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie können in Basisstandard, Zusatzstandard und Benutzerdefiniert unterteilt werden. </font><font style="vertical-align: inherit;">In diesem Abschnitt und Abschnitt 2 werden Standardformulare erläutert. Benutzerdefinierte Formulare werden in Abschnitt 3 erläutert.</font></font><br>
<br>
<a name="id-1-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1. </font><font style="vertical-align: inherit;">Grundlegende Standardformulare</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die wichtigsten Standardformen von Operatoren, </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die beim Erstellen und Löschen eines Objekts und eines Arrays des Typs verwendet werden, sind </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folgende:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span> T[<span class="hljs-comment">/*   */</span>]
<span class="hljs-keyword">delete</span> ptr;
<span class="hljs-keyword">delete</span>[] ptr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ihre Arbeit kann wie folgt beschrieben werden. Wenn der Operator aufgerufen wird </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird dem Objekt zuerst Speicher zugewiesen. Wenn die Auswahl erfolgreich ist, wird der Konstruktor aufgerufen. Wenn der Konstruktor eine Ausnahme auslöst, wird der zugewiesene Speicher freigegeben. Wenn der Operator aufgerufen wird, </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geschieht alles in umgekehrter Reihenfolge: Zuerst wird der Destruktor aufgerufen, dann wird der Speicher freigegeben. Der Destruktor sollte keine Ausnahmen auslösen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Bediener</font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Erstellen eines Arrays von Objekten wird zunächst Speicher für das gesamte Array zugewiesen. Wenn die Auswahl erfolgreich ist, wird der Standardkonstruktor (oder ein anderer Konstruktor, wenn es einen Initialisierer gibt) für jedes Element des Arrays ab Null aufgerufen. Wenn ein Konstruktor eine Ausnahme auslöst, wird für alle erstellten Elemente des Arrays der Destruktor in der umgekehrten Reihenfolge des Konstruktoraufrufs aufgerufen, und der zugewiesene Speicher wird freigegeben. Um ein Array zu löschen, müssen Sie den Operator aufrufen. </font></font><code>delete[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für alle Elemente des Arrays wird der Destruktor in umgekehrter Reihenfolge wie der Konstruktor aufgerufen. Anschließend wird der zugewiesene Speicher freigegeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachtung! Es ist notwendig, die richtige Form des Bedieners aufzurufen</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abhängig davon, ob ein einzelnes Objekt oder ein Array gelöscht wird. Diese Regel muss strikt eingehalten werden, sonst kann es zu undefiniertem Verhalten kommen, dh es kann alles passieren: Speicherlecks, Absturz usw. Siehe [Meyers1] für Details. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der obigen Beschreibung ist eine Klarstellung erforderlich. Für die sogenannten Trivialtypen (eingebaute Typen, Strukturen im C-Stil) darf der Standardkonstruktor nicht aufgerufen werden, und der Destruktor tut auf keinen Fall etwas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Standardspeicherzuweisungsfunktionen lösen eine Typausnahme aus, wenn die Anforderung nicht erfüllt werden kann </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Diese Ausnahme kann jedoch abgefangen werden. Dazu müssen Sie einen globalen Interceptor mithilfe eines Funktionsaufrufs installieren. </font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Informationen finden Sie unter [Meyers1]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede Form von Operator</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sicher auf Nullzeiger anwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Erstellen eines Arrays mit einem Operator kann die </font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Größe auf Null gesetzt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beide Formen des Operators </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ermöglichen die Verwendung von Initialisierern in geschweiften Klammern.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>{<span class="hljs-number">42</span>}
<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>]{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}</code></pre><br>
<a name="id-1-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2. </font><font style="vertical-align: inherit;">Zusätzliche Standardformulare</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Verbinden der Header-Datei </font></font><code>&lt;new&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stehen 4 weitere Standardoperatorformulare zur Verfügung </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(ptr) T(<span class="hljs-comment">/*  */</span>);
<span class="hljs-keyword">new</span>(ptr) T[<span class="hljs-comment">/*   */</span>];
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T(<span class="hljs-comment">/*   */</span>);
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T[<span class="hljs-comment">/*   */</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten beiden werden als </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht zuweisende Platzierung bezeichnet </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ein Argument </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist ein Zeiger auf einen Speicherbereich, der groß genug ist, um eine Instanz oder ein Array aufzunehmen. Außerdem muss der Speicherbereich eine geeignete Ausrichtung haben. Diese Version des Operators </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weist keinen Speicher zu, sondern ruft nur den Konstruktor auf. Mit dieser Option können Sie die Phasen der Speicherzuweisung und Initialisierung von Objekten trennen. Diese Funktion wird in Standardcontainern aktiv verwendet. Der Operator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für auf diese Weise erstellte Objekte kann natürlich nicht aufgerufen werden. Um ein Objekt zu löschen, müssen Sie den Destruktor direkt aufrufen und dann den Speicher auf eine Weise freigeben, die von der Methode zum Zuweisen von Speicher abhängt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweiten beiden Optionen werden als Operator bezeichnet, der keine Ausnahmen </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auslöst (nothrow </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Sie unterscheiden sich darin, dass sie zurückkehren </font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber keine </font><font style="vertical-align: inherit;">Typausnahme auslösen </font><font style="vertical-align: inherit;">, wenn die Anforderung nicht erfüllt werden kann </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das Löschen eines Objekts erfolgt mit dem Hauptoperator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Optionen gelten als veraltet und werden nicht zur Verwendung empfohlen.</font></font><br>
<br>
<a name="id-1-3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3. </font><font style="vertical-align: inherit;">Speicherzuordnung und freie Funktionen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standardformen von Operatoren </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwenden die folgenden Zuordnungs- und Freigabefunktionen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktionen werden im globalen Namespace definiert. </font><font style="vertical-align: inherit;">Die Speicherzuweisungsfunktionen für die Host-Anweisungen </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bewirken nichts und kehren einfach zurück </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17 unterstützte zusätzliche Formen von Speicherzuweisungs- und Freigabefunktionen, die auf die Ausrichtung hinweisen. </font><font style="vertical-align: inherit;">Hier sind einige davon:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Formulare sind für den Benutzer nicht direkt zugänglich. Sie werden vom Compiler für Objekte verwendet, deren Ausrichtungsanforderungen überlegen </font></font><code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sind. Das Hauptproblem besteht also darin, dass der Benutzer sie nicht versehentlich ausblendet (siehe Abschnitt 2.2.1). </font><font style="vertical-align: inherit;">Denken Sie daran, dass es in C ++ 11 möglich wurde, die Ausrichtung von Benutzertypen explizit festzulegen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct <span class="hljs-title">alignas</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span> X </span>{ <span class="hljs-comment">/* ... */</span> };</code></pre><br>
<a name="id-2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Überladen der Standardformulare für neue / gelöschte Operatoren</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Überladen der Standardformen von Operatoren </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besteht darin, benutzerdefinierte Funktionen zum Zuweisen und Freigeben von Speicher zu definieren, deren Signaturen mit den Standardsignaturen übereinstimmen. </font><font style="vertical-align: inherit;">Diese Funktionen können im globalen Namespace oder in einer Klasse definiert werden, jedoch nicht in einem anderen als dem globalen Namespace. </font><font style="vertical-align: inherit;">Die Speicherzuweisungsfunktion für eine Standardhostanweisung </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann nicht im globalen Namespace definiert werden. </font><font style="vertical-align: inherit;">Nach einer solchen Definition werden sie von den entsprechenden Operatoren </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet, nicht von den Standardoperatoren.</font></font><br>
<br>
<a name="id-2-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1. </font><font style="vertical-align: inherit;">Überladung im globalen Namespace</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, in einem Modul in einem globalen Namespace werden benutzerdefinierte Funktionen definiert:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
</span>{
<span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall werden die Standardfunktionen zum Zuweisen und Freigeben von Speicher für alle Operatoraufrufe </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für alle Klassen (einschließlich Standardklassen) im gesamten Modul </font><font style="vertical-align: inherit;">tatsächlich ersetzt ( </font><font style="vertical-align: inherit;">ersetzt). Dies kann zu völligem Chaos führen. Beachten Sie, dass der beschriebene Substitutionsmechanismus ein spezieller Mechanismus ist, der nur für diesen Fall implementiert ist, und kein allgemeiner C ++ - Mechanismus. In diesem Fall wird es beim Implementieren der Benutzerfunktionen zum Zuweisen und Freigeben von Speicher unmöglich, die entsprechenden Standardfunktionen aufzurufen. Sie sind vollständig ausgeblendet (der Operator </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hilft nicht), und wenn Sie versuchen, sie aufzurufen, erfolgt ein rekursiver Aufruf der Benutzerfunktion. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Globale Namespace-definierte Funktion</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird auch das Standardproblem ersetzen, es treten jedoch weniger potenzielle Probleme auf, da der Operator, der keine Ausnahmen </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auslöst, selten verwendet wird. </font><font style="vertical-align: inherit;">Das Standardformular ist aber auch nicht verfügbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die gleiche Situation mit Funktionen für Arrays. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Überladen von Anweisungen </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im globalen Namespace wird dringend empfohlen.</font></font><br>
<br>
<a name="id-2-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2. </font><font style="vertical-align: inherit;">Klassenüberlastung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Überladen von Operatoren </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einer Klasse weist keine der oben beschriebenen Nachteile auf. </font><font style="vertical-align: inherit;">Das Überladen ist nur beim Erstellen und Löschen von Instanzen der entsprechenden Klasse wirksam, unabhängig vom Kontext des Aufrufs von Operatoren </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bei der Implementierung benutzerdefinierter Funktionen zum Zuweisen und Freigeben von Speicher mithilfe des Operators können </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie auf die entsprechenden Standardfunktionen zugreifen. </font><font style="vertical-align: inherit;">Betrachten Sie ein Beispiel.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span>
{</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete\n"</span>;<font></font>
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new[]\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete[]\n"</span>;<font></font>
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](ptr);<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel wird die Ablaufverfolgung einfach zu Standardoperationen hinzugefügt. </font><font style="vertical-align: inherit;">Nun, in Bezug auf </font></font><code>new X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>new X[N]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird diese Funktionen verwenden, um Speicher zuzuweisen und freizugeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktionen sind formal statisch und können als deklariert werden </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Im Wesentlichen handelt es sich jedoch um eine Instanz. Mit dem Funktionsaufruf </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beginnt die Erstellung der Instanz, und der Aufruf der Funktion </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schließt das Löschen ab. </font><font style="vertical-align: inherit;">Diese Funktionen werden niemals für andere Aufgaben aufgerufen. </font><font style="vertical-align: inherit;">Darüber hinaus ist die Funktion, wie nachstehend gezeigt wird, im </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wesentlichen virtuell. </font><font style="vertical-align: inherit;">Es ist also richtiger, sie ohne zu deklarieren </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1. </font><font style="vertical-align: inherit;">Zugriff auf Standardformulare für neue / gelöschte Operatoren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operatoren </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">können beispielsweise mit einem zusätzlichen Operator für die Bereichsauflösung verwendet werden </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In diesem Fall wird die </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Klasse definierte </font><font style="vertical-align: inherit;">Funktion </font><font style="vertical-align: inherit;">ignoriert und der entsprechende Standard verwendet. </font><font style="vertical-align: inherit;">Auf die gleiche Weise können Sie den Operator verwenden </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2. </font><font style="vertical-align: inherit;">Andere Formen von Neu- / Löschoperatoren ausblenden</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">jetzt für die Klasse </font><font style="vertical-align: inherit;">versuchen, Ausnahmen zu werfen oder nicht zu werfen </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, erhalten wir eine Fehlermeldung. </font><font style="vertical-align: inherit;">Tatsache ist, dass die Funktion </font></font><code>operator new(std::size_t size)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere Formen verbirgt </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das Problem kann auf zwei Arten gelöst werden. </font><font style="vertical-align: inherit;">Im ersten Schritt müssen Sie der Klasse die entsprechenden Optionen hinzufügen (diese Optionen sollten einfach die Operation der Standardfunktion delegieren). </font><font style="vertical-align: inherit;">Im zweiten Fall müssen Sie beispielsweise einen Operator </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem Operator für die Bereichsauflösung verwenden </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3. </font><font style="vertical-align: inherit;">Standardbehälter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir beispielsweise versuchen, die Instanzen </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einem Standardcontainer zu platzieren </font></font><code>std::vector&lt;X&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, werden wir feststellen, dass unsere Funktionen nicht zum Zuweisen und Freigeben von Speicher verwendet werden. </font><font style="vertical-align: inherit;">Tatsache ist, dass alle Standardcontainer über einen eigenen Mechanismus zum Zuweisen und Freigeben von Speicher verfügen (eine spezielle Allokatorklasse, die ein Vorlagenparameter des Containers ist) und einen Platzierungsoperator zum Initialisieren der Elemente verwenden </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.4. </font><font style="vertical-align: inherit;">Erbe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionen zum Zuweisen und Freigeben von Speicher werden vererbt. Wenn diese Funktionen in der Basisklasse definiert sind, jedoch nicht in der abgeleiteten, werden die Operatoren für die abgeleitete Klasse überladen </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die in der Basisklasse definierten und zugewiesenen Funktionen werden zum Zuweisen und Freigeben von Speicher verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie nun eine polymorphe Klassenhierarchie, in der jede Klasse Operatoren überlastet </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lassen Sie nun die Instanz der abgeleiteten Klasse mit dem Operator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">über einen Zeiger auf die Basisklasse </font><font style="vertical-align: inherit;">löschen </font><font style="vertical-align: inherit;">. Wenn der Destruktor der Basisklasse virtuell ist, garantiert der Standard, dass der Destruktor dieser abgeleiteten Klasse aufgerufen wird. In diesem Fall </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist auch der für diese abgeleitete Klasse definierte </font><font style="vertical-align: inherit;">Funktionsaufruf garantiert </font><font style="vertical-align: inherit;">. Somit ist die Funktion </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tatsächlich virtuell.</font></font><br>
<br>
<a name="id-2-2-5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.5. </font><font style="vertical-align: inherit;">Alternative Form der Operator-Funktion delete ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einer Klasse (insbesondere wenn Vererbung verwendet wird) ist es manchmal zweckmäßig, eine alternative Form der Funktion zu verwenden, um Speicher freizugeben:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Parameter </font></font><code>size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">legt die Größe des Elements fest (auch in der Version für das Array). </font><font style="vertical-align: inherit;">In diesem Formular können Sie je nach abgeleiteter Klasse unterschiedliche Funktionen zum Zuweisen und Freigeben von Speicher verwenden.</font></font><br>
<br>
<a name="id-3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Benutzeroperatoren neu / löschen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ kann benutzerdefinierte Operatorformulare der </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folgenden Form unterstützen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T[<span class="hljs-comment">/*   */</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit diese Formulare unterstützt werden, müssen die geeigneten Funktionen zum Zuweisen und Freigeben von Speicher festgelegt werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>);
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Liste der zusätzlichen Parameter der Speicherzuweisungsfunktionen sollte nicht leer sein und nicht aus einem bestehen, </font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>const std::nothrow_t&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ihre Signatur sollte nicht mit einem der Standardparameter übereinstimmen. Listen zusätzlicher Parameter in </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">müssen übereinstimmen. An den Operator übergebene Argumente </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">müssen zusätzlichen Parametern der Speicherzuordnungsfunktionen entsprechen. Eine benutzerdefinierte Funktion </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann auch im Formular mit einem optionalen Größenparameter vorliegen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktionen können im globalen Namespace oder in einer Klasse definiert werden, jedoch nicht in einem anderen als dem globalen Namespace. Wenn sie im globalen Namespace definiert sind, ersetzen sie die Standardfunktionen zum Zuweisen und Freigeben von Speicher nicht, sondern überladen sie, sodass ihre Verwendung vorhersehbar und sicher ist und Standardfunktionen immer verfügbar sind. Wenn sie in der Klasse definiert sind, verbergen sie die Standardformulare. Der Zugriff auf Standardformulare kann jedoch über den Operator erfolgen </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies wird in Abschnitt 2.2 ausführlich beschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Benutzerdefinierte Operatorformulare </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden als </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benutzerdefinierte Platzierung bezeichnet </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie sollten nicht mit dem </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Abschnitt 1.2 beschriebenen </font><font style="vertical-align: inherit;">Standard-Platzierungsoperator (nicht zuweisend) verwechselt werden </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das entsprechende Operatorformular </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existiert nicht. </font><font style="vertical-align: inherit;">Es </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt zwei Möglichkeiten, </font><font style="vertical-align: inherit;">ein Objekt </font><font style="vertical-align: inherit;">zu </font><font style="vertical-align: inherit;">löschen, das mit einem benutzerdefinierten Operator erstellt wurde </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn eine benutzerdefinierte Funktion </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Speicherzuweisungsoperation an Standardspeicherzuweisungsfunktionen delegiert, kann ein Standardoperator verwendet werden </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn nicht, müssen Sie den Destruktor und dann die benutzerdefinierte Funktion explizit aufrufen </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der Compiler ruft die benutzerdefinierte Funktion </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur in einem Fall auf: Wenn der </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstruktor </font><font style="vertical-align: inherit;">während der Operation des benutzerdefinierten Operators </font><font style="vertical-align: inherit;">eine Ausnahme </font><font style="vertical-align: inherit;">auslöst </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Beispiel (im globalen Bereich).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"new "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"delete "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;<font></font>
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span><span class="hljs-comment">/* ... */</span>};<font></font>
X* p = <span class="hljs-keyword">new</span>(<span class="hljs-number">42</span>, <span class="hljs-string">"meow"</span>) X(); <span class="hljs-comment">// : new 42 + meow</span>
<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//   ::operator delete()</span></code></pre><br>
<a name="id-4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Definition der Speicherzuweisungsfunktionen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesen Beispielen entsprechen Benutzerfunktionen </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delegierte Operationen den Standardfunktionen. Manchmal ist diese Option nützlich, aber das Hauptziel der Überladung </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besteht darin, einen neuen Mechanismus zum Zuweisen / Freigeben von Speicher zu erstellen. Die Aufgabe ist nicht einfach, und bevor man sie übernimmt, muss man alles sorgfältig durchdenken. Scott Meyers [Meyers1] diskutiert mögliche Motive für eine solche Entscheidung (das wichtigste ist natürlich die Effizienz). Er erörtert auch die wichtigsten technischen Probleme, die mit der korrekten Implementierung benutzerdefinierter Funktionen zum Zuweisen und Freigeben von Speicher (unter Verwendung der Funktion) verbunden sind</font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Multithread-Synchronisation, Ausrichtung). </font><font style="vertical-align: inherit;">Guntheroth bietet ein Beispiel für die Implementierung relativ einfacher benutzerdefinierter Speicherzuweisungs- und Freigabefunktionen. </font><font style="vertical-align: inherit;">Bevor Sie Ihre eigene Version erstellen, sollten Sie nach vorgefertigten Lösungen suchen. Als Beispiel können Sie die Pool-Bibliothek aus dem Boost-Projekt holen.</font></font><br>
<br>
<a name="id-5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Allokatorklassen von Standardcontainern</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie oben erwähnt, verwenden Standardcontainer spezielle Allokatorklassen zum Zuweisen und Freigeben von Speicher. </font><font style="vertical-align: inherit;">Diese Klassen sind Vorlagenparameter von Containern, und der Benutzer kann seine Version einer solchen Klasse definieren. </font><font style="vertical-align: inherit;">Die Motive für eine solche Lösung sind ungefähr die gleichen wie für Überlastungsbetreiber </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Guntheroth] beschreibt, wie solche Klassen erstellt werden.</font></font><br>
<br>
<a name="id-refs"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referenzliste</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Guntheroth] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gunteroth, Kurt. </font><font style="vertical-align: inherit;">Optimierung von Programmen in C ++. </font><font style="vertical-align: inherit;">Bewährte Methoden zur Steigerung der Produktivität .: Per. </font><font style="vertical-align: inherit;">aus dem Englischen </font><font style="vertical-align: inherit;">- SPb .: Alpha-book LLC, 2017. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Meyers1] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meyers, Scott. </font><font style="vertical-align: inherit;">Effektive Nutzung von C ++. </font><font style="vertical-align: inherit;">55 sichere Möglichkeiten zur Verbesserung der Struktur und des Codes Ihrer Programme .: Per. </font><font style="vertical-align: inherit;">aus dem Englischen </font><font style="vertical-align: inherit;">- M.: DMK Press, 2014.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de490626/index.html">Eine vollständige Anleitung zu Daten- * HTML-Attributen</a></li>
<li><a href="../de490628/index.html">Was tun, wenn CSS das Parsen von Seiten blockiert?</a></li>
<li><a href="../de490630/index.html">Laden von NumPy-Arrays von der Festplatte: Vergleich von memmap () und Zarr / HDF5</a></li>
<li><a href="../de490634/index.html">Digitale Veranstaltungen in Moskau vom 2. bis 8. März</a></li>
<li><a href="../de490636/index.html">Digitale Events in St. Petersburg vom 2. bis 8. März</a></li>
<li><a href="../de490642/index.html">Plugin zur Überwachung von K8s-Anwendungen DevOpsProdigy KubeGraf v1.3.0: neue Version und neue Funktionen</a></li>
<li><a href="../de490644/index.html">Einfaches RPM-Repository mit Inotify und Webdav</a></li>
<li><a href="../de490648/index.html">Verwenden von Kata-Containern in Kubernetes</a></li>
<li><a href="../de490650/index.html">Die Hauptfehler bei der Erstellung eines Lebenslaufs durch IT-Anfänger</a></li>
<li><a href="../de490652/index.html">Logistik. Einführung Fast kompliziert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>