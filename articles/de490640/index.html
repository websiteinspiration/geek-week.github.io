<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüî¨ ü§õüèø üòì √úberladen in C ++. Teil III. √úberladen neuer / L√∂schanweisungen ‚öìÔ∏è ü§∞üèΩ üë¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir setzen die Serie "C ++, Graben in die Tiefe" fort. Der Zweck dieser Reihe ist es, so viel wie m√∂glich √ºber die verschiedenen Merkmale der Sprache ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>√úberladen in C ++. Teil III. √úberladen neuer / L√∂schanweisungen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490640/"><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir setzen die Serie "C ++, Graben in die Tiefe" fort. </font><font style="vertical-align: inherit;">Der Zweck dieser Reihe ist es, so viel wie m√∂glich √ºber die verschiedenen Merkmale der Sprache zu erz√§hlen, m√∂glicherweise ganz besonders. </font><font style="vertical-align: inherit;">In diesem Artikel geht es um das √úberladen von Bedienern </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist der dritte Artikel in der Reihe, der erste f√ºr √úberladungsfunktionen und -vorlagen, der sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier befindet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der zweite f√ºr √úberladungsoperatoren, der sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier befindet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dieser Artikel schlie√üt eine Serie mit drei Artikeln zum √úberladen in C ++ ab.</font></font><br>
<hr><a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhaltsverzeichnis</font></font></h1><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhaltsverzeichnis</font></font></b><div class="spoiler_text">&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.    new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.1.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.3.     </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.1.     </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.1.      new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.3.  </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.4. </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.5.    operator delete()</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.   new/delete</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.    </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. -  </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a><br>
</div></div><br>
<a name="id-1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Standardformulare f√ºr neue / gel√∂schte Operatoren</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ unterst√ºtzt mehrere Operatoroptionen </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie k√∂nnen in Basisstandard, Zusatzstandard und Benutzerdefiniert unterteilt werden. </font><font style="vertical-align: inherit;">In diesem Abschnitt und Abschnitt 2 werden Standardformulare erl√§utert. Benutzerdefinierte Formulare werden in Abschnitt 3 erl√§utert.</font></font><br>
<br>
<a name="id-1-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1. </font><font style="vertical-align: inherit;">Grundlegende Standardformulare</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die wichtigsten Standardformen von Operatoren, </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die beim Erstellen und L√∂schen eines Objekts und eines Arrays des Typs verwendet werden, sind </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folgende:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span> T[<span class="hljs-comment">/*   */</span>]
<span class="hljs-keyword">delete</span> ptr;
<span class="hljs-keyword">delete</span>[] ptr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ihre Arbeit kann wie folgt beschrieben werden. Wenn der Operator aufgerufen wird </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird dem Objekt zuerst Speicher zugewiesen. Wenn die Auswahl erfolgreich ist, wird der Konstruktor aufgerufen. Wenn der Konstruktor eine Ausnahme ausl√∂st, wird der zugewiesene Speicher freigegeben. Wenn der Operator aufgerufen wird, </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geschieht alles in umgekehrter Reihenfolge: Zuerst wird der Destruktor aufgerufen, dann wird der Speicher freigegeben. Der Destruktor sollte keine Ausnahmen ausl√∂sen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Bediener</font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Erstellen eines Arrays von Objekten wird zun√§chst Speicher f√ºr das gesamte Array zugewiesen. Wenn die Auswahl erfolgreich ist, wird der Standardkonstruktor (oder ein anderer Konstruktor, wenn es einen Initialisierer gibt) f√ºr jedes Element des Arrays ab Null aufgerufen. Wenn ein Konstruktor eine Ausnahme ausl√∂st, wird f√ºr alle erstellten Elemente des Arrays der Destruktor in der umgekehrten Reihenfolge des Konstruktoraufrufs aufgerufen, und der zugewiesene Speicher wird freigegeben. Um ein Array zu l√∂schen, m√ºssen Sie den Operator aufrufen. </font></font><code>delete[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr alle Elemente des Arrays wird der Destruktor in umgekehrter Reihenfolge wie der Konstruktor aufgerufen. Anschlie√üend wird der zugewiesene Speicher freigegeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachtung! Es ist notwendig, die richtige Form des Bedieners aufzurufen</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abh√§ngig davon, ob ein einzelnes Objekt oder ein Array gel√∂scht wird. Diese Regel muss strikt eingehalten werden, sonst kann es zu undefiniertem Verhalten kommen, dh es kann alles passieren: Speicherlecks, Absturz usw. Siehe [Meyers1] f√ºr Details. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der obigen Beschreibung ist eine Klarstellung erforderlich. F√ºr die sogenannten Trivialtypen (eingebaute Typen, Strukturen im C-Stil) darf der Standardkonstruktor nicht aufgerufen werden, und der Destruktor tut auf keinen Fall etwas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Standardspeicherzuweisungsfunktionen l√∂sen eine Typausnahme aus, wenn die Anforderung nicht erf√ºllt werden kann </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Diese Ausnahme kann jedoch abgefangen werden. Dazu m√ºssen Sie einen globalen Interceptor mithilfe eines Funktionsaufrufs installieren. </font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Informationen finden Sie unter [Meyers1]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede Form von Operator</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sicher auf Nullzeiger anwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Erstellen eines Arrays mit einem Operator kann die </font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√∂√üe auf Null gesetzt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beide Formen des Operators </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erm√∂glichen die Verwendung von Initialisierern in geschweiften Klammern.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>{<span class="hljs-number">42</span>}
<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>]{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}</code></pre><br>
<a name="id-1-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2. </font><font style="vertical-align: inherit;">Zus√§tzliche Standardformulare</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Verbinden der Header-Datei </font></font><code>&lt;new&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stehen 4 weitere Standardoperatorformulare zur Verf√ºgung </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(ptr) T(<span class="hljs-comment">/*  */</span>);
<span class="hljs-keyword">new</span>(ptr) T[<span class="hljs-comment">/*   */</span>];
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T(<span class="hljs-comment">/*   */</span>);
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T[<span class="hljs-comment">/*   */</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten beiden werden als </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht zuweisende Platzierung bezeichnet </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ein Argument </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist ein Zeiger auf einen Speicherbereich, der gro√ü genug ist, um eine Instanz oder ein Array aufzunehmen. Au√üerdem muss der Speicherbereich eine geeignete Ausrichtung haben. Diese Version des Operators </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weist keinen Speicher zu, sondern ruft nur den Konstruktor auf. Mit dieser Option k√∂nnen Sie die Phasen der Speicherzuweisung und Initialisierung von Objekten trennen. Diese Funktion wird in Standardcontainern aktiv verwendet. Der Operator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr auf diese Weise erstellte Objekte kann nat√ºrlich nicht aufgerufen werden. Um ein Objekt zu l√∂schen, m√ºssen Sie den Destruktor direkt aufrufen und dann den Speicher auf eine Weise freigeben, die von der Methode zum Zuweisen von Speicher abh√§ngt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweiten beiden Optionen werden als Operator bezeichnet, der keine Ausnahmen </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ausl√∂st (nothrow </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Sie unterscheiden sich darin, dass sie zur√ºckkehren </font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber keine </font><font style="vertical-align: inherit;">Typausnahme ausl√∂sen </font><font style="vertical-align: inherit;">, wenn die Anforderung nicht erf√ºllt werden kann </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das L√∂schen eines Objekts erfolgt mit dem Hauptoperator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Optionen gelten als veraltet und werden nicht zur Verwendung empfohlen.</font></font><br>
<br>
<a name="id-1-3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3. </font><font style="vertical-align: inherit;">Speicherzuordnung und freie Funktionen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standardformen von Operatoren </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwenden die folgenden Zuordnungs- und Freigabefunktionen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktionen werden im globalen Namespace definiert. </font><font style="vertical-align: inherit;">Die Speicherzuweisungsfunktionen f√ºr die Host-Anweisungen </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bewirken nichts und kehren einfach zur√ºck </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17 unterst√ºtzte zus√§tzliche Formen von Speicherzuweisungs- und Freigabefunktionen, die auf die Ausrichtung hinweisen. </font><font style="vertical-align: inherit;">Hier sind einige davon:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Formulare sind f√ºr den Benutzer nicht direkt zug√§nglich. Sie werden vom Compiler f√ºr Objekte verwendet, deren Ausrichtungsanforderungen √ºberlegen </font></font><code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sind. Das Hauptproblem besteht also darin, dass der Benutzer sie nicht versehentlich ausblendet (siehe Abschnitt 2.2.1). </font><font style="vertical-align: inherit;">Denken Sie daran, dass es in C ++ 11 m√∂glich wurde, die Ausrichtung von Benutzertypen explizit festzulegen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct <span class="hljs-title">alignas</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span> X </span>{ <span class="hljs-comment">/* ... */</span> };</code></pre><br>
<a name="id-2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. √úberladen der Standardformulare f√ºr neue / gel√∂schte Operatoren</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das √úberladen der Standardformen von Operatoren </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besteht darin, benutzerdefinierte Funktionen zum Zuweisen und Freigeben von Speicher zu definieren, deren Signaturen mit den Standardsignaturen √ºbereinstimmen. </font><font style="vertical-align: inherit;">Diese Funktionen k√∂nnen im globalen Namespace oder in einer Klasse definiert werden, jedoch nicht in einem anderen als dem globalen Namespace. </font><font style="vertical-align: inherit;">Die Speicherzuweisungsfunktion f√ºr eine Standardhostanweisung </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann nicht im globalen Namespace definiert werden. </font><font style="vertical-align: inherit;">Nach einer solchen Definition werden sie von den entsprechenden Operatoren </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet, nicht von den Standardoperatoren.</font></font><br>
<br>
<a name="id-2-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1. </font><font style="vertical-align: inherit;">√úberladung im globalen Namespace</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, in einem Modul in einem globalen Namespace werden benutzerdefinierte Funktionen definiert:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
</span>{
<span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall werden die Standardfunktionen zum Zuweisen und Freigeben von Speicher f√ºr alle Operatoraufrufe </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr alle Klassen (einschlie√ülich Standardklassen) im gesamten Modul </font><font style="vertical-align: inherit;">tats√§chlich ersetzt ( </font><font style="vertical-align: inherit;">ersetzt). Dies kann zu v√∂lligem Chaos f√ºhren. Beachten Sie, dass der beschriebene Substitutionsmechanismus ein spezieller Mechanismus ist, der nur f√ºr diesen Fall implementiert ist, und kein allgemeiner C ++ - Mechanismus. In diesem Fall wird es beim Implementieren der Benutzerfunktionen zum Zuweisen und Freigeben von Speicher unm√∂glich, die entsprechenden Standardfunktionen aufzurufen. Sie sind vollst√§ndig ausgeblendet (der Operator </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hilft nicht), und wenn Sie versuchen, sie aufzurufen, erfolgt ein rekursiver Aufruf der Benutzerfunktion. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Globale Namespace-definierte Funktion</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird auch das Standardproblem ersetzen, es treten jedoch weniger potenzielle Probleme auf, da der Operator, der keine Ausnahmen </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ausl√∂st, selten verwendet wird. </font><font style="vertical-align: inherit;">Das Standardformular ist aber auch nicht verf√ºgbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die gleiche Situation mit Funktionen f√ºr Arrays. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das √úberladen von Anweisungen </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im globalen Namespace wird dringend empfohlen.</font></font><br>
<br>
<a name="id-2-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2. </font><font style="vertical-align: inherit;">Klassen√ºberlastung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das √úberladen von Operatoren </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einer Klasse weist keine der oben beschriebenen Nachteile auf. </font><font style="vertical-align: inherit;">Das √úberladen ist nur beim Erstellen und L√∂schen von Instanzen der entsprechenden Klasse wirksam, unabh√§ngig vom Kontext des Aufrufs von Operatoren </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bei der Implementierung benutzerdefinierter Funktionen zum Zuweisen und Freigeben von Speicher mithilfe des Operators k√∂nnen </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie auf die entsprechenden Standardfunktionen zugreifen. </font><font style="vertical-align: inherit;">Betrachten Sie ein Beispiel.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span>
{</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete\n"</span>;<font></font>
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new[]\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete[]\n"</span>;<font></font>
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](ptr);<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel wird die Ablaufverfolgung einfach zu Standardoperationen hinzugef√ºgt. </font><font style="vertical-align: inherit;">Nun, in Bezug auf </font></font><code>new X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>new X[N]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird diese Funktionen verwenden, um Speicher zuzuweisen und freizugeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktionen sind formal statisch und k√∂nnen als deklariert werden </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Im Wesentlichen handelt es sich jedoch um eine Instanz. Mit dem Funktionsaufruf </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beginnt die Erstellung der Instanz, und der Aufruf der Funktion </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schlie√üt das L√∂schen ab. </font><font style="vertical-align: inherit;">Diese Funktionen werden niemals f√ºr andere Aufgaben aufgerufen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus ist die Funktion, wie nachstehend gezeigt wird, im </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wesentlichen virtuell. </font><font style="vertical-align: inherit;">Es ist also richtiger, sie ohne zu deklarieren </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1. </font><font style="vertical-align: inherit;">Zugriff auf Standardformulare f√ºr neue / gel√∂schte Operatoren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operatoren </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen beispielsweise mit einem zus√§tzlichen Operator f√ºr die Bereichsaufl√∂sung verwendet werden </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In diesem Fall wird die </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Klasse definierte </font><font style="vertical-align: inherit;">Funktion </font><font style="vertical-align: inherit;">ignoriert und der entsprechende Standard verwendet. </font><font style="vertical-align: inherit;">Auf die gleiche Weise k√∂nnen Sie den Operator verwenden </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2. </font><font style="vertical-align: inherit;">Andere Formen von Neu- / L√∂schoperatoren ausblenden</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">jetzt f√ºr die Klasse </font><font style="vertical-align: inherit;">versuchen, Ausnahmen zu werfen oder nicht zu werfen </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, erhalten wir eine Fehlermeldung. </font><font style="vertical-align: inherit;">Tatsache ist, dass die Funktion </font></font><code>operator new(std::size_t size)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere Formen verbirgt </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das Problem kann auf zwei Arten gel√∂st werden. </font><font style="vertical-align: inherit;">Im ersten Schritt m√ºssen Sie der Klasse die entsprechenden Optionen hinzuf√ºgen (diese Optionen sollten einfach die Operation der Standardfunktion delegieren). </font><font style="vertical-align: inherit;">Im zweiten Fall m√ºssen Sie beispielsweise einen Operator </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem Operator f√ºr die Bereichsaufl√∂sung verwenden </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3. </font><font style="vertical-align: inherit;">Standardbeh√§lter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir beispielsweise versuchen, die Instanzen </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einem Standardcontainer zu platzieren </font></font><code>std::vector&lt;X&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, werden wir feststellen, dass unsere Funktionen nicht zum Zuweisen und Freigeben von Speicher verwendet werden. </font><font style="vertical-align: inherit;">Tatsache ist, dass alle Standardcontainer √ºber einen eigenen Mechanismus zum Zuweisen und Freigeben von Speicher verf√ºgen (eine spezielle Allokatorklasse, die ein Vorlagenparameter des Containers ist) und einen Platzierungsoperator zum Initialisieren der Elemente verwenden </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.4. </font><font style="vertical-align: inherit;">Erbe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionen zum Zuweisen und Freigeben von Speicher werden vererbt. Wenn diese Funktionen in der Basisklasse definiert sind, jedoch nicht in der abgeleiteten, werden die Operatoren f√ºr die abgeleitete Klasse √ºberladen </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die in der Basisklasse definierten und zugewiesenen Funktionen werden zum Zuweisen und Freigeben von Speicher verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie nun eine polymorphe Klassenhierarchie, in der jede Klasse Operatoren √ºberlastet </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lassen Sie nun die Instanz der abgeleiteten Klasse mit dem Operator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºber einen Zeiger auf die Basisklasse </font><font style="vertical-align: inherit;">l√∂schen </font><font style="vertical-align: inherit;">. Wenn der Destruktor der Basisklasse virtuell ist, garantiert der Standard, dass der Destruktor dieser abgeleiteten Klasse aufgerufen wird. In diesem Fall </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist auch der f√ºr diese abgeleitete Klasse definierte </font><font style="vertical-align: inherit;">Funktionsaufruf garantiert </font><font style="vertical-align: inherit;">. Somit ist die Funktion </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tats√§chlich virtuell.</font></font><br>
<br>
<a name="id-2-2-5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.5. </font><font style="vertical-align: inherit;">Alternative Form der Operator-Funktion delete ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einer Klasse (insbesondere wenn Vererbung verwendet wird) ist es manchmal zweckm√§√üig, eine alternative Form der Funktion zu verwenden, um Speicher freizugeben:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Parameter </font></font><code>size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">legt die Gr√∂√üe des Elements fest (auch in der Version f√ºr das Array). </font><font style="vertical-align: inherit;">In diesem Formular k√∂nnen Sie je nach abgeleiteter Klasse unterschiedliche Funktionen zum Zuweisen und Freigeben von Speicher verwenden.</font></font><br>
<br>
<a name="id-3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Benutzeroperatoren neu / l√∂schen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ kann benutzerdefinierte Operatorformulare der </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folgenden Form unterst√ºtzen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T[<span class="hljs-comment">/*   */</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit diese Formulare unterst√ºtzt werden, m√ºssen die geeigneten Funktionen zum Zuweisen und Freigeben von Speicher festgelegt werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>);
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Liste der zus√§tzlichen Parameter der Speicherzuweisungsfunktionen sollte nicht leer sein und nicht aus einem bestehen, </font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>const std::nothrow_t&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ihre Signatur sollte nicht mit einem der Standardparameter √ºbereinstimmen. Listen zus√§tzlicher Parameter in </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√ºssen √ºbereinstimmen. An den Operator √ºbergebene Argumente </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√ºssen zus√§tzlichen Parametern der Speicherzuordnungsfunktionen entsprechen. Eine benutzerdefinierte Funktion </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann auch im Formular mit einem optionalen Gr√∂√üenparameter vorliegen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktionen k√∂nnen im globalen Namespace oder in einer Klasse definiert werden, jedoch nicht in einem anderen als dem globalen Namespace. Wenn sie im globalen Namespace definiert sind, ersetzen sie die Standardfunktionen zum Zuweisen und Freigeben von Speicher nicht, sondern √ºberladen sie, sodass ihre Verwendung vorhersehbar und sicher ist und Standardfunktionen immer verf√ºgbar sind. Wenn sie in der Klasse definiert sind, verbergen sie die Standardformulare. Der Zugriff auf Standardformulare kann jedoch √ºber den Operator erfolgen </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies wird in Abschnitt 2.2 ausf√ºhrlich beschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Benutzerdefinierte Operatorformulare </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden als </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benutzerdefinierte Platzierung bezeichnet </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie sollten nicht mit dem </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Abschnitt 1.2 beschriebenen </font><font style="vertical-align: inherit;">Standard-Platzierungsoperator (nicht zuweisend) verwechselt werden </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das entsprechende Operatorformular </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existiert nicht. </font><font style="vertical-align: inherit;">Es </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt zwei M√∂glichkeiten, </font><font style="vertical-align: inherit;">ein Objekt </font><font style="vertical-align: inherit;">zu </font><font style="vertical-align: inherit;">l√∂schen, das mit einem benutzerdefinierten Operator erstellt wurde </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn eine benutzerdefinierte Funktion </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Speicherzuweisungsoperation an Standardspeicherzuweisungsfunktionen delegiert, kann ein Standardoperator verwendet werden </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn nicht, m√ºssen Sie den Destruktor und dann die benutzerdefinierte Funktion explizit aufrufen </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der Compiler ruft die benutzerdefinierte Funktion </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur in einem Fall auf: Wenn der </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstruktor </font><font style="vertical-align: inherit;">w√§hrend der Operation des benutzerdefinierten Operators </font><font style="vertical-align: inherit;">eine Ausnahme </font><font style="vertical-align: inherit;">ausl√∂st </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Beispiel (im globalen Bereich).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"new "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"delete "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;<font></font>
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span><span class="hljs-comment">/* ... */</span>};<font></font>
X* p = <span class="hljs-keyword">new</span>(<span class="hljs-number">42</span>, <span class="hljs-string">"meow"</span>) X(); <span class="hljs-comment">// : new 42 + meow</span>
<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//   ::operator delete()</span></code></pre><br>
<a name="id-4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Definition der Speicherzuweisungsfunktionen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesen Beispielen entsprechen Benutzerfunktionen </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delegierte Operationen den Standardfunktionen. Manchmal ist diese Option n√ºtzlich, aber das Hauptziel der √úberladung </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besteht darin, einen neuen Mechanismus zum Zuweisen / Freigeben von Speicher zu erstellen. Die Aufgabe ist nicht einfach, und bevor man sie √ºbernimmt, muss man alles sorgf√§ltig durchdenken. Scott Meyers [Meyers1] diskutiert m√∂gliche Motive f√ºr eine solche Entscheidung (das wichtigste ist nat√ºrlich die Effizienz). Er er√∂rtert auch die wichtigsten technischen Probleme, die mit der korrekten Implementierung benutzerdefinierter Funktionen zum Zuweisen und Freigeben von Speicher (unter Verwendung der Funktion) verbunden sind</font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Multithread-Synchronisation, Ausrichtung). </font><font style="vertical-align: inherit;">Guntheroth bietet ein Beispiel f√ºr die Implementierung relativ einfacher benutzerdefinierter Speicherzuweisungs- und Freigabefunktionen. </font><font style="vertical-align: inherit;">Bevor Sie Ihre eigene Version erstellen, sollten Sie nach vorgefertigten L√∂sungen suchen. Als Beispiel k√∂nnen Sie die Pool-Bibliothek aus dem Boost-Projekt holen.</font></font><br>
<br>
<a name="id-5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Allokatorklassen von Standardcontainern</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie oben erw√§hnt, verwenden Standardcontainer spezielle Allokatorklassen zum Zuweisen und Freigeben von Speicher. </font><font style="vertical-align: inherit;">Diese Klassen sind Vorlagenparameter von Containern, und der Benutzer kann seine Version einer solchen Klasse definieren. </font><font style="vertical-align: inherit;">Die Motive f√ºr eine solche L√∂sung sind ungef√§hr die gleichen wie f√ºr √úberlastungsbetreiber </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Guntheroth] beschreibt, wie solche Klassen erstellt werden.</font></font><br>
<br>
<a name="id-refs"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referenzliste</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Guntheroth] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gunteroth, Kurt. </font><font style="vertical-align: inherit;">Optimierung von Programmen in C ++. </font><font style="vertical-align: inherit;">Bew√§hrte Methoden zur Steigerung der Produktivit√§t .: Per. </font><font style="vertical-align: inherit;">aus dem Englischen </font><font style="vertical-align: inherit;">- SPb .: Alpha-book LLC, 2017. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Meyers1] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meyers, Scott. </font><font style="vertical-align: inherit;">Effektive Nutzung von C ++. </font><font style="vertical-align: inherit;">55 sichere M√∂glichkeiten zur Verbesserung der Struktur und des Codes Ihrer Programme .: Per. </font><font style="vertical-align: inherit;">aus dem Englischen </font><font style="vertical-align: inherit;">- M.: DMK Press, 2014.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de490626/index.html">Eine vollst√§ndige Anleitung zu Daten- * HTML-Attributen</a></li>
<li><a href="../de490628/index.html">Was tun, wenn CSS das Parsen von Seiten blockiert?</a></li>
<li><a href="../de490630/index.html">Laden von NumPy-Arrays von der Festplatte: Vergleich von memmap () und Zarr / HDF5</a></li>
<li><a href="../de490634/index.html">Digitale Veranstaltungen in Moskau vom 2. bis 8. M√§rz</a></li>
<li><a href="../de490636/index.html">Digitale Events in St. Petersburg vom 2. bis 8. M√§rz</a></li>
<li><a href="../de490642/index.html">Plugin zur √úberwachung von K8s-Anwendungen DevOpsProdigy KubeGraf v1.3.0: neue Version und neue Funktionen</a></li>
<li><a href="../de490644/index.html">Einfaches RPM-Repository mit Inotify und Webdav</a></li>
<li><a href="../de490648/index.html">Verwenden von Kata-Containern in Kubernetes</a></li>
<li><a href="../de490650/index.html">Die Hauptfehler bei der Erstellung eines Lebenslaufs durch IT-Anf√§nger</a></li>
<li><a href="../de490652/index.html">Logistik. Einf√ºhrung Fast kompliziert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>