<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📁 ▫️ 👨‍💼 アポフェニア、テレゴニア、タイムトラベル（および先頭に_を付けて機能する）の質問へ 💨 ⬜️ 🐄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1958年、ドイツの神経心理学者クラウスコンラッドは「アポフェニア」という用語を作り出しました（ラテン語のアポフェンから-明確な判断、明確にしてください。この用語は、宗教的啓示のテキストに戻ります。ここでは、認識のプロセスの外で達成された知識を意味します）。意味のない、またはランダムな事実またはデー...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>アポフェニア、テレゴニア、タイムトラベル（および先頭に_を付けて機能する）の質問へ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505926/"><blockquote><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1958年、ドイツの神経心理学者クラウスコンラッドは「アポフェニア」という用語を作り出しました（ラテン語のアポフェンから-明確な判断、明確にしてください。この用語は、宗教的啓示のテキストに戻ります。ここでは、認識のプロセスの外で達成された知識を意味します）。意味のない、またはランダムな事実またはデータで関係を確認し、偶然で意味を見つけます。意味のあるコミュニケーションの幻想。私たちの脳は常にパターンを探していますが、しばしば間違いを犯し、それらが存在しないパターンを見たいという不合理な欲求があります。偶然と偶然に従うことへの独特の欲求。これはアポフェニアと呼ばれます。数学的統計では、これは第1種の標準誤差です。</font></font></i><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネプリャヒンN.「私はあなたを操っている」</font></font></i></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特にITリソースに関して、なぜこの用語を思い出したのですか？</font><font style="vertical-align: inherit;">なぜなら、プログラムのデバッグ中に異種のファクト間の関係を検索することが、その成功を決定する主な要因の1つだからです。</font><font style="vertical-align: inherit;">作業の多くのランダムな不正確さは、それぞれがその発生の理由を示さず、プログラム全体の動作に影響を与えないため、無秩序に見えるかもしれません。</font><font style="vertical-align: inherit;">ただし、それらの間の関係を見つけようとすると、1行のコードで多くの問題をすぐに解決できます...または、関係が心のゲーム、つまり開発者の想像力の産物にすぎないことを確認してください。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第1章「エージェントとコーディネーター」</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはすべて、リモートサーバーでいくつかのタスクを実行するエージェントプログラムの開発中に始まり、クライアント/サーバーメカニズムを通じてタスクのリストを受け取りました。エージェントは、サーバーに接続されたローカルコーディネーターであるポート34002でサーバーを起動し、お互いの承認を確認し、すべてが成功した場合、エージェントは必要なアクションを実行し、上部に報告しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tr/mz/kl/trmzklssjskomt-sxqhxfdpbihq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラム</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の</font><i><font style="vertical-align: inherit;">簡略化されたスキーム</font></i><font style="vertical-align: inherit;">エージェント側の明らかなステップは、プロセスを起動中のプログラムに置き換えるために、execファミリーから任意の関数を実行する独自のフォークを作成することでした。この場合、エージェントはプロセスのpidを受け取り、プロセスの完了を待つか、強制的に終了することができました。すべてがうまくいきましたが、コーディネーターが完了した作業に関するレポートを受け取るためには、stdoutとstderrの結論を返す必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題はいくつかの方法で解決できます。stdoutとstderrにプロセスの新しい（dup2）FDを渡し、親プロセスでそれらを読み取ります。 stderrをstdoutにリダイレクトし、popenを使用します。 stdoutおよびstderr記述子をファイルとしてオーバーライドし、完了時にそれらを読み取ります。後者の方法を選択したのは、最初の方法で読み取るには追加のコードと同期が必要なため（そして、常に読み取らないと、2 MBに達した後、パイプバッファーが使い果たされると記録が停止するため）、2番目の方法ではstdoutとstderrの区別がなくなったためです。したがって、最も単純な方法が選択されました-stdoutおよびstderrプロセスを新しいプロセスで閉じてから、出力を上書きするopenで使用するファイルを開きます。 openのドキュメントによると、使用可能な最小のFDインデックスを使用しているため、コードはシンプルでエレガントになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> pid = fork();
<span class="hljs-keyword">switch</span> (pid) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span> :
        <span class="hljs-keyword">return</span> BADFORK;
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> :<font></font>
        close(<span class="hljs-built_in">stdout</span>);<font></font>
        close(<span class="hljs-built_in">stderr</span>);<font></font>
        open(fileout, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        open(fileerr, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        execve(arguments[<span class="hljs-number">0</span>], arguments, environ);
        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);
    <span class="hljs-keyword">default</span> :
        <span class="hljs-keyword">return</span> pid;<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡略化されたコードは次のようになります（読みやすくするためにエラーチェックが削除されています）。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードが起動され、コマンド出力がファイルに正常に書き込まれ、完了し、「戦闘」システムで動作する準備が整いました。</font><font style="vertical-align: inherit;">か否か？</font><font style="vertical-align: inherit;">テスト段階で、小さなバグが現れ、タイムトラベルの可能性（または少なくとも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電信</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">「証明」しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第2章「テレゴニア」</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は次のとおりです。プログラムが完了した後、およびエージェント自体が終了した後、開始されているプログラムの出力（子プログラムのstdoutのリダイレクト先）が含まれているはずのファイルに次の行が見つかりました。</font></font><br>
<br>
<pre><code class="plaintext hljs">[2020-06-05 16:58:49]      :34002</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちょっと待って！しかし、これはエージェント自体の出力からの行です-fork（）を呼び出した親プロセス！それだけでなく、エージェントは呼び出されたプログラムが終了した後、しばらくしてこの行を表示します！エージェントの残りの出力をすべてstdoutに書き込むにはどうすればよいですか。また、行の1つがファイルに入る可能性があります。エージェントのすべての作業は、waitpidが完了した後にそれを読み取ることです。おそらく、ファイルの読み取り中にエラーが発生し、メモリがボロボロになりますか？</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _exec_readfile(struct frs_json * target, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * filename) {<font></font>
    FILE * fp;<font></font>
    <span class="hljs-keyword">char</span> linebuff[VEN_PIPE_READ_SIZE + <span class="hljs-number">1</span>] = { <span class="hljs-number">0</span> };<font></font>
    fp = fopen(filename, <span class="hljs-string">"r"</span>);
    <span class="hljs-keyword">if</span> (!fp)<font></font>
        frs_err(<span class="hljs-string">" \"%s\"    "</span>, filename);
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">while</span>(fgets(linebuff, VEN_PIPE_READ_SIZE, fp))<font></font>
            frs_json_string(target, <span class="hljs-literal">NULL</span>, bxi_strtrimr(linebuff));<font></font>
    }<font></font>
    fclose(fp);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリに勝るものは何もないようです（frs_ *はテストでカバーされています）。</font><font style="vertical-align: inherit;">では、このfpは、この関数が実行された数分後に発生するエージェントの出力にどのように影響しますか？</font><font style="vertical-align: inherit;">当然、ある種の電信-彼らはファイルを読んで読んだところ、9か月後には「最初のパートナー」から連絡を受けました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9g/pv/c7/9gpvc7fjwrn55pggacmexfxbohm.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私のFDはシマウマに触れられた</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Valgrindは問題を発見しなかった、それは私たちを幾分動揺させた。</font><font style="vertical-align: inherit;">結局のところ、彼の全能アナライザーはメモリアクセスエラーを認識せず、分析に多くの時間を費やしただけでした。</font><font style="vertical-align: inherit;">または無駄ではないですか？</font><font style="vertical-align: inherit;">メモリアクセスエラーがない場合は、論理エラーを意味します。</font><font style="vertical-align: inherit;">しかし、どのような論理エラーがそのような影響をもたらす可能性があるのでしょうか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3章「2つのサーバー」</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、2番目のバグが見つかりました。</font><font style="vertical-align: inherit;">QtCreatorデバッグ（開発環境として使用するCプロジェクト自体）での起動中に、プログラムに関連するすべてのプロセスが正常に完了し、このバグは表示されませんでした。</font><font style="vertical-align: inherit;">ただし、2回目の起動が停止したため、プログラムを直接起動してから、（正当な方法で）プログラムを終了することは価値がありました。</font></font><br>
<br>
<pre><code class="plaintext hljs">^C[2020-06-05 16:58:46]    "Interrupt",   <font></font>
[2020-06-05 16:58:49]      :34002<font></font>
[2020-06-05 16:58:49]      :34002<font></font>
[2020-06-05 16:58:49]      :34002<font></font>
[2020-06-05 16:58:49]     <font></font>
[2020-06-05 16:58:50]      </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムのメカニズムを内側から破壊し、プログラムの一部を破壊し、次に他の部分を破壊する小さなグレムリンを考えるのはちょうどいいことでした。</font><font style="vertical-align: inherit;">しかし、プログラマーの才能は、これらのバグの間に関係があることを示唆しています。</font><font style="vertical-align: inherit;">どれ？</font><font style="vertical-align: inherit;">誰にもわかりませんが、それが理由で何も役立たないのです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
打ち上げ失敗の原因を見つけることは簡単であることがわかりました。</font><font style="vertical-align: inherit;">プログラムのシステムログを確認するだけで十分で、その理由が明確かつ明確に定義されています。</font></font><br>
<br>
<pre><code class="plaintext hljs">[2020-06-06 14:40:12] frs_socket_bind  :34002   ("Address already in use" (98))<font></font>
[2020-06-06 14:40:12]      :34002<font></font>
[2020-06-06 14:40:12] ven_server_start     </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでにどのように発売されていますか？</font><font style="vertical-align: inherit;">誰がローンチしたの？</font><font style="vertical-align: inherit;">1分前に終了しました。</font></font><br>
<br>
<pre><code class="plaintext hljs">$ ps aux | grep vento<font></font>
alex     14144  0.0  0.0 156780  7212 pts/0    Sl+  14:39   0:00 ./vento</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本当に発売されました。</font><font style="vertical-align: inherit;">しかし、たぶん事故ですか？</font></font><br>
<br>
<pre><code class="plaintext hljs">kill -9 14144</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして再び、プログラムは開始しますが、プログラムが終了した後、ポート34002を所有するプロセスが残ります。</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
vento     14144 alex    3u  IPv4 12275384      0t0  TCP *:34002 (LISTEN)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、誰が終わるのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行時のlsof -iの出力を検討してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ローンチ：</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
vento     151640 alex    3u  IPv4 12275384      0t0  TCP *:34002 (LISTEN)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ええ、1つのソケット、1つのサーバー</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、1つのライヒ</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
_Postman  25078 alex  104u  IPv4 12885232      0t0  TCP localhost:46154-&gt;localhost:34002 (ESTABLISHED)<font></font>
vento     27468 alex    3u  IPv4 12890254      0t0  TCP *:34002 (LISTEN)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでクライアントはそれに接続され、いくつかのコマンドを設定します... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それは何ですか？</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
_Postman  25078 alex  104u  IPv4 12885232      0t0  TCP localhost:46154-&gt;localhost:34002 (ESTABLISHED)<font></font>
vento     27468 alex    3u  IPv4 12890254      0t0  TCP *:34002 (LISTEN)<font></font>
vento     27506 alex    3u  IPv4 12890254      0t0  TCP *:34002 (LISTEN)<font></font>
vento     27506 alex    4u  IPv4 12890329      0t0  TCP localhost:34002-&gt;localhost:46154 (ESTABLISHED)</code></pre><br>
<img src="https://habrastorage.org/webt/wp/wq/62/wpwq62hwasqdflzz9bxomgjvebq.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">楽しい事実＃197766：遅かれ早かれ、Star Warsへの参照は</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
2つのサーバーポートに</font><i><font style="vertical-align: inherit;">表示され</font></i><font style="vertical-align: inherit;">ますか？</font><font style="vertical-align: inherit;">サーバーがREUSEPORTフラグを使用していないという事実にもかかわらず。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第4章「CLOEXEC」</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
うーん...おそらくCLOEXECフラグがサーバーの実装にありませんか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグを詳しく見てみましょう：</font></font><br>
<br>
<pre><code class="plaintext hljs">$man fork<font></font>
       *  The child process is created  with  a  single  thread—the  one  that<font></font>
          called  fork().   The  entire virtual address space of the parent is<font></font>
          replicated in the child, including the states of mutexes,  condition<font></font>
          variables,  and other pthreads objects; the use of pthread_atfork(3)<font></font>
          may be helpful for dealing with problems that this can cause.<font></font>
<font></font>
       *  The child inherits copies of the parent's set of open file  descrip‐<font></font>
          tors.   Each  file  descriptor  in the child refers to the same open<font></font>
          file description (see open(2)) as the corresponding file  descriptor<font></font>
          in  the parent.  This means that the two file descriptors share open<font></font>
          file status flags, file offset,  and  signal-driven  I/O  attributes<font></font>
          (see the description of F_SETOWN and F_SETSIG in fcntl(2)).<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
fork（）関数を呼び出すと、プロセスの現在のスレッドのコピーが作成され、開いている各プロセス記述子のコピーが作成されます（UNIXのようなシステムでは「すべてがファイルである」ため、ネットワークファイルはファイル記述子とともに傾斜します）。</font></font><br>
<br>
<pre><code class="plaintext hljs">$man exec<font></font>
       The exec() family of functions replaces the current process image with a new process image.  The functions described in<font></font>
       this manual page are front-ends for execve(2).  (See the manual page  for  execve(2)  for  further  details  about  the<font></font>
       replacement of the current process image.)</code></pre><br>
<pre><code class="plaintext hljs">$man execve<font></font>
       *  By  default,  file  descriptors  remain open across an execve().  File descriptors that are marked close-on-exec are<font></font>
          closed; see the description of FD_CLOEXEC in fcntl(2).  (If a file descriptor is closed, this will cause the release<font></font>
          of  all record locks obtained on the underlying file by this process.  See fcntl(2) for details.)  POSIX.1 says that<font></font>
          if file descriptors 0, 1, and 2 would otherwise be closed after a successful execve(), and the  process  would  gain<font></font>
          privilege because the set-user-ID or set-group_ID mode bit was set on the executed file, then the system may open an<font></font>
          unspecified file for each of these file descriptors.  As a general principle, no portable  program,  whether  privi‐<font></font>
          leged or not, can assume that these three file descriptors will remain closed across an execve().</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
呼び出されたプロセスが記述子のコピーを受信したくない場合は、フラグFD_CLOEXEC / SOCK_CLOEXECを設定する必要があります。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般に、ルートアクセスファイルのリークを回避するために、コピーしたいタグでマークされている場合は論理的ですが、フラグはPOSIX-2001に現れたため、私たちの遺産</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですが</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物議を醸してい</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><br>
<br>
<pre><code class="cpp hljs">server-&gt;socket = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC, <span class="hljs-number">0</span>);</code></pre><br>
<pre><code class="cpp hljs">fcntl(client, F_SETFD, FD_CLOEXEC);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、いいえ、フラグは設定どおりに設定されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それから何が起こりますか？</font><font style="vertical-align: inherit;">カーネルはフラグを無視しますか？</font><font style="vertical-align: inherit;">誰かが彼を捨てる？</font><font style="vertical-align: inherit;">そして最も重要なのは、アプリケーションが完了した後、なぜポートを占有するプロセスがシステムに残っているのか、です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインサーバーを閉じて、gdbを使用して残りのプロセスに接続してみましょう。</font></font><br>
<br>
<pre><code class="plaintext hljs">$ sudo gdb -p 27506<font></font>
GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git<font></font>
[...]<font></font>
Reading symbols from /lib/x86_64-linux-gnu/libgcc_s.so.1...(no debugging symbols found)...done.<font></font>
0x00007f503d50c9f3 in futex_wait_cancelable (private=[optimized out], expected=0, futex_word=0x55f485d383b8)<font></font>
    at ../sysdeps/unix/sysv/linux/futex-internal.h:88<font></font>
88	../sysdeps/unix/sysv/linux/futex-internal.h:     .<font></font>
(gdb) bt<font></font>
#0  0x00007f503d50c9f3 in futex_wait_cancelable (private=[optimized out], expected=0, futex_word=0x55f485d383b8)<font></font>
    at ../sysdeps/unix/sysv/linux/futex-internal.h:88<font></font>
#1  __pthread_cond_wait_common (abstime=0x0, mutex=0x55f485d38368, cond=0x55f485d38390) at pthread_cond_wait.c:502<font></font>
#2  __pthread_cond_wait (cond=0x55f485d38390, mutex=0x55f485d38368) at pthread_cond_wait.c:655<font></font>
#3  0x00007f503d948097 in _frs_signal_wait (signal=0x55f485d38340, filename=0x7f503d7315c8 "fen_server.c", fileline=298)<font></font>
    at ./projects/shared/libforseti/code/thread/frs_signal.c:250<font></font>
#4  0x00007f503d728044 in _server_wait (server=0x55f485d38270) at ./projects/shared/libfenrir/code/server/fen_server.c:298<font></font>
#5  0x00007f503d72822d in fen_server_free (server=0x55f485d38270) at ./projects/shared/libfenrir/code/server/fen_server.c:351</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストップストップストップ、どんなserver_free？</font><font style="vertical-align: inherit;">間違ったプロセスを完了しましたか？</font><font style="vertical-align: inherit;">結局、エコーアプリケーションの起動があるはずです！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それともそうではありませんか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第5章「1文字」</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文字列echoを送信しますが、同じシステムとは異なり、シェル環境では実行しないため、execにアプリケーションへのフルパスを配置する必要があります。</font><font style="vertical-align: inherit;">/ bin / echoに変更して、問題がなくなったことを確認します。</font><font style="vertical-align: inherit;">しかし、execの観点から誤ったコマンドを与えると、同じプロセスで作業を続け、実行中のアプリケーションに置き換えないことがわかります。つまり、...</font></font><br>
<br>
<pre><code class="cpp hljs">        execve(arguments[<span class="hljs-number">0</span>], arguments, environ);
        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ええ、はい、終了しました。</font><font style="vertical-align: inherit;">しかし、これによりサーバーはどのようにシャットダウンするのでしょうか。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/*! \brief   */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _free(<span class="hljs-keyword">void</span>) __attribute__((destructor));
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _free(<span class="hljs-keyword">void</span>) {<font></font>
    fen_server_free(g_server);<font></font>
    frs_inf(<span class="hljs-string">"   "</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これですべてが整いました。</font><font style="vertical-align: inherit;">これら2つのバグは実際には相互に関連しており、今では正確にどのように言うこともでき</font></font><br>
<br>
<img src="https://habrastorage.org/webt/g0/sk/-s/g0sk-sf74ratdovfkkoqny7ongu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。</font><font style="vertical-align: inherit;">そして、テレビのマスターとハンマーで1つのヒットについてのジョークのようにそれを行います。exit </font><font style="vertical-align: inherit;">という単語に「_」</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記号</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><b><font style="vertical-align: inherit;">1つ追加し</font></b><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> pid = fork();
<span class="hljs-keyword">switch</span> (pid) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span> :
        <span class="hljs-keyword">return</span> BADFORK;
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> :<font></font>
        close(<span class="hljs-built_in">stdout</span>);<font></font>
        close(<span class="hljs-built_in">stderr</span>);<font></font>
        open(fileout, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        open(fileerr, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        execve(arguments[<span class="hljs-number">0</span>], arguments, environ);<font></font>
        _exit(EXIT_FAILURE);<font></font>
    <span class="hljs-keyword">default</span> :
        <span class="hljs-keyword">return</span> pid;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今何が起こっているのですか？</font><font style="vertical-align: inherit;">特別なことはありませんが、atexitを通じて登録された関数を呼び出さずに終了プロセスが終了する点が異なります。</font><font style="vertical-align: inherit;">古いglibcの実装では、これは_exitシステムコールの呼び出しとなります。新しいものでは、exit_groupが呼び出され、すべてのプログラムスレッドがより正確に完了します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、どちらのバグも打ち負かされており、「apofenia」、「不思議」、「接続がありません」と言っていました。</font><font style="vertical-align: inherit;">箱を棚の上</font><font style="vertical-align: inherit;">に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移動し</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。そうしないと、人類は宇宙に飛べなくなります。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja505898/index.html">クロードシャノン：すべての取引のジャック、ジョーカー、情報理論の父</a></li>
<li><a href="../ja505900/index.html">個人的な依存症：フルサイズの40 mm、ワイヤーなし、72時間8000ルーブル</a></li>
<li><a href="../ja505904/index.html">JUG Ru Group＃5オンラインストリームウィーク</a></li>
<li><a href="../ja505906/index.html">overthewire.orgのウォークスルー盗賊</a></li>
<li><a href="../ja505918/index.html">ソニーの電話インターフェース-無効化されていない広告</a></li>
<li><a href="../ja505928/index.html">関数型プログラミングがそれほど複雑である理由</a></li>
<li><a href="../ja505946/index.html">Django / Django RESTを使用した画像の保存</a></li>
<li><a href="../ja505954/index.html">Alpine.js-イベントとグローバルデータウェアハウス</a></li>
<li><a href="../pt486176/index.html">Memorando de correspondência por e-mail corporativo</a></li>
<li><a href="../pt486178/index.html">FOSS News No. 1 - revisão de notícias gratuitas e de código aberto de 27 de janeiro a 2 de fevereiro de 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>