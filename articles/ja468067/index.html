<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏿 👘 ⛑️ アルファ合成のしくみ 🐙 🍛 👠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="透明性は興味深いトピックのようには思えないかもしれません。一部のピクセルが背景を通して光るGIF形式は、30年以上前に公開されました。過去20年間にリリースされたほとんどすべてのグラフィックデザインアプリケーションは、半透明のコンテンツの作成をサポートしています。これらの概念は、長い間新しいものでは...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>アルファ合成のしくみ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468067/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fd/bw/7x/fdbw7xdswtd_k6crz13wprtqbtm.gif" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
透明性は興味深いトピックのようには思えないかもしれません。</font><font style="vertical-align: inherit;">一部のピクセルが背景を通して光るGIF形式は、30年以上前に公開されました。</font><font style="vertical-align: inherit;">過去20年間にリリースされたほとんどすべてのグラフィックデザインアプリケーションは、半透明のコンテンツの作成をサポートしています。</font><font style="vertical-align: inherit;">これらの概念は、長い間新しいものではなくなりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の記事では、デジタル画像の透明度は見た目よりもはるかに興味深いことを示したいと思います。当然のことながら、目に見えない深さと美しさがあります。</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不透明度</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピンクのメガネを通して見たことがあれば、下の図に示されているものに似たものを見ることができます。</font><font style="vertical-align: inherit;">[元の記事では、多くの画像がインタラクティブです。]メガネを動かして、見えているものにどのように影響するかを確認してください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tu/zo/mz/tuzomzqhbl9mcfzbxxcaneot3aq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなメガネは次のように機能します。赤が多く、青がかなり多く、緑がほとんどありません。</font><font style="vertical-align: inherit;">これらのポイントの数学は、3つの方程式のセットで記述できます。</font><font style="vertical-align: inherit;">文字</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は操作の結果を示し、文字</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は私たちが見ているポイントを示します。</font><font style="vertical-align: inherit;">RGBインデックスは、赤、緑、青のコンポーネントを示します。</font></font><br>
<br>
<blockquote><code>R<sub>R</sub> = D<sub>R</sub> × 1.0<br>
R<sub>G</sub> = D<sub>G</sub> × 0.7<br>
R<sub>B</sub> = D<sub>B</sub> × 0.9</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この着色されたガラスは、背景の赤、緑、青の成分をさまざまな強さで透過します。</font><font style="vertical-align: inherit;">つまり、</font><font style="vertical-align: inherit;">ピンクのメガネ</font><font style="vertical-align: inherit;">の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">透明度</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、入射光の色に依存します。</font><font style="vertical-align: inherit;">一般的な場合、透明度</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は光の波長によって異なります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、この簡略化された例では、ガラスが従来のRGBコンポーネントにどのように影響するかにのみ関心があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のサングラスの動作のシミュレーションははるかに簡単です。通常、サングラスは入射光をある程度減衰させます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/lq/8k/qflq8kkgpnh__pk8lpv5rx6txya.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのガラスは、それらを通過する光の30％のみを許可します。</font><font style="vertical-align: inherit;">それらの動作は、次の方程式で表すことができます。</font></font><br>
<br>
<blockquote><code>R<sub>R</sub> = D<sub>R</sub> × 0.3<br>
R<sub>G</sub> = D<sub>G</sub> × 0.3<br>
R<sub>B</sub> = D<sub>B</sub> × 0.3</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つの色成分はすべて同じ値で減少します-入射光の吸収は同じです。</font><font style="vertical-align: inherit;">ダークグラスは30％透明（不透明）または70％不透明であると言えます。</font><font style="vertical-align: inherit;">オブジェクト</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の不透明度は、</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトがブロックする色の量を決定します。</font><font style="vertical-align: inherit;">コンピュータグラフィックスでは、通常、このプロパティを説明するために必要な値が1つだけの単純化されたモデルを扱います。</font><font style="vertical-align: inherit;">不透明度は空間的に異なります。</font><font style="vertical-align: inherit;">たとえば、煙の柱が高くなり、透明度が高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現実の世界では、不透明度が100％のオブジェクトは単に不透明であり、光をまったく透過しません。</font><font style="vertical-align: inherit;">デジタル画像の世界は少し異なります。</font><font style="vertical-align: inherit;">その中には境界線の場合があり、固体の不透明なオブジェクトでさえ一定の量の光を通過させます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コーティング</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベクターグラフィックスは、点、線分、ベジェ曲線、およびその他の数学的プリミティブを使用して定義された、形状の明確で無限に正確な記述を扱います。</font><font style="vertical-align: inherit;">コンピューター画面に図形を表示する必要がある場合、これらの非の打ち所のないエンティティをビットマップにラスタライズする必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebc/a01/6ed/ebca016ed191611e29f68dfca5aebe62.svg" width="492" height="202"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクターシェイプのビットマップ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
へのラスタライズラスタライズの最も基本的な方法は、ピクセルサンプルがベクターシェイプの内側または外側のどこにあるかを確認することです。</font><font style="vertical-align: inherit;">以下の例では、三角形をドラッグして拡大表示すると、動きがより正確になります。</font><font style="vertical-align: inherit;">青い輪郭は元のベクトルジオメトリを示します。</font><font style="vertical-align: inherit;">ご覧のように、ジオメトリを移動すると、三角形の端にあるラダーが見苦しくなり、ちらつきが大きくなります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mp/kn/pg/mpknpgk1lauj0ruzaobm6azr2wy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの欠点は、表示されたピクセルごとに1つのチェックのみを実行し、結果が2つの可能な値の1つ（内部または外部）に離散化されることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピクセルごとに数回ベクトルジオメトリをサンプリングして、大きなグラデーションを取得し、一部のピクセルのみが</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分的に</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">閉じていると判断できます</font><font style="vertical-align: inherit;">。一つの可能な解決策は、5つのカバレッジレベルを表すために4つのサンプリング点を使用することである：0、</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および1：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hi/uu/pw/hiuupwrv88cjcfjxv5_f-b1hege.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
三角形のエッジの品質は向上しましたが、カバレッジの考えられる5つのレベルだけでは十分でないことが多く、はるかに優れた結果を簡単に達成できます。信号処理の世界ではピクセルを小さな正方形として</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示することは不承認</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">見なされますが</font></a><font style="vertical-align: inherit;">、状況によっては、ベクトルジオメトリによってピクセルの正確なカバレッジを計算できる便利なモデルです。線と正方形の交点は、常に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">台形</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長方形に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分解でき</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24e/b9f/494/24eb9f494ab4259257189da367efef01.svg" alt="画像"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線分は正方形を台形と長方形に分割します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
両方の部分の面積を簡単に計算でき、それらの合計を正方形の面積で割ると、ピクセルカバレッジの割合が決まります。したがって、カバレッジは任意の精度で正確な数値として計算されます。以下に示すデモでは、このメソッドを使用して、三角形をドラッグした場合でも滑らかなままのはるかに優れたエッジをレンダリングします。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/xj/pd/fw/xjpdfwcvkdgujdwittnyzxan6ce.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
楕円や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベジェ曲線</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などのより複雑な形状になると、</font><font style="vertical-align: inherit;">多くの場合、必要な精度でカバレッジを計算できるように単純な線分に分割されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
部分的なカバレッジの概念は、ベクトルグラフィックスの高品質なレンダリング、さらに重要なことには、テキストのレンダリングにとって重要です。</font><font style="vertical-align: inherit;">この記事のスクリーンショットを撮って注意深く検討すると、グリフのほとんどすべてのエッジが部分的にのみピクセルを覆っていることがわかります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69a/b93/1ef/69ab931ef9b9eeb4f669f29652044c0d.png" height="50%" width="50%"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分的なカバレッジはテキストレンダリングでアクティブに使用されます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
オブジェクトを不透明にし、個々のピクセルをそのオブジェクトでカバーすると、それらを1つの値に組み合わせることができます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルファ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトの不透明度とそのピクセルカバレッジの積は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alpha</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<blockquote><code> =  × </code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピクセル領域の30％をカバーする60％の不透明度を持つオブジェクトは、このピクセルで18％のアルファ値を持っています。当然、オブジェクトが透明であるか、ピクセルが完全に覆われていない場合、このピクセルのアルファ値は0になります。乗算後、不透明度とコーティングの違いはなくなります。これは、ある意味で、「アルファ」と「不透明度」の概念が同義で使用されているという事実を正当化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、アルファはビットマップ画像の4番目のチャネルとして表されます。赤、緑、青の通常の値は、アルファ値によって補完され、4つのRGBA値を形成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルファ値をメモリに格納することになると、これに数ビットだけを使用する誘惑があります。</font><font style="vertical-align: inherit;">不透明なオブジェクトのエッジのピクセルをカバーする場合、画面のピクセル密度に応じて、4ビットまたは3ビットで十分であると思われます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qr/xt/pr/qrxtpr2tyhpn1znd0brdi8ehhns.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、不透明度もアルファ値に影響を与えるため、透明度がスムーズに変化する場合、ビット深度が低いと破滅的な場合があります。</font><font style="vertical-align: inherit;">以下の画像は、不透明な黒から白へのグラデーションを示しています。これは、ビット深度が低いと、非常に強い色の変化が生じることを示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jm/8a/bv/jm8abvbbl5mejxely1nbhefyv8u.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、ビット数が多いほど、多くの場合アルファ8は8のビット深度を使用してカラーコンポーネントの精度に一致します。そのため、多くのRGBAバッファがピクセルあたり32ビットを占有します。また、非線形変換を使用してエンコードされることが多いカラーコンポーネントとは異なり、アルファは線形に格納されます。エンコードされた値0.5は、アルファ値0.5に対応します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルファについて言えば、他のすべての色成分を完全に無視しましたが、背景色をブロックすることに加えて、ピクセル自体が少し色を追加できます。アイデアは非常に単純です。半透明のピンク色のオブジェクトは、入ってくる背景の照明の一部をブロックし、小さなピンク色の光を放出または反射します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/_w/kf/tc_wkf6dtsblbjvxx1nslytlu2u.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステンドグラスのように</font><font style="vertical-align: inherit;">
動作し</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ない</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことに注意してください</font><font style="vertical-align: inherit;">。 Glassは、背景の照明の一部を異なる明るさで単に遮断します。ピンクのガラスを通して完全に黒いオブジェクトを見ると、黒いオブジェクトは発光せず、光を反射しないため、その黒さは残ります。ただし、半透明のピンク色のオブジェクト</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自の光を</font><em><font style="vertical-align: inherit;">追加</font></em><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。黒いオブジェクトの上に置くと、結果はピンクがかった色になります。この動作の良い類似物は、ヘイズ、煙、霧、またはいくつかの着色された粉末など、空気中に浮遊している微細な物質です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルファチャネルのレンダリングは少し難しくなります。完全に透明なオブジェクトは定義上不可視であるため、オブジェクトを区別するには、2つのトリックを使用する必要があります。</font><font style="vertical-align: inherit;">チェッカーボードの背景は、画像のどの部分が透明であるかを示します。</font><font style="vertical-align: inherit;">このパターンは、多くのグラフィカルアプリケーションで使用されています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b4/ff5/064/6b4ff5064b6cd9262e4d381125b406c4.svg" width="280" height="144"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェスパターンは透明な部分を示しています。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
画像の下にある4つの小さな正方形は、画像の赤、緑、青、およびアルファコンポーネントを示しています。</font><font style="vertical-align: inherit;">場合によっては、アルファチャネルの値を直接確認すると便利です。それらを表示する最も簡単な方法は、灰色の陰影を使用することです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9a/c12/c33/c9ac12c335263552b56dda8f3bd35262.svg" width="280" height="306"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なるサーフェスでのRGB値とA値の表示</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
グレーの色合いが明るいほど、アルファ値が高くなります。つまり、純粋な黒は0％アルファに対応し、純粋な白は100％アルファに対応します。</font><font style="vertical-align: inherit;">小さな正方形は、画像のRGBおよびAコンポーネントが2つの部分に分割されていることを示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルファコンポーネント自体は特に有用ではありませんが、合成について話すときに非常に重要になります。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純な合成</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1回の操作で実装できる2Dレンダリング効果はほとんどなく、最終的な結果を作成するために、</font><font style="vertical-align: inherit;">異なる画像を組み合わせる</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合成</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスを使用し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">たとえば、単純な「キャンセル」ボタンは、5つの個別の要素を合成することで作成できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd5/2d1/80f/cd52d180f6aba101c8fd2bf95bd721fe.svg" width="318" height="328"></div> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「キャンセル」ボタンの要素の</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
合成合成は多くの場合、いくつかの段階で実行され、それぞれが2つの画像を結合します。合成に使用される前景画像は、一般に</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><em><font style="vertical-align: inherit;">ます</font></em><font style="vertical-align: inherit;">。合成に使用される背景画像は、ソースが重ね合わされており、通常は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宛先</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><em><font style="vertical-align: inherit;">ます</font></em><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは非常に一般的なケースであるため、不透明な背景での合成から始めます。画面に表示されるすべてのものは、最終的には不透明な宛先で合成することによって重ね合わされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースのアルファ値が100％の場合、ソースは不透明であり、宛先を完全にカバーする必要があります。</font><font style="vertical-align: inherit;">アルファ値が0％の場合、ソースは完全に透明であり、宛先にはまったく影響しません。</font><font style="vertical-align: inherit;">アルファ値が25％の場合、オブジェクトは光の25％を放出し、背景からの光の75％を通過させることができます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/985/719/921/985719921b6dc06496caba46db08a5c5.svg" width="520" height="248"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なるアルファ値を持つ紫のソースを黄色の宛先に</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
合成するそれが何であるかはすでに理解できます-不透明な背景でのアルファ合成の単純なケースは、宛先カラーとソースカラー間の単なる線形補間です。</font><font style="vertical-align: inherit;">下のグラフでは、スライダーがソースのアルファ値を制御し、赤、緑、青のグラフがRGBコンポーネントの値を表示します。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の結果は</font><font style="vertical-align: inherit;">、ソース</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と宛先</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dの</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単なる混合</font><font style="vertical-align: inherit;">です</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fd/bw/7x/fdbw7xdswtd_k6crz13wprtqbtm.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで何が起こるかは、以下に示す方程式で説明できます。</font><font style="vertical-align: inherit;">、インデックスがあるコンポーネントを表す前述のように、S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aは、</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースアルファ値であり、D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gは、</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先に緑の値です。</font></font><br>
<br>
<blockquote><code>R<sub>R</sub> = S<sub>R</sub> × S<sub>A</sub> + D<sub>R</sub> × (1 − S<sub>A</sub>)<br>
<br>
R<sub>G</sub> = S<sub>G</sub> × S<sub>A</sub> + D<sub>G</sub> × (1 − S<sub>A</sub>)<br>
<br>
R<sub>B</sub> = S<sub>B</sub> × S<sub>A</sub> + D<sub>B</sub> × (1 − S<sub>A</sub>)</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
赤、緑、青のコンポーネントの方程式は同じように見えるため、</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックス</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して</font><font style="vertical-align: inherit;">それらを1行に結合できます。</font></font><br>
<br>
<blockquote><code>R<sub>RGB</sub> = S<sub>RGB</sub> × S<sub>A</sub> + D<sub>RGB</sub> × (1 − S<sub>A</sub>)</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、デスティネーションは不透明であり、すべての背景光をすでに遮断しているため、結果のアルファ値は常に1であることがわかります。</font></font><br>
<br>
<blockquote><code>R<sub>A</sub> = 1</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不透明な背景での合成は簡単ですが、機能がかなり制限されています。</font><font style="vertical-align: inherit;">多くの場合、より信頼性の高いソリューションが必要です。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中間バッファー</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下の画像は、A、B、Cとラベル付けされた3つの異なるレイヤーを合成する2段階のプロセスを示しています。記号⇨は、「合成によって重ね合わされる」ことを意味します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a9/fb8/ca5/6a9fb8ca58b71a7327785e10b54ef8da.svg" width="620" height="310"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3層の2段階合成の結果</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
まず、BをCでオーバーレイし、次にAをそれらでオーバーレイして、完成した画像を取得します。</font><font style="vertical-align: inherit;">次の例では、少し異なる方法で処理を行います。</font><font style="vertical-align: inherit;">最初に、上の2つのレイヤーを合成して接続し、最後の宛先に結果をオーバーレイします。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/a10/e40/a99a10e409562f903fa7e66b4a363706.svg" width="620" height="310"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3つのレイヤーを異なる順序で2段階合成した結果</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このような状況が実際に発生するのか疑問に思われるかもしれませんが、実際には非常に一般的です。マスキングやブラーなどの多くの重要な合成操作やレンダリング効果では、部分的な合成結果のみを含む中間バッファーを通過する必要があります。この概念には異なる名前があります。オフスクリーンパス、透明画層、サイドバッファーですが、通常は同じ考え方に基づいています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちにとってより重要なのは、</font><font style="vertical-align: inherit;">透明度の</font><font style="vertical-align: inherit;">あるほとんど</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像が、一部のレンダリングの部分的な結果として認識され、後で最終的な宛先で合成することによって重ねられることです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/862/2cc/804/8622cc804d280c508244ccfc60c0e461.svg" width="128" height="48"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボタンをバッファに部分的に合成する</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
半透明の画像AとBの合成を、同じ色と不透明度を持つ1つの画像（A⇨B）に置き換える方法を理解する必要があります。</font><font style="vertical-align: inherit;">最初に、最終バッファーのアルファ値を計算します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルファ値を組み合わせる</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのオブジェクトの不透明度をどのように組み合わせるかはわかりにくいかもしれませんが、代わりに透明度について説明すると、このタスクについて説明する方が簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ある量の光が最初のオブジェクトを通過し、次に2番目のオブジェクトを通過するとします。最初のオブジェクトの透明度が80％の場合、入射光の80％を通過します。同様に、60％の透明度を持つ2番目のオブジェクトは、60％の光を通過させるため、元の光の60％×80％= 48％になります。元の記事で透明度を試すことができます。スライダーが</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">透明度を</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制御し、</font><font style="vertical-align: inherit;">光の経路にあるオブジェクトの不透明度を</font><font style="vertical-align: inherit;">制御しないことを忘れないでください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/av/f5/lv/avf5lvv7kve1zkgnztkd_i_hylq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然、第1または第2のオブジェクトのいずれかが不透明である場合、それらを通過する光はなく、別のオブジェクトが完全に透明です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトDに透明度D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり、オブジェクトSに透明度S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がある場合、</font><font style="vertical-align: inherit;">これら2つのオブジェクト</font><font style="vertical-align: inherit;">の最終的な一般的な透明度R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tは</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらの積に等しくなります。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></sub></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、透明度は単なる単位からアルファを引いたものなので、置換により次のようになります。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =（1-D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この式は、次のように展開できます。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1-D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、次のように単純化します。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、2つの類似したタイプのいずれかに減らすことができます。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（1-D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すぐに、2番目がより頻繁に使用されることがわかります。</font><font style="vertical-align: inherit;">また、生成されるアルファ値はオブジェクトの相対的な順序に依存しないことにも注意してください。ソースと宛先を入れ替えても、生成されるピクセルの不透明度は同じです。</font><font style="vertical-align: inherit;">これは非常に論理的です。</font><font style="vertical-align: inherit;">2つのオブジェクトを通過する光は、星のどの側からでも、正面からでも、背面からでも同じようにフェードアウトします。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色の組み合わせ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルファの計算はそれほど難しくなかったので、RGBコンポーネントの計算を理解してみましょう。</font><font style="vertical-align: inherit;">ソース画像の色はS </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですが、その不透明度S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、これらの2つの値の積のみを最終結果に反映させます。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デスティネーションイメージの色はD </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり、不透明度はD </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aの</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光を放出します</font><font style="vertical-align: inherit;">が、ライトの一部はイメージSの不透明度によってブロックされるため、デスティネーションの全体的な効果は次のようになります。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SとDからの光の合計寄与は、それらの合計に等しくなります。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、マージされたレイヤーの寄与は、それらの色に不透明度を掛けたものに等しくなります。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの2つの値を一致させたい：</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終的な方程式を与えるもの：</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =（S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">））/ R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の方程式がどれほど複雑かを確認してください。</font><font style="vertical-align: inherit;">結果のRGB値を取得するには、アルファ値で除算する必要があることに注意してください。</font><font style="vertical-align: inherit;">ただし、合成の次の段階では、現在の演算の結果が次の演算の新しいソースまたは宛先になるため、アルファ値による乗算が再び必要になります。</font><font style="vertical-align: inherit;">それは単に醜いです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少しの間、R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGBの</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほぼ最終的な形式に戻りましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソース、デスティネーション</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、および</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果は、それらのアルファコンポーネントで乗算されます。</font><font style="vertical-align: inherit;">これにより、ピクセルの色とアルファが「似ている」ことを理解できるため、一歩下がって色情報の格納方法を再考する必要があります。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乗算済みアルファ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不透明度について説明したことを思い出してください-オブジェクトが部分的に不透明である場合、結果への寄与も部分的です。</font><font style="vertical-align: inherit;">事前乗算されたアルファ（「アルファによる事前乗算」）の概念は、このアイデアを実装しています。</font><font style="vertical-align: inherit;">名前が示すように、RGBコンポーネントの値には、以前にアルファコンポーネントが乗算されています。</font><font style="vertical-align: inherit;">予備的な乗算なしの色から始めましょう。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1.00、0.80、0.30、0.40）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルファによる予備的な乗算により、以下が得られます。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（0.40、0.32、0.12、0.40）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一度にいくつかのピクセルを見てみましょう。</font><font style="vertical-align: inherit;">以下の図は、最初にアルファを乗算せずにカラー情報を保存する方法を示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e20/ba7/338/e20ba7338feb27cdf22f3c25d3afa697.svg" width="440" height="262"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像内</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の緑と青のグリッチからわかるように、アルファが0の領域は任意のRGB値を持つ可能性があることに注意してください。</font><font style="vertical-align: inherit;">アルファによる予備的な乗算の場合、色情報にはピクセルの不透明度の値も格納されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/613/5d9/ede/6135d9ede6ea6789bbcd979e48a2cce0.svg" width="440" height="262"></div><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリマルチプライ済みアルファのプリマルチプライ済み</font><i><font style="vertical-align: inherit;">イメージのRGBおよびA情報は、</font></i><font style="vertical-align: inherit;">関連付けられたアルファと呼ばれることもあり、非プリマルチプライ済みアルファは、ストレートまたは関連付けられていないアルファと呼ばれることもあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
色のアルファコンポーネントが0の場合、予備的な乗算により、値に関係なく他のすべてのコンポーネントがリセットされます。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（0.0、0.0、0.0、0.0）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
乗算済みアルファの場合、</font><font style="vertical-align: inherit;">完全に透明な色</font><font style="vertical-align: inherit;">は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかなく</font><font style="vertical-align: inherit;">、これは魅力的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このカラーコンポーネントの処理の利点は次第に明らかになりますが、合成の例に戻る前に、プリマルチプライ済みアルファが他のレンダリング問題の解決にどのように役立つかを見てみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">濾過</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガウスぼかし</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、興味深いデフォーカスされた背景を作成したり</font><font style="vertical-align: inherit;">、一部のUI要素のコンテンツの背景部分の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高周波を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">減らしたりする一般的な方法</font><font style="vertical-align: inherit;">です。後で見るように、適切に見えるぼかしを作成するには、乗算前のアルファが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分析する画像は、背景を1％の不透明な青で塗りつぶして作成され、その上に不透明な赤い円が描かれます。最初に、予備的な乗算なしの例を見てみましょう。何が起こっているのかを理解するために、RGBチャネルをアルファチャネルから分離しました。矢印はぼかし操作を示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ce/0eb/7f9/1ce0eb7f9342c4d90ca7c18bb827afba.png" width="530" height="264"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初に乗算せずにコンテンツをぼかす</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
完成した結果には、醜い青いハローがあります。</font><font style="vertical-align: inherit;">これは、ぼかし中に青い背景が赤い領域に漏れ、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合成中にアルファウェイトが追加されたために発生しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
色がアルファであらかじめ乗算されている場合、結果は正しいです：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c6/9f8/aa9/2c69f8aa9cba7a689eb2094d89661576.png" width="530" height="264"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事前乗算されたコンテンツのぼかし事前乗算</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
により、画像の青色は元の強度の1％に減らされるため、ぼかされた円の色への影響は非常に小さくなります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">補間</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピクセルが宛先に完全に適合する画像をレンダリングすることは、サンプル間で簡単な1対1のマッピングを実行する必要があるため、簡単な作業です。回転、スケーリング、ハイフネーションなどにより、単純なマッピングがない場合に問題が発生します。以下の図は、赤いアウトラインで示される回転した画像のピクセルが宛先と一致しなくなったことを示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7c/55c/d9d/a7c55cd9d320d2fc5b8b4dd80622b54c.svg" width="596" height="290"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回転前と回転後の相対的な画像の向きと目的のピクセル画像から目的のピクセルに</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
書き込む色を選択する方法はたくさんありますが、最も簡単な方法はいわゆる最近傍内挿です。最後のピクセルとして、テクスチャの最も近いサンプルが選択されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に示すデモでは、赤い輪郭が目的地での画像の位置を示しています。右側は、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">視点から見たサンプルの位置</font><font style="vertical-align: inherit;">です。 （元の記事の）スライダーをドラッグすると、四角形を回転させ、サンプルがビットマップから色を選択する様子を観察できます。ソースとデスティネーションの1つのピクセルを強調表示して、それらの関係をより明確にしました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/0v/if/zd0vifjvna1jjf_apdomph8bmd0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このソリューションは非常に機能的であり、ピクセルは全体的な色を持っていますが、品質は許容できません。</font><font style="vertical-align: inherit;">サンプリングされた画像の最も近い4つのピクセルの加重平均を計算</font><font style="vertical-align: inherit;">する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイリニア補間</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用することをお</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">勧め</font></a><font style="vertical-align: inherit;">します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/s0/fy/qi/s0fyqirq3p9cpyfb5vl4gxzsz0q.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはうまく機能しますが、長方形の周りのエッジは正しく見えません。補間後にアルファが「適用」されるため、ピクセルのコンテンツは乗算なしでマージされます。</font><font style="vertical-align: inherit;">Adrian Corregerの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">驚くべき記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [Habréの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]に</font><font style="vertical-align: inherit;">示されている、適切なコンテンツの色をマージするための推奨されるソリューション</font><font style="vertical-align: inherit;">は、理想とはほど遠いです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あらかじめ乗算されたアルファと高度な数式で合成された画像ですべてがどのように見えるかを見てみましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/to/ax/zy/toaxzyjkgdouyossh7kzgkgudyi.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完璧です-私たちは色の融合をすべて取り除き、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">歯は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どこにも見えません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終的に、ぼかしと補間に関連する問題は密接に関連しています。</font><font style="vertical-align: inherit;">最初にカラーをアルファで乗算せずに、半透明カラーの任意の組み合わせを必要とする操作は、誤った結果をもたらす可能性があります。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">適切な合成</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合成に戻りましょう。</font><font style="vertical-align: inherit;">ほぼ導出された方程式で解決しました：</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事前に乗算されたアルファを使用する色を想像すると、アルファはすでにカラー値の一部であるため、これらの不快な乗算はすべて消えます。</font><font style="vertical-align: inherit;">次に、以下を取得します。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルファ方程式を見てみましょう：</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
赤、緑、青、アルファチャネルの係数は同じであるため、式全体を1つの方程式で表すことができ、各コンポーネントが同じ演算を受けることを覚えておいてください。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事前乗算されたアルファがどのように物事を簡単にしたかをご覧ください。</font><font style="vertical-align: inherit;">方程式の構成要素を分析するとき、それらはすべて適切に配置されています。</font><font style="vertical-align: inherit;">この操作</font><font style="vertical-align: inherit;">は、背景ライトの一部を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マスクし</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、新しいライトを追加します。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このミキシング操作は、source-over、sover、または単に通常と呼ばれ、間違いなく最も一般的な合成モードです。</font><font style="vertical-align: inherit;">このモードでは、私のWebサイトに表示されるほとんどすべてが混在しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関連性</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pre-alpha-multipliedカラーで実行される重要なsource-overプロパティは、</font><font style="vertical-align: inherit;">この操作の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関連性です</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">彼のおかげで、複雑な混合方程式では、括弧を完全に任意に配置できます。</font><font style="vertical-align: inherit;">以下に示す構成はすべて同等です。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R =（（（A⇨B）⇨C）⇨D）⇨ER </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
=（A⇨B）⇨（C⇨（D⇨E））</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R =A⇨（B⇨（C⇨（D⇨E）） ）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これの証明は十分簡単ですが、代数的操作で負担をかけません。</font><font style="vertical-align: inherit;">実際には、これは、最終的な構成が間違って見えることを恐れることなく、複雑な図面を部分的にレンダリングできることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、アルファはソースオーバーを使用した合成にのみ使用されますが、その利点はそれだけではありません。</font><font style="vertical-align: inherit;">アルファ値は、他の便利なレンダリング操作にも使用できます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポーターダフ合成</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1984年7月、トーマスポーターとトムダフは、オリジナルの記事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「デジタル画像の合成」を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公開しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">著者は、最初に事前乗算アルファの概念を導入し、ソースオーバー合成方程式を導き出しただけでなく、アルファ合成操作のファミリ全体を提示しました。その多くはあまり知られていませんが、非常に有用です。</font><font style="vertical-align: inherit;">新しい関数は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">も呼ばれ</font><em><font style="vertical-align: inherit;">ます</font></em><font style="vertical-align: inherit;">。これは、加算や乗算と同様に、入力値に対してアクションを実行して出力値を作成するためです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以上</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらなる例では、さまざまな描画モードの操作を示すインタラクティブなデモを使用します。</font><font style="vertical-align: inherit;">宛先イメージは黒い「クラブ」シンボルになり、ソースイメージは赤い「ワーム」シンボルになります。</font><font style="vertical-align: inherit;">画像上でハートをドラッグして、重なり合う形状がさまざまな合成演算子でどのように動作するかを観察できます。</font><font style="vertical-align: inherit;">隅にある小さなミニマップに注意してください。</font><font style="vertical-align: inherit;">いくつかの描画モードは非常に破壊的で混乱しやすいものです。</font><font style="vertical-align: inherit;">ミニマップは常に単純なソースオーバー合成の結果を表示するため、理解が簡単になります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/nb/n3/vxnbn3qhwfuiobes7rws0ardxtq.gif"></div><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S×（1-D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）+ D</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
destination-overに切り替えると、source-overが単純に「反転」することがすぐにわかります。宛先とソースが方程式で入れ替えられ、結果はdestinationをソースイメージと見なしたものと同等です。</font><font style="vertical-align: inherit;">不必要に思えますが、destination-over演算子は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">既存のコンテンツの</font><em><font style="vertical-align: inherit;">下にある</font></em><font style="vertical-align: inherit;">オブジェクトを作成できるため、非常に便利です</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アウト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
source-outおよびdestination-outステートメントは、ソースまたは宛先に穴をあけるのに最適です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/c1/pn/ou/c1pnoudiz66kdmddiaqkmdxcyuq.gif"></div><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S×（1-D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = D×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これら2つの演算子のうち、Destination-outは、アルファチャネルを使用して宛先フォームに穴を開けるため、より便利です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
source-inおよびdestination-in演算子は、基本的にマスキング演算子です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/je/jc/fxjejc-my5ewd7otz8_r2ylueas.gif"></div><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S×D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub></blockquote><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = D×S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは、ベクトルコンターの交差を計算するのが比較的難しい問題を解決せずに、重要なジオメトリの複雑な交差を非常に簡単に作成できるようにします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">頂上</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演算子</font></font><code>source-atop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とを</font></font><code>destination-atop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用して、宛先コンテンツに沿ってマスキングしながら、既存のコンテンツに新しいコンテンツをオーバーレイできます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/js/f-/2o/jsf-2on9uxoowdzpk73ugiadypw.gif"></div><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S×D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S×（1-D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）+ D×S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
排他的OR演算子（</font></font><code>xor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースまたは宛先の</font><em><font style="vertical-align: inherit;">いずれかを</font></em><font style="vertical-align: inherit;">保存し</font><font style="vertical-align: inherit;">、それらの一致する領域は消えます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/i6/uo/bmi6uoidqbrytp4e4gbmy6afvck.png"></div><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S×（1-D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）+ D×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース、宛先、クリア</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後の3つの古典的な合成モードはかなり退屈です。</font></font><code>Source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はとも呼ばれ</font></font><code>copy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、カラーソースを取得します。</font><font style="vertical-align: inherit;">同様に、</font></font><code>destination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カラーソースを無視し、単にを返します</font></font><code>destination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">オペレーターは</font></font><code>clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてをクリアします。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fw/li/mo/fwlimouoegmu9ff1r1tqno-uags.gif"></div><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S</font></font></blockquote><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = D</font></font></blockquote><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = 0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのモードの適用範囲は限られています。</font><font style="vertical-align: inherit;">これを使用する</font></font><code>clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、満たされたバッファをフラッシュできますが、この操作はメモリをゼロで満たすだけで最適化できます。</font><font style="vertical-align: inherit;">さらに、場合によって</font><font style="vertical-align: inherit;">は、混合を必要とせず、バッファの内容をソース情報に置き換えるだけなので、計算</font></font><code>source</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より経済的に</font><i><font style="vertical-align: inherit;">なる</font></i><font style="vertical-align: inherit;">場合</font><i><font style="vertical-align: inherit;">があり</font></i><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際のポーターダフ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
個々のオペレーターを扱ったので、それらを組み合わせる方法を見てみましょう。</font><font style="vertical-align: inherit;">以下の例では、マスキングや複雑な幾何学的形状を使用せずに海洋ロゴを描画します。</font><font style="vertical-align: inherit;">青い輪郭は、作成されている単純なジオメトリを示しています。</font><font style="vertical-align: inherit;">画像の右側をクリックして手順を進め、左側をクリックして戻ることができます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/-l/ct/qf-lctetuaygx6y7nwxhl95breu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、マスクを放棄して輪郭をトリミングする義務は決してありませんが、Porter-Duff合成モードなどのツールを忘れることがよくありますが、助けを借りて視覚効果を作成する方がはるかに簡単です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーター</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Porter-Duffオペレーターをよく見ると、それらはすべて同じ形式であることがわかります。</font><font style="vertical-align: inherit;">ソースは常に特定の係数F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で乗算され、係数F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dで</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乗算された宛先に追加されます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S×F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D×F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></sub></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は値0、1、D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1-D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をとることができ</font><font style="vertical-align: inherit;">、F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は0、1、</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aに</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等しいかもしれません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ソースまたはデスティネーションに独自のアルファを乗算しても意味がありません。それらはすでに事前に乗算されており、空想的ですが、非常に有用な2次アルファ効果は得られません。</font><font style="vertical-align: inherit;">すべての演算子は、テーブルの形式で表すことができます。</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody>
<tr>
<td></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">晴れ</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースイン</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースアウト</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先</font></font></td>
<td></td>
<td></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行き先</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目的地</font></font></td>
<td></td>
<td></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目的地の上</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宛先アウト</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースオーバー</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソーストップ</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XOR</font></font></td>
</tr>
</tbody>
</table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対角線上の演算子の対称性に注意してください。</font><font style="vertical-align: inherit;">テーブルの4つの中心的な要素が欠落していますが、他の要素とは異なるために発生しました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付加照明</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その記事では、ポーター及びダフはF両方が別のオペレータに提示</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とF </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dは、</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは、その名前で知られている1に等しく</font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>lighter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>plus-lighter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この操作は、基本的</font><font style="vertical-align: inherit;">に宛先に光源を</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2f/a9b/31c/a2fa9b31c91913bc0445b91ea8217670.png" width="488" height="226"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーターで実装された加法照明は、</font></font><code><em>plus</em></code></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
緑と赤が正しく黄色を形成し、緑と青がシアンを形成します。</font><font style="vertical-align: inherit;">黒は操作がないことです。数値にゼロを追加しても何も変更されないため、色の値はまったく変更されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残りの3つの演算子は特に有用ではないため、名前は付けられていません。</font><font style="vertical-align: inherit;">それらはマスキングとブレンディングの単なる組み合わせです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、事前に乗算されたアルファにより、</font></font><code>source-over</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予期しない方法で</font><font style="vertical-align: inherit;">演算子を使用できることにも注意してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">もう一度方程式を見てみましょう。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースのアルファ値をゼロに等しくすることができた場合、RGBチャネルにゼロ以外の値がある場合、演算子を使用せずに追加の照明を実現できます</font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/400/42b/fbf/40042bfbf25d98ec04a5609fcf828f39.png" width="488" height="290"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーターを使用して追加された照明</font></font><code><em>source-over</em></code></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ここで注意する必要があることに注意してください-値はアルファで正しく乗算されなくなりました。一部のプログラムでは、ゼロアルファとの色の混合を完全に回避する最適化があるかもしれませんが、他のプログラムはアルファ値による事前乗算を逆にして、いくつかの色操作を実行し、次にアルファによって再度事前乗算することができます。これにより、カラーチャネルが完全に破壊されます。また、この形式でリソースをエクスポートすることは難しい場合があるため、レンダリングパイプラインを完全に制御する能力がない場合は、演算子を使用する必要があります</font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまで説明してきたすべての要素は、これまでうまく組み合わされてきました。</font><font style="vertical-align: inherit;">さて、ピンクのメガネを外して、アルファ合成で作業するときに考慮する必要があるいくつかの問題について説明しましょう。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グループの不透明度</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6つのプリミティブだけで構成されるこの単純な錠剤の描画を見てみましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e7/b44/c84/6e7b44c84ff94dfbe3e0f2943cd44b89.png" width="512" height="208"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純な形状を使用して錠剤を描く</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
不透明度を50％にして錠剤をレンダリングするように依頼された場合、不透明度を各描画操作の半分に単純に分割したくなるかもしれませんが、これは誤りです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/63a/26b/13a63a26b176861264010a8d43aefb7a.png" width="160" height="96"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不透明度が半分の錠剤をレンダリングしたときの予期しない結果</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
正しい結果を得るには、オブジェクトの不透明度を個々のコンポーネントに分配することはできません。</font><font style="vertical-align: inherit;">最初にオブジェクトを作成してビットマップにレンダリングし、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビットマップの不透明度を変更して、最後に合成を実行する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/798/7d0/708/7987d07084e48d8b3a51e99111c8a3ae.png" width="512" height="96"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不透明度が半分の錠剤をレンダリングした</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
場合</font><i><font style="vertical-align: inherit;">の予想される結果</font></i><font style="vertical-align: inherit;">これは、サイドバッファーへのレンダリングの概念の有用性を示すもう1つのケースです。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合成カバレッジ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幾何学的なカバーを単一のアルファ値に変換すると、不快な結果になります。</font><font style="vertical-align: inherit;">以下の図にオレンジと青の輪郭で示されている、ベクトルジオメトリの図の2つの理想的に一致するエッジがビットマップにレンダリングされる場合を考えます。</font><font style="vertical-align: inherit;">理想的な世界では、各ピクセルが完全に閉じているため、結果は次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45d/728/ca1/45d728ca1d4b35c64a2a3b1499930353.svg" width="555" height="255"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正しいカバレッジで理想的なレンダリング結果が得られ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ますが、最初にオレンジのジオメトリをレンダリングし、次に青のジオメトリをレンダリングした場合、最終的な画像では少し白い背景が境界ピクセルに漏れます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2f/cdd/66f/f2fcdd66f6b53504a36c5db42c17bfc5.svg" width="555" height="255"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2ステージ合成の結果</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コーティングがアルファチャネルに保存されるとすぐに、そのすべての幾何学的情報が失われ、どのような方法でもそれを復元することはできません。青のジオメトリ</font><font style="vertical-align: inherit;">は、バッファ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツの</font><em><font style="vertical-align: inherit;">一部と</font></em><font style="vertical-align: inherit;">単純に混ざりますが</font><font style="vertical-align: inherit;">、赤みがかったピクセルで表されるジオメトリがそれに一致する必要があることはわかりません。この問題は、ジオメトリが互いに正確に重ね合わされている場合に特に顕著です。下の画像では、黒い円の上に白い円が描かれています。暗いエッジが目立ちますが、両方の円の</font><font style="vertical-align: inherit;">半径と位置</font><font style="vertical-align: inherit;">は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まったく同じ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a8/33f/e2c/9a833fe2c9881ed7c89ece47c0984f38.svg" width="180" height="180"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">黒い円の上に白い円を描画</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この問題を解決する1つの方法</font><font style="vertical-align: inherit;">は、ピクセルの部分的なカバレッジを計算せ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ず</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、非常に大きなバッファーを使用することです。単純なイン/アウトコーティングでベクタージオメトリをラスタライズし、結果のスケールを元の画像のサイズに縮小することで、期待どおりの結果を得ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、8ビットアルファチャンネルのエッジのレンダリング品質の理想的な比較のために、バッファが256倍であるべきである</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の方向、すなわち、画素数は2だけ増加すべきである</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間。</font><font style="vertical-align: inherit;">上で見たように、カバレッジ値のビット深度が減少しても、満足のいく結果が得られるため、実際にはより小さなスケールを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような問題は、多くの場合、巨大なビットマップを使用しなくても比較的簡単に回避できることにも注意してください。</font><font style="vertical-align: inherit;">たとえば、代わりに2つのつの重ね合わされた円を描画するには、単に互いの上に2つの正方形を描画することができ、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後、</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">円を形成する結果をマスク。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形値</font></font></h1><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色空間の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
知識を更新した場合</font><font style="vertical-align: inherit;">、それらのほとんどが色値を非線形にエンコードし、正しい数学的演算を実行するために予備の線形化が必要であることを覚えておくことができます。</font><font style="vertical-align: inherit;">この段階が完了すると、合成の結果は次のようになります。</font><font style="vertical-align: inherit;">重ね合わせたパーツの美しい黄色がかった色合いに注意してください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/24f/14d/bb024f14d3ede0fe13e72eb1de4a115a.png" width="280" height="300"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形値を使用して緑の背景に合成することによって重ねられたぼやけた赤い円です</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
が、ほとんどの場合、合成は</font><font style="vertical-align: inherit;">そうで</font><font style="vertical-align: inherit;">はあり</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Webおよびほとんどのグラフィックソフトウェアの標準的な方法は、非線形値を直接混合することです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/245/77c/a2e/24577ca2e1dd42a2ef6c2ef1d33884d9.png" width="280" height="300"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非線形の値を使用して緑の背景に作曲家によって重ねられたぼやけた赤い円</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
緑のオーバーレイの赤が</font><i><font style="vertical-align: inherit;">重なっ</font></i><font style="vertical-align: inherit;">ている領域がはるかに暗い</font><i><font style="vertical-align: inherit;">ことに</font></i><font style="vertical-align: inherit;">注意してください。</font><font style="vertical-align: inherit;">それらは理想からはほど遠いですが、不適切な操作は、私たちが色をどのように認識するかを理解することに深く根ざしています。</font><font style="vertical-align: inherit;">たとえば、sRGBスペースからの50％の不透明な灰色は、50％の不透明度と白い背景を混ぜ合わせた純粋な黒のように見えます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/366/ca1/573/366ca1573d720de845ce276d7ef0d5b4.svg" width="405" height="133"></div><br>
<i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形化</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なしの</font><i><font style="vertical-align: inherit;">白い背景上での2色の合成</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
下の図では、ソース画像と宛先画像のsRGBカラーが線形化され、表示用に非線形エンコーディングに変換されています。</font><font style="vertical-align: inherit;">これらの色が実際にどのように見えるかを次に示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ae/c74/90a/1aec7490a8fdf2a096f5e4c8f2b56cdc.svg" width="405" height="133"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">白い背景の上の2つの色の構成</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形化。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
我々は我々の期待を満たしていない矛盾を持っています。</font><font style="vertical-align: inherit;">この方法を使用して視覚的な均一性を得る唯一の方法は、線形値を使用してすべての色を選択することですが、これは誰もが慣れている方法とは大きく異なります。</font><font style="vertical-align: inherit;">線形値の50％グレーは、sRGB空間の73.5％でグレーのように見えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、あらかじめ乗算されたアルファを使用する場合は特に注意する必要があります。</font><font style="vertical-align: inherit;">事前乗算は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値で</font><font style="vertical-align: inherit;">実行する必要があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">非線形にコーディングする前。</font><font style="vertical-align: inherit;">これのおかげで、線形化ステップは、以前にアルファを掛けた正しい線形値で正しく終了します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乗算済みアルファとビット深度</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合成、フィルタリング、補間のための優れたユーティリティにもかかわらず、プリマルチプライドアルファは「特効薬」ではなく、欠点があります。</font><font style="vertical-align: inherit;">それらの中で最も深刻なのは、想像できる色のビット深度の減少です。</font><font style="vertical-align: inherit;">150の値の8ビットエンコーディングを想像してください。これはアルファ20％であらかじめ乗算されています。</font><font style="vertical-align: inherit;">アルファによる予備的な乗算の後、</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラウンド（150×0.2）= 30</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
151の値で同じ手順を繰り返すと、次のようになります。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラウンド（151×0.2）= 30</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期値が異なっていても、エンコードされた値は同じです。</font><font style="vertical-align: inherit;">実際、アルファを掛けた後、148、149、150、151、および152の値は30にエンコードされ、これらの5つの固有の色の間の元の違いは失われます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af3/a80/76c/af3a8076caef4fdae6146e6d503ea639.svg" width="560" height="203"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20％のアルファによる事前乗算は、さまざまな8ビット値を1に減らします。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
当然、アルファが小さいほど、その効果はより破壊的です。 256の可能な範囲</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（約43億）の8ビットRGBA値のさまざまな組み合わせのうち、アルファによる予備的な乗算の後、一意の表現を保持しているのは25.2％だけです。実際、32ビットの範囲からほぼ2ビットが失われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異なる色空間間で色を変換するには、事前の乗算を逆にする必要がある場合があります。つまり、値をアルファコンポーネントに分割して、元の色の明るさを取得します。上記のように、エンコードは非線形で実行されるため、この手順が必要です。事前乗算が存在すると、色表現の精度が低下し、色空間間の変換は理想的ではない場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、ビット深度を減らすことは、特に合成においてはほとんど重要ではありません。アルファ値が低いほど、色が見えにくくなり、合成への影響​​が少なくなります。結局のところ、細心の注意を払って色を正確に操作しようとする場合は、8ビット表現を使用しないことになります-この目的のために、フォーマットははるかに適しています</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浮動小数点</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加の読書</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルファチャネルのコンセプトは、Pixarの共同創設者である</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Elvy </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smith</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ed Catmell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって作成され</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ました</font></a><font style="vertical-align: inherit;">。スミスの記事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「アルファとデジタル合成</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の歴史</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">」では</font></a><font style="vertical-align: inherit;">、発明の歴史と「アルファ」という名前の出典、およびこれらの概念がどのように進化し、映画制作における</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マスク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の概念に徐々に取って代わったかについて説明しています</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルファの意味を理解するには、Andrew Glassnerの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Interpreting Alpha」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を読むことを強くお勧めします</font><font style="vertical-align: inherit;">。この記事では、不透明度とカバレッジの間の相互作用の尺度として、厳密だが非常にアクセスしやすいアルファの数学的導出を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事前乗算されたアルファの詳細な説明は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「GPUは事前乗算を好む」にあります。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エリック・ヘインズ </font><font style="vertical-align: inherit;">この記事は</font><font style="vertical-align: inherit;">、特に3Dレンダリング</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">での</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予備的な乗算</font><font style="vertical-align: inherit;">の</font><em><font style="vertical-align: inherit;">欠如</font></em><font style="vertical-align: inherit;">によって引き起こされる問題の優れた概要を提供するだけでなく</font><font style="vertical-align: inherit;">、このトピックに関する他の多くの記事へのリンクも提供します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最終的に</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当初、この記事はPorter-Duff合成オペレーターの説明として考えられましたが、アルファ合成に関連する他のすべての概念は非常に興味深く、見逃すことはできませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルファについて私が最も気に入っているのは、RGBコンポーネントに付随する追加の数値に過ぎないということですが、同時に多くのユニークなレンダリング機能を生み出します。</font><font style="vertical-align: inherit;">Alphaは文字通り、合成と2Dレンダリングの退屈な古い世界に新たな機会の変化をもたらしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次回、ベクトルシェイプの滑らかなエッジを表示したり、ユーザーインターフェースの一部を覆い隠す暗いオーバーレイに気づいたりしたときは、それをすべて可能にした小さいながらも強力なコンポーネントを考えてください。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja468057/index.html">UnixライクなOS開発-マルチタスクとシステムコール（7）</a></li>
<li><a href="../ja468059/index.html">ハイクとの2週目：隠されたたくさんのダイヤモンドと楽しいサプライズ、そしていくつかの問題</a></li>
<li><a href="../ja468061/index.html">LinuxのCron：履歴、使用方法、デバイス</a></li>
<li><a href="../ja468063/index.html">Angulareact</a></li>
<li><a href="../ja468065/index.html">皆のための精神的な製品管理モデル</a></li>
<li><a href="../ja468071/index.html">Tungsten LabsのCTOであるEduard Medvedev氏：「テクノロジーが大規模な損害を引き起こす可能性があるところまで成長しました」</a></li>
<li><a href="../ja468073/index.html">Andrei Terekhov：「アメリカ人の方がいいと言っていいほど話せますが、車は故障しません」</a></li>
<li><a href="../ja468075/index.html">検索におけるシャムニューラルネットワークの使用</a></li>
<li><a href="../ja468077/index.html">大人の方法でテストを行います。スペクトル分析</a></li>
<li><a href="../ja468079/index.html">何度も節約してくれたGoogle Analyticsのカスタムディメンション</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>