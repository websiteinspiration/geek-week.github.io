<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèΩ üì∑ üì¢ Escribir una API en Rust usando macros de procedimiento üî¨ üéõÔ∏è üë©üèø‚Äçü§ù‚Äçüë©üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las macros de procedimiento en Rust es una herramienta de generaci√≥n de c√≥digo muy poderosa que le permite prescindir de escribir una tonelada de c√≥di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Escribir una API en Rust usando macros de procedimiento</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486740/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las macros de procedimiento en Rust es una herramienta de generaci√≥n de c√≥digo muy poderosa que le permite prescindir de escribir una tonelada de c√≥digo repetitivo, o expresar algunos conceptos nuevos, como lo hicieron los desarrolladores de la caja, por ejemplo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>async_trait</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, muchas personas tienen miedo justificado de usar esta herramienta, principalmente debido al hecho de que analizar el √°rbol de sintaxis y los atributos de macro a menudo se convierte en una "puesta de sol manualmente", ya que el problema debe resolverse a un nivel muy bajo.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este art√≠culo quiero compartir algunos, en mi opini√≥n, enfoques exitosos para escribir macros de procedimiento, y mostrar que hoy las macros de procedimiento se pueden crear de manera relativamente simple y conveniente.</font></font></p><a name="habracut"></a><br>
<h2 id="predislovie"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefacio</font></font></h2><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar, definamos el problema que resolveremos con la ayuda de macros: intentaremos definir una </font><font style="vertical-align: inherit;">API </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RPC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abstracta </font><font style="vertical-align: inherit;">en forma de rasgo, que luego implementa tanto la parte del servidor como la parte del cliente; </font><font style="vertical-align: inherit;">y las macros de procedimiento, a su vez, nos ayudar√°n a prescindir de un mont√≥n de c√≥digo repetitivo. </font><font style="vertical-align: inherit;">A pesar del hecho de que implementaremos una API algo abstracta, la tarea es realmente vital y, entre otras cosas, es ideal para demostrar las capacidades de las macros de procedimiento.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La API en s√≠ se ejecutar√° de acuerdo con un principio muy simple: hay 4 tipos de solicitudes:</font></font></p><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peticiones GET sin par√°metros, por ejemplo: </font></font><code>/ping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peticiones GET con los par√°metros, los par√°metros de los cuales se transmitir√°n en forma de una consulta URL, por ejemplo: </font></font><code>/status?name=foo&amp;count=15</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solicitudes POST sin par√°metros.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solicitudes POST con par√°metros que se pasan como objetos JSON.</font></font></li>
</ul><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En todos los casos, el servidor responder√° con un objeto JSON v√°lido.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como servidor back-end, utilizaremos la caja </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>warp</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealmente, quiero obtener algo como esto:</font></font></p><br>
<pre><code class="rust hljs"><span class="hljs-comment">//  :</span><font></font>
<font></font>
<span class="hljs-comment">/// ,   .      URL query,    JSON.</span>
<span class="hljs-meta">#[derive(Debug, FromUrlQuery, Deserialize, Serialize)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Query</span></span> {<font></font>
    first: <span class="hljs-built_in">String</span>,<font></font>
    second: <span class="hljs-built_in">u64</span>,<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">///  ,      </span>
<span class="hljs-comment">///  API  warp'.</span>
<span class="hljs-meta">#[http_api(warp = <span class="hljs-meta-string">"serve_ping_interface"</span>)]</span>
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PingInterface</span></span> {
    <span class="hljs-meta">#[http_api_endpoint(method = <span class="hljs-meta-string">"get"</span>)]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;Query, Error&gt;;
    <span class="hljs-meta">#[http_api_endpoint(method = <span class="hljs-meta-string">"get"</span>)]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">check</span></span>(&amp;<span class="hljs-keyword">self</span>, query: Query) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">bool</span>, Error&gt;;
    <span class="hljs-meta">#[http_api_endpoint(method = <span class="hljs-meta-string">"post"</span>)]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_value</span></span>(&amp;<span class="hljs-keyword">self</span>, param: Query) -&gt; <span class="hljs-built_in">Result</span>&lt;(), Error&gt;;
    <span class="hljs-meta">#[http_api_endpoint(method = <span class="hljs-meta-string">"post"</span>)]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">increment</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;(), Error&gt;;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//    :</span><font></font>
<font></font>
<span class="hljs-comment">///  ,     .</span>
<span class="hljs-meta">#[derive(Debug, Default)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ServiceInner</span></span> {<font></font>
    first: <span class="hljs-built_in">String</span>,<font></font>
    second: <span class="hljs-built_in">u64</span>,<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">///  ,      .</span>
<span class="hljs-meta">#[derive(Clone, Default)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ServiceImpl</span></span>(Arc&lt;RwLock&lt;ServiceInner&gt;&gt;);<font></font>
<font></font>
<span class="hljs-keyword">impl</span> ServiceImpl {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; <span class="hljs-keyword">Self</span> {<font></font>
        Self::default()<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; RwLockReadGuard&lt;ServiceInner&gt; {
        <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.read().unwrap()<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">write</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; RwLockWriteGuard&lt;ServiceInner&gt; {
        <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.write().unwrap()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//    :</span><font></font>
<font></font>
<span class="hljs-keyword">impl</span> PingInterface <span class="hljs-keyword">for</span> ServiceImpl {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;Query, Error&gt; {
        <span class="hljs-keyword">let</span> inner = <span class="hljs-keyword">self</span>.read();
        <span class="hljs-literal">Ok</span>(Query {<font></font>
            first: inner.first.clone(),<font></font>
            second: inner.second,<font></font>
        })<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">check</span></span>(&amp;<span class="hljs-keyword">self</span>, query: Query) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">bool</span>, Error&gt; {
        <span class="hljs-keyword">let</span> inner = <span class="hljs-keyword">self</span>.read();
        <span class="hljs-literal">Ok</span>(inner.first == query.first &amp;&amp; inner.second == query.second)<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_value</span></span>(&amp;<span class="hljs-keyword">self</span>, param: Query) -&gt; <span class="hljs-built_in">Result</span>&lt;(), Error&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> inner = <span class="hljs-keyword">self</span>.write();<font></font>
        inner.first = param.first;<font></font>
        inner.second = param.second;<font></font>
        <span class="hljs-literal">Ok</span>(())<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">increment</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;(), Error&gt; {
        <span class="hljs-keyword">self</span>.write().second += <span class="hljs-number">1</span>;
        <span class="hljs-literal">Ok</span>(())<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#[tokio::main]</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> addr: SocketAddr = <span class="hljs-string">"127.0.0.1:8080"</span>.parse().unwrap();
    <span class="hljs-comment">//          API</span>
    serve_ping_interface(ServiceImpl::new(), addr).<span class="hljs-keyword">await</span>
}</code></pre><br>
<p>  ,     Rust'     ,       ,     ,        .<br>
          : derive-,      -  (     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>serde</code></a>),   ,       .</p><br>
<p>           ,        : <code>http_api</code>,         ,  <code>http_api_derive</code>   .</p><br>
<h2 id="sozdaem-makros-fromurlquery">  FromUrlQuery</h2><br>
<p>  ,        ‚Äî    ,    ,        . ,    -   ,          .</p><br>
<p>, .        URL query.          ,     .    :</p><br>
<pre><code class="rust hljs"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">FromUrlQuery</span></span>: <span class="hljs-built_in">Sized</span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from_query_str</span></span>(query: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>, ParseQueryError&gt;;<font></font>
}</code></pre><br>
<p>      ,    .       derive      :</p><br>
<pre><code class="rust hljs"><span class="hljs-comment">///        `#[derive(FromUrlQuery)]`,     </span>
<span class="hljs-comment">///    #[from_url_query(rename = "bar", skip, etc)]</span>
<span class="hljs-meta">#[proc_macro_derive(FromUrlQuery, attributes(from_url_query))]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from_url_query</span></span>(input: TokenStream) -&gt; TokenStream {<font></font>
    from_url_query::impl_from_url_query(input)<font></font>
}</code></pre><br>
<p>      ‚Äî   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>syn</code></a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>quote</code></a>.     <code>Rust</code> ,       ,    .<br>
       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>quote!</code></a>,            Rust ,        .<br>
         ,    ,   ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>darling</code></a>.                   ( ,      ).</p><br>
<div class="spoiler"><b class="spoiler_title">    ,    ** **.      :</b><div class="spoiler_text"><p>   AST      ,     ,    .</p><br>
<pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_field_names</span></span>(input: &amp;DeriveInput) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">Vec</span>&lt;(Ident, Action)&gt;&gt; {
    <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">match</span> &amp;input.data {<font></font>
        Data::Struct(x) =&gt; <span class="hljs-literal">Some</span>(x),<font></font>
        Data::Enum(..) =&gt; <span class="hljs-literal">None</span>,<font></font>
        _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"Protobuf convert can be derived for structs and enums only."</span>),<font></font>
    };<font></font>
    data.map(|data| {<font></font>
        data.fields<font></font>
            .iter()<font></font>
            .map(|f| {<font></font>
                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> action = Action::Convert;
                <span class="hljs-keyword">for</span> attr <span class="hljs-keyword">in</span> &amp;f.attrs {
                    <span class="hljs-keyword">match</span> attr.parse_meta() {
                        <span class="hljs-literal">Ok</span>(syn::Meta::List(<span class="hljs-keyword">ref</span> meta)) <span class="hljs-keyword">if</span> meta.ident == <span class="hljs-string">"protobuf_convert"</span> =&gt; {
                            <span class="hljs-keyword">for</span> nested <span class="hljs-keyword">in</span> &amp;meta.nested {
                                <span class="hljs-keyword">match</span> nested {<font></font>
                                    syn::NestedMeta::Meta(syn::Meta::Word(ident))<font></font>
                                        <span class="hljs-keyword">if</span> ident == <span class="hljs-string">"skip"</span> =&gt;<font></font>
                                    {<font></font>
                                        action = Action::Skip;<font></font>
                                    }<font></font>
                                    _ =&gt; {<font></font>
                                        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"Unknown attribute"</span>);<font></font>
                                    }<font></font>
                                }<font></font>
                            }<font></font>
                        }<font></font>
                        _ =&gt; {<font></font>
                            <span class="hljs-comment">// Other attributes are ignored</span><font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
                (f.ident.clone().unwrap(), action)<font></font>
            })<font></font>
            .collect()<font></font>
    })<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_field_names_enum</span></span>(input: &amp;DeriveInput) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">Vec</span>&lt;Ident&gt;&gt; {
    <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">match</span> &amp;input.data {<font></font>
        Data::Struct(..) =&gt; <span class="hljs-literal">None</span>,<font></font>
        Data::Enum(x) =&gt; <span class="hljs-literal">Some</span>(x),<font></font>
        _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"Protobuf convert can be derived for structs and enums only."</span>),<font></font>
    };<font></font>
    data.map(|data| data.variants.iter().map(|f| f.ident.clone()).collect())<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">implement_protobuf_convert_from_pb</span></span>(field_names: &amp;[(Ident, Action)]) -&gt; <span class="hljs-keyword">impl</span> quote::ToTokens {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> to_convert = <span class="hljs-built_in">vec!</span>[];
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> to_skip = <span class="hljs-built_in">vec!</span>[];
    <span class="hljs-keyword">for</span> (x, a) <span class="hljs-keyword">in</span> field_names {
        <span class="hljs-keyword">match</span> a {<font></font>
            Action::Convert =&gt; to_convert.push(x),<font></font>
            Action::Skip =&gt; to_skip.push(x),<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">let</span> getters = to_convert<font></font>
        .iter()<font></font>
        .map(|i| Ident::new(&amp;<span class="hljs-built_in">format!</span>(<span class="hljs-string">"get_{}"</span>, i), Span::call_site()));
    <span class="hljs-keyword">let</span> our_struct_names = to_convert.clone();
    <span class="hljs-keyword">let</span> our_struct_names_skip = to_skip;<font></font>
<font></font>
    quote! {<font></font>
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from_pb</span></span>(pb: Self::ProtoStruct) -&gt; std::result::<span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>, _FailureError&gt; {
          <span class="hljs-literal">Ok</span>(<span class="hljs-keyword">Self</span> {<font></font>
           #( #our_struct_names: ProtobufConvert::from_pb(pb.#getters().to_owned())?, )*<font></font>
           #( #our_struct_names_skip: <span class="hljs-built_in">Default</span>::default(), )*<font></font>
          })<font></font>
        }<font></font>
    }<font></font>
}</code></pre></div></div><br>
<p>     <code>darling</code>,           .</p><br>
<p> ,     <code>FromUrlQuery</code>,    ,                 .  ,   -  :</p><br>
<pre><code class="rust hljs"><span class="hljs-meta">#[derive(FromUrlQuery)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OptionalQuery</span></span> {<font></font>
    first: <span class="hljs-built_in">String</span>,<font></font>
    opt_value: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u64</span>&gt;,<font></font>
}</code></pre><br>
<p> <code>darling</code>'    ,        .</p><br>
<p>  ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>FromField</code></a>,           :</p><br>
<pre><code class="rust hljs"><span class="hljs-meta">#[derive(Clone, Debug, FromField)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueryField</span></span> {<font></font>
    ident: <span class="hljs-built_in">Option</span>&lt;syn::Ident&gt;,<font></font>
    ty: syn::Type,<font></font>
}</code></pre><br>
<p> ,        ,     ,       :</p><br>
<pre><code class="rust hljs"><span class="hljs-meta">#[derive(Clone, Debug, FromField)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueryField</span></span> {<font></font>
    ident: <span class="hljs-built_in">Option</span>&lt;syn::Ident&gt;,<font></font>
    ty: syn::Type,<font></font>
    vis: syn::Visibility,<font></font>
}</code></pre><br>
<p>    ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>FromDeriveInput</code></a>,         :</p><br>
<pre><code class="rust hljs"><span class="hljs-meta">#[derive(Debug, FromDeriveInput)]</span>
<span class="hljs-comment">//         </span>
<span class="hljs-comment">// ,          </span>
<span class="hljs-comment">//  ,   .</span>
<span class="hljs-meta">#[darling(supports(struct_named))]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FromUrlQuery</span></span> {<font></font>
    ident: syn::Ident,<font></font>
    <span class="hljs-comment">//           </span>
    <span class="hljs-comment">//  .</span>
    <span class="hljs-comment">//  darling::ast::Data   :   </span>
    <span class="hljs-comment">// ,     .</span>
    <span class="hljs-comment">//         ,   </span>
    <span class="hljs-comment">//   ().</span><font></font>
    data: darling::ast::Data&lt;(), QueryField&gt;,<font></font>
}</code></pre><br>
<p> ,     .</p><br>
<pre><code class="rust hljs"><span class="hljs-keyword">let</span> input: DeriveInput = syn::parse(input).unwrap();
<span class="hljs-keyword">let</span> from_url_query = <span class="hljs-keyword">match</span> FromUrlQuery::from_derive_input(&amp;input) {
    <span class="hljs-literal">Ok</span>(parsed) =&gt; parsed,
    <span class="hljs-literal">Err</span>(e) =&gt; <span class="hljs-keyword">return</span> e.write_errors().into(),<font></font>
};</code></pre><br>
<p>    .</p><br>
<p>     ,      URL query  <code>serde</code>.     <code>serde</code>  ,       .            <code>Deserialize</code>,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>serde_urlencoded</code></a>.        <code>serde</code>  ,      .</p><br>
<pre><code class="rust hljs"><span class="hljs-meta">#[doc(hidden)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> export {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> serde;
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> serde_derive;
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> serde_urlencoded;<font></font>
}</code></pre><br>
<p>  ,         <code>FromUrlQuery</code>:</p><br>
<pre><code class="rust hljs"><span class="hljs-keyword">impl</span> FromUrlQuery {
    <span class="hljs-comment">//     ,      </span>
    <span class="hljs-comment">//  "Serde".</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serde_wrapper_ident</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; syn::Ident {
        <span class="hljs-keyword">let</span> ident_str = <span class="hljs-built_in">format!</span>(<span class="hljs-string">"{}Serde"</span>, <span class="hljs-keyword">self</span>.ident);<font></font>
        syn::Ident::new(&amp;ident_str, proc_macro2::Span::call_site())<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">///        .</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">impl_serde_wrapper</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-keyword">impl</span> ToTokens {
        <span class="hljs-comment">//          </span>
        <span class="hljs-comment">// ,     `unwrap`  .</span>
        <span class="hljs-keyword">let</span> fields = <span class="hljs-keyword">self</span>.data.clone().take_struct().unwrap();
        <span class="hljs-comment">//         ,   </span>
        <span class="hljs-comment">//   Query  SerdeQuery,   .</span>
        <span class="hljs-keyword">let</span> wrapped_fields = fields.iter().map(|field| {
            <span class="hljs-keyword">let</span> ident = &amp;field.ident;
            <span class="hljs-keyword">let</span> ty = &amp;field.ty;<font></font>
            quote! { #ident: #ty }<font></font>
        });<font></font>
        <span class="hljs-keyword">let</span> from_fields = fields.iter().map(|field| {
            <span class="hljs-keyword">let</span> ident = &amp;field.ident;<font></font>
            quote! { #ident: v.#ident }<font></font>
        });<font></font>
<font></font>
        <span class="hljs-keyword">let</span> wrapped_ident = <span class="hljs-keyword">self</span>.serde_wrapper_ident();
        <span class="hljs-keyword">let</span> ident = &amp;<span class="hljs-keyword">self</span>.ident;<font></font>
<font></font>
        <span class="hljs-comment">//    ,      `quote!`</span>
        <span class="hljs-comment">//         , </span>
        <span class="hljs-comment">//  ,    "#"  "$".</span><font></font>
        quote! {<font></font>
            <span class="hljs-comment">//  serde    .</span>
            <span class="hljs-keyword">use</span> http_api::export::serde_derive::Deserialize;<font></font>
<font></font>
            <span class="hljs-meta">#[derive(Deserialize)]</span>
            <span class="hljs-comment">//    serde   ,   </span>
            <span class="hljs-comment">//  .</span>
            <span class="hljs-meta">#[serde(crate = <span class="hljs-meta-string">"http_api::export::serde"</span>)]</span>
            <span class="hljs-class"><span class="hljs-keyword">struct</span> #<span class="hljs-title">wrapped_ident</span></span> {<font></font>
                #( #wrapped_fields, )*<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">impl</span> <span class="hljs-built_in">From</span>&lt;#wrapped_ident&gt; <span class="hljs-keyword">for</span> #ident {
                <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(v: #wrapped_ident) -&gt; <span class="hljs-keyword">Self</span> {
                    <span class="hljs-keyword">Self</span> {<font></font>
                        #( #from_fields, )*<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<p>,          ,      ,   ,         ,         . ,  ,      ;    <del></del> ,       ,  .</p><br>
<h2 id="pishem-makros-http_api">  http_api</h2><br>
<p>      <code>FromDeriveInput</code>,   <code>darling</code>'      ,        AST.     ,   ,   :</p><br>
<p>         :</p><br>
<pre><code class="rust hljs"><span class="hljs-meta">#[proc_macro_attribute]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">http_api</span></span>(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    <span class="hljs-comment">//     :    ,  </span>
    <span class="hljs-comment">//     AST  .</span><font></font>
    http_api::impl_http_api(attr, item)<font></font>
}</code></pre><br>
<p>     ,         :    ,              (,   <code>http_api_endpoint</code>),      . ,      <code>TokenStream</code>,          "cannot find attribute <code>http_api_endpoint</code> in this scope",     .    ,        ,   ,    .  ,        ,   ,    .</p><br>
<p>   ,      <code>http_api_endpoint</code>,     ,         .</p><br>
<pre><code class="rust hljs"><span class="hljs-meta">#[proc_macro_attribute]</span>
<span class="hljs-meta">#[doc(hidden)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">http_api_endpoint</span></span>(_attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    <span class="hljs-comment">//      ,   `http_api_endpoint`</span>
    <span class="hljs-comment">//       `http_api` .</span><font></font>
<font></font>
    <span class="hljs-comment">//    `http_api_endpoint`  </span>
    <span class="hljs-comment">//   , ,  rustc  </span>
    <span class="hljs-comment">//   .</span><font></font>
    item<font></font>
}</code></pre><br>
<p>  ,    ,       .</p><br>
<h2 id="razbiraem-metody-interfeysnogo-treyta">   </h2><br>
<p>   ,        ,        :</p><br>
<pre><code class="rust hljs"><span class="hljs-comment">//    :</span>
<span class="hljs-meta">#[http_api_endpoint(method = <span class="hljs-meta-string">"#method_type"</span>)]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> #<span class="hljs-title">method_name</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;$ResponseType, Error&gt;;
<span class="hljs-comment">//     :</span>
<span class="hljs-meta">#[http_api_endpoint(method = <span class="hljs-meta-string">"#method_type"</span>)]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> #<span class="hljs-title">method_name</span></span>(&amp;<span class="hljs-keyword">self</span>, query: $QueryType) -&gt; <span class="hljs-built_in">Result</span>&lt;$ResponseType, Error&gt;;</code></pre><br>
<p>  HTTP ,    :</p><br>
<pre><code class="rust hljs"><span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SupportedHttpMethod</span></span> {<font></font>
    Get,<font></font>
    Post,<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">impl</span> FromMeta <span class="hljs-keyword">for</span> SupportedHttpMethod {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from_string</span></span>(value: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>, darling::Error&gt; {
        <span class="hljs-keyword">match</span> value {
            <span class="hljs-string">"get"</span> =&gt; <span class="hljs-literal">Ok</span>(SupportedHttpMethod::Get),
            <span class="hljs-string">"post"</span> =&gt; <span class="hljs-literal">Ok</span>(SupportedHttpMethod::Post),<font></font>
            other =&gt; <span class="hljs-literal">Err</span>(darling::Error::unknown_value(other)),<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<p>     ,    :</p><br>
<pre><code class="rust hljs"><span class="hljs-meta">#[derive(Debug, FromMeta)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EndpointAttrs</span></span> {
    <span class="hljs-comment">//    ,      </span>
    <span class="hljs-comment">//  .</span><font></font>
    method: SupportedHttpMethod,<font></font>
    <span class="hljs-comment">//     ,     </span>
    <span class="hljs-comment">//  None,       :</span>
    <span class="hljs-comment">// #[http_api_endpoint(method = "get", rename = "foo")]</span>
    <span class="hljs-meta">#[darling(default)]</span>
    rename: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">String</span>&gt;,<font></font>
}</code></pre><br>
<p>    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>syn::Signature</code></a>,         darling'    :        ,             <code>FromMeta</code>.<br>
        <code>http_api_endpoint</code>     .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>syn::NestedMeta</code></a>  ,        <code>(foo = "bar", boo(first, second))</code>.</p><br>
<pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">find_meta_attrs</span></span>(name: &amp;<span class="hljs-built_in">str</span>, args: &amp;[syn::Attribute]) -&gt; <span class="hljs-built_in">Option</span>&lt;syn::NestedMeta&gt; {<font></font>
    args.as_ref()<font></font>
        .iter()<font></font>
        .filter_map(|a| a.parse_meta().ok())<font></font>
        .find(|m| m.path().is_ident(name))<font></font>
        .map(syn::NestedMeta::from)<font></font>
}</code></pre><br>
<p>     .     ,   <br>
  ‚Äî      :</p><br>
<pre><code class="rust hljs"><span class="hljs-comment">///      .</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">invalid_method</span></span>(span: &amp;<span class="hljs-keyword">impl</span> syn::spanned::Spanned) -&gt; darling::Error {<font></font>
    darling::Error::custom(<font></font>
        <span class="hljs-string">"API method should have one of `fn foo(&amp;self) -&gt; Result&lt;Bar, Error&gt;` or \
         `fn foo(&amp;self, arg: Foo) -&gt; Result&lt;Bar, Error&gt;` form"</span>,<font></font>
    )<font></font>
    .with_span(span)<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">impl</span> ParsedEndpoint {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse</span></span>(sig: &amp;syn::Signature, attrs: &amp;[syn::Attribute]) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>, darling::Error&gt; {
        <span class="hljs-comment">///      .</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> args = sig.inputs.iter();<font></font>
<font></font>
        <span class="hljs-comment">// ,     -   &amp;self   ,</span>
        <span class="hljs-comment">//    &amp;mut self,   &amp;self: Arc&lt;Self&gt;  </span>
        <span class="hljs-comment">//  .</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(arg) = args.next() {
            <span class="hljs-keyword">match</span> arg {
                <span class="hljs-comment">// `self`  `syn`   Receiver.</span><font></font>
                syn::FnArg::Receiver(syn::Receiver {<font></font>
                    <span class="hljs-comment">//  `reference`  ,     </span>
                    <span class="hljs-comment">// `&amp;self`.</span>
                    reference: <span class="hljs-literal">Some</span>(_),
                    <span class="hljs-comment">//  `mutability`   ,   </span>
                    <span class="hljs-comment">//    `mut`.</span>
                    mutability: <span class="hljs-literal">None</span>,
                    <span class="hljs-comment">//      .</span><font></font>
                    ..<font></font>
                }) =&gt; {<font></font>
                    <span class="hljs-comment">//  ,    .</span><font></font>
                }<font></font>
                _ =&gt; {<font></font>
                    <span class="hljs-comment">//   -  ,  </span>
                    <span class="hljs-comment">//   .</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(invalid_method(&amp;arg));<font></font>
                }<font></font>
            }<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(invalid_method(&amp;sig));<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">//    .</span>
        <span class="hljs-keyword">let</span> arg = args<font></font>
            .next()<font></font>
            .map(|arg| <span class="hljs-keyword">match</span> arg {
                <span class="hljs-comment">// `FnArg`    `Typed`,  `Receiver`,  `Receiver`</span>
                <span class="hljs-comment">//      ,   </span>
                <span class="hljs-comment">//   .</span>
                syn::FnArg::Typed(arg) =&gt; <span class="hljs-literal">Ok</span>(arg.ty.clone()),
                <span class="hljs-comment">//      `self`.</span>
                _ =&gt; <span class="hljs-built_in">unreachable!</span>(<span class="hljs-string">"Only first argument can be receiver."</span>),<font></font>
            })<font></font>
            <span class="hljs-comment">// Transpose   ,  </span>
            <span class="hljs-comment">// `Option&lt;Result&lt;...&gt;&gt;`  `Result&lt;Option&lt;...&gt;&gt;`,   </span>
            <span class="hljs-comment">//  .</span><font></font>
            .transpose()?;<font></font>
<font></font>
        <span class="hljs-comment">//    ,     `Typed`,</span>
        <span class="hljs-comment">//   `Receiver`.</span>
        <span class="hljs-keyword">let</span> ret = <span class="hljs-keyword">match</span> &amp;sig.output {<font></font>
            syn::ReturnType::Type(_, ty) =&gt; <span class="hljs-literal">Ok</span>(ty.clone()),<font></font>
            _ =&gt; <span class="hljs-literal">Err</span>(invalid_method(&amp;sig)),<font></font>
        }?;<font></font>
<font></font>
        <span class="hljs-comment">// ,    ,   , </span>
        <span class="hljs-comment">//   .</span>
        <span class="hljs-comment">//   `FromMeta::from_nested_meta`    .</span>
        <span class="hljs-keyword">let</span> attrs = find_meta_attrs(<span class="hljs-string">"http_api_endpoint"</span>, attrs)<font></font>
            .map(|meta| EndpointAttrs::from_nested_meta(&amp;meta))<font></font>
            .unwrap_or_else(|| <span class="hljs-literal">Err</span>(darling::Error::custom(<span class="hljs-string">"todo"</span>)))?;<font></font>
<font></font>
        <span class="hljs-comment">/// ,    ,   .</span>
        <span class="hljs-literal">Ok</span>(<span class="hljs-keyword">Self</span> {<font></font>
            ident: sig.ident.clone(),<font></font>
            arg,<font></font>
            ret,<font></font>
            attrs,<font></font>
        })<font></font>
    }<font></font>
}</code></pre><br>
<h2 id="razbiraem-interfeysnyy-treyt-celikom">   </h2><br>
<p>         .       ,     ,    .<br>
 ,       :</p><br>
<pre><code class="rust hljs">
<span class="hljs-comment">///    ,     </span>
<span class="hljs-comment">///  .</span>
<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ParsedApiDefinition</span></span> {
    <span class="hljs-comment">///  ,    .     </span>
    <span class="hljs-comment">///     .</span><font></font>
    item_trait: syn::ItemTrait,<font></font>
    <span class="hljs-comment">///   .</span>
    endpoints: <span class="hljs-built_in">Vec</span>&lt;ParsedEndpoint&gt;,
    <span class="hljs-comment">///   .</span><font></font>
    attrs: ApiAttrs,<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#[derive(Debug, FromMeta)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ApiAttrs</span></span> {
    <span class="hljs-comment">///     ,   </span>
    <span class="hljs-comment">///    warp'.</span><font></font>
    warp: syn::Ident,<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">impl</span> ParsedApiDefinition {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse</span></span>(<font></font>
        item_trait: syn::ItemTrait,<font></font>
        attrs: &amp;[syn::NestedMeta],<font></font>
    ) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>, darling::Error&gt; {
        <span class="hljs-comment">//       ,    </span>
        <span class="hljs-comment">//  ,       , </span>
        <span class="hljs-comment">//   .</span>
        <span class="hljs-keyword">let</span> endpoints = item_trait<font></font>
            .items<font></font>
            .iter()<font></font>
            .filter_map(|item| {<font></font>
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> syn::TraitItem::Method(method) = item {
                    <span class="hljs-literal">Some</span>(method)<font></font>
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-literal">None</span><font></font>
                }<font></font>
            })<font></font>
            .map(|method| ParsedEndpoint::parse(&amp;method.sig, method.attrs.as_ref()))<font></font>
            .collect::&lt;<span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">Vec</span>&lt;_&gt;, darling::Error&gt;&gt;()?;<font></font>
<font></font>
        <span class="hljs-comment">//   .</span>
        <span class="hljs-keyword">let</span> attrs = ApiAttrs::from_list(attrs)?;<font></font>
<font></font>
        <span class="hljs-comment">//      HTTP API.</span>
        <span class="hljs-literal">Ok</span>(<span class="hljs-keyword">Self</span> {<font></font>
            item_trait,<font></font>
            endpoints,<font></font>
            attrs,<font></font>
        })<font></font>
    }<font></font>
}</code></pre><br>
<h2 id="perehodim-k-kodogeneracii">  </h2><br>
<p>     ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>warp</code></a>.</p><br>
<p>,     ,    ,   <code>warp</code>        .   warp'   ,   <code>Filter</code>.         <code>and</code>, <code>map</code>, <code>and_then</code>,      ,    .</p><br>
<p>,       ,   GET      JSON,     -   :</p><br>
<pre><code class="rust hljs"><span class="hljs-comment">///    ,    </span>
<span class="hljs-comment">///   warp'</span>
<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">simple_get</span></span>&lt;F, R, E&gt;(name: &amp;<span class="hljs-symbol">'static</span> <span class="hljs-built_in">str</span>, handler: F) -&gt; JsonReply
<span class="hljs-keyword">where</span>
    F: <span class="hljs-built_in">Fn</span>() -&gt; <span class="hljs-built_in">Result</span>&lt;R, E&gt; + <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span> + <span class="hljs-symbol">'static</span>,<font></font>
    R: ser::Serialize,<font></font>
    E: Reject,<font></font>
{<font></font>
    <span class="hljs-comment">//    ,    GET ,</span>
    <span class="hljs-comment">//   .</span><font></font>
    warp::get()<font></font>
        <span class="hljs-comment">//     ,   </span>
        <span class="hljs-comment">//     {name}</span><font></font>
        .and(warp::path(name))<font></font>
        <span class="hljs-comment">//     and_then    </span>
        <span class="hljs-comment">//      JSON </span>
        .and_then(<span class="hljs-keyword">move</span> || {
            <span class="hljs-keyword">let</span> handler = handler.clone();
            <span class="hljs-comment">//      , </span>
            <span class="hljs-comment">//        async .</span>
            <span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> {
                <span class="hljs-keyword">match</span> handler() {
                    <span class="hljs-literal">Ok</span>(value) =&gt; <span class="hljs-literal">Ok</span>(warp::reply::json(&amp;value)),
                    <span class="hljs-comment">//  warp'     ,</span>
                    <span class="hljs-comment">//     ,    </span>
                    <span class="hljs-comment">//       -</span>
                    <span class="hljs-comment">//   .</span>
                    <span class="hljs-literal">Err</span>(e) =&gt; <span class="hljs-literal">Err</span>(warp::reject::custom(e)),<font></font>
                }<font></font>
            }<font></font>
        })<font></font>
        .boxed()<font></font>
}</code></pre><br>
<p>   GET        ,    ,      :</p><br>
<pre><code class="rust hljs"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">query_get</span></span>&lt;F, Q, R, E&gt;(name: &amp;<span class="hljs-symbol">'static</span> <span class="hljs-built_in">str</span>, handler: F) -&gt; JsonReply
<span class="hljs-keyword">where</span>
    F: <span class="hljs-built_in">Fn</span>(Q) -&gt; <span class="hljs-built_in">Result</span>&lt;R, E&gt; + <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span> + <span class="hljs-symbol">'static</span>,<font></font>
    Q: FromUrlQuery,<font></font>
    R: ser::Serialize,<font></font>
    E: Reject,<font></font>
{<font></font>
    warp::get()<font></font>
        .and(warp::path(name))<font></font>
        <span class="hljs-comment">//       URL query,   </span>
        <span class="hljs-comment">//    query.</span><font></font>
        .and(warp::filters::query::raw())<font></font>
        .and_then(<span class="hljs-keyword">move</span> |raw_query: <span class="hljs-built_in">String</span>| {
            <span class="hljs-keyword">let</span> handler = handler.clone();
            <span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> {
                <span class="hljs-comment">//         </span>
                <span class="hljs-comment">// FromUrlQuery      </span>
                <span class="hljs-comment">//  .</span>
                <span class="hljs-keyword">let</span> query = Q::from_query_str(&amp;raw_query)<font></font>
                    .map_err(|_| warp::reject::custom(IncorrectQuery))?;<font></font>
<font></font>
                <span class="hljs-keyword">match</span> handler(query) {
                    <span class="hljs-literal">Ok</span>(value) =&gt; <span class="hljs-literal">Ok</span>(warp::reply::json(&amp;value)),
                    <span class="hljs-literal">Err</span>(e) =&gt; <span class="hljs-literal">Err</span>(warp::reject::custom(e)),<font></font>
                }<font></font>
            }<font></font>
        })<font></font>
        .boxed()<font></font>
}</code></pre><br>
<p>       .</p><br>
<h2 id="sobiraem-obrabotchiki-voedino">  </h2><br>
<p>  <code>and</code>,     ,   <br>
<code>or</code>,         , , <br>
    ,      .<br>
      :</p><br>
<pre><code class="rust hljs"><span class="hljs-keyword">use</span> std::net::SocketAddr;
<span class="hljs-keyword">use</span> warp::Filter;<font></font>
<font></font>
<span class="hljs-comment">//    warp     `/:u32` </span>
<span class="hljs-comment">// `/:socketaddr`</span>
warp::path::param::&lt;<span class="hljs-built_in">u32</span>&gt;()<font></font>
    .or(warp::path::param::&lt;SocketAddr&gt;());</code></pre><br>
<p>           <code>serve_ping_interface</code>.      warp     ,  service  ,  -.</p><br>
<pre><code class="rust hljs"><span class="hljs-keyword">impl</span> ParsedEndpoint {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">impl_endpoint_handler</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-keyword">impl</span> ToTokens {
        <span class="hljs-comment">//      .</span>
        <span class="hljs-keyword">let</span> path = <span class="hljs-keyword">self</span>.endpoint_path();
        <span class="hljs-keyword">let</span> ident = &amp;<span class="hljs-keyword">self</span>.ident;<font></font>
<font></font>
        <span class="hljs-comment">//        ,  </span>
        <span class="hljs-comment">//   warp .</span>
        <span class="hljs-keyword">match</span> (&amp;<span class="hljs-keyword">self</span>.attrs.method, &amp;<span class="hljs-keyword">self</span>.arg) {<font></font>
            (SupportedHttpMethod::Get, <span class="hljs-literal">None</span>) =&gt; {<font></font>
                quote! {<font></font>
                    <span class="hljs-keyword">let</span> #ident = http_api::warp_backend::simple_get(#path, {
                        <span class="hljs-keyword">let</span> out = service.clone();
                        <span class="hljs-keyword">move</span> || out.#ident()<font></font>
                    });<font></font>
                }<font></font>
            }<font></font>
<font></font>
            (SupportedHttpMethod::Get, <span class="hljs-literal">Some</span>(_arg)) =&gt; {<font></font>
                quote! {<font></font>
                    <span class="hljs-keyword">let</span> #ident = http_api::warp_backend::query_get(#path, {
                        <span class="hljs-keyword">let</span> out = service.clone();
                        <span class="hljs-keyword">move</span> |query| out.#ident(query)<font></font>
                    });<font></font>
                }<font></font>
            }<font></font>
<font></font>
            (SupportedHttpMethod::Post, <span class="hljs-literal">None</span>) =&gt; {<font></font>
                quote! {<font></font>
                    <span class="hljs-keyword">let</span> #ident = http_api::warp_backend::simple_post(#path, {
                        <span class="hljs-keyword">let</span> out = service.clone();
                        <span class="hljs-keyword">move</span> || out.#ident()<font></font>
                    });<font></font>
                }<font></font>
            }<font></font>
<font></font>
            (SupportedHttpMethod::Post, <span class="hljs-literal">Some</span>(_arg)) =&gt; {<font></font>
                quote! {<font></font>
                    <span class="hljs-keyword">let</span> #ident = http_api::warp_backend::params_post(#path, {
                        <span class="hljs-keyword">let</span> out = service.clone();
                        <span class="hljs-keyword">move</span> |params| out.#ident(params)<font></font>
                    });<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<p>     <code>or</code>    .</p><br>
<pre><code class="rust hljs"><span class="hljs-keyword">impl</span> ToTokens <span class="hljs-keyword">for</span> ParsedApiDefinition {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">to_tokens</span></span>(&amp;<span class="hljs-keyword">self</span>, out: &amp;<span class="hljs-keyword">mut</span> proc_macro2::TokenStream) {
        <span class="hljs-keyword">let</span> fn_name = &amp;<span class="hljs-keyword">self</span>.attrs.warp;
        <span class="hljs-keyword">let</span> interface = &amp;<span class="hljs-keyword">self</span>.item_trait.ident;<font></font>
<font></font>
        <span class="hljs-comment">//     ,    </span>
        <span class="hljs-comment">//   ,    </span>
        <span class="hljs-comment">//    .</span>
        <span class="hljs-keyword">let</span> (filters, idents): (<span class="hljs-built_in">Vec</span>&lt;_&gt;, <span class="hljs-built_in">Vec</span>&lt;_&gt;) = <span class="hljs-keyword">self</span><font></font>
            .endpoints<font></font>
            .iter()<font></font>
            .map(|endpoint| {<font></font>
                <span class="hljs-keyword">let</span> ident = &amp;endpoint.ident;
                <span class="hljs-keyword">let</span> handler = endpoint.impl_endpoint_handler();<font></font>
<font></font>
                (handler, ident)<font></font>
            })<font></font>
            .unzip();<font></font>
<font></font>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> tail = idents.into_iter();
        <span class="hljs-comment">//        </span>
        <span class="hljs-comment">// `a.or(b).or(c).or(d)`,     </span>
        <span class="hljs-comment">//   ,   .</span>
        <span class="hljs-keyword">let</span> head = tail.next().unwrap();
        <span class="hljs-keyword">let</span> serve_impl = quote! {<font></font>
            #head #( .or(#tail) )*<font></font>
        };<font></font>
<font></font>
        <span class="hljs-comment">//  :   .</span>
        <span class="hljs-keyword">let</span> tokens = quote! {
            <span class="hljs-function"><span class="hljs-keyword">fn</span> #<span class="hljs-title">fn_name</span></span>&lt;T&gt;(<font></font>
                service: T,<font></font>
                addr: <span class="hljs-keyword">impl</span> <span class="hljs-built_in">Into</span>&lt;std::net::SocketAddr&gt;,<font></font>
            ) -&gt; <span class="hljs-keyword">impl</span> std::future::Future&lt;Output = ()&gt;
            <span class="hljs-keyword">where</span>
                T: #interface + <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span> + <span class="hljs-symbol">'static</span>,<font></font>
            {<font></font>
                <span class="hljs-keyword">use</span> warp::Filter;<font></font>
<font></font>
                <span class="hljs-comment">//      .</span><font></font>
                #( #filters )*<font></font>
<font></font>
                <span class="hljs-comment">//      API  </span>
                <span class="hljs-comment">// warp .</span><font></font>
                warp::serve(#serve_impl).run(addr.into())<font></font>
            }<font></font>
<font></font>
        };<font></font>
        out.extend(tokens)<font></font>
    }<font></font>
}</code></pre><br>
<h2 id="zaklyuchenie"></h2><br>
<p>      ,  derive       ,<br>
       .<br>
  ,       ,   <br>
 RPC,   ,    Rust'.<br>
 ,       -  HTTP<br>
  <code>reqwest</code>             .</p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al usar macros, nadie se molesta en ir m√°s all√° y mostrar la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especificaci√≥n openapi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swagger</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
para los tipos de interfaz. </font><font style="vertical-align: inherit;">Pero me parece que en este caso es mejor ir hacia otro lado y escribir un generador de c√≥digo Rust de acuerdo con la especificaci√≥n, esto dar√° m√°s espacio para maniobras. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si escribe este generador en forma de dependencia de compilaci√≥n, puede usar las bibliotecas </font></font><br>
<code>syn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>quote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo tanto, escribir el generador ser√° muy c√≥modo y simple. </font><font style="vertical-align: inherit;">Sin embargo, esto ya son pensamientos de largo alcance :)</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c√≥digo completamente funcional, ejemplos de los cuales se dieron en este art√≠culo, se puede encontrar en este </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/alekseysidorov/playground/blob/master/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Gracias por la atenci√≥n!</font></font></p></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es486726/index.html">Diagn√≥stico de conexiones de red en un enrutador EDGE virtual</a></li>
<li><a href="../es486728/index.html">Autoridad Alemana de Protecci√≥n de Datos: la telemetr√≠a en Windows 10 1909 Enterprise se puede deshabilitar por completo</a></li>
<li><a href="../es486734/index.html">Arquitectura pura con mecanografiado: DDD y arquitectura en capas</a></li>
<li><a href="../es486736/index.html">C√≥mo aumentar la velocidad de decodificaci√≥n de una transmisi√≥n de video en FFmpeg</a></li>
<li><a href="../es486738/index.html">Convenciones de estilo de c√≥digo PHP</a></li>
<li><a href="../es486742/index.html">Entrevista con Anatoly Wasserman sobre el futuro</a></li>
<li><a href="../es486744/index.html">Un corrector de postura inteligente hecho en casa sali√≥ a la venta. Miramos el nuevo producto - IBACK</a></li>
<li><a href="../es486746/index.html">Escribe, no cortes. Lo que comenc√© a extra√±ar en las publicaciones de Habr</a></li>
<li><a href="../es486750/index.html">La serie "Para toda la humanidad": de una historia alternativa a la basura</a></li>
<li><a href="../es486752/index.html">Servidor web WSGI √∫nico que utiliza ESP8266. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>