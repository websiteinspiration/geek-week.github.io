<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏿 👨🏽‍⚕️ 🗽 10 lignes de code pour réduire la douleur de votre projet Vue 👩🏾‍🔧 🚴🏽 🚣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... ou familiarité avec les plugins Vue JS comme exemple de bus d'événements intégré
 Quelques mots sur ...
 Bonjour à tous! Je ferai une réservation ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>10 lignes de code pour réduire la douleur de votre projet Vue</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odin_ingram_micro/blog/488422/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... ou familiarité avec les plugins Vue JS comme exemple de bus d'événements intégré</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelques mots sur ...</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bonjour à tous! </font><font style="vertical-align: inherit;">Je ferai une réservation tout de suite. </font><font style="vertical-align: inherit;">J'adore vraiment VueJS, j'écris activement dessus depuis plus de 2 ans et je ne pense pas que son développement puisse faire mal au moins dans une certaine mesure :)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'un autre côté, nous essayons toujours de trouver des solutions universelles qui aideront à passer moins de temps sur les travaux mécaniques et plus sur ce qui est vraiment intéressant. Parfois, la solution est particulièrement réussie. Je veux partager avec vous l'un d'entre eux. Les 10 lignes qui seront discutées (spoiler: à la fin il y en aura un peu plus) sont nées dans le processus de travail sur le projet Cloud Blue - Connect, qui est une application assez grande avec plus de 400 composants. La solution que nous avons trouvée est déjà intégrée à divers points du système et pendant plus de six mois, elle n'a jamais nécessité de corrections, elle peut donc être considérée avec succès comme testée avec succès pour la stabilité.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et la dernière. </font><font style="vertical-align: inherit;">Avant de passer directement à la solution, je voudrais m'attarder un peu plus sur la description des trois types d'interaction entre les composants Vue entre eux: les principes du flux unidirectionnel, le modèle du magasin et le bus d'événements. </font><font style="vertical-align: inherit;">Si cette explication est inutile (ou ennuyeuse) pour vous, allez directement à la section avec la solution - tout est aussi bref et technique que possible.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un peu sur la façon dont les composants Vue communiquent entre eux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peut-être que la première question qu'une personne qui a rédigé son premier volet soulève est de savoir comment il recevra les données pour le travail et comment, à son tour, il transmettra les données qu'il a reçues «à l'extérieur». </font><font style="vertical-align: inherit;">Le principe d'interaction adopté dans le framework Vue JS s'appelle ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flux de données unidirectionnel</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En bref, ce principe sonne comme «propriétés - vers le bas, événements - vers le haut». Autrement dit, pour recevoir des données de l'extérieur («d'en haut»), nous enregistrons une propriété spéciale à l'intérieur du composant dans lequel le framework écrit, si nécessaire, nos données reçues «de l'extérieur». Afin de transférer les données «vers le haut», à l'intérieur du composant au bon endroit, nous appelons la méthode spéciale $ emit framework, qui transmet nos données au gestionnaire du composant parent. Dans le même temps, dans Vue JS, nous ne pouvons pas simplement «diffuser» l'événement jusqu'à une profondeur illimitée (comme par exemple dans Angular 1.x). Il "n'apparaît" qu'un seul niveau, au parent immédiat. Il en va de même pour les événements. Pour les transférer au niveau suivant, pour chacun d'eux, vous devez également enregistrer une interface spéciale - les propriétés et les événements qui transmettront notre «message» plus loin.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela peut être décrit comme un immeuble de bureaux dans lequel les travailleurs ne peuvent se déplacer que de leurs étages vers les étages voisins - un de haut en bas. Ainsi, afin de transférer le «document à signer» du cinquième étage au deuxième, une chaîne de trois travailleurs sera requise qui le livrera du cinquième étage au deuxième, puis trois autres qui le remettront au cinquième. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Mais ce n'est pas pratique!" Bien sûr, cela n'est pas toujours pratique du point de vue du développement, mais en regardant le code de chaque composant, nous pouvons voir ce qu'il transmet et à qui il passe. Nous n'avons pas besoin de garder à l'esprit toute la structure de l'application pour comprendre si notre composant est «en route» vers l'événement ou non. Nous pouvons voir cela à partir du composant parent.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien que les avantages de cette approche soient compréhensibles, elle présente également des inconvénients évidents, à savoir la forte cohésion des composants. </font><font style="vertical-align: inherit;">Autrement dit, pour que nous puissions placer un composant dans la structure, nous devons le superposer avec les interfaces nécessaires afin de gérer son état. </font><font style="vertical-align: inherit;">Afin de réduire cette connectivité, ils utilisent souvent des «outils de gestion des états». </font><font style="vertical-align: inherit;">L'outil le plus populaire pour Vue est peut-être ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vuex (côté)</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Poursuivant notre analogie avec un immeuble de bureaux, Vuex Stor est un service postal interne. Imaginez qu'à chaque étage du bureau il y ait une fenêtre pour émettre et recevoir des colis. Au cinquième étage, ils transfèrent le document n ° 11 pour signature, et au deuxième ils demandent périodiquement: "Y a-t-il des documents à signer?", Signez les documents existants et restituez-les. Sur le cinquième, ils demandent également: "Y a-t-il des signataires?" Dans le même temps, les employés peuvent déménager à d'autres étages ou dans d'autres pièces - le principe du travail ne changera pas pendant le travail du courrier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Environ par ce principe, le modèle appelé Store fonctionne également. À l'aide de l'interface Vuex, un entrepôt de données global est enregistré et configuré, et les composants s'y abonnent. Et peu importe le niveau de la structure de l'appel, le magasin fournira toujours les bonnes informations.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il semblerait que tous les problèmes aient déjà été résolus. Mais à un moment donné dans notre bâtiment métaphorique, un employé veut appeler un autre pour le déjeuner ... ou signaler une sorte d'erreur. Et ici commence l'étrange. Le message lui-même ne nécessite pas de transmission en tant que tel. Mais pour utiliser le courrier, vous devez transférer quelque chose. Ensuite, nos employés élaborent un code. Une balle verte - allez déjeuner, deux cubes rouges - une erreur d'application E-981273 s'est produite, trois pièces jaunes - vérifiez votre courrier et ainsi de suite.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est facile de deviner qu'avec l'aide de cette métaphore maladroite, je décris des situations où nous devons assurer la réponse de notre composant à un événement qui s'est produit dans un autre composant, qui en soi n'est en aucun cas lié au flux de données. </font><font style="vertical-align: inherit;">L'enregistrement d'un nouvel élément est terminé - vous devez reprendre la collection. </font><font style="vertical-align: inherit;">Une erreur 403 non autorisée s'est produite - vous devez démarrer une déconnexion utilisateur, etc. </font><font style="vertical-align: inherit;">La pratique habituelle (et loin d'être la meilleure) dans ce cas est de créer des indicateurs à l'intérieur du magasin ou d'interpréter indirectement les données stockées et leurs modifications. </font><font style="vertical-align: inherit;">Cela entraîne rapidement une pollution à la fois du magasin lui-même et de la logique des composants qui l'entourent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À ce stade, nous commençons à réfléchir à la façon de passer directement les événements, en contournant toute la chaîne des composants. </font><font style="vertical-align: inherit;">Et, un peu sur Google ou en fouillant dans la documentation, on tombe sur un schéma ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bus d'événement</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'un point de vue technique, le bus d'événements est un objet qui permet d'utiliser une méthode spéciale pour lancer un «événement» et s'y abonner en utilisant une autre. En d'autres termes, lors de l'abonnement à l'événement eventA, cet objet stocke la fonction de gestionnaire transmis dans sa structure, qu'il appellera lorsque la méthode de lancement avec la clé eventA est appelée quelque part dans l'application. Pour signer ou exécuter, il suffit d'y accéder via l'importation ou par référence, et vous avez terminé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Métaphoriquement, dans notre «bâtiment», un bus est une conversation courante dans le messager. Les composants s'abonnent à une «conversation générale» à laquelle d'autres composants envoient des messages. Dès qu'un «message» apparaît sur le «chat» auquel le composant s'est abonné, le gestionnaire démarre.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe différentes manières de créer un bus d'événements. </font><font style="vertical-align: inherit;">Vous pouvez l'écrire vous-même ou vous pouvez utiliser des solutions prêtes à l'emploi - le même RxJS, qui offre une énorme fonctionnalité pour travailler avec des flux entiers d'événements. </font><font style="vertical-align: inherit;">Mais le plus souvent, lorsqu'ils utilisent VueJS, ils utilisent, curieusement, VueJS lui-même. </font><font style="vertical-align: inherit;">L'instance Vue créée via le constructeur (new Vue ()) fournit une interface événementielle belle et concise, décrite dans la documentation officielle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous approchons de la question suivante ...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que voulons-nous?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et nous voulons construire un bus d'événements dans notre application. </font><font style="vertical-align: inherit;">Mais nous avons deux exigences supplémentaires:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il doit être facilement accessible dans tous les composants. </font><font style="vertical-align: inherit;">Des importations distinctes dans chacune des dizaines de composants nous semblent redondantes.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il doit être modulaire. </font><font style="vertical-align: inherit;">Nous ne voulons pas garder à l'esprit tous les noms d'événements afin d'éviter la situation où l'événement «créé par un élément» déclenche des gestionnaires de l'application entière. </font><font style="vertical-align: inherit;">Par conséquent, nous voulons pouvoir séparer facilement un petit fragment de l'arborescence des composants dans un module séparé et diffuser ses événements à l'intérieur, et non à l'extérieur.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de mettre en œuvre une fonctionnalité aussi impressionnante, nous utilisons la puissante interface de plug-in que VueJS nous fournit. </font><font style="vertical-align: inherit;">Vous pouvez vous y familiariser plus en détail </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur la page de documentation officielle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enregistrons d'abord notre plugin. </font><font style="vertical-align: inherit;">Pour ce faire, juste avant le point d'initialisation de notre application Vue (avant d'appeler Vue. $ Mount ()) nous plaçons le bloc suivant:</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { }, <font></font>
});<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, les plugins Vue sont un moyen d'étendre les fonctionnalités du framework à l'ensemble du niveau de l'application. L'interface du plugin offre plusieurs façons de s'intégrer dans le composant, mais aujourd'hui, nous allons présenter l'interface mixin. Cette méthode accepte un objet qui étend le descripteur de chaque composant avant de démarrer le cycle de vie dans l'application.</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Le code du composant que nous écrivons n'est probablement pas le composant lui-même, mais une description de son comportement et l'encapsulation d'une certaine partie de la logique que le framework utilise à différentes étapes de son cycle de vie. L'initialisation du plug-in est en dehors du cycle de vie du composant, le précédant, donc nous nous disons «descripteur», pas un composant, pour souligner qu'exactement le code qui est écrit dans notre fichier, et non une entité qui est un produit du travail du framework, sera transféré dans la section mixin du plugin)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({<font></font>
  install(vue) {     <font></font>
    vue.mixin({}); <span class="hljs-comment">// &lt;--</span><font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est cet objet vide qui contiendra les extensions de nos composants. Mais pour commencer, un autre arrêt. Dans notre cas, nous voulons créer une interface pour accéder au bus au niveau de chaque composant. Ajoutons le champ '$ broadcast' à notre descripteur, il stockera un lien vers notre bus. Pour ce faire, utilisez Vue.prototype:</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <span class="hljs-comment">// &lt;--</span><font></font>
    vue.mixin({}); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous devons créer le bus lui-même, mais rappelons d'abord l'exigence de modularité et supposons que dans le descripteur de composant, nous déclarerons un nouveau module avec le champ «$ module» avec une valeur de texte (nous en aurons besoin un peu plus tard). </font><font style="vertical-align: inherit;">Si le champ $ module est spécifié dans le composant lui-même, nous allons créer un nouveau bus pour lui; sinon, nous transmettrons le lien au parent via le champ $ parent. </font><font style="vertical-align: inherit;">Notez que les champs descripteurs seront disponibles pour nous via le champ $ options. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous placerons la création de notre bus le plus tôt possible - dans le crochet avantCréer.</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({<font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <font></font>
    vue.mixin({<font></font>
      beforeCreate() {  <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {  <span class="hljs-comment">// &lt;--</span><font></font>
         <font></font>
 	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) {  <span class="hljs-comment">// &lt;--</span><font></font>
         <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, remplissons les branches logiques. </font><font style="vertical-align: inherit;">Si le descripteur contient une nouvelle déclaration de module, créez une nouvelle instance de bus, sinon, prenez le lien de $ parent.</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue();  <span class="hljs-comment">// &lt;--</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast;  <span class="hljs-comment">// &lt;--</span><font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous rejetons l'annonce du plugin, nous considérons ... 1, 2, 3, 4 ... 10 lignes, comme je l'ai promis! </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pouvons-nous faire mieux?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr on peut. </font><font style="vertical-align: inherit;">Ce code est facilement extensible. </font><font style="vertical-align: inherit;">Par exemple, dans notre cas, en plus de $ broadcast, nous avons décidé d'ajouter l'interface $ rootBroadcast, qui donne accès à un seul bus pour toute l'application. </font><font style="vertical-align: inherit;">Les événements que l'utilisateur exécute sur le bus $ broadcast sont dupliqués sur le bus $ rootBroadcast afin que vous puissiez vous abonner à tous les événements d'un module particulier (dans ce cas, le nom de l'événement sera transmis au gestionnaire comme premier argument) ou à tous les événements d'application en général (puis le nom du module sera transmis au gestionnaire avec le premier argument, le nom de l'événement avec le second, et les données transmises avec l'événement seront transmises avec les arguments suivants). </font><font style="vertical-align: inherit;">Cette conception nous permettra d'établir une interaction entre les modules, ainsi que de suspendre un seul gestionnaire sur les événements des différents modules.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// This one emits event  </span>
<span class="hljs-keyword">this</span>.$broadcast.$emit(‘my-event’, ‘PARAM_A’); 
<span class="hljs-comment">// This is standard subscription inside module </span>
<span class="hljs-keyword">this</span>.$broadcast.$on(‘my-event’, (paramA) =&gt; {…}); 
<span class="hljs-comment">// This subscription will work for the same event </span>
<span class="hljs-keyword">this</span>.$rootBroadcast.$on(‘my-event’, (<span class="hljs-built_in">module</span>, paramA) =&gt; {…}); 
<span class="hljs-comment">// This subscription will also work for the same event </span>
<span class="hljs-keyword">this</span>.$rootBroadcast.$on(‘*’, (event, <span class="hljs-built_in">module</span>, paramA) =&gt; {…});
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment nous pouvons y parvenir: tout d' </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
abord, créez un seul bus, qui sera organisé via $ rootBroadcast, et le champ lui-même avec un lien:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue(); <span class="hljs-comment">// &lt;--</span><font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus; <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue(); <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast; <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous avons besoin d'appartenance à un module dans chaque composant, développons donc la définition de la modularité comme ceci:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue(); <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast; <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous devons faire en sorte que l'événement sur le bus local modulaire se reflète dans la manière dont nous avons besoin à la racine. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons d'abord créer une interface proxy simple et placer le bus lui-même dans la propriété conditionnellement privée de $ bus:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <span class="hljs-comment">// &lt;--</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };  <span class="hljs-comment">// &lt;--</span><font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et enfin, ajoutez des méthodes proxy à l'objet - car maintenant le champ $ broadcast ne fournit pas un accès direct au bus:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };<font></font>
        } <font></font>
        <span class="hljs-comment">// &gt;&gt;&gt;</span>
        <span class="hljs-keyword">this</span>.$broadcast.$emit = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$emit(…attrs);           
          <span class="hljs-keyword">const</span> [event, …attributes] = attrs; 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)); 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(‘*’, event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)<font></font>
        };<font></font>
        <font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$on = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {           
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$on(…attrs);<font></font>
        };<font></font>
        <span class="hljs-comment">// &lt;&lt;&lt;</span><font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, comme touche finale, rappelons-nous que nous avons accès au bus en fermant, ce qui signifie que les gestionnaires ajoutés une fois ne seront pas effacés avec le composant, mais vivront pendant tout le temps de travail avec l'application. Cela peut provoquer des effets secondaires désagréables, alors ajoutons une fonction de nettoyage de l'auditeur à notre bus à la fin du cycle de vie du composant:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeDestroy() {                               <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">this</span>.$broadcast.$off(<span class="hljs-keyword">this</span>.$broadcastEvents);  <span class="hljs-comment">// &lt;--</span><font></font>
      },<font></font>
<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">this</span>.$broadcastEvents = [];  <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };<font></font>
        } <font></font>
<font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$emit = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {
          <span class="hljs-keyword">this</span>.$broadcastEvents.push(attrs[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$emit(…attrs);           
          <span class="hljs-keyword">const</span> [event, …attributes] = attrs; 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)); 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(‘*’, event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)<font></font>
        };<font></font>
        <font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$on = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {           
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$on(…attrs);<font></font>
        };<font></font>
<font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$off =: <span class="hljs-function">(<span class="hljs-params">...attrs</span>) =&gt;</span> {  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$off(...attrs);   <span class="hljs-comment">// &lt;--</span><font></font>
        };<font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, cette option offre une fonctionnalité plus intéressante, bien que moins concise. </font><font style="vertical-align: inherit;">Avec lui, vous pouvez implémenter un système complet de communication alternative entre les composants. </font><font style="vertical-align: inherit;">De plus, il est entièrement sous notre contrôle et n'apporte pas de dépendances externes dans notre projet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'espère qu'après avoir lu ou acquis votre connaissance des plugins Vue, et peut-être que la prochaine fois que vous aurez besoin d'ajouter des fonctionnalités génériques à votre application, vous pourrez les implémenter plus efficacement - sans ajouter de dépendances externes.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr488408/index.html">Passerelle IoT Ethernet-RS485 STM32</a></li>
<li><a href="../fr488410/index.html">7 leçons que j'ai apprises en dix ans de développement</a></li>
<li><a href="../fr488412/index.html">Création d'un bot Discord basé sur discord.js</a></li>
<li><a href="../fr488416/index.html">SLAE - Examen expert de sécurité Linux Assembly</a></li>
<li><a href="../fr488418/index.html">Authentification de l'API REST avec Spring Security et MongoDB</a></li>
<li><a href="../fr488424/index.html">Qu'adviendra-t-il de l'ITSM en 2020?</a></li>
<li><a href="../fr488426/index.html">Comment faire une revue de code? Partie 2: revoir la navigation, la vitesse, les commentaires, les conflits</a></li>
<li><a href="../fr488428/index.html">Comment prédisons-nous l'avenir de la recherche Yandex: des corrections de bugs aux requêtes de découverte</a></li>
<li><a href="../fr488432/index.html">Snoop Project, un outil incroyable pour l'intelligence Internet, que les utilisateurs de RuNet attendent depuis si longtemps - est disponible</a></li>
<li><a href="../fr488436/index.html">Créez rapidement de la musique chiptune open source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>