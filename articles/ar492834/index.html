<!doctype html>
<html class="no-js" lang="ar">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍💻 🤱🏻 💇 ما هو المشترك بين LVM و matryoshka؟ 🧝🏻 🐟 🍠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="يوم جيد. 
 أريد أن أشارك المجتمع تجربة عملية في بناء نظام تخزين لـ KVM باستخدام md RAID + LVM. 
 
 سيقوم البرنامج:
 
 

- قم ببناء md RAID 1 من NVMe S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ما هو المشترك بين LVM و matryoshka؟</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492834/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يوم جيد. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
أريد أن أشارك المجتمع تجربة عملية في بناء نظام تخزين لـ KVM باستخدام md RAID + LVM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
سيقوم البرنامج:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قم ببناء md RAID 1 من NVMe SSD.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قم ببناء md RAID 6 من SATA SSD ومحركات الأقراص العادية.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ميزات TRIM / DISCARD على SSD RAID 1/6.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إنشاء صفيف md RAID 1/6 قابل للتمهيد على مجموعة مشتركة من الأقراص.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تثبيت النظام على NVMe RAID 1 إذا لم يكن هناك دعم NVMe في BIOS.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">باستخدام مخبأ LVM ورقيقة LVM.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">باستخدام لقطات BTRFS وإرسال / تلقي النسخ الاحتياطي.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">استخدام لقطات رقيقة LVM و thin_delta للنسخ الاحتياطي بنمط BTRFS.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
إذا كانت مهتمة ، من فضلك ، تحت القط.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بيان</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لا يتحمل المؤلف أي مسؤولية عن عواقب استخدام أو عدم استخدام المواد / الأمثلة / الكود / النصائح / البيانات من هذه المقالة. </font><font style="vertical-align: inherit;">من خلال قراءة أو استخدام هذه المواد بأي شكل من الأشكال ، فإنك تتحمل المسؤولية عن جميع عواقب هذه الإجراءات. </font><font style="vertical-align: inherit;">تشمل العواقب المحتملة ما يلي:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVMe SSD المقلية المقرمشة.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">استخدام كامل لموارد التسجيل وفشل محركات الأقراص SSD.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">فقدان كامل لجميع البيانات الموجودة على جميع محركات الأقراص ، بما في ذلك النسخ الاحتياطية.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أجهزة الكمبيوتر المعيبة.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أمضى الوقت والأعصاب والمال.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أي تأثيرات أخرى غير مدرجة أعلاه.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حديد</font></font></h2><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في المخزن كان:</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
اللوحة الأم حوالي عام 2013 على مجموعة شرائح Z87 كاملة مع Intel Core i7 / Haswell.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> وحدة المعالجة المركزية 4 النوى ، 8 خيوط</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 32 جيجا بايت من DDR3 RAM</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 × 16 أو 2 × 8 فتحة PCIe 3.0</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 × 4 + 1 × 1 فتحة PCIe 2.0</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6 × 6 جيجابايت / ثانية من موصلات SATA 3 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تومض محول SAS LSI SAS9211-8I في وضع IT / HBA. </font><font style="vertical-align: inherit;">تم استبدال البرامج الثابتة التي تدعم RAID عمدًا بالبرامج الثابتة HBA من أجل:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كان من الممكن في أي وقت رمي ​​هذا المحول واستبداله بأي محول آخر.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عمل TRIM / Discard بشكل طبيعي على الأقراص ، مثل </font><font style="vertical-align: inherit;">في برامج RAID الثابتة ، لا يتم دعم هذه الأوامر على الإطلاق ، ولا يهتم HBA بشكل عام بالأوامر التي يجب إرسالها في الناقل.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
الأقراص الصلبة - 8 قطع من HGST Travelstar 7K1000 بحجم 1 تيرابايت في شكل عامل 2.5 ، كما هو الحال بالنسبة لأجهزة الكمبيوتر المحمولة. </font><font style="vertical-align: inherit;">كانت محركات الأقراص هذه في السابق في صفيف RAID 6. </font><font style="vertical-align: inherit;">في النظام الجديد ، سيجدون أيضًا التطبيق. </font><font style="vertical-align: inherit;">لتخزين النسخ الاحتياطية المحلية.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بالإضافة إلى ذلك تم إضافته:</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 قطع من طراز SATA SSD Samsung 860 QVO 2TB. </font><font style="vertical-align: inherit;">تتطلب محركات الأقراص ذات الحالة الصلبة هذه كمية كبيرة ، ووجود ذاكرة تخزين مؤقت SLC ، والموثوقية أمر مرغوب فيه ، وسعر منخفض. </font><font style="vertical-align: inherit;">كان إلزاميًا دعمًا للتجاهل / صفر والذي تم فحصه بواسطة سطر في dmesg: </font></font><br>
<br>
<code>kernel: ata1.00: Enabling discard_zeroes_data</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
قطعتان من طراز NVMe SSD Samsung SSD 970 EVO 500GB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بالنسبة لأقراص SSD هذه ، تعد سرعة القراءة / الكتابة العشوائية وموردًا لاحتياجاتك مهمة. </font><font style="vertical-align: inherit;">المبرد لهم. </font><font style="vertical-align: inherit;">إلزامي. </font><font style="vertical-align: inherit;">الضرورة القصوى. </font><font style="vertical-align: inherit;">خلاف ذلك ، قم بقليها حتى تصبح هشة أثناء مزامنة RAIDa الأولى.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
محول StarTech PEX8M2E2 لقرصين NVMe SSD مع فتحة PCIe 3.0 8x. هذا ، مرة أخرى ، هو HBA فقط ، ولكن بالنسبة لـ NVMe. وهو يختلف عن المحولات الرخيصة في غياب متطلبات دعم التشعب PCIe من اللوحة الأم بسبب وجود مفتاح PCIe مدمج. ستعمل حتى في أقدم نظام يوجد به PCIe ، حتى لو كانت فتحة x1 PCIe 1.0. وبطبيعة الحال ، بالسرعة المناسبة. لا توجد RAIDs هناك. لا يوجد BIOS متكامل على اللوحة. لذلك ، لن يتعلم نظامك بطريقة سحرية التمهيد من NVMe ، ناهيك عن NVMe RAID بفضل هذا الجهاز. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
كان هذا المكون ناتجًا فقط عن وجود قرص واحد مجاني 8x PCIe 3.0 في النظام ، وفي وجود فتحتين مجانيتين ، يمكن استبداله بسهولة بقطعتين PEX4M2E1 أو نظيرتين رخيصتين ، والتي يمكن شراؤها في أي مكان بسعر 600 روبل.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تم رفض جميع أنواع الأجهزة أو شرائح RAID / BIOS المدمجة بشكل متعمد ، حتى تتمكن من استبدال النظام بالكامل ، باستثناء SSD / HDD ، مما يحفظ جميع البيانات. </font><font style="vertical-align: inherit;">من الناحية المثالية ، سيكون من الممكن الاحتفاظ حتى بنظام التشغيل المثبت عند الانتقال إلى جهاز جديد / مختلف تمامًا. </font><font style="vertical-align: inherit;">الشيء الرئيسي هو أن هناك منافذ SATA و PCIe. </font><font style="vertical-align: inherit;">إنه مثل قرص مضغوط مباشر أو محرك أقراص فلاش قابل للتشغيل ، فقط سريع جدًا وقليل الحجم قليلاً.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">دعابة</font></font></b><div class="spoiler_text"> ,   , —          .     .            5.25  .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
حسنًا ، وبطبيعة الحال ، لتجربة طرق مختلفة للتخزين المؤقت SSD في Linux.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">غارات الأجهزة ، إنها مملة. </font><font style="vertical-align: inherit;">شغله. </font><font style="vertical-align: inherit;">إما أنه يعمل أم لا. </font><font style="vertical-align: inherit;">ومع mdadm هناك دائمًا خيارات.</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ناعم</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
سابقًا ، تم تثبيت Debian 8 Jessie على الجهاز ، وهو قريب من موسوعة الحياة. </font><font style="vertical-align: inherit;">تم إقران RAID 6 من الأقراص الصلبة المذكورة أعلاه مع LVM. </font><font style="vertical-align: inherit;">كان يشغل آلات افتراضية في kvm / libvirt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لان </font><font style="vertical-align: inherit;">يمتلك المؤلف الخبرة المناسبة في إنشاء محركات أقراص محمولة قابلة للتشغيل SATA / NVMe محمولة ، وأيضًا ، حتى لا يتمزق قالب apt المعتاد ، تم اختيار Ubuntu 18.04 كنظام مستهدف ، والذي استقر بالفعل بما يكفي ، ولكن لا يزال لديه 3 سنوات من الدعم في المستقبل. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في النظام المذكور ، هناك جميع برامج تشغيل الأجهزة التي نحتاجها خارج الصندوق. </font><font style="vertical-align: inherit;">لا نحتاج إلى أي برامج وبرامج تشغيل تابعة لجهات خارجية.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التحضير للتثبيت</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لتثبيت النظام ، نحتاج إلى Ubuntu Desktop Image. </font><font style="vertical-align: inherit;">يحتوي نظام الخادم على نوع من المثبتات القوية التي تظهر استقلالية مفرطة وغير قابلة للفصل ، مما يدفع دائمًا قسم نظام UEFI إلى أحد الأقراص التي تفسد كل الجمال. </font><font style="vertical-align: inherit;">وفقًا لذلك ، يتم تثبيته فقط في وضع UEFI. </font><font style="vertical-align: inherit;">لا تقدم خيارات. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هذا لا يناسبنا.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لماذا ا؟</font></font></b><div class="spoiler_text"> , UEFI        RAID, ..   UEFI ESP     .    ,    ESP     USB , ,   .      mdadm RAID 1    0.9    UEFI BIOS   , ,       BIOS       -  ESP     .<br>
<br>
 ,  UEFI   NVRAM,         , ..    .<br>
<br>
 ,      .     ,       Legacy/BIOS boot,    CSM  UEFI- .      , ,      .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لا يعرف إصدار سطح المكتب من Ubuntu أيضًا كيفية التثبيت بشكل طبيعي مع Legoot bootloader ، ولكن هنا ، كما يقولون ، على الأقل هناك خيارات. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لذا ، قم بتجميع الأجهزة وتحميل النظام من محرك أقراص Ubuntu Live القابل للتمهيد. </font><font style="vertical-align: inherit;">سنحتاج إلى تنزيل الحزم ، لذا قمنا بإعداد الشبكة ، والتي أكسبتك. </font><font style="vertical-align: inherit;">إذا لم يفلح ذلك ، يمكنك تنزيل الحزم الضرورية على محرك أقراص USB المحمول مسبقًا. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نذهب إلى بيئة سطح المكتب ، ونشغل محاكي الطرفية ، ودعونا نذهب:</font></font><br>
<br>
<code>#sudo bash</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كيف...؟</font></font></b><div class="spoiler_text">       sudo.  <b></b>    <b></b> .   ,       .     sudo   ,     . :<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/W-tPTmdnc7E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
</div></div><br>
<code>#apt-get install mdadm lvm2 thin-provisioning-tools btrfs-tools util-linux lsscsi nvme-cli mc</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لماذا لا ZFS ...؟</font></font></b><div class="spoiler_text">       , —  ,         . <br>
        , —        ,   -  .<br>
<br>
    ZFS —  ,  mdadm+lvm    .<br>
<br>
           .      .   .  .  .  .      ,       . <br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ثم لماذا BTRFS ...؟</font></font></b><div class="spoiler_text">            Legacy/BIOS GRUB  , ,  ,   -.      /boot .  ,       / ()   ,           LVM     . <br>
<br>
   ,          .<br>
                       send/recieve.<br>
<br>
 ,                        GPU  PCI-USB Host-  KVM  IOMMU.<br>
<br>
    —  ,    .<br>
<br>
    ZFS, ,  ,     .<br>
<br>
  ,       / RAID      ZFS, BRTFS  LVM.<br>
<br>
   , BTRFS       ,         /    HDD.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
إعادة فحص جميع الأجهزة: لنلق نظرة حولك </font></font><br>
<br>
<code>#udevadm control --reload-rules &amp;&amp; udevadm trigger</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
:</font></font><br>
<br>
<code>#lsscsi &amp;&amp; nvme list<br>
[0:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sda <br>
[1:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdb <br>
[2:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdc <br>
[3:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdd <br>
[4:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sde <br>
[5:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdf <br>
[6:0:0:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdg <br>
[6:0:1:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdh <br>
[6:0:2:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdi <br>
[6:0:3:0] disk ATA HGST HTS721010A9 A3B0 /dev/sdj <br>
[6:0:4:0] disk ATA HGST HTS721010A9 A3B0 /dev/sdk <br>
[6:0:5:0] disk ATA HGST HTS721010A9 A3B0 /dev/sdl <br>
[6:0:6:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdm <br>
[6:0:7:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdn <br>
Node SN Model Namespace Usage Format FW Rev <br>
---------------- -------------------- ---------------------------------------- --------- -------------------------- ---------------- --------<br>
/dev/nvme0n1 S466NXXXXXXX15L Samsung SSD 970 EVO 500GB 1 0,00 GB / 500,11 GB 512 B + 0 B 2B2QEXE7<br>
/dev/nvme1n1 S5H7NXXXXXXX48N Samsung SSD 970 EVO 500GB 1 0,00 GB / 500,11 GB 512 B + 0 B 2B2QEXE7<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تقسيم "محركات الأقراص"</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVMe SSD</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ولكن بأي شكل من الأشكال لن نقوم بترميزها. </font><font style="vertical-align: inherit;">على الرغم من ذلك ، لا يرى BIOS محركات الأقراص هذه. </font><font style="vertical-align: inherit;">لذلك ، سوف يذهبون بالكامل إلى برنامج RAID. </font><font style="vertical-align: inherit;">لن نقوم حتى بإنشاء أقسام هناك. </font><font style="vertical-align: inherit;">إذا كنت تريد وفقًا "للشريعة" أو "المبدأ" - قم بإنشاء قسم واحد كبير ، مثل محرك الأقراص الثابتة.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA HDD</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لا يوجد شيء خاص للاختراع. </font><font style="vertical-align: inherit;">سنقوم بإنشاء قسم واحد لكل شيء. </font><font style="vertical-align: inherit;">سنقوم بإنشاء القسم لأن BIOS يرى هذه الأقراص وقد يحاول حتى التمهيد منها. </font><font style="vertical-align: inherit;">سنقوم أيضًا بتثبيت GRUB لاحقًا على هذه الأقراص حتى ينجح النظام فجأة.</font></font><br>
<br>
<code>#cat &gt;hdd.part &lt;&lt; EOF<br>
label: dos<br>
label-id: 0x00000000<br>
device: /dev/sdg<br>
unit: sectors<br>
<br>
/dev/sdg1 : start= 2048, size= 1953523120, type=fd, bootable<br>
EOF<br>
#sfdisk /dev/sdg &lt; hdd.part<br>
#sfdisk /dev/sdh &lt; hdd.part<br>
#sfdisk /dev/sdi &lt; hdd.part<br>
#sfdisk /dev/sdj &lt; hdd.part<br>
#sfdisk /dev/sdk &lt; hdd.part<br>
#sfdisk /dev/sdl &lt; hdd.part<br>
#sfdisk /dev/sdm &lt; hdd.part<br>
#sfdisk /dev/sdn &lt; hdd.part<br>
</code><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA SSD</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هنا لدينا الأكثر إثارة للاهتمام. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
أولاً ، لدينا محركي أقراص TB. </font><font style="vertical-align: inherit;">هذا ضمن الحدود المسموح بها لـ MBR ، والتي سنستخدمها. </font><font style="vertical-align: inherit;">إذا لزم الأمر ، يمكن استبداله بـ GPT. </font><font style="vertical-align: inherit;">تحتوي أقراص GPT على طبقة توافق تسمح للأنظمة المتوافقة مع MBR برؤية الأقسام الأربعة الأولى إذا كانت موجودة ضمن أول 2 تيرابايت. </font><font style="vertical-align: inherit;">الشيء الرئيسي هو أن قسم التمهيد وقسم bios_grub على هذه الأقراص يجب أن يكون في البداية. </font><font style="vertical-align: inherit;">هذا يسمح لك بالتمهيد حتى من محرك GPT Legacy / BIOS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لكن ، هذه ليست قضيتنا. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هنا سنقوم بإنشاء قسمين. </font><font style="vertical-align: inherit;">سيكون الأول بحجم 1 جيجا بايت ويستخدم لـ RAID 1 / boot. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
سيتم استخدام الثاني لـ RAID 6 وسيشغل كل المساحة الخالية المتبقية باستثناء منطقة صغيرة غير مخصصة في نهاية محرك الأقراص.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ما هي المساحة غير المخصصة؟</font></font></b><div class="spoiler_text">     SATA SSD      SLC    6  78 . 6    «»     «»  «»   .  72      . <br>
<br>
  ,     SLC,      4 bit MLC.     ,    4       1  SLC .<br>
<br>
 72   4   288 .           ,       SLC .<br>
<br>
 ,     312  SLC     .    2    RAID  .<br>
<br>
            ,      .        QLC , —          .      , ,       ,    SSD     TBW  .<br>
</div></div><br>
<code>#cat &gt;ssd.part &lt;&lt; EOF<br>
label: dos<br>
label-id: 0x00000000<br>
device: /dev/sda<br>
unit: sectors<br>
<br>
/dev/sda1 : start= 2048, size= 2097152, type=fd, bootable<br>
/dev/sda2 : start= 2099200, size= 3300950016, type=fd<br>
EOF<br>
#sfdisk /dev/sda &lt; ssd.part<br>
#sfdisk /dev/sdb &lt; ssd.part<br>
#sfdisk /dev/sdc &lt; ssd.part<br>
#sfdisk /dev/sdd &lt; ssd.part<br>
#sfdisk /dev/sde &lt; ssd.part<br>
#sfdisk /dev/sdf &lt; ssd.part<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إنشاء المصفوفات</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
أولاً نحتاج إلى إعادة تسمية السيارة. </font><font style="vertical-align: inherit;">يعد ذلك ضروريًا لأن اسم المضيف جزء من اسم الصفيف في مكان ما داخل mdadm ويؤثر على شيء ما في مكان ما. </font><font style="vertical-align: inherit;">بالطبع ، يمكن إعادة تسمية المصفوفات في وقت لاحق ، ولكن هذه إجراءات غير ضرورية.</font></font><br>
<br>
<code>#mcedit /etc/hostname <br>
#mcedit /etc/hosts<br>
#hostname<br>
vdesk0<br>
</code><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVMe SSD</font></font></h4><br>
<code>#mdadm --create --verbose --assume-clean /dev/md0 --level=1 --raid-devices=2 /dev/nvme[0-1]n1</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لماذا - نظيف - ...؟</font></font></b><div class="spoiler_text">   .    RAID 1  6  .      ,    .  ,   SSD   —     TBW.   TRIM/DISCARD      SSD   «».<br>
<br>
  SSD RAID 1 DISCARD   .<br>
<br>
  SSD RAID 6 DISCARD      . <br>
<br>
      ,    SSD     4/5/6       discard_zeroes_data.    ,       , , -,  ,     .       , ,       .     DISCARD -   RAID 6.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
انتباه ، الأمر التالي سوف يدمر جميع البيانات الموجودة على محركات أقراص NVMe عن طريق "تهيئة" الصفيف بـ "الأصفار". </font></font><br>
<br>
<code>#blkdiscard /dev/md0</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
إذا حدث خطأ ما ، فحاول تحديد خطوة.</font></font><br>
<br>
<code>#blkdiscard --step 65536 /dev/md0</code><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA SSD</font></font></h4><br>
<code>#mdadm --create --verbose --assume-clean /dev/md1 --level=1 --raid-devices=6 /dev/sd[a-f]1</code><br>
<code>#blkdiscard /dev/md1</code><br>
<code>#mdadm --create --verbose --assume-clean /dev/md2 --chunk-size=512 --level=6 --raid-devices=6 /dev/sd[a-f]2</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لماذا كبير جدا ...؟</font></font></b><div class="spoiler_text"> chunk-size         chunk-size .   ,              . , IOPS    .   99% IO   512K.<br>
<br>
 RAID 6 IOPS   <b></b>    IOPS   .      IOPS          ,       . <br>
           RAID 6 by-design     ,   RAID 6   .<br>
   RAID 6      NVMe    thin-provisioning.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لم نقم بعد بتمكين DISCARD لـ RAID 6. لذا ، لن نقوم "بتهيئة" هذا الصفيف بعد. </font><font style="vertical-align: inherit;">سنفعل ذلك لاحقًا ، بعد تثبيت نظام التشغيل.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA HDD</font></font></h4><br>
<code>#mdadm --create --verbose --assume-clean /dev/md3 --chunk-size=512 --level=6 --raid-devices=8 /dev/sd[g-n]1</code><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LVM على NVMe RAID</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
للسرعة ، نريد وضع الجذر FS على NVMe RAID 1 وهو / dev / md0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ومع ذلك ، ما زلنا بحاجة إلى هذا الصفيف السريع للاحتياجات الأخرى ، مثل المبادلة والبيانات الوصفية وذاكرة التخزين المؤقت LVM وبيانات التعريف الرقيقة LVM ، وبالتالي ، في هذا الصفيف ، سننشئ LVM VG. </font><font style="vertical-align: inherit;">
إنشاء قسم للجذر FS. </font><font style="vertical-align: inherit;">
قم بإنشاء قسم لتبديل حجم ذاكرة الوصول العشوائي.</font></font><br>
<br>
<code>#pvcreate /dev/md0<br>
#vgcreate root /dev/md0</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 128G --name root root</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 32G --name swap root</code><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تثبيت نظام التشغيل</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في المجموع ، لدينا كل ما يلزم لتثبيت النظام. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
قم بتشغيل معالج التثبيت من بيئة Ubuntu Live. </font><font style="vertical-align: inherit;">التثبيت العادي. </font><font style="vertical-align: inherit;">فقط في مرحلة تحديد محركات الأقراص للتثبيت ، تحتاج إلى تحديد ما يلي:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / md1 ، - نقطة تحميل / تمهيد ، FS - BTRFS </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / root / root (aka / dev / mapper / root-root) ، - نقطة تحميل / (root) ، FS - BTRFS</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / root / swap (aka / dev / mapper / root-swap) ، - استخدم كقسم تبديل</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تثبيت برنامج Bootloader على / dev / sda</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
إذا قمت بتحديد BTRFS كجذر FS ، فسيقوم المثبت تلقائيًا بإنشاء مجلدين BTRFS بأسماء "@" لـ / (root) و "home" لـ / home. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نبدأ التثبيت ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
سينتهي التثبيت بمربع حوار مشروط للإبلاغ عن خطأ تثبيت محمل التمهيد. </font><font style="vertical-align: inherit;">لسوء الحظ ، سيفشل الخروج من هذا الحوار بالوسائل العادية ومواصلة التثبيت. </font><font style="vertical-align: inherit;">نقوم بتسجيل الخروج من النظام وتسجيل الدخول مرة أخرى ، والوصول إلى سطح مكتب Ubuntu Live النظيف. </font><font style="vertical-align: inherit;">افتح الوحدة الطرفية ، ومرة ​​أخرى: </font></font><br>
<br>
<code>#sudo bash</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
قم بإنشاء بيئة chroot لمواصلة التثبيت: قم بإعداد </font><font style="vertical-align: inherit;">
الشبكة واسم المضيف في chroot: </font><font style="vertical-align: inherit;">
انتقل إلى بيئة chroot: </font><font style="vertical-align: inherit;">
أولاً نقوم بتوصيل الحزم: </font><font style="vertical-align: inherit;">
تحقق من جميع الحزم التي كانت ملتوية بسبب التثبيت غير الكامل للنظام:</font></font><br>
<br>
<code>#mkdir /mnt/chroot<br>
#mount -o defaults,space_cache,noatime,nodiratime,discard,subvol=@ /dev/mapper/root-root /mnt/chroot<br>
#mount -o defaults,space_cache,noatime,nodiratime,discard,subvol=@home /dev/mapper/root-root /mnt/chroot/home<br>
#mount -o defaults,space_cache,noatime,nodiratime,discard /dev/md1 /mnt/chroot/boot<br>
#mount --bind /proc /mnt/chroot/proc <br>
#mount --bind /sys /mnt/chroot/sys<br>
#mount --bind /dev /mnt/chroot/dev<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#cat /etc/hostname &gt;/mnt/chroot/etc/hostname<br>
#cat /etc/hosts &gt;/mnt/chroot/etc/hosts<br>
#cat /etc/resolv.conf &gt;/mnt/chroot/etc/resolv.conf<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#chroot /mnt/chroot<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>apt-get install --reinstall mdadm lvm2 thin-provisioning-tools btrfs-tools util-linux lsscsi nvme-cli mc debsums hdparm</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#CORRUPTED_PACKAGES=$(debsums -s 2&gt;&amp;1 | awk '{print $6}' | uniq)<br>
#apt-get install --reinstall $CORRUPTED_PACKAGES<br>
</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
إذا لم ينمو شيء ما معًا ، فقد تحتاج إلى </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تعديل </font><font style="vertical-align: inherit;">/etc/apt/sources.list قبل ذلك. </font><font style="vertical-align: inherit;">دعنا نغير معلمات وحدة RAID 6 لتمكين TRIM / DISCARD: سنقوم </font><font style="vertical-align: inherit;">
بتعديل </font><font style="vertical-align: inherit;">صفائفنا </font><font style="vertical-align: inherit;">قليلاً:</font></font><br>
<br>
<code>#cat &gt;/etc/modprobe.d/raid456.conf &lt;&lt; EOF<br>
options raid456 devices_handle_discard_safely=1<br>
EOF<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#cat &gt;/etc/udev/rules.d/60-md.rules &lt;&lt; EOF<br>
SUBSYSTEM=="block", KERNEL=="md*", ACTION=="change", TEST=="md/stripe_cache_size", ATTR{md/stripe_cache_size}="32768"<br>
SUBSYSTEM=="block", KERNEL=="md*", ACTION=="change", TEST=="md/sync_speed_min", ATTR{md/sync_speed_min}="48000"<br>
SUBSYSTEM=="block", KERNEL=="md*", ACTION=="change", TEST=="md/sync_speed_max", ATTR{md/sync_speed_max}="300000"<br>
EOF<br>
#cat &gt;/etc/udev/rules.d/62-hdparm.rules &lt;&lt; EOF<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="1", RUN+="/sbin/hdparm -B 254 /dev/%k"<br>
EOF<br>
#cat &gt;/etc/udev/rules.d/63-blockdev.rules &lt;&lt; EOF<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="1", RUN+="/sbin/blockdev --setra 1024 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="0", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="nvme[0-9]n1", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="dm-*", ATTR{queue/rotational}=="0", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="md*", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
<br>
EOF<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ماذا كان ..؟</font></font></b><div class="spoiler_text">   udev     :<br>
<br>
<ul>
<li>    2020-      RAID 6.  -, ,      Linux,     .</li>
<li>    /   IO.  ,           .</li>
<li>    /   IO.  ,  / SSD RAID-       .    NVMe. (   ?    . )</li>
<li>   APM     (HDD)         7 .    APM      (-B 255).   -      .      ,   , ,  -.       .    -        .     , , - «»,    -,    RAID-   mini-MAID-.</li>
<li> readahead   ()  1  —   /chunk RAID 6</li>
<li> readahead  SATA SSD</li>
<li> readahead  NVMe SSD</li>
<li> readahead   LVM    SSD.</li>
<li> readahead   RAID .</li>
</ul><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تحرير / etc / fstab:</font></font><br>
<br>
<code>#cat &gt;/etc/fstab &lt;&lt; EOF<br>
# /etc/fstab: static file system information.<br>
#<br>
# Use 'blkid' to print the universally unique identifier for a<br>
# device; this may be used with UUID= as a more robust way to name devices<br>
# that works even if disks are added and removed. See fstab(5).<br>
# file-system mount-point type options dump pass<br>
/dev/mapper/root-root / btrfs defaults,space_cache,noatime,nodiratime,discard,subvol=@ 0 1<br>
UUID=$(blkid -o value -s UUID /dev/md1) /boot btrfs defaults,space_cache,noatime,nodiratime,discard 0 2<br>
/dev/mapper/root-root /home btrfs defaults,space_cache,noatime,nodiratime,discard,subvol=@home 0 2<br>
/dev/mapper/root-swap none swap sw 0 0<br>
EOF</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لماذا هذا..؟</font></font></b><div class="spoiler_text"> /boot     UUID ..     .<br>
<br>
      LVM    /dev/mapper/vg-lv, ..     . <br>
<br>
  UUID  LVM .. UUID  LVM      .</div></div><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مرتين نحن جبل / ديف / مخطط / الجذر الجذر ..؟</font></font></b><div class="spoiler_text">.  .  BTRFS.         subvol.<br>
<br>
  -      LVM   BTRFS .     .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نقوم بتجديد تكوين mdadm: </font><font style="vertical-align: inherit;">
قم بتصحيح إعدادات LVM:</font></font><br>
<br>
<code>#/usr/share/mdadm/mkconf | sed 's/#DEVICE/DEVICE/g' &gt;/etc/mdadm/mdadm.conf<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#cat &gt;&gt;/etc/lvm/lvmlocal.conf &lt;&lt; EOF<br>
<br>
activation {<br>
 thin_pool_autoextend_threshold=90<br>
 thin_pool_autoextend_percent=5<br>
}<br>
allocation {<br>
 cache_pool_max_chunks=2097152<br>
}<br>
devices {<br>
 global_filter=["r|^/dev/.*_corig$|","r|^/dev/.*_cdata$|","r|^/dev/.*_cmeta$|","r|^/dev/.*gpv$|","r|^/dev/images/.*$|","r|^/dev/mapper/images.*$|","r|^/dev/backup/.*$|","r|^/dev/mapper/backup.*$|"]<br>
 issue_discards=1<br>
}<br>
EOF<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ماذا كان ..؟</font></font></b><div class="spoiler_text">     LVM thin   90%    5%  .<br>
<br>
       LVM cache.<br>
<br>
  LVM  LVM  (PV) :<br>
<br>
<ul>
<li>   LVM cache (cdata)</li>
<li>     LVM cache    (&lt;lv_name&gt;_corig).            ( &lt;lv_name&gt;).</li>
<li>    LVM cache (cmeta)</li>
<li>    VG   images.        , ,     LVM       .</li>
<li>    VG   backup.         .</li>
<li>       «gpv» ( guest physical volume )</li>
</ul><br>
   DISCARD      LVM VG.  .    LV  SSD  .     SSD RAID 6. ,  ,    thin provisioning,  ,     .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تحديث صورة initramfs: </font></font><br>
<br>
<code>#update-initramfs -u -k all</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تثبيت وتكوين اليرقة:</font></font><br>
<br>
<code>#apt-get install grub-pc<br>
#apt-get purge os-prober<br>
#dpkg-reconfigure grub-pc</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ما يدفع للاختيار؟</font></font></b><div class="spoiler_text">  sd*.         SATA   SSD.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لماذا مسمر os-prober ..؟</font></font></b><div class="spoiler_text">     . <br>
<br>
       RAID-    .      ,         .<br>
<br>
   ,   , ,    .         .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بهذا أكملنا التثبيت الأولي. </font><font style="vertical-align: inherit;">حان الوقت لإعادة التشغيل في نظام التشغيل المثبت حديثًا. </font><font style="vertical-align: inherit;">تذكر إزالة قرص CD / USB المباشر القابل للتمهيد. </font><font style="vertical-align: inherit;">
كجهاز للتشغيل ، حدد أيًا من SATA SSD.</font></font><br>
<br>
<code>#exit<br>
#reboot</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LVM إلى SATA SSD</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في هذه المرحلة ، قمنا بالفعل بالتمهيد إلى نظام التشغيل الجديد ، وقمنا بتهيئة الشبكة ، وفتح ، ومحاكي الطرفية ، وبدأنا: </font></font><br>
<br>
<code>#sudo bash</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
متابعة. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"تهيئة" صفيف من SATA SSD: </font></font><br>
<br>
<code>#blkdiscard /dev/md2</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
إذا لم يحدث ذلك ، فحاول: </font></font><br>
<br>
<code>#blkdiscard --step 65536 /dev/md2</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
إنشاء LVM VG على SATA SSD:</font></font><br>
<br>
<code>#pvcreate /dev/md2<br>
#vgcreate data /dev/md2</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لماذا آخر vg ..؟</font></font></b><div class="spoiler_text">  ,     VG   root.        VG?<br>
<br>
  VG   PV,     VG  PV   (online).   LVM RAID,     .<br>
<br>
  ,    (  )    RAID 6           .<br>
<br>
 ,           «»   VG.<br>
<br>
 -,   RAID     « ».         ,    VG.<br>
<br>
 LVM  «»        RAID  -  . , —  <b></b> bcache + LVM thin, bcache + BTRFS, LVM cache + LVM thin,   ZFS       ,      .<br>
<br>
 «»   ,  - «» LVM-,   .    , ,     .<br>
<br>
,   ,     -   .<br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LVM إلى SATA HDD</font></font></h3><br>
<code>#pvcreate /dev/md3<br>
#vgcreate backup /dev/md3</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مرة أخرى VG الجديد ..؟</font></font></b><div class="spoiler_text">  ,     ,        ,      , -     . , -   VG, —    VG.<br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تكوين ذاكرة التخزين المؤقت LVM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
قم بإنشاء LV على NVMe RAID 1 لاستخدامه كجهاز تخزين مؤقت.</font></font><br>
<br>
<code>#lvcreate -L 70871154688B --name cache root</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لماذا القليل جدا ...؟</font></font></b><div class="spoiler_text">  ,    NVMe SSD   SLC . 4  «»  18         3-bit MLC. -   NVMe SSD       SATA SSD  . ,        LVM cache      SLC  NVMe .   NVMe      32-64  . <br>
<br>
      64  ,       .<br>
<br>
 ,      LVM         .  ,       lvchange       . ,      .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لنقم بإنشاء LV على SATA RAID 6 لاستخدامه كجهاز مخبأ.</font></font><br>
<br>
<code>#lvcreate -L 3298543271936B --name cache data</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لماذا فقط ثلاثة تيرابايت ..؟</font></font></b><div class="spoiler_text">,  ,    SATA SSD RAID 6  -  .      ,  ,    .         , ,   LVM-cache , , bcache,  ,      .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
إنشاء VG جديد للتخزين المؤقت. </font><font style="vertical-align: inherit;">
قم بإنشاء LV على الجهاز المخزن مؤقتًا. </font><font style="vertical-align: inherit;">
هنا أخذنا على الفور كل المساحة الحرة على / dev / data / cache حتى يتم إنشاء جميع الأقسام الضرورية الأخرى على الفور على / dev / root / cache. </font><font style="vertical-align: inherit;">إذا كان لديك شيء لم يتم إنشاؤه هناك ، يمكنك نقله باستخدام pvmove. </font><font style="vertical-align: inherit;">
إنشاء وتمكين ذاكرة التخزين المؤقت:</font></font><br>
<br>
<code>#pvcreate /dev/root/cache<br>
#pvcreate /dev/data/cache<br>
#vgcreate cache /dev/root/cache /dev/data/cache</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 3298539077632B --name cachedata cache /dev/data/cache</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -y -L 64G -n cache cache /dev/root/cache<br>
#lvcreate -y -L 1G -n cachemeta cache /dev/root/cache<br>
#lvconvert -y --type cache-pool --cachemode writeback --chunksize 64k --poolmetadata cache/cachemeta cache/cache<br>
#lvconvert -y --type cache --cachepool cache/cache cache/cachedata<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لماذا قطع هكذا ..؟</font></font></b><div class="spoiler_text">     ,        LVM cache     LVM thin.  ,   ,        . <br>
<br>
64 —       LVM thin.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحذير رد ..!</font></font></b><div class="spoiler_text">.         .    , ,    ,      .   ,  ,  NVMe RAID 1  ,    . <br>
<br>
    ,     RAID 6   .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
دعنا نتحقق من نجاحنا: </font><font style="vertical-align: inherit;">
يجب وضع [cachedata_corig] فقط على / dev / data / cache. </font><font style="vertical-align: inherit;">إذا كان هناك شيء خاطئ ، فاستخدم pvmove. </font><font style="vertical-align: inherit;">
إذا لزم الأمر ، يمكنك تعطيل ذاكرة التخزين المؤقت بأمر واحد: </font><font style="vertical-align: inherit;">
يتم ذلك عبر الإنترنت. </font><font style="vertical-align: inherit;">يقوم LVM ببساطة بمزامنة ذاكرة التخزين المؤقت على القرص وحذفها وإعادة تسمية cachedata_corig إلى البيانات المخزنة مؤقتًا.</font></font><br>
<br>
<code>#lvs -a -o lv_name,lv_size,devices --units B cache<br>
 LV LSize Devices <br>
 [cache] 68719476736B cache_cdata(0) <br>
 [cache_cdata] 68719476736B /dev/root/cache(0) <br>
 [cache_cmeta] 1073741824B /dev/root/cache(16384)<br>
 cachedata 3298539077632B cachedata_corig(0) <br>
 [cachedata_corig] 3298539077632B /dev/data/cache(0) <br>
 [lvol0_pmspare] 1073741824B /dev/root/cache(16640)<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvconvert -y --uncache cache/cachedata</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إعداد LVM رفيع</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
سنقدّر </font><font style="vertical-align: inherit;">
تقريبًا </font><font style="vertical-align: inherit;">مقدار المساحة التي سنحتاجها للبيانات الوصفية الرقيقة LVM: </font><font style="vertical-align: inherit;">تقريب ما يصل إلى 4 غيغابايت: 4294967296B </font><font style="vertical-align: inherit;">
اضرب في اثنين وأضف 4194304B للبيانات الوصفية LVM PV: 8594128896B </font><font style="vertical-align: inherit;">
أنشئ قسمًا منفصلاً على NVMe RAID 1 لوضع علامة على البيانات الوصفية الرقيقة LVM عليها وعمل نسخة احتياطية منها:</font></font><br>
<br>
<code>#thin_metadata_size --block-size=64k --pool-size=6terabytes --max-thins=100000 -u bytes<br>
thin_metadata_size - 3385794560 bytes estimated metadata area size for "--block-size=64kibibytes --pool-size=6terabytes --max-thins=100000"</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 8594128896B --name images root</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لماذا..؟</font></font></b><div class="spoiler_text">   ,    LVM thin ,        NVMe    .<br>
<br>
     ,     .    ,  ,   .    - , ,   LVM thin  ,      .         .<br>
<br>
-    -,  , ,          .             ,      .           .<br>
<br>
 ,        , ,  ,       , ,      LVM thin,        . <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
قم بإنشاء VG جديد سيكون مسؤولاً عن التزويد الرقيق: </font><font style="vertical-align: inherit;">
إنشاء تجمع:</font></font><br>
<br>
<code>#pvcreate /dev/root/images<br>
#pvcreate /dev/cache/cachedata<br>
#vgcreate images /dev/root/images /dev/cache/cachedata</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 274877906944B --poolmetadataspare y --poolmetadatasize 4294967296B --chunksize 64k -Z y -T images/thin-pool</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لماذا -Z y</font></font></b><div class="spoiler_text"> ,       , —               , — zeroing          64k.    64k           64K    .          .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
دعنا </font><font style="vertical-align: inherit;">
ننقل LV إلى PVs المقابلة: </font><font style="vertical-align: inherit;">تحقق: </font><font style="vertical-align: inherit;">
إنشاء حجم صغير للاختبارات: </font><font style="vertical-align: inherit;">
ضع حزمًا للاختبارات والملاحظات: </font><font style="vertical-align: inherit;">
هذه هي الطريقة التي يمكنك من خلالها ملاحظة سلوك تكوين التخزين لدينا في الوقت الفعلي: </font><font style="vertical-align: inherit;">
هذه هي الطريقة التي يمكنك بها اختبار التكوين لدينا:</font></font><br>
<br>
<code>#pvmove -n images/thin-pool_tdata /dev/root/images /dev/cache/cachedata<br>
#pvmove -n images/lvol0_pmspare /dev/cache/cachedata /dev/root/images<br>
#pvmove -n images/thin-pool_tmeta /dev/cache/cachedata /dev/root/images <br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvs -a -o lv_name,lv_size,devices --units B images<br>
 LV LSize Devices <br>
 [lvol0_pmspare] 4294967296B /dev/root/images(0) <br>
 thin-pool 274877906944B thin-pool_tdata(0) <br>
 [thin-pool_tdata] 274877906944B /dev/cache/cachedata(0) <br>
 [thin-pool_tmeta] 4294967296B /dev/root/images(1024)<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -V 64G --thin-pool thin-pool --name test images</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#apt-get install sysstat fio</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#watch 'lvs --rows --reportformat basic --quiet -ocache_dirty_blocks,cache_settings cache/cachedata &amp;&amp; (lvdisplay cache/cachedata | grep Cache) &amp;&amp; (sar -p -d 2 1 | grep -E "sd|nvme|DEV|md1|md2|md3|md0" | grep -v Average | sort)'</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#fio --loops=1 --size=64G --runtime=4 --filename=/dev/images/test --stonewall --ioengine=libaio --direct=1 \<br>
--name=4kQD32read --bs=4k --iodepth=32 --rw=randread \<br>
--name=8kQD32read --bs=8k --iodepth=32 --rw=randread \<br>
--name=16kQD32read --bs=16k --iodepth=32 --rw=randread \<br>
--name=32KQD32read --bs=32k --iodepth=32 --rw=randread \<br>
--name=64KQD32read --bs=64k --iodepth=32 --rw=randread \<br>
--name=128KQD32read --bs=128k --iodepth=32 --rw=randread \<br>
--name=256KQD32read --bs=256k --iodepth=32 --rw=randread \<br>
--name=512KQD32read --bs=512k --iodepth=32 --rw=randread \<br>
--name=4Kread --bs=4k --rw=read \<br>
--name=8Kread --bs=8k --rw=read \<br>
--name=16Kread --bs=16k --rw=read \<br>
--name=32Kread --bs=32k --rw=read \<br>
--name=64Kread --bs=64k --rw=read \<br>
--name=128Kread --bs=128k --rw=read \<br>
--name=256Kread --bs=256k --rw=read \<br>
--name=512Kread --bs=512k --rw=read \<br>
--name=Seqread --bs=1m --rw=read \<br>
--name=Longread --bs=8m --rw=read \<br>
--name=Longwrite --bs=8m --rw=write \<br>
--name=Seqwrite --bs=1m --rw=write \<br>
--name=512Kwrite --bs=512k --rw=write \<br>
--name=256Kwrite --bs=256k --rw=write \<br>
--name=128Kwrite --bs=128k --rw=write \<br>
--name=64Kwrite --bs=64k --rw=write \<br>
--name=32Kwrite --bs=32k --rw=write \<br>
--name=16Kwrite --bs=16k --rw=write \<br>
--name=8Kwrite --bs=8k --rw=write \<br>
--name=4Kwrite --bs=4k --rw=write \<br>
--name=512KQD32write --bs=512k --iodepth=32 --rw=randwrite \<br>
--name=256KQD32write --bs=256k --iodepth=32 --rw=randwrite \<br>
--name=128KQD32write --bs=128k --iodepth=32 --rw=randwrite \<br>
--name=64KQD32write --bs=64k --iodepth=32 --rw=randwrite \<br>
--name=32KQD32write --bs=32k --iodepth=32 --rw=randwrite \<br>
--name=16KQD32write --bs=16k --iodepth=32 --rw=randwrite \<br>
--name=8KQD32write --bs=8k --iodepth=32 --rw=randwrite \<br>
--name=4kQD32write --bs=4k --iodepth=32 --rw=randwrite \<br>
 | grep -E 'read|write|test' | grep -v ioengine<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الحذر! </font><font style="vertical-align: inherit;">الموارد!</font></font></b><div class="spoiler_text">   36  ,       4 .     .  4   NVMe     .  3   .  ,           216   SSD.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">القراءة والكتابة المراوغة؟</font></font></b><div class="spoiler_text">.          .  ,   ,    ,        .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ستختلف النتائج بشكل كبير في البداية الأولى واللاحقة بعد ذلك ، حيث تمتلئ ذاكرة التخزين المؤقت والحجم الرقيق ، وأيضًا اعتمادًا على ما إذا كان النظام تمكن من مزامنة ذاكرة التخزين المؤقت المملوءة في البداية الأخيرة.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
من بين أمور أخرى ، أوصي بقياس السرعة على الحجم الرقيق المملوء بالفعل الذي تم عمل اللقطة منه للتو. </font><font style="vertical-align: inherit;">أتيحت للمؤلف فرصة ملاحظة كيف يتسارع التسجيل العشوائي بشكل حاد بعد إنشاء اللقطة الأولى ، خاصة عندما لا تكون ذاكرة التخزين المؤقت ممتلئة بعد. </font><font style="vertical-align: inherit;">ويرجع ذلك إلى دلالات الكتابة عند الكتابة ، ومحاذاة كتل التخزين المؤقت والأحجام الرقيقة ، وحقيقة أن الكتابة العشوائية إلى RAID 6 تتحول إلى قراءة عشوائية من RAID 6 ثم الكتابة إلى ذاكرة التخزين المؤقت. </font><font style="vertical-align: inherit;">في تكويننا ، تكون القراءة العشوائية من RAID 6 حتى 6 مرات (عدد SATA SSDs في الصفيف) أسرع من الكتابة. </font><font style="vertical-align: inherit;">لان </font><font style="vertical-align: inherit;">نظرًا لأن كتل CoW يتم تخصيصها بالتسلسل من تجمع رقيق ، فإن السجل ، في معظمه ، يتحول أيضًا إلى تسلسلي. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يمكن استخدام كل من هذه الميزات بشكل مفيد.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لقطات ذاكرة التخزين المؤقت "المتماسكة"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لتقليل خطر فقدان البيانات في حالة تلف / فقدان ذاكرة التخزين المؤقت ، يقترح المؤلف تقديم ممارسة اللقطات الدورية لضمان سلامتها في هذه الحالة. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
أولاً ، نظرًا لأن البيانات الوصفية للأحجام الرقيقة موجودة على جهاز غير مُخزن مؤقتًا ، ستكون البيانات الوصفية متسقة وسيتم عزل الخسائر المحتملة داخل كتل البيانات. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تضمن دورة تدوير اللقطات التالية تكامل البيانات داخل اللقطات في حالة فقدان ذاكرة التخزين المؤقت:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لكل مجلد رفيع باسم &lt;name&gt; ، قم بإنشاء لقطة باسم &lt;name&gt; .cached</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قم بتعيين حد الترحيل إلى قيمة عالية معقولة: </font></font><code>#lvchange --quiet --cachesettings "migration_threshold=16384" cache/cachedata</code> </li>
<li>       : <code>#lvs --rows --reportformat basic --quiet -ocache_dirty_blocks cache/cachedata | awk '{print $2}'</code>    .     ,        writethrough . ,      SATA  NVMe SSD,  ,   TBW,            ,           . -          100%    .  NVMe SSD  100%        <b>3-4 </b>. SATA SSD  -    . ,   ,       ,     , —             .</li>
<li>   ( )  —  &lt;&gt;.cached  &lt;&gt;.committed.  &lt;&gt;.committed   .</li>
<li>,     100%,    ,   .         .</li>
<li> migration threshold  : <code>#lvchange --quiet --cachesettings "migration_threshold=0" cache/cachedata</code>        . </li>
<li>,        <code>#lvs --rows --reportformat basic --quiet -ocache_dirty_blocks cache/cachedata | awk '{print $2}'</code>   .</li>
<li> . </li>
</ol><br>
<div class="spoiler"><b class="spoiler_title">   migration threshold...?</b><div class="spoiler_text">   ,     «»       .    -    4 ,   ,         -     (+- 32K) .<br>
<br>
 migration threshold        SATA SSD       64K  .      SATA SSD.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title">  ..?</b><div class="spoiler_text"> ,         bash     100%    «google»-driven development,  ,    ,      ,     .<br>
<br>
,               , ,  ,      systemd ,     .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
سيسمح لنا نظام التدوير البسيط هذا للقطات ليس فقط الحصول على لقطة واحدة متزامنة تمامًا على SATA SSD ، ولكن أيضًا بمساعدة الأداة المساعدة thin_delta لمعرفة الكتل التي تم تغييرها بعد إنشائها ، وبالتالي تحديد موقع الضرر على المجلدات الرئيسية ، مما يجعل من الأسهل بكثير الاستعادة .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تريم / تجاهل في libvirt / KVM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لان </font><font style="vertical-align: inherit;">نظرًا لأنه سيتم استخدام مخزن البيانات لتشغيل KVM libvirt ، فسيكون من الجيد تعليم أجهزة VM لدينا ليس فقط لشغل مساحة خالية ، ولكن أيضًا لتحرير ما لم يعد مطلوبًا. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يتم ذلك عن طريق محاكاة دعم TRIM / DISCARD على الأقراص الافتراضية. </font><font style="vertical-align: inherit;">للقيام بذلك ، قم بتغيير نوع وحدة التحكم إلى Virtio-scsi وتحرير xml. </font><font style="vertical-align: inherit;">
تتم معالجة DISCARDs المماثلة من أنظمة تشغيل الضيف بشكل صحيح بواسطة LVM ، ويتم تحرير الكتل بشكل صحيح في ذاكرة التخزين المؤقت وفي التجمع الرقيق. </font><font style="vertical-align: inherit;">في حالتنا ، يحدث هذا ، بشكل رئيسي ، مؤجل ، عندما تحذف اللقطة التالية.</font></font><br>
<br>
<code>#virsh edit vmname<br>
&lt;disk type='block' device='disk'&gt;<br>
 &lt;driver name='qemu' type='raw' cache='writethrough' io='threads' <b>discard='unmap'</b>/&gt;<br>
 &lt;source dev='/dev/images/vmname'/&gt;<br>
 &lt;backingStore/&gt;<br>
 &lt;target dev='sda' bus='scsi'/&gt;<br>
 &lt;alias name='scsi0-0-0-0'/&gt;<br>
 &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;<br>
&lt;/disk&gt;<br>
<br>
&lt;controller type='scsi' index='0' <b>model='virtio-scsi'</b>&gt;<br>
 &lt;alias name='scsi0'/&gt;<br>
 &lt;address type='pci' domain='0x0000' bus='0x04' slot='0x00' function='0x0'/&gt;<br>
&lt;/controller&gt;<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">النسخ الاحتياطي BTRFS</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
استخدام البرامج النصية الجاهزة مع </font></font><u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المدقع</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الحذر و </font></font><u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على مسؤوليتك الخاصة، والمخاطر</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">كتب المؤلف هذا الرمز بنفسه وحصريا لنفسه. </font><font style="vertical-align: inherit;">أنا متأكد من أن العديد من مستخدمي Linux ذوي الخبرة لديهم مثل هذه </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">العكازات من</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الخبرة ، ولن يحتاج نسخ الآخرين. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
إنشاء وحدة تخزين على جهاز النسخ الاحتياطي: </font></font><br>
<br>
<code>#lvcreate -L 256G --name backup backup</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تهيئتها في BTRFS: </font></font><br>
<br>
<code>#mkfs.btrfs /dev/backup/backup</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
إنشاء نقاط تحميل </font><font style="vertical-align: inherit;">وتثبيت </font><font style="vertical-align: inherit;">مفاتيح الجذر الفرعية لـ FS: </font><font style="vertical-align: inherit;">
إنشاء أدلة للنسخ الاحتياطية: </font><font style="vertical-align: inherit;">
إنشاء دليل للبرامج النصية للنسخ الاحتياطي: نسخ </font><font style="vertical-align: inherit;">
البرنامج النصي:</font></font><br>
<br>
<code>#mkdir /backup<br>
#mkdir /backup/btrfs<br>
#mkdir /backup/btrfs/root<br>
#mkdir /backup/btrfs/back<br>
#ln -s /boot /backup/btrfs<br>
# cat &gt;&gt;/etc/fstab &lt;&lt; EOF<br>
<br>
/dev/mapper/root-root /backup/btrfs/root btrfs defaults,space_cache,noatime,nodiratime 0 2<br>
/dev/mapper/backup-backup /backup/btrfs/back btrfs defaults,space_cache,noatime,nodiratime 0 2<br>
EOF<br>
#mount -a<br>
#update-initramfs -u<br>
#update-grub<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#mkdir /backup/btrfs/back/remote<br>
#mkdir /backup/btrfs/back/remote/root<br>
#mkdir /backup/btrfs/back/remote/boot<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#mkdir /root/btrfs-backup</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الكثير من كود باش مخيف. </font><font style="vertical-align: inherit;">استخدام على مسؤوليتك الخاصة. </font><font style="vertical-align: inherit;">المؤلف لا يكتب رسائل غاضبة ...</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/btrfs-backup/btrfs-backup.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
LOCK_FILE="/dev/shm/$SCRIPT_NAME.lock"<br>
DATE_PREFIX='%Y-%m-%d'<br>
DATE_FORMAT=$DATE_PREFIX'-%H-%M-%S'<br>
DATE_REGEX='[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]'<br>
BASE_SUFFIX=".@base"<br>
PEND_SUFFIX=".@pend"<br>
SNAP_SUFFIX=".@snap"<br>
MOUNTS="/backup/btrfs/"<br>
BACKUPS="/backup/btrfs/back/remote/"<br>
<br>
function terminate ()<br>
{<br>
 echo "$1" &gt;&amp;2<br>
 exit 1<br>
}<br>
<br>
function wait_lock()<br>
{<br>
 flock 98<br>
}<br>
<br>
function wait_lock_or_terminate()<br>
{<br>
 echo "Wating for lock..."<br>
 wait_lock || terminate "Failed to get lock. Exiting..."<br>
 echo "Got lock..."<br>
}<br>
<br>
function suffix()<br>
{<br>
 FORMATTED_DATE=$(date +"$DATE_FORMAT")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function filter()<br>
{<br>
 FORMATTED_DATE=$(date --date="$1" +"$DATE_PREFIX")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function backup()<br>
{<br>
SOURCE_PATH="$MOUNTS$1"<br>
TARGET_PATH="$BACKUPS$1"<br>
SOURCE_BASE_PATH="$MOUNTS$1$BASE_SUFFIX"<br>
TARGET_BASE_PATH="$BACKUPS$1$BASE_SUFFIX"<br>
TARGET_BASE_DIR="$(dirname $TARGET_BASE_PATH)"<br>
SOURCE_PEND_PATH="$MOUNTS$1$PEND_SUFFIX"<br>
TARGET_PEND_PATH="$BACKUPS$1$PEND_SUFFIX"<br>
 if [ -d "$SOURCE_BASE_PATH" ]<br>
 then<br>
 echo "$SOURCE_BASE_PATH found"<br>
 else<br>
 echo "$SOURCE_BASE_PATH File not found creating snapshot of $SOURCE_PATH to $SOURCE_BASE_PATH"<br>
 btrfs subvolume snapshot -r $SOURCE_PATH $SOURCE_BASE_PATH<br>
 sync<br>
 if [ -d "$TARGET_BASE_PATH" ]<br>
 then<br>
 echo "$TARGET_BASE_PATH found out of sync with source... removing..."<br>
 btrfs subvolume delete -c $TARGET_BASE_PATH<br>
 sync<br>
 fi<br>
 fi<br>
 if [ -d "$TARGET_BASE_PATH" ]<br>
 then<br>
 echo "$TARGET_BASE_PATH found"<br>
 else<br>
 echo "$TARGET_BASE_PATH not found. Synching to $TARGET_BASE_DIR"<br>
 btrfs send $SOURCE_BASE_PATH | btrfs receive $TARGET_BASE_DIR<br>
 sync<br>
 fi<br>
 if [ -d "$SOURCE_PEND_PATH" ]<br>
 then<br>
 echo "$SOURCE_PEND_PATH found removing..."<br>
 btrfs subvolume delete -c $SOURCE_PEND_PATH<br>
 sync<br>
 fi<br>
 btrfs subvolume snapshot -r $SOURCE_PATH $SOURCE_PEND_PATH<br>
 sync<br>
 if [ -d "$TARGET_PEND_PATH" ]<br>
 then<br>
 echo "$TARGET_PEND_PATH found removing..."<br>
 btrfs subvolume delete -c $TARGET_PEND_PATH<br>
 sync<br>
 fi<br>
 echo "Sending $SOURCE_PEND_PATH to $TARGET_PEND_PATH"<br>
 btrfs send -p $SOURCE_BASE_PATH $SOURCE_PEND_PATH | btrfs receive $TARGET_BASE_DIR<br>
 sync<br>
 TARGET_DATE_SUFFIX=$(suffix)<br>
 btrfs subvolume snapshot -r $TARGET_PEND_PATH "$TARGET_PATH$TARGET_DATE_SUFFIX"<br>
 sync<br>
 btrfs subvolume delete -c $SOURCE_BASE_PATH<br>
 sync<br>
 btrfs subvolume delete -c $TARGET_BASE_PATH<br>
 sync<br>
 mv $SOURCE_PEND_PATH $SOURCE_BASE_PATH<br>
 mv $TARGET_PEND_PATH $TARGET_BASE_PATH<br>
 sync<br>
}<br>
<br>
function list()<br>
{<br>
LIST_TARGET_BASE_PATH="$BACKUPS$1$BASE_SUFFIX"<br>
LIST_TARGET_BASE_DIR="$(dirname $LIST_TARGET_BASE_PATH)"<br>
LIST_TARGET_BASE_NAME="$(basename -s .$BASE_SUFFIX $LIST_TARGET_BASE_PATH)"<br>
find "$LIST_TARGET_BASE_DIR" -maxdepth 1 -mindepth 1 -type d -printf "%f\n" | grep "${LIST_TARGET_BASE_NAME/$BASE_SUFFIX/$SNAP_SUFFIX}.$DATE_REGEX"<br>
}<br>
<br>
function remove()<br>
{<br>
REMOVE_TARGET_BASE_PATH="$BACKUPS$1$BASE_SUFFIX"<br>
REMOVE_TARGET_BASE_DIR="$(dirname $REMOVE_TARGET_BASE_PATH)"<br>
btrfs subvolume delete -c $REMOVE_TARGET_BASE_DIR/$2<br>
sync<br>
}<br>
<br>
function removeall()<br>
{<br>
DATE_OFFSET="$2"<br>
FILTER="$(filter "$DATE_OFFSET")"<br>
while read -r SNAPSHOT ; do<br>
 remove "$1" "$SNAPSHOT"<br>
done &lt; &lt;(list "$1" | grep "$FILTER")<br>
<br>
}<br>
<br>
(<br>
 COMMAND="$1"<br>
 shift<br>
 <br>
 case "$COMMAND" in<br>
 "--help") <br>
 echo "Help"<br>
 ;;<br>
 "suffix") <br>
 suffix<br>
 ;;<br>
 "filter") <br>
 filter "$1"<br>
 ;;<br>
 "backup") <br>
 wait_lock_or_terminate<br>
 backup "$1"<br>
 ;;<br>
 "list") <br>
 list "$1"<br>
 ;;<br>
 "remove") <br>
 wait_lock_or_terminate<br>
 remove "$1" "$2"<br>
 ;;<br>
 "removeall") <br>
 wait_lock_or_terminate<br>
 removeall "$1" "$2"<br>
 ;;<br>
 *)<br>
 echo "None.."<br>
 ;;<br>
 esac<br>
) 98&gt;$LOCK_FILE <br>
<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ماذا يفعل حتى ..؟</font></font></b><div class="spoiler_text">       BTRFS        BTRFS send/recieve.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يمكن أن يكون الإطلاق الأول طويلًا نسبيًا ، لأنه </font><font style="vertical-align: inherit;">في البداية سيتم نسخ جميع البيانات. </font><font style="vertical-align: inherit;">المزيد من عمليات الإطلاق ستكون سريعة جدًا ، لأن </font><font style="vertical-align: inherit;">سيتم نسخ التغييرات فقط. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
سيناريو آخر في كرون:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المزيد من كود باش</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/btrfs-backup/cron-daily.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
BACKUP_SCRIPT="$SCRIPT_DIR/btrfs-backup.sh"<br>
RETENTION="-60 day"<br>
$BACKUP_SCRIPT backup root/@<br>
$BACKUP_SCRIPT removeall root/@ "$RETENTION"<br>
$BACKUP_SCRIPT backup root/@home<br>
$BACKUP_SCRIPT removeall root/@home "$RETENTION"<br>
$BACKUP_SCRIPT backup boot/<br>
$BACKUP_SCRIPT removeall boot/ "$RETENTION"<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ماذا يفعل ..؟</font></font></b><div class="spoiler_text">     backup     BTRFS-.       60  .     /backup/btrfs/back/remote/     . <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
دعونا نعطي الرمز الحق في التنفيذ: </font><font style="vertical-align: inherit;">
تحقق واكتظ في التيجان:</font></font><br>
<br>
<code>#chmod +x /root/btrfs-backup/cron-daily.sh<br>
#chmod +x /root/btrfs-backup/btrfs-backup.sh<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#/usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/btrfs-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t btrfs-backup<br>
#cat /var/log/syslog | grep btrfs-backup<br>
#crontab -e<br>
0 2 * * * /usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/btrfs-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t btrfs-backup<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LVM احتياطية رقيقة</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
إنشاء تجمع رقيقة على جهاز النسخ الاحتياطي: </font></font><br>
<br>
<code>#lvcreate -L 274877906944B --poolmetadataspare y --poolmetadatasize 4294967296B --chunksize 64k -Z y -T backup/thin-pool</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تثبيت ddrescue ، لأن </font><font style="vertical-align: inherit;">ستستخدم البرامج النصية هذه الأداة: </font></font><br>
<br>
<code>#apt-get install gddrescue</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
إنشاء دليل للنصوص البرمجية: </font></font><br>
<br>
<code>#mkdir /root/lvm-thin-backup</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نسخ البرامج النصية:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الكثير من باش في الداخل ...</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/lvm-thin-backup/lvm-thin-backup.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
LOCK_FILE="/dev/shm/$SCRIPT_NAME.lock"<br>
DATE_PREFIX='%Y-%m-%d'<br>
DATE_FORMAT=$DATE_PREFIX'-%H-%M-%S'<br>
DATE_REGEX='[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]'<br>
BASE_SUFFIX=".base"<br>
PEND_SUFFIX=".pend"<br>
SNAP_SUFFIX=".snap"<br>
BACKUPS="backup"<br>
BACKUPS_POOL="thin-pool"<br>
<br>
export LVM_SUPPRESS_FD_WARNINGS=1<br>
<br>
function terminate ()<br>
{<br>
 echo "$1" &gt;&amp;2<br>
 exit 1<br>
}<br>
<br>
function wait_lock()<br>
{<br>
 flock 98<br>
}<br>
<br>
function wait_lock_or_terminate()<br>
{<br>
 echo "Wating for lock..."<br>
 wait_lock || terminate "Failed to get lock. Exiting..."<br>
 echo "Got lock..."<br>
}<br>
<br>
function suffix()<br>
{<br>
 FORMATTED_DATE=$(date +"$DATE_FORMAT")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function filter()<br>
{<br>
 FORMATTED_DATE=$(date --date="$1" +"$DATE_PREFIX")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function read_thin_id {<br>
lvs --rows --reportformat basic --quiet -othin_id "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_pool_lv {<br>
lvs --rows --reportformat basic --quiet -opool_lv "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_dm_path {<br>
lvs --rows --reportformat basic --quiet -olv_dm_path "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_active {<br>
lvs --rows --reportformat basic --quiet -olv_active "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_chunk_size {<br>
lvs --rows --reportformat basic --quiet --units b --nosuffix -ochunk_size "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_size {<br>
lvs --rows --reportformat basic --quiet --units b --nosuffix -olv_size "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function activate_volume {<br>
lvchange -ay -Ky "$1/$2"<br>
}<br>
<br>
function deactivate_volume {<br>
lvchange -an "$1/$2"<br>
}<br>
<br>
function read_thin_metadata_snap {<br>
dmsetup status "$1" | awk '{print $7}'<br>
}<br>
<br>
function thindiff()<br>
{<br>
DIFF_VG="$1"<br>
DIFF_SOURCE="$2"<br>
DIFF_TARGET="$3"<br>
DIFF_SOURCE_POOL=$(read_pool_lv $DIFF_VG $DIFF_SOURCE)<br>
DIFF_TARGET_POOL=$(read_pool_lv $DIFF_VG $DIFF_TARGET)<br>
<br>
if [ "$DIFF_SOURCE_POOL" == "" ]<br>
then<br>
 (&gt;&amp;2 echo "Source LV is not thin.")<br>
 exit 1<br>
fi<br>
<br>
if [ "$DIFF_TARGET_POOL" == "" ]<br>
then<br>
 (&gt;&amp;2 echo "Target LV is not thin.")<br>
 exit 1<br>
fi<br>
<br>
if [ "$DIFF_SOURCE_POOL" != "$DIFF_TARGET_POOL" ]<br>
then<br>
 (&gt;&amp;2 echo "Source and target LVs belong to different thin pools.")<br>
 exit 1<br>
fi<br>
<br>
DIFF_POOL_PATH=$(read_lv_dm_path $DIFF_VG $DIFF_SOURCE_POOL)<br>
DIFF_SOURCE_ID=$(read_thin_id $DIFF_VG $DIFF_SOURCE)<br>
DIFF_TARGET_ID=$(read_thin_id $DIFF_VG $DIFF_TARGET)<br>
DIFF_POOL_PATH_TPOOL="$DIFF_POOL_PATH-tpool"<br>
DIFF_POOL_PATH_TMETA="$DIFF_POOL_PATH"_tmeta<br>
DIFF_POOL_METADATA_SNAP=$(read_thin_metadata_snap $DIFF_POOL_PATH_TPOOL)<br>
<br>
if [ "$DIFF_POOL_METADATA_SNAP" != "-" ]<br>
then<br>
 (&gt;&amp;2 echo "Thin pool metadata snapshot already exist. Assuming stale one. Will release metadata snapshot in 5 seconds.")<br>
 sleep 5<br>
 dmsetup message $DIFF_POOL_PATH_TPOOL 0 release_metadata_snap<br>
fi<br>
<br>
dmsetup message $DIFF_POOL_PATH_TPOOL 0 reserve_metadata_snap<br>
DIFF_POOL_METADATA_SNAP=$(read_thin_metadata_snap $DIFF_POOL_PATH_TPOOL)<br>
<br>
if [ "$DIFF_POOL_METADATA_SNAP" == "-" ]<br>
then<br>
 (&gt;&amp;2 echo "Failed to create thin pool metadata snapshot.")<br>
 exit 1<br>
fi<br>
<br>
#We keep output in variable because metadata snapshot need to be released early.<br>
DIFF_DATA=$(thin_delta -m$DIFF_POOL_METADATA_SNAP --snap1 $DIFF_SOURCE_ID --snap2 $DIFF_TARGET_ID $DIFF_POOL_PATH_TMETA)<br>
<br>
dmsetup message $DIFF_POOL_PATH_TPOOL 0 release_metadata_snap<br>
<br>
echo $"$DIFF_DATA" | grep -E 'different|left_only|right_only' | sed 's/&lt;/"/g' | sed 's/ /"/g' | awk -F'\"' '{print $6 "\t" $8 "\t" $11}' | sed 's/different/copy/g' | sed 's/left_only/copy/g' | sed 's/right_only/discard/g'<br>
<br>
}<br>
<br>
function thinsync()<br>
{<br>
SYNC_VG="$1"<br>
SYNC_PEND="$2"<br>
SYNC_BASE="$3"<br>
SYNC_TARGET="$4"<br>
SYNC_PEND_POOL=$(read_pool_lv $SYNC_VG $SYNC_PEND)<br>
SYNC_BLOCK_SIZE=$(read_lv_chunk_size $SYNC_VG $SYNC_PEND_POOL)<br>
SYNC_PEND_PATH=$(read_lv_dm_path $SYNC_VG $SYNC_PEND)<br>
<br>
activate_volume $SYNC_VG $SYNC_PEND<br>
<br>
while read -r SYNC_ACTION SYNC_OFFSET SYNC_LENGTH ; do<br>
 SYNC_OFFSET_BYTES=$((SYNC_OFFSET * SYNC_BLOCK_SIZE))<br>
 SYNC_LENGTH_BYTES=$((SYNC_LENGTH * SYNC_BLOCK_SIZE))<br>
 if [ "$SYNC_ACTION" == "copy" ]<br>
 then<br>
 ddrescue --quiet --force --input-position=$SYNC_OFFSET_BYTES --output-position=$SYNC_OFFSET_BYTES --size=$SYNC_LENGTH_BYTES "$SYNC_PEND_PATH" "$SYNC_TARGET"<br>
 fi<br>
<br>
if [ "$SYNC_ACTION" == "discard" ]<br>
 then<br>
 blkdiscard -o $SYNC_OFFSET_BYTES -l $SYNC_LENGTH_BYTES "$SYNC_TARGET"<br>
 fi<br>
done &lt; &lt;(thindiff "$SYNC_VG" "$SYNC_PEND" "$SYNC_BASE")<br>
}<br>
<br>
function discard_volume()<br>
{<br>
DISCARD_VG="$1"<br>
DISCARD_LV="$2"<br>
DISCARD_LV_PATH=$(read_lv_dm_path "$DISCARD_VG" "$DISCARD_LV")<br>
if [ "$DISCARD_LV_PATH" != "" ]<br>
then<br>
 echo "$DISCARD_LV_PATH found"<br>
else<br>
 echo "$DISCARD_LV not found in $DISCARD_VG"<br>
 exit 1<br>
fi<br>
DISCARD_LV_POOL=$(read_pool_lv $DISCARD_VG $DISCARD_LV)<br>
DISCARD_LV_SIZE=$(read_lv_size "$DISCARD_VG" "$DISCARD_LV")<br>
lvremove -y --quiet "$DISCARD_LV_PATH" || exit 1<br>
lvcreate --thin-pool "$DISCARD_LV_POOL" -V "$DISCARD_LV_SIZE"B --name "$DISCARD_LV" "$DISCARD_VG" || exit 1<br>
}<br>
<br>
function backup()<br>
{<br>
SOURCE_VG="$1"<br>
SOURCE_LV="$2"<br>
TARGET_VG="$BACKUPS"<br>
TARGET_LV="$SOURCE_VG-$SOURCE_LV"<br>
SOURCE_BASE_LV="$SOURCE_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV="$TARGET_LV$BASE_SUFFIX"<br>
SOURCE_PEND_LV="$SOURCE_LV$PEND_SUFFIX"<br>
TARGET_PEND_LV="$TARGET_LV$PEND_SUFFIX"<br>
SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
SOURCE_PEND_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_PEND_LV")<br>
TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
TARGET_PEND_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_PEND_LV")<br>
<br>
if [ "$SOURCE_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_BASE_LV_PATH found"<br>
 else<br>
 echo "Source base not found creating snapshot of $SOURCE_VG/$SOURCE_LV to $SOURCE_VG/$SOURCE_BASE_LV"<br>
 lvcreate --quiet --snapshot --name "$SOURCE_BASE_LV" "$SOURCE_VG/$SOURCE_LV" || exit 1<br>
 SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 echo "Discarding $SOURCE_BASE_LV_PATH as we need to bootstrap."<br>
 SOURCE_BASE_POOL=$(read_pool_lv $SOURCE_VG $SOURCE_BASE_LV)<br>
 SOURCE_BASE_CHUNK_SIZE=$(read_lv_chunk_size $SOURCE_VG $SOURCE_BASE_POOL)<br>
 discard_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 sync<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found out of sync with source... removing..."<br>
 lvremove -y --quiet $TARGET_BASE_LV_PATH || exit 1<br>
 TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
 sync<br>
 fi<br>
 fi<br>
SOURCE_BASE_SIZE=$(read_lv_size "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found"<br>
 else<br>
 echo "$TARGET_VG/$TARGET_LV not found. Creating empty volume."<br>
 lvcreate --thin-pool "$BACKUPS_POOL" -V "$SOURCE_BASE_SIZE"B --name "$TARGET_BASE_LV" "$TARGET_VG" || exit 1<br>
 echo "Have to rebootstrap. Discarding source at $SOURCE_BASE_LV_PATH"<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 SOURCE_BASE_POOL=$(read_pool_lv $SOURCE_VG $SOURCE_BASE_LV)<br>
 SOURCE_BASE_CHUNK_SIZE=$(read_lv_chunk_size $SOURCE_VG $SOURCE_BASE_POOL)<br>
 discard_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 TARGET_BASE_POOL=$(read_pool_lv $TARGET_VG $TARGET_BASE_LV)<br>
 TARGET_BASE_CHUNK_SIZE=$(read_lv_chunk_size $TARGET_VG $TARGET_BASE_POOL)<br>
 TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
 echo "Discarding target at $TARGET_BASE_LV_PATH"<br>
 discard_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 sync<br>
 fi<br>
 if [ "$SOURCE_PEND_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_PEND_LV_PATH found removing..."<br>
 lvremove -y --quiet "$SOURCE_PEND_LV_PATH" || exit 1<br>
 sync<br>
 fi<br>
 lvcreate --quiet --snapshot --name "$SOURCE_PEND_LV" "$SOURCE_VG/$SOURCE_LV" || exit 1<br>
SOURCE_PEND_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_PEND_LV")<br>
 sync<br>
 if [ "$TARGET_PEND_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_PEND_LV_PATH found removing..."<br>
 lvremove -y --quiet $TARGET_PEND_LV_PATH<br>
 sync<br>
 fi<br>
 lvcreate --quiet --snapshot --name "$TARGET_PEND_LV" "$TARGET_VG/$TARGET_BASE_LV" || exit 1<br>
TARGET_PEND_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_PEND_LV")<br>
SOURCE_PEND_LV_SIZE=$(read_lv_size "$SOURCE_VG" "$SOURCE_PEND_LV")<br>
 lvresize -L "$SOURCE_PEND_LV_SIZE"B "$TARGET_PEND_LV_PATH"<br>
 activate_volume "$TARGET_VG" "$TARGET_PEND_LV"<br>
 echo "Synching $SOURCE_PEND_LV_PATH to $TARGET_PEND_LV_PATH"<br>
 thinsync "$SOURCE_VG" "$SOURCE_PEND_LV" "$SOURCE_BASE_LV" "$TARGET_PEND_LV_PATH" || exit 1<br>
 sync<br>
<br>
TARGET_DATE_SUFFIX=$(suffix)<br>
 lvcreate --quiet --snapshot --name "$TARGET_LV$TARGET_DATE_SUFFIX" "$TARGET_VG/$TARGET_PEND_LV" || exit 1<br>
 sync<br>
 lvremove --quiet -y "$SOURCE_BASE_LV_PATH" || exit 1<br>
 sync<br>
 lvremove --quiet -y "$TARGET_BASE_LV_PATH" || exit 1<br>
 sync<br>
 lvrename -y "$SOURCE_VG/$SOURCE_PEND_LV" "$SOURCE_BASE_LV" || exit 1<br>
 lvrename -y "$TARGET_VG/$TARGET_PEND_LV" "$TARGET_BASE_LV" || exit 1<br>
 sync<br>
 deactivate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 deactivate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
}<br>
<br>
function verify()<br>
{<br>
SOURCE_VG="$1"<br>
SOURCE_LV="$2"<br>
TARGET_VG="$BACKUPS"<br>
TARGET_LV="$SOURCE_VG-$SOURCE_LV"<br>
SOURCE_BASE_LV="$SOURCE_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV="$TARGET_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
<br>
if [ "$SOURCE_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_BASE_LV_PATH found"<br>
 else<br>
 echo "$SOURCE_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found"<br>
 else<br>
 echo "$TARGET_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 activate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 echo Comparing "$SOURCE_BASE_LV_PATH" with "$TARGET_BASE_LV_PATH"<br>
 cmp "$SOURCE_BASE_LV_PATH" "$TARGET_BASE_LV_PATH"<br>
 echo Done...<br>
 deactivate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 deactivate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
}<br>
<br>
function resync()<br>
{<br>
SOURCE_VG="$1"<br>
SOURCE_LV="$2"<br>
TARGET_VG="$BACKUPS"<br>
TARGET_LV="$SOURCE_VG-$SOURCE_LV"<br>
SOURCE_BASE_LV="$SOURCE_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV="$TARGET_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
<br>
if [ "$SOURCE_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_BASE_LV_PATH found"<br>
 else<br>
 echo "$SOURCE_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found"<br>
 else<br>
 echo "$TARGET_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 activate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 SOURCE_BASE_POOL=$(read_pool_lv $SOURCE_VG $SOURCE_BASE_LV)<br>
 SYNC_BLOCK_SIZE=$(read_lv_chunk_size $SOURCE_VG $SOURCE_BASE_POOL)<br>
<br>
echo Syncronizing "$SOURCE_BASE_LV_PATH" to "$TARGET_BASE_LV_PATH"<br>
<br>
CMP_OFFSET=0<br>
 while [[ "$CMP_OFFSET" != "" ]] ; do<br>
 CMP_MISMATCH=$(cmp -i "$CMP_OFFSET" "$SOURCE_BASE_LV_PATH" "$TARGET_BASE_LV_PATH" | grep differ | awk '{print $5}' | sed 's/,//g' )<br>
 if [[ "$CMP_MISMATCH" != "" ]] ; then<br>
 CMP_OFFSET=$(( CMP_MISMATCH + CMP_OFFSET ))<br>
 SYNC_OFFSET_BYTES=$(( ( CMP_OFFSET / SYNC_BLOCK_SIZE ) * SYNC_BLOCK_SIZE ))<br>
 SYNC_LENGTH_BYTES=$(( SYNC_BLOCK_SIZE ))<br>
 echo "Synching $SYNC_LENGTH_BYTES bytes at $SYNC_OFFSET_BYTES from $SOURCE_BASE_LV_PATH to $TARGET_BASE_LV_PATH"<br>
 ddrescue --quiet --force --input-position=$SYNC_OFFSET_BYTES --output-position=$SYNC_OFFSET_BYTES --size=$SYNC_LENGTH_BYTES "$SOURCE_BASE_LV_PATH" "$TARGET_BASE_LV_PATH"<br>
 else<br>
 CMP_OFFSET=""<br>
 fi<br>
 done<br>
 echo Done...<br>
 deactivate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 deactivate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
}<br>
<br>
function list()<br>
{<br>
LIST_SOURCE_VG="$1"<br>
LIST_SOURCE_LV="$2"<br>
LIST_TARGET_VG="$BACKUPS"<br>
LIST_TARGET_LV="$LIST_SOURCE_VG-$LIST_SOURCE_LV"<br>
LIST_TARGET_BASE_LV="$LIST_TARGET_LV$SNAP_SUFFIX"<br>
lvs -olv_name | grep "$LIST_TARGET_BASE_LV.$DATE_REGEX"<br>
}<br>
<br>
function remove()<br>
{<br>
REMOVE_TARGET_VG="$BACKUPS"<br>
REMOVE_TARGET_LV="$1"<br>
lvremove -y "$REMOVE_TARGET_VG/$REMOVE_TARGET_LV"<br>
sync<br>
}<br>
<br>
function removeall()<br>
{<br>
DATE_OFFSET="$3"<br>
FILTER="$(filter "$DATE_OFFSET")"<br>
while read -r SNAPSHOT ; do<br>
 remove "$SNAPSHOT"<br>
done &lt; &lt;(list "$1" "$2" | grep "$FILTER")<br>
<br>
}<br>
<br>
(<br>
 COMMAND="$1"<br>
 shift<br>
 <br>
 case "$COMMAND" in<br>
 "--help") <br>
 echo "Help"<br>
 ;;<br>
 "suffix") <br>
 suffix<br>
 ;;<br>
 "filter") <br>
 filter "$1"<br>
 ;;<br>
 "backup") <br>
 wait_lock_or_terminate<br>
 backup "$1" "$2"<br>
 ;;<br>
 "list") <br>
 list "$1" "$2"<br>
 ;;<br>
 "thindiff") <br>
 thindiff "$1" "$2" "$3"<br>
 ;;<br>
 "thinsync") <br>
 thinsync "$1" "$2" "$3" "$4"<br>
 ;;<br>
 "verify") <br>
 wait_lock_or_terminate<br>
 verify "$1" "$2"<br>
 ;;<br>
 "resync") <br>
 wait_lock_or_terminate<br>
 resync "$1" "$2"<br>
 ;;<br>
 "remove") <br>
 wait_lock_or_terminate<br>
 remove "$1"<br>
 ;;<br>
 "removeall") <br>
 wait_lock_or_terminate<br>
 removeall "$1" "$2" "$3"<br>
 ;;<br>
 *)<br>
 echo "None.."<br>
 ;;<br>
 esac<br>
) 98&gt;$LOCK_FILE <br>
<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ماذا يفعل ...؟</font></font></b><div class="spoiler_text">             ,   thin_delta,       ddrescue  blkdiscard.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نص آخر سنضعه في التيجان:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المزيد من باش</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/lvm-thin-backup/cron-daily.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
BACKUP_SCRIPT="$SCRIPT_DIR/lvm-thin-backup.sh"<br>
RETENTION="-60 days"<br>
<br>
$BACKUP_SCRIPT backup images linux-dev<br>
$BACKUP_SCRIPT backup images win8<br>
$BACKUP_SCRIPT backup images win8-data<br>
#etc<br>
<br>
$BACKUP_SCRIPT removeall images linux-dev "$RETENTION"<br>
$BACKUP_SCRIPT removeall images win8 "$RETENTION"<br>
$BACKUP_SCRIPT removeall images win8-data "$RETENTION"<br>
#etc<br>
<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ماذا يفعل ...؟</font></font></b><div class="spoiler_text">  ,         .      ,        .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يجب تعديل هذا النص البرمجي ، مما يشير إلى قائمة المجلدات الرقيقة التي تتطلب نسخًا احتياطية لها. </font><font style="vertical-align: inherit;">الأسماء المعطاة هي لأغراض التوضيح فقط. </font><font style="vertical-align: inherit;">إذا كنت ترغب في ذلك ، يمكنك كتابة برنامج نصي يقوم بمزامنة جميع المجلدات. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
دعونا نعطي الحقوق: </font><font style="vertical-align: inherit;">
تحقق وتكدس في التيجان: </font><font style="vertical-align: inherit;">
سيكون الإطلاق الأول طويلًا ، لأنه </font><font style="vertical-align: inherit;">ستتم مزامنة وحدات التخزين الرفيعة بشكل كامل عن طريق نسخ المساحة المستخدمة بالكامل. </font><font style="vertical-align: inherit;">بفضل البيانات الوصفية الرقيقة LVM ، نحن نعرف الكتل المستخدمة بالفعل ، لذلك لن يتم نسخ سوى الكتل الفعلية للأحجام الرقيقة فقط. </font><font style="vertical-align: inherit;">
ستقوم عمليات الإطلاق اللاحقة بنسخ البيانات بشكل تدريجي من خلال تتبع التغييرات من خلال بيانات التعريف الرقيقة LVM.</font></font><br>
<br>
<code>#chmod +x /root/lvm-thin-backup/cron-daily.sh<br>
#chmod +x /root/lvm-thin-backup/lvm-thin-backup.sh</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#/usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/lvm-thin-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t lvm-thin-backup<br>
#cat /var/log/syslog | grep lvm-thin-backup<br>
#crontab -e<br>
0 3 * * * /usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/lvm-thin-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t lvm-thin-backup<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">دعونا نرى ما حدث:</font></font></h3><br>
<code>#time /root/btrfs-backup/cron-daily.sh<br>
real 0m2,967s<br>
user 0m0,225s<br>
sys 0m0,353s<br>
<br>
#time /root/lvm-thin-backup/cron-daily.sh<br>
real 1m2,710s<br>
user 0m12,721s<br>
sys 0m6,671s<br>
<br>
#ls -al /backup/btrfs/back/remote/*<br>
/backup/btrfs/back/remote/boot:<br>
total 0<br>
drwxr-xr-x 1 root root 1260  26 09:11 .<br>
drwxr-xr-x 1 root root 16  6 09:30 ..<br>
drwxr-xr-x 1 root root 322  26 02:00 .@base<br>
drwxr-xr-x 1 root root 516  6 09:39 .@snap.2020-03-06-09-39-37<br>
drwxr-xr-x 1 root root 516  6 09:39 .@snap.2020-03-06-09-39-57<br>
...<br>
/backup/btrfs/back/remote/root:<br>
total 0<br>
drwxr-xr-x 1 root root 2820  26 09:11 .<br>
drwxr-xr-x 1 root root 16  6 09:30 ..<br>
drwxr-xr-x 1 root root 240  26 09:11 @.@base<br>
drwxr-xr-x 1 root root 22  26 09:11 @home.@base<br>
drwxr-xr-x 1 root root 22  6 09:39 @home.@snap.2020-03-06-09-39-35<br>
drwxr-xr-x 1 root root 22  6 09:39 @home.@snap.2020-03-06-09-39-57<br>
...<br>
drwxr-xr-x 1 root root 240  6 09:39 @.@snap.2020-03-06-09-39-26<br>
drwxr-xr-x 1 root root 240  6 09:39 @.@snap.2020-03-06-09-39-56<br>
...<br>
<br>
#lvs -olv_name,lv_size images &amp;&amp; lvs -olv_name,lv_size backup<br>
 LV LSize <br>
 linux-dev 128,00g<br>
 linux-dev.base 128,00g<br>
 thin-pool 1,38t<br>
 win8 128,00g<br>
 win8-data 2,00t<br>
 win8-data.base 2,00t<br>
 win8.base 128,00g<br>
 LV LSize <br>
 backup 256,00g<br>
 images-linux-dev.base 128,00g<br>
 images-linux-dev.snap.2020-03-08-10-09-11 128,00g<br>
 images-linux-dev.snap.2020-03-08-10-09-25 128,00g<br>
...<br>
 images-win8-data.base 2,00t<br>
 images-win8-data.snap.2020-03-16-14-11-55 2,00t<br>
 images-win8-data.snap.2020-03-16-14-19-50 2,00t<br>
...<br>
 images-win8.base 128,00g<br>
 images-win8.snap.2020-03-17-04-51-46 128,00g<br>
 images-win8.snap.2020-03-18-03-02-49 128,00g<br>
...<br>
 thin-pool &lt;2,09t<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وماذا عن تعشيش الدمى؟</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
على الأرجح ، على الرغم من أن الأحجام المنطقية LVM LV يمكن أن تكون أحجام LVM PV المادية لـ VGs أخرى. </font><font style="vertical-align: inherit;">يمكن أن تكون LVM عودية ، مثل دمى التعشيش. </font><font style="vertical-align: inherit;">هذا يمنح LVM مرونة قصوى.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ملاحظة</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في المقالة التالية ، سنحاول استخدام العديد من أنظمة التخزين المحمولة / KVMs المتشابهة كأساس لإنشاء مجموعة تخزين / vm موزعة جغرافيًا مع التكرار في عدة قارات من خلال أجهزة الكمبيوتر المكتبية المنزلية والإنترنت المنزلي وشبكات P2P.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar492820/index.html">صافي النواة: الحصول على البيانات في طلب من مصادر مختلفة</a></li>
<li><a href="../ar492822/index.html">مطورو CSS - لماذا يحتاجهم العالم؟</a></li>
<li><a href="../ar492828/index.html">كيفية البقاء في عالم مغلق</a></li>
<li><a href="../ar492830/index.html">SameSite = Lax افتراضيًا - بالفعل في Chrome 80 مستقر (وإن لم يكن متاحًا للجميع بعد)</a></li>
<li><a href="../ar492832/index.html">بوابة إنترنت الأشياء للبروتوكولات الصناعية القائمة على i.MX6 و Linux</a></li>
<li><a href="../ar492838/index.html">قم بتوصيل M5Stack بالتلفزيون</a></li>
<li><a href="../ar492844/index.html">كيفية تصور وتحريك النماذج (الجيوفيزيائية). الرسوم المتحركة ثلاثية الأبعاد وتصور بيانات 4D</a></li>
<li><a href="../ar492850/index.html">لا يريد الجميع التحول إلى العمل عن بُعد</a></li>
<li><a href="../ar492856/index.html">Covid19 ، مجتمعك وأنت من وجهة نظر علم البيانات. مقال مترجم من قبل جيريمي هوارد وراشيل توماس (fast.ai)</a></li>
<li><a href="../ar492862/index.html">15 أفضل نصائح ضبط أداء Oracle APEX للمطورين</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>