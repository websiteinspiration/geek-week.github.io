<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèº ‚úçÔ∏è üßùüèª Distributed wheelset registry: experience with Hyperledger Fabric üêû üëÜüèª üòø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, I work in the project team of the RRP KP (distributed data register for monitoring the life cycle of wheelsets). Here I want to share the experien...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Distributed wheelset registry: experience with Hyperledger Fabric</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489002/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hi, I work in the project team of the RRP KP (distributed data register for monitoring the life cycle of wheelsets). Here I want to share the experience of our team in developing a corporate blockchain for this project under the conditions imposed by technology. For the most part I will talk about Hyperledger Fabric, but the approach described here can be extrapolated to any permissioned blockchain. The ultimate goal of our research is to prepare corporate blockchain solutions so that the final product is pleasant to use and not too hard to maintain.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There will be no discoveries, unexpected solutions and no unique developments will be covered here (because I do not have them). </font><font style="vertical-align: inherit;">I just want to share my modest experience, to show that ‚Äúit was possible‚Äù and, perhaps, to read about the experiences of others in making good and not so good decisions in the comments.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem: blockchains are not scaled yet</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Today, the efforts of many developers are aimed at making the blockchain a really convenient technology, and not a time bomb in a beautiful wrapper. State channels, optimistic rollup, plasma, and sharding may become everyday. Someday. Or perhaps TON will again delay the launch for six months, and the next Plasma Group will cease to exist. We can believe in another roadmap and read brilliant white papers for the night, but here and now we need to do something with what we have. Get shit done.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The task set for our team in the current project looks like this in general: there are many entities reaching several thousand, not wishing to build relationships on trust; it is necessary to build such a solution on DLT that will work on ordinary PCs without special performance requirements and provide a user experience no worse than any centralized accounting system. The technology underlying the solution should minimize the possibility of malicious manipulation of data - this is why the blockchain is here. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Slogans from whitepapers and the media promise us that the next development will allow you to make millions of transactions per second. What really is?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mainnet Ethereum is now running at ~ 30 tps. </font><font style="vertical-align: inherit;">Already because of this, it is difficult to perceive it as any blockchain suitable for corporate needs. </font><font style="vertical-align: inherit;">Among permissioned-solutions, benchmarks are known, showing 2000 tps ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quorum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) or 3000 tps ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hyperledger Fabric</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the publication is slightly smaller, but you need to consider that the benchmark was carried out on the old consensus engine). </font><font style="vertical-align: inherit;">There was </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an attempt to radically revise Fabric</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which did not give the worst results, 20,000 tps, but so far this is only academic research waiting for its stable implementation. </font><font style="vertical-align: inherit;">It is unlikely that a corporation that can afford to maintain a department of blockchain developers will put up with such indicators. </font><font style="vertical-align: inherit;">But the problem is not only throughput, there is still latency.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latency</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The delay from the moment the transaction is initiated to its final approval by the system depends not only on the speed of the message passing through all stages of validation and ordering, but also on the parameters of the formation of the block. Even if our blockchain allows us to commit at a speed of 1,000,000 tps, but it takes 10 minutes to form a 488 MB block, will it become easier for us? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's take a closer look at the transaction life cycle in Hyperledger Fabric to understand what the time is spent on and how it relates to the parameters of block formation. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/mx/f5/hkmxf5adied9tlyfxtkdcltitiw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">taken from here</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hyperledger-fabric.readthedocs.io/en/release-1.4/arch-deep-dive.html#swimlane</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(1) The client generates a transaction, sends it to endorsing peers, the latter simulate the transaction (apply the changes made by the chaincode to the current state, but do not commit to the ledger) and get RWSet - key names, versions and values ‚Äã‚Äãtaken from the collection in CouchDB, ( 2) endorsers send back the signed RWSet to the client, (3) the client either checks for the signatures of all necessary peers (endorsers), and then sends the transaction to the ordering service, or sends it without verification (verification will still take place later), ordering service forms a block and ( 4) sends back to all peers, not only endorsers; peers check that the key versions in the read set match the versions in the database, the signatures of all endorsers, and finally commit the block.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But that's not all. The words ‚Äúorder forms a block‚Äù hide not only the ordering of transactions, but also 3 consecutive network requests from the leader to the followers and vice versa: the leader adds a message to the log, sends followers, the latter add to his log, send confirmation of successful replication to the leader, the leader commits a message , sends a commit confirmation to followers, followers commit. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The smaller the size and time of forming the block, the more often it will be necessary for the ordering service to establish consensus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hyperledger Fabric has two parameters of block formation: BatchTimeout - time of block formation and BatchSize - block size (number of transactions and the size of the block itself in bytes). </font><font style="vertical-align: inherit;">As soon as one of the parameters reaches the limit, a new block is released. </font><font style="vertical-align: inherit;">The more warrant nodes, the longer it will take. </font><font style="vertical-align: inherit;">Therefore, you need to increase BatchTimeout and BatchSize. </font><font style="vertical-align: inherit;">But since RWSets are versioned, the more we make a block, the higher the likelihood of MVCC conflicts. </font><font style="vertical-align: inherit;">In addition, with an increase in BatchTimeout, UX is catastrophically degrading. </font><font style="vertical-align: inherit;">It seems to me reasonable and obvious the following scheme to solve these problems.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avoid waiting for block finalization and not lose the ability to track transaction status</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The longer the formation time and the block size, the higher the throughput of the blockchain. One of the other does not follow directly, but it should be remembered that consensus building in RAFT requires three network requests from the leader to the followers and vice versa. The more order nodes, the longer it will take. The smaller the size and formation time of the block, the more such interactions. How to increase the formation time and the block size without increasing the waiting time for a system response for the end user? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firstly, you need to somehow solve MVCC conflicts caused by a large block size, which may include different RWSets with the same version. Obviously, on the client side (in relation to the blockchain network, this may well be the backend, and I mean it), you need an </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MVCC conflict handler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which can be either a separate service or a regular decorator over a transaction-triggering call with retry logic. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retry can be implemented with an exponential strategy, but then latency will degrade just as exponentially. So you should use either a randomized retry within certain small limits, or a permanent one. With an eye on possible conflicts in the first embodiment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next step is to make the client‚Äôs interaction with the system asynchronous so that it does not wait 15, 30, or 10,000,000 seconds, which we will set as BatchTimeout. But at the same time, you need to save the opportunity to make sure that the changes initiated by the transaction are written / not written to the blockchain.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can use a database to store transaction status. The easiest option is CouchDB because of ease of use: the database has a UI out of the box, a REST API, and you can easily configure replication and sharding for it. You can create just a separate collection in the same CouchDB instance that Fabric uses to store its world state. We need to store documents of this kind.</font></font><br>
<br>
<pre><code class="json hljs">{<font></font>
&nbsp;Status string <span class="hljs-comment">//  : "pending", "done", "failed"</span>
&nbsp;TxID: string <span class="hljs-comment">// ID </span>
&nbsp;Error: string <span class="hljs-comment">// optional,   </span>
}</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This document is written to the database before the transaction is transferred to peers, an entity ID is returned to the user (the same ID is used as a key) if this is an operation to create something, and then the Status, TxID and Error fields are updated as relevant information from peers is received. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fu/0b/jb/fu0bjbp0rlxexrco1hrtzfrdwym.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this scheme, the user does not wait for the block to finally form, watching the spinning wheel on the screen for 10 seconds, he receives an instant response from the system and continues to work.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We chose BoltDB for storing transaction statuses, because we need to save memory and don‚Äôt want to spend time on network interaction with a stand-alone database server, especially when this interaction takes place using the plain text protocol. By the way, you use CouchDB to implement the scheme described above or just to store the world state, in any case, it makes sense to optimize the way data is stored in CouchDB. By default, in CouchDB, the size of b-tree nodes is 1279 bytes, which is much smaller than the sector size on the disk, which means that both reading and rebalancing the tree will require more physical disk accesses. The optimal size complies with the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advanced Format</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> standard </font><font style="vertical-align: inherit;">and is 4 kilobytes. For optimization, we need to set the </font><b><font style="vertical-align: inherit;">btree_chunk_size</font></b><font style="vertical-align: inherit;"> parameter </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to 4096</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the CouchDB configuration file. </font><font style="vertical-align: inherit;">For BoltDB, such manual intervention is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not required</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Backpressure: buffer strategy</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But there can be a lot of messages. </font><font style="vertical-align: inherit;">More than the system is capable of processing, sharing resources with a dozen other services besides those shown in the diagram - and all this should work without fail even on machines on which launching Intellij Idea will be extremely tedious. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problem of different throughputs of communicating systems, producer and consumer, is solved in different ways. </font><font style="vertical-align: inherit;">Let's see what we could do. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dropping</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : we can claim to be able to process no more than X transactions in T seconds. </font><font style="vertical-align: inherit;">All requests that exceed this limit are reset. </font><font style="vertical-align: inherit;">It's pretty simple, but then you can forget about UX. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controlling</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: the consumer should have some interface through which, depending on the load, he will be able to control the producer's tps. Not bad, but it imposes obligations on the developers of the client creating the load to implement this interface. For us, this is unacceptable, since the blockchain in the future will be integrated into a large number of long-existing systems. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buffering</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Instead of contriving to resist the input data stream, we can buffer this stream and process it at the required speed. Obviously, this is the best solution if we want to provide a good user experience. We implemented the buffer using the queue in RabbitMQ.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hz/cf/b7/hzcfb7f-n6ipwduhqq7aotr2nhk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Two new actions were added to the scheme: (1) after receiving the request for the API, a message with the parameters necessary to call the transaction is queued, and the client receives a message that the transaction was accepted by the system, (2) the backend reads the data with the speed specified in the config from the queue; </font><font style="vertical-align: inherit;">initiates a transaction and updates the data in the status store. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now you can increase the formation time and block capacity as much as you want, hiding delays from the user.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Other tools</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nothing was said here about the chaincode, because, as a rule, there is nothing to optimize in it. </font><font style="vertical-align: inherit;">Chaincode should be as simple and secure as possible - that's all that is required of it. </font><font style="vertical-align: inherit;">Cheynkod write simply and safely helps us greatly framework </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSKit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from S7 Techlab and static analyzer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revive ^ CC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, our team is developing a set of utilities to make working with Fabric simple and enjoyable: a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blockchain explorer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a utility for </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">automatically changing the network configuration</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (adding / deleting organizations, RAFT nodes), a utility for </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">revoking certificates and removing identity</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If you want to contribute - welcome.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This approach makes it easy to replace Hyperledger Fabric with Quorum, other private Ethereum networks (PoA or even PoW), significantly reduce real bandwidth, but at the same time maintain normal UX (both for users in the browser and for integrated systems). </font><font style="vertical-align: inherit;">When replacing Fabric with Ethereum in the scheme, you will only need to change the logic of the retry service / decorator from processing MVCC conflicts to the atomic increment nonce and resending. </font><font style="vertical-align: inherit;">Buffering and status storage allowed to decouple the response time from the block formation time. </font><font style="vertical-align: inherit;">Now you can add thousands of order nodes and not be afraid that blocks are formed too often and load ordering service. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, that‚Äôs all I wanted to share. </font><font style="vertical-align: inherit;">I would be glad if this helps someone in their work.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en488986/index.html">Who is a mentor and what kind of flexible skills should he have</a></li>
<li><a href="../en488990/index.html">Overview of the full-face mask of UNIX 5100, filters to it, comparison with UNIX 5000, 6100 models and PPM-88 mask</a></li>
<li><a href="../en488994/index.html">DDR5? Yes, we barely met DDR4</a></li>
<li><a href="../en488998/index.html">Why AI requirements can only make matters worse</a></li>
<li><a href="../en489000/index.html">How to assemble a cool mitap: 16 tips from three ‚Äúserial mitapers‚Äù. Leader-IT events # 1</a></li>
<li><a href="../en489004/index.html">Cell Phone with Disc Dialer</a></li>
<li><a href="../en489008/index.html">Routing in complex chatbots with the Hobot framework</a></li>
<li><a href="../en489010/index.html">We share the largest in Russia layer of data on online training with projects in linguistics, personalization, peddesign, ML</a></li>
<li><a href="../en489012/index.html">Google Cloud Spanner: good, bad, evil</a></li>
<li><a href="../en489014/index.html">The book ‚ÄúPerfect Algorithm. Greedy Algorithms and Dynamic Programming ¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>