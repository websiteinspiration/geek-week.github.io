<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌓 🤶🏾 📲 Google就職の面接解析：関係を見つける 🤴🏽 📩 👨🏽‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="リーク後に禁止される前に、Googleのインタビュー中に私が尋ねた一連のパズル の次の記事へようこそ。それ以来、私はGoogleでソフトウェアエンジニアとしての仕事を辞め、Redditの開発マネージャーのポジションに異動しましたが、まだ守るべき素晴らしいトピックがいくつかあります。これまでに、我々が...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Google就職の面接解析：関係を見つける</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467371/"><img src="https://habrastorage.org/getpro/habr/post_images/915/39d/3b3/91539d3b3be71056861dc65e18921c88.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リーク後に禁止される前に、Googleのインタビュー中に私が尋ねた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一連の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パズル</font><font style="vertical-align: inherit;">
の次の</font><font style="vertical-align: inherit;">記事</font><font style="vertical-align: inherit;">へようこそ</font><font style="vertical-align: inherit;">。それ以来、私はGoogleでソフトウェアエンジニアとしての仕事を辞め、Redditの開発マネージャーのポジションに異動しましたが、まだ守るべき素晴らしいトピックがいくつかあります。これまでに、我々が検討している</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的計画法を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電源に行列を上げる</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、クエリの異名</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。今回は完全に新しい質問です。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、最初に、2つのポイント。まず、Redditでの仕事は素晴らしかったです。過去8か月間、新しい広告関連性チームを構築して主導し、ニューヨークに新しい開発オフィスを設置しました。どんなに楽しくても、残念ながら最近までブログに時間もエネルギーも残っていませんでした。このシリーズはちょっと見捨ててしまったようです。遅くなってすみません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第2に、記事をフォローしている場合、最後の問題の後、クエリの同義語オプションについて掘り下げようと思うかもしれません。いつか戻ってみたいと思いますが、仕事の変更のためにこの問題にあまり興味がなくなったことを認めざるを得ず、今のところ延期することにしました。ただし、連絡を取り合ってください！借りているので返却するつもりです。ほんの少し後で...</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単な免責事項：候補者へのインタビューは私の職務の1つですが、このブログでは私の個人的な見解、個人的なストーリー、個人的な意見を紹介しています。</font><font style="vertical-align: inherit;">Google、Alphabet、Reddit、またはその他の個人や組織からの公式声明にはこれを採用しないでください。</font></font></i> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい質問を検索</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前の記事、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は避けられない漏れの前に、長時間使用することを私のお気に入りの質問のいずれかを説明しました。</font><font style="vertical-align: inherit;">前の質問は理論的な観点から魅力的でしたが、会社としてのGoogleにもう少し関連性のある問題を選択したいと思いました。</font><font style="vertical-align: inherit;">この質問が禁止されたとき、私は新しい制限を考慮に入れて代わりの質問を見つけたかったの</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">質問を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にするため</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Googleでの悪名高いインタビュープロセスを考えると、これは少し意外に思われるかもしれません。しかし、その時はもっと簡単な問題が理にかなっています。私の推論は2つの部分から成っていました。 1つ目は実用的です。多数のヒントや単純化にもかかわらず、候補者は通常、以前の質問にうまく対応できませんでした。その理由を常に完全に確信することはできませんでした。 2番目の理論的なもの：面接プロセスでは、候補者を「採用する価値がある」と「採用する価値がない」のカテゴリに分類する必要があります。質問でこれを少し簡単に行うことができるかどうか知りたいと思いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これら2つの点を明確にする前に、私はそれらが</font><i><font style="vertical-align: inherit;">そう</font></i><font style="vertical-align: inherit;">では</font><i><font style="vertical-align: inherit;">ない</font></i><font style="vertical-align: inherit;">ことを指摘したいと思います</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平均。 「なぜ人が問題を抱えているのか常にわからない」というのは、質問が無用であることを意味しているわけではなく、この理由で面接を簡略化したかったのです。最も難しい質問でさえ、多くはうまく対処しました。つまり、候補者が問題を抱えていたときに、何が欠けているのか理解するのが大変でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
良い面接は、候補者の長所と短所の全体像を示します。採用委員会が単に「不合格」と言うだけでは不十分です。委員会は、候補者が求めている会社固有の資質を持っているかどうかを判断します。同様に、「彼はかっこいい」という言葉は、委員会が特定の分野では強いが他の分野では疑わしい候補者を決定するのに役立ちません。より複雑な質問では、候補者がこれら2つのカテゴリに分類されることがよくあります。この観点から見ると、「人がなぜ問題を抱えているのか常にわからない」ということは、「この問題を先に進めないからといって、この候補者の能力を描写することができない」という意味です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
候補者を「採用に値する」と「採用する価値が</font><i><font style="vertical-align: inherit;">ない</font></i><font style="vertical-align: inherit;">」に分類することは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">面接プロセスでは、愚かな候補者を賢い候補者から分離する必要があります。賢く、才能があり、やる気がなかった一人の候補者を思い出すことはできません。多くは優秀な大学から来ましたが、残りは明らかに非常にやる気があります。電話インタビューを通過することはすでに良いふるいであり、この段階で拒否することさえ能力の欠如の兆候ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はできる</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">面接に十分な準備ができていなかった、または作業が遅すぎた、問題を解決するためにあまりにも多くの監督が必要だった、またはあいまいな方法で伝えられた、またはアイデアをコードに変換できなかった、または単に成功につながらない立場を保持した多くの人を覚えている「採用に値する」の定義はあいまいで、会社によって異なります。面接プロセスでは、各候補者が特定の会社の要件を満たしているかどうかを判断します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
過度に複雑なインタビューの質問について不平を言っている多くのredditコメントを読みました。より単純なタスクで価値のある/価値のない推奨を行うことがまだ可能かどうか、私は興味を持っていました。これは、候補者の神経を不必要に叫ぶことなく、有用なシグナルを与えると私は思った。私の結論は記事の最後でお知らせします... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの考えから、新しい質問を探していました。理想的な世界では、これは45分で解くのに十分単純な質問ですが、より強力な候補者が自分のスキルを示すために追加の質問があります。多くの候補者がまだボードに書き込むため、実装もコンパクトでなければなりません。トピックが何らかの形でGoogle製品に関連している場合の大きなプラス。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、いくつかの素晴らしいグーグルが注意深く説明し、質問データベースに挿入した質問に落ち着きました。</font><font style="vertical-align: inherit;">今、私は以前の同僚と相談し、質問がまだ禁止されていることを確認したので、インタビューでは絶対に尋ねられません。</font><font style="vertical-align: inherit;">私はそれが最も効果的であると思われる形で提示し、原作者には謝罪します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">質問</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
距離の測定について話します。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハンド</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、英語圏の国で馬の身長を測定するために一般的に使用されている4インチの測定単位です。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光年</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font><i><font style="vertical-align: inherit;">光の</font></i><font style="vertical-align: inherit;">粒子（または波？）が特定の秒数で移動する距離に等しい別の測定単位であり、およそ1地球年に等しくなります。一見、距離の測定に使用されることを除いて、それらは互いにほとんど共通点がありません。しかし、Googleがそれらを非常に簡単に変換できることがわかりました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uu/8z/y-/uu8zy-po4rpuvr61dtewmyhjns0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは明白に思えるかもしれません。最終的には、どちらも距離を測定しているため、変化があることは明らかです。</font><font style="vertical-align: inherit;">しかし、あなたがそれについて考えるならば、それは少し奇妙です：どのように彼らはこの転換率を計算しましたか？</font><font style="vertical-align: inherit;">光の年に実際に手の数を数えた人がいないことは明らかです。</font><font style="vertical-align: inherit;">実際、これを直接取る必要はありません。</font><font style="vertical-align: inherit;">あなたは単によく知られた変換を使うことができます：</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片手</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4インチ</font></font></i><br>
</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4インチ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.33333フィート</font></font></i><br>
</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.33333フィート</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3125e − 5マイル</font></font></i><br>
</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3125e − 5マイル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.0737e − 17光年</font></font></i></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクの目標は、この変換を実行するシステムを開発することです。</font><font style="vertical-align: inherit;">特に：</font></font><br>
<br>
<blockquote>       (    )      ,    , :<br>
<br>
<pre>  12<font></font>
  0,3333333<font></font>
 . .</pre><br>
 ,  ORIGIN * MULTIPLIER = DESTINATION.  ,             .</blockquote><br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
直感的で明白な答えがあるので、この問題が好きです。あるユニットから別のユニットに変換し、次に、ターゲットを見つけるまで次のユニットに変換するだけです！この問題に遭遇し、解決方法に完全に戸惑った一人の候補者を思い出せません。これまでの問題は通常、少なくともソリューションへの基本的なアプローチが見つかる前に、長時間の調査と考察を必要としたため、これは「より単純な」問題の要件によく適合します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それにもかかわらず、多くの候補者は、明確なヒントなしに、彼らの直感を実用的な解決策として理解することに失敗しました。この質問の利点の1つは、問題を定式化する（問題を組み立てる）候補者の能力を、分析とコーディングに役立つようにテストすることです。後で見るように、ここには新しい概念的な飛躍を必要とする非常に興味深い拡張機能が1つあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテキストでは、フレーミングは自明ではないソリューションの問題を同等の問題に変換する行為であり、ソリューションは自然な方法で推定されます。</font><font style="vertical-align: inherit;">これが完全に抽象的で難攻不落に聞こえる場合は、申し訳ありませんが、そうです。</font><font style="vertical-align: inherit;">この問題の最初の解決策を提示するときの意味を説明します。</font><font style="vertical-align: inherit;">ソリューションの最初の部分は、アルゴリズムの知識を開発して適用する練習です。</font><font style="vertical-align: inherit;">2番目の部分は、新しい非自明な最適化に到達するために、この知識を操作する練習です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート0.直感</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より深く掘り下げる前に、「明白な」ソリューションを完全に探索しましょう。</font><font style="vertical-align: inherit;">必要な変換のほとんどは単純で簡単です。</font><font style="vertical-align: inherit;">アメリカ国外に旅行したアメリカ人なら誰でも、世界のほとんどが神秘的な単位「キロメートル」を使って距離を測定していることを知っています。</font><font style="vertical-align: inherit;">変換するには、マイル数に約1.6を掛けるだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは私たちの生活のほとんどでそのようなことに遭遇しています。</font><font style="vertical-align: inherit;">ほとんどの単位については、事前に計算された変換が既にあるため、対応する表でそれを確認するだけで済みます。</font><font style="vertical-align: inherit;">しかし、直接変換がない場合（たとえば、手から光年へ）、上記のように変換パスを構築することは理にかなっています。</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片手</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4インチ</font></font></i><br>
</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4インチ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.33333フィート</font></font></i><br>
</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.33333フィート</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3125e − 5マイル</font></font></i><br>
</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3125e − 5マイル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.0737e − 17光年</font></font></i></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とてもシンプルで、想像力と標準的な変換テーブルを使用して、このような変換を思いついただけです。</font><font style="vertical-align: inherit;">ただし、いくつかの質問が残っています。</font><font style="vertical-align: inherit;">もっと短い方法はありますか？</font><font style="vertical-align: inherit;">係数はどのくらい正確ですか？</font><font style="vertical-align: inherit;">変換は常に可能ですか？</font><font style="vertical-align: inherit;">自動化は可能ですか？</font><font style="vertical-align: inherit;">残念ながら、ここでは単純なアプローチは失敗します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1.素朴な決定</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題に直感的な解決策があることは素晴らしいことですが、実際には、この単純さは問題を解決するための障害です。あなたがすでに理解していることを新しい方法で理解しようとすることほど難しいことは何もありません-特にあなたはしばしばあなたが思っているよりも少ないことを知っているからです。説明のために、あなたが面接に来たと想像してみてください-そしてあなたはこの直感的な方法を頭に持っています。しかし、彼は多くの重要な問題を解決することを許可していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換がない</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font><i><font style="vertical-align: inherit;">は</font></i><font style="vertical-align: inherit;">どうなりますか？明白なアプローチは何も言いません、あるユニットから別のユニットに変換することは本当に可能ですか？彼らが私に千の変換率を与えるならば、それが原理的に可能であるかどうかを決定することは私にとって非常に難しいでしょう。私は不慣れな（または架空の）間の変換を行うことが求められていた場合の単位</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインタ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注射</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それから私はどこから始めればいいのか分かりません。ここでは直感的なアプローチがどのように役立ちますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは一種の不自然なシナリオであることを認めざるを得ませんが、より現実的なシナリオもあります。問題の私の声明には距離の単位しか含まれていないことがわかります。これは意図的に行われます。システムにインチからキログラムへの変換を要求するとどうなりますか？あなたと私はどちらも、異なるタイプを測定するためこれは不可能であることを知っていますが、入力は各ユニットが測定する「タイプ」について何も述べていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
質問の完全な定式化により、有力な候補者が自分自身を証明できるようになります。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムを開発することにより、彼らはシステムの極端なケースを熟考します。そして、そのような問題の発言は、意図的に彼らに、異なる単位を翻訳するかどうかを尋ねる機会を与えてくれます。これは、初期段階で発生する場合はそれほど大きな問題ではありませんが、「変換できない場合、プログラムは何を返すべきですか？」このように質問をすることで、候補者が少なくとも1行のコードを書く前に、その能力を知ることができます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラフ形式でのプレゼンテーション</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
明らかに、単純なアプローチは適切ではないので、そのような変換を行う方法を検討する必要がありますか？答えは、単位をグラフと見なすことです。これは、この問題を解決するために必要な最初の理解です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に、次のように</font><font style="vertical-align: inherit;">変換できる</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、各単位がグラフのノードであり、ノードからノード</font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">への</font><font style="vertical-align: inherit;">エッジがあると想像し</font><font style="vertical-align: inherit;">て</font><font style="vertical-align: inherit;">ください。</font><font style="vertical-align: inherit;">
エッジには、</font><font style="vertical-align: inherit;">を得るのに</font><font style="vertical-align: inherit;">乗算</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">必要がある変換係数でラベルが付けられています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
ほとんどの場合、候補者がそのようなフレーミングを思いつくことを期待し、彼に深刻なヒントを与えることはほとんどありませんでした。互いに素な集合を使用する問題の解決策に気づかない、または線形代数にあまり詳しくない候補者は、隣接行列の次数の再上昇につながる解決策を実現することができませんが、グラフはカリキュラムまたはプログラミングコースで教えられます。候補者が適切な知識を持っていない場合、これは「採用しない」シグナルです。</font></font><code>B</code><font style="vertical-align: inherit;"></font><code>A</code><font style="vertical-align: inherit;"></font><code>B</code><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fc6/d25/89f/fc6d2589f8a9a411cec0d704e2ad644e.png"><br>
<br><font style="vertical-align: inherit;"></font><code>A</code><font style="vertical-align: inherit;"></font><code>B</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いずれにせよ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
、グラフ表現は、古典的なグラフ検索問題の解を減らします。特に、ここでは2つのアルゴリズムが役立ちます。ワイド検索（BFS）とディープ検索（DFS）です。幅で検索するとき、我々は、原点からの距離に応じてノードを調べる：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d45/4cb/15b/d454cb15b85c4ea9ce32e87623ed4115.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗い青の色は、後の世代を意味し</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
、深さ検索するときに、我々は、彼らが発生した順にノードを調べます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/40b/f4c/f1a/40bf4cf1ae3d89554505c031c4529559.png"><br>
<br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">また、暗い青色平均後の世代。実際にすべてのサイトにアクセスするわけではないことに注意してください</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのアルゴリズムでも、ある単位から別の単位への変換があるかどうかを簡単に判断できます。グラフを検索するだけです。元のユニットから始め、目的のユニットが見つかるまで検索します。目的地が見つからない場合（インチをキログラムに変換しようとする場合など）、方法がないことはわかっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、待ってください、何かが欠けています。方法を探すのではなく、コンバージョン率を求めたいのです。これは候補者がジャンプをしなければならない場所です：進行中に追加の状態を保存するだけで、検索アルゴリズムを変更してコンバージョン率を計算できることがわかります。ここではイラストが意味をなさなくなったので、コードを見ていきましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、グラフのデータ構造を決定する必要があるため、これを使用します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RateGraph</span>(<span class="hljs-params">object</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, rates</span>):</span>
        <span class="hljs-string">'Initialize the graph from an iterable of (start, end, rate) tuples.'</span><font></font>
        self.graph = {}<font></font>
        <span class="hljs-keyword">for</span> orig, dest, rate <span class="hljs-keyword">in</span> rates:<font></font>
            self.add_conversion(orig, dest, rate)<font></font>
<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_conversion</span>(<span class="hljs-params">self, orig, dest, rate</span>):</span>
        <span class="hljs-string">'Insert a conversion into the graph.'</span>
        <span class="hljs-keyword">if</span> orig <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.graph:<font></font>
            self.graph[orig] = {}<font></font>
        self.graph[orig][dest] = rate<font></font>
<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_neighbors</span>(<span class="hljs-params">self, node</span>):</span>
        <span class="hljs-string">'Returns an iterable of the nodes neighboring the given node.'</span>
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.graph:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        <span class="hljs-keyword">return</span> self.graph[node].items()<font></font>
        <font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_nodes</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-string">'Returns an iterable of all the nodes in the graph.'</span>
        <span class="hljs-keyword">return</span> self.graph.keys()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、DFSから始めましょう。</font><font style="vertical-align: inherit;">それを実装する方法はたくさんありますが、最も一般的なのは再帰的な解決策です。</font><font style="vertical-align: inherit;">これから始めましょう：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__dfs_helper</span>(<span class="hljs-params">rate_graph, node, end, rate_from_origin, visited</span>):</span>
    <span class="hljs-keyword">if</span> node == end:
        <span class="hljs-keyword">return</span> rate_from_origin<font></font>
<font></font>
    visited.add(node)<font></font>
<font></font>
    <span class="hljs-keyword">for</span> unit, rate <span class="hljs-keyword">in</span> rate_graph.get_neighbors(node):
        <span class="hljs-keyword">if</span> unit <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<font></font>
            rate = __dfs_helper(rate_graph, unit, end, rate_from_origin * rate, visited)<font></font>
            <span class="hljs-keyword">if</span> rate <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">return</span> rate<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">rate_graph, node, end</span>):</span>
    <span class="hljs-keyword">return</span> __dfs_helper(rate_graph, node, end, <span class="hljs-number">1.0</span>, set())</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単に言うと、このアルゴリズムは1つのノードから始まり、その隣接ノードを反復処理してすぐに各ノードにアクセスし、関数を再帰的に呼び出します。</font><font style="vertical-align: inherit;">スタックの各関数呼び出しは、それ自体の反復の状態を保存するため、1回の再帰訪問が返されると、その親は直ちに反復を続行します。</font><font style="vertical-align: inherit;">すべての呼び出しで訪問済みサイトのセットを維持することにより、同じサイトに再度アクセスすることを回避します。</font><font style="vertical-align: inherit;">また、各ノードとソースの間に変換係数を割り当てることで係数を計算します。</font><font style="vertical-align: inherit;">したがって、ターゲットノード/ブロックに遭遇したとき、ソースノードから変換係数をすでに作成しており、単純にそれを返すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは優れた実装ですが、2つの主な欠陥があります。まず、再帰的です。目的のパスが1,000を超えるジャンプで構成されていることが判明した場合は、グリッチで飛行します。もちろん、これはありそうもないことですが、長期的なサービスに受け入れられないものがある場合、それは失敗です。次に、正常に完了したとしても、答えにはいくつかの望ましくない特性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は実際に投稿の冒頭ですでにヒントを与えました。 Googleがコンバージョン率をどのように表示するかに気づきました</font></font><code>1.0739e-17</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、私の手計算では次のようになり</font></font><code>1.0737e-17</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ますか？これらすべての浮動小数点乗算により、エラーの分散についてすでに考えていることがわかります。この記事のニュアンスは多すぎますが、肝心なのは、累積して問題を引き起こすエラーを回避するために、浮動小数点の乗算を最小限に抑える必要があるということです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DFSは優れた検索アルゴリズムです。</font><font style="vertical-align: inherit;">解が存在する場合、それはそれを見つけます。</font><font style="vertical-align: inherit;">しかし、彼には重要な特性がありません。彼は必ずしも最短経路を見つけるわけではありません。</font><font style="vertical-align: inherit;">パスが短いほどジャンプが少なくなり、浮動小数点の乗算によるエラーが少なくなるため、これは私たちにとって重要です。</font><font style="vertical-align: inherit;">この問題を解決するには、BFSを使用します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート2. BFSソリューション</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、候補者が再帰的なDFSソリューションを正常に実装して解決した場合、通常、少なくともこの候補者を採用することについては弱い提案をします。</font><font style="vertical-align: inherit;">彼は問題を理解し、適切なフレーミングを選択し、実用的なソリューションを実装しました。</font><font style="vertical-align: inherit;">これは素朴な決定なので、私は彼を雇うことを主張しませんが、彼が他のインタビューにうまく対処できれば、私は拒否を勧めません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは繰り返す価値があります。疑わしい場合は、単純な解決策を書いてください！完全に最適化されていなくても、ボード上のコードの存在はすでに達成されており、多くの場合、それに基づいて適切なソリューションを見つけることができます。私は別の言い方をします：決して何のために働くことはありません。おそらく、あなたは素朴な解決策を考えたが、それが最適ではないことを知っているので、それを提供したくなかった。現時点で最適なソリューションをレイアウトする準備ができている場合は問題ありませんが、そうでない場合は、より複雑な作業に進む前に、進捗状況を記録してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これから、アルゴリズムの改善について話しましょう。</font><font style="vertical-align: inherit;">再帰的なDFSソリューションの主な欠点は、再帰的であり、乗算の数を最小化しないことです。</font><font style="vertical-align: inherit;">すぐにわかるように、BFSは乗算の数を最小限に抑え、再帰的に実装することも非常に困難です。</font><font style="vertical-align: inherit;">残念ながら、それを改善するにはコードを完全に書き直す必要があるため、再帰的なDFAソリューションを放棄する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに苦労することなく、私はBFSに基づく反復アプローチを提示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">rate_graph, start, end</span>):</span><font></font>
    to_visit = deque()<font></font>
    to_visit.appendleft( (start, <span class="hljs-number">1.0</span>) )<font></font>
    visited = set()<font></font>
<font></font>
    <span class="hljs-keyword">while</span> to_visit:<font></font>
        node, rate_from_origin = to_visit.pop()<font></font>
        <span class="hljs-keyword">if</span> node == end:
            <span class="hljs-keyword">return</span> rate_from_origin<font></font>
        visited.add(node)<font></font>
        <span class="hljs-keyword">for</span> unit, rate <span class="hljs-keyword">in</span> rate_graph.get_neighbors(node):
            <span class="hljs-keyword">if</span> unit <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<font></font>
                to_visit.appendleft((unit, rate_from_origin * rate))<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実装は、前の実装と機能的に非常に異なりますが、よく見るとほぼ同じですが、重要な変更が1つあります。再帰的なDFSは、コールスタックの追加ルートの状態を保存し、LIFOスタックを効果的に実装しながら、反復ソリューションは、キューにそれを格納します。 FIFO</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、「最短パス/乗算の最小数」というプロパティを意味します。ノードは発生順にアクセスし、このようにしてノードの世代を取得します。最初のノードはそのネイバーを挿入し、次にこれらのネイバーを順番に訪問し、常にそれらのネイバーをくっつけます。最短パスプロパティは、ノードがソースからの距離の順にアクセスされるという事実に基づいています。したがって、目的地に直面したとき、それをもたらす可能性のある初期の世代は存在しないことがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点で、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほぼ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完了です。最初にいくつかの質問に答える必要があり、それらは問題の元の定式化に戻らざるを得ません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、元のユニットが存在しない場合の最も簡単なことは何ですか？</font><font style="vertical-align: inherit;">つまり、指定された名前のノードが見つかりません。</font><font style="vertical-align: inherit;">実際には、Pound、Pound、lbが同じ「ポンド」ノード（または他の正規表現）を指すように線の正規化を行う必要がありますが、これは質問の範囲を超えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、2つの単位の間に変換がない場合はどうなりますか？</font><font style="vertical-align: inherit;">初期データには単位間の変換のみがあり、特定の単位から別の単位を取得できるかどうかを示すものではないことを思い出してください。</font><font style="vertical-align: inherit;">これは、変換とパスが直接同等であるため、2つのノード間にパスがない場合、変換は行われないという事実に要約されます。</font><font style="vertical-align: inherit;">実際には、無関係な単位の島ができます。1つは距離、1つはウェイト、1つは通貨などです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、上のグラフをよく見ると、このソリューションでは針と光年を変換できないことがわかります。</font><font style="vertical-align: inherit;">ノード間のリンクの方向は、手から光年への道がないことを意味します。</font><font style="vertical-align: inherit;">ただし、変換を元に戻すことができるため、これは簡単に修正できます。</font><font style="vertical-align: inherit;">グラフの初期化コードを次のように変更できます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_conversion</span>(<span class="hljs-params">self, orig, dest, rate</span>):</span>
    <span class="hljs-string">'Insert a conversion into the graph. Note we insert its inverse also.'</span>
    <span class="hljs-keyword">if</span> orig <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.graph:<font></font>
        self.graph[orig] = {}<font></font>
    self.graph[orig][dest] = rate<font></font>
<font></font>
    <span class="hljs-keyword">if</span> dest <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.graph:<font></font>
        self.graph[dest] = {}<font></font>
    self.graph[dest][orig] = <span class="hljs-number">1.0</span> / rate</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート3.評価</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
できた！</font><font style="vertical-align: inherit;">候補者がこの時点に達している場合、私はおそらく彼に雇うことを勧めます。</font><font style="vertical-align: inherit;">コンピュータサイエンスを学んだり、アルゴリズムのコースを受講したりした場合、「これで本当にこの人との面接を受けるのに十分ですか？」という質問に答えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
質問が単純すぎると決める前に、候補者がこの点に到達するために何をしなければならないかを見てみましょう。</font></font><br>
<br>
<ul>
<li> <br>
</li>
<li>     <br>
</li>
<li>,       <br>
</li>
<li>        <br>
</li>
<li>      ,   <br>
</li>
<li>   DFS   ,    <br>
</li>
<li> BFS<br>
</li>
<li>     :<br>
<ul>
<li>,   c   ?<br>
</li>
<li> ,     ?</li>
</ul></li>
<li>,     , , </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この質問は以前の質問よりも簡単ですが、難しい問題でもあります。これまでのすべての質問と同様に、候補者は、抽象的に定式化された質問から、解法への道を開くアルゴリズムまたはデータ構造へと精神的に飛躍しなければなりません。唯一のことは、最終的なアルゴリズムが他の問題よりも進んでいないことです。このアルゴリズム素材以外では、特に極端なケースと正確さに関して同じ要件が適用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「でも待ってください！」 -Googleはランタイムの複雑さに取り憑かれていませんか？この問題の時間的または空間的な複雑さについても質問しませんでした。うん！」また、次のように質問することもできます。「ちょっと待って、評価を付けました」「採用を強くお勧めします」？どうすれば入手できますか？」どちらも非常に良い質問です。これで、最後のボーナスラウンドが始まります...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート4.より良いことは可能ですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点で、私は候補者に良い答えを祝福し、さらにすべてが単なるボーナスであることを明確にしたいと思います。</font><font style="vertical-align: inherit;">プレッシャーがなくなると、私たちは創造を始めることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、BFSを実行する難しさは何ですか？</font><font style="vertical-align: inherit;">最悪の場合、個々のノードとエッジを考慮する必要があるため、線形の複雑さが生じます</font></font><code>O(N+E)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、</font></font><code>O(N+E)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラフ作成</font><font style="vertical-align: inherit;">と同じ複雑さの上にあり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">検索エンジンの場合、これはおそらく適切です。1000単位でほとんどの妥当なアプリケーションに十分であり、クエリごとにメモリ検索を実行しても過負荷にはなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、もっとうまくやることができます。やる気を出すために、このコードを検索文字列に挿入する方法を検討してください。一部の非標準単位の変換はもう少し一般的であるため、それらを何度も計算します。検索が実行されるたびに、中間値などが計算されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、それらは単に計算結果をキャッシュすることを提案します。単位変換が計算されるときはいつでも、常に2つの変換の間にエッジを追加できます。おまけとして、私たちは逆変換を取得します、そして無料で！終わった？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、これにより漸近的に一定の検索時間が得られますが、追加のエッジのストレージにコストがかかります。これは実際には非常にコストがかかります。すべての変換のペアが徐々に計算されて保存されるため、時間の経過とともに完全なグラフを目指します。グラフ内の可能なエッジの数はノード数の二乗の半分であるため、1000のノードの場合は50万のエッジが必要です。 1万ノード、約5千万など。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検索システムの範囲を超えて、100万ノードのグラフの場合、5兆個のエッジを目指します。このような量を保存するのは不合理であり、グラフにエッジを挿入するのに時間を費やします。私達はもっと良くしなければならない。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸いなことに、二次空間の増加なしに、係数を検索する一定の時間を達成する方法があります。</font><font style="vertical-align: inherit;">実際、私たちが必要とするほとんどすべてのものは私たちの鼻のすぐ下にあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート4.一定時間</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、合計キャッシュは実際には最適なソリューションに近くなります。</font><font style="vertical-align: inherit;">このアプローチでは、（最終的に）すべてのノード間のエッジを取得します。つまり、変換は1つのエッジを見つけることまで削減されます。</font><font style="vertical-align: inherit;">しかし、各ノードから各ノードへの変換を保存することは本当に必要ですか？</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノードから他のすべてのノードに</font><font style="vertical-align: inherit;">変換係数を保存するとどうなる</font><font style="vertical-align: inherit;">でしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BFSソリューションをもう一度見てみましょう。</font></font><br>
<br>
<pre><code class="python hljs">
<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">rate_graph, start, end</span>):</span><font></font>
    to_visit = deque()<font></font>
    to_visit.appendleft( (start, <span class="hljs-number">1.0</span>) )<font></font>
    visited = set()<font></font>
<font></font>
    <span class="hljs-keyword">while</span> to_visit:<font></font>
        node, rate_from_origin = to_visit.pop()<font></font>
        <span class="hljs-keyword">if</span> node == end:
            <span class="hljs-keyword">return</span> rate_from_origin<font></font>
        visited.add(node)<font></font>
        <span class="hljs-keyword">for</span> unit, rate <span class="hljs-keyword">in</span> rate_graph.get_neighbors(node):
            <span class="hljs-keyword">if</span> unit <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<font></font>
                to_visit.appendleft((unit, rate_from_origin * rate))<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで何が起こるか見てみましょう。ソースノードから開始し、発生した各ノードについて、ソースからこのノードへの変換係数を計算します。次に、目的地に到着するとすぐに、始点と終点の間の係数を返し、中間係数を破棄します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの中間比率が重要です。しかし、それらを捨てない場合はどうなりますか？代わりにそれらを書き留めるとどうなりますか？最も複雑で理解できない検索はすべて単純になります。AとBの比率を見つけるには、まずXとBの比率を見つけ、それをXとAの比率で割れば完了です。視覚的には、次のようになります</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/284/a08/b6c/284a08b6cb6ef95af556422fa3c604f3.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。2つのノード間でエッジが2つ以下である</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ことに</font><i><font color="gray"><font style="vertical-align: inherit;">注意してください。</font></font></i><font style="vertical-align: inherit;">このテーブルを計算するために、BFSソリューションを変更する必要はほとんどないことがわかります。</font></font><br>
<br>
<pre><code class="python hljs">
<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_conversions</span>(<span class="hljs-params">graph</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conversions_bfs</span>(<span class="hljs-params">rate_graph, start, conversions</span>):</span><font></font>
        to_visit = deque()<font></font>
        to_visit.appendleft( (start, <span class="hljs-number">1.0</span>) )<font></font>
<font></font>
        <span class="hljs-keyword">while</span> to_visit:<font></font>
            node, rate_from_origin = to_visit.pop()<font></font>
            conversions[node] = (start, rate_from_origin)<font></font>
            <span class="hljs-keyword">for</span> unit, rate <span class="hljs-keyword">in</span> rate_graph.get_neighbors(node):
                <span class="hljs-keyword">if</span> unit <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> conversions:<font></font>
                    to_visit.append((unit, rate_from_origin * rate))<font></font>
<font></font>
        <span class="hljs-keyword">return</span> conversions<font></font>
<font></font>
    conversions = {}<font></font>
    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph.get_nodes():
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> conversions:<font></font>
            conversions_bfs(graph, node, conversions)<font></font>
    <span class="hljs-keyword">return</span> conversions</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変換の構造は、ユニットAのディクショナリによって2つの値で表されます。ユニットAの関連コンポーネントのルートと、ルートユニットとユニットAの間の変換係数です。訪問ごとにこのディクショナリにユニットを挿入するので、このディクショナリのキースペースを訪問のセットとして使用できます。専用の訪問セット。最終ノードがないことに注意してください。代わりに、完了するまでノードを反復処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このBFSの外側には、グラフのノードを反復処理するヘルパー関数があります。トランスレーションディクショナリの外部にあるノードを検出すると、そのノードからBFSを開始します。したがって、すべてのノードを関連コンポーネントに折りたたむことが保証されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユニット間の関係を見つける必要がある場合は、計算した変換構造を使用します。</font></font><br>
<br>
<pre><code class="python hljs">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span>(<span class="hljs-params">conversions, start, end</span>):</span>
    <span class="hljs-string">'Given a conversion structure, performs a constant-time conversion'</span>
    <span class="hljs-keyword">try</span>:<font></font>
        start_root, start_rate = conversions[start]<font></font>
        end_root, end_rate = conversions[end]<font></font>
    <span class="hljs-keyword">except</span> KeyError:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><font></font>
<font></font>
    <span class="hljs-keyword">if</span> start_root != end_root:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><font></font>
<font></font>
    <span class="hljs-keyword">return</span> end_rate / start_rate</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「そのようなユニットがない」という状況は、変換の構造にアクセスするときに例外をリッスンすることによって処理されます。</font><font style="vertical-align: inherit;">「そのような変換がない」という状況は、2つの量の根を比較することによって処理されます。それらが異なる根を持つ場合、それらは2つの異なるBFS呼び出しを通じて発見されます。つまり、それらは2つの異なる接続コンポーネントにあり、したがってそれらの間に方法はありません。</font><font style="vertical-align: inherit;">最後に、変換を実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような！</font><font style="vertical-align: inherit;">現在のソリューションは前処理が複雑です</font></font><code>O(V+E)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（以前のソリューションより悪くない）、しかし彼女はまた一定の時間で検索します。</font><font style="vertical-align: inherit;">理論的には、スペース要件は2倍になりますが、ほとんどの場合、元のグラフは不要になるため、削除してこのグラフのみを使用できます。</font><font style="vertical-align: inherit;">さらに、空間の複雑さは実際には元のグラフよりも少なくなります。</font></font><code>O(V+E)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのエッジと頂点を格納</font><font style="vertical-align: inherit;">する必要がある</font><font style="vertical-align: inherit;">ため、この構造が必要</font></font><code>O(V)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">この構造が必要とするのは</font><font style="vertical-align: inherit;">、エッジが不要になったためです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここまで進んだ場合、質問の1つは、単純な問題が依然として価値のある候補者を選択するのに役立つかどうかを確認することであり、それが能力のより良い状況を与えるかどうかを思い出したかもしれません。ある種の最終的な科学的答えを出したいと思いますが、私には個人的な経験からの物語しかありません。しかし、私はいくつかの肯定的な結果に気づきました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題の解決策を4つの障害（フレーミングの議論、アルゴリズムの選択、実装、一定時間の実行の議論）に分割すると、インタビューの終わりまでに、ほぼすべての候補者が「アルゴリズムの選択」に到達しました。私が思ったように、フレーミングの議論は良いフィルターでした：候補者はすぐにグラフを表示するか、またはかなりのヒントにもかかわらず、どうにかそこに来ることができませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはすぐに役立つ信号です。私は、人が高度または不明瞭なデータ構造を知らないときに理解できます。正直なところ、めったにないセットを実装する必要はほとんどありません。しかし、グラフは基本的なデータ構造であり、このトピックに関するほとんどすべての入門コースの一部として教えられています。候補者が理解するのに苦労している、または簡単に適用できない場合、おそらく彼がGoogleで成功するのは難しいでしょう（少なくとも今のところ、今日はどうなのかわかりません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、アルゴリズムの選択は、特に有用な信号源ではありませんでした。フレーミング段階を通過した人々は通常、問題なくアルゴリズムに到達しました。これは、ほとんどの場合、検索アルゴリズムはグラフ自体と一緒に教えられるため、誰かが1つのグラフに精通している場合、もう1つは知っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装は簡単ではありませんでした。多くの人はDFSの再帰的な実装に問題はありませんでしたが、前述したように、この実装は本番環境には適していません。驚いたことに、BFSとDFSの反復的な実装は人々にあまり馴染みがないようであり、明白なヒントを付けた後でも、それらはしばしば話題に浮かびました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、実装フェーズを通過した人は誰でも「採用」の推奨をすでに得ており、一定のリードタイムの​​議論は単なるボーナスです。</font><font style="vertical-align: inherit;">記事ではソリューションを詳細に検討しましたが、実際には、コーディングよりも口頭での議論の方が通常は生産性が高くなります。</font><font style="vertical-align: inherit;">すぐに決定を下せる候補者はほとんどいません。</font><font style="vertical-align: inherit;">私はしばしばかなりの手がかりを与えなければならず、それでも多くの人が彼を見つけることができませんでした。</font><font style="vertical-align: inherit;">これは正常です。予想通り、強く推奨される評価を獲得するのは困難です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、待ってください、それだけではありません！</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的に、問題全体を調査しましたが、さらに詳しく調べたい場合は、ここでは取り上げない拡張機能がいくつかあります。次の演習は読者に任せます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、ウォームアップ：レイアウトした一定時間のソリューションで、接続されている各コンポーネントのルートノードを任意に選択しました。特に、最初に遭遇したコンポーネントノードを使用します。これは最適ではありません。すべての既知の値に対して、いくつかのノードを選択したためです。ただし、他のノードは中心に近く、他のすべてのノードへのパスが短い場合があります。あなたの仕事は、この任意の選択を、必要な乗算の数を最小限に抑え、浮動小数点誤差の広がりを最小限に抑えるものに置き換えることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二に、すべての議論において、グラフを通るすべての等しいパスは最初は等しいと仮定されていましたが、常にそうであるとは限りません。この問題の興味深いオプションの1つは通貨換算です。ノードは通貨であり、AからBへのエッジ、またはその逆は各通貨ペアの需要/供給価格です。通貨の裁定取引の問題として、単位換算の問題を言い換えることができます。通貨換算グラフを前提として、トレーダーに初期金額より多くのお金を提供するグラフを通じてサイクルを計算するアルゴリズムを実装します。取引手数料は含めないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、本物の宝石：いくつかの単位は、異なる基本単位の組み合わせとして表現されます。</font><font style="vertical-align: inherit;">たとえば、ワットはSIシステムでkg•m²/s³として定義されます。</font><font style="vertical-align: inherit;">最後のタスクは、このシステムを拡張して、基本的なSI単位の定義のみを考慮して、これらの単位間の変換をサポートすることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご不明な点がござい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ましたら、redditからお</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">気軽</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">にお問い合わせください</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
面接でこの質問をし始めたとき、以前のタスクより少し簡単になることを望みました。実験は大成功しました。候補者がすぐに解決策を見た場合、彼は通常その課題に迅速に対処しました。そのため、一定の時間のある高度な解決策について話す時間はたくさんありました。概して、困難を経験した人々は、アルゴリズムの概念的な飛躍以外の場所でつまずきました：候補者は適切な方法で問題を完全に定式化することも、優れたソリューションをスケッチすることもできませんでしたが、実際のコードに変換することはできませんでした。いつ、どこで問題があったとしても、候補者の長所と短所について有意義な情報を得られることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事がお役に立てば幸いです。</font><font style="vertical-align: inherit;">以前の記事ほど、アルゴリズムを使った冒険はそれほど多くないかもしれません。</font><font style="vertical-align: inherit;">開発者へのインタビューでは、アルゴリズムについて豊富に議論するのが慣例です。</font><font style="vertical-align: inherit;">しかし、真実は、単純なよく知られた方法を使用する場合でも、かなりの困難が生じることです。</font><font style="vertical-align: inherit;">すべてのコードは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事シリーズのリポジトリ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にあり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja467359/index.html">PVS-Studioがクラウドに移行：Azure DevOps</a></li>
<li><a href="../ja467361/index.html">JavaScriptでの委任について忘れていました。反応中のイベント委任</a></li>
<li><a href="../ja467363/index.html">Kerasでカスタム損失関数と学習品質メトリックを使用する</a></li>
<li><a href="../ja467365/index.html">住宅用電圧監視リレー</a></li>
<li><a href="../ja467369/index.html">RubyRussia2019。MikhailPronyakin：Rubyは安全ですか？</a></li>
<li><a href="../ja467373/index.html">TimberとNode.JSを使用して、Androidログをインターネット経由で転送します</a></li>
<li><a href="../ja467375/index.html">カスタマーエクスペリエンスマネジメント-それは何ですか？</a></li>
<li><a href="../ja467377/index.html">3行連続：メビウス2019 Piterの上位10レポート</a></li>
<li><a href="../ja467381/index.html">18ルーブルの多階建てLED、スマートライト、電球</a></li>
<li><a href="../ja467383/index.html">「マネージャーはコーディングを続ける必要がある」：Stephen Chinへのインタビュー</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>