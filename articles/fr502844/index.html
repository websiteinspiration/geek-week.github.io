<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😐 🐹 👨🏽‍🚀 [Partie 2/2] Guide de FFmpeg et SDL ou Comment écrire un lecteur vidéo en moins de 1000 lignes 👨🏻 💥 👨🏽‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous publions le reste de la traduction en russe du manuel, qui est quelque peu dépassé, mais n'a pas perdu de sa pertinence, car ce tutoriel permet d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>[Partie 2/2] Guide de FFmpeg et SDL ou Comment écrire un lecteur vidéo en moins de 1000 lignes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/502844/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><div style="text-align:center;"><img width="780" height="325" src="https://habrastorage.org/webt/yx/qh/nq/yxqhnqwvdlvzfw22erhmpfzpfba.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous publions le reste de la traduction en russe du manuel, qui est quelque peu dépassé, mais n'a pas perdu de sa pertinence, car ce tutoriel permet de plonger dans la «cuisine» de la création d'applications vidéo à l'aide des bibliothèques FFmpeg et SDL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et bien que nous ayons essayé, les </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">difficultés de traduction sont</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inévitables dans un texte aussi volumineux </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Signalez les bugs (de préférence dans les messages privés) - ensemble, nous ferons mieux.</font></font><a name="menu"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table des matières</font></font></h3><div class="scrollable-table"><table>
<tbody><tr>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 1</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 2</font></font></th>
</tr>
<tr>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Préface </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leçon 1: Création d'écrans vidéo </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leçon 2: Affichage de la </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leçon 3: Lecture du son </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leçon 4: Plusieurs threads </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leçon 5: Synchronisation de la vidéo</font></font></a><br>
</td>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leçon 6: Synchronisation audio </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leçon 7: Recherche </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">postface </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annexe 1. Liste des fonctions </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annexe 2. Structures de données </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liens</font></font></a></td>
</tr>
</tbody></table></div><a name="habracut"></a><br>
<a name="audio"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Logiciel EDISON - développement web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Logiciel EDISON - développement web"></a><br clear="right">
     EDISON.<br>
<br>
    ,      .<br>
<br>
,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a>,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   Axxon Next  SureView Immix</a>.<br>
<br>
      ! ;-)</blockquote><br>
<h2> 6:   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Leçon 5: synchronisation vidéo">←</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Vers la table des matières">⇑</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Leçon 7: Recherche">→</a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">  tutorial06.c</b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial05.c</span>
<span class="hljs-comment">// A pedagogical video player that really works!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial05 tutorial05.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SAMPLE_CORRECTION_PERCENT_MAX 10</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AUDIO_DIFF_AVG_NB 20</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_VIDEO_MASTER</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;
  <span class="hljs-keyword">double</span> pts;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">int</span>             av_sync_type;
  <span class="hljs-keyword">double</span>          external_clock; <span class="hljs-comment">/* external clock base */</span>
  <span class="hljs-keyword">int64_t</span>         external_clock_time;<font></font>
<font></font>
  <span class="hljs-keyword">double</span>          audio_clock;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;
  <span class="hljs-keyword">int</span>             audio_hw_buf_size;
  <span class="hljs-keyword">double</span>          audio_diff_cum; <span class="hljs-comment">/* used for AV difference average computation */</span>
  <span class="hljs-keyword">double</span>          audio_diff_avg_coef;
  <span class="hljs-keyword">double</span>          audio_diff_threshold;
  <span class="hljs-keyword">int</span>             audio_diff_avg_count;
  <span class="hljs-keyword">double</span>          frame_timer;
  <span class="hljs-keyword">double</span>          frame_last_pts;
  <span class="hljs-keyword">double</span>          frame_last_delay;
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span>
  <span class="hljs-keyword">double</span>          video_current_pts; <span class="hljs-comment">///&lt;current displayed pts (different from video_clock if frame fifos are used)</span>
  <span class="hljs-keyword">int64_t</span>         video_current_pts_time;  <span class="hljs-comment">///&lt;time (av_gettime) at which we updated video_current_pts - used to have running video pts</span><font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
<span class="hljs-keyword">enum</span> {<font></font>
  AV_SYNC_AUDIO_MASTER,<font></font>
  AV_SYNC_VIDEO_MASTER,<font></font>
  AV_SYNC_EXTERNAL_MASTER,<font></font>
};<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_ctx-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_video_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> delta;<font></font>
<font></font>
  delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="hljs-number">1000000.0</span>;
  <span class="hljs-keyword">return</span> is-&gt;video_current_pts + delta;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_external_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">return</span> av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_master_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {
    <span class="hljs-keyword">return</span> get_video_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">return</span> get_audio_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> get_external_clock(is);<font></font>
  }<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-comment">/* Add or subtract samples to get a better sync, return new
   audio buffer size */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">synchronize_audio</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">short</span> *samples,
		      <span class="hljs-keyword">int</span> samples_size, <span class="hljs-keyword">double</span> pts)</span> </span>{
  <span class="hljs-keyword">int</span> n;
  <span class="hljs-keyword">double</span> ref_clock;<font></font>
<font></font>
  n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">double</span> diff, avg_diff;
    <span class="hljs-keyword">int</span> wanted_size, min_size, max_size <span class="hljs-comment">/*, nb_samples */</span>;<font></font>
    <font></font>
    ref_clock = get_master_clock(is);<font></font>
    diff = get_audio_clock(is) - ref_clock;<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) {
      <span class="hljs-comment">// accumulate the diffs</span><font></font>
      is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef<font></font>
	* is-&gt;audio_diff_cum;<font></font>
      <span class="hljs-keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) {<font></font>
	is-&gt;audio_diff_avg_count++;<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	avg_diff = is-&gt;audio_diff_cum * (<span class="hljs-number">1.0</span> - is-&gt;audio_diff_avg_coef);
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) {<font></font>
	  wanted_size = samples_size + ((<span class="hljs-keyword">int</span>)(diff * is-&gt;audio_ctx-&gt;sample_rate) * n);<font></font>
	  min_size = samples_size * ((<span class="hljs-number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);<font></font>
	  max_size = samples_size * ((<span class="hljs-number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);
	  <span class="hljs-keyword">if</span>(wanted_size &lt; min_size) {<font></font>
	    wanted_size = min_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wanted_size &gt; max_size) {<font></font>
	    wanted_size = max_size;<font></font>
	  }<font></font>
	  <span class="hljs-keyword">if</span>(wanted_size &lt; samples_size) {
	    <span class="hljs-comment">/* remove samples */</span><font></font>
	    samples_size = wanted_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wanted_size &gt; samples_size) {
	    <span class="hljs-keyword">uint8_t</span> *samples_end, *q;
	    <span class="hljs-keyword">int</span> nb;<font></font>
<font></font>
	    <span class="hljs-comment">/* add samples by copying final sample*/</span><font></font>
	    nb = (samples_size - wanted_size);<font></font>
	    samples_end = (<span class="hljs-keyword">uint8_t</span> *)samples + samples_size - n;<font></font>
	    q = samples_end + n;<font></font>
	    <span class="hljs-keyword">while</span>(nb &gt; <span class="hljs-number">0</span>) {
	      <span class="hljs-built_in">memcpy</span>(q, samples_end, n);<font></font>
	      q += n;<font></font>
	      nb -= n;<font></font>
	    }<font></font>
	    samples_size = wanted_size;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">/* difference is TOO big; reset diff stuff */</span>
      is-&gt;audio_diff_avg_count = <span class="hljs-number">0</span>;<font></font>
      is-&gt;audio_diff_cum = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> samples_size;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size, <span class="hljs-keyword">double</span> *pts_ptr)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> n;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_size = synchronize_audio(is, (<span class="hljs-keyword">int16_t</span> *)is-&gt;audio_buf,<font></font>
				       audio_size, pts);<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <font></font>
      is-&gt;video_current_pts = vp-&gt;pts;<font></font>
      is-&gt;video_current_pts_time = av_gettime();<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio if not master source */</span>
      <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) {<font></font>
	ref_clock = get_master_clock(is);<font></font>
	diff = vp-&gt;pts - ref_clock;<font></font>
	<font></font>
	<span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	   FFPlay still doesn't "know if this is the best guess." */</span><font></font>
	sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	  <span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	    delay = <span class="hljs-number">0</span>;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	    delay = <span class="hljs-number">2</span> * delay;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    vp-&gt;pts = pts;<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) {<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_hw_buf_size = spec.size;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
<font></font>
    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;<font></font>
    is-&gt;video_current_pts_time = av_gettime();<font></font>
<font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que nous avons un joueur plus ou moins décent sur lequel vous pouvez même regarder un film, nous allons maintenant joindre les deux bouts. </font><font style="vertical-align: inherit;">La dernière fois, nous avons légèrement abordé la synchronisation, à savoir la synchronisation du son avec la vidéo, dans cet ordre, et non l'inverse. </font><font style="vertical-align: inherit;">Nous allons faire cela de la même disposition qu'avec la vidéo: créer une horloge vidéo interne pour suivre la distance du flux vidéo et synchroniser l'audio avec. </font><font style="vertical-align: inherit;">Plus tard, nous généraliserons encore plus - nous synchroniserons l'audio et la vidéo avec une horloge externe.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implémentation de l'horloge vidéo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous voulons créer une horloge vidéo similaire à l'horloge audio que nous avions la dernière fois: une valeur interne qui renvoie le décalage horaire actuel de la vidéo en cours de lecture. Vous pourriez penser que ce sera aussi simple que de mettre à jour le minuteur avec le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> actuel </font><b><font style="vertical-align: inherit;">de la</font></b><font style="vertical-align: inherit;"> dernière image affichée. Cependant, n'oubliez pas que le temps entre les images vidéo peut être trop long si nous passons au niveau de la milliseconde. Par conséquent, la solution consiste à suivre une autre valeur, l'heure à laquelle nous avons réglé l'horloge vidéo sur le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS de la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dernière image. Ainsi, la valeur actuelle de l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horloge</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vidéo sera </font><b><font style="vertical-align: inherit;">PTS_of_last_frame</font></b><font style="vertical-align: inherit;"> + ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">current_time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_elapsed_since_PTS_value_was_set</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Cette solution est très similaire à ce que nous avons fait avec </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_audio_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, dans notre structure complète, nous allons mettre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">double video_current_pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t video_current_pts_time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">L'horloge sera mise à jour dans la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_refresh_timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">/* ... */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
<font></font>
      is-&gt;video_current_pts = vp-&gt;pts;<font></font>
      is-&gt;video_current_pts_time = av_gettime();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N'oubliez pas de l'initialiser dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_component_open</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">is-&gt;video_current_pts_time = av_gettime();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant, tout ce dont nous avons besoin est d'un moyen d'obtenir les informations:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_video_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> delta;<font></font>
<font></font>
  delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="hljs-number">1000000.0</span>;
  <span class="hljs-keyword">return</span> is-&gt;video_current_pts + delta;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstrait de la montre</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais pourquoi vous forcer à utiliser une horloge vidéo? </font><font style="vertical-align: inherit;">Vous pouvez aller plus loin et modifier notre code de synchronisation vidéo afin que l'audio et la vidéo n'essaient pas de se synchroniser. </font><font style="vertical-align: inherit;">Imaginez quel gâchis ce sera si nous essayons de le faire avec une option de ligne de commande, comme dans FFplay. </font><font style="vertical-align: inherit;">Donc, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abstenons-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous: nous allons créer une nouvelle fonction wrapper, </font><b><font style="vertical-align: inherit;">get_master_clock</font></b><font style="vertical-align: inherit;"> , qui vérifie la variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_sync_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puis appelle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_audio_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_video_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou toute autre horloge qui pourrait l'utiliser. </font><font style="vertical-align: inherit;">Nous pouvons même utiliser une horloge d'ordinateur, que nous appelons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_external_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">enum</span> {<font></font>
  AV_SYNC_AUDIO_MASTER,<font></font>
  AV_SYNC_VIDEO_MASTER,<font></font>
  AV_SYNC_EXTERNAL_MASTER,<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_VIDEO_MASTER</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_master_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {
    <span class="hljs-keyword">return</span> get_video_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">return</span> get_audio_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> get_external_clock(is);<font></font>
  }<font></font>
}<font></font>
main() {<font></font>
...<font></font>
  is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;<font></font>
...<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronisation audio</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, la partie la plus difficile: synchroniser l'audio avec l'horloge vidéo. Notre stratégie consiste à mesurer où se trouve l'audio, à le comparer avec l'horloge vidéo, puis à découvrir combien d'échantillons nous devons ajuster, c'est-à-dire, devons-nous accélérer en supprimant les échantillons ou ralentir en ajoutant? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous exécutons la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaque fois que nous traitons chaque ensemble d'échantillons audio que nous obtenons afin de réduire ou d'augmenter correctement cet ensemble. Cependant, nous ne voulons pas synchroniser tout le temps, car le traitement audio se produit beaucoup plus souvent que le traitement des paquets vidéo. Donc, nous allons définir le nombre minimum d'appels consécutifs à la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui sont considérés comme non synchronisés avant que nous ne prenions la peine de faire quoi que ce soit. Bien entendu, comme la dernière fois, la «désynchronisation» signifie que l'horloge audio et l'horloge vidéo diffèrent d'une quantité supérieure au seuil de synchronisation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons donc utiliser un coefficient fractionnaire, disons, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et maintenant, disons que nous avons obtenu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ensembles d'échantillons audio qui n'étaient pas synchronisés. Le nombre d'échantillons que nous ne synchronisons pas peut également varier considérablement, nous prenons donc la valeur moyenne de combien chacun d'eux n'est pas synchronisé. Par exemple, le premier appel pourrait montrer que nous ne sommes pas synchronisés pendant 40 ms, le suivant pendant 50 ms et ainsi de suite. Mais nous n'allons pas prendre une moyenne simple, car les valeurs les plus récentes sont plus importantes que celles qui les précèdent. Donc, nous allons utiliser un coefficient fractionnaire, disons, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et résumer les différences comme suit: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diff_sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new_diff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diff_sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lorsque nous sommes prêts à trouver la différence moyenne, nous calculons simplement </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avg_diff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diff_sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * (1 - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qu'est ce qui se passe ici? </font><font style="vertical-align: inherit;">L'équation ressemble à une sorte de magie. </font><font style="vertical-align: inherit;">Eh bien, il s'agit essentiellement d'une moyenne pondérée utilisant une série géométrique comme poids. </font><font style="vertical-align: inherit;">Je ne sais pas s'il y a un nom pour ça (j'ai même vérifié sur Wikipédia!), Mais pour plus d'informations, voici une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explication</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ou ici: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weightedmean.txt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici à quoi ressemble notre fonction:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Add or subtract samples to get a better sync, return new
   audio buffer size */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">synchronize_audio</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">short</span> *samples,
		      <span class="hljs-keyword">int</span> samples_size, <span class="hljs-keyword">double</span> pts)</span> </span>{
  <span class="hljs-keyword">int</span> n;
  <span class="hljs-keyword">double</span> ref_clock;<font></font>
  <font></font>
  n = <span class="hljs-number">2</span> * is-&gt;audio_st-&gt;codec-&gt;channels;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">double</span> diff, avg_diff;
    <span class="hljs-keyword">int</span> wanted_size, min_size, max_size, nb_samples;<font></font>
    <font></font>
    ref_clock = get_master_clock(is);<font></font>
    diff = get_audio_clock(is) - ref_clock;<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) {
      <span class="hljs-comment">// accumulate the diffs</span><font></font>
      is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef<font></font>
	* is-&gt;audio_diff_cum;<font></font>
      <span class="hljs-keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) {<font></font>
	is-&gt;audio_diff_avg_count++;<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	avg_diff = is-&gt;audio_diff_cum * (<span class="hljs-number">1.0</span> - is-&gt;audio_diff_avg_coef);<font></font>
<font></font>
       <span class="hljs-comment">/* Shrinking/expanding buffer code.... */</span><font></font>
<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">/* difference is TOO big; reset diff stuff */</span>
      is-&gt;audio_diff_avg_count = <span class="hljs-number">0</span>;<font></font>
      is-&gt;audio_diff_cum = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> samples_size;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc tout va bien pour nous; </font><font style="vertical-align: inherit;">nous savons approximativement à quel point le son n'est pas cohérent avec la vidéo ou avec ce que nous utilisons comme montre. </font><font style="vertical-align: inherit;">Donc, calculons maintenant combien d'échantillons nous devons ajouter ou supprimer en plaçant ce code dans la section "Réduire / étendre le code tampon":</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) {<font></font>
  wanted_size = samples_size + <font></font>
  ((<span class="hljs-keyword">int</span>)(diff * is-&gt;audio_st-&gt;codec-&gt;sample_rate) * n);<font></font>
  min_size = samples_size * ((<span class="hljs-number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX)<font></font>
                             / <span class="hljs-number">100</span>);<font></font>
  max_size = samples_size * ((<span class="hljs-number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) <font></font>
                             / <span class="hljs-number">100</span>);
  <span class="hljs-keyword">if</span>(wanted_size &lt; min_size) {<font></font>
    wanted_size = min_size;<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wanted_size &gt; max_size) {<font></font>
    wanted_size = max_size;<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N'oubliez pas que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_length</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sample_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * # </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of channel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * 2) est le nombre d'échantillons en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_length</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> secondes d'audio. </font><font style="vertical-align: inherit;">Par conséquent, le nombre d'échantillons que nous voulons sera égal au nombre d'échantillons que nous avons déjà, plus ou moins le nombre d'échantillons correspondant à la durée pendant laquelle le son a été joué. </font><font style="vertical-align: inherit;">Nous fixerons également une limite sur l'ampleur de notre correction, car si nous modifions trop notre tampon, ce sera trop ennuyeux pour l'utilisateur.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correction du nombre d'échantillons</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous devons corriger le son. </font><font style="vertical-align: inherit;">Vous avez peut-être remarqué que notre fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> renvoie une taille d'échantillon, qui nous indique ensuite le nombre d'octets à envoyer au flux. </font><font style="vertical-align: inherit;">Il nous suffit donc d'ajuster la taille de l'échantillon à la valeur souhaitée. </font><font style="vertical-align: inherit;">Cela fonctionne pour réduire la taille de l'échantillon. </font><font style="vertical-align: inherit;">Mais si vous devez l'augmenter, nous ne pouvons pas simplement augmenter la taille de l'échantillon, car il n'y a plus de données dans le tampon! </font><font style="vertical-align: inherit;">Par conséquent, nous devons ajouter un peu. </font><font style="vertical-align: inherit;">Mais quoi ajouter exactement? </font><font style="vertical-align: inherit;">Il serait stupide d'essayer d'extrapoler l'audio, alors utilisons simplement l'audio que nous avons déjà, en ajoutant la valeur du dernier échantillon au tampon.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(wanted_size &lt; samples_size) {
  <span class="hljs-comment">/* remove samples */</span><font></font>
  samples_size = wanted_size;<font></font>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wanted_size &gt; samples_size) {
  <span class="hljs-keyword">uint8_t</span> *samples_end, *q;
  <span class="hljs-keyword">int</span> nb;<font></font>
<font></font>
  <span class="hljs-comment">/* add samples by copying final samples */</span><font></font>
  nb = (samples_size - wanted_size);<font></font>
  samples_end = (<span class="hljs-keyword">uint8_t</span> *)samples + samples_size - n;<font></font>
  q = samples_end + n;<font></font>
  <span class="hljs-keyword">while</span>(nb &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">memcpy</span>(q, samples_end, n);<font></font>
    q += n;<font></font>
    nb -= n;<font></font>
  }<font></font>
  samples_size = wanted_size;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous retournons la taille de l'échantillon, et nous avons terminé avec cette fonction. </font><font style="vertical-align: inherit;">Il ne nous reste plus qu'à utiliser ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_size = synchronize_audio(is, (<span class="hljs-keyword">int16_t</span> *)is-&gt;audio_buf,<font></font>
				       audio_size, pts);<font></font>
	is-&gt;audio_buf_size = audio_size;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout ce que nous avons fait, c'est insérer un appel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">(Aussi, assurez-vous de vérifier le code source, dans lequel nous initialisons les variables que je n'ai pas pris la peine de définir.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et la dernière, avant de terminer: nous devons ajouter la condition "si" pour nous assurer de ne pas synchroniser la vidéo si c'est l'horloge principale:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) {<font></font>
  ref_clock = get_master_clock(is);<font></font>
  diff = vp-&gt;pts - ref_clock;<font></font>
<font></font>
  <span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
     FFPlay still doesn't "know if this is the best guess." */</span><font></font>
  sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay :<font></font>
                    AV_SYNC_THRESHOLD;<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
    <span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
      delay = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
      delay = <span class="hljs-number">2</span> * delay;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et il fonctionne! </font><font style="vertical-align: inherit;">Assurez-vous de vérifier le fichier source pour initialiser toutes les variables que je n'ai pas pris la peine de définir ou d'initialiser. </font><font style="vertical-align: inherit;">Compilez ensuite:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial06 tutorial06.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et le vol sera normal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la dernière leçon, nous allons revenir en arrière.</font></font><a name="seeking"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leçon 7: Recherche </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Leçon 6: Synchronisation audio"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Vers la table des matières"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Épilogue"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste complète tutorial07.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial05.c</span>
<span class="hljs-comment">// A pedagogical video player that really works!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial05 tutorial05.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SAMPLE_CORRECTION_PERCENT_MAX 10</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AUDIO_DIFF_AVG_NB 20</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_VIDEO_MASTER</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;
  <span class="hljs-keyword">double</span> pts;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">int</span>             av_sync_type;
  <span class="hljs-keyword">double</span>          external_clock; <span class="hljs-comment">/* external clock base */</span>
  <span class="hljs-keyword">int64_t</span>         external_clock_time;
  <span class="hljs-keyword">int</span>             seek_req;
  <span class="hljs-keyword">int</span>             seek_flags;
  <span class="hljs-keyword">int64_t</span>         seek_pos;<font></font>
<font></font>
  <span class="hljs-keyword">double</span>          audio_clock;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;
  <span class="hljs-keyword">int</span>             audio_hw_buf_size;
  <span class="hljs-keyword">double</span>          audio_diff_cum; <span class="hljs-comment">/* used for AV difference average computation */</span>
  <span class="hljs-keyword">double</span>          audio_diff_avg_coef;
  <span class="hljs-keyword">double</span>          audio_diff_threshold;
  <span class="hljs-keyword">int</span>             audio_diff_avg_count;
  <span class="hljs-keyword">double</span>          frame_timer;
  <span class="hljs-keyword">double</span>          frame_last_pts;
  <span class="hljs-keyword">double</span>          frame_last_delay;
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span>
  <span class="hljs-keyword">double</span>          video_current_pts; <span class="hljs-comment">///&lt;current displayed pts (different from video_clock if frame fifos are used)</span>
  <span class="hljs-keyword">int64_t</span>         video_current_pts_time;  <span class="hljs-comment">///&lt;time (av_gettime) at which we updated video_current_pts - used to have running video pts</span><font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
<span class="hljs-keyword">enum</span> {<font></font>
  AV_SYNC_AUDIO_MASTER,<font></font>
  AV_SYNC_VIDEO_MASTER,<font></font>
  AV_SYNC_EXTERNAL_MASTER,<font></font>
};<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
AVPacket flush_pkt;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(pkt != &amp;flush_pkt &amp;&amp; av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_flush</span><span class="hljs-params">(PacketQueue *q)</span> </span>{<font></font>
  AVPacketList *pkt, *pkt1;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">for</span>(pkt = q-&gt;first_pkt; pkt != <span class="hljs-literal">NULL</span>; pkt = pkt1) {<font></font>
    pkt1 = pkt-&gt;next;<font></font>
    av_free_packet(&amp;pkt-&gt;pkt);<font></font>
    av_freep(&amp;pkt);<font></font>
  }<font></font>
  q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;first_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;nb_packets = <span class="hljs-number">0</span>;<font></font>
  q-&gt;size = <span class="hljs-number">0</span>;<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_ctx-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_video_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> delta;<font></font>
<font></font>
  delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="hljs-number">1000000.0</span>;
  <span class="hljs-keyword">return</span> is-&gt;video_current_pts + delta;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_external_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">return</span> av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_master_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {
    <span class="hljs-keyword">return</span> get_video_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">return</span> get_audio_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> get_external_clock(is);<font></font>
  }<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-comment">/* Add or subtract samples to get a better sync, return new
   audio buffer size */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">synchronize_audio</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">short</span> *samples,
		      <span class="hljs-keyword">int</span> samples_size, <span class="hljs-keyword">double</span> pts)</span> </span>{
  <span class="hljs-keyword">int</span> n;
  <span class="hljs-keyword">double</span> ref_clock;<font></font>
<font></font>
  n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">double</span> diff, avg_diff;
    <span class="hljs-keyword">int</span> wanted_size, min_size, max_size <span class="hljs-comment">/*, nb_samples */</span>;<font></font>
    <font></font>
    ref_clock = get_master_clock(is);<font></font>
    diff = get_audio_clock(is) - ref_clock;<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) {
      <span class="hljs-comment">// accumulate the diffs</span><font></font>
      is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef<font></font>
	* is-&gt;audio_diff_cum;<font></font>
      <span class="hljs-keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) {<font></font>
	is-&gt;audio_diff_avg_count++;<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	avg_diff = is-&gt;audio_diff_cum * (<span class="hljs-number">1.0</span> - is-&gt;audio_diff_avg_coef);
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) {<font></font>
	  wanted_size = samples_size + ((<span class="hljs-keyword">int</span>)(diff * is-&gt;audio_ctx-&gt;sample_rate) * n);<font></font>
	  min_size = samples_size * ((<span class="hljs-number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);<font></font>
	  max_size = samples_size * ((<span class="hljs-number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);
	  <span class="hljs-keyword">if</span>(wanted_size &lt; min_size) {<font></font>
	    wanted_size = min_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wanted_size &gt; max_size) {<font></font>
	    wanted_size = max_size;<font></font>
	  }<font></font>
	  <span class="hljs-keyword">if</span>(wanted_size &lt; samples_size) {
	    <span class="hljs-comment">/* remove samples */</span><font></font>
	    samples_size = wanted_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wanted_size &gt; samples_size) {
	    <span class="hljs-keyword">uint8_t</span> *samples_end, *q;
	    <span class="hljs-keyword">int</span> nb;<font></font>
<font></font>
	    <span class="hljs-comment">/* add samples by copying final sample*/</span><font></font>
	    nb = (samples_size - wanted_size);<font></font>
	    samples_end = (<span class="hljs-keyword">uint8_t</span> *)samples + samples_size - n;<font></font>
	    q = samples_end + n;<font></font>
	    <span class="hljs-keyword">while</span>(nb &gt; <span class="hljs-number">0</span>) {
	      <span class="hljs-built_in">memcpy</span>(q, samples_end, n);<font></font>
	      q += n;<font></font>
	      nb -= n;<font></font>
	    }<font></font>
	    samples_size = wanted_size;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">/* difference is TOO big; reset diff stuff */</span>
      is-&gt;audio_diff_avg_count = <span class="hljs-number">0</span>;<font></font>
      is-&gt;audio_diff_cum = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> samples_size;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size, <span class="hljs-keyword">double</span> *pts_ptr)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> n;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data == flush_pkt.data) {<font></font>
      avcodec_flush_buffers(is-&gt;audio_ctx);<font></font>
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_size = synchronize_audio(is, (<span class="hljs-keyword">int16_t</span> *)is-&gt;audio_buf,<font></font>
				       audio_size, pts);<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <font></font>
      is-&gt;video_current_pts = vp-&gt;pts;<font></font>
      is-&gt;video_current_pts_time = av_gettime();<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio if not master source */</span>
      <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) {<font></font>
	ref_clock = get_master_clock(is);<font></font>
	diff = vp-&gt;pts - ref_clock;<font></font>
	<font></font>
	<span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	   FFPlay still doesn't "know if this is the best guess." */</span><font></font>
	sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	  <span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	    delay = <span class="hljs-number">0</span>;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	    delay = <span class="hljs-number">2</span> * delay;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    vp-&gt;pts = pts;<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) {<font></font>
      pts = av_frame_get_best_effort_timestamp(pFrame);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_hw_buf_size = spec.size;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
<font></font>
    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;<font></font>
    is-&gt;video_current_pts_time = av_gettime();<font></font>
<font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;seek_req) {
      <span class="hljs-keyword">int</span> stream_index= <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">int64_t</span> seek_target = is-&gt;seek_pos;<font></font>
<font></font>
      <span class="hljs-keyword">if</span>     (is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;videoStream;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;audioStream;<font></font>
<font></font>
      <span class="hljs-keyword">if</span>(stream_index&gt;=<span class="hljs-number">0</span>){<font></font>
	seek_target= av_rescale_q(seek_target, AV_TIME_BASE_Q,<font></font>
				  pFormatCtx-&gt;streams[stream_index]-&gt;time_base);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span>(av_seek_frame(is-&gt;pFormatCtx, stream_index, <font></font>
		       seek_target, is-&gt;seek_flags) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: error while seeking\n"</span>,<font></font>
		is-&gt;pFormatCtx-&gt;filename);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) {<font></font>
	  packet_queue_flush(&amp;is-&gt;audioq);<font></font>
	  packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span>(is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) {<font></font>
	  packet_queue_flush(&amp;is-&gt;videoq);<font></font>
	  packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);<font></font>
	}<font></font>
      }<font></font>
      is-&gt;seek_req = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stream_seek</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int64_t</span> pos, <span class="hljs-keyword">int</span> rel)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;seek_req) {<font></font>
    is-&gt;seek_pos = pos;<font></font>
    is-&gt;seek_flags = rel &lt; <span class="hljs-number">0</span> ? AVSEEK_FLAG_BACKWARD : <span class="hljs-number">0</span>;<font></font>
    is-&gt;seek_req = <span class="hljs-number">1</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  av_init_packet(&amp;flush_pkt);<font></font>
  flush_pkt.data = <span class="hljs-string">"FLUSH"</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">double</span> incr, pos;<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_KEYDOWN:
      <span class="hljs-keyword">switch</span>(event.key.keysym.sym) {
      <span class="hljs-keyword">case</span> SDLK_LEFT:<font></font>
	incr = <span class="hljs-number">-10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_RIGHT:<font></font>
	incr = <span class="hljs-number">10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_UP:<font></font>
	incr = <span class="hljs-number">60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_DOWN:<font></font>
	incr = <span class="hljs-number">-60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;<font></font>
      do_seek:<font></font>
	<span class="hljs-keyword">if</span>(global_video_state) {<font></font>
	  pos = get_master_clock(global_video_state);<font></font>
	  pos += incr;<font></font>
	  stream_seek(global_video_state, (<span class="hljs-keyword">int64_t</span>)(pos * AV_TIME_BASE), incr);<font></font>
	}<font></font>
	<span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;
      <span class="hljs-comment">/*
       * If the video has finished playing, then both the picture and
       * audio queues are waiting for more data.  Make them stop
       * waiting and terminate normally.
       */</span><font></font>
      SDL_CondSignal(is-&gt;audioq.cond);<font></font>
      SDL_CondSignal(is-&gt;videoq.cond);<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
}<font></font>
</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traitement des commandes de recherche</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous allons ajouter des fonctionnalités de recherche dans notre lecteur, car c'est vraiment ennuyeux lorsque vous ne pouvez pas rembobiner le film. De plus, nous verrons à quel point il est facile d'utiliser la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons faire «fléchir» vers la gauche et la «droite» les flèches du clavier pour faire avancer et reculer un peu le film, et les flèches «haut» et «bas» sont déjà plus importantes. «Un peu» - ce sera 10 secondes et «beaucoup» - tous les 60. Par conséquent, nous devons configurer notre boucle principale afin qu'elle intercepte les événements de frappe. Mais le fait est que lorsque nous obtenons une frappe, nous ne pouvons pas appeler </font><font style="vertical-align: inherit;">directement </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela doit être fait dans notre boucle de décodage principale, boucle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decode_thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Par conséquent, à la place, nous ajouterons quelques valeurs à la structure principale, qui contiendront une nouvelle position pour la recherche et quelques indicateurs de recherche:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">int</span>             seek_req;
  <span class="hljs-keyword">int</span>             seek_flags;
  <span class="hljs-keyword">int64_t</span>         seek_pos;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous devons configurer notre boucle principale qui capture les frappes:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">double</span> incr, pos;<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_KEYDOWN:
      <span class="hljs-keyword">switch</span>(event.key.keysym.sym) {
      <span class="hljs-keyword">case</span> SDLK_LEFT:<font></font>
	incr = <span class="hljs-number">-10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_RIGHT:<font></font>
	incr = <span class="hljs-number">10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_UP:<font></font>
	incr = <span class="hljs-number">60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_DOWN:<font></font>
	incr = <span class="hljs-number">-60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;<font></font>
      do_seek:<font></font>
	<span class="hljs-keyword">if</span>(global_video_state) {<font></font>
	  pos = get_master_clock(global_video_state);<font></font>
	  pos += incr;<font></font>
	  stream_seek(global_video_state, <font></font>
                      (<span class="hljs-keyword">int64_t</span>)(pos * AV_TIME_BASE), incr);<font></font>
	}<font></font>
	<span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      <span class="hljs-keyword">break</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour intercepter une frappe, nous examinons d'abord si l'événement </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_KEYDOWN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s'est </font><b><font style="vertical-align: inherit;">produit</font></b><font style="vertical-align: inherit;"> . Ensuite, nous vérifions quelle clé est reçue à l'aide de </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">event.key.keysym.sym</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dès que nous découvrons dans quelle direction nous cherchons, nous calculons une nouvelle heure, en ajoutant un incrément à la valeur de notre nouvelle fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_master_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ensuite , </font><font style="vertical-align: inherit;">nous appelons la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_seek</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonction </font><font style="vertical-align: inherit;">pour définir les </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seek_pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> valeurs </font><font style="vertical-align: inherit;">, etc. Convertissez notre nouvelle heure en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unités d'</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> horodatage interne </font><b><font style="vertical-align: inherit;">avcodec</font></b><font style="vertical-align: inherit;"> . Rappelez-vous que les horodatages dans les flux sont mesurés en images, pas en secondes, en utilisant la formule suivante: </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secondes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">images</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base de temps</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fps</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par défaut, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> défini sur 1 000 000 d'images par seconde (donc une position de 2 secondes aura un horodatage de 2 000 000). Pourquoi devons-nous convertir cette valeur - voir plus loin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici notre fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_seek</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Notez que nous mettons le drapeau si nous revenons en arrière:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stream_seek</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int64_t</span> pos, <span class="hljs-keyword">int</span> rel)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;seek_req) {<font></font>
    is-&gt;seek_pos = pos;<font></font>
    is-&gt;seek_flags = rel &lt; <span class="hljs-number">0</span> ? AVSEEK_FLAG_BACKWARD : <span class="hljs-number">0</span>;<font></font>
    is-&gt;seek_req = <span class="hljs-number">1</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons maintenant à notre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decode_thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , où nous effectuons réellement une recherche. Dans les fichiers source, vous pouvez voir que nous avons marqué la zone "la recherche est en cours". Eh bien, nous allons le mettre là tout de suite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La recherche est centrée sur la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cette fonction prend comme argument le contexte de format, le flux, l'horodatage et le jeu d'indicateurs. La fonction recherchera l'horodatage que vous lui attribuez. L'unité d'horodatage est la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base de temps du</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flux que vous passez à la fonction. Cependant, vous n'avez pas besoin de le transmettre au flux (indiqué en passant la valeur -1). Si vous faites cela, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sera dans l' </font><b><font style="vertical-align: inherit;">unité de</font></b><font style="vertical-align: inherit;"> temps interne </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou 1000000fps. C'est pourquoi nous avons multiplié notre position par </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lorsque nous avons défini </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seek_pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, parfois, vous pouvez (rarement) rencontrer des problèmes pour certains fichiers si vous passez </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le flux, nous allons donc sélectionner le premier flux dans notre fichier et le transmettre à </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . N'oubliez pas que nous devons changer l'échelle de notre horodatage pour être dans le nouveau «système de coordonnées».</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(is-&gt;seek_req) {
  <span class="hljs-keyword">int</span> stream_index= <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int64_t</span> seek_target = is-&gt;seek_pos;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>     (is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;videoStream;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index&gt;=<span class="hljs-number">0</span>){<font></font>
    seek_target= av_rescale_q(seek_target, AV_TIME_BASE_Q,<font></font>
                      pFormatCtx-&gt;streams[stream_index]-&gt;time_base);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(av_seek_frame(is-&gt;pFormatCtx, stream_index, <font></font>
                    seek_target, is-&gt;seek_flags) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: error while seeking\n"</span>,<font></font>
            is-&gt;pFormatCtx-&gt;filename);<font></font>
  } <span class="hljs-keyword">else</span> {
     <span class="hljs-comment">/* handle packet queues... more later... */</span>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_rescale_q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) est une fonction qui met à l'échelle l'horodatage d'une base à une autre. Il calcule essentiellement </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais cette fonction est utile car ce calcul conduit parfois à un débordement. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE_Q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une version fractionnée d' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ils sont complètement différents: </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_in_seconds</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_timestamp</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE_Q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_timestamp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_in_seconds</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (mais notez que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE_Q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est en fait un objet </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous devez donc utiliser des fonctions </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> spéciales </font><font style="vertical-align: inherit;">dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le traiter).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nettoyage des tampons</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc configuré nos recherches correctement, mais nous n'avons pas encore terminé. N'oubliez pas, avons-nous une file d'attente configurée pour accumuler des paquets? Maintenant que nous sommes dans un horodatage différent, nous devons effacer cette file d'attente, sinon la recherche dans le film ne fonctionnera pas! De plus, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> possède ses propres tampons internes, qui doivent également être vidés pour chaque flux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ce faire, vous devez d'abord écrire une fonction qui efface notre file d'attente de paquets. Ensuite, vous devez en quelque sorte indiquer au flux audio et vidéo qu'ils ont effacé les tampons internes </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nous pouvons le faire en plaçant un paquet spécial dans la file d'attente après son nettoyage, et quand ils (threads) découvriront ce paquet spécial, ils effaceront simplement leurs tampons.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par la fonction de réinitialisation. </font><font style="vertical-align: inherit;">C'est vraiment assez simple, donc je vais juste vous montrer le code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_flush</span><span class="hljs-params">(PacketQueue *q)</span> </span>{<font></font>
  AVPacketList *pkt, *pkt1;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">for</span>(pkt = q-&gt;first_pkt; pkt != <span class="hljs-literal">NULL</span>; pkt = pkt1) {<font></font>
    pkt1 = pkt-&gt;next;<font></font>
    av_free_packet(&amp;pkt-&gt;pkt);<font></font>
    av_freep(&amp;pkt);<font></font>
  }<font></font>
  q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;first_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;nb_packets = <span class="hljs-number">0</span>;<font></font>
  q-&gt;size = <span class="hljs-number">0</span>;<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que la file d'attente est effacée, ajoutez notre «paquet de nettoyage». </font><font style="vertical-align: inherit;">Mais d'abord, il serait bien de définir ce que c'est et de le créer:</font></font><br>
<br>
<pre><code class="cpp hljs">AVPacket flush_pkt;<font></font>
<font></font>
main() {<font></font>
  ...<font></font>
  av_init_packet(&amp;flush_pkt);<font></font>
  flush_pkt.data = <span class="hljs-string">"FLUSH"</span>;<font></font>
  ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, mettez ce paquet dans la file d'attente:</font></font><br>
<br>
<pre><code class="cpp hljs">  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) {<font></font>
      packet_queue_flush(&amp;is-&gt;audioq);<font></font>
      packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) {<font></font>
      packet_queue_flush(&amp;is-&gt;videoq);<font></font>
      packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);<font></font>
    }<font></font>
  }<font></font>
  is-&gt;seek_req = <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Cet extrait de code continue l'extrait de code ci-dessus pour </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decode_thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) Nous devons également modifier </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_queue_put</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afin de ne pas dupliquer un package spécial pour le nettoyage:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(pkt != &amp;flush_pkt &amp;&amp; av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et puis dans le flux audio et vidéo, nous plaçons cet appel dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_flush_buffers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> juste après </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_queue_get</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data == flush_pkt.data) {<font></font>
      avcodec_flush_buffers(is-&gt;audio_st-&gt;codec);<font></font>
      <span class="hljs-keyword">continue</span>;<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'extrait de code ci-dessus est exactement le même pour le flux vidéo, avec le remplacement de "audio" par "video". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ça y est ...! </font><font style="vertical-align: inherit;">Nous l'avons fait! </font><font style="vertical-align: inherit;">Compilez votre lecteur:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial07 tutorial07.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et profitez de votre lecteur de film fait en moins de 1000 lignes de C! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, il y a beaucoup de choses qui peuvent être ajoutées ou améliorées.</font></font><a name="epilogue"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postface </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Leçon 7: Recherche"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Vers la table des matières"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Annexe 1. Liste des fonctions"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, nous avons un joueur qui fonctionne, mais bien sûr, il n'est pas aussi bon qu'il pourrait l'être. </font><font style="vertical-align: inherit;">Il serait possible de modifier le fichier et d'ajouter beaucoup de choses utiles:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avouons-le, ce joueur est nul. </font><font style="vertical-align: inherit;">La version de ffplay.c sur laquelle il est basé est complètement obsolète et, par conséquent, ce didacticiel doit être entièrement révisé. </font><font style="vertical-align: inherit;">Si vous souhaitez passer à des projets plus sérieux en utilisant les bibliothèques FFmpeg, je vous recommande fortement de vérifier la dernière version de ffplay.c comme tâche suivante.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La gestion des erreurs dans notre code est terrible et peut être implémentée beaucoup mieux.</font></font></li>
<li>      ,  ,   ,     .   ,    <b>paused</b>    ,   ,    .   ,    ,      .     <b>av_read_play</b>.   -   ,     .  ,    ,       . : ,     ffplay.c.</li>
<li> .</li>
<li> .       ,    ,      ,    ,   <b>VOB-</b>.</li>
<li> .   ,        .</li>
<li> .       .</li>
<li>  ,   ,  ,      ,   <b>YUV</b>,             <b>time_base</b>.</li>
<li> .</li>
<li>--,    ;  ffplay.c      .</li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous voulez en savoir plus sur FFmpeg, alors nous avons considéré loin de tout. L'étape suivante consiste à étudier le codage multimédia. Il est préférable de commencer avec le fichier </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">output_example.c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que vous trouverez dans la distribution FFmpeg. Je pourrais déjà écrire un autre manuel sur ce sujet, mais il est peu probable qu'il dépasse ce guide. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a longtemps, je n'ai pas mis à jour ce texte, mais en attendant le monde ne reste pas immobile. Ce didacticiel ne nécessite que de simples mises à jour d'API; très peu de choses ont changé en termes de concepts de base. La plupart de ces mises à jour ont en fait simplifié le code. Cependant, bien que j'aie parcouru le code et l'ai mis à jour, FFplay est toujours supérieur à ce joueur. La main sur le cœur, nous l'admettons: dans ces leçons, nous avons écrit un lecteur de film assez moche. Par conséquent, si aujourd'hui (ou à l'avenir) vous souhaitez améliorer ce didacticiel, je vous recommande de vous familiariser avec FFplay et de découvrir ce qui manque. Je pense que cela concerne principalement l'utilisation de l'équipement vidéo, mais il est fort possible que je passe à côté d'autres éléments évidents. Peut-être qu'une comparaison avec le FFplay actuel conduirait à une réécriture radicale de certaines choses - je ne l'ai pas encore regardé.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais je suis très fier qu'au fil des ans, mon travail ait beaucoup aidé, même en tenant compte du fait que les gens recherchaient souvent du code ailleurs. </font><font style="vertical-align: inherit;">Je suis extrêmement reconnaissant à </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chelyaev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui s'est chargé de remplacer toutes les fonctions obsolètes depuis que j'ai écrit cette monographie il y a 8 (!) Ans. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je me réjouis en espérant que ces leçons se sont avérées utiles et non ennuyeuses. </font><font style="vertical-align: inherit;">S'il y a des suggestions, des erreurs, des plaintes, des remerciements, etc. concernant ce guide, veuillez m'écrire à dranger dog gmail dot com. </font><font style="vertical-align: inherit;">Et oui, cela n'a aucun sens de me demander de vous aider avec votre projet FFmpeg. </font><font style="vertical-align: inherit;">Il y a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trop</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><font style="vertical-align: inherit;">lettres similaires </font><font style="vertical-align: inherit;">.</font></font><a name="functions"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annexe 1. Liste des fonctions </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Épilogue"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Vers la table des matières"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Annexe 2. Structures de données"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avformat_open_input</span><span class="hljs-params">(AVFormatContext **ptr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * filename, AVInputFormat *fmt, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ouvre le nom du fichier multimédia, enregistre le contexte de format à l'adresse spécifiée dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fmt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : sinon NULL, définit le format de fichier. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buf_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : taille du tampon (facultatif). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">options</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : AVDictionary est rempli avec les paramètres de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFormatContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et du démultiplexeur.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">avformat_close_input</span><span class="hljs-params">(AVFormatContext **s)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ferme le fichier multimédia. </font><font style="vertical-align: inherit;">Cependant, il ne ferme pas les codecs.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">nt <span class="hljs-title">avio_open2</span> <span class="hljs-params">(AVIOContext **s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *url, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">const</span> AVIOInterruptCB *int_cb, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Crée un contexte d'E / S pour utiliser la ressource spécifiée dans l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">url</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : pointeur vers l'endroit où l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVIOContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sera créé </font><font style="vertical-align: inherit;">. En cas d'échec, la valeur spécifiée est définie sur NULL. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">url</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : nom de la ressource à accéder. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : contrôle l'ouverture de la ressource spécifiée dans l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">url</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int_cb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : interruption du rappel pour une utilisation au niveau du protocole. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">options</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : un dictionnaire rempli de paramètres de protocole privés. Lorsque la fonction revient, le paramètre sera détruit et remplacé par un dict contenant des options non trouvées. Peut être NULL.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_dup_packet</span><span class="hljs-params">(AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, c'est un hack: si ce package n'a pas été alloué, nous le postons ici. </font><font style="vertical-align: inherit;">Renvoie 0 en cas de succès ou AVERROR_NOMEM en cas d'échec.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_find_stream_info</span><span class="hljs-params">(AVFormatContext *s, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fonction recherche des informations de flux non évidentes, telles que la fréquence d'images. </font><font style="vertical-align: inherit;">Ceci est utile pour les formats de fichiers sans en-tête tels que MPEG. </font><font style="vertical-align: inherit;">Il est recommandé d'appeler après avoir ouvert le fichier. </font><font style="vertical-align: inherit;">Retourne&gt; = 0 en cas de succès, AVERROR_ * en cas d'erreur.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVFrame *<span class="hljs-title">avcodec_free_frame</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ancien nom pour av_frame_free. </font><font style="vertical-align: inherit;">Modifié en lavc 55.28.1.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_frame_free</span> <span class="hljs-params">(AVFrame **frame)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Libère un cadre et tout objet alloué dynamiquement, par exemple, Extended_data.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Libère la mémoire allouée à l'aide de av_malloc () ou av_realloc (). </font><font style="vertical-align: inherit;">Vous pouvez appeler cette fonction avec ptr == NULL. </font><font style="vertical-align: inherit;">Il est recommandé d'appeler à la place av_freep ().</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_freep</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Libère de la mémoire et définit le pointeur sur NULL. </font><font style="vertical-align: inherit;">Utilise en interne av_free ().</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_free_packet</span><span class="hljs-params">(AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enrouler autour de la méthode de destruction de paquets (pkt-&gt; destruct).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">av_gettime</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obtenez l'heure actuelle en microsecondes.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_init_packet</span><span class="hljs-params">(AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialisation des champs de package facultatifs.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">av_malloc</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Taille d'octet d'allocation de mémoire avec alignement adapté à tous les accès à la mémoire (y compris les vecteurs, si disponibles sur le CPU). </font><font style="vertical-align: inherit;">av_malloc (0) doit renvoyer un pointeur non nul.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">av_mallocz</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Identique à av_malloc (), mais initialise la mémoire à zéro.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">av_q2d</span><span class="hljs-params">(AVRational a)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Double AVRational.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_read_frame</span><span class="hljs-params">(AVFormatContext *s, AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Renvoie la trame de flux suivante. Les informations sont stockées sous forme de package dans pkt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le paquet retourné est valide jusqu'au prochain av_read_frame () ou jusqu'à av_close_input_file () et doit être libéré en utilisant av_free_packet. Pour un package vidéo contient exactement une image. Pour l'audio, il contient un nombre entier de trames si chaque trame a une taille fixe connue (par exemple, des données PCM ou ADPCM). Si les images audio sont de taille variable (par exemple, audio MPEG), elles contiennent une image. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pkt-&gt; pts, pkt-&gt; dts et pkt-&gt; duration sont toujours définis sur les valeurs correctes en unités de AVStream.timebase (et il est supposé que le format ne peut pas les fournir). pkt-&gt; pts peut être AV_NOPTS_VALUE si le format vidéo a des images B, il est donc préférable de s'appuyer sur pkt-&gt; dts si vous ne déballez pas la charge utile.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résultat retourné:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0, si tout va bien, &lt;0, s'il y a une erreur ou la fin du fichier.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_register_all</span><span class="hljs-params">()</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enregistre tous les codecs de la bibliothèque.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">av_rescale_q</span><span class="hljs-params">(<span class="hljs-keyword">int64_t</span> a, AVRational bq, AVRational cq)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Renvoie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_seek_frame</span><span class="hljs-params">(AVFormatContext *s, <span class="hljs-keyword">int</span> stream_index, <span class="hljs-keyword">int64_t</span> timestamp, <span class="hljs-keyword">int</span> flags)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recherche une image clé à un horodatage. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_index</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : si stream_index est -1, le flux par défaut est sélectionné et l'horodatage est automatiquement converti des unités AV_TIME_BASE en une base de temps spécifique au flux. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horodatage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : horodatage mesuré en unités de AVStream.time_base ou, si aucun flux n'est spécifié, puis en unités de AV_TIME_BASE. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drapeaux</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : définissez les paramètres concernant la direction et le mode de recherche: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVSEEK_FLAG_ANY: recherchez dans n'importe quelle image, pas seulement les images clés. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVSEEK_FLAG_BACKWARD: recherche dans la direction opposée. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVSEEK_FLAG_BYTE: recherche basée sur la position en octets.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVFrame *<span class="hljs-title">avcodec_alloc_frame</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ancien nom pour av_frame_alloc. </font><font style="vertical-align: inherit;">Modifié en lavc 55.28.1.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVFrame *<span class="hljs-title">av_frame_alloc</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sélectionne un AVFrame et l'initialise. </font><font style="vertical-align: inherit;">Peut être libéré en utilisant av_frame_free ().</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_decode_audio4</span><span class="hljs-params">(AVCodecContext *avctx, AVFrame *frame, <span class="hljs-keyword">int</span> *got_frame_ptr, <span class="hljs-keyword">const</span> AVPacket *avpkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Décode une image audio d'avpkt en image. La fonction avcodec_decode_audio4 () décode un fichier audio d'AVPacket. Pour son décodage, un codec audio est utilisé, qui était associé à avctx en utilisant avcodec_open2 (). La trame décodée résultante est stockée dans l'AVFrame spécifié. Si la trame a été décompressée, elle mettra got_frame_ptr à 1. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avertissement: le</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tampon d'entrée, avpkt-&gt; data, doit être FF_INPUT_BUFFER_PADDING_SIZE plus grand que les octets de lecture réels, car certains lecteurs de flux binaires optimisés lisent 32 ou 64 bits à la fois et peuvent lire jusqu'à la fin. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avctx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : contexte du codec. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">frame</font></b><font style="vertical-align: inherit;"> cible. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">got_frame_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : target int, qui sera défini si le cadre a été décompressé. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPKT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: AVPacket contenant de l'audio. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résultat retourné:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si une erreur est retournée, une valeur négative est retournée; sinon, le nombre d'octets utilisés à partir de l'AVPacket d'entrée est retourné.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_decode_video2</span><span class="hljs-params">(AVCodecContext *avctx, AVFrame *picture, <span class="hljs-keyword">int</span> *frameFinished, <span class="hljs-keyword">const</span> AVPacket *avpkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Décode une image vidéo de buf en image. La fonction avcodec_decode_video2 () décode une image vidéo à partir d'un tampon d'entrée de taille buf_size. Pour son décodage, un codec vidéo est utilisé, qui était associé à avctx en utilisant avcodec_open2 (). L'image décodée résultante est enregistrée dans l'image. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avertissement: les</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exemples d'alignement et les problèmes de tampon qui s'appliquent à avcodec_decode_audio4 s'appliquent également à cette fonction. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avctx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : contexte du codec. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">image</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : AVFrame dans lequel la vidéo décodée sera enregistrée. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frameFinished</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : zéro si aucune </font><b><font style="vertical-align: inherit;">trame</font></b><font style="vertical-align: inherit;"> ne peut être décompressée, sinon elle n'est pas égale à zéro. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avpkt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: AVPacket d'entrée contenant le tampon d'entrée. </font><font style="vertical-align: inherit;">Vous pouvez créer un tel package à l'aide de av_init_packet (), puis, après avoir spécifié les données et la taille, certains décodeurs peuvent en outre avoir besoin d'autres champs, tels que drapeaux et AV_PKT_FLAG_KEY. </font><font style="vertical-align: inherit;">Tous les décodeurs sont conçus pour utiliser le moins de champs possible. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résultat retourné:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En cas d'erreur, une valeur négative est renvoyée, sinon le nombre d'octets est utilisé ou zéro si aucune trame ne peut être décompressée.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">av_frame_get_best_effort_timestamp</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> AVFrame *frame)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une méthode d'accès simple pour obtenir best_effort_timestamp à partir d'un objet AVFrame.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVCodec *<span class="hljs-title">avcodec_find_decoder</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> CodecID id)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recherche un décodeur avec CodecID. </font><font style="vertical-align: inherit;">Renvoie NULL en cas d'erreur. </font><font style="vertical-align: inherit;">Il doit être appelé après avoir obtenu l'AVCodecContext requis à partir du flux dans AVFormatContext à l'aide de codecCtx-&gt; codec_id.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">avcodec_flush_buffers</span><span class="hljs-params">(AVCodecContetx *avctx)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rinçage du tampon. </font><font style="vertical-align: inherit;">Appelé lors de la recherche ou du passage à un autre flux.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVCodecContext * <span class="hljs-title">avcodec_alloc_context3</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> AVCodec *codec)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attribue AVCodecContext et définit ses champs sur des valeurs par défaut.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_copy_context</span> <span class="hljs-params">(AVCodecContext *dest, <span class="hljs-keyword">const</span> AVCodecContext *src)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Copiez les paramètres de l'AVCodecContext source dans l'AVCodecContext cible. </font><font style="vertical-align: inherit;">Le contexte résultant du codec de destination sera fermé, c'est-à-dire </font><font style="vertical-align: inherit;">vous devez appeler avcodec_open2 () avant d'utiliser cet AVCodecContext pour décoder / encoder des données vidéo / audio. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dest</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : doit être initialisé avec avcodec_alloc_context3 (NULL), sinon il ne sera pas initialisé.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_open2</span><span class="hljs-params">(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialise avctx pour utiliser le codec spécifié dans le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Doit être utilisé après avcodec_find_decoder. </font><font style="vertical-align: inherit;">Retourne zéro en cas de succès et une valeur négative en cas d'erreur.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avpicture_fill</span><span class="hljs-params">(AVPicture *picture, <span class="hljs-keyword">uint8_t</span> *ptr, <span class="hljs-keyword">int</span> pix_fmt, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Définit la structure vers laquelle l'image pointe, avec le tampon </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le format </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pix_fmt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et la largeur et la hauteur spécifiées. </font><font style="vertical-align: inherit;">Renvoie la taille des données d'image en octets.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avpicture_get_size</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pix_fmt, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Calcule le nombre d'octets nécessaires pour une image d'une largeur, d'une hauteur et d'un format d'image donnés.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct SwsContext* <span class="hljs-title">sws_getContext</span><span class="hljs-params">(<span class="hljs-keyword">int</span> srcW, <span class="hljs-keyword">int</span> srcH, <span class="hljs-keyword">int</span> srcFormat, <span class="hljs-keyword">int</span> dstW, <span class="hljs-keyword">int</span> dstH, <span class="hljs-keyword">int</span> dstFormat, <span class="hljs-keyword">int</span> flags, SwsFilter *srcFilter, SwsFilter *dstFilter, <span class="hljs-keyword">double</span> *param)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Renvoie SwsContext pour une utilisation dans sws_scale. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcW</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : largeur, hauteur et format des pixels souhaités. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstW</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : largeur, hauteur et format des derniers pixels. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la méthode de mise à l'échelle à utiliser. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les options suivantes sont disponibles: SWS_FAST_BILINEAR, SWS_BILINEAR, SWS_BICUBIC, SWS_X, SWS_POINT, SWS_AREA, SWS_BICUBLIN, SWS_GAUSS, SWS_SINC, SWS_LANCZOS, SWS_SPLINE. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les autres indicateurs incluent les indicateurs de capacité du processeur: SWS_CPU_CAPS_MMX, SWS_CPU_CAPS_MMX2, SWS_CPU_CAPS_3DNOW, SWS_CPU_CAPS_ALTIVEC.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'autres indicateurs incluent (actuellement pas complètement implémentés) SWS_FULL_CHR_H_INT, SWS_FULL_CHR_H_INP et SWS_DIRECT_BGR. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, il y a SWS_ACCURATE_RND et peut-être le plus utile pour les débutants, SWS_PRINT_INFO. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'ai aucune idée de ce que font la plupart d'entre eux. Peut-être m'écris-tu? </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcFilter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstFilter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : SwsFilter pour la source et la destination. SwsFilter permet le filtrage couleur / luminosité. La valeur par défaut est NULL. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : devrait être un pointeur vers un tampon int [2] avec des coefficients. Non documenté. Il semble être utilisé pour modifier légèrement les algorithmes de mise à l'échelle standard. La valeur par défaut est NULL. Uniquement pour les experts!</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sws_scale</span><span class="hljs-params">(SwsContext *c, <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">int</span> srcStride[], <span class="hljs-keyword">int</span> srcSliceY, <span class="hljs-keyword">int</span> srcSliceH, <span class="hljs-keyword">uint8_t</span> dst[], <span class="hljs-keyword">int</span> dstStride[]
sws_scale(sws_ctx, pFrame-&gt;data, pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_st-&gt;codec-&gt;height, pict.data, pict.linesize);</span></span></code></pre><br><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Met à l'échelle les</font></b><font style="vertical-align: inherit;"> 
données en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">src</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> selon nos paramètres dans notre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwsContext * c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcStride</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstStride</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont les tailles de ligne source et destination.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_TimerID <span class="hljs-title">SDL_AddTimer</span><span class="hljs-params">(Uint32 interval, SDL_NewTimerCallback callback, <span class="hljs-keyword">void</span> *param)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ajoute une fonction de rappel qui s'exécute après un nombre spécifié de millisecondes. La fonction de rappel transmet l'intervalle de temporisation en cours et le paramètre fourni par l'utilisateur à partir de l'appel SDL_AddTimer et renvoie l'intervalle de temporisation suivant. (Si la valeur de retour du rappel correspond à la valeur transmise, le minuteur continue de fonctionner à la même vitesse.) Si la valeur de retour du rappel est 0, le minuteur est annulé. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre façon d'annuler le temporisateur en cours consiste à appeler SDL_RemoveTimer avec l'identifiant du temporisateur (qui a été renvoyé par SDL_AddTimer). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction de rappel du minuteur peut s'exécuter sur un thread différent de votre programme principal et ne doit donc pas appeler de fonction à partir d'elle-même. Cependant, vous pouvez toujours appeler SDL_PushEvent.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le degré de détail du temporisateur dépend de la plate-forme, mais vous devez vous attendre à au moins 10 ms, car il s'agit de la valeur la plus courante. </font><font style="vertical-align: inherit;">Cela signifie que si vous demandez un temporisateur de 16 ms, le rappel commencera après environ 20 ms sur un système non chargé. </font><font style="vertical-align: inherit;">Si vous devez définir un indicateur qui signale la mise à jour des images à une vitesse de 30 images par seconde (toutes les 33 ms), vous pouvez définir une minuterie de 30 ms (voir l'exemple ci-dessous). </font><font style="vertical-align: inherit;">Si vous utilisez cette fonction, vous devez passer SDL_INIT_TIMER à SDL_Init. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Renvoie la valeur d'identificateur du minuteur ajouté, ou NULL si une erreur se produit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Format de rappel:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">Uint32 <span class="hljs-title">callback</span> <span class="hljs-params">( Uint32, <span class="hljs-keyword">void</span> * param)</span></span></code></pre><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_CondSignal</span><span class="hljs-params">(SDL_cond *cond)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redémarrage de l'un des threads en attente de la variable de condition </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cond</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Renvoie 0 en cas de succès et -1 en cas d'erreur.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_CondWait</span><span class="hljs-params">(SDL_cond *cond, SDL_mutex *mut)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Déverrouillez le mutex fourni et attendez qu'un autre thread appelle SDL_CondSignal ou SDL_CondBroadcast pour la variable de condition cond, puis verrouillez à nouveau le mutex. </font><font style="vertical-align: inherit;">Le mutex doit être verrouillé avant d'accéder à cette fonction. </font><font style="vertical-align: inherit;">Renvoie 0 lorsqu'un signal est reçu ou -1 en cas d'erreur.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_cond *<span class="hljs-title">SDL_CreateCond</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Crée une variable de condition.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_Thread *<span class="hljs-title">SDL_CreateThread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*fn)(<span class="hljs-keyword">void</span> *), <span class="hljs-keyword">void</span> *data)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_CreateThread crée un nouveau thread d'exécution qui partage toute la mémoire globale de son parent, des gestionnaires de signaux, des descripteurs de fichiers, etc. </font><font style="vertical-align: inherit;">Et il exécute la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fn</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en lui passant les données du pointeur vide. </font><font style="vertical-align: inherit;">Le thread se termine lorsque fn renvoie une valeur.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_Delay</span> <span class="hljs-params">(Uint32 )</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attend le nombre de millisecondes spécifié. SDL_Delay attendra au moins l'heure spécifiée, mais peut-être plus longtemps en raison de la planification du système d'exploitation. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> attendez-vous à une granularité de retard d'au moins 10 ms. Certaines plateformes ont des mesures plus courtes, mais c'est l'option la plus courante.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_Overlay *<span class="hljs-title">SDL_CreateYUVOverlay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, Uint32 format, SDL_Surface *display)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_CreateYUVOverlay crée une superposition YUV de la largeur, de la hauteur et du format spécifiés (pour une liste des formats disponibles, voir la structure de données SDL_Overlay) pour l'affichage fourni. </font><font style="vertical-align: inherit;">Renvoie SDL_Overlay. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'affichage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devrait en fait être une surface dérivée de SDL_SetVideoMode, sinon cette fonction fonctionnera par défaut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le terme «superposition» est incorrect, car si la superposition n'est pas créée dans le matériel, le contenu de la surface d'affichage sous la zone où la superposition est affichée sera écrasé lorsque la superposition est affichée.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_LockYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_LockYUVOverlay bloque la superposition pour un accès direct aux données de pixels. </font><font style="vertical-align: inherit;">Renvoie 0 en cas de succès ou -1 en cas d'erreur.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_UnlockYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Déverrouille une superposition précédemment verrouillée. </font><font style="vertical-align: inherit;">La superposition doit être déverrouillée avant de pouvoir être affichée.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_DisplayYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay, SDL_Rect *dstrect)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Place la superposition sur la surface spécifiée lors de sa création. </font><font style="vertical-align: inherit;">La structure SDL_Rect dstrect définit la position et la taille de la destination. </font><font style="vertical-align: inherit;">Si dstrect est plus ou moins une superposition, alors la superposition sera mise à l'échelle, ceci est optimisé pour une mise à l'échelle 2x. </font><font style="vertical-align: inherit;">Renvoie 0 en cas de succès.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_FreeYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Libère la superposition créée par SDL_CreateYUVOverlay.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_Init</span><span class="hljs-params">(Uint32 flags)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialise le SDL. Cela doit être appelé avant toutes les autres fonctions SDL. Le paramètre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> spécifie les parties du SDL à initialiser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_TIMER - initialise le sous-système de temporisation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_AUDIO - initialise le sous-système audio. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_VIDEO - initialise le sous-système vidéo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_CDROM - initialise le sous-système du CD-ROM. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_JOYSTICK - initialise le sous-système du joystick. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_EVERYTHING - Initialise tout ce qui précède. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_NOPARACHUTE - ne permet pas à SDL de détecter les erreurs fatales. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_EVENTTHREAD - lance le gestionnaire d'événements dans un thread séparé.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Renvoie -1 en cas d'erreur ou 0 en cas de succès. </font><font style="vertical-align: inherit;">Vous pouvez obtenir un message d'erreur étendu en appelant SDL_GetError. </font><font style="vertical-align: inherit;">Une cause typique d'une erreur est l'utilisation d'un affichage spécifique sans le support correspondant pour le sous-système, par exemple, l'absence d'un pilote de souris lors de l'utilisation d'un tampon de trame avec le périphérique. </font><font style="vertical-align: inherit;">Dans ce cas, vous pouvez soit compiler SDL sans souris, soit définir la variable d'environnement "SDL_NOMOUSE = 1" avant de démarrer l'application.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_mutex *<span class="hljs-title">SDL_CreateMutex</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Crée un nouveau mutex déverrouillé.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_LockMutex</span><span class="hljs-params">(SDL_mutex *mutex)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_LockMutex est un alias pour SDL_mutexP. </font><font style="vertical-align: inherit;">Il bloque un mutex créé précédemment à l'aide de SDL_CreateMutex. </font><font style="vertical-align: inherit;">Si le mutex est déjà bloqué par un autre thread, alors SDL_mutexP ne renvoie pas de valeur tant que le thread bloqué par lui ne le déverrouille pas (à l'aide de SDL_mutexV). </font><font style="vertical-align: inherit;">Lorsque le mutex est appelé à nouveau, SDL_mutexV (alias SDL_UnlockMutex) doit être appelé un nombre égal de fois pour remettre le mutex dans un état déverrouillé. </font><font style="vertical-align: inherit;">Renvoie 0 en cas de succès ou -1 en cas d'erreur.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_UnlockMutex</span><span class="hljs-params">(SDL_Mutex *mutex)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Déverrouillage Mutex.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_OpenAudio</span><span class="hljs-params">(SDL_AudioSpec *desired, SDL_AudioSpec *obtained)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fonction ouvre l'unité audio avec les paramètres requis et renvoie 0 en cas de succès, en plaçant les paramètres matériels réels dans la structure vers laquelle elle pointe finalement. Si une valeur NULL est reçue, les données audio transmises à la fonction de rappel seront garanties d'avoir le format requis et, si nécessaire, seront automatiquement converties au format audio matériel. Cette fonction renvoie -1 si le périphérique audio n'a pas pu être ouvert ou le flux audio n'a pas pu être configuré. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ouvrir un périphérique audio, vous devez créer le SDL_AudioSpec souhaité. Ensuite, vous devez remplir cette structure avec les spécifications audio souhaitées. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desire-&gt; freq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : fréquence sonore souhaitée en échantillons par seconde. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">désiré-&gt; format</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">format</font></b><font style="vertical-align: inherit;"> audio souhaité (voir SDL_AudioSpec). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">souhaité-&gt; canaux</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Canaux requis (1 pour mono, 2 pour stéréo, 4 pour son surround, 6 pour son surround avec centrage et LFE). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">désiré-&gt; échantillons</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : taille de tampon audio souhaitée dans les échantillons. Ce nombre doit être une puissance de deux et peut être ajusté par le pilote audio à une valeur plus adaptée au matériel. Les valeurs optimales vont de 512 à 8192 inclus, selon l'application et la vitesse du processeur. Des valeurs plus petites entraînent des temps de réponse plus rapides, mais peuvent entraîner de mauvaises performances si l'application effectue un traitement intensif et ne peut pas remplir le tampon audio à temps. L'échantillon stéréo se compose des canaux droit et gauche dans l'ordre LR. Veuillez noter que le nombre d'échantillons est directement lié au temps en utilisant la formule suivante: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ms</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = (</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">échantillons</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * 1000) / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">désiré-&gt; rappel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : doit être réglé sur une fonction qui sera appelée lorsque l'unité audio sera prête à recevoir des données supplémentaires. Le pointeur vers le tampon audio et la longueur en octets du tampon audio sont transmis. Cette fonction est généralement exécutée dans un thread séparé, et il est donc nécessaire de protéger les structures de données auxquelles elle accède en appelant SDL_LockAudio et SDL_UnlockAudio dans le code. Le prototype de rappel est un </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rappel vide</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uint8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - un pointeur stocké dans le champ userdata SDL_AudioSpec. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">courant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est un pointeur vers le tampon audio que vous souhaitez remplir avec des informations, et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la longueur du tampon audio en octets. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">required-&gt; userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : ce pointeur est passé comme premier paramètre à la fonction de rappel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OpenAudio lit ces champs à partir de la structure SDL_AudioSpec souhaitée transmise à la fonction et essaie de trouver la configuration audio qui correspond à votre désir. Comme mentionné ci-dessus, si le paramètre résultant est NULL, alors SDL est converti des paramètres sonores souhaités en paramètres d'équipement pendant la lecture.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si NULL est renvoyé, alors la SDL_AudioSpec requise est votre spécification de travail, sinon la SDL_AudioSpec résultante devient une spécification de travail et la spécification souhaitée peut être supprimée. Les données de la spécification de travail sont utilisées lors de la construction de SDL_AudioCVT pour convertir les données téléchargées au format d'équipement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OpenAudio calcule les champs de taille et de silence pour les spécifications souhaitées et résultantes. Le champ taille stocke la taille totale du tampon audio en octets, tandis que silence stocke la valeur utilisée pour représenter le silence dans le tampon audio</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le périphérique audio commence à lire le silence lorsqu'il est ouvert et doit être allumé pour la lecture en appelant SDL_PauseAudio (0) lorsque vous êtes prêt à appeler la fonction de rappel audio. </font><font style="vertical-align: inherit;">Étant donné que le pilote audio peut modifier la taille demandée du tampon audio, vous devez sélectionner les tampons de mixage locaux après avoir ouvert le périphérique audio.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_PauseAudio</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pause_on)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fonction met en pause et arrête le traitement du rappel audio. </font><font style="vertical-align: inherit;">Il doit être appelé avec pause_on = 0 après avoir ouvert le périphérique audio afin de commencer la lecture du son. </font><font style="vertical-align: inherit;">Cela vous permet d'initialiser en toute sécurité les données de la fonction de rappel après avoir ouvert l'unité audio. </font><font style="vertical-align: inherit;">Le silence sera enregistré sur l'appareil audio pendant une pause.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_PushEvent</span><span class="hljs-params">(SDL_Event *event)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une file d'attente d'événements qui est réellement utilisée comme canal de communication bidirectionnel. </font><font style="vertical-align: inherit;">Non seulement les événements peuvent être lus dans la file d'attente, mais l'utilisateur peut également y placer leurs propres événements. </font><font style="vertical-align: inherit;">Un événement est un pointeur sur la structure de l'événement que vous souhaitez mettre en file d'attente. </font><font style="vertical-align: inherit;">L'événement est copié dans la file d'attente et l'appelant peut gérer la mémoire pointée après avoir renvoyé SDL_PushEvent. </font><font style="vertical-align: inherit;">Cette fonction est orientée thread et peut être appelée en toute sécurité à partir d'autres threads. </font><font style="vertical-align: inherit;">Renvoie 0 en cas de succès ou -1 si l'événement n'a pas pu être distribué.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_WaitEvent</span><span class="hljs-params">(SDL_Event *event)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attend indéfiniment le prochain événement disponible, renvoyant 0 si une erreur s'est produite lors de l'attente des événements, 1 sinon. </font><font style="vertical-align: inherit;">Si l'événement n'est pas NULL, l'événement suivant est supprimé de la file d'attente et stocké dans cette zone.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_Quit</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Désactive tous les sous-systèmes SDL et libère les ressources qui lui sont allouées. Cela doit toujours être appelé avant de quitter.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_Surface *<span class="hljs-title">SDL_SetVideoMode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> bitsperpixel, Uint32 flags)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Réglage du mode vidéo avec la largeur, la hauteur et les bits de pixel spécifiés. À partir de SDL 1.2.10, si la largeur et la hauteur sont égales à 0, il utilisera la largeur et la hauteur du mode vidéo actuel (ou le mode bureau si le mode n'est pas défini). Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bitsperpixel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vaut 0, il est traité comme les bits d'affichage actuels par pixel. Le paramètre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le même que le champ flags de la structure SDL_Surface. Ou une combinaison des valeurs suivantes: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SWSURFACE - crée une surface vidéo dans la mémoire système. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWSURFACE - crée une surface vidéo dans la mémoire vidéo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ASYNCBLIT - permet l'utilisation de mises à jour asynchrones de la surface d'affichage. Cela ralentit généralement le travail sur les ordinateurs à processeur unique, mais peut augmenter la vitesse des systèmes SMP.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ANYFORMAT - généralement, si une surface vidéo avec les bits demandés par pixel (bpp - à partir de bits par pixel) n'est pas disponible, SDL émule la vidéo avec une surface ombrée. Passer SDL_ANYFORMAT empêche cela et force le SDL à utiliser la surface de la vidéo, quelle que soit sa profondeur en pixels. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWPALETTE - Fournit un accès exclusif SDL à la palette. Sans cet indicateur, vous ne pouvez pas toujours obtenir les couleurs que vous demandez à l'aide de SDL_SetColors ou SDL_SetPalette.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_DOUBLEBUF - active le double tampon matériel; valable uniquement avec SDL_HWSURFACE. Un appel à SDL_Flip inversera les tampons et rafraîchira l'écran. Tout le dessin aura lieu sur une surface qui n'est pas actuellement affichée. Si la double mise en mémoire tampon ne peut pas être activée, alors SDL_Flip exécutera simplement SDL_UpdateRect en plein écran. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_FULLSCREEN SDL - essayez d'utiliser le mode plein écran. Si la modification de la résolution matérielle n'est pas possible (pour une raison quelconque), la résolution supérieure suivante sera utilisée et la fenêtre d'affichage sera centrée sur un fond noir. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGL - crée un contexte de rendu OpenGL. Il est supposé que les attributs vidéo OpenGL avec SDL_GL_SetAttribute sont prédéfinis.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGLBLIT - crée un contexte de rendu OpenGL, comme décrit ci-dessus, mais autorise les opérations de blitting normales. Une surface d'écran (2D) peut avoir un canal alpha et SDL_UpdateRects doit être utilisé pour mettre à jour les changements de surface d'écran. REMARQUE. Cette option est enregistrée uniquement pour des raisons de compatibilité et sera supprimée dans les futures versions. Non recommandé pour une utilisation dans un nouveau code. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_RESIZABL -créer une fenêtre redimensionnable. Lorsque la taille de la fenêtre est modifiée par l'utilisateur, l'événement SDL_VIDEORESIZE est généré et SDL_SetVideoMode peut être appelé à nouveau avec une nouvelle taille. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_NOFRAME Si possible, SDL_NOFRAME force SDL à créer une fenêtre sans titre ni encadrée. Ce drapeau est automatiquement défini en mode plein écran.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remarque. Peu importe quels indicateurs SDL_SetVideoMode peuvent satisfaire, ils sont définis dans l'élément flags de la surface renvoyée. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
REMARQUE. Le pixel bit 24 utilise une représentation compactée de 3 octets par pixel. Pour le mode 4 octets par pixel le plus courant, utilisez un pixel 32 bits. Curieusement, 15 et 16 demanderont un mode 2 octets par pixel, mais avec des formats de pixels différents.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
REMARQUE. Utilisez SDL_SWSURFACE si vous prévoyez d'effectuer des manipulations de pixels distinctes ou de faire glisser des surfaces à l'aide de canaux alpha et que vous avez besoin d'une fréquence d'images élevée. Lorsque vous utilisez des surfaces matérielles (SDL_HWSURFACE), le SDL copie les surfaces de la mémoire vidéo dans la mémoire système lorsque vous les verrouillez et inversement lorsque vous les déverrouillez. Cela peut entraîner une baisse significative des performances. (Gardez à l'esprit que vous pouvez rechercher une surface matérielle mais toujours obtenir une surface logicielle. De nombreuses plates-formes ne peuvent fournir une surface matérielle que lorsque vous utilisez SDL_FULLSCREEN.) SDL_HWSURFACE est mieux utilisé lorsque les surfaces que vous clignoterez peuvent également être stockées dans la mémoire vidéo.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
REMARQUE. </font><font style="vertical-align: inherit;">Si vous souhaitez contrôler la position sur l'écran lors de la création de la surface de la fenêtre, vous pouvez le faire en définissant les variables d'environnement «SDL_VIDEO_CENTERED = center» ou «SDL_VIDEO_WINDOW_POS = x, y». </font><font style="vertical-align: inherit;">Vous pouvez les installer via SDL_putenv. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valeur de retour:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> surface du tampon de trame ou NULL en cas d'échec. </font><font style="vertical-align: inherit;">La surface retournée est libérée par SDL_Quit et ne doit pas être libérée par l'appelant. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
REMARQUE. </font><font style="vertical-align: inherit;">Cette règle inclut les appels consécutifs à SDL_SetVideoMode (c'est-à-dire le redimensionnement) - la surface existante sera libérée automatiquement.</font></font><a name="data"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annexe 2. Structures de données </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Annexe 1. Liste des fonctions"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Vers la table des matières"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Références"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<br>
<pre><code class="cpp hljs">AVCodecContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toutes les informations sur le codec du flux, de AVStream-&gt; codec. Quelques attributs importants: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : nombre d'images par seconde </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sample_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : échantillons par seconde </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : nombre de canaux </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voir la liste complète (très impressionnante) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://web.archive.org/web/20090410064257/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archives web, car le lien d'origine est déjà inexistant</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). De nombreux paramètres sont utilisés principalement pour le codage, pas pour le décodage.</font></font><br>
<br>
<pre><code class="cpp hljs">AVFormatContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Champs de données: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
const </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVClass</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_class </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVInputFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iformat </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVOutputFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oformat </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">priv_data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ByteIOContext </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : utilisé pour la manipulation de fichiers de bas niveau. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned int nb_streams</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : nombre de threads dans le fichier. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flux AVStream * [MAX_STREAMS]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : les données de chaque flux sont stockées ici. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char nom de fichier [1024]:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mais qu'en est-il sans (dans l'original - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duh</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Informations sur le fichier: </font><b><font style="vertical-align: inherit;">horodatage</font></b></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
int64_t </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">
char </font><b><font style="vertical-align: inherit;">title</font></b><font style="vertical-align: inherit;"> [512]:</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ombles </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auteur</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
omble chevalier </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">droit d' </font><font style="vertical-align: inherit;">auteur</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
omble chevalier </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commentaire</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ombles </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">album</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">année</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">piste</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ombles </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [32]: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ctx_flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Les </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
valeurs possibles sont AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS, AVFMT_RAWPICTURE, AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_GENERIC_INDEX </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacketList</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_buffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : ce tampon est nécessaire uniquement lorsque les paquets sont déjà tamponnés mais non décodés, par exemple, pour recevoir les paramètres du codec dans les flux mpeg. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int64_t</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start_time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : lors du décodage: la position de la première trame du composant, en fractions de seconde, AV_TIME_BASE. Ne définissez JAMAIS cette valeur directement: elle est déduite des valeurs d'AVStream. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t durée: décodage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : durée du flux, en fractions d'AV_TIME_BASE. Ne définissez JAMAIS cette valeur directement: elle est déduite des valeurs d'AVStream. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t file_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : taille totale du fichier, 0 si inconnu. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int bit_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : decoding: débit binaire total du flux en bit / s, 0 s'il n'est pas disponible. NE le définissez JAMAIS directement si file_size et la durée connue dans ffmpeg peuvent le calculer automatiquement. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVStream * cur_st </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const uint8_t * cur_ptr </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int cur_len </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacket cur_pkt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t data_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int index_built</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : décalage du premier paquet. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int mux_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int packet_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int preload</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int loop_output</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : nombre de boucles de sortie dans les formats pris en charge. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drapeaux int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int loop_input</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned int probesize</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : décodage: taille des données de l'échantillon; non utilisé dans le codage. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_analyze_duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : durée maximale en unités de AV_TIME_BASE pendant laquelle les données d'entrée doivent être analysées dans av_find_stream_info () </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const uint8_t * clé</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int keylen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVIOContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contexte d'E / S pour accéder aux ressources. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const AVClass * av_class</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : classe pour les paramètres privés. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * buffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : début du tampon. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int buffer_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : taille maximale du tampon. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * buf_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : position actuelle dans le tampon. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * buf_end</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Les données peuvent être plus petites que buffer + buffer_size si la fonction de lecture a retourné moins de données que demandé, par exemple. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * opaque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : pointeur privé passé à read / write / search / ... </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* read_packet) (void * opaque, uint8_t * buf, int buf_size)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* write_packet) (void * opaque, uint8_t * buf, int buf_size )</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t (* cherche) (void * opaque, int64_t offset, int d'où)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : position dans le fichier du tampon courant. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int must_flush</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : true si la prochaine recherche doit être réinitialisée. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int eof_reached</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : true si la fin du fichier est atteinte. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int write_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : true si ouvert pour l'écriture. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_packet_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned long checksum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * checksum_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned long (* update_checksum) (unsigned long checksum, const uint8_t * buf, unsigned int size)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int error</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : contient le code d'erreur ou 0 si aucune erreur ne s'est produite. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* read_pause) (void * opaque, int pause)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: mettre en pause ou reprendre la lecture pour les protocoles de streaming réseau, par exemple. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t (* read_seek) (void * opaque, int stream_index, int64_t timestamp, int flags)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : recherchez l'horodatage spécifié dans le flux avec l'index stream_index spécifié. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int recherche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : combinaison des drapeaux AVIO_SEEKABLE_ ou 0 lorsque le flux n'est pas consultable. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t maxsize</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : taille maximale du fichier utilisée pour limiter la sélection. Ce champ est interne à libavformat et son accès depuis l'extérieur est interdit. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int direct</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : avio_read et avio_write doivent être exécutés directement dans la mesure du possible, et ne pas passer par le tampon, et avio_seek appellera toujours directement la fonction de recherche principale. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t bytes_read</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: statistiques de lecture d'octets Ce champ est interne à libavformat et l'accès externe est refusé. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int seek_count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : statistiques de recherche. </font><font style="vertical-align: inherit;">Ce champ est interne à libavformat et son accès depuis l'extérieur est interdit. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int writeout_count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : écrire des statistiques. </font><font style="vertical-align: inherit;">Ce champ est interne à libavformat et son accès depuis l'extérieur est interdit. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int orig_buffer_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la taille du tampon d'origine utilisée en interne après vérification et retour pour réinitialiser la taille du tampon. </font><font style="vertical-align: inherit;">Ce champ est interne à libavformat et son accès depuis l'extérieur est interdit.</font></font><br>
<br>
<pre><code class="cpp hljs">AVDictionary</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilisé pour passer des paramètres à ffmpeg. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombre </font></font></b><font style="vertical-align: inherit;"></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entier</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">AVDictionaryEntry * elems</font></b><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVDictionaryEntry</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilisé pour stocker les entrées du dictionnaire dans AVDictionary. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char * ket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char * valeur</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVFrame</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette structure dépend du type de codec et est donc déterminée dynamiquement. Cependant, il existe des propriétés et des méthodes communes pour cette structure: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * data [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int linesize [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : information stride. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * base [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int key_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int pict_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : ce ne sont pas les pts attendus lors du décodage. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int coded_picture_number</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int display_picture_number</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int qualité</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int age</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int référence</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int8_t * qscale_table</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int qstride</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * mbskip_table</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int16_t (* motion_val [2]) [2]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint32_t * mb_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t motion_subsample_log2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * opaque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : données utilisateur </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint64_t erreur [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int repeat_pict</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : vous demande de répéter l'image un nombre spécifié de fois. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int qscale_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int interlaced_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int top_field_first</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPanScan * pan_scan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int palette_has_changed</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int buffer_hints</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">short * dct_coeff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int8_t * ref_index [2]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVPacket</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Structure dans laquelle les données brutes des paquets sont stockées. Ces données doivent être transférées vers avcodec_decode_audio2 ou avcodec_decode_video pour recevoir une trame. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : horodatage de présentation en unités de base de temps. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t dts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : horodatage de la décompression en unités de time_base. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : données brutes. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : taille des données. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int stream_index</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : flux dont AVPacket est issu, basé sur la quantité dans AVFormatContext. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drapeaux int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : PKT_FLAG_KEY est défini si le paquet est une image clé. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : durée de la présentation en unités de time_base (0 si non disponible)</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void (* destruct) (struct AVPacket *)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : fonction de libération des ressources pour ce package (av_destruct_packet par défaut). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * priv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : position d'octet dans le flux, -1 si inconnu.</font></font><br>
<br>
<pre><code class="cpp hljs">AVPacketList</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une simple liste chaînée pour les packages. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacket pkt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacketList * suivant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVPicture</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette structure est exactement la même que les deux premiers éléments de données AVFrame, elle est donc souvent supprimée. </font><font style="vertical-align: inherit;">Couramment utilisé dans les fonctions SWS. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * data [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int linesize [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : le nombre d'octets dans la chaîne.</font></font><br>
<br>
<pre><code class="cpp hljs">AVRational</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Structure simple pour représenter des nombres rationnels. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int num</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : numérateur. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int den</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : dénominateur.</font></font><br>
<br>
<pre><code class="cpp hljs">AVStream</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La structure du flux. Vous utiliserez probablement ces informations dans le codec le plus souvent. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int index</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int id</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecContext * codec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational r_frame_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * priv_data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t codec_info_duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int codec_info_nb_frames</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFrac pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int pts_wrap_bits</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int stream_copy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un disque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne peut pas </font><b><font style="vertical-align: inherit;">ignorer</font></b><font style="vertical-align: inherit;"> le paquet en démultiplexage. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">float quality</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t start_time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langue Char [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int need_parsing</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 1 -&gt; besoin parsing complète, 2 -&gt; parse têtes uniquement, sans remballer </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecParserContext * analyseur</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t cur_dts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int last_IP_duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t last_IP_pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVIndexEntry * index_entries</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int nb_index_entries</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un unsigned int index_entries_allocated_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t nb_frames</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : nombre de trames dans ce flux (si connu) ou 0 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pts_buffer [MAX_REORDER_DELAY + 1]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">ByteIOContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une structure qui stocke des informations de bas niveau sur un fichier vidéo. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * buffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int buffer_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * buf_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * buf_end</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * opaque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* read_packet) (void * opaque, uint8_t * buf, int buf_size)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* write_packet) (void * opaque, uint8_t * buf, int buf_size)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offset_t (* cherche) (void * opaque, offset_t offset, int d'où)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offset_t pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int must_flush</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int eof_reached</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int write_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int is_streamed</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_packet_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned long checksum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * checksum_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned long (* update_checksum) (unsigned long checksum: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
const uint8_t * buf, unsigned int size)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int error</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : contient le code d'erreur ou 0 si aucune erreur ne s'est produite.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_AudioSpec</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilisé pour décrire le format de certaines données audio. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : fréquence sonore en échantillons par seconde. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">format</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">format</font></b><font style="vertical-align: inherit;"> de données audio. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canaux</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : nombre de canaux: 1 - mono, 2 - stéréo, 4 surround, 6 surround avec centrage et </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">silence</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LFE </font><font style="vertical-align: inherit;">: valeur de </font><b><font style="vertical-align: inherit;">silence</font></b><font style="vertical-align: inherit;"> du tampon sonore (calculée). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">samples</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : taille du buffer audio dans les samples. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">taille</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la taille du tampon audio en octets (calculée). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">callback (..)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : fonction de rappel pour remplir le buffer audio. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : un pointeur vers les données utilisateur qui sont passées à la fonction de rappel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les valeurs de format suivantes sont </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
valides </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">AUDIO_U8 - ​​Échantillons non signés 8 bits.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S8 - échantillons 8 bits signés. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_U16 ou AUDIO_U16LSB - non pris en charge par tout le matériel (ordre des octets faibles 16 bits non signé). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S16 ou AUDIO_S16LS - non pris en charge par tous les matériels (16 bits avec ancien ordre d'octets) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_U16MSB - non pris en charge par tous les matériels (big-endian 16 bits non signé). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S16MS - non pris en charge par tout le matériel (16 bits avec ordre d'octets élevé). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_U16SYS: AUDIO_U16LSB ou AUDIO_U16MSB - selon le processeur matériel. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S16SYS: AUDIO_S16LSB ou AUDIO_S16MSB - selon le processeur matériel.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Event</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La structure de base pour les événements. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : type d'événement. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">active</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : événement d'activation (voir SDL_ActiveEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">key</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : événement clavier (voir SDL_KeyboardEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">motion</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : événement de mouvement de la souris (voir SDL_MouseMotionEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bouton</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : événement de clic de souris (voir SDL_MouseButtonEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jaxis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : événement de mouvement de l'axe du joystick (voir SDL_JoyAxisEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jball</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : événement de mouvement du joystick trackball (voir SDL_JoyBallEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jhat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : événement de déplacement de l'en-tête du joystick (voir SDL_JoyHatEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jbutton</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : événement d'appuyer sur le bouton du joystick (voir SDL_JoyButtonEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redimensionner</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Événement de redimensionnement de la fenêtre d'application (voir SDL_ResizeEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expose</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : événement d'ouverture de fenêtre d'application (voir SDL_ExposeEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : événement de demande de sortie d'application (voir SDL_QuitEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">user</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : événement utilisateur (voir SDL_UserEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syswm</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : événement de gestionnaire de fenêtres non défini (voir SDL_SysWMEvent). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici les types d'événements. Voir la documentation SDL pour plus d'informations: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ACTIVEEVENT SDL_ActiveEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_KEYDOWN / the UP SDL_KeyboardEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_MOUSEMOTION SDL_MouseMotionEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_MOUSEBUTTONDOWN / UP </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UPLLMouseButtonEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JOYAXISMOTION SDL_JoyAJOEL_JO</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JoyHatEvent SDL_JOYHATMOTION </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JOYBUTTONDOWN / the UP SDL_JoyButtonEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_VIDEORESIZE </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ResizeEvent SDL_VIDEOEXPOSE </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ExposeEvent SDL_Quit </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_QuitEvent SDL_USEREVENT </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_USEREVS SDL_USERES</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Overlay</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Superposition YUV. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">format</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">format de</font></b><font style="vertical-align: inherit;"> superposition (voir ci-dessous). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w, h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : largeur / hauteur de la superposition. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plans</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : le nombre de plans à superposer. Habituellement, soit 1 ou 3. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emplacements</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : un tableau de retraits, un pour chaque plan. L'indentation est la longueur de la chaîne en octets. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixels</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : un tableau de pointeurs de données pour chaque plan. La superposition doit être verrouillée avant d'utiliser ces pointeurs. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hw_overlay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : défini sur 1 si la superposition est accélérée par le matériel.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Rect</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La zone rectangulaire. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sint16 x, y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : position du coin supérieur gauche du rectangle. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uint16 w, h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la largeur et la hauteur du rectangle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_Rect définit une zone rectangulaire de pixels. Il est utilisé par SDL_BlitSurface pour identifier les zones de blitting et certaines autres fonctionnalités vidéo.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Surface</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Structure graphique du côté extérieur (surface). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uint32 drapeaux</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Drapeaux des stotrons externes. Uniquement pour la lecture. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Format SDL_PixelFormat *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : lecture seule. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int w, h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : largeur et hauteur. Uniquement pour la lecture. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pas Uint16</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : pas. Uniquement pour la lecture. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * pixels</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : un pointeur sur les données réelles des pixels. Pour l'enregistrement uniquement. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Rect clip_rect</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : l'extérieur rectangulaire du clip. Uniquement pour la lecture. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int refcount</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : utilisé pour allouer de la mémoire. Surtout pour la lecture. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette structure contient également des champs privés non représentés ici.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_Surface représente une zone de mémoire "graphique" qui peut être dessinée. La trame de tampon vidéo est renvoyée en tant que SDL_Surface à l'aide de SDL_SetVideoMode et SDL_GetVideoSurface. Les champs w et h sont des valeurs représentant la largeur et la hauteur de la surface en pixels. Le champ de pixels est un pointeur vers les données de pixels réelles. Remarque: la surface doit être verrouillée (via SDL_LockSurface) avant d'accéder à ce champ. Le champ clip_rect est le rectangle découpé défini par SDL_SetClipRect. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le champ indicateur prend en charge les valeurs OR suivantes: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SWSURFACE - l'extérieur est stocké dans la mémoire système. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWSURFACE - Le côté externe est stocké dans la mémoire vidéo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ASYNCBLIT - L'extérieur utilise l'éblouissement asynchrone, si possible.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ANYFORMAT - Tout format de pixel (surface d'affichage) est autorisé. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWPALETTE - La surface a une palette exclusive. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_DOUBLEBUF - surface à double tampon (surface d'affichage). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_FULLSCREEN - surface plein écran (surface d'affichage). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGL - la surface a un contexte OpenGL (surface d'affichage). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGLBLIT - la surface prend en charge le blining OpenGL (surface d'affichage). REMARQUE. Cette option est uniquement pour la compatibilité et n'est pas recommandée pour le nouveau code. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_RESIZABLE - le redimensionnement est possible pour une surface (surface d'affichage). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWACCEL - le blit de surface utilise l'accélération matérielle. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SRCCOLORKEY - La superficialité utilise le mélange des couleurs.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_RLEACCEL - le dégradé des couleurs est accéléré à l'aide de RLE. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SRCALPHA - Surface Blyth utilise le mélange alpha. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_PREALLOC - La surface utilise de la mémoire pré-allouée.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Thread</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette structure est indépendante du système et vous n'avez probablement pas besoin de l'utiliser. </font><font style="vertical-align: inherit;">Voir src / thread / sdl_thread_c.h dans le code source pour plus d'informations.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_cond</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette structure est indépendante du système et vous n'avez probablement pas besoin de l'utiliser. </font><font style="vertical-align: inherit;">Voir src / thread / &lt;system&gt; /SDL_syscond.c dans le code source pour plus d'informations.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_mutex</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette structure est indépendante du système et vous n'avez probablement pas besoin de l'utiliser. </font><font style="vertical-align: inherit;">Voir src / thread / &lt;system&gt; /SDL_sysmutex.c dans le code source pour plus d'informations.</font></font><a name="links"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liens </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Annexe 2. Structures de données"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Vers la table des matières"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑</font></font></a></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img width="122" height="30" src="https://habrastorage.org/webt/ts/cs/ro/tscsrofdmymu7o1rbml2evolway.png"></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un didacticiel FFmpeg et SDL ou comment écrire un </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lecteur </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">vidéo en moins de 1 000 lignes </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">FFmpeg</font></a><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">FFmpeg HomePage </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">SDL HomePage</font></a></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img width="122" height="30" src="https://habrastorage.org/webt/z0/e1/6o/z0e16ozcekig9i8jdthljdqpgga.png"></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img width="60" height="30" src="https://habrastorage.org/webt/js/4n/23/js4n231ba7glkow_nud5i3dsveq.png"> </a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<hr><hr><hr><hr><hr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img align="right" width="420" height="125" src="https://habrastorage.org/webt/co/i3/m0/coi3m0tliby9r5uxtiydjoeaqkm.png"></a><br clear="left">
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A lire également sur le blog de la société EDISON:</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg libav manual</font></font></b></a><br></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr502834/index.html">Comment devenir ingénieur DevOps en six mois ou plus vite. Partie 5. Déploiement</a></li>
<li><a href="../fr502836/index.html">Unity Editor Adventures: Matriochka sérialisé</a></li>
<li><a href="../fr502838/index.html">Quelle est la différence entre les métiers de l'informatique et du numérique: transformation numérique et avis d'experts</a></li>
<li><a href="../fr502840/index.html">Test du scanner 3D Shin 3D EinScan Pro 2X Plus</a></li>
<li><a href="../fr502842/index.html">Comment protéger les données biométriques des utilisateurs contre une utilisation criminelle</a></li>
<li><a href="../fr502846/index.html">Zuckerberg a lancé Shops. Instagram et Facebook deviennent progressivement des magasins.</a></li>
<li><a href="../fr502852/index.html">Pourquoi les gens résistent-ils au changement et comment peuvent-ils les aider à reconstruire</a></li>
<li><a href="../fr502854/index.html">Pourquoi les implémentations ERP échouent-elles?</a></li>
<li><a href="../fr502860/index.html">Transports le 20 mai: une reprise rapide de l'aviation est visible</a></li>
<li><a href="../fr502862/index.html">LabVIEW NXG - Principes de base du panneau avant - Commandes et indicateurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>