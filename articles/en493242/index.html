<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚û°Ô∏è ‚§µÔ∏è ‚≠ïÔ∏è HTTP String Fast Processing Algorithms üêò üëá üçó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Compression of standard headers has appeared in HTTP / 2, but the body of the URI, Cookie, User-Agent values ‚Äã‚Äãcan still be tens of kilobytes and requ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>HTTP String Fast Processing Algorithms</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/493242/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compression of standard headers has appeared in HTTP / 2, but the body of the URI, Cookie, User-Agent values ‚Äã‚Äãcan still be tens of kilobytes and require tokenization, search and comparison of substrings. </font><font style="vertical-align: inherit;">The task becomes critical if an HTTP parser needs to handle heavy malicious traffic. </font><font style="vertical-align: inherit;">Standard libraries provide extensive string processing tools, but HTTP strings have their own specifics. </font><font style="vertical-align: inherit;">It is for this specificity that the Tempesta FW HTTP parser was developed. </font><font style="vertical-align: inherit;">Its performance is several times higher compared to modern Open Source solutions and surpasses the fastest of them.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GcAJF4648JI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Krizhanovsky</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">krizhanovsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) founder and system architect Tempesta Technologies, an expert in high performance computing in Linux / x86-64. Alexander will talk about the peculiarities of the structure of HTTP strings, explain why standard libraries are poorly suited for processing them, and present the Tempesta FW solution. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Under the cat: how does HTTP Flood turn your HTTP parser into a bottleneck, x86-64 problems with branch mispredictions, caching and out-of-memory memory on typical HTTP parser tasks, comparing FSM with direct jumps, GCC optimization, auto-vectorization, strspn () - and strcasecmp () - like algorithms for HTTP strings, SSE, AVX2 and filtering injection attacks using AVX2.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At Tempesta Technologies we develop custom software: we specialize in complex areas related to high performance. </font><font style="vertical-align: inherit;">We are especially proud of the development of the core of Positive Technologies' first version WAF. </font><font style="vertical-align: inherit;">Web Application Firewall (WAF) is an HTTP proxy: it deals with a very deep analysis of HTTP traffic for attacks (Web and DDoS). </font><font style="vertical-align: inherit;">We wrote the first core for it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to consulting, we are developing </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - this is Application Delivery Controller (ADC). </font><font style="vertical-align: inherit;">We‚Äôll talk about him.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application Delivery Controller</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Application Delivery Controller is an HTTP proxy with enhanced functionality. </font><font style="vertical-align: inherit;">But I‚Äôll talk about a feature that is related to security - about filtering DDoS and Web attacks. </font><font style="vertical-align: inherit;">I‚Äôll also mention the limitations, and I‚Äôll show the work and functions with code examples.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mg/gf/tw/mggftw9mux_ycaxzjbfqe6hpdc0.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta FW is built into the Linux TCP / IP Stack kernel. </font><font style="vertical-align: inherit;">Thanks to this and a number of other optimizations, it is very fast - it can process 1.8 million requests per second on cheap hardware. </font><font style="vertical-align: inherit;">This is 3 times faster than Nginx at the top load and is also fast when compared with </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kernel bypass approach. </font></font></strong><br>
<br>
<img src="https://habrastorage.org/webt/te/md/pe/temdpec1gcgnm98ktgwr4gewn-8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On a small number of cores, it shows similar performance with the Seastar project, which is used in ScyllaDB (written in DPDK).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The project was born when we started working on PT AF - in 2013. </font><font style="vertical-align: inherit;">This WAF was based on one popular Open Source HTTP accelerator. </font><font style="vertical-align: inherit;">Nginx, HAProxy, Varnish or Apache Traffic are good HTTP accelerators: they deliver content fine, cache, modify, but none of them </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are designed for massive traffic processing and filtering</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, we thought that if there is a network-level firewall, why not continue this idea and integrate into the TCP / IP stack as an application-level firewall? </font><font style="vertical-align: inherit;">Actually, it turned out Tempesta FW - a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hybrid of HTTP accelerator and firewall</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: Nginx will be used as an example in the report because it is a simple and popular web server. </font><font style="vertical-align: inherit;">Instead, there could be any other Open Source HTTP server.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at our </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP request</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (HTTP / (1, ~ 2)) </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_o/3z/tq/_o3ztqvtwrv-7epdryhdztg8wsq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can have a very large URI. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separators</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that are important at the time of HTTP parsing </font><font style="vertical-align: inherit;">are highlighted in red bold </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">I will highlight the features: large strings of several kilobytes, as well as different delimiters, for example, additional "semicolons" that we need to parse, or the sequence "\ r \ n". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A little bit about HTTP / 2 also needs to be said.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2 Features</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2 is a mixture of strings and binary data</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This mix is ‚Äã‚Äãmore about optimizing the bandwidth of a connection than saving server resources. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2 in HPACK uses a dynamic table</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The first request from the client is not optimized, it is not in the table. You must parse it so that it is added to the table. If HTTP / 2 DDoS comes to you, this will be just the case. In the normal case, HTTP / 2 is a binary protocol, but you still need to parse text: text header names, data. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman encoding</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is a simple encoding, but Huffman is monstrously hard to program quickly for compression: Huffman encoding crosses the byte boundary, you cannot use vector extensions and you need to go by bytes. </font><font style="vertical-align: inherit;">You will not be able to quickly process data in 32 or 16 bytes. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cookies, User-Agent, Referer, URIs can be very large</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">First, remove Huffman, then send it to a regular HTTP parser, the same as in HTTP / 1. </font><font style="vertical-align: inherit;">Although it is allowed by the RFC, cookies are not recommended to be compressed, because this is confidential data - you should not give the attacker information about their size. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slow HTTP processing</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">All HTTP servers first decode HTTP / 2 and then send these lines to the HTTP / 1 parser that HTTP / 1 already uses. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is the problem with HTTP / 1 parsing?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You need to quickly program the state machine.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You need to quickly process consecutive lines.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malicious traffic targets the slowest (weakest) part of the process. </font><font style="vertical-align: inherit;">Therefore, if we want to make a filter, we must pay attention to the slow parts so that they also work quickly.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx profile</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at the nginx profile under the HTTP flood. </font><font style="vertical-align: inherit;">Disable access log so that the file system does not slow down. </font><font style="vertical-align: inherit;">When even a regular index page is requested, the parser goes up at the top.</font></font><br>
<div class="scrollable-table"><table>
<tbody>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">symbol name</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,5719</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_parse_header_line</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,0303</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_vslprintf</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.6401</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.5807</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recv</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.5156</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_linux_sendfile_chain</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.4990</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_limit_req_handler</font></font></td>
</tr>
</tbody>
</table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Left - "Flat profile". </font><font style="vertical-align: inherit;">Interestingly, the hottest spot in it is not much heavier than the next, and after it the profile descends smoothly. </font><font style="vertical-align: inherit;">This means, for example, that optimizing the first function twice will not help to significantly improve performance. </font><font style="vertical-align: inherit;">That is why we did not optimize the same Nginx, but made a new project that will improve the performance of the entire tail of the profile.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How regular HTTP parsers are encoded</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usually we have a loop ( </font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) that runs along the line, and two variables: state ( </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and current data ( </font></font><code>str_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We enter the cycle (1) and look at the current state (check state). We pass to the received data (symbol </font></font><code><em>'b'</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and implement some logic. We pass to the second state (2). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hi/z7/s2/hiz7s2e3yw5bpqqz-qbir5hbteq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go to the end </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3) - this is the second transition relative to the beginning of our code and, possibly, the second miss in the instruction cache. Then we go to the beginning </font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4), eat the next character ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/zs/17/gkzs17hdxtyfcaife8j1pms7wbi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... and again look for the state in the instructions inside </font></font><code>case 2:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When a variable has already been assigned a </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value</font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we could just go to the next instruction. </font><font style="vertical-align: inherit;">But instead, they went up again and went down again. </font><font style="vertical-align: inherit;">We ‚Äúcut circles‚Äù by code instead of just going down. </font><font style="vertical-align: inherit;">Normal parsers do not, for example, Ragel generates a parser with direct transitions.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mc/ba/3w/mcba3wgxqkflqjvq1mxytcy_kwo.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx HTTP Parser</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A few words about the nginx parser and its environment. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx works with the normal socket API</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the data that goes to the adapter is copied to user space. </font><font style="vertical-align: inherit;">As a result, we have a large data chunk in which we are looking for what we need. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx uses an algorithm that works in two passes: first it searches for length, then it checks. </font><font style="vertical-align: inherit;">In the first step, he scans the string for tokens, searches for the first token (‚Äútrial‚Äù). </font><font style="vertical-align: inherit;">On the second, it tokens, checks the end of the request ( </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and starts </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, according to the size of the token.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (p = b-&gt;pos; p &lt; b-&gt;last; p++) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">switch</span> (state) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">case</span> sw_method:
        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">' '</span>) {<font></font>
            m = r-&gt;request_start;<font></font>
            <span class="hljs-keyword">switch</span> (p - m) {         <span class="hljs-comment">// switch on token length!</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                <span class="hljs-keyword">if</span> (ngx_str3_cmp(m, <span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)) {<font></font>
                ...<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> ((ch &lt; <span class="hljs-string">'A'</span> || ch &gt; <span class="hljs-string">'Z'</span>) &amp;&amp; ch != <span class="hljs-string">'_'</span> &amp;&amp; ch != <span class="hljs-string">'-'</span>)
                <span class="hljs-keyword">return</span> NGX_HTTP_PARSE_INVALID_METHOD;
            <span class="hljs-keyword">break</span>;<font></font>
    ...</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúGet‚Äù is always in the same data chunk</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tempesta FW works with zero-copy. </font><font style="vertical-align: inherit;">This means that data can come with a completely arbitrary size: 1 byte or 1000 bytes each. </font><font style="vertical-align: inherit;">This "mechanism" does not suit us. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see how it works </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in GCC.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gcc</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lookup table</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . On the left is a typical example of enum: start with 0, then consecutive labels, 26 constants, and then some code that processes it all. On the right is the code that the compiler generates. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ac/1n/hh/ac1nhhz9jqe87hdqb6bxfv541vu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, compare the variable </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the EAX register with a constant. Next, we present all the labels in the form of a sequential array of pointers of 8 bytes (lookup table). On this instruction we pass on offset in this array - it is double dereferencing of pointers. Bottom right is the code that we switched to from this table. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It turns out double dereferencing of memory: if we received secret data, then by bytes we find the address in the array and go to this pointer. It is important to know that in life it is still worse than in the example - for lookup table the compiler </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generates</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the code is more complicated in the case of a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">script</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for a Specter attack. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binary search</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The next case is </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not with sequential constants, but with arbitrary ones. The code is the same, but now GCC cannot compile such a large array and use constants as the index of the array. He switches to binary search. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/mo/7p/asmo7pb4lxsv7pchnafv-qjz7u4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the right we see a sequential comparison, the transition to the address and the continuation of the comparison - the binary search is by code. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx HTTP parser.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's see what state machine nginx is. It has 9 kilobytes of code - this is three times less than the first level cache on the machine on which the benchmarks were launched (as on most x86-64 processors).</font></font><br>
<br>
<pre><code class="bash hljs">$ nm -S /opt/nginx-1.11.5/sbin/nginx<font></font>
| grep http_parse | cut -d<span class="hljs-string">' '</span> -f 2<font></font>
| perl -le <span class="hljs-string">'$a += hex($_) while (&lt;&gt;); print $a'</span><font></font>
9220<font></font>
<font></font>
$ getconf LEVEL1_ICACHE_SIZE<font></font>
32768<font></font>
<font></font>
$ grep -c <span class="hljs-string">'case sw_'</span> src/http/ngx_http_parse.c<font></font>
84</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The nginx header parser </font></font><code>ngx_http_parse_header_line ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a simple tokenizer. </font><font style="vertical-align: inherit;">It does nothing with the values ‚Äã‚Äãof the headers and their names, but simply puts the tokens of the HTTP headers into a hash. </font><font style="vertical-align: inherit;">If you need any header value, scan the header table and repeat the analysis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We must </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strictly check the names and values ‚Äã‚Äãof the headers</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for security reasons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></strong><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW: string validation of HTTP strings</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our state machine is an order of magnitude more powerful: we do RFC header validation and immediately, in the parser, process almost everything. </font><font style="vertical-align: inherit;">If nginx has 80 states, then we have 520, and there are more of them. </font><font style="vertical-align: inherit;">If we drove on </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then it would be 10 times larger. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zero-copy I / O</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - chunks of different sizes can cut data in different places. </font><font style="vertical-align: inherit;">different chunks can cut our data. </font><font style="vertical-align: inherit;">In zero-copy I / O, for example, ‚ÄúGET‚Äù can (rarely) occur as ‚ÄúGET‚Äù, ‚ÄúGE‚Äù and ‚ÄúT‚Äù or ‚ÄúG‚Äù, ‚ÄúE‚Äù and ‚ÄúT‚Äù, so you need to store the state between pieces of data . </font><font style="vertical-align: inherit;">We practically remove the costs of I / O, but in the profile it flies up - everything is bad. </font><font style="vertical-align: inherit;">The large HTTP parser is one of the most critical places in the project.</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -c <span class="hljs-string">'__FSM_STATE\|__FSM_TX\|__FSM_METH_MOVE\|__TFW_HTTP_PARSE_'</span> http_parser.c<font></font>
520<font></font>
    7.64% [tempesta_fw]     [k] tfw_http_parse_req<font></font>
    2.79% [e1000]           [k] e1000_xmit_frame<font></font>
    2.32% [tempesta_fw]     [k] __tfw_strspn_simd<font></font>
    2.31% [tempesta_fw]     [k] __tfw_http_msg_add_str_data<font></font>
    1.60% [tempesta_fw]     [k] __new_pgfrag<font></font>
    1.58% [kernel]          [k] skb_release_data<font></font>
    1.55% [tempesta_fw]     [k] __str_grow_tree<font></font>
    1.41% [kernel]          [k] __inet_lookup_established<font></font>
    1.35% [tempesta_fw]     [k] tfw_cache_do_action<font></font>
    1.35% [tempesta_fw]     [k] __tfw_strcmpspn</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What to do to improve this situation?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSM Direct Referrals</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first thing we do is </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use not a loop, but direct transitions by labels ( </font></font></strong><code>go to</code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Normal parser generators like Ragel do this. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bq/di/pr/bqdipr9bt6au4ifisfpvjli2p_e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We encode each of our states with a label in </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and a label in C with </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the same name</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Every time we want to go, we find a label in </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or access the same state directly from the code. The first time we go through </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and then inside it we go directly to the desired label. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disadvantage</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : when we want to switch to the next state, we must immediately evaluate whether we still have data available (because zero-copy I / O). Condition body</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is copied to each state: instead of one condition in a regular switch-driven FSM, we have 500 of them according to the number of states. Generating code for each state is not great. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the case of large state machines, for </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a large </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inside, GTC also repeats the condition </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">several times inside the code. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Replace with </font></font></strong><code><strong>switch</strong></code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direct transitions.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The next optimization is that we don‚Äôt use it </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and switch to direct jumps to the saved meta addresses. We want to immediately go to the desired point as soon as we enter the function. GCC allows you to do this. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i3/x5/7m/i3x57mb0tahhz99szccnfdbxde0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GCC has a standard extension that may help. We take the label name (here it is </font></font><code>from</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and assign its address to some C-variable via double ampersand (&amp;&amp;). Now we can make a direct jump instruction</font></font><code>jmp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the address of this label with </font></font><code>goto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see what comes of it.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direct Conversion Performance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On a small number of states, the direct transition code generator is even a little slower than normal </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But for large state machines, productivity doubles. </font><font style="vertical-align: inherit;">If the state machine is small, it is better to use the usual one </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -m 2 <span class="hljs-string">'model name\|bugs'</span> /proc/cpuinfo<font></font>
model name : Intel(R) Core(TM) i7-6500U CPU @ 2.50GHz<font></font>
bugs       : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf<font></font>
<font></font>
$ gcc --version|head -1<font></font>
gcc (GCC) 8.2.1 20181105 (Red Hat 8.2.1-5)<font></font>
<font></font>
States     Switch-driven automaton     Goto-driven automaton<font></font>
     7     header_line:      139ms     header_line:          156ms<font></font>
    27     request_line:     210ms     request_line:         186ms<font></font>
   406     big_header_line: 1406ms     goto_big_header_line: 727ms</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: Tempesta code is more complicated than the examples. </font><font style="vertical-align: inherit;">GitHub has all the </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://github.com/tempesta-tech/blog/tree/master/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benchmarks</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so you can see everything in detail. </font><font style="vertical-align: inherit;">The original parser code is available </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the link</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (main HTTP parser). </font><font style="vertical-align: inherit;">In addition to it, in Tempesta FW there are </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smaller parsers</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that use FSM easier.</font></font></em><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why direct transitions may be slower</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the state machine, we go through a lot of code, so (expected) there will be a lot of branch mispredictions. </font><font style="vertical-align: inherit;">Let's perform ‚Äúprofiling‚Äù according to branch-misses prediction:</font></font><br>
<br>
<pre><code class="bash hljs">perf record -e branch-misses -g ./http_benchmark<font></font>
406 states:    switch       - 38% on switch(),<font></font>
               direct jumps - 13% on header value parsing<font></font>
			   <font></font>
7,27 states:   switch       - &lt;18% switch(), up to 40% <span class="hljs-keyword">for</span>()<font></font>
               direct jumps ‚Äì up to 46% on header &amp; URI parsing</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On a large state machine with 406 states, we spend 38% of the time processing transitions in </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">On a state machine with direct transitions, hotspots are line parsing. </font><font style="vertical-align: inherit;">Parsing a string in each state includes checking the condition of the end of the string: the condition </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the state machine on </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="bash hljs">perf <span class="hljs-built_in">stat</span> -e L1-icache-load-misses ./http_benchmark<font></font>
<font></font>
                       Switch-driven automaton  Goto-driven automaton<font></font>
big FSM code size:                       29156                  49202<font></font>
L1-icache-load-misses:                      4M                     2M</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, let's look at the profiling of both types of state machine by events L1 instruction cache miss - almost 30 kilobytes for </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and 50 kilobytes for direct jumps (more than the cache of the first level instructions). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It seems that if we do not fit in the cache, there should be a lot of cache misses for such a state machine. </font><font style="vertical-align: inherit;">But no, they are 2 times less. </font><font style="vertical-align: inherit;">That's because the cache works better: we work with the code sequentially and manage to pull up data from the older caches.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The compiler changes the order of the code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When we program the state machine code on </font></font><code>go to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we first have the states that will be called first when the data is received: the HTTP method, URI, and then the HTTP headers. It seems logical that the code will be loaded into the processor cache sequentially, from top to bottom, just as we go through the data. But this is completely wrong. If you look at the assembler code, you will see amazing things. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tg/uf/zr/tgufzrnfusabmvn1gg9ulzjgvgo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the left is what we programmed: first we parse the methods </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then somewhere far below the unlikely method </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Therefore, we expect to see parsing </font></font><code> GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">at the beginning of the assembler </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and then </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. But everything is quite the opposite: </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the middle, </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the end, and </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">above.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is because the compiler does not understand how data comes to us. </font><font style="vertical-align: inherit;">He distributes the code according to his picture of beautiful code. </font><font style="vertical-align: inherit;">In order for him to arrange the code in the correct order, we must use the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compiler barrier</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The compiler barrier is an assembly dummy through which the compiler will not reorder. </font><font style="vertical-align: inherit;">By simply placing such barriers, we </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">improved productivity by 4%</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">STATE(sw_method) {<font></font>
    ... <span class="hljs-comment">// the most frequent states</span>
    MATCH(NGX_HTTP_GET, <span class="hljs-string">"GET "</span>);<font></font>
    MATCH(NGX_HTTP_POST, <span class="hljs-string">"POST"</span>);<font></font>
    <font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span>: : :<span class="hljs-string">"memory"</span>);<font></font>
    ... <span class="hljs-comment">// many other states</span><font></font>
    <font></font>
    <span class="hljs-comment">// Improbable states</span>
    METH_MOVE(Req_MethU, <span class="hljs-string">'N'</span>, Req_MethUn);<font></font>
    METH_MOVE(Req_MethUn, <span class="hljs-string">'L'</span>, Req_MethUnl);<font></font>
    METH_MOVE(Req_MethUnl, <span class="hljs-string">'O'</span>, Req_MethUnlo);<font></font>
    METH_MOVE(Req_MethUnlo, <span class="hljs-string">'C'</span>, Req_MethUnloc);<font></font>
    METH_MOVE_finish(Req_MethUnloc, <span class="hljs-string">'K'</span>, NGX_HTTP_UNLOCK)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compose the code in your own way</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the compiler does not arrange the data as we want, we will do </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">profiler guided optimization</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (optimization under the control of the profiler). </font><font style="vertical-align: inherit;">Profiler guided optimization (PGO) is the total number of samples, not a sequence of calls. </font><font style="vertical-align: inherit;">For example, a URI receives more samples than a method analysis, so it will position the URI processing code before processing the method.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How it works? </font><font style="vertical-align: inherit;">We‚Äôll write the code, run benchmarks on it, give the result of the profiling to the compiler, and it will generate the optimal code for our loads. </font><font style="vertical-align: inherit;">But the problem is that it simply compiles the hottest sections of code, but does not track the time dependency. </font><font style="vertical-align: inherit;">If the biggest URI in the load, then this will be the hottest place. </font><font style="vertical-align: inherit;">The URI will rise to the top of the function, and PGO will not show that the method name is always before the URI. </font><font style="vertical-align: inherit;">Accordingly, PGO does not work.</font></font><br>
<br>
<pre><code class="cpp hljs">Req_Method: {
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_Uri;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'P'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'T'</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_UriSpace;<font></font>
    }<font></font>
    <span class="hljs-keyword">goto</span> Req_Meth_SlowPath;<font></font>
}<font></font>
... <span class="hljs-comment">// other methods: POST, PUT etc.</span><font></font>
Req_Uri:<font></font>
    ... <span class="hljs-comment">// URI processing</span><font></font>
Req_Meth_SlowPath:<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What does work? </font></font><br>
<br>
<code><strong>likely</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code><strong>unlikely</strong></code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">macros</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (for Linux kernel code, GCC intrinsics are available in user space </font></font><code>__builtin_expect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). They say which code to place closer. For example, likely reports that the request body should be immediately behind </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Then prefetching the code (prefetching the processor) will select that code and everything will be fast. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7x/4u/05/7x4u057of2wmtq310wflcuyvlei.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The picture shows the beginning of the parsing method, the end and the barrier. We did not expect to see the code behind the barrier. It seems that this should not be - we have put up a barrier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But what happens in reality? The compiler sees the </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">condition - it is most likely that we will enter the body of the condition and there we will switch to an unconditional jump to the label</font></font><code>Req_Uri</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It turns out that the code that is after our condition is not processed in the "hot path". </font><font style="vertical-align: inherit;">The compiler moves the code under the label behind </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, despite the barrier, because the hot code condition is met. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To this was not, GCC has an extension: the attributes </font></font><code>hot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>cold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the labels. </font><font style="vertical-align: inherit;">They say which label is hot (most likely) and which is cold (less likely). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/ra/uh/bwrauhxesqvk_ke22cw67cqwuja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we agree on what is </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">more likely </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and leave it to him </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Under the condition, URI processing rises, and </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">goes below. </font><font style="vertical-align: inherit;">All other code for the least likely state machine stays below because the label is cold.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambiguous -O3</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at compiler optimization. </font><font style="vertical-align: inherit;">The first thing that comes to mind is to use not O2, but O3 - it should be faster. </font><font style="vertical-align: inherit;">But this is not so - O3 sometimes generates worse code. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vc/-p/q8/vc-pq8a078kyofsx7cj1ukorbta.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O3 is a collection of some optimizations</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If we add them to O2 separately, we get different options: some optimizations help, some interfere. </font><font style="vertical-align: inherit;">For our specific code, we select only those optimizations that generate the code better. </font><font style="vertical-align: inherit;">We leave the best result - here are 1,820 seconds relative to 1,838 and 1,858. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some options are highlighted in green - this is auto-vectorization.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autovectorization</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An example of a cycle from the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCC guide</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a[<span class="hljs-number">256</span>], b[<span class="hljs-number">256</span>], c[<span class="hljs-number">256</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<font></font>
        a[i] = b[i] + c[i];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we have some variable array that repeats, we can optimize the cycle - decompose into vectors. </font><font style="vertical-align: inherit;">By default, auto- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vectorization is</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enabled at the third level of optimization -O3 </font><font style="vertical-align: inherit;">: GCC generates vector code where it can. </font><font style="vertical-align: inherit;">But </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not all code</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be automatically vectorized (even if it is vectorized in principle). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can enable the GCC option </font></font><code>-fopt-info-vec-all</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which shows what has been vectorized and what is not. </font><font style="vertical-align: inherit;">We get that for our benchmark nothing is vectorized, but the code is still generated worse. </font><font style="vertical-align: inherit;">Therefore, vectorization does not always work: sometimes it slows down the code. </font><font style="vertical-align: inherit;">But we can always see what has been vectorized and what is not, and turn off vectorization, if necessary.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alignment: how to compare string with GET?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We make a small hack, as in nginx: we do not parse lines by bytes, but calculate </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and compare lines with them.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR4_INT(a, b, c, d)    ((d &lt;&lt; 24) | (c &lt;&lt; 16) | (b &lt;&lt; 8) | a)</span>
<span class="hljs-keyword">if</span> (p == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)))
    <span class="hljs-comment">// we have GET as method</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We know that if it is </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not aligned, then it slows down 2-3 times. </font><font style="vertical-align: inherit;">We wrote a small </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benchmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that proves this.</font></font><br>
<br>
<pre><code class="cpp hljs">$ ./int_align<font></font>
Unaligned access = <span class="hljs-number">6.20482</span>
Aligned access = <span class="hljs-number">2.87012</span>
Read four bytes = <span class="hljs-number">2.45249</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then try to align </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We will look, if the address is </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aligned, then compare by </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, if not, bytes.</font></font><br>
<br>
<pre><code class="cpp hljs"> (((<span class="hljs-keyword">long</span>)(p) &amp; <span class="hljs-number">3</span>)<font></font>
  ? ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">0</span>]) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>)<font></font>
  | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span>))<font></font>
  : *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(p));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But it turns out that this approach works worse:</font></font><br>
<br>
<pre><code class="bash hljs">full request line:     no difference<font></font>
method only:           unaligned      - 214ms<font></font>
                       aligned        - 231ms<font></font>
                       bytes          - 216ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In short: there is a difference between the isolated, non-optimizable, benchmark code and the inlined parser code, which loses its optimization due to the large amount of code. </font><font style="vertical-align: inherit;">There was no penalty in profiling. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: a detailed discussion of why this is happening in our task can be </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">read on GitHub</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why are HTTP strings important to us?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, this is a normal URI: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pw/_d/tw/pw_dtwjndt-xro47gvj3qehvpm4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you are picky enough about the hotel, go to Booking and set some filters, get a URI more than a kilobyte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx has a fairly massive parsing machine on </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It does not work very fast. </font><font style="vertical-align: inherit;">In addition, in the case of Tempesta FW, we need to not only parse the URI, but also check it for injections.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">case</span> sw_check_uri:
    <span class="hljs-keyword">if</span> (usual[ch &gt;&gt; <span class="hljs-number">5</span>] &amp; (<span class="hljs-number">1U</span> &lt;&lt; (ch &amp; <span class="hljs-number">0x1f</span>)))
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">switch</span> (ch) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:<font></font>
        r-&gt;uri_ext = <span class="hljs-literal">NULL</span>;<font></font>
        state = sw_after_slash_in_uri;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'.'</span>:<font></font>
        r-&gt;uri_ext = p + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">' '</span>:<font></font>
        r-&gt;uri_end = p;<font></font>
        state = sw_check_uri_http_09;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> CR:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;<font></font>
        state = sw_almost_done;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LF:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;
        <span class="hljs-keyword">goto</span> done;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'%'</span>:<font></font>
    r-&gt;quoted_uri = <span class="hljs-number">1</span>;<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another URI: /redir_lang.jsp?lang=foobar%0d%0aContent-Length:%200%0d% </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0a% 0d% 0aHTTP / 1.1% 20200% 20OK% 0d% 0aContent-Type:% 20text / </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html% 0d% 0aContent -Length:% 2019% 0d% 0a% 0d% 0aShazam &lt;/ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html&gt;. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It looks like the first, but it has an injection. You‚Äôll have to dig deep enough to understand this. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's run a test</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : take the first URI, feed wrk, set it to nginx and see that parsing nginx gets very hot. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m-/y1/id/m-y1idxtawyq5rjayodyb_r2tgq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If on the previous regular index query it was clear that the parser is already in the top, here it gets even hotter.</font></font><br>
<br>
<pre><code class="bash hljs">8.62%  nginx         [.] ngx_http_parse_request_line<font></font>
2.52%  nginx         [.] ngx_http_parse_header_line<font></font>
1.42%  nginx         [.] ngx_palloc<font></font>
0.90%  [kernel]      [k] copy_user_enhanced_fast_string<font></font>
0.85%  nginx         [.] ngx_strstrn<font></font>
0.78%  libc-2.24.so  [.] _int_malloc<font></font>
0.69%  nginx         [.] ngx_hash_find<font></font>
0.66%  [kernel]      [k] tcp_recvmsg</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is special about HTTP strings? </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are different separators </font></font><code>' : '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>' , '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and even the end of the lines, which can be either double-byte </font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or single-byte </font></font><code>\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which was discussed at the beginning. </font><font style="vertical-align: inherit;">There is no 0-termination of C-lines - for security reasons we want to more accurately check what comes to us. </font><font style="vertical-align: inherit;">We have two standard functions that help in the parser.</font></font><br>
<br>
<ul>
<li><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: checks the alphabet, available characters in a string, dynamically compiles a valid alphabet, although it is known at the stage of compilation of the program.</font></font></li>
<li><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">There is no need to convert case to compare </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with </font></font><code>Foo:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In most cases </font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, only compliance / non-compliance is required </font><font style="vertical-align: inherit;">for </font><font style="vertical-align: inherit;">, and you do not need to know the position in the line.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
They work slowly. </font><font style="vertical-align: inherit;">Let's see the benchmarks and understand what is wrong with them.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quick parsers</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are several parsers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx is the simplest parser, parser. It strictly checks RFC compliance. There are also PicoHTTPParser (H2O) and Cloudflare parsers. They process data faster, but may </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://blog.cloudflare.com/improving-pico"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">skip characters</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that are not allowed by the RFC. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCMESTRI.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parsers use several different approaches. The first is the PCMESTRI instruction, which is used in the Pico parser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We set ranges in the instructions. Unfortunately, we can load either 16 characters or 8 ranges. If the range consists of only one character - just repeat. Because of this limitation, the Pico parser cannot fully verify RFC compliance, because the RFC has more than 8 ranges in this location.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ks/x8/m_/ksx8m_ixc0oy3kzucdwzumppaus.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We load the alphabet into the register, load the string, execute the instruction. At the exit, we quickly see whether there is a coincidence or not. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2 - CloudFlare Approach.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The CloudFlare parser, using AVX2, processes 32 bytes of a string at a time, instead of 16 bytes with a Pico parser. Parsing is better at CloudFlare because it was transferred to AVX2. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/b8/3j/g1/b83jg1epzz6ec6dllxv1j4a-0lo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We check all the characters to a space in the ASCII table, all characters are greater than 128 and take the range between them. Simple code is fast. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compare PCMESTRI and AVX2.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For us, the current limit is 1500. This is the maximum package size that comes to us. We see that the AVX2 code on big data is much faster than the Pico parser. But it works slower on small data, because instructions are heavier in AVX2. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/se/5t/c2/se5tc2npli1yed8ypqkdkk3z-pm.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comparable to</font></font><code><strong>strspn</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If we decide to use </font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, things get worse, especially on big data. </font><font style="vertical-align: inherit;">In the "combat" parser can not be used </font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/08/vq/bf08vqlzni3dcjzxgiuj73zgszo.png"><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta matcher is faster and more accurate</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our speed parser is like these two. On small data, it is as fast as a Pico parser, on large - like CloudFlare. However, it does not skip invalid characters. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5t/ns/lw/5tnslwsd-ywmrv1d4xaj5_ypwbw.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How is the parser arranged?</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We, as nginx, define an array of bytes and check the input data by it - this is the prologue of the function. Here we work only with short terms, we use </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it because branch misprediction is more painful for short lines than for long ones. We take this code up. We have a limit of 4 because of the last line - we must write a fairly powerful condition. If we process more than 4 bytes, the condition will be harder and the code slower.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> uri_a[] __attribute__((aligned(<span class="hljs-number">64</span>))) = {
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<font></font>
        ...<font></font>
        <span class="hljs-comment">// Branch misprediction is more crucial for short strings</span>
        <span class="hljs-keyword">if</span> (likely(len &lt;= <span class="hljs-number">4</span>)) {
                <span class="hljs-keyword">switch</span> (len) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<font></font>
                    c3 = uri_a[s[<span class="hljs-number">3</span>]];
                    <span class="hljs-comment">// fall through to process other chars</span>
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    c2 = uri_a[s[<span class="hljs-number">2</span>]];
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    c1 = uri_a[s[<span class="hljs-number">1</span>]];
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span> (c0 &amp; c1) == <span class="hljs-number">0</span> ? c0 : <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Main loop and large tail. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the main processing cycle, we divide the data: if it is long enough, we process 128, 64, 32, or 16 bytes each. </font><font style="vertical-align: inherit;">It makes sense to process 128 each: in parallel, we use several processor channels (several pipeline) and a superscalar processor.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> ( ; unlikely(s + <span class="hljs-number">128</span> &lt;= end); s += <span class="hljs-number">128</span>) {<font></font>
        n = match_symbols_mask128_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">128</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">64</span> &lt;= end)) {<font></font>
        n = match_symbols_mask64_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">64</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">64</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">32</span> &lt;= end)) {<font></font>
        n = match_symbols_mask32_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">32</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">32</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">16</span> &lt;= end)) {<font></font>
        n = match_symbols_mask16_c(__C.URI_BM128, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">16</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">16</span>;<font></font>
}</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tail. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The end of the function is similar to the beginning. </font><font style="vertical-align: inherit;">If we have less than 16 bytes, then we process 4 bytes in a loop, and then no more than 3 bytes at the end.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">while</span> (s + <span class="hljs-number">4</span> &lt;= end) {<font></font>
        c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
        c1 = uri_a[s[<span class="hljs-number">1</span>]];<font></font>
        c2 = uri_a[s[<span class="hljs-number">2</span>]];<font></font>
        c3 = uri_a[s[<span class="hljs-number">3</span>]];
        <span class="hljs-keyword">if</span> (!(c0 &amp; c1 &amp; c2 &amp; c3)) {<font></font>
                n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;
                <span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }<font></font>
        s += <span class="hljs-number">4</span>;<font></font>
}<font></font>
<font></font>
c0 = c1 = c2 = <span class="hljs-number">0</span>;
<span class="hljs-keyword">switch</span> (end - s) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                c2 = uri_a[s[<span class="hljs-number">2</span>]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                c1 = uri_a[s[<span class="hljs-number">1</span>]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
}<font></font>
<font></font>
n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;
<span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + c2;</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We load bit masks and data -</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this is the main algorithm of the main body of the function. We present an ASCII table (as in the picture) with 16 rows and 8 columns. First, we encode our table rows in the first register of BM URI: the first and second row. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9l/cv/k2/9lcvk2_wg7qs6svdibpx9m1b09c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The actual symbols that we allow are </font></font><code>0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. They are encoded as follows: </font></font><code>b8 = inv(1011 1000) = 0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>f8 = inv(1111 1000) = 2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We encode in the reverse order: we start at 0, the first service character is not allowed, and then units are what is allowed. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set the ASCII bit masks.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For example, a line comes in </font></font><code>"pr"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: the first character from the first line is ASCII, the second from the second line. We run the shuffle statement, which shuffles our encoded table rows in accordance with the order of these characters in the input.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_i/zr/ol/_izrolii19qo5olblx0zzjgq_iu.jpeg"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Column ID for input.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next, we place the columns of the ASCII table in a different register. Then we ‚Äúcross‚Äù the registers of columns and rows, and we get a correspondence: our character or not. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the columns are the most significant 4 bits from the byte, we shift to the left. AVX has an offset of only 2 bytes, so first shift the byte, then n with our mask to get only significant bits. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d9/xy/xr/d9xyxrmjyplbnhkpwrxbqblians.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arranging ASCII Columns</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Run the second shuffle, move the column to the desired positions. In both cases, the input byte from the last column, so in the first and second position we get the same column. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/g1/2s/hxg12sn4xw-qlt7miq97k0pnwgy.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intersection of columns and rows of masks</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . We do </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(‚Äúcross‚Äù the columns with columns) and we get that the input data is valid - the result</font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the intersection of columns and rows is not zero. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cd/oa/kw/cdoakwgjf-oipltg_xeyyglobn8.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Count the number of zeros at the end. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We collect it all from the vector in </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and return it to the output - quite simply. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f9/ci/tl/f9citlkgsjvtxifi9qe3pdxu7su.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Customize the alphabets. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Working with the ASCII table, we get a cheap feature: we use static tables, but nothing prevents asking the user which alphabet is available for URIs, names and values ‚Äã‚Äãof different headers. </font><font style="vertical-align: inherit;">The HTTP URI request and the header use 8 alphabets (plus or minus) to parse one HTTP request. </font><font style="vertical-align: inherit;">These tables can be loaded into the same code and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compared in a single alphabet specified by the user, a</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> valid URI. </font><font style="vertical-align: inherit;">If not, it‚Äôs different.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attacks</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A few cases when this may be useful. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSRF attack with BlackHat'17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (‚ÄúA New Era of SSRF‚Äù): </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">http://foo@evil.com:80@google.com/</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- an unlikely ampersand symbol. </font><font style="vertical-align: inherit;">In some applications it is used, in some not. </font><font style="vertical-align: inherit;">But if you are not using it, you can exclude it from the valid alphabet and the attack will be blocked. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RCE-attack:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬´effective is the perform command injection attacks like¬ª, BSides'16: </font></font><code>User-Agent: ...;echo NAELBD$((26+58))$echo(echo NAELBD)NAELBD...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The User-Agent is a static header, but there are cases of an RCE attack when some come </font></font><code>shell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with atypical characters for the User-Agent. </font><font style="vertical-align: inherit;">We protect ourselves except for the dollar sign. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relative Path Overwrite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The last case is what Google had in 2016. </font><font style="vertical-align: inherit;">Curly braces, colons, came to the URI </font></font><code>.../gallery?q=%0a{}*{background:red}/..//apis/howto_guide.html</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">These are unlikely characters that can be excluded from the alphabet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strcasecmp ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a fairly trivial code. </font><font style="vertical-align: inherit;">We also compare strings of 32 bytes, two arrays each.</font></font><br>
<br>
<pre><code class="cpp hljs">__m256i CASE = _mm256_set1_epi8(<span class="hljs-number">0x20</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker‚Äôs Delight for signed comparison: -0x80 for both operands</span>
__m256i A = _mm256_set1_epi8(<span class="hljs-string">'A'</span> ‚Äì <span class="hljs-number">0x80</span>);<font></font>
__m256i D = _mm256_set1_epi8(<span class="hljs-string">'Z'</span> - <span class="hljs-string">'A'</span> + <span class="hljs-number">1</span> ‚Äì <span class="hljs-number">0x80</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker‚Äôs Delight: 'a' &lt;= v &lt;= 'z' to</span>
<span class="hljs-comment">// v - ('a' ‚Äì 0x80) &lt; 'z' - 'a' + 1 - 0x80</span><font></font>
__m256i sub = _mm256_sub_epi8(str1, A);<font></font>
__m256i cmp_r = _mm256_cmpgt_epi8(D, sub);<font></font>
__m256i lc = _mm256_and_si256(cmp_r, CASE);<font></font>
__m256i vl = _mm256_or_si256(str1, lc);<font></font>
__m256i eq = _mm256_cmpeq_epi8(vl, str2);<font></font>
<span class="hljs-keyword">return</span> ~_mm256_movemask_epi8(eq);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We give the register only one line, because in the second we programmed the constants in our parser in lower case. </font><font style="vertical-align: inherit;">Since we have significant comparisons, we subtract 128 from each byte (a trick from Hacker's Delight). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We also compare the range of a valid character: whether we can register for this string or not, is it a letter or not. </font><font style="vertical-align: inherit;">At the time of checking this, instead of two comparisons from a to z, we can use only one comparison (a trick from Hacker's Delight) and move to a constant.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance strcasecmp ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta is much faster than GLIBC, even the new version (18 or 19). </font><font style="vertical-align: inherit;">The code </font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also uses AVX, but not the second version. </font><font style="vertical-align: inherit;">AVX2 is faster, so Tempesta has faster code.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/zi/pb/wxzipbzdsbvge8u_abhsnok-gfa.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux kernel FPU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We use </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector processor extensions</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - they are available in the kernel. Vector instructions are processed by the FPU processor module. This is not the main processor module, not the main registers, but quite voluminous. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, there is optimization in Linux. If we go from the kernel to user space and back, we don‚Äôt save the context of the FPU registers (XMM, YMM, ZMM): we change the context of only the registers of the main processor module. It is assumed that the OS kernel does not work with the vector extension of the processor. But if you need it, for example, cryptography can do it, but need to use </font></font><code>fpu_begin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>fpu_end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to save and restore the context of the FPU register:</font></font><br>
<br>
<pre><code class="cpp hljs">__kernel_fpu_begin_bh();<font></font>
memcpy_avx(dst, src, n);<font></font>
__kernel_fpu_end_bh();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These are native macros that </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">save and restore the state of the processor module</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is responsible for vector registers. </font><font style="vertical-align: inherit;">These are fairly slow resources.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX and SSE</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before the benchmarks of saving and restoring the FPU context, a couple of words about vector operations. </font><font style="vertical-align: inherit;">Why sometimes it makes sense to work with assembler? </font><font style="vertical-align: inherit;">Sometimes GCC generates suboptimal code. </font><font style="vertical-align: inherit;">The problem is that on older processor models, there is a significant penalty from the transition from SSE to AVX. </font><font style="vertical-align: inherit;">GCC has a new key </font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- use it so that it does not generate this instruction </font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which clears the registers and removes this penalty. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You need to use this instruction only if you are working with old code that was compiled for SSE by some third party. </font><font style="vertical-align: inherit;">This is not our case and we can safely throw out these instructions.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto-vectorization</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the processor. This means that in any user space code there will be vector operations. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n9/vy/0w/n9vy0wal4alh1eelo1rbdjabavc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Any two processes in the system use vector processor extensions. When your process goes to the kernel and back, you do not waste time saving and restoring the vector state of the processor. But if you switch from one user space to another (context switch), then in addition to the fact that first level caches are disabled there, the context switch module on FPU begin / end also works poorly. The operation is quite expensive - a microbenchmark.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In microbenchmarks, everything is always dramatic, but the operation is very expensive. </font><font style="vertical-align: inherit;">Therefore, in user space, switch the context for a long time. </font><font style="vertical-align: inherit;">In the kernel, we don‚Äôt have context switching, so everything is fast. </font><font style="vertical-align: inherit;">We save and restore the vector processor only once for a sufficiently large set of packages.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intelpocalypse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the beginning, I showed a lookup table option for optimizing the switch code: a long process, enum, compile the switch table into an array and follow the double dereferencing of the pointer that jumps over this array. This is a scenario for a Specter attack that exploits speculative execution. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google has a good </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on how double dereferencing of pointers in modern compilers is arranged right now (since the beginning of 2018). It does not work very well. If earlier in the register some address was stored and we went to this address, now we have a different code.</font></font><br>
<br>
<pre><code class="cpp hljs">jmp *%r11 <font></font>
    call l1<font></font>
l0: pause<font></font>
    lfence<font></font>
    jmp l0<font></font>
l1: mov %r11, (%rsp)<font></font>
    ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How does it work? We ‚Äúcall‚Äù the function on l1, the process goes to this label and we make a hack: as if returning from the function (which is not), but rewrite the return address. When we do the instruction </font></font><code>call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">we place </font><font style="vertical-align: inherit;">the return address, the current address on the stack, rewrite it with the necessary contents of the register and go to l1. But the processor, when its prefetcher is running, sees that there is a function, and then a barrier. Accordingly, everything will be slow - it throws out prefetching and we get rid of the Specter vulnerability. The code is slow, performance drops by 15%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next relatively new attack is </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meltdown.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It is specific to user space processes only. </font><font style="vertical-align: inherit;">Very painful is reading kernel memory from user space. </font><font style="vertical-align: inherit;">The attack is prevented by the Kernel Pate Table Isolation (KPTI), which compiles in new kernels by default. </font><font style="vertical-align: inherit;">But KPTI is very expensive, up to 30-40% performance degradation ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as measured by MariaDB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is due to the fact that you no longer have lazy TLB optimization: the address space of the kernel and the processor is completely separated in different page tables (before, lazy TLB kept mapping the kernel space to the page table of each process). </font><font style="vertical-align: inherit;">This is painful for user space, but not for Tempesta FW, which works completely in the kernel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some useful links:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=http://natsys-lab.blogspot.com/2014/11/the-fast-finite-state-machine-for-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast Finite State Machine for HTTP Parsing</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=http://natsys-lab.blogspot.com/2016/10/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP Strings Processing Using C, SSE4.2 and AVX2</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacker's delight</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meltdown and Specter attacks docs</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">Intelpocalypse: goodbye fast system calls</a></li>
</ul><br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">Saint HighLoad++</a>        .       , 6   -- (  ,      Saint HighLoad++)  ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="> web </a>. <br>
<br>
     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">PHP Russia</a>: 13   ,  .       ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">KnowledgeConf</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">++</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">TechLead Conf</a> ‚Äî     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="></a>  , ,    .<br>
</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en493226/index.html">How to read and fix 100,000 lines of code per week</a></li>
<li><a href="../en493230/index.html">New Google PageSpeed ‚Äã‚ÄãInsights powered by Lighthouse 6 (beta): check your site‚Äôs performance</a></li>
<li><a href="../en493232/index.html">The history of my work at Open Product LLC</a></li>
<li><a href="../en493234/index.html">ING Launches Lion: A Library of Productive, Affordable, and Flexible Web Components</a></li>
<li><a href="../en493236/index.html">Asterisk: external trunks in Request Sent state</a></li>
<li><a href="../en493244/index.html">What can a quantum computer</a></li>
<li><a href="../en493248/index.html">Webinar "Winnum Opportunities for Industrial Analytics"</a></li>
<li><a href="../en493250/index.html">What is happening with travel right now - and how to protect yourself in transport</a></li>
<li><a href="../en493252/index.html">Teaching experience at a development school, or why you need to go to school after university</a></li>
<li><a href="../en493254/index.html">The system of mass wiretapping of the population was practically useless for the FBI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>