<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔐 👣 🤳🏽 Panduan praktis untuk menangani kebocoran memori di Node.js ❤️ 👇🏽 👔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kebocoran memori mirip dengan entitas parasit pada aplikasi. Mereka diam-diam menembus ke dalam sistem, pada awalnya tanpa menimbulkan bahaya. Tetapi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Panduan praktis untuk menangani kebocoran memori di Node.js</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/495898/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kebocoran memori mirip dengan entitas parasit pada aplikasi. </font><font style="vertical-align: inherit;">Mereka diam-diam menembus ke dalam sistem, pada awalnya tanpa menimbulkan bahaya. </font><font style="vertical-align: inherit;">Tetapi jika kebocorannya ternyata cukup kuat, itu dapat membawa aplikasi ke bencana. </font><font style="vertical-align: inherit;">Misalnya - untuk memperlambatnya dengan kuat atau hanya untuk "membunuh" itu. </font><font style="vertical-align: inherit;">
Penulis artikel, terjemahan yang kami terbitkan hari ini, menyarankan untuk membicarakan kebocoran memori dalam JavaScript. </font><font style="vertical-align: inherit;">Secara khusus, kita akan berbicara tentang manajemen memori dalam JavaScript, bagaimana mengidentifikasi kebocoran memori dalam aplikasi nyata, dan bagaimana menangani kebocoran memori.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ut/sj/t-/utsjt-d80r9mqkvrexbbkws-eae.png"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa itu kebocoran memori?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kebocoran memori, dalam arti luas, adalah sepotong memori yang dialokasikan untuk aplikasi yang tidak lagi dibutuhkan aplikasi ini, tetapi tidak dapat dikembalikan ke sistem operasi untuk digunakan di masa mendatang. </font><font style="vertical-align: inherit;">Dengan kata lain, itu adalah blok memori yang ditangkap oleh aplikasi tanpa niat menggunakan memori ini di masa depan.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajemen memori</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manajemen memori adalah mekanisme untuk mengalokasikan memori sistem ke aplikasi yang membutuhkannya, dan mekanisme untuk mengembalikan memori yang tidak perlu ke sistem operasi. </font><font style="vertical-align: inherit;">Ada banyak pendekatan untuk manajemen memori. </font><font style="vertical-align: inherit;">Pendekatan mana yang digunakan tergantung pada bahasa pemrograman yang digunakan. </font><font style="vertical-align: inherit;">Berikut ini adalah ikhtisar dari beberapa pendekatan umum untuk manajemen memori:</font></font><br>
<br>
<ul>
<li>  .           .         .       ,    .        C  C++.   ,   ,   <code>malloc</code>  <code>free</code>,      .</li>
<li>   . ,      ,   ,       .   ,  ,    ,        . ,     ,  ,      ,   .         .  — JavaScript, ,   JVM (Java, Scala, Kotlin), Golang, Python, Ruby  .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penerapan konsep kepemilikan memori. </font><font style="vertical-align: inherit;">Dengan pendekatan ini, setiap variabel harus memiliki pemiliknya sendiri. </font><font style="vertical-align: inherit;">Segera setelah pemilik berada di luar ruang lingkup, nilai dalam variabel dihancurkan, membebaskan memori. </font><font style="vertical-align: inherit;">Ide ini digunakan di Rust.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada pendekatan lain untuk manajemen memori yang digunakan dalam berbagai bahasa pemrograman. </font><font style="vertical-align: inherit;">Misalnya, C ++ 11 menggunakan idiom </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAII</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sementara Swift menggunakan mekanisme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tetapi membicarakannya adalah di luar cakupan artikel ini. </font><font style="vertical-align: inherit;">Untuk membandingkan metode manajemen memori di atas, untuk memahami pro dan kontra mereka, kita memerlukan artikel terpisah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript, sebuah bahasa yang tanpa itu pemrogram web tidak dapat membayangkan pekerjaan mereka, menggunakan ide pengumpulan sampah. </font><font style="vertical-align: inherit;">Karena itu, kita akan berbicara lebih banyak tentang bagaimana mekanisme ini bekerja.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengumpulan sampah JavaScript</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang telah disebutkan, JavaScript adalah bahasa yang menggunakan konsep pengumpulan sampah. </font><font style="vertical-align: inherit;">Selama pengoperasian program JS, mekanisme yang disebut pengumpul sampah diluncurkan secara berkala. </font><font style="vertical-align: inherit;">Dia mencari tahu bagian mana dari memori yang dialokasikan dapat diakses dari kode aplikasi. </font><font style="vertical-align: inherit;">Yaitu, variabel mana yang dirujuk. </font><font style="vertical-align: inherit;">Jika pengumpul sampah mengetahui bahwa sepotong memori tidak lagi diakses dari kode aplikasi, itu membebaskan memori ini. </font><font style="vertical-align: inherit;">Pendekatan di atas dapat diimplementasikan menggunakan dua algoritma utama. </font><font style="vertical-align: inherit;">Yang pertama adalah yang disebut algoritma Mark and Sweep. </font><font style="vertical-align: inherit;">Ini digunakan dalam JavaScript. </font><font style="vertical-align: inherit;">Yang kedua adalah Menghitung Referensi. </font><font style="vertical-align: inherit;">Ini digunakan dalam Python dan PHP.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ee/8ac/c60/3ee8acc608afe85e6a4c6f202cb1e8fe.gif"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tanda Fase (penandaan) dan Sapu (pembersihan) dari</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
algoritma</font><i><font color="#999999"><font style="vertical-align: inherit;"> Mark dan Sapu</font></font></i><font style="vertical-align: inherit;"> Saat menerapkan algoritme penandaan, daftar simpul akar yang diwakili oleh variabel lingkungan global (ini adalah objek di browser</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dibuat terlebih dahulu, dan kemudian pohon yang dihasilkan dirayapi dari akar ke simpul daun yang ditandai dengan semua bertemu di jalan benda. </font><font style="vertical-align: inherit;">Memori pada heap yang ditempati oleh objek yang tidak berlabel dibebaskan.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memori bocor di aplikasi Node.js</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sampai saat ini, kami telah menganalisis konsep teoritis yang cukup terkait dengan kebocoran memori dan pengumpulan sampah. </font><font style="vertical-align: inherit;">Jadi - kami siap untuk melihat bagaimana semuanya terlihat dalam aplikasi nyata. </font><font style="vertical-align: inherit;">Di bagian ini, kita akan menulis server Node.js yang memiliki kebocoran memori. </font><font style="vertical-align: inherit;">Kami akan mencoba mengidentifikasi kebocoran ini menggunakan berbagai alat, dan kemudian kami akan menghilangkannya.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Keakraban dengan kode yang memiliki kebocoran memori</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk tujuan demonstrasi, saya menulis server Express yang memiliki rute kebocoran memori. </font><font style="vertical-align: inherit;">Kami akan men-debug server ini.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> app = express();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
<font></font>
app.listen(port, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example app listening on port <span class="hljs-subst">${port}</span>!`</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada larik </font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang berada di luar cakupan kode pemrosesan permintaan API. </font><font style="vertical-align: inherit;">Akibatnya, setiap kali kode yang sesuai dijalankan, elemen baru ditambahkan ke array. </font><font style="vertical-align: inherit;">Array tidak pernah dihapus. </font><font style="vertical-align: inherit;">Karena tautan ke larik ini tidak hilang setelah keluar dari penangan permintaan, pemulung tidak pernah membebaskan memori yang digunakannya.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍Panggil kebocoran memori</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita sampai pada yang paling menarik. Banyak artikel telah ditulis tentang bagaimana, menggunakan </font></font><code>node --inspect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, untuk men-debug kebocoran memori server, setelah mengisi server dengan permintaan menggunakan sesuatu seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artileri</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tetapi pendekatan ini memiliki satu kelemahan penting. Bayangkan Anda memiliki server API yang memiliki ribuan titik akhir. Masing-masing dari mereka mengambil banyak parameter, kode tertentu yang akan dipanggil tergantung pada fitur-fiturnya. Akibatnya, dalam kondisi nyata, jika pengembang tidak tahu di mana letak kebocoran memori, ia harus mengakses setiap API berkali-kali menggunakan semua kombinasi parameter yang mungkin untuk mengisi memori. Bagi saya, tidak mudah untuk melakukannya. Solusi untuk masalah ini, bagaimanapun, difasilitasi dengan menggunakan sesuatu seperti</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">goreplay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - sistem yang memungkinkan Anda merekam dan "memainkan" lalu lintas nyata. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengatasi masalah kami, kami akan melakukan debugging dalam produksi. </font><font style="vertical-align: inherit;">Artinya, kami akan memungkinkan server kami untuk meluap memori selama penggunaannya yang sebenarnya (karena menerima berbagai permintaan API). </font><font style="vertical-align: inherit;">Dan setelah kami menemukan peningkatan mencurigakan dalam jumlah memori yang dialokasikan untuk itu, kami akan melakukan debugging.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Heap Dump</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memahami apa heap dump, pertama-tama kita perlu mencari tahu arti konsep heap. Jika Anda menggambarkan konsep ini sesederhana mungkin, ternyata tumpukan adalah tempat di mana segala sesuatu yang dialokasikan memori jatuh ke dalamnya. Semua ini ada di tumpukan sampai pengumpul sampah menghapus semua yang dianggap tidak perlu. Tumpukan tumpukan adalah sedikit gambaran dari kondisi tumpukan saat ini. Dump berisi semua variabel internal dan variabel yang dideklarasikan oleh programmer. Ini mewakili semua memori yang dialokasikan pada heap pada saat dump diterima.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, jika kita dapat membandingkan tumpukan timbunan server yang baru saja dimulai dengan timbunan tumpukan server, yang telah berjalan untuk waktu yang lama dan memori yang meluap, maka kita dapat mengidentifikasi objek mencurigakan yang tidak diperlukan aplikasi, tetapi tidak dihapus oleh pengumpul sampah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum melanjutkan percakapan, mari kita bicara tentang cara membuat heap dumps. </font><font style="vertical-align: inherit;">Untuk mengatasi masalah ini, kami akan menggunakan heapdump paket </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">npm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang memungkinkan Anda untuk mendapatkan dump dari tumpukan server. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instal paket:</font></font><br>
<br>
<pre><code class="bash hljs">npm i heapdump
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan membuat beberapa perubahan pada kode server yang memungkinkan kami menggunakan paket ini:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> heapdump = <span class="hljs-built_in">require</span>(<span class="hljs-string">"heapdump"</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> app = express();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
<font></font>
app.get(<span class="hljs-string">'/heapdump'</span>, (req, res) =&gt; {<font></font>
&nbsp;&nbsp;heapdump.writeSnapshot(<span class="hljs-string">`heapDump-<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>.heapsnapshot`</span>, (err, filename) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Heap dump of a bloated server written to"</span>, filename);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">msg</span>: <span class="hljs-string">"successfully took a heap dump"</span>})<font></font>
&nbsp;&nbsp;});<font></font>
});<font></font>
<font></font>
app.listen(port, () =&gt; {<font></font>
&nbsp;&nbsp;heapdump.writeSnapshot(<span class="hljs-string">`heapDumpAtServerStart.heapsnapshot`</span>, (err, filename) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Heap dump of a fresh server written to"</span>, filename);<font></font>
&nbsp;&nbsp;});<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kami menggunakan paket ini untuk membuang server yang baru diluncurkan. </font><font style="vertical-align: inherit;">Kami juga membuat API yang </font></font><code>/heapdump</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dirancang untuk membuat heap saat mengaksesnya. </font><font style="vertical-align: inherit;">Kami akan beralih ke API ini pada saat kami menyadari bahwa server mulai mengkonsumsi terlalu banyak memori. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika server Anda berjalan di kluster Kubernetes, maka Anda tidak akan dapat, tanpa usaha ekstra, untuk beralih ke pod yang servernya sedang berjalan di mana menghabiskan terlalu banyak memori. </font><font style="vertical-align: inherit;">Untuk melakukan ini, Anda dapat menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penerusan porta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Selain itu, karena Anda tidak akan memiliki akses ke sistem file yang Anda butuhkan untuk mengunduh file dump, akan lebih baik untuk mengunggah file-file ini ke penyimpanan cloud eksternal (seperti S3).</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Deteksi kebocoran memori</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan sekarang, server dikerahkan. Dia telah bekerja selama beberapa hari. Ia menerima banyak permintaan (dalam kasus kami, hanya permintaan dari jenis yang sama) dan kami memperhatikan peningkatan jumlah memori yang dikonsumsi oleh server. Kebocoran memori dapat dideteksi menggunakan alat pemantauan seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Express Status Monitor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clinic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prometheus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Setelah itu, kami memanggil API untuk membuang heap. Tempat sampah ini akan berisi semua objek yang tidak bisa dihapus oleh pemulung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inilah yang tampak seperti kueri untuk membuat dump:</font></font><br>
<br>
<pre><code class="bash hljs">curl --location --request GET <span class="hljs-string">'http://localhost:3000/heapdump'</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika tumpukan sampah dibuat, pengumpul sampah terpaksa dijalankan. Akibatnya, kita tidak perlu khawatir tentang benda-benda yang mungkin dibuang oleh pengumpul sampah di masa depan, tetapi masih di tumpukan. Yaitu - tentang objek ketika bekerja dengan yang kebocoran memori tidak terjadi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah kami memiliki keduanya dump (dump dari server yang baru diluncurkan dan dump server yang telah bekerja selama beberapa waktu), kami dapat mulai membandingkannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mendapatkan dump memori adalah operasi pemblokiran yang membutuhkan banyak memori untuk menyelesaikannya. Karena itu, harus dilakukan dengan hati-hati. Anda dapat membaca lebih lanjut tentang kemungkinan masalah yang terjadi selama operasi ini di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luncurkan Chrome dan tekan tombol.</font></font><code>F12</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini akan mengarah pada penemuan alat pengembang. </font><font style="vertical-align: inherit;">Di sini Anda perlu pergi ke tab </font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan memuat kedua snapshot memori.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c1/252/992/5c125299224be08bb5bb73f74842f0b8.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Download dump memori pada tab Memory alat pengembang Chrome</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Setelah men-download kedua snapshot, Anda perlu perubahan</font></font><code>perspective</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk</font></font><code>Comparison</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan klik pada snapshot dari memori server yang bekerja untuk beberapa waktu.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/7c7/224/a997c7224ac3d053651be9e848380e75.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mulai membandingkan foto-foto</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Di sini kita dapat menganalisis kolom</font></font><code>Constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mencari objek yang tidak dapat dihapus oleh pengumpul sampah. </font><font style="vertical-align: inherit;">Sebagian besar objek ini akan diwakili oleh tautan internal yang digunakan node. </font><font style="vertical-align: inherit;">Di sini berguna untuk menggunakan satu trik, yang terdiri dari pengurutan daftar berdasarkan bidang</font></font><code>Alloc. Size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini akan dengan cepat menemukan objek yang menggunakan sebagian besar memori. </font><font style="vertical-align: inherit;">Jika Anda memperluas blok</font></font><code>(array)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian -</font></font><code>(object elements)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Anda dapat melihat array yang</font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi sejumlah besar objek yang tidak dapat dihapus menggunakan pengumpul sampah.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e85/02c/0a2/e8502c0a2dcd1cf635f229eaef8d9e90.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis array yang mencurigakan</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Teknik ini akan memungkinkan kita untuk pergi ke array</font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan memahami bahwa itu adalah operasi yang salah dengan itu yang menyebabkan kebocoran memori.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍Fiks memori bocor</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita tahu bahwa "pelakunya" adalah sebuah array </font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kita dapat menganalisis kode dan menemukan bahwa masalahnya adalah bahwa array tersebut dinyatakan di luar request handler. </font><font style="vertical-align: inherit;">Akibatnya, ternyata tautan ke sana tidak pernah dihapus. </font><font style="vertical-align: inherit;">Untuk memperbaiki masalah ini cukup sederhana - cukup transfer deklarasi array ke handler:</font></font><br>
<br>
<pre><code class="javascript hljs">app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memverifikasi keefektifan tindakan yang diambil, cukup untuk mengulangi langkah-langkah di atas dan membandingkan gambar tumpukan lagi.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ringkasan</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kebocoran memori terjadi dalam berbagai bahasa. </font><font style="vertical-align: inherit;">Secara khusus, mereka yang menggunakan mekanisme pengumpulan sampah. </font><font style="vertical-align: inherit;">Misalnya, dalam JavaScript. </font><font style="vertical-align: inherit;">Biasanya tidak sulit untuk memperbaiki kebocoran - kesulitan sebenarnya timbul hanya ketika Anda mencarinya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada artikel ini, Anda membiasakan diri dengan dasar-dasar manajemen memori, dan bagaimana manajemen memori diatur dalam berbagai bahasa. </font><font style="vertical-align: inherit;">Di sini kami mereproduksi skenario nyata kebocoran memori dan menjelaskan metode untuk pemecahan masalah. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembaca yang budiman! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pernahkah Anda mengalami kebocoran memori di proyek web Anda?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/iq/fi/b4/iqfib45pgphfrxv--zfemt0qnmw.jpeg"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id495888/index.html">PyCon Russia telah membuka CFP untuk pembicara masa depan. Formulir Partisipasi dan Topik yang Diharapkan</a></li>
<li><a href="../id495890/index.html">Mengkonfigurasi Bundel Nginx / LetsEncrypt di Docker Swarm</a></li>
<li><a href="../id495892/index.html">Apakah Anda benar-benar tahu apa itu array?</a></li>
<li><a href="../id495894/index.html">Pengukuran Kinerja Javascript</a></li>
<li><a href="../id495896/index.html">Paket Penggunaan-suara: Efek Suara di Aplikasi Bereaksi</a></li>
<li><a href="../id495902/index.html">CAPTCHA: membunuh konversi</a></li>
<li><a href="../id495904/index.html">Bisakah epidemi diprediksi?</a></li>
<li><a href="../id495908/index.html">Jalan menuju hadiah</a></li>
<li><a href="../id495910/index.html">Menginstal ROS dalam Gambar IMG Ubuntu Papan Tunggal</a></li>
<li><a href="../id495912/index.html">Stiker replay cerdas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>