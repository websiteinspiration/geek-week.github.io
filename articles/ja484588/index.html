<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌇 👩‍🎤 😬 自動プログラム管理モデル 🧑🏽‍🤝‍🧑🏻 👩‍🔬 👨‍👨‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1.はじめに
 [1]では、自動プログラミング（AP）と見なされるものの質問に対する回答が示されましたが、有限状態機械（SC）のモデルは、自動プログラムの制御モデルとして詳細に説明されていませんでした。純粋な抽象オートマトンはこの役割には適していません。チャネル数によって制限されます。しかし、オート...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>自動プログラム管理モデル</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484588/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.はじめに</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[1]では、自動プログラミング（AP）と見なされるものの質問に対する回答が示されましたが、有限状態機械（SC）のモデルは、自動プログラムの制御モデルとして詳細に説明されていませんでした。</font><font style="vertical-align: inherit;">純粋な抽象オートマトンはこの役割には適していません。</font><font style="vertical-align: inherit;">チャネル数によって制限されます。</font><font style="vertical-align: inherit;">しかし、オートマトンの構造モデル、およびそれに対応する構造オートマトンの理論は、まだオートマトンモデルの選択について答えを出していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、有限オートマトン（TCA）の理論に関する多くの研究の中で、構造有限オートマトン（SCA）のモデルを定義するものはほとんどないという事実から始まります。確かに、構造オートマトンは、抽象オートマトンのモデルを実装する基本オートマトン（機能要素）の[構造]ダイアグラムであることを理解できます[2]。理論によれば、すべては抽象オートマトンの形でデバイスモデルを作成することから始まり、次にそれを実装するデジタル回路を合成することがタスクであることを思い出してください[3]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見プログラミングは、デジタル回路の合成に少し似ています。しかし、最初は。まず、あちこちですべてがアルゴリズムから始まります。第二に、デジタル回路とプログラミングの組織化と実装の構造的な問題は、特に並列プログラミングのコンテキストでは、多くの共通点があります。ただし、並列処理のトピックについては個別に説明します。それまでの間、私たちの仕事は、さまざまなソフトウェアツールを使いこなすプログラマにとって理解しやすく、便利で、快適な有限状態機械のモデルを選択または変更することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確かに、質問はすぐに論理的です。なぜもう1つ、かなり珍しい「自動ツールキット」なのでしょうか。通常のプログラミングモデルと比較した場合の利点も考慮して、[入れ子の]自動制御のモデルを定義することにより、この質問に答えようとします。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.自動プログラムの制御モデルの定義</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
進化の過程で、プログラミングの実践により、プログラム管理モデルに特定の要件が形成されました。古典的な有限状態機械のモデルはそれらにかなり対応していないことを認識しなければなりません。そして、タスクがプログラミングでオートマトンを使用することである場合、それは適応される必要があります。これをオートマトンの理論の枠組みの中で行うことが望ましい。既存のAPに対する主な主張は、この条件に違反しているという事実に帰着します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義1. </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">論理オートマトン（DNKA）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><i><font style="vertical-align: inherit;">選言標準形を</font></i><font style="vertical-align: inherit;">完全に定義された有限オートマトンと</font><font style="vertical-align: inherit;">呼び、</font><font style="vertical-align: inherit;">その遷移は論理変数の素結合によってラベル付けされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DNAモデルは</font><i><font style="vertical-align: inherit;">、抽象状態を持つ</font></i><font style="vertical-align: inherit;">完全に（完全に）定義された</font><i><font style="vertical-align: inherit;">オートマトンの</font></i><font style="vertical-align: inherit;">正式なモデルに基づいてい</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4]と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">論理オートマトン</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [5]。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義2. </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有限オートマトン（DFA）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><i><font style="vertical-align: inherit;">分離型を、</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果として生じる遷移</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のみを含むDFAの形のオートマトン</font><font style="vertical-align: inherit;">と呼びます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力信号でマークされた遷移と、オートマトンの現在の状態を変更する出力信号の代わりにダッシュが付いた遷移は、有効な遷移として分類されます。</font><font style="vertical-align: inherit;">選言オートマトンの説明に含まれていない遷移は</font><font style="vertical-align: inherit;">、完全に定義されたDFAオートマトンに対する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DKA（DDA）の補完を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">そのような追加は、ループの形で遷移があり、出力信号の代わりにダッシュが付いた孤立状態からなるオートマトンです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.計算モデルAPのメモリモデル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DFAの複数の入力と出力の存在は、関連するソフトウェアオペレーター/関数の並列処理を定義します。正しく実装するには、CREWタイプのメモリモデル（同時読み取り専用-書き込み）が必要です[6]。そのフレームワーク内で、現在のデータ値の読み取りは、すべての関数（述語とアクション）のセットの一部で許可されており</font><font style="vertical-align: inherit;">、並列実行可能なアクションの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般データ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">変更</font><font style="vertical-align: inherit;">できるのはそのうちの1つだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動制御モデルは、マルチスレッドコンピューティングモデルとは異なり、自動プログラムの演算子/関数の実行を離散時間サイクルの境界に制限します。このような状況では、現在のクロックサイクルで実行されたアクションによるメモリの変更を</font><i><font style="vertical-align: inherit;">「シャドウメモリ」に</font></i><font style="vertical-align: inherit;">書き込むことができ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらの完了後、次の離散メジャーの開始前に、新しい値になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オートマトンプログラムオペレータとメモリの相互作用は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャドウメモリモデル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">このモデルは、自動プログラミングの一般的なモデルの重要な部分です。</font><font style="vertical-align: inherit;">APオペレーターの並列操作の正確性を保証し、並列プロセスのプログラミングを簡素化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリモデルのフレームワーク内では、プロセスのマルチスレッド同期の複雑であまり信頼性の高いメカニズムは必要ありません（詳細については、[7]を参照してください）。</font><font style="vertical-align: inherit;">しかし、必要に応じて、オートマトンと</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムのグラフ図（GAW）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [8] </font><font style="vertical-align: inherit;">が同等であるため</font><font style="vertical-align: inherit;">、オートマトンプログラミングモデルはその適用も制限しません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.オートマトンのネストされたモデルと慣性モデル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例としてさらに選択された遅延の論理要素のモデルを作成するタスクは、一方ではオートマトンの古典的なモデルの問題を示し、他方ではより視覚的で便利な手段でアルゴリズムの問​​題を解決するDFAモデルの品質を反映しています。入れ子になったオートマトンの導入モデルは、以下では</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">慣性オートマトン</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるオートマトンモデルの</font><font style="vertical-align: inherit;">サブクラスと、対応する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">慣性アルゴリズムの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブクラスを生成し</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、バイナリ入力信号の送信を実装する遅延ロジックエレメントの離散モデルを作成するタスクとします。さらに、一般的な場合のユニット状態とゼロ状態へのそれぞれの遅延t01とt10の時間は一致しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純な</font><i><font style="vertical-align: inherit;">単位遅延</font></i><font style="vertical-align: inherit;">モデル</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイルのオートマトンの形で図に示されています。 1（比較のために、[2]の遅延モデルを参照）。その遅延は、単一の離散クロックサイクルによって決定されます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">輸送</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅延の</font><font style="vertical-align: inherit;">より複雑なモデル</font><font style="vertical-align: inherit;">（遅延の種類の詳細については、[9]を参照）を、Milieオートマトンと結合されたMilie-Mooreモデルの形で図1に示します。 2aと図2b。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1v/1j/pw/1v1jpwicourr8xbg6yf2egq5nxk.jpeg" alt="画像"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/di/bf/-d/dibf-daun_zrsuqr6hohywv2le0.jpeg" alt="画像"> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図</font><font style="vertical-align: inherit;">1.マイル遅延オートマトンの形式の単位遅延モデル</font><font style="vertical-align: inherit;">。 2.輸送遅延モデルMiles（a）およびMiles-Moore（b）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力信号x3（自動プログラムでは述語[1]がそれに対応することを思い出してください）は、クロックカウンターの値が遅延t01またはt10に等しい変数tの値と等しい場合、真の値を取ります。変数tの値は、信号y3とy4によって割り当てられます（プログラムでは、出力信号と同じ名前のアクション関数）。信号y1、y2は、モデルの出力を表す変数の値を設定します。信号y5は、信号y6によってリセットされるクロックカウンターをインクリメントします。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">備考2.図のモデルの内部状態。図１に示すように、要素の出力状態と関連付けると便利である。これにより、演算子y1とy2だけでなく、出力変数自体も除外できます。</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブルーチンの呼び出しと同様のオートマトンの埋め込みの実装は、モジュラーオートマトンプログラミングのテクノロジーを形成します。同時に、ソフトウェアレベルでは、ハードウェアレベルでの同様の試行（対照的に[10]を参照）とは対照的に、これははるかに単純です。これを行うには、ネストされたオートマトンのプログラム呼び出しを挿入する必要があります。次に、通常のプロセッサと同様に、オートマトンの実装のカーネルが、制御を現在のネストレベルに戻すように編成します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義3.ネストされたオートマトン</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、最終状態のあるオートマトンと呼ばれ</font><i><font style="vertical-align: inherit;">ます。</font></i><font style="vertical-align: inherit;">これは、ネストの前のレベル（ランク）に戻る手順を開始する遷移です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オートマトンのネストの正しい実装は、それらの作成手順に制限を課します。第1に、ネストされたオートマトンは従属することができるだけです。さらに、ランク0を除く最上位のオートマトンは、ネストされたオートマトンにすることもできます。第2に、トランジションで</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされたオートマトン</font><font style="vertical-align: inherit;">を</font><b><font style="vertical-align: inherit;">1つだけ</font></b><font style="vertical-align: inherit;">作成できます</font><font style="vertical-align: inherit;">。ネストされたオートマトンのメカニズムは、自動制御に基づく再帰アルゴリズムの実装の基礎も作成します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8c/4u/e5/8c4ue5ufusdgforqughwh5aw83w.jpeg" alt="画像"> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。 3.ネストされたオートマトンの形式の遅延モデル</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図3は、遅延モデルを示しています。図3aは上位レベルのモデル、図3bと図3bは3c-トランスポートおよび</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">慣性</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅延</font><font style="vertical-align: inherit;">のネストされたオートマトンのバリアント</font><font style="vertical-align: inherit;">（遅延のタイプの詳細については、[8]を参照）同時に、これらは2種類のネストされたオートマトンの例です-</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">慣性</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ネストされたオートマトンのタイプは、その最終状態の名前によって定義されます。「00」という名前の状態は、ネストされたオートマトンからの通常の終了を決定し、「XX」という名前の状態は、トップレベルのオートマトンの現在の状態を変更しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
慣性遅延アルゴリズムを理解するための重要な説明。その場合（図3cを参照）、述語x1の値は、ネストされたオートマトンが作成される遷移に依存します。言い換えると、状態「0」の述語は、入力での「ゼロ」の保存を制御し、状態「1」では、逆に「単位」を制御します。入力の値が出力のゼロ値でゼロである場合、真の値を返す必要があります。さらに、入力の安定性が損なわれ（値x1がfalse）、遅延時間が経過していない場合（値x3はfalse）、組み込みマシンからの出口は慣性状態によって実現されます（図3cを参照）。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義4.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オートマトンは、最終的な慣性状態を持つネストされたオートマトンの呼び出しを含め、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">慣性オートマトン</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図3aのモデルでは、アクションz1（ネストされたオートマトンの呼び出しを含むアクションの名前にz記号が選択されています）は、遅延値が定義されている場合にネストされたオートマトンを作成します。</font><font style="vertical-align: inherit;">このアクションの一部として、図3bまたは図3に示されているネストされたオートマトンのいずれが作成されるかに応じて、指定されたタイプの遅延が決定されます。</font><font style="vertical-align: inherit;">3c。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
階層の最上位では、図3aのオートマトンのビューは、図1のモデルと構造が完全に一致し、遷移に対するアクションの存在のみが異なります。</font><font style="vertical-align: inherit;">ネストされたオートマトンの遅延は、図2の単一レベルモデルに比べて単純な形式です。</font><font style="vertical-align: inherit;">ネストされたオートマトンは、他のオートマトンから呼び出すことができる一種の「ライブラリオートマトン」と見なすこともできます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.オブジェクトオートマトンプログラミング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動制御モデルは、グラフィック形式に加えて、単純な表形式（遷移表（TP））も備えています。これは、C ++で効果的に解釈できます。そのフレームワーク内では、別個のオートマトンプログラム（またはその一部）、したがってプログラムSのスキームの形でのその定義は、クラスで表すことができます。この場合、メモリモデルはクラスのプロパティに対応し、操作のセットはクラスのメソッドに対応し、TPの形の自動制御はクラスの動作を記述します。クラスにコントロールを導入することで、しばしばエージェントとも呼ばれるアクティブなオブジェクトについて話すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動制御の形で動作する多くのオブジェクトは、</font><i><font style="vertical-align: inherit;">オブジェクト自動並列プログラムの</font></i><font style="vertical-align: inherit;">概念を形式化し</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この場合、並列プログラムのモデルは、コントロールCがオートマトンネットワークの形式で表示されるプログラムダイアグラムで表すことができます。コンポーネントオートマトンはアクティブオブジェクトの動作を記述し、メモリMはオブジェクトのプロパティの組み合わせで表され、多くのオペレーターAはプログラムオブジェクトのメソッドの組み合わせで表されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VKPA環境では、自動プログラミング言語の役割はC ++言語に割り当てられます。 「自動C ++」では、オブジェクトにはアクティビティ/動作が備わっており、個々のオブジェクトのメソッドのレベルと多くのオブジェクトの並列操作を記述するレベルの両方で、並列処理を記述および実装する手段があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APの既存のオブジェクト実装はかなり複雑です。 VKPaでは、そのオブジェクト実装は、オートマトンの解釈とプログラムの専用制御に基づいています。 SWITHテクノロジーなどで使用されるオートマトンの直接実装とは異なり、オートマトンモデルをブロック線図モデルに変換する手順が不要になります。 VKPaで使用される解釈アルゴリズムは、E。Hambyによる決定テーブルの解釈方法に似ています[12]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に指定のない限り、オートマトンプログラムの概念と</font><i><font style="vertical-align: inherit;">オートマトンオブジェクト（AO）</font></i><font style="vertical-align: inherit;">の概念をさらに関連付け</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOPの意味でですが、上で紹介したオブジェクトオートマトンの並列プログラムの概念を考慮に入れています。</font><font style="vertical-align: inherit;">このため、APのオペレータとメモリは、アクティブオブジェクトのメソッドとプロパティによって決定されます。</font><font style="vertical-align: inherit;">オートマトンオブジェクトは、ステートマシンモデルによって決定される動作の存在によって、通常のオブジェクトと区別されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.結論 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネストされたオートマトンのモデルを作成することは、プログラミング技術の質的な変化に向けた一歩です。説明されているオートマトンの慣性モデルは、UMLの履歴状態の概念に似ています。通常のオートマトンの埋め込みにはプログラミングの類似点があります。「慣性埋め込み」にはそれがないためです。プログラムでは、サブルーチン呼び出しの前のコマンドに戻ることはできません。そして、これらは自動プログラミングと通常のプログラミングの質的な違いの要素です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、通常のプログラミングにシャドウメモリを導入して、関数の並列性を表すことができます。しかし、オートマトンモデルのフレームワークでは、これらすべてが、記述の点でもパフォーマンスの点でも、有機的な形をしています。すべては、モデルの自然な並列性によって決定されます。ブロック線図モデルにはそのような機能はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクティブオブジェクトはプログラミング機能も拡張します。</font><font style="vertical-align: inherit;">しかし、「オブジェクトラッパー」は、その一部として、自動プログラミングに定性的に影響し、ネストされたオートマトンの呼び出しと実装の手順を簡素化します。</font><font style="vertical-align: inherit;">したがって、[local]クラスプロパティを使用すると、埋め込みだけでなく、再帰的なアルゴリズムも実装できます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></b><div class="spoiler_text">1.  ,    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">habr.com/ru/post/481998</a>, . . . (  07.01.2020).<br>
2.  ..,  ..,  ..     – .: . . . .-. ., 1985. – 320 .<br>
3.  ..   . .: , 1962.<br>
4.  ..    . – .: . . . .-. ., 1981. – 416 .<br>
5.  ..       //   . – 1975. – №9.– . 149-158.<br>
6.  .,  .,  . :    – .: , 2001. – 960 .<br>
7.  .,  .,  .  UML.  .  .  : , 2007. – 493 .<br>
8.  ..   . – .: , 1979. – 232.<br>
9.  ..      VHDL:   ./.: , 1992. – 175 .<br>
10.  ..,  ..       . I, .  ., 1981,  2, 135-144<br>
11.  . .   . -  -    ,   . . 53.  . 2008, . 3–23.<br>
12.  .   . .: , 1976. – 86 .<br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja484578/index.html">サービスレベル目標-Googleエクスペリエンス（Google SREブックの章の翻訳）</a></li>
<li><a href="../ja484580/index.html">メモリのシミュレータについて知っておくべきこと</a></li>
<li><a href="../ja484582/index.html">ASP.NET MVC-Entity Framework、MySQL、およびDependency Resolverを使用してリポジトリを選択</a></li>
<li><a href="../ja484584/index.html">ITプロジェクトにマネージャーが必要な理由と、マネージャーがいない場合に何が起こるか</a></li>
<li><a href="../ja484586/index.html">PHPでIPv6を使用する</a></li>
<li><a href="../ja484590/index.html">男の子が見せることを恥じないように</a></li>
<li><a href="../ja484592/index.html">先週のフロントエンドの世界からの新鮮な食材のダイジェストNo. 398（2020年1月13日〜19日）</a></li>
<li><a href="../ja484596/index.html">Blazorクライアント側オンラインストア：パート1-認証OIDC（OAuth2）+ Identity Server4</a></li>
<li><a href="../ja484600/index.html">Microsoft Ignite The Tour Prague Technical Conference</a></li>
<li><a href="../ja484602/index.html">本「iOSおよびAndroid向けC＃でのモバイルアプリケーションの開発」</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>