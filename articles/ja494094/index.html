<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏾 👵 ✴️ 3Dは自分で行います。パート1：ピクセルとライン 🎐 👛 🥫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="このシリーズの記事は、3Dプログラミングの世界をゼロから探求したい読者、ゲームやアプリケーションの3Dコンポーネント作成の基本を学びたい人々に捧げたいと思います。既成の機能で高速化する場合でも、あらゆる面を理解できるように、一から実装していきます。学習したら、3Dを操作するための組み込みツールに切り...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>3Dは自分で行います。パート1：ピクセルとライン</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/494094/"><img src="https://habrastorage.org/webt/-u/-n/6a/-u-n6axbw6fowganklzotzai0sk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシリーズの記事は、3Dプログラミングの世界をゼロから探求したい読者、ゲームやアプリケーションの3Dコンポーネント作成の基本を学びたい人々に捧げたいと思います。</font><font style="vertical-align: inherit;">既成の機能で高速化する場合でも、あらゆる面を理解できるように、一から実装していきます。</font><font style="vertical-align: inherit;">学習したら、3Dを操作するための組み込みツールに切り替えます。</font><font style="vertical-align: inherit;">一連の記事を読んだ後、光、影、テクスチャ、効果を使用して複雑な3次元シーンを作成する方法、数学の深い知識なしにこれらすべてを行う方法などを理解します。</font><font style="vertical-align: inherit;">これらすべてを独立して、または既製のツールを使用して行うことができます。</font></font><br>
<a name="habracut"></a><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の部分では、以下を検討します。</font></font><br>
</b><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリングの概念（ソフトウェア、ハードウェア）</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピクセル/表面とは何ですか？</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライン出力の詳細分析</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
準備ができていない人には理解できないかもしれない記事を読む貴重な時間を無駄にしないために、私はすぐに要件に目を向けます。あらゆる言語でのプログラミングの基本を知っていれば、3Dに関する記事を安全に読み始めることができます。私は3Dプログラミングの研究にのみ焦点を当て、言語の特徴とプログラミングの基礎の研究には焦点を当てません。数学的準備については、ここでは心配しないでください。彼らは複雑な計算と猛烈な公式に怯えていますが、それは後に悪夢が夢見るからですが、実際に心配することは何もありません。 3Dに必要なすべてを可能な限り明確に説明するように努めますが、乗算、除算、加算、および減算ができる必要があります。したがって、選択基準を満たしている場合は、読み始めることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dの興味深い世界を探る前に、例としてプログラミング言語と開発環境を選択しましょう。 3Dグラフィックスのプログラミングにはどの言語を選択すればよいですか？誰でも、最も快適な場所で作業できます。数学はどこでも同じです。この記事では、すべての例をJSのコンテキストで示します（ここではトマトが飛んでいきます）。なぜjs？簡単です。最近は主に彼と一緒に仕事をしているので、本質をより効果的に伝えることができます。例ではJSのすべての機能をバイパスします。どの言語にもある最も基本的な機能だけが必要なので、特に3Dに注意を払います。でも好きなものを選ぶのは記事では、すべての式がプログラミング言語の機能に関連付けられるわけではありません。どの環境を選択しますか？それはどうでもいい事です、JSの場合、どのテキストエディターも適しています。より近いものを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての例では、次のようにキャンバスをペイントに使用します。これを使用すると、詳細な分析なしで非常にすばやく描画を開始できます。 Canvasは強力なツールであり、多くの既製の描画方法がありますが、そのすべての機能の中で、初めて、ピクセル出力のみを使用します！&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピクセルを使用した画面上のすべての3次元ディスプレイ。記事の後半で、これがどのように行われるかを確認します。遅くなりますか？ハードウェアアクセラレーション（たとえば、ビデオカードによるアクセラレーション）なし-になります。最初の記事では、アクセラレーションは使用しません。3Dの基本的な側面を理解するために、最初からすべてを記述します。将来の記事で言及されるいくつかの用語を見てみましょう。</font></font><br>
<br>
<ul>
<li><i> (Rendering)</i> —    3D-    . ,     3D-     ,        ,        .</li>
<li><i>  (Software Rendering) </i> —     .  ,  , ,    -  .       ,     .       3D-   ,    —  .</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハードウェアレンダリング</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -ハードウェア支援のレンダリングプロセス。</font><font style="vertical-align: inherit;">ゲームやアプリケーションで使用しています。</font><font style="vertical-align: inherit;">すべてが非常に速く動作します、なぜなら </font><font style="vertical-align: inherit;">多くのルーチンコンピューティングが、このために設計されたビデオカードを引き継ぎます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「年の定義」というタイトルは望みません。用語の説明はできるだけ明確に記載するようにしています。</font><font style="vertical-align: inherit;">主なことは、アイデアを理解することです。アイデアは、独自に開発できます。</font><font style="vertical-align: inherit;">また、理解を容易にするために、記事で紹介するすべてのコード例は速度が最適化されていないことが多いという事実にも注目したいと思います。</font><font style="vertical-align: inherit;">主なもの、つまり3Dグラフィックスのしくみを理解すると、自分ですべてを最適化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、プロジェクトを作成します。私にとって</font><font style="vertical-align: inherit;">は、次の内容</font><font style="vertical-align: inherit;">の単なるテキストの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index.html</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルです。</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>3D it’s easy. Part 1<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">&lt;!--         --&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"surface"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"800"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"600"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//    </span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、JSとキャンバスに重点を置きません。これらは、この記事のメインキャラクターではありません。</font><font style="vertical-align: inherit;">ただし、一般的な理解のために、&lt;canvas ...&gt;はすべてのグラフィックスを表示する長方形（この場合、サイズが800 x 600ピクセル）であることを明確にします。</font><font style="vertical-align: inherit;">キャンバスを一度登録しただけで、もう変更しません。</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span> … <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&nbsp;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリプト-（JavaScriptで）自分の手で3Dグラフィックスをレンダリングするためのすべてのロジックを記述する要素。&nbsp;</font><font style="vertical-align: inherit;">新しく作成したプロジェクトの</font><i><font style="vertical-align: inherit;">index.html</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ファイルの構造を確認したところで、</font><font style="vertical-align: inherit;">3Dグラフィックスの処理を開始します。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィンドウに何かを描画すると、モニターが表示するのはピクセルであるため、最終的なカウントのこれはピクセルになります。ピクセル数が多いほど画像は鮮明になりますが、コンピューターの負荷も高くなります。保存されたウィンドウに描画するものはどのように保存されますか？どのウィンドウのグラフィックもピクセルの配列として表すことができ、ピクセル自体は単なる色です。つまり、800x600の画面解像度は、ウィンドウにそれぞれ800ピクセルの600行が含まれていることを意味します。つまり、800 * 600 = 480000ピクセルですよね。ピクセルは配列に格納されます。ピクセルを格納する配列を考えてみましょう。 800 x 600ピクセルが必要な場合、最も明白なオプションは800 x 600の2次元配列です。これはほぼ正しいオプション、つまり完全に正しいオプションです。しかし、ウィンドウのピクセルは、480,000要素の1次元配列に格納することをお勧めします（解像度が800 x 600の場合）。1次元配列で作業する方が速いからです。連続したバイトシーケンスでメモリに保存されます（すべてが近くにあるため、簡単に取得できます）。 2次元配列（JSの場合など）では、各行がメモリ内の異なる場所に散在している可能性があるため、そのような配列の要素へのアクセスには時間がかかります。また、1次元の配列を並べ替えるには1サイクルしか必要ありません。2次元の整数2の場合、サイクルを何万回も繰り返す必要がある場合、速度はここで重要です。そのような配列のピクセルは何ですか？上記のとおり、これは単なる色、または3つのコンポーネント（赤、緑、青）です。いずれにしても、最もカラフルな画像でさえ、異なる色のピクセルの配列です。メモリ内のピクセルは、3つの要素の配列、または赤、グリー、青い;または、他の何か。解析したばかりのピクセルの配列で構成される画像です。引き続き表面を呼び出します。画面に表示されるものはすべてピクセルの配列に格納されているため、この配列の要素（ピクセル）を変更すると、画面上の画像がピクセルごとに変更されます。これがまさにこの記事で行うことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャンバスにはピクセル描画機能はありませんが、上記で説明したピクセルの1次元配列にアクセスできます。</font><font style="vertical-align: inherit;">これを行う方法を以下の例に示します（これと将来のすべての例は、script要素内にのみ含まれます）。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     ()    </span>
<span class="hljs-keyword">const</span> ctx = <span class="hljs-built_in">document</span>
.getElementById(<span class="hljs-string">'surface'</span>)<font></font>
.getContext(<span class="hljs-string">'2d'</span>)<font></font>
<font></font>
<span class="hljs-comment">//     ,   &nbsp;</span>
<span class="hljs-comment">// +       </span>
<span class="hljs-keyword">const</span> imageData = ctx.createImageData(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、imageDataは3つのプロパティがあるオブジェクトです。</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高さと幅</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -描画するウィンドウの高さと幅を格納する整数</font></font><br>
</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -8ビットの符号なし整数配列（0〜255の範囲の数値を格納できます）</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ配列は単純ですが説明的な構造です。</font><font style="vertical-align: inherit;">この1次元配列には、各ピクセルのデータが格納され、次の形式で画面に表示されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列の最初の4つの要素（インデックス0、1、2、3）は、最初の行の最初のピクセルのデータです。 2番目の4つの要素（インデックス4、5、6、7）は、最初の行の2番目のピクセルのデータです。ウィンドウの幅が800ピクセルである場合、最初の行の800番目のピクセルに到達すると、801番目のピクセルはすでに2番目の行に属しています。これを変更すると、画面上で2行目の1番目のピクセルが変更されたことがわかります（ただし、配列内のカウントによって801番目のピクセルになります）。配列の各ピクセルに4つの要素があるのはなぜですか？これは、キャンバスでは、赤、緑、青（これらは3つの要素）ごとに1つの要素を割り当てることに加えて、透明度（アルファチャネルまたは不透明度とも呼ばれます）のために1つの要素を割り当てるためです。アルファチャネルは、色と同様に、0（透明）〜255（不透明）の範囲で設定されます。この構造で、32ビットのイメージを取得し、各ピクセルは8ビットの4つの要素で構成されているためです。要約すると、各ピクセルには、赤、緑、青の色とアルファチャネル（透明度）が含まれています。この配色はARGB（Alpha Red Green Blue）と呼ばれます。また、各ピクセルが32ビットを占めるということは、32ビットの画像があることを意味します（色深度が32ビットの画像とも呼ばれます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトでは、ピクセルの配列imageData.data（データはピクセルの配列であり、imageDataは単なるオブジェクトであるプロパティ）全体に値0が入力されています。このような配列を出力しようとしても、画面には何も表示されません。0 、0、0は黒ですが、ここでの透明度も0であり、これは完全に透明な色であるため、画面に黒が表示されることもありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような1次元配列を直接操作するのは不便なので、描画用のメソッドを作成するクラスを作成します。クラスにはDrawerという名前を付けます。このクラスは必要なデータのみを格納し、必要な計算を実行して、レンダリングに使用されるツールから可能な限り抽象化します。そのため、すべての計算を配置し、その中で配列を操作します。そして、キャンバス上のdisplayメソッドの呼び出しそのものが、クラスの外側に配置されます。キャンバスの代わりに他の何かがあるかもしれません。この場合、クラスを変更する必要はありません。ピクセル（表面）の配列を操作するには、それをDrawerクラスに保存するだけでなく、画像の幅と高さを保存して、目的のピクセルに正しくアクセスできるようにする方が便利です。したがって、Drawerクラスは、描画に必要な最小限のデータを保持しながら、私には次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Drawer</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;surface = <span class="hljs-literal">null</span>
&nbsp;&nbsp;&nbsp;&nbsp;width = <span class="hljs-number">0</span>
&nbsp;&nbsp;&nbsp;&nbsp;height = <span class="hljs-number">0</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(surface, width, height) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface = surface
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.width = width
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.height = height<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンストラクタで確認できるように、Drawerクラスは必要なすべてのデータを取得して保存します。</font><font style="vertical-align: inherit;">これで、このクラスのインスタンスを作成し、ピクセル、幅、高さの配列をそのクラスに渡すことができます（上で作成してimageDataに保存したため、このデータはすべて揃っています）。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> drawer = <span class="hljs-keyword">new</span> Drawer(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.data,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.width,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.height<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Drawerクラスでは、将来の作業を容易にするために、いくつかの描画関数を記述します。</font><font style="vertical-align: inherit;">ピクセルを描画する関数、線を描画する関数、そして今後の記事では三角形やその他の図形を描画する関数が登場します。</font><font style="vertical-align: inherit;">しかし、ピクセル描画メソッドから始めましょう。</font><font style="vertical-align: inherit;">私は彼をdrawPixelと呼びます。</font><font style="vertical-align: inherit;">ピクセルを描画する場合、座標と色が必要です。</font></font><br>
<br>
<pre><code class="javascript hljs">drawPixel(x, y, r, g, b)&nbsp; { }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
drawPixel関数はalphaパラメータ（透明度）を受け入れないことに注意してください。また、ピクセル配列は3つのカラーパラメータと1つの透明度パラメータで構成されることがわかりました。透明度は具体的には示していません。例では絶対に必要ないからです。デフォルトでは、255に設定します（つまり、すべてが不透明になります）。次に、x、y座標のピクセルの配列に目的の色を書き込む方法について考えてみましょう。画像に関するすべての情報が1次元配列に格納されているので、各ピクセルに1ピクセル（8ビット）が割り当てられます。配列内の目的のピクセルにアクセスするには、赤の位置インデックスを決定する必要があります。これは、ピクセルがそれから始まるためです（たとえば、[r、g、b、a]）。配列の構造の簡単な説明：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uz/4j/8o/uz4j8olujyuhzo3z1anuexucnoc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
緑の表は、カラーコンポーネントが1次元のサーフェス配列に格納される方法を示しています。同じ配列内のそれらのインデックスは青で示され、一次元配列のインデックスに変換する必要があるdrawPixel関数を受け入れるピクセルの座標は、青のピクセルのr、g、b、aを示します。したがって、表から、各ピクセルについて、色の赤の成分が最初に来ることがわかります。それから始めましょう。 2 x 2ピクセルの画像サイズで座標X1Y1のピクセルの色の赤のコンポーネントを変更するとします。表では、これがインデックス12であることがわかりますが、それをどのように計算しますか？まず、必要な行のインデックスを見つけます。このために、画像の幅にYと4（ピクセルあたりの値の数）を掛けます。これは次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">width * y * 4 <font></font>
//  :<font></font>
2 * 1 * 4 = 8</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2行目がインデックス8で始まることがわかります。プレートと比較すると、結果は収束しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、目的の赤いインデックスを取得するために、見つかった行インデックスに列オフセットを追加する必要があります。</font><font style="vertical-align: inherit;">これを行うには、行インデックスにX倍4を追加します。完全な数式は次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">width * y * 4 + x * 4 <font></font>
//     :<font></font>
(width * y + x) * 4<font></font>
//  :<font></font>
(2 * 1 + 1) * 4 = 12</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、12とテーブルを比較して、ピクセルX1Y1が実際にはインデックス12で始まる</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ことを確認します。他の色成分のインデックスを見つけるには、カラーオフセットを赤のインデックスに追加する必要があります：+1（緑）、+ 2（青）、+ 3（アルファ） 。</font><font style="vertical-align: inherit;">これで、上記の式を使用して、Drawerクラス内にdrawPixelメソッドを実装できます。</font></font><br>
<br>
<pre><code class="javascript hljs">drawPixel(x, y, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> offset = (<span class="hljs-keyword">this</span>.width * y + x) * <span class="hljs-number">4</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset] = r
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">1</span>] = g
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">2</span>] = b
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">3</span>] = <span class="hljs-number">255</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このdrawPixelメソッドでは、式の繰り返し部分をオフセット定数にレンダリングしました。また、アルファでは255と書くだけです。構造内にありますが、ピクセルを出力する必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードをテストして、最後に画面の最初のピクセルを確認します。ピクセルレンダリングメソッドを使用した例を次に示します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     Drawer</span>
drawer.drawPixel(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
drawer.drawPixel(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
<font></font>
<span class="hljs-comment">//         canvas</span>
ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例では、2つのピクセルを描画します。1つは赤255、0、0、もう1つは青0、0、255です。ただし、imageData.data配列（Drawerクラス内のサーフェスでもある）の変更は画面に表示されません。描画するには、ctx.putImageData（imageData、0、0）を呼び出す必要があります。ここで、imageDataはピクセルの配列と描画領域の幅/高さのオブジェクトであり、0、0はピクセルの配列が表示される相対的なポイントです（常に0、0のままにします）。 ）すべてを正しく行った場合、ブラウザウィンドウのcanvas要素の左上に次の画像が表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d8/xn/cz/d8xnczchpgfg-9amhgdlyrpvzma.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピクセルが表示されましたか？それらはとても小さく、どれだけの作業が行われたかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、例にダイナミクスを少し追加してみましょう。たとえば、10ミリ秒ごとにピクセルが右にシフトするように（10ミリ秒ごとにXピクセルを+1ずつ変更します）、ピクセル描画コードを間隔を空けて1つずつ修正します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>
setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.drawPixel(x++, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
<font></font>
}, <span class="hljs-number">10</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、青いピクセルの出力のみを残し、JavaScriptでパラメーター10を使用してsetInterval関数をラップしました。つまり、コードは約10ミリ秒ごとに呼び出されます。このような例を実行すると、ピクセルが右にシフトするのではなく、次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8o/0v/uu/8o0vuuurtmmqgu8uy7sufdka16o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような長いストリップ（またはトレース）が残るのは、サーフェス配列の前のピクセルの色をクリアしないため、間隔が呼び出されるたびに、別のピクセルを追加します1ピクセル。表面を元の状態にきれいにするメソッドを書いてみましょう。つまり、配列をゼロで埋めます。 clearSurfaceメソッドをDrawerクラスに追加します。</font></font><br>
<br>
<pre><code class="javascript hljs">clearSurface() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> surfaceSize = <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height * <span class="hljs-number">4</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; surfaceSize; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[i] = <span class="hljs-number">0</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この配列にはロジックはなく、ゼロを埋め込むだけです。</font><font style="vertical-align: inherit;">新しい画像を描画する前に、毎回このメソッドを呼び出すことをお勧めします。</font><font style="vertical-align: inherit;">ピクセルアニメーションの場合、このピクセルを描画する前に：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>
setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.clearSurface()<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.drawPixel(x++, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
}, <span class="hljs-number">10</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例を実行すると、ピクセルは1つずつ右にシフトします-以前の座標からの不要なトレースはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の記事で最後に実装するのは、線の描画方法です。</font><font style="vertical-align: inherit;">もちろん、それをDrawerクラスに追加します。</font><font style="vertical-align: inherit;">drawLineを呼び出すメソッド。</font><font style="vertical-align: inherit;">彼は何をしますか？</font><font style="vertical-align: inherit;">点とは異なり、線にはまだ終点の座標があります。</font><font style="vertical-align: inherit;">言い換えると、ラインには開始、終了、色があり、メソッドに渡します。</font></font><br>
<br>
<pre><code class="javascript hljs">drawLine(x1, y1, x2, y2, r, g, b) { }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての線はピクセルで構成され、x1、y1からx2、y2までのピクセルを正しく埋めるためだけに残ります。まず、ラインはピクセルで構成されているため、ループ内のピクセルごとに出力しますが、出力するピクセル数を計算するにはどうすればよいでしょうか。たとえば、[0、0]から[3、0]に線を引くには、4ピクセル（[0、0]、[1、0]、[2、0]、[3、0]、）が必要であることは直感的に明らかです。しかし、[12、6]から[43、14]まで、ラインの長さ（表示するピクセル数）とそれらが持つ座標はまだ明確ではありません。これを行うには、少しジオメトリを思い出してください。したがって、x1、y1で始まり、x2、y2で終わる行があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/z7/ip/ouz7ipd2uiokmmijlro7wldayzw.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
三角形になるように、最初と最後から点線を引いてみましょう（上の図）。</font><font style="vertical-align: inherit;">描かれた線の接合部で90度の角度が形成されていることがわかります。</font><font style="vertical-align: inherit;">三角形にこのような角度がある場合、三角形は長方形と呼ばれ、角度が90度であるその辺はレッグと呼ばれます。</font><font style="vertical-align: inherit;">3番目の実線（描画しようとしている）は、三角形の斜辺と呼ばれます。</font><font style="vertical-align: inherit;">これら2つの導入されたレッグ（図のc1とc2）を使用して、ピタゴラスの定理を使用して斜辺の長さを計算できます。</font><font style="vertical-align: inherit;">それを行う方法を見てみましょう。</font><font style="vertical-align: inherit;">斜辺の長さ（または線の長さ）の式は次のようになります。&nbsp;</font></font><br>
<p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x433;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x438;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43F;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43E;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43D;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x443;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x437;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mo>=</mo><msqrt><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43A;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43A;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><msup><mn>2</mn><mn>2</mn></msup></msqrt></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="31.778ex" height="4.759ex" viewBox="0 -1401.3 13682.2 2049.1" role="img" focusable="false" style="vertical-align: -1.505ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text><g transform="translate(376,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(861,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1345,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1776,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(2152,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(2535,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3019,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3450,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3790,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhitAPJZ4xG0z9MV29U7fo1uFI9Q2w#MJMAIN-3D" x="4499" y="0"></use><g transform="translate(5555,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhitAPJZ4xG0z9MV29U7fo1uFI9Q2w#MJSZ2-221A" x="0" y="87"></use><rect stroke="none" width="7126" height="60" x="1000" y="1178"></rect><g transform="translate(1000,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text><g transform="translate(430,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(861,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1237,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1620,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1997,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhitAPJZ4xG0z9MV29U7fo1uFI9Q2w#MJMAIN-31" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhitAPJZ4xG0z9MV29U7fo1uFI9Q2w#MJMAIN-32" x="707" y="583"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhitAPJZ4xG0z9MV29U7fo1uFI9Q2w#MJMAIN-2B" x="3173" y="0"></use><g transform="translate(4174,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(4605,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5035,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5412,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5795,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(6171,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhitAPJZ4xG0z9MV29U7fo1uFI9Q2w#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhitAPJZ4xG0z9MV29U7fo1uFI9Q2w#MJMAIN-32" x="707" y="583"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mo>=</mo><msqrt><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><msup><mn>2</mn><mn>2</mn></msup></msqrt></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> = \sqrt{1^2 + 2^2}</script></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
三角形から両足の出し方も見えます。</font><font style="vertical-align: inherit;">ここで、上記の式を使用して、長いライン（ピクセル数）になる斜辺を見つけます。</font></font><br>
<br>
<pre><code class="javascript hljs">&nbsp;drawLine(x1, y1, x2, y2, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c1 = y2 - y1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
線を描画するために描画するピクセル数はすでにわかっています。しかし、ピクセルがどのようにシフトするかはまだわかりません。つまり、x1、y1からx2、y2に線を引く必要があります。線の長さは、たとえば20ピクセルになることがわかっています。最初のピクセルをx1、y1で描画し、最後のピクセルをx2、y2で描画できますが、中間のピクセルの座標を見つける方法は？これを行うには、x1、y1に関して次の各ピクセルをシフトして、目的のラインを取得する方法を取得する必要があります。私たちが話している変位の種類をよりよく理解するために、もう1つの例を挙げます。ポイント[0、0]と[0、3]があるので、それらに線を引く必要があります。この例から、[0、0]の後の次のポイントは[0、1]になり、次に[0、2]になり、最後に[0、3]になることがはっきりとわかります。つまり、各ポイントのXはシフトされなかった、または0ピクセルだけシフトされ、Yは1ピクセルシフトされたと言えます。これはオフセットです。[0、1]と書くことができます。別の例：ポイント[0、0]とポイント[3、6]があるので、それらがどのようにシフトするかを頭の中で計算してみましょう。最初は[0、0]、次に[0.5、1]、次に[1、2]です。次に[1.5、3]から[3、6]へと続きます。この例では、オフセットは[0.5、1]になります。計算方法は？&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の式を使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs">   = <span class="hljs-number">2</span> /  <font></font>
  Y = <span class="hljs-number">1</span> /  &nbsp;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムコードでは、次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> xStep = c2 / length
<span class="hljs-keyword">const</span> yStep = c1 / length</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのデータはすでにそこにあります。線の長さ、XとYに沿ったピクセルのオフセットです。描画するサイクルから始めます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.drawPixel(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r, g, b,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pixel関数のX座標として、Xラインの始点+オフセットX * iを渡して、i番目のピクセルの座標を取得し、Y座標も計算します。Math.truncは、数値の小数部分を破棄できるJSのメソッドです。</font><font style="vertical-align: inherit;">メソッドコード全体は次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs">drawLine(x1, y1, x2, y2, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c1 = y2 - y1
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> xStep = c2 / length
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> yStep = c1 / length<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.drawPixel(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r, g, b,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の部分は終わりました。3Dの世界を理解するための長くて刺激的な道のりです。</font><font style="vertical-align: inherit;">3次元はまだありませんでしたが、描画の準備操作を実行しました。ピクセル、線を描画する機能、ウィンドウをクリアする機能を実装し、いくつかの用語を学びました。</font><font style="vertical-align: inherit;">Drawerクラスのすべてのコードは、スポイラーの下で表示できます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドロワークラスコード</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Drawer</span> </span>{<font></font>
  surface = <span class="hljs-literal">null</span>
  width = <span class="hljs-number">0</span>
  height = <span class="hljs-number">0</span><font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(surface, width, height) {
    <span class="hljs-keyword">this</span>.surface = surface
    <span class="hljs-keyword">this</span>.width = width
    <span class="hljs-keyword">this</span>.height = height<font></font>
  }<font></font>
<font></font>
  drawPixel(x, y, r, g, b)  {<font></font>
    <span class="hljs-keyword">const</span> offset = (<span class="hljs-keyword">this</span>.width * y + x) * <span class="hljs-number">4</span><font></font>
<font></font>
    <span class="hljs-keyword">this</span>.surface[offset] = r
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">1</span>] = g
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">2</span>] = b
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">3</span>] = <span class="hljs-number">255</span><font></font>
  }<font></font>
<font></font>
  drawLine(x1, y1, x2, y2, r, g, b) {<font></font>
    <span class="hljs-keyword">const</span> c1 = y2 - y1
    <span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
    <span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)<font></font>
<font></font>
    <span class="hljs-keyword">const</span> xStep = c2 / length
    <span class="hljs-keyword">const</span> yStep = c1 / length<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; length ; i++) {
        <span class="hljs-keyword">this</span>.drawPixel(
          <span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
          <span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
          r, g, b,<font></font>
        )<font></font>
    }<font></font>
  }<font></font>
<font></font>
  clearSurface() {<font></font>
    <span class="hljs-keyword">const</span> surfaceSize = <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height * <span class="hljs-number">4</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; surfaceSize; i++) {
      <span class="hljs-keyword">this</span>.surface[i] = <span class="hljs-number">0</span><font></font>
    }<font></font>
  }<font></font>
}<font></font>
</code></pre></div></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次は何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次回の記事では、ピクセルとラインの出力などの単純な操作が興味深い3Dオブジェクトにどのように変化するかを見ていきます。</font><font style="vertical-align: inherit;">マトリックスとその操作に慣れ、ウィンドウに3次元オブジェクトを表示し、さらにアニメーションを追加します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja494076/index.html">分析：株式市場の暴落時の投資家行動戦略</a></li>
<li><a href="../ja494082/index.html">ダレンカ：自宅からの効果的な仕事に関する最も役立つ記事</a></li>
<li><a href="../ja494084/index.html">コロナウイルス：オンライン情報サービス</a></li>
<li><a href="../ja494090/index.html">Celeryスロットリング-キューのレート制限の設定</a></li>
<li><a href="../ja494092/index.html">接続された構造の劣化</a></li>
<li><a href="../ja494096/index.html">イントラネットの展開。経験、間違い、推奨事項</a></li>
<li><a href="../ja494098/index.html">Jetbrains KTorおよびR2DBCの例に関する反応データへの命令的アプローチ</a></li>
<li><a href="../ja494100/index.html">ITスペシャリストをトレーニングするための教育センターの理想的なモデルを作成するために必要なもの</a></li>
<li><a href="../ja494106/index.html">健康な人のためのページオブジェクトクラスを作成するためのヒント</a></li>
<li><a href="../ja494108/index.html">パーソナライズされたインターフェイス。パート1.コンセプトの長所と短所</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>