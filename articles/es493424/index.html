<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê≥ üñ®Ô∏è üìÖ Implementamos conversiones de c√≥digo Python üîë üéé üèÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr 
 
 Hoy le ofrecemos una traducci√≥n de un art√≠culo que toca un tema que no es el m√°s discutido: la compilaci√≥n de c√≥digo en Python, a saber:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Implementamos conversiones de c√≥digo Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/493424/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hola Habr </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoy le ofrecemos una traducci√≥n de un art√≠culo que toca un tema que no es el m√°s discutido: la compilaci√≥n de c√≥digo en Python, a saber: trabajar con √°rbol de sintaxis abstracta (AST) y c√≥digo de bytes. Si bien Python es un lenguaje interpretado, tales caracter√≠sticas son extremadamente importantes desde el punto de vista de la optimizaci√≥n. Hablaremos de ellos hoy.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øAlguna vez te has preguntado c√≥mo exactamente el compilador optimiza tu c√≥digo para que funcione m√°s r√°pido? </font><font style="vertical-align: inherit;">¬øQuiere saber qu√© es un √°rbol de sintaxis abstracta (AST) y para qu√© se puede utilizar? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este art√≠culo de revisi√≥n describe c√≥mo el c√≥digo Python se convierte en forma de √°rbol (AST). </font><font style="vertical-align: inherit;">Despu√©s de crear el AST de su programa, puede continuar buscando oportunidades para optimizar y transformar su c√≥digo. </font><font style="vertical-align: inherit;">Sin embargo, tenga en cuenta que optimizar los programas de Python de manera no trivial es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extremadamente dif√≠cil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥digo de programa como un √°rbol</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo puede una computadora asegurarse de que eval√∫a las expresiones de su c√≥digo en el orden correcto? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer esto, primero rehace el c√≥digo de su programa en una estructura de √°rbol llamada AST. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando se trabaja con un lenguaje de programaci√≥n interpretado (como Python), generalmente se acepta que el int√©rprete pasa a trav√©s de su c√≥digo y hace todo lo que encuentra, directamente, sin convertir el c√≥digo de Python en c√≥digo de m√°quina de ninguna manera. Sin embargo, en la pr√°ctica, este esquema de ejecuci√≥n provoca muchos problemas, lo que lo hace muy inconveniente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tomemos, por ejemplo, un problema tan simple como la prioridad de los operadores. En una expresi√≥n de vista </font></font><code>3 + 4 * x </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la parte se calcula primero</font></font><code>4 * x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y solo entonces se puede agregar 3 al resultado de la multiplicaci√≥n. Quiz√°s aprendi√≥ la precedencia de los operadores en las clases de matem√°ticas al dibujar estos √°rboles bajo la expresi√≥n: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xw/lr/sp/xwlrspwopyld8gohdzt4jxgwauu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python usa las reglas est√°ndar de notaci√≥n matem√°tica (primero la multiplicaci√≥n, luego la suma). Para no confundir nada con la prioridad de los operadores, en Python, al principio se construye un √°rbol como en la imagen anterior. La operaci√≥n general es la suma (en la ra√≠z del √°rbol), y aunque el lado izquierdo de esta suma es un n√∫mero regular, a la derecha tenemos el producto. La estructura de datos resultante se ve as√≠:</font></font><br>
<br>
<pre><code class="python hljs">BinOp(<font></font>
  left  = Num(<span class="hljs-number">3</span>),<font></font>
  op    = Add(),<font></font>
  right = BinOp(<font></font>
            left  = Num(<span class="hljs-number">4</span>),<font></font>
            op    = Mult(),<font></font>
            right = Name(<span class="hljs-string">'x'</span>)<font></font>
          )<font></font>
)<font></font>
</code></pre><br>
<code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significa Operaci√≥n binaria (Operaci√≥n binaria) e indica que en operaciones como la suma y la multiplicaci√≥n, dos operandos. Naturalmente, no obtendr√° ninguna adici√≥n si la parte correcta de la expresi√≥n no tiene el valor correcto; por lo tanto, primero debe multiplicar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la teor√≠a de compiladores y lenguajes de programaci√≥n, dicho √°rbol se llama </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Årbol de sintaxis abstracta</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AST</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para abreviar. El AST en el ejemplo anterior incluye dos nodos </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dos nodos </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y un nodo </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay una buena caracter√≠stica en Python: la capacidad de ver y mostrar directamente AST para cualquier programa Python en particular. Todo lo que se requiere es importar un m√≥dulo est√°ndar</font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, analiza el programa y luego muestra el resultado en la pantalla (por cierto, el an√°lisis es el proceso de convertir el c√≥digo fuente del programa al √°rbol AST).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
my_tree = ast.parse(<span class="hljs-string">"3 + 4*x"</span>)<font></font>
print(ast.dump(my_tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, notar√° que habr√° nodos y campos adicionales en el AST generados por Python, y se mostrar√° en una l√≠nea, lo que hace que parezca m√°s complicado a primera vista de lo que realmente es. </font></font><br>
<br>
<pre><code class="python hljs">Module(body=[Expr(value=BinOp(left=Num(n=<span class="hljs-number">3</span>), op=Add(), right=BinOp(left=Num(n=<span class="hljs-number">4</span>), op=Mult(), right=Name(id=<span class="hljs-string">'x'</span>, ctx=Load()))))])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Divid√°moslo en nodos separados, como la √∫ltima vez, y volvamos a abrir el AST, que ya est√° en la parte superior, como parte de todo el √°rbol: </font></font><br>
<br>
<pre><code class="python hljs">Module(body = [<font></font>
    Expr(<font></font>
        value = BinOp(<font></font>
            left  = Num(n=<span class="hljs-number">3</span>),<font></font>
            op    = Add(),<font></font>
            right = BinOp(<font></font>
                left  = Num(n=<span class="hljs-number">4</span>),<font></font>
                op    = Mult(),<font></font>
                right = Name(id=<span class="hljs-string">'x'</span>, ctx=Load())<font></font>
            )<font></font>
        )<font></font>
    )<font></font>
])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, Python "piensa" que la l√≠nea que le dimos para analizar es un m√≥dulo completo. El cuerpo del m√≥dulo es una lista de todas las instrucciones que contiene. La √∫nica instrucci√≥n en nuestro ejemplo es una expresi√≥n </font></font><code>Expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuyo significado es exactamente lo que discutimos anteriormente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota: el nodo </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene un campo adicional </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(abreviado como "contexto"), que tiene un valor </font></font><code>Load()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Entonces Python dice que usamos el valor almacenado en la variable </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y no (re) definimos o eliminamos el nombre </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ahora su movimiento, intenta analizar algo as√≠ </font></font><code>del x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font><font style="vertical-align: inherit;">usted mismo </font></font><code>x = 123</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y ver√° c√≥mo el campo </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el nodo de </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cambios a </font></font><code>Del()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o </font></font><code>Store()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, respectivamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto: si instala el m√≥dulo</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">astunparse</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la salida de AST a la pantalla se puede hacer mucho m√°s bella e incluso convertir la AST nuevamente en c√≥digo Python en vivo.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El proceso de compilaci√≥n: el resto</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez recopilados los programas AST, en principio es posible completar todo el programa pasando por el AST y realizando las operaciones en el orden en que se indican. Sin embargo, este enfoque tiene al menos dos inconvenientes. En primer lugar, AST puede ocupar una cantidad relativamente grande de memoria, especialmente si contiene informaci√≥n redundante. En segundo lugar, el recorrido AST puede llevar m√°s tiempo del necesario. En resumen: se puede hacer, pero es ineficiente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El compilador no procesa el AST directamente, sino que prepara el c√≥digo de bytes, que luego se ejecuta en la m√°quina virtual Python. Aunque discutir los detalles de este proceso est√° m√°s all√° del alcance de este art√≠culo, el principio b√°sico es que el compilador traduce el AST en notaci√≥n polaca inversa (RPN). En lugar de poner un operador</font></font><code>+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entre los operandos izquierdo y derecho, lo colocamos despu√©s de ambos operandos. En el ejemplo </font></font><code>3 + 4*x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anterior, obtenemos la secuencia </font></font><code>3 4 x * +</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(y esta notaci√≥n es especialmente buena porque puedes ver inmediatamente de la secuencia: primero debes realizar la multiplicaci√≥n, y solo luego la suma). Como cada uno de los cinco elementos en esta secuencia puede representarse en principio como un solo byte, dicho c√≥digo se llama c√≥digo de byte. Python luego usa la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√°quina virtual apilada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para ejecutar eficientemente este c√≥digo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En otras palabras, el proceso de compilaci√≥n de un programa escrito en Python tiene lugar en dos etapas. </font><font style="vertical-align: inherit;">Primero, el programa recibido por la entrada se analiza y el resultado es un √°rbol de sintaxis abstracta (AST). </font><font style="vertical-align: inherit;">El compilador luego pasa a trav√©s de AST y genera bytecode. </font><font style="vertical-align: inherit;">Despu√©s de eso, el int√©rprete de Python ejecuta este bytecode. </font><font style="vertical-align: inherit;">Una vez adoptada la optimizaci√≥n, puede aplicarse tanto a nivel AST como a nivel de bytecode. </font><font style="vertical-align: inherit;">Ambas opciones tienen sus propias ventajas y desventajas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, tenga en cuenta que aunque AST es com√∫n en cualquier implementaci√≥n de Python, el proceso de traducir AST a bytecode puede ser diferente, y en algunas implementaciones de Python, digamos, JavaScript, en lugar de bytecode, puede generarse en la etapa intermedia.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paradigmas de otros lenguajes de programaci√≥n.</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No todos los lenguajes de programaci√≥n usan notaci√≥n infija, como en Python. </font><font style="vertical-align: inherit;">Dos ejemplos dignos de menci√≥n en este caso son PostScript, donde el programa se escribe directamente en notaci√≥n polaca inversa, y Lisp, por supuesto, donde los programas generalmente se escriben en notaci√≥n polaca. </font><font style="vertical-align: inherit;">Por lo tanto, nuestra expresi√≥n del ejemplo anterior, en Lisp podr√≠a adoptar la forma siguiente: </font></font><code>(+ 3 (* 4 x))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conversi√≥n de nodos dentro de AST</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teniendo un programa AST, ¬øc√≥mo convertir partes individuales de este √°rbol? Con las pr√°cticas funciones integradas de Python. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si echamos un vistazo a AST y, por ejemplo, encontramos que tanto los campos </font></font><code>left</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como los </font></font><code>right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nodos </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">son n√∫meros (nodos </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), podemos realizar los c√°lculos correspondientes de antemano y luego reemplazarlos por un </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nodo normal </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, debe actuar con mucho cuidado para no cambiar el comportamiento del programa, haciendo tales transformaciones. Por ejemplo, en </font></font><code>len([a(), b(), c(), d()])</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, est√° claro que el resultado es 4. Sin embargo, no puede sustituir a toda la expresi√≥n del n√∫mero 4 porque cuatro funciones </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todav√≠a han invocado correctamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuevamente, comience con una optimizaci√≥n simple. Siempre que aparezca un nombre en el c√≥digo fuente de un programa </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, reempl√°celo con el valor 3.14159265. El m√≥dulo Python </font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ya proporciona las estructuras de datos necesarias para hacer esto: una clase de convertidor </font></font><code>NodeTransformer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que pasa por todos los AST y verifica para cada nodo si se puede reemplazar. Por defecto, el m√©todo de transformaci√≥n simplemente devuelve el nodo fuente para cada nodo, de modo que obtengamos el mismo AST desde el que comenzamos. Pero podemos anular f√°cilmente el m√©todo para los nodos </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por ejemplo, para que verifique </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si es as√≠, y luego devuelve el nodo en </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lugar del nodo con el nombre original ...</font></font><br>
<br>
<pre><code class="python hljs">	<span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:
            <span class="hljs-keyword">return</span> ast.Num(n=<span class="hljs-number">3.14159265</span>)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que el convertidor / optimizador atraviese nuestro √°rbol, es necesario llamar a su m√©todo </font></font><code>visit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que luego devolver√° un √°rbol nuevo y modificado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desafortunadamente, es imposible compilar y ejecutar el AST resultante, la raz√≥n de esto es un detalle t√©cnico. Esto a√∫n no es visible, pero (casi) todos los nodos en el AST tambi√©n tienen campos </font></font><code>lineno</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>col_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Indican la posici√≥n exacta de un nodo particular en el c√≥digo fuente. Si no los instala correctamente, el compilador jurar√° y se negar√° a trabajar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, copiemos los campos apropiados del nodo fuente </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al nuevo nodo </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Luego puede compilar y ejecutar el AST resultante:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)<font></font>
            result.lineno = node.lineno<font></font>
            result.col_offset = node.col_offset<font></font>
            <span class="hljs-keyword">return</span> result
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"print(2 * pi)"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
code = compile(tree, <span class="hljs-string">"&lt;string&gt;"</span>, <span class="hljs-string">"exec"</span>)<font></font>
exec(code)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la funci√≥n de compilaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requiere no s√≥lo el c√≥digo fuente (en el que puede ser un programa en s√≠, o la l√≠nea AST), pero el nombre de archivo (como pedimos </font></font><code>"&lt;string&gt;"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), as√≠ como uno de los tres: </font></font><code>"exec"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>"eval"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>"single"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La necesidad de copiar los campos que describen la posici√≥n del nodo en el c√≥digo fuente surge con bastante frecuencia. Por lo tanto, el m√≥dulo </font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene una funci√≥n dedicada </font></font><code>copy_location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo para este prop√≥sito, y podemos escribir:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, puede ampliar el ejemplo anterior para que realmente realice la optimizaci√≥n, es decir, en el nodo </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De acuerdo con la regla de transformaci√≥n, primero debemos transformar / optimizar el nodo izquierdo y luego el nodo derecho como parte de BinOp. </font><font style="vertical-align: inherit;">Si, como resultado, los nodos izquierdo y derecho son n√∫meros, entonces los c√°lculos se pueden realizar en el acto y reemplazar el original con el </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resultado num√©rico de la operaci√≥n.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_BinOp</span>(<span class="hljs-params">self, node: ast.BinOp</span>):</span><font></font>
        node.left = self.visit(node.left)<font></font>
        node.right = self.visit(node.right)<font></font>
        <span class="hljs-keyword">if</span> isinstance(node.left, ast.Num) <span class="hljs-keyword">and</span> isinstance(node.right, ast.Num):
            <span class="hljs-keyword">if</span> isinstance(node.op, ast.Add):<font></font>
                result = ast.Num(n = node.left.n + node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
            <span class="hljs-keyword">elif</span> isinstance(node.op, ast.Mult):<font></font>
                result = ast.Num(n = node.left.n * node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi + 1"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, el compilador CPython ya est√° optimizando nodos </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como se muestra aqu√≠. </font><font style="vertical-align: inherit;">El c√≥digo correspondiente se escribe en C y se proporciona en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python / ast_opt.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tenga en cuenta: el optimizador de CPython es m√°s universal y funciona no solo con n√∫meros, como en el ejemplo que estamos considerando, sino con diferentes tipos de valores constantes.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comprobaci√≥n de nodos en AST</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo asegurarnos de que las transformaciones que hicimos fueron correctas? Primero debe omitir por completo AST e inspeccionar todo el programa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El optimizador presentado anteriormente sigue siendo un grave defecto. ¬øQu√© sucede si redefine en alg√∫n lugar del programa </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Solo imagina algo tan simple e inteligible como </font></font><code>pi = 4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nuestro optimizador simplemente reemplazar√° pi en el lado izquierdo de la expresi√≥n con el valor num√©rico 3.14159265, y Python se negar√° a compilar porque no puede asignar nada a un valor literal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quiz√°s este sea precisamente el comportamiento que buscaba, haciendo de pi una verdadera constante, que se reemplaza en la compilaci√≥n y nunca se puede reasignar, es decir, no puede obtener un valor diferente. Sin embargo, esto definitivamente viola la sem√°ntica de Python.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ¬øqu√© hacer si queremos mantener la sem√°ntica de Python, pero reemplazar pi de todos modos siempre que sea posible? En este caso, primero debe revisar todo el programa y verificar si el valor de est√° asignado en alguna parte </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Hasta que lo compliquemos: no recurriremos a reemplazar pi si al menos un punto del programa tiene una asignaci√≥n de valor a </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora usamos el nodo visitante, similar al nodo convertidor descrito anteriormente. A diferencia del convertidor, el visitante no tiene la intenci√≥n de cambiar ning√∫n nodo, simplemente pasa por el AST y examina los nodos (los visita). En consecuencia, los m√©todos de visita no devuelven nada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestro caso, se comprueba si el nodo se refiere </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y hace otra cosa que cargar el valor</font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(recuerda el campo de contexto </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeVisitor</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>
        self.modify_pi = <span class="hljs-literal">False</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_FunctionDef</span>(<span class="hljs-params">self, node: ast.FunctionDef</span>):</span>
        <span class="hljs-keyword">if</span> node.name == <span class="hljs-string">'pi'</span>:<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
        self.generic_visit(node)<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> isinstance(node.ctx, ast.Load):<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
 <font></font>
program = <span class="hljs-string">"""
def pi():
    return 3.1415
print(2 * pi())
"""</span><font></font>
tree = ast.parse(program)<font></font>
my_visitor = MyVisitor()<font></font>
my_visitor.visit(tree)<font></font>
print(<span class="hljs-string">"Pi modified:"</span>, my_visitor.modify_pi)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El </font></font><code>generic_visit(node)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">visitante llama al </font><font style="vertical-align: inherit;">m√©todo </font><font style="vertical-align: inherit;">para cada nodo para el que no proporcionamos un m√©todo de visita especializado. </font><font style="vertical-align: inherit;">En otras palabras: no existe tal m√©todo </font></font><code>visit_FunctionDef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la clase </font></font><code>NodeVisitor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que podr√≠amos llamar usando </font></font><code>super()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Con respecto a las definiciones de funciones, debemos llamar a un visitante gen√©rico para asegurarnos de que todo el cuerpo de la funci√≥n tambi√©n se procese correctamente. </font><font style="vertical-align: inherit;">De lo contrario, podr√≠amos ocultar las instrucciones en la funci√≥n </font></font><code>global pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y cambiar globalmente el valor </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para que nuestro optimizador no note nada.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valores locales en Python</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro m√©todo, que nos permite determinar si el programador ha cambiado pi, result√≥ ser bastante grosero. </font><font style="vertical-align: inherit;">Sin embargo, el compilador de Python act√∫a de manera muy similar cuando determina qu√© nombres en el alcance de una funci√≥n corresponden a variables locales. </font><font style="vertical-align: inherit;">Si una variable cambia en alg√∫n lugar del alcance de la funci√≥n (y no se hace expl√≠citamente global, por ejemplo, usando la instrucci√≥n global), entonces esta variable se considera local en todo el alcance de la funci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente ejemplo se ejecutar√° bien sin la cuarta l√≠nea. </font><font style="vertical-align: inherit;">Pero, aunque </font></font><code>x = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la cuarta l√≠nea nunca se ejecuta, todav√≠a se considera una asignaci√≥n a</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y por lo tanto, x se convierte en una variable local en la escala de toda la funci√≥n, e incluso en la l√≠nea 3. Es por eso que Python jurar√° que la variable x en la tercera l√≠nea todav√≠a no importa.</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_x</span>():</span><font></font>
    print(x)<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>: x = <span class="hljs-number">0</span>
print_x()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si est√° interesado en los detalles de c√≥mo funciona exactamente Python aqu√≠, consulte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python / symtable.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi√≥n</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Python, como en la mayor√≠a de los lenguajes de programaci√≥n, un programa en particular no se ejecuta directamente desde el c√≥digo fuente. </font><font style="vertical-align: inherit;">De hecho, la traducci√≥n del c√≥digo fuente tiene lugar en dos etapas: primero, se crea un √°rbol de sintaxis abstracta (AST), y luego el c√≥digo de bytes para la m√°quina virtual apilada. </font><font style="vertical-align: inherit;">Python tambi√©n proporciona una serie de caracter√≠sticas muy agradables para analizar e incluso transformar el AST de cualquier programa Python en particular, despu√©s de lo cual el AST modificado se puede compilar y ejecutar. </font><font style="vertical-align: inherit;">Por lo tanto, podemos implementar f√°cilmente nuestras propias optimizaciones.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, simplemente omit√≠ muchos detalles aqu√≠. </font><font style="vertical-align: inherit;">Asegurarse de que su optimizaci√≥n funcionar√° correctamente en todos los casos y circunstancias posibles es una cuesti√≥n muy trivial. </font><font style="vertical-align: inherit;">Sin embargo, el prop√≥sito de este art√≠culo no es informarle sobre la optimizaci√≥n que est√° lista para su uso en producci√≥n, sino dar una idea b√°sica de c√≥mo Python analiza el c√≥digo de su programa para que pueda aprender c√≥mo convertirlo correctamente y luego optimizarlo.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es493408/index.html">El mini helic√≥ptero DJI Mavic cay√≥ como una palanca</a></li>
<li><a href="../es493412/index.html">Juegos con Wifi en ESP32</a></li>
<li><a href="../es493416/index.html">IDA Pro y t√©cnicas de ingenier√≠a inversa</a></li>
<li><a href="../es493418/index.html">¬øPor qu√© el aprendizaje autom√°tico utiliza datos "sint√©ticos"?</a></li>
<li><a href="../es493420/index.html">Mi manera de presentar a los estudiantes de secundaria a Python</a></li>
<li><a href="../es493426/index.html">Organizaci√≥n de c√≥digo en microservicios y mi enfoque de usar arquitectura hexagonal y DDD</a></li>
<li><a href="../es493428/index.html">"No daremos lugar a teor√≠as de conspiraci√≥n". Hable sobre conferencias de ML con personas de compa√±√≠as de ciencia y TI</a></li>
<li><a href="../es493430/index.html">Arquitectura de red para aplicaciones web</a></li>
<li><a href="../es493432/index.html">¬øPor qu√© no comenzar una carrera en una peque√±a empresa que no es de TI?</a></li>
<li><a href="../es493436/index.html">Programa para cambiar los derechos de acceso y el registro de nombres de archivo / directorio en Bash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>