<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌉 📝 🎷 Computer Vision Mail.ruチームのモデリング経験 👌 🈂️ 🧛🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eduard Tyantovと申します。Mail.ruGroupのコンピュータビジョンチームのリーダーです。私たちのチームは数年にわたってコンピュータビジョンに関する数十の問題を解決してきました。今日では、さまざまなタスクで機能する機械学習モデルを作成するために使用する方法について説明します。タスク...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Computer Vision Mail.ruチームのモデリング経験</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/460307/"><img src="https://habrastorage.org/webt/zz/gc/py/zzgcpycxxdaz-0a657wzkvjlvos.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eduard Tyantovと申します。Mail.ruGroupのコンピュータビジョンチームのリーダーです。</font><font style="vertical-align: inherit;">私たちのチームは数年にわたってコンピュータビジョンに関する数十の問題を解決してきました。今日では、さまざまなタスクで機能する機械学習モデルを作成するために使用する方法について説明します。</font><font style="vertical-align: inherit;">タスクの設定、データの準備、本番環境でのトレーニングとデプロイのすべての段階でモデルを高速化できるトリックを共有します。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mail.ruのコンピュータビジョン</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、Mail.ruのコンピュータビジョンとは何か、そして私たちが行うプロジェクトは何ですか。 Mail、Mail.ru Cloud（写真とビデオを保存するためのアプリケーション）、Vision（コンピュータビジョンに基づくB2Bソリューション）などのソリューションを提供しています。いくつか例を挙げます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラウド（これは私たちの最初の主要なクライアントです）は600億枚の写真を保持しています。顔認識や観光など、機械学習に基づいてスマート処理するさまざまな機能を開発しています（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これについては別の投稿があります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。すべてのユーザーの写真は認識モデルを介して実行されます。これにより、人やタグ、訪れた都市や国などで検索やグループ化を整理できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dc/ls/ug/dclsugao8xumevprode0ift5dxq.jpeg"><img src="https://habrastorage.org/webt/zr/bo/rd/zrbordgq4zygrzpzvmsg5x0nt6i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メールについては、OCRを行いました-画像からのテキストの認識。</font><font style="vertical-align: inherit;">今日はもう少し彼について話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
B2B製品については、キューにいる人の認識とカウントを行います。</font><font style="vertical-align: inherit;">たとえば、スキー場のリフトのキューがあり、そこに何人がいるかを計算する必要があります。</font><font style="vertical-align: inherit;">まず、テクノロジーとプレイをテストするために、オフィスのダイニングルームにプロトタイプを展開しました。</font><font style="vertical-align: inherit;">複数のキャッシュデスクがあり、それに応じて複数のキューがあり、モデルを使用して、複数のカメラ（各キューに1つ）を使用して、キューに何人がいて、それぞれにおよそ何分残っているかを数えます。</font><font style="vertical-align: inherit;">これにより、ダイニングルームのラインのバランスをより良くすることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yr/yq/hb/yryqhbu5zqhxm_fozg-4ygkz6i4.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の定式化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクの重要な部分、つまりその定式化から始めましょう。ほとんどすべてのML開発には少なくとも1か月かかります（これは、何をすべきかを知っている場合に最高です）。多くの場合、数か月かかります。タスクが正しくない、または不正確である場合、作業の最後に、プロダクトマネージャーから精神的に何かを聞く可能性が高くなります。これは良くない。他のものが欲しかった。」これを防ぐには、いくつかの手順を実行する必要があります。 MLベースの製品の特別な点は何ですか？サイトを開発するタスクとは異なり、機械学習のタスクはテキストだけで形式化することはできません。さらに、原則として、準備ができていない人にとっては、すべてがすでに明白であるように見え、すべてを「美しく」行うだけでよいのです。そして、どんな小さな詳細でも、タスクマネージャーはそれらを知らない、考えたことがない、考えないかもしれません。彼が最終製品を見て、「何をしましたか？」</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題が何であるかを例によって理解しましょう。</font><font style="vertical-align: inherit;">顔認識タスクがあるとします。</font><font style="vertical-align: inherit;">あなたはそれを受け取り、喜んで母親に電話します。</font><font style="vertical-align: inherit;">しかし、直接分解して実行を開始することは可能ですか？</font><font style="vertical-align: inherit;">これを行うと、最後に驚きが予想されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">国籍はさまざまです。</font><font style="vertical-align: inherit;">たとえば、データセットにはアジア人や他の誰もいませんでした。</font><font style="vertical-align: inherit;">したがって、モデルはそれらをどのように認識するかをまったく知らず、製品はそれを必要とします。</font><font style="vertical-align: inherit;">またはその逆で、修正にさらに3か月を費やした場合、製品には白人のみが含まれ、これは不要でした。</font></font><br>
</li>
<li> .    ,  ,     .     ,         —   ,    ! ;)   ,    ,   .      .      ,            (true story).<br>
</li>
<li>    ,  .     ? <br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなタスクの側面は、最初に特定することが非常に重要です。したがって、最初から「データについて」作業を行い、マネージャーと通信する必要があります。口頭による説明はお受けできません。データを見る必要があります。モデルが機能するのと同じ分布から望ましいものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的には、このディスカッションの過程で、最終的にモデルを実行し、マネージャーが意図したとおりに機能するかどうかを確認できるテストデータセットが取得されます。テストデータセットの一部を管理者自身に渡して、アクセスできないようにすることをお勧めします。このテストセットは簡単に再トレーニングできるため、ML開発者です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MLでタスクを設定することは、プロダクトマネージャーとMLのスペシャリストの間で常に行われる作業です。最初にタスクを適切に設定したとしても、モデルが発展するにつれて、ますます新しい問題が現れ、データについて学習する新しい機能が現れます。これらすべては常にマネージャーと話し合う必要があります。優れたマネージャーは、責任を持ってマネージャーがタスクを設定できるように支援する必要があることを、MLチームに常にブロードキャストします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何故ですか？</font><font style="vertical-align: inherit;">機械学習はかなり新しい分野です。</font><font style="vertical-align: inherit;">管理者は、そのようなタスクを管理した経験がありません（またはほとんどありません）。</font><font style="vertical-align: inherit;">どのくらいの頻度で人々は新しい問題を解決することを学びますか？</font><font style="vertical-align: inherit;">間違いについて。</font><font style="vertical-align: inherit;">お気に入りのプロジェクトをミスにしたくない場合は、関与して責任を取り、プロダクトマネージャーにタスクを正しく設定し、チェックリストとポリシーを作成するように教える必要があります。</font><font style="vertical-align: inherit;">これはすべて非常に役立ちます。</font><font style="vertical-align: inherit;">新しい興味深いタスクが到着するたびに私は自分自身を引き離す（または私の同僚の誰かが私を引き離す）たびに、実行します。</font><font style="vertical-align: inherit;">私があなたに言ったすべて、私自身は忘れています。</font><font style="vertical-align: inherit;">したがって、自分自身をチェックするためのチェックリストのようなものを持つことが重要です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MLではデータは非常に重要です。</font><font style="vertical-align: inherit;">ディープラーニングの場合、モデルに供給するデータが多ければ多いほどよいでしょう。</font><font style="vertical-align: inherit;">青いグラフは、通常、ディープラーニングモデルがデータを追加すると大幅に向上することを示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/1x/wf/bb/1xwfbbc7-os0p9wjc8y_2iiyn10.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ある時点からの「古い」（古典的な）アルゴリズムはもはや改善できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、MLではデータセットはダーティです。彼らは常に嘘をつく人々によってマークされました。査定者はしばしば無関心であり、多くの間違いを犯します。この手法を使用します。保有しているデータを取得してモデルをトレーニングし、このモデルの助けを借りてデータを消去してサイクルを繰り返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ顔認識の例を詳しく見てみましょう。 VKontakteユーザーのアバターをダウンロードしたとしましょう。たとえば、4つのアバターを持つユーザープロファイルがあります。 4つの画像すべてにある顔を検出し、顔認識モデルを実行します。そのため、人の埋め込みを取得します。これにより、類似の人をグループ（クラスター）に「接着」できます。次に、ユーザーのアバターに主に顔が含まれていると仮定して、最大のクラスターを選択します。したがって、この方法で他のすべての面（ノイズ）を除去できます。その後、サイクルを再度繰り返すことができます。クリーンアップされたデータで、モデルをトレーニングし、それを使用してデータをクリーンアップします。複数回繰り返すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、このようなクラスタリングにはCLinkアルゴリズムを使用します。これは、類似のオブジェクトを「接着」するためのしきい値を設定すると非常に便利な階層型クラスタリングアルゴリズムです（これは、クリーニングに必要なものにすぎません）。 CLinkは球状クラスターを生成します。私たちはこれらの埋め込みのメトリック空間をよく学ぶので、これは重要です。アルゴリズムの複雑度はO（n </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）であり、原則として約0.25です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合によっては、データの取得やマークアップが非常に難しいため、データの生成を開始すると、何もする必要がなくなることがあります。生成アプローチでは、大量のデータを生成できます。しかし、そのためには何かをプログラムする必要があります。最も簡単な例は、画像上のテキスト認識であるOCRです。このタスクのテキストのマークアップは非常に費用がかかり、ノイズが多くなります。各行と各単語を強調表示し、テキストに署名する必要があります。 100ページのテキスト評価者（マークアップに関与する人々）でもレイアウトが非常に長くなり、トレーニングにはさらに多くの時間が必要になります。もちろん、モデルを学習するために、テキストを生成して「移動」することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この作業に最適で最も便利なツールキットは、PIL、OpenCV、Numpyの組み合わせであることがわかりました。彼らはテキストを扱うためのすべてを持っています。簡単な例でネットワークが再トレーニングしないように、画像をテキストで複雑にすることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cv/zd/ib/cvzdibgjrtt_qnyro4u8-zcgdgw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実世界のオブジェクトが必要になる場合があります。たとえば、店の棚の商品。これらの画像の1つが自動的に生成されます。左か右か？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/os/py/gi/ospygi-cu95vtgblk8ekol86qak.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、両方が生成されます。細かい部分を注意深く見ないと、現実との違いに気付かないでしょう。これは、Blender（3dmaxのアナログ）を使用して行います。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wq/7i/hd/wq7ihd3zrqp0fevkbdylp96hm0m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な重要な利点は、それがオープンソースであることです。</font><font style="vertical-align: inherit;">優れたPython APIを備えているため、オブジェクトをコードに直接配置し、プロセスを構成してランダム化し、最終的に多様なデータセットを取得できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レンダリングにはレイトレーシングが使用されます。</font><font style="vertical-align: inherit;">これはかなり費用のかかる手順ですが、優れた品質の結果が得られます。</font><font style="vertical-align: inherit;">最も重要な質問：オブジェクトのモデルはどこで入手できますか？</font><font style="vertical-align: inherit;">原則として、購入する必要があります。</font><font style="vertical-align: inherit;">しかし、あなたが貧しい学生であり、何かを実験したい場合、常に急流があります。</font><font style="vertical-align: inherit;">プロダクションの場合、レンダリングされたモデルを購入するか、誰かから注文する必要があることは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データについては以上です。</font><font style="vertical-align: inherit;">学習に移りましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メトリック学習</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メトリック学習の目的は、ネットワークをトレーニングして、埋め込みメトリック空間内の同様のオブジェクトを同様の領域に変換することです。見どころについてもう一度例を挙げましょう。これは、本質的に分類タスクですが、数万クラスの場合は珍しいものです。なぜここでは、顔認識などのタスクに原則として適切なメトリック学習が適しているのでしょうか。それを理解してみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Softmaxなどの分類問題をトレーニングするときに標準損失を使用すると、計量空間のクラスは十分に分離されますが、埋め込み空間では、異なるクラスの点が互いに接近する可能性があります...</font></font><br>
<br>
<img src="https://habrastorage.org/webt/od/fl/aq/odflaq4hgygf8vvrnftdrdeinh8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、一般化中に潜在的なエラーが発生します。</font><font style="vertical-align: inherit;">ソースデータのわずかな違いにより、分類結果が変わる場合があります。</font><font style="vertical-align: inherit;">ポイントをもっとコンパクトにしてほしい。</font><font style="vertical-align: inherit;">このために、さまざまな計量学習手法が使用されます。</font><font style="vertical-align: inherit;">たとえば、センター損失、つまり非常にシンプルな考え方：各クラスの学習センターにポイントをまとめるだけで、最終的にはよりコンパクトになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/am/pf/nw/ampfnwjhkn4idpxob_tjpvg3sey.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中心損失は、Pythonでは文字通り10行でプログラムされ、非常に迅速に機能し、最も重要なことに、分類の品質が向上します。</font><font style="vertical-align: inherit;">コンパクトさは一般化能力の向上につながります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">角度ソフトマックス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの異なるメトリック学習方法を試し、Angular Softmaxが最良の結果を生成するという結論に達しました。</font><font style="vertical-align: inherit;">研究コミュニティーの中でも、彼は最先端技術と見なされています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ks/gx/ap/ksgxapfkweb9invhas0g2dz2w2s.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顔認識の例を見てみましょう。ここには2人います。標準のSoftmaxを使用する場合、2つの重みベクトルに基づいて、それらの間に分割平面が描画されます。埋め込みノルムを1にすると、ポイントは円上に配置されます。 n次元の場合の球体（右の図）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/by/zf/a9/byzfa9okk0cry7vcx6vg4n3dsd8.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、それらの間の角度がクラスの分離にすでに関与しており、最適化できることがわかります。</font><font style="vertical-align: inherit;">しかし、それだけでは十分ではありません。</font><font style="vertical-align: inherit;">角度を最適化するだけでは、タスクは実際には変化しません。</font><font style="vertical-align: inherit;">私たちは単にそれを別の言葉で再定式化しました。</font><font style="vertical-align: inherit;">私の目標は、クラスターをよりコンパクトにすることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何らかの方法でクラス間の角度を大きくする必要があります-ニューラルネットワークのタスクを複雑にします。</font><font style="vertical-align: inherit;">たとえば、あるクラスのポイント間の角度が実際よりも大きいと彼女が思うように、彼女はそれらをますます圧縮しようとします。</font><font style="vertical-align: inherit;">これは、角度の余弦の違いを制御するパラメーターmを導入することによって達成されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lx/fk/xc/lxfkxcrdodlg-wpoasqxcws3gao.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angular Softmaxにはいくつかのオプションがあります。</font><font style="vertical-align: inherit;">それらはすべて、この角度をm倍するか、または加算するか、または乗算して加算するという事実で遊んでいます。</font><font style="vertical-align: inherit;">最先端-ArcFace。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ye/_i/zw/ye_izwbkvqmr0-fxpxahc2uty6e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、これはパイプライン分類に簡単に統合できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/05/gi/vt/05givtsihtduioo9co9f0jzj5hk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジャック・ニコルソンの例を見てみましょう。私たちは彼の写真を学習プロセスのグリッドに通します。埋め込みを取得し、分類のために線形レイヤーを実行し、クラスに属する度合いを反映する出力でスコアを取得します。この場合、ニコルソンの写真の速度は最大で20です。さらに、ArcFaceの式によれば、速度を20から13（グラウンドトゥルースクラスに対してのみ行われる）に減らし、ニューラルネットワークのタスクを複雑にします。次に、いつものようにすべてを行います：Softmax + Cross Entropy。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体として、通常の線形レイヤーは、ArcFaceレイヤーに置き換えられます。ArcFaceレイヤーは、10行ではなく20行で記述されますが、優れた結果と実装のオーバーヘッドを最小限に抑えます。</font><font style="vertical-align: inherit;">その結果、ArcFaceはほとんどのタスクで他のほとんどの方法よりも優れています。</font><font style="vertical-align: inherit;">分類タスクと完全に統合され、品質が向上します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">転移学習</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つお話ししたいのは、転移学習です。同様のタスクで事前トレーニング済みのネットワークを使用して、新しいタスクを再トレーニングします。したがって、知識はあるタスクから別のタスクに転送されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像を検索しました。タスクの本質は、画像（クエリ）のデータベースから意味的に類似したものを作成することです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hp/m-/x2/hpm-x27etg2zdagi9wupvgjdqtm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数百万の画像が存在するImageNetまたはOpenImagesデータセットで、すでに多数の画像について研究を行っているネットワークを利用し、データでトレーニングするのが理にかなっています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fn/hq/c-/fnhqc-efmzfkuqmwocx_zy4wp1a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像とユーザークリックの類似性に基づいてこのタスクのデータを収集し、200kクラスを得ました。 ArFaceでトレーニングした後、次の結果が得られました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/da/gu/dd/daguddqmsfbsvj9rdrix-slta4u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の画像では、リクエストされたペリカンについて、スズメも問題に巻き込まれていることがわかります。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">埋め込みは意味的に真実であることが判明しました-それは鳥ですが、人種的には不誠実です。</font><font style="vertical-align: inherit;">最も厄介なのは、再トレーニングした元のモデルがこれらのクラスを知っていて、完全に区別していることです。</font><font style="vertical-align: inherit;">ここでは、壊滅的な忘却と呼ばれるすべてのニューラルネットワークに共通する効果を確認します。</font><font style="vertical-align: inherit;">つまり、再トレーニング中、ネットワークは前のタスクを、場合によっては完全に忘れてしまいます。</font><font style="vertical-align: inherit;">これこそが、このタスクでより良い品質を達成することを妨げているものです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知識蒸留</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、あるネットワークが別のネットワークに教え、「その知識をそれに転送する」ときに、知識蒸留と呼ばれる手法を使用して処理されます。</font><font style="vertical-align: inherit;">それがどのように見えるか（下の写真の完全なトレーニングパイプライン）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-j/bx/kc/-jbxkco1joxnxva7ec8luts-hii.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arcfaceには、おなじみの分類パイプラインがすでにあります。ふりをしているネットワークがあることを思い出してください。フリーズして、ネットワークを学習するすべての写真で埋め込みを計算し、OpenImagesクラスのクラス（ペリカン、スズメ、車、人など）を取得します。訓練された元のニューラルネットワークから学習し、クラスの別の埋め込みを学習します。 OpenImages。同様のスコアを生成します。 BCEを使用して、これらのスコアの同様の分布をネットワークに生成させます。したがって、一方では（図の上部にある）新しいタスクを学習していますが、ネットワークには（その下部にある）ルートを忘れないようにしています-以前は知っていたクラスを覚えています。 50/50の条件付き比率でグラデーションのバランスを正しく調整すると、すべてのペリカンが上部に残り、そこからすべてのスズメが放り出されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vx/kf/ha/vxkfhatx6n6heozx_xpbhgg_zuq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを適用すると、mAPで全体の割合が得られます。</font><font style="vertical-align: inherit;">これはかなりたくさんあります。</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型番</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地図</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弧面</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">92.8</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+知識の詳細</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">93.8（+ 1％）</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ネットワークが前のタスクを忘れた場合は、知識の蒸留を使用して処理してください。これは問題なく機能します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予備ヘッド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的な考え方はとてもシンプルです。</font><font style="vertical-align: inherit;">再び顔認識の例について。</font><font style="vertical-align: inherit;">データセットには一連の人々がいます。</font><font style="vertical-align: inherit;">しかし、多くの場合、データセットには他の顔の特徴があります。</font><font style="vertical-align: inherit;">たとえば、年齢、目の色などです。</font><font style="vertical-align: inherit;">これらすべてをもう1つ追加することができます。</font><font style="vertical-align: inherit;">シグナル：このデータを予測するように個々の頭に教える。</font><font style="vertical-align: inherit;">したがって、私たちのネットワークはより多様な信号を受信し、その結果、主なタスクを学ぶ方が良いかもしれません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/43/to/rp/43torpgdsj-cce3akz2pfe3me9a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の例：キューの検出。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/im/cj/tk/imcjtk4jdpqwcphgrzjldnckfgq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人のデータセットでは、体に加えて、頭の位置の個別のマーキングがよくあります。これは明らかに使用できます。</font><font style="vertical-align: inherit;">したがって、ネットワークに人物のバウンディングボックスの予測と頭のバウンディングボックスの予測を追加すると、精度（mAP）が0.5％向上します。これはまともです。</font><font style="vertical-align: inherit;">そして最も重要なこと-パフォーマンスの観点から無料で、</font><font style="vertical-align: inherit;">製造時には、余分なヘッドは「オフ」になります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gl/4y/5l/gl4y5lhjiikvdewhfntr7bdhkwu.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OCR</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より複雑で興味深いケースは、すでに上で述べたOCRです。標準のパイプラインはそのようなものです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i8/nj/dd/i8njddzf7z3ux8wcawjqmjvkyri.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ペンギンのポスターがあるとしよう。そこに文章が書かれている。検出モデルを使用して、このテキストを強調表示します。さらに、このテキストを認識モデルの入力にフィードし、認識されたテキストを生成します。私たちのネットワークが間違っていて、ペンギンの「i」の代わりに「l」を予測するとします。これは、ネットワークが類似の文字を混同している場合、OCRで実際に非常に一般的な問題です。問題はこれを回避する方法です-ペンギンをペンギンに翻訳しますか？人がこの例を見るとき、これが間違いであることは彼には明らかです。彼は言語の構造の知識を持っています。したがって、言語の文字と単語の分布に関する知識をモデルに埋め込む必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これには、BPE（バイトペアエンコーディング）と呼ばれるものを使用しました。これは、一般に90年代に機械学習用ではなく発明された圧縮アルゴリズムですが、現在は非常に人気があり、ディープラーニングで使用されています。アルゴリズムの意味は、テキスト内で頻繁に発生するサブシーケンスが新しい文字に置き換えられることです。 「aaabdaaabac」という文字列があり、そのBPEを取得したいとします。 「aa」という文字のペアが単語の中で最も頻繁に使用されていることがわかります。これを新しい「Z」文字に置き換え、文字列「ZabdZabac」を取得します。イテレーションを繰り返します。abが最も頻繁なサブシーケンスであることがわかります。これを「Y」に置き換えます。文字列「ZYdZYac」を取得します。今度は「ZY」が最も頻繁なサブシーケンスです。「X」に置き換えると「XdXac」になります。したがって、テキストの分布におけるいくつかの統計的な依存関係をエンコードします。言葉に出会ったら非常に「奇妙な」（教団にとっては珍しい）サブシーケンスがあり、これはこの単語が疑わしいことを意味します。</font></font><br>
<br>
<code>aaabdaaabac<br>
ZabdZabac Z=aa<br>
<font color="#fa7566">ZY</font>d<font color="#fa7566">ZY</font>ac Y=ab<br>
<font color="#fa7566">X</font>d<font color="#fa7566">X</font>ac X=ZY</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてがどのように認識に適合するか。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zq/fm/1v/zqfm1vzn2szxicl-txouuvguwj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「ペンギン」という単語を強調表示して、それを畳み込みニューラルネットワークに送信し、空間埋め込み（512などの固定長のベクトル）を生成しました。このベクトルは、空間シンボル情報をエンコードします。次に、リカレントネットワーク（UPD：実際には既にTransformerモデルを使用しています）を使用します。これにより、いくつかの隠された状態（緑色のバー）が表示され、それぞれに確率分布が作成されます。モデルに従って、特定の位置にシンボルが描かれます。さらに、CTC-Lossの助けを借りて、これらの状態をほどき、単語全体の予測を取得しますが、iの代わりにLのエラーが発生します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jc/p4/6k/jcp46k4rb7hz_b18kbbsbgm_aac.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、BPEをパイプラインに統合しています。個々の文字から単語への予測を避けたいので、文字に関する情報が縫い合わされている状態から分岐し、それらに別の再帰ネットワークを設定します。彼女はBPEを予測しています。上記のエラーの場合、「peng」、「ul」、「ns」の3つのBPEが取得されます。これは、ペンギンという単語の正しいシーケンス、つまり、pen、gu、insとは大きく異なります。これをモデルトレーニングの観点から見ると、文字ごとの予測では、ネットワークは8文字のうち1文字だけ間違いを犯しました（12.5％エラー）。また、BPEに関しては、彼女は3つのBPEをすべて誤って予測することを100％間違っていました。これは、何か問題が発生したことを示す、ネットワークに対するはるかに大きな信号であり、動作を修正する必要があります。これを実装したとき、この種のエラーを修正し、Word Error Rateを0.25％削減することができました。これは大きな問題です。この余分な頭は推論時に削除され、トレーニングでの役割を果たします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FP16</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トレーニングについて最後に言いたかったのはFP16です。</font><font style="vertical-align: inherit;">歴史的にそうなったように、ネットワークはGPUでユニット精度、つまりFP32でトレーニングされました。</font><font style="vertical-align: inherit;">しかし、これは特に推論の場合、冗長です。半精度（FP16）で品質を損なうことなく十分です。</font><font style="vertical-align: inherit;">ただし、これはトレーニングには当てはまりません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ax/wj/ts/axwjtss6t1hmatnqwhd34s6uztq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラーの伝播時に重みを更新する情報である勾配の分布を見ると、ゼロに大きなピークがあることがわかります。</font><font style="vertical-align: inherit;">そして一般的に、多くの値はゼロに近いです。</font><font style="vertical-align: inherit;">すべての重みをFP16に転送するだけの場合、左側の（赤い線から）ゼロの領域が切り取られていることがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sv/th/2_/svth2_7cdnkfckg5qvvebpv-bwo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、非常に多数のグラデーションをリセットします。そして、FP16の動作範囲内の正しい部分はまったく使用されません。その結果、FP16で額をトレーニングすると、プロセスが分散する可能性があります（下の図の灰色のグラフ）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nq/n_/20/nqn_20y7f_4auaqespf7pxakuoo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
混合精度技法を使用してトレーニングする場合、結果はFP32とほぼ同じです。混合精度は2つのトリックを実装します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、損失に定数（128など）を掛けるだけです。したがって、すべての勾配をスケーリングし、それらの値をゼロからFP16の動作範囲に移動します。第2に、更新のみに使用されるFP32バランスのマスターバージョンを保存し、順方向および逆方向パスネットワークの計算操作では、FP16のみを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pytorchを使用してネットワークをトレーニングします。 NVIDIAは、上記のロジックを実装する、いわゆるAPEXを使用して特別なアセンブリを作成しました。彼には2つのモードがあります。 1つ目は、自動混合精度です。使い方がいかに簡単かは、以下のコードを参照してください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fu/nb/8o/funb8omqcc4yrglue2tlsn9bx14.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文字通り、モデルとオプティマイザの損失と初期化手順をラップするトレーニングコードに2行追加されます。 AMPの機能彼はすべての機能を修正します。正確には何が起こっているのですか？たとえば、畳み込み関数があることがわかり、彼女はFP16から利益を受け取ります。次に、FP16にキャストしてから畳み込み演算を実行する自分のものに置き換えます。したがって、AMPはネットワークで使用できるすべての機能を実行します。一部では、そうではありません。加速はありません。ほとんどのタスクでは、この方法が適しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のオプション：完全に制御するファンのためのFP16オプティマイザー。</font><font style="vertical-align: inherit;">FP16とFP32のどちらのレイヤーにするかを自分で指定する場合に適しています。</font><font style="vertical-align: inherit;">しかし、いくつかの制限と困難があります。</font><font style="vertical-align: inherit;">ハーフキックからは始まりません（少なくともキックするには汗をかかなければなりませんでした）。</font><font style="vertical-align: inherit;">また、FP_optimizerはAdamでのみ機能し、その場合でもAPEXにあるそのAdamでのみ機能します（そうです、リポジトリには独自のAdamがあり、Paytorchとは完全に異なるインターフェイスを持っています）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tesla T4カードで学習するときに比較を行いました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rq/go/6c/rqgo6cvrixdwnueh4rczvoooj3m.jpeg"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
推論では、予想される加速が2回あります。</font><font style="vertical-align: inherit;">トレーニングで、Apexフレームワークは比較的単純なFP16で20％の加速を提供することがわかります。</font><font style="vertical-align: inherit;">その結果、2倍の速さで2分の1のメモリしか消費しないワークアウトが得られ、トレーニングの質が低下することはありません。</font><font style="vertical-align: inherit;">景品。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜなら </font><font style="vertical-align: inherit;">私たちはPyTorchを使用しているので、問題はそれをどのように本番環境にデプロイするかが急務です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qj/6u/vr/qj6uvrpjh44wmvkktkvdoxpfwow.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それを行う方法には3つのオプションがあります（私たちが使用したすべてのオプション）。 </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ONNX-&gt; Caffe2 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ONNX-&gt; TensorRT </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして最近ではPytorch C ++</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらのそれぞれを見てみましょう。 </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ONNXとCaffe2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ONNXは1.5年前に登場しました。</font><font style="vertical-align: inherit;">これは、異なるフレームワーク間でモデルを変換するための特別なフレームワークです。</font><font style="vertical-align: inherit;">また、Pytorchに隣接するフレームワークであるCaffe2は、どちらもFacebookで開発されています。</font><font style="vertical-align: inherit;">歴史的に、PytorchはCaffe2よりもはるかに速く開発されています。</font><font style="vertical-align: inherit;">Caffe2はPytorchよりも機能が遅いため、PytorchでトレーニングしたすべてのモデルをCaffe2に変換できるわけではありません。</font><font style="vertical-align: inherit;">多くの場合、他のレイヤーで再学習する必要があります。</font><font style="vertical-align: inherit;">たとえば、Caffe2では、最近傍内挿によるアップサンプリングなどの標準的な操作はありません。</font><font style="vertical-align: inherit;">その結果、モデルごとに特別なDockerイメージを導入し、フレームワークのバージョンを釘で釘付けして、将来の更新時の不一致を回避し、バージョンの1つが再度更新されたときに、互換性に時間を浪費しないという結論に達しました。 。</font><font style="vertical-align: inherit;">これらすべてはあまり便利ではなく、展開プロセスが長くなります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンソルrt</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NVIDIAのフレームワークであるTensor RTもあり、ネットワークアーキテクチャを最適化して推論を高速化します。テスラT4マップ上で測定を行いました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ls/fn/q0/lsfnq0otllhgjqy1gh2lhwufbom.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフを見ると、FP32からFP16への移行により、Pytorchで2倍の加速が得られ、同時にTensorRTで4倍の加速が得られることがわかります。</font><font style="vertical-align: inherit;">非常に大きな違い。</font><font style="vertical-align: inherit;">私たちは、TensorRTで明らかに優れているFP16計算を非常にうまく利用するテンソルカーネルを備えたTesla T4でテストしました。</font><font style="vertical-align: inherit;">したがって、数十枚のグラフィックカードで高負荷のモデルが実行されている場合、Tensor RTを試す動機はすべてあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、TensorRTを使用する場合は、Caffe2の場合よりもさらに苦労します。レイヤーのサポートはさらに低くなります。</font><font style="vertical-align: inherit;">残念ながら、このフレームワークを使用するたびに、モデルの変換に少し苦労する必要があります。</font><font style="vertical-align: inherit;">しかし、負荷の高いモデルの場合は、これを行う必要があります。</font><font style="vertical-align: inherit;">;）テンソルカーネルのないマップでは、このような大幅な増加は見られません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pytorch C ++</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後はPytorch C ++です。 6か月前に、Pytorch開発者はフレームワークを使用する人々の苦痛に気づき、</font><font style="vertical-align: inherit;">不要なジェスチャー（JIT）なしでPythonモデルをトレースして静的グラフにシリアル化できる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TorchScriptチュートリアル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をリリースし</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ました</font></a><font style="vertical-align: inherit;">。 2018年12月にリリースされ、すぐに使用を開始し、すぐにいくつかのパフォーマンスバグをキャッチし、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Chintala</font></a><font style="vertical-align: inherit;">からの修正を数か月待ち</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、今ではそれはかなり安定した技術であり、すべてのモデルに積極的に使用しています。</font><font style="vertical-align: inherit;">唯一のことは、積極的に補足されているドキュメントの欠如です。</font><font style="vertical-align: inherit;">もちろん、いつでも* .hファイルを見ることができますが、プラスを知らない人にとっては、これは難しいことです。</font><font style="vertical-align: inherit;">しかし、Pythonを使用してもまったく同じ作業が行われます。</font><font style="vertical-align: inherit;">C ++では、jコードは最小限のPythonインタープリターで実行されます。これにより、PythonでのC ++のアイデンティティーが実質的に保証されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の説明は非常に重要です。</font><font style="vertical-align: inherit;">データについて製品マネージャーと通信する必要があります。</font><font style="vertical-align: inherit;">タスクを開始する前に、実装段階の前に最終的なメトリックを測定する既製のテストセットを用意することをお勧めします。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスタリングを利用して、自分でデータをクリーンアップします。</font><font style="vertical-align: inherit;">ソースデータのモデルを取得し、CLinkクラスタリングを使用してデータをクリーンアップし、収束するまでこのプロセスを繰り返します。</font></font><br>
</li>
<li>Metric learning:   . State-of-the-art — ArcFace,      .<br>
</li>
<li>   transfer learning   , ,      ,  knowledge distillation. <br>
</li>
<li>     ,       ,    .<br>
</li>
<li> FP16    Apex  NVIDIA, Pytorch.<br>
</li>
<li>     Pytorch C++.<br>
</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja460291/index.html">リクエストのバッチ処理の問題とその解決策（パート1）</a></li>
<li><a href="../ja460295/index.html">Rustで危険とはどういう意味ですか？</a></li>
<li><a href="../ja460297/index.html">WeakRef-ECMAScript標準に追加するための提案</a></li>
<li><a href="../ja460301/index.html">新世代ハイパワーLEDランプ</a></li>
<li><a href="../ja460305/index.html">AERODISKエンジン：壊滅的。パート2. Metrocluster</a></li>
<li><a href="../ja460311/index.html">新しいお金の理論の時間</a></li>
<li><a href="../ja460313/index.html">別のヒット曲に共通点はありますか？</a></li>
<li><a href="../ja460319/index.html">宇宙検査官の狩猟</a></li>
<li><a href="../ja460321/index.html">最高のMLおよびデータサイエンスノートブックのギャラリー</a></li>
<li><a href="../ja460329/index.html">FEDORではなく、Skybot F-850がISSに飛びます</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>