<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÄ üèΩ üñïüèæ Premi√®re impression de concepts üëºüèº üèÑ ‚ùé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai d√©cid√© de m'occuper de la nouvelle fonctionnalit√© C ++ 20 - concepts. 
 
 Les concepts (ou concepts , comme l'√©crit le Wiki russophone) est une f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Premi√®re impression de concepts</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495396/"><img src="https://habrastorage.org/webt/qd/ja/kc/qdjakcxd4173w_juzv5fx3bf0_o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai d√©cid√© de m'occuper de la nouvelle fonctionnalit√© C ++ 20 - concepts. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les concepts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">concepts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , comme l'√©crit le Wiki russophone) est une fonctionnalit√© tr√®s int√©ressante et utile qui fait d√©faut depuis longtemps. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essentiellement, il tape des arguments de mod√®le. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le principal probl√®me des mod√®les avant C ++ 20 est que vous pouvez y substituer n'importe quoi, y compris quelque chose pour lequel ils n'ont pas √©t√© con√ßus du tout. Autrement dit, le syst√®me de mod√®les √©tait compl√®tement non typ√©. En cons√©quence, des messages d'erreur incroyablement longs et compl√®tement illisibles se sont produits lors du passage du mauvais param√®tre au mod√®le. Ils ont essay√© de lutter contre cela avec l'aide de diff√©rents hacks linguistiques, que je ne veux m√™me pas mentionner (m√™me si j'ai d√ª faire face).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les concepts sont con√ßus pour corriger ce malentendu. </font><font style="vertical-align: inherit;">Ils ajoutent un syst√®me de saisie aux mod√®les, et c'est tr√®s puissant. </font><font style="vertical-align: inherit;">Et maintenant, comprenant les caract√©ristiques de ce syst√®me, j'ai commenc√© √† √©tudier les mat√©riaux disponibles sur Internet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Franchement, je suis un peu choqu√© :) Le C ++ est un langage d√©j√† compliqu√©, mais au moins il y a une excuse: c'est arriv√©. </font><font style="vertical-align: inherit;">La m√©taprogrammation sur des mod√®les a √©t√© d√©couverte, non d√©finie, lors de la conception d'un langage. </font><font style="vertical-align: inherit;">Et puis, lors du d√©veloppement des prochaines versions du langage, ils ont √©t√© oblig√©s de s'adapter √† cette ¬´d√©couverte¬ª, car beaucoup de code √©tait √©crit dans le monde. </font><font style="vertical-align: inherit;">Les concepts sont une opportunit√© fondamentalement nouvelle. </font><font style="vertical-align: inherit;">Et, il me semble, une certaine opacit√© est d√©j√† pr√©sente dans leur mise en ≈ìuvre. </font><font style="vertical-align: inherit;">Peut-√™tre est-ce une cons√©quence de la n√©cessit√© de prendre en compte l'√©norme quantit√© de capacit√©s h√©rit√©es? </font><font style="vertical-align: inherit;">Essayons de le comprendre ...</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informations g√©n√©rales</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un concept est une nouvelle entit√© de langage bas√©e sur la syntaxe du mod√®le. </font><font style="vertical-align: inherit;">Un concept a un nom, des param√®tres et un corps - un pr√©dicat qui renvoie une valeur logique constante (c'est-√†-dire calcul√©e au stade de la compilation) en fonction des param√®tres du concept. </font><font style="vertical-align: inherit;">Comme √ßa:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt; 
<span class="hljs-keyword">concept</span> Even = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;  <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> FourByte = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Techniquement, les concepts sont tr√®s similaires aux mod√®les d'expressions constexpr comme bool:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> EvenX = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> FourByteX = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez m√™me utiliser des concepts dans des expressions courantes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Even&lt;<span class="hljs-number">2</span>&gt;; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En utilisant</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'id√©e principale des concepts est qu'ils peuvent √™tre utilis√©s √† la place du nom de type ou des mots-cl√©s de classe dans les mod√®les. </font><font style="vertical-align: inherit;">Comme les m√©tatypes ("types pour types"). </font><font style="vertical-align: inherit;">Ainsi, la saisie statique est introduite dans les mod√®les.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;FourByte T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp; t)</span> </span>{}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, si nous utilisons int comme param√®tre de mod√®le, alors le code dans la grande majorit√© des cas sera compil√©; </font><font style="vertical-align: inherit;">et si double, un message d'erreur court et compr√©hensible sera √©mis. </font><font style="vertical-align: inherit;">Saisie simple et claire des mod√®les, jusqu'√† pr√©sent tout va bien.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a besoin</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit d'un nouveau mot cl√© "contextuel" C ++ 20 avec un double objectif: requiert une clause et requiert une expression. </font><font style="vertical-align: inherit;">Comme nous le verrons plus loin, ces √©conomies de mots cl√©s √©tranges entra√Ænent une certaine confusion.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√©cessite une expression</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, consid√©rez requiert une expression. </font><font style="vertical-align: inherit;">L'id√©e est assez bonne: ce mot a un bloc entre accolades, dont le code √† l'int√©rieur est √©valu√© pour la compilation. </font><font style="vertical-align: inherit;">Certes, le code ne devrait pas √™tre √©crit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en C ++, mais dans un langage sp√©cial, proche de C ++, mais ayant ses propres caract√©ristiques</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (c'est la premi√®re bizarrerie, il √©tait tout √† fait possible de faire juste du code C ++). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si le code est correct - l'expression requise renvoie true, sinon false. </font><font style="vertical-align: inherit;">Le code lui-m√™me, bien s√ªr, n'entre jamais dans la g√©n√©ration de code, tout comme les expressions de taille ou de type de declt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, le mot est contextuel et ne fonctionne qu'√† l'int√©rieur des mod√®les, c'est-√†-dire qu'√† l'ext√©rieur du mod√®le, cela ne compile pas:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b = <span class="hljs-keyword">requires</span> { <span class="hljs-number">3.14</span> &gt;&gt; <span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et dans le mod√®le - veuillez:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> Shiftable = <span class="hljs-keyword">requires</span>(T i) { i&gt;&gt;<span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et cela fonctionnera:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Shiftable&lt;<span class="hljs-keyword">int</span>&gt;; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">bool</span> b2 = Shiftable&lt;<span class="hljs-keyword">double</span>&gt;; <span class="hljs-comment">// false</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'utilisation principale de l'expression requiert la cr√©ation de concepts. </font><font style="vertical-align: inherit;">Par exemple, voici comment vous pouvez v√©rifier la pr√©sence de champs et de m√©thodes dans un type. </font><font style="vertical-align: inherit;">Un cas tr√®s populaire.</font></font><br>
<br>
<pre><code class="plaintext hljs">template &lt;typename T&gt;<font></font>
concept Machine = <font></font>
  requires(T m) {  //   `m` ,   Machine<font></font>
	m.start();     //    `m.start()` <font></font>
	m.stop();      //   `m.stop()`<font></font>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, toutes les variables qui peuvent √™tre requises dans le code test√© (pas seulement les param√®tres du mod√®le) doivent √™tre d√©clar√©es entre parenth√®ses requiert une expression. </font><font style="vertical-align: inherit;">Pour une raison quelconque, d√©clarer une variable n'est tout simplement pas possible.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La v√©rification de type √† l'int√©rieur n√©cessite</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est l√† que les diff√©rences entre le code requis et le C ++ standard commencent. </font><font style="vertical-align: inherit;">Pour v√©rifier les types retourn√©s, une syntaxe sp√©ciale est utilis√©e: l'objet est pris entre accolades, une fl√®che est plac√©e, et apr√®s cela, un concept est √©crit que le type doit satisfaire. </font><font style="vertical-align: inherit;">De plus, l'utilisation de types directement n'est pas autoris√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V√©rifiez que le retour de la fonction peut √™tre converti en int:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">int</span>&gt;;<font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V√©rifiez que la fonction de retour est exactement int:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::same_as&lt;<span class="hljs-keyword">int</span>&gt;; <font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(std :: same_as et std :: convertible_to sont des concepts de la biblioth√®que standard). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous n'incluez pas une expression dont le type est v√©rifi√© entre accolades, le compilateur ne comprend pas ce qu'il attend de lui et interpr√®te la cha√Æne enti√®re comme une seule expression qui doit √™tre v√©rifi√©e pour la compilation.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√©cessite √† l'int√©rieur n√©cessite</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le mot cl√© require a une signification sp√©ciale √† l'int√©rieur des expressions require. </font><font style="vertical-align: inherit;">Les expressions-requis imbriqu√©es (d√©j√† sans accolades) ne sont pas v√©rifi√©es pour la compilation, mais pour l'√©galit√© vraie ou fausse. </font><font style="vertical-align: inherit;">Si une telle expression s'av√®re fausse, alors l'expression englobante se r√©v√®le imm√©diatement fausse (et une analyse de compilation suppl√©mentaire est interrompue). </font><font style="vertical-align: inherit;">Forme g√©n√©rale:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> { <font></font>
  expression;         <span class="hljs-comment">// expression is valid</span>
  <span class="hljs-keyword">requires</span> predicate; <span class="hljs-comment">// predicate is true</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En tant que pr√©dicat, par exemple, des concepts ou des traits de type d√©finis pr√©c√©demment peuvent √™tre utilis√©s. </font><font style="vertical-align: inherit;">Exemple:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(Iter it) {
  <span class="hljs-comment">//     (   Iter   *  ++)</span><font></font>
  *it++;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_convertible_v&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le m√™me temps, les expressions require imbriqu√©es sont autoris√©es avec du code entre accolades, dont la validit√© est v√©rifi√©e. </font><font style="vertical-align: inherit;">Cependant, si vous √©crivez simplement une expression require dans une autre, la validit√© de l'expression imbriqu√©e (tout dans son ensemble, y compris le mot cl√© nested requires) sera simplement v√©rifi√©e:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">typename</span> T::value_type x) { ++x; }; <span class="hljs-comment">//     , </span>
												<span class="hljs-comment">//     !</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par cons√©quent, une forme √©trange avec double n√©cessite est apparue:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span> <span class="hljs-params">(<span class="hljs-keyword">typename</span> T::value_type x)</span> </span>{ ++x; }; <span class="hljs-comment">//       "++x"</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici une s√©quence d'√©vasion amusante de ¬´n√©cessite¬ª. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, une autre combinaison de deux n√©cessite cette clause de temps (voir ci-dessous) et l'expression:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span><span class="hljs-params">(T x, T y)</span> </span>{ <span class="hljs-keyword">bool</span>(x &lt; y); }
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">equivalent</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; x, T <span class="hljs-keyword">const</span>&amp; y)</span>
</span>{
  <span class="hljs-keyword">return</span> !(x &lt; y) &amp;&amp; !(y &lt; x);<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√©cessite une clause</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons maintenant √† une autre utilisation du mot require - pour d√©clarer les restrictions d'un type de mod√®le. </font><font style="vertical-align: inherit;">Il s'agit d'une alternative √† l'utilisation de noms de concept au lieu de nom de type. </font><font style="vertical-align: inherit;">Dans l'exemple suivant, les trois m√©thodes sont √©quivalentes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  require</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
	<span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span></span>;<font></font>
<font></font>
<span class="hljs-comment">//   require (  )</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span> <span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;</span>;<font></font>
<font></font>
<span class="hljs-comment">//    typename</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Sortable Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span>  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La d√©claration require peut utiliser plusieurs pr√©dicats combin√©s par des op√©rateurs logiques.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<font></font>
 <font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// ok</span>
  fun(s);  <span class="hljs-comment">// compiler error</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, inversez simplement l'une des conditions, car une erreur de compilation se produit:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; !is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un exemple qui ne compilera pas non plus</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> !<span class="hljs-function">is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;	</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La raison en est les ambigu√Øt√©s qui surviennent lors de l'analyse de certaines expressions. </font><font style="vertical-align: inherit;">Par exemple, dans un tel mod√®le:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">bool</span>)&amp;<span class="hljs-function">T::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
on ne sait pas √† quoi attribuer non sign√© - l'op√©rateur ou le prototype de la fonction foo (). </font><font style="vertical-align: inherit;">Par cons√©quent, les d√©veloppeurs ont d√©cid√© que sans parenth√®ses, car les arguments n√©cessitent une clause, seul un ensemble tr√®s limit√© d'entit√©s peut √™tre utilis√© - vrais ou faux litt√©raux, noms de champ de type bool de la forme valeur, valeur, T :: valeur, ns :: trait :: valeur, Noms de concept de type Concept et requiert des expressions. </font><font style="vertical-align: inherit;">Tout le reste doit √™tre plac√© entre parenth√®ses:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!is_trivial_v&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä propos des fonctionnalit√©s de pr√©dicat dans la clause requires</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons un autre exemple.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet exemple, require utilise un trait qui d√©pend du type imbriqu√© value_type. </font><font style="vertical-align: inherit;">On ne sait pas √† l'avance si un type arbitraire a un tel type imbriqu√© qui peut √™tre transmis au mod√®le. </font><font style="vertical-align: inherit;">Si vous passez, par exemple, un type int simple √† un tel mod√®le, il y aura une erreur de compilation, cependant, si nous avons deux sp√©cialisations du mod√®le, il n'y aura pas d'erreur; </font><font style="vertical-align: inherit;">juste une autre sp√©cialisation sera choisie.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"1"</span>; } <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2"</span>; } <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// displays: "2"</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la sp√©cialisation est rejet√©e non seulement lorsque le pr√©dicat de la clause require renvoie false, mais √©galement lorsqu'il s'av√®re incorrect. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les parenth√®ses autour du pr√©dicat sont un rappel important que dans la clause require, l'inverse du pr√©dicat n'est pas l'oppos√© du pr√©dicat lui-m√™me. </font><font style="vertical-align: inherit;">Donc,</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
signifie que le trait est correct et renvoie vrai. </font><font style="vertical-align: inherit;">O√π</font></font><br>
<br>
<pre><code class="cpp hljs">!is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
signifierait ¬´le trait est correct et renvoie faux¬ª La </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
v√©ritable inversion logique du premier pr√©dicat n'est PAS (¬´le trait est correct et retourne vrai¬ª) == ¬´le trait est INCORRECT ou retourne faux¬ª - ceci est r√©alis√© d'une mani√®re l√©g√®rement plus complexe - gr√¢ce √† une d√©finition explicite du concept:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> value_type_valid_and_trivial <font></font>
  = is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;; <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!value_type_valid_and_trivial&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conjonction et disjonction</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les op√©rateurs de conjonction et de disjonction logiques semblent comme d'habitude, mais fonctionnent en fait un peu diff√©remment qu'en C ++ normal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consid√©rez deux extraits de code tr√®s similaires. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier est un pr√©dicat sans parenth√®ses:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		|| <span class="hljs-function"><span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La seconde est entre parenth√®ses:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> (<span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		 || <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diff√©rence est uniquement entre parenth√®ses. </font><font style="vertical-align: inherit;">Mais pour cette raison, dans le deuxi√®me mod√®le, il n'y a pas deux contraintes r√©unies par une "clause d'exigence", mais une contrainte par un OU logique habituel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette diff√©rence est la suivante. </font><font style="vertical-align: inherit;">Consid√©rez le code</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">int</span>&gt; oi {};
<span class="hljs-keyword">int</span> i {};<font></font>
fun(i, oi);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, le mod√®le est instanci√© par les types int et std :: facultatif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le premier cas, le type int :: value_type n'est pas valide et la premi√®re limitation n'est donc pas satisfaite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais le type optional :: value_type est valide, le deuxi√®me trait renvoie true, et comme il y a un op√©rateur OR entre les contraintes, le pr√©dicat entier est satisfait dans son ensemble. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le second cas, il s'agit d'une expression unique contenant un type non valide, √† cause de laquelle elle est invalide en g√©n√©ral et le pr√©dicat n'est pas satisfait. </font><font style="vertical-align: inherit;">Des crochets si simples changent imperceptiblement la signification de ce qui se passe.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr, toutes les fonctionnalit√©s des concepts ne sont pas pr√©sent√©es ici. Je ne suis simplement pas all√© plus loin. Mais comme premi√®re impression - une id√©e tr√®s int√©ressante et une mise en ≈ìuvre confuse quelque peu √©trange. Et une syntaxe amusante avec r√©p√©tition oblige, ce qui confond vraiment. Y a-t-il vraiment si peu de mots en anglais que vous avez d√ª utiliser un mot √† des fins compl√®tement diff√©rentes? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'id√©e avec du code compil√© est d√©finitivement bonne. Il est m√™me quelque peu similaire √† la ¬´quasi-citation¬ª dans les macros de syntaxe. Mais valait-il la peine de m√©langer la syntaxe sp√©ciale pour v√©rifier les types de retour? √Ä mon humble avis, pour cela, il serait simplement n√©cessaire de cr√©er un mot-cl√© distinct.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√©lange implicite des concepts ¬´vrai / faux¬ª et ¬´compile / ne compile pas¬ª dans un seul tas, et par cons√©quent, les blagues avec des crochets sont √©galement erron√©es. </font><font style="vertical-align: inherit;">Ce sont des concepts diff√©rents, et ils doivent exister strictement dans des contextes diff√©rents (bien que je comprenne d'o√π ils viennent - de la r√®gle SFINAE, o√π le code non compil√© excluait silencieusement la sp√©cialisation de la consid√©ration). </font><font style="vertical-align: inherit;">Mais si le but des concepts est de rendre le code aussi explicite que possible, cela valait-il la peine de faire glisser toutes ces choses implicites dans de nouvelles fonctionnalit√©s? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'article a √©t√© √©crit principalement sur la base de </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/01/29/requires-expression </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/03/26/requires-clause</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
(il y a beaucoup plus d'exemples et de fonctionnalit√©s int√©ressantes) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
avec mes ajouts de d'autres sources, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tous les exemples peuvent √™tre v√©rifi√©s sur</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wandbox.org</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr495380/index.html">Grand pare-feu √©gyptien</a></li>
<li><a href="../fr495384/index.html">Mon exp√©rience de stage chez Microsoft Redmond et l'obtention d'une offre</a></li>
<li><a href="../fr495388/index.html">√âmission de t√©l√©vision des ann√©es 1970 qui est devenue un anc√™tre de l'eSport</a></li>
<li><a href="../fr495390/index.html">STM32CubeMonitor m√©rite un essai</a></li>
<li><a href="../fr495392/index.html">Comment rechercher des bugs sur le front-end: 4 √©tapes principales</a></li>
<li><a href="../fr495398/index.html">Ro.Ri.Re</a></li>
<li><a href="../fr495400/index.html">Fonctionne avec la carte SD via l'interface SPI. Impl√©mentation VHDL</a></li>
<li><a href="../fr495402/index.html">L'ann√©e derni√®re, nous avons finalement photographi√© un trou noir. Maintenant quoi?</a></li>
<li><a href="../fr495404/index.html">Les stocks affaiss√©s sont-ils prometteurs? Analysons avec python</a></li>
<li><a href="../fr495408/index.html"># 02 - Et un octet entier ne suffit pas ... | La croix des changements</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>