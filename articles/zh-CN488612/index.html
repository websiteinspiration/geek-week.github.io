<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕋 🤗 🕺🏻 Java序列化：没有僵化数据结构的最高速度 💆🏻 🏅 🕣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们在Sberbank的团队正在开发会话数据服务，该服务可组织分布式应用程序之间单个Java会话上下文的互换。我们的服务迫切需要非常快速的Java对象序列化，因为这是我们关键任务的一部分。最初，它们浮现在我们的脑海：Google协议缓冲区，Apache Thrift，Apache Avro，CBOR...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Java序列化：没有僵化数据结构的最高速度</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/488612/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在Sberbank的团队正在开发会话数据服务，该服务可组织分布式应用程序之间单个Java会话上下文的互换。我们的服务迫切需要非常快速的Java对象序列化，因为这是我们关键任务的一部分。最初，它们</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">浮现</font></a><font style="vertical-align: inherit;">在我们的脑海：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google协议缓冲区</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache Thrift</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache Avro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBOR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些库的前三个要求对对象进行序列化以描述其数据模式。</font><font style="vertical-align: inherit;">CBOR非常低级，它只能序列化标量值及其集合。</font><font style="vertical-align: inherit;">我们需要的是一个Java序列化库，该库“没有问太多问题”，并且不强制将可序列化对象“手动分类为原子”。</font><font style="vertical-align: inherit;">我们想序列化任意Java对象，而实际上不了解它们，因此我们希望尽快进行。</font><font style="vertical-align: inherit;">因此，我们组织了一场争夺Java序列化问题的可用开源解决方案的竞赛。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/52/0t/82/520t82yicq9kayb7s3bovbktf04.png" alt="KDPV"><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">竞争者</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在竞赛中，我们选择了最受欢迎的Java序列化库（主要使用二进制格式）以及在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Java序列化</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">审核中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行良好的库</font><font style="vertical-align: inherit;">。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java标准</font></font></i></td>
<td> Java- « »,&nbsp; Java-    .<br>
</td>
</tr>
<tr>
<td>2</td>
<td><i>Jackson JSON</i></td>
<td> &nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FasterXML/jackson-databind</a>,  Java-   JSON-.<br>
</td>
</tr>
<tr>
<td>3</td>
<td><i>Jackson JSON (with types)</i></td>
<td>  ,   ,    ,      full qualified  Java-.        JSON- (,  )  .<br>
<div class="spoiler"><b class="spoiler_title">,    JSON...</b><div class="spoiler_text"><pre><code class="javascript hljs">[
  <span class="hljs-string">"ru.sbrf.ufs.dto.PersonDto"</span>,<font></font>
  {<font></font>
    <span class="hljs-string">"firstName"</span>:<span class="hljs-string">"Ivan"</span>,
    <span class="hljs-string">"lastName"</span>:<span class="hljs-string">"Ivanov"</span><font></font>
  }<font></font>
]<font></font>
</code></pre></div></div><div class="spoiler"><b class="spoiler_title">  ...</b><div class="spoiler_text">:<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> ObjectMapper <span class="hljs-title">createMapper</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjectMapper();<font></font>
}<font></font>
</code></pre>:<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> ObjectMapper <span class="hljs-title">createMapper</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjectMapper()<font></font>
            .enable(<font></font>
                    ACCEPT_SINGLE_VALUE_AS_ARRAY,<font></font>
                    ACCEPT_EMPTY_STRING_AS_NULL_OBJECT,<font></font>
                    ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT,<font></font>
                    READ_UNKNOWN_ENUM_VALUES_AS_NULL,<font></font>
                    UNWRAP_SINGLE_VALUE_ARRAYS<font></font>
            )<font></font>
            .disable(<font></font>
                    FAIL_ON_INVALID_SUBTYPE,<font></font>
                    FAIL_ON_NULL_FOR_PRIMITIVES,<font></font>
                    FAIL_ON_IGNORED_PROPERTIES,<font></font>
                    FAIL_ON_UNKNOWN_PROPERTIES,<font></font>
                    FAIL_ON_NUMBERS_FOR_ENUMS,<font></font>
                    FAIL_ON_UNRESOLVED_OBJECT_IDS,<font></font>
                    WRAP_EXCEPTIONS<font></font>
            )<font></font>
            .enable(ALLOW_SINGLE_QUOTES)<font></font>
            .disable(FAIL_ON_EMPTY_BEANS)<font></font>
            .enable(MapperFeature.PROPAGATE_TRANSIENT_MARKER)<font></font>
            .setVisibility(FIELD, ANY)<font></font>
            .setVisibility(ALL, NONE)<font></font>
            .enableDefaultTyping(NON_FINAL);  <span class="hljs-comment">// !</span><font></font>
}<font></font>
</code></pre></div></div></td>
</tr>
<tr>
<td>4</td>
<td><i>Jackson Smile</i></td>
<td>&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FasterXML/jackson-dataformats-binary/smile</a>,   Jackson-,  Java-    JSON- – Smile.<br>
</td>
</tr>
<tr>
<td>5</td>
<td><i>Jackson Smile (with types)</i></td>
<td>  ,   ,    «Jackson JSON (with types)» (full qualified  Java-    ).<br>
</td>
</tr>
<tr>
<td>6</td>
<td><i>Bson4Jackson</i></td>
<td>&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">michel-kraemer/bson4jackson</a>,   Jackson-,  Java-    JSON- – BSON.<br>
</td>
</tr>
<tr>
<td>7</td>
<td><i>Bson4Jackson (with types)</i></td>
<td>  ,   ,    «Jackson JSON (with types)» (full qualified  Java-    ).<br>
</td>
</tr>
<tr>
<td>8</td>
<td><i>BSON MongoDb</i></td>
<td>&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">mongodb/mongo-java-driver/bson</a>,&nbsp;&nbsp; Java-  BSON-.<br>
</td>
</tr>
<tr>
<td>9</td>
<td><i>Kryo</i></td>
<td>&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EsotericSoftware/kryo</a>,&nbsp; Java-    .<br>
</td>
</tr>
<tr>
<td>10</td>
<td><i>Kryo (unsafe)</i></td>
<td>  ,   ,      sun.misc.Unsafe   /.<br>
<div class="spoiler"><b class="spoiler_title">  ...</b><div class="spoiler_text"> :<pre><code class="plaintext hljs">com.esotericsoftware.kryo.io.Input<font></font>
com.esotericsoftware.kryo.io.Output<font></font>
</code></pre>:<pre><code class="plaintext hljs">com.esotericsoftware.kryo.io.UnsafeInput<font></font>
com.esotericsoftware.kryo.io.UnsafeOutput</code></pre></div></div></td>
</tr>
<tr>
<td>11</td>
<td><i>FST</i></td>
<td><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RuedigerMoeller /快速序列化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库&nbsp; </font><font style="vertical-align: inherit;">将Java对象转换为自己的二进制格式。</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FST（不安全）</font></font></i></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与上述相同的库，但配置为使用sun.misc.Unsafe类加快序列化/反序列化。</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库自定义功能...</font></font></b><div class="spoiler_text">:<pre><code class="java hljs">FSTConfiguration fst = FSTConfiguration.createDefaultConfiguration();
</code></pre>:<pre><code class="plaintext hljs">FSTConfiguration fst = FSTConfiguration.createUnsafeBinaryConfiguration();</code></pre></div></div></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十三</font></font></td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一ni</font></font></i></td>
<td><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">odnoklassniki / one-nio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库&nbsp; </font><font style="vertical-align: inherit;">将Java对象转换为自己的二进制格式。</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14</font></font></td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个Nio（用于持久）</font></font></i></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与上述相同的库，但是配置为在序列化结果中包括有关可序列化Java对象类的详细元信息。</font></font><code>byte[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在反序列化之前</font><font style="vertical-align: inherit;">的长期存储</font><font style="vertical-align: inherit;">（例如，在数据库中）</font><font style="vertical-align: inherit;">期间可能需</font><font style="vertical-align: inherit;">要这样做。</font><font style="vertical-align: inherit;">也就是说，追求的目标与Jackson JSON（带有类型）的目标相同。</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库自定义功能...</font></font></b><div class="spoiler_text">:<pre><code class="java hljs"><span class="hljs-keyword">byte</span>[] bufWithoutSerializers = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[bufferSize];<font></font>
SerializeStream out = <span class="hljs-keyword">new</span> SerializeStream( bufWithoutSerializers );<font></font>
out.writeObject(object);<font></font>
<span class="hljs-comment">// bufWithoutSerializers is the result</span>
</code></pre>:<pre><code class="java hljs"><span class="hljs-keyword">byte</span>[] bufWithSerializers = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[bufferSize];<font></font>
PersistStream out = <span class="hljs-keyword">new</span> PersistStream( bufWithSerializers );<font></font>
out.writeObject(object);<font></font>
bufWithSerializers = out.toByteArray();<font></font>
<span class="hljs-comment">// bufWithSerializers is the result</span>
</code></pre><br>
   <code>object</code>-  <code>result</code>&nbsp;  -:<br>
1) full qualified    <code>object</code>,<br>
2)     ,<br>
3) full qualified     ,<br>
4)        .<br>
  -  ,  One Nio   ,        .</div></div></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始了！</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">种族</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
速度是评估即兴比赛参与者Java序列化库的主要标准。</font><font style="vertical-align: inherit;">为了客观地评估哪个序列化库更快，我们</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从系统日志中获取真实数据，并从它们中组合合成会话数据，这些数据的长度</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从0到1 MB </font><i><font style="vertical-align: inherit;">不等</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">数据格式为字符串和字节数组。</font></font><br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">展望未来，应该说赢家和输家已经出现在0到10 KB的可序列化对象的大小上。</font><font style="vertical-align: inherit;">对象大小进一步增加到1 MB并没有改变比赛的结果。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这方面，为了更好地说明，以下Java序列化器性能的图表受到10 KB对象大小的限制。</font></font></blockquote><i> ,    :</i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td></td>
<td>Intel<sup>R</sup>&nbsp;Core<sup>TM</sup> i7-6700 CPU, 3.4GHz, 8 cores</td>
</tr>
<tr>
<td></td>
<td>16 GB</td>
</tr>
<tr>
<td> </td>
<td>Microsoft Windows&nbsp;10&nbsp;(64-bit)</td>
</tr>
<tr>
<td>JRE</td>
<td>IBM J9 VM 1.7.0</td>
</tr>
</tbody></table></div><blockquote><strong>:</strong>   ,  IBM JRE    One Nio (   13  14).     <code>sun.reflect.MagicAccessorImpl</code>    <code>private</code>  <code>final</code> ( )  ,    . , IBM JRE      &nbsp;<code>sun.reflect.MagicAccessorImpl</code>,   ,     runtime .<br>
<br>
           (,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Serialization-FAQ</a>,  One Nio   ),    fork  ,    &nbsp;<code>sun.reflect.MagicAccessorImpl</code>&nbsp;  .   &nbsp;<code>sun.reflect.MagicAccessorImpl</code>&nbsp;  fork-   <code>sun.misc.Unsafe</code>     .<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，在我们的分支中，对字符串的序列化进行了优化-使用IBM JRE时，字符串的序列化开始速度提高了30-40％。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，在本出版物中，One Nio库的所有结果都是通过我们自己的叉子获得的，而不是在原始库中获得的。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">串行化/反序列化速度的直接测量是使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java Microbenchmark Harness</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（JMH）进行的，该工具来自OpenJDK，用于构建和运行基准测试。</font><font style="vertical-align: inherit;">对于每次测量（图形上的一个点），使用5秒钟“预热” JVM，另外5秒钟用于时间测量本身，然后取平均值。</font></font><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD：</font></font></b></i><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有一些细节的JMH基准代码</font></font></b><div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerializationPerformanceBenchmark</span> </span>{<font></font>
<font></font>
    <span class="hljs-meta">@State( Scope.Benchmark )</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parameters</span> </span>{<font></font>
<font></font>
        <span class="hljs-meta">@Param( {
            "Java standard",
            "Jackson default",
            "Jackson system",
            "JacksonSmile default",
            "JacksonSmile system",
            "Bson4Jackson default",
            "Bson4Jackson system",
            "Bson MongoDb",
            "Kryo default",
            "Kryo unsafe",
            "FST default",
            "FST unsafe",
            "One-Nio default",
            "One-Nio for persist"
        } )</span>
        <span class="hljs-keyword">public</span> String serializer;
        <span class="hljs-keyword">public</span> Serializer serializerInstance;<font></font>
<font></font>
        <span class="hljs-meta">@Param( { "0", "100", "200", "300", /*... */ "1000000" } )</span>  <span class="hljs-comment">// Toward 1 MB</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> sizeOfDto;
        <span class="hljs-keyword">public</span> Object dtoInstance;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] serializedDto;<font></font>
<font></font>
        <span class="hljs-meta">@Setup( Level.Trial )</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>{<font></font>
            serializerInstance = Serializers.getMap().get( serializer );<font></font>
            dtoInstance = DtoFactory.createWorkflowDto( sizeOfDto );<font></font>
            serializedDto = serializerInstance.serialize( dtoInstance );<font></font>
        }<font></font>
<font></font>
        <span class="hljs-meta">@TearDown( Level.Trial )</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tearDown</span><span class="hljs-params">()</span> </span>{<font></font>
            serializerInstance = <span class="hljs-keyword">null</span>;<font></font>
            dtoInstance = <span class="hljs-keyword">null</span>;<font></font>
            serializedDto = <span class="hljs-keyword">null</span>;<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] serialization( Parameters parameters ) <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-keyword">return</span> parameters.serializerInstance.serialize(<font></font>
                parameters.dtoInstance );<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">unserialization</span><span class="hljs-params">( Parameters parameters )</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>{
        <span class="hljs-keyword">return</span> parameters.serializerInstance.deserialize(<font></font>
                parameters.serializedDto,<font></font>
                parameters.dtoInstance.getClass() );<font></font>
    }<font></font>
}<font></font>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是发生的事情：</font><font style="vertical-align: inherit;">
首先，我们注意到，将其他元数据添加到序列化结果中的库选项比相同库的默认配置要慢（请参阅“使用类型”和“用于持久”配置）。</font><font style="vertical-align: inherit;">
通常，无论配置如何，根据序列化的结果</font><i><font style="vertical-align: inherit;">淘汰的Jackson JSON和Bson4Jackson都会</font></i><font style="vertical-align: inherit;">成为局外人</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
此外，基于反序列化结果</font><font style="vertical-align: inherit;">，</font><i><font style="vertical-align: inherit;">Java Standard退出了竞争</font></i><font style="vertical-align: inherit;">，因为对于任何大小的可序列化数据，反序列化都比竞争对手慢得多。</font><font style="vertical-align: inherit;">
仔细看看其余的参与者：</font><font style="vertical-align: inherit;">
根据序列化的结果，</font><i><font style="vertical-align: inherit;">FST</font></i><font style="vertical-align: inherit;">库充满信心</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/un/cl/x7/unclx7kgnmniixupznbhmuigcwi.png" alt="赛车-所有参与者"></a><br>
<br><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ct/fm/cg/ctfmcgtlh9wo66vctatdvwujhzy.png" alt="赛车-局外人除外"></a><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且随着对象尺寸的增加，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One Nio会</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “ </font><i><font style="vertical-align: inherit;">踩</font></i><font style="vertical-align: inherit;">她的脚跟” </font><font style="vertical-align: inherit;">。请注意，对于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One Nio，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “ forpersist”选项比序列化速度的默认配置慢得多。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您查看反序列化，我们会发现</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One Nio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能够随着数据量的增加而超过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FST</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。相反，在后者中，非标准配置“不安全”执行反序列化的速度要快得多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了将所有要点放在AND上，让我们看一下序列化和反序列化的总结果：</font><font style="vertical-align: inherit;">
很明显，有</font><u><font style="vertical-align: inherit;">两个明确的领导者：</font></u><u><i><font style="vertical-align: inherit;">FST（不安全）</font></i></u><u><font style="vertical-align: inherit;">和</font></u><u><i><font style="vertical-align: inherit;">One Nio</font></i></u><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
如果在小物体上</font><i><font style="vertical-align: inherit;">FST（不安全）</font></i></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/zp/qq/mw/zpqqmwuxdlsb_gvl3orjyd1pyda.png" alt="比赛-局外人除外（总体分类）"></a><br>
<br><font style="vertical-align: inherit;"></font><u><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i></u><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;自信地领导，然后随着可序列化对象大小的增加，他开始认输，并最终落后于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One Nio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><u><i><font style="vertical-align: inherit;">BSON MongoDb</font></i></u></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
自信地将可序列化对象的大小增加到第三位</font><font style="vertical-align: inherit;">，尽管它</font></font><u><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">领先领先</font></font></i></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">者将近两倍。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">称量</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
序列化结果的大小是评估Java序列化库的第二个最重要的标准。从某种意义上说，序列化/反序列化的速度取决于结果的大小：形成和处理紧凑的结果要比批量结果更快。为了“加权”序列化的结果，使用了所有相同的Java对象，它们是从系统日志（字符串和字节数组）中获取的真实数据组成的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，序列化结果的重要属性还在于压缩后压缩的程度（例如，将其保存在数据库或其他存储中）。在我们的比赛中，我们使用了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deflate</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">压缩</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;">算法</font></i></a><font style="vertical-align: inherit;">，它是ZIP和gzip的基础。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“称量”的结果如下：</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/pb/ek/h-/pbekh-hfdtstyzpd2ttgtkfhb88.png" alt="称量"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以预期，最紧凑的结果是该赛事的</font></font><u><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中一位</font></font></i></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">领先者之一：</font><u><i><font style="vertical-align: inherit;">One Nio</font></i></u><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
紧凑度排名第二的是</font></font><u><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BSON MongoDb</font></font></i></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;（在比赛中排名第三）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就紧凑性而言，排在第三位的</font></font><u><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kryo</font></font></i></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库“逃脱了” </font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">库</font><font style="vertical-align: inherit;">以前未能在比赛中证明自己。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这三个“ weighing”前导的序列化结果也得到了完美压缩（几乎两个）。</font><font style="vertical-align: inherit;">事实证明，它是最不可压缩的：JSON的二进制等效项是Smile和JSON本身。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个奇怪的事实-序列化过程中“权衡”的所有赢家都将相同数量的服务数据添加到小型和大型可序列化对象中。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">灵活性</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在做出负责任的选择获奖者决定之前，我们决定彻底检查每个序列化器的灵活性及其可用性。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，我们编制了20条评估参加比赛的序列化器的标准，以使“没有一只鼠标滑过”我们的眼睛。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/zd/t4/it/zdt4itoudhnnpfo7e2l9jdscwdo.png" alt="灵活性"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带说明的脚注</font></font></b><div class="spoiler_text"><sup>1</sup>&nbsp; &nbsp; <i> <code>LinkedHashMap</code>.</i><br>
<sup>2</sup>&nbsp; &nbsp;<i>    — ,    — .</i><br>
<sup>3</sup>&nbsp; &nbsp;<i>    — ,    — .</i><br>
<sup>4</sup>&nbsp; &nbsp;<i>  <code>sun.reflect.MagicAccessorImpl</code> — : boxing/unboxing,   <code>BigInteger/BigDecimal/String</code>.   <code>MagicAccessorImpl</code>&nbsp;(  ' fork One Nio) — .</i><br>
<sup>5</sup>&nbsp; &nbsp;<i> <code>ArrayList</code>.</i><br>
<sup>6</sup>&nbsp; &nbsp;<i> <code>ArrayList</code>  <code>HashSet</code>      .</i><br>
<sup>7</sup>&nbsp; &nbsp;<i> <code>HashMap</code>.</i><br>
<sup>8</sup>&nbsp; &nbsp;<i>        — ,     ,   /Map-,   (   <code>HashMap</code>).</i><br>
<sup>9</sup>&nbsp; &nbsp;<i>   -.</i><br>
<sup>10</sup>&nbsp;<i>   One Nio — ,    ' fork- — .</i><br>
<sup>11</sup> <i>     .</i><br>
</div></div><i><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据第13条标准，One Nio（表示坚持）获得了另一分（第19条）。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
这种细致的“申请人审查”也许是我们“播报”中最耗时的阶段。但是随后这些比较结果很好地打开了使用序列化库的便利。因此，您可以将这些结果用作参考。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
意识到真是遗憾，但我们的领导人根据比赛和称量的结果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -FST（不安全）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> One Nio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-事实证明在灵活性方面是局外人...但是，我们对一个奇怪的事实感兴趣：在持久性方面的配置（不是最快的，也不是最紧凑的）中的一个Nio在灵活性方面得分最高-19/20。灵活地进行默认（快速而紧凑）One Nio配置工作的机会看起来也很有吸引力-并且有一种方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一开始，当我们向参与者介绍比赛时，据说</font><font style="vertical-align: inherit;">序列化结果中包含的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One Nio（表示持久性）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">详细</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">说明了有关可序列化Java对象类的元信息。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（*）。</font><font style="vertical-align: inherit;">使用此元信息进行反序列化，One Nio库确切地知道序列化时可序列化对象的类是什么样。</font><font style="vertical-align: inherit;">基于此知识，One Nio反序列化算法是如此灵活，以至于它提供了序列化所带来的最大兼容性</font></font><code>byte[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实证明，可以为指定的类分别获取元信息（*），将其序列化&nbsp; </font></font><code>byte[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;并发送到将反序列化该类的Java对象的一侧：</font></font><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逐步执行代码...</font></font></b><div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment">//  №1:  -   SomeDto</span><font></font>
one.nio.serial.Serializer&lt;SomeDto&gt; dtoSerializerWithMeta = Repository.get( SomeDto.class );<font></font>
<span class="hljs-keyword">byte</span>[] dtoMeta = serializeByDefaultOneNioAlgorithm( dtoSerializerWithMeta );<font></font>
//  №<span class="hljs-number">1</span>:  dtoMeta  №<span class="hljs-number">2</span><font></font>
<font></font>
<span class="hljs-comment">//  №2:  -    SomeDto      One Nio</span><font></font>
one.nio.serial.Serializer&lt;SomeDto&gt; dtoSerializerWithMeta = deserializeByOneNio( dtoMeta );<font></font>
Repository.provideSerializer( dtoSerializerWithMeta );<font></font>
<font></font>
<span class="hljs-comment">//  №1:    SomeDto</span>
<span class="hljs-keyword">byte</span>[] bytes1 = serializeByDefaultOneNioAlgorithm( object1 );
<span class="hljs-keyword">byte</span>[] bytes2 = serializeByDefaultOneNioAlgorithm( object2 );<font></font>
...<font></font>
<span class="hljs-comment">//  №1:    №2</span><font></font>
<font></font>
<span class="hljs-comment">//  №2:      SomeDto</span><font></font>
SomeDto object1 = deserializeByOneNio( bytes1 );<font></font>
SomeDto object2 = deserializeByOneNio( bytes2 );<font></font>
...<font></font>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果执行此显式过程以在分布式服务之间交换有关类的元信息，则这些服务将能够使用默认的（快速而紧凑的）One Nio配置相互发送序列化的Java对象。毕竟，在服务运行时，它们两侧的类的版本保持不变，这意味着在每次交互过程中都无需在每个序列化结果中“来回拖动”常量元信息。因此，在开始时做了一些更多的操作，然后您可以</font><font style="vertical-align: inherit;">同时使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One Nio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的速度和紧凑性以及</font><i><font style="vertical-align: inherit;">One Nio</font></i><font style="vertical-align: inherit;">的灵活性</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（表示持久性）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。确实需要什么！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，为了以序列化的形式在分布式服务之间传输Java对象（这就是我们组织这次竞赛的目的）&nbsp;</font></font><u><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个Nio是灵活性的赢家</font></font></i></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;（19/20）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在较早在赛车和称重方面出类拔萃的Java序列化程序中，展示了不错的灵活性：</font></font><br>
<br>
<ul>
<li><u><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BSON MongoDb</font></font></i></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;（14.5 / 20），</font></font></li>
<li><u><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">克里奥</font></font></i></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（13/20）。</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基座</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回顾一下过去的Java序列化竞赛的结果：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在比赛中，评分的前两行分别由</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FST（不安全）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One Nio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">划分</font><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BSON MongoDb</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排名第三</font><font style="vertical-align: inherit;">，</font></font></li>
<li><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个Nio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">击败了称重区</font><font style="vertical-align: inherit;">，然后是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BSON MongoDb</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kryo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在灵活性方面，仅出于我们在分布式应用程序之间交换会话上下文的任务，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One Nio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次获得了第一名&nbsp; </font><font style="vertical-align: inherit;">，而</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BSON MongoDb</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kryo表现出色</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，就所获得的结果的整体而言，我们获得的基座如下：</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个Nio</font></font></strong><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在主要比赛中（种族</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font><i><font style="vertical-align: inherit;">FST（不安全）并列</font></i><font style="vertical-align: inherit;">第一</font><font style="vertical-align: inherit;">，但在衡量和测试灵活性方面却大大压倒了竞争对手。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FST（不安全）</font></font></strong><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
也是一个非常快速的Java序列化库，但是，它缺少序列化导致的字节数组的直接和向后兼容性。</font></font></li>
<li><strong>BSON MongoDB&nbsp;+&nbsp;Kryo</strong><br>
 2   3-      Java-,     .       2-   ,          .        <code>Collection</code>  <code>Map</code>,   <i>BSON MongoDB</i>     custom-  / (<code>Externalizable</code>  ..).</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Sberbank的会话数据服务中，我们使用了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One Nio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">库</font><font style="vertical-align: inherit;">在我们的竞争中赢得了第一名。使用该库，Java会话上下文数据被序列化并在应用程序之间传输。由于此修订，会话传输的速度提高了数倍。负载测试表明，在接近Sberbank Online用户实际行为的情况下，仅由于这一改进，就可获得高达40％的加速。这样的结果意味着减少了系统对用户动作的响应时间，从而增加了客户的满意度。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在下一篇文章中，我将尝试在实践中演示</font><i><font style="vertical-align: inherit;">One Nio</font></i><font style="vertical-align: inherit;">的附加加速</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从使用类派生的</font></font><code>sun.reflect.MagicAccessorImpl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">不幸的是，IBM JRE不支持该类的最重要属性，这意味着</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One Nio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此JRE版本上</font><font style="vertical-align: inherit;">的全部潜力</font><font style="vertical-align: inherit;">尚未显现。</font><font style="vertical-align: inherit;">未完待续。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN488602/index.html">FUNCORP的iOS MEETUP＃2以及如何使开发人员保持最新</a></li>
<li><a href="../zh-CN488604/index.html">上周第402期（2020年2月10日至16日）来自前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN488606/index.html">Подлинная сущность ящеролюдей</a></li>
<li><a href="../zh-CN488608/index.html">“荣耀ZHPSS！” 或记得GPSS World</a></li>
<li><a href="../zh-CN488610/index.html">一个人对电磁辐射敏感的故事，或者我们对悬崖边缘的感觉... UPD：+常见问题解答</a></li>
<li><a href="../zh-CN488614/index.html">线轴3.0.0-改进回顾</a></li>
<li><a href="../zh-CN488616/index.html">数据科学和机器学习中的空问题</a></li>
<li><a href="../zh-CN488618/index.html">＃333移动开发人员的有趣材料摘要（2月10日至16日）</a></li>
<li><a href="../zh-CN488622/index.html">清单取代规则吗？</a></li>
<li><a href="../zh-CN488624/index.html">共同经济</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>