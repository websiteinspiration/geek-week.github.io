<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏽 🙍 👨🏼‍🎨 Encarts Android: gérer les peurs et se préparer pour Android Q ◀️ 🦔 🔱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Android Q est la dixième version d'Android avec le niveau d'API 29. L'une des principales idées de la nouvelle version est le concept de bord à bord, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Encarts Android: gérer les peurs et se préparer pour Android Q</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/488196/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android Q est la dixième version d'Android avec le niveau d'API 29. </font><font style="vertical-align: inherit;">L'une des principales idées de la nouvelle version est le concept de bord à bord, lorsque les applications occupent tout l'écran, de bas en haut. </font><font style="vertical-align: inherit;">Cela signifie que la barre d'état et la barre de navigation doivent être transparentes. </font><font style="vertical-align: inherit;">Mais, s'ils sont transparents, il n'y a pas d'interface utilisateur système - elle chevauche les composants interactifs de l'application. </font><font style="vertical-align: inherit;">Ce problème est résolu avec des encarts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les développeurs mobiles évitent les encarts, ils leur font peur. </font><font style="vertical-align: inherit;">Mais dans Android Q, il ne sera pas possible de contourner les encarts - vous devrez les étudier et les appliquer. </font><font style="vertical-align: inherit;">En fait, les encarts n'ont rien de compliqué: ils montrent quels éléments d'écran se croisent avec l'interface système et suggèrent comment déplacer l'élément afin qu'il n'entre pas en conflit avec l'interface utilisateur du système. </font><strong><font style="vertical-align: inherit;">Konstantin Tskhovrebov</font></strong><font style="vertical-align: inherit;"> expliquera le fonctionnement des encarts et leur utilité</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/6Djql74drwk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstantin Tskhovrebov</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terrakok</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) travaille à </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redmadrobot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A été impliqué dans Android pendant 10 ans et a accumulé beaucoup d'expérience dans divers projets dans lesquels il n'y avait pas de place pour les encarts, ils ont toujours réussi à se déplacer d'une manière ou d'une autre. </font><font style="vertical-align: inherit;">Konstantin racontera une longue histoire d'évitement du problème des encarts, d'étudier et de combattre Android. </font><font style="vertical-align: inherit;">Il examinera les tâches typiques de son expérience dans lesquelles des encarts pourraient être appliqués et montrera comment arrêter d'avoir peur du clavier, reconnaître sa taille et répondre à l'apparence. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque. </font><font style="vertical-align: inherit;">L'article a été écrit sur la base d'un rapport de Konstantin à </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saint AppsConf 2019</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Le rapport utilise des documents de plusieurs articles sur des encarts. </font><font style="vertical-align: inherit;">Lien vers ces documents à la fin.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tâches typiques</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barre d'état des couleurs. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans de nombreux projets, le concepteur dessine une barre d'état couleur. </font><font style="vertical-align: inherit;">Il est devenu à la mode lorsque Android 5 est venu avec le nouveau Material Design. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9l/ii/76/9lii76jdfrbb5i0vq8-ecv2ikby.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment peindre la barre d'état? </font><font style="vertical-align: inherit;">Élémentaire - ajoutez </font></font><code>colorPrimaryDark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la couleur est substituée.</font></font><br>
<br>
<pre><code class="kotlin hljs"> &lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;<font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"colorPrimaryDark"</span>&gt;<span class="hljs-meta">@color</span>/colorAccent&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour Android au-dessus de la cinquième version (API à partir de 21 et plus), vous pouvez définir des paramètres spéciaux dans la rubrique:</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;<font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"android:statusBarColor"</span>&gt;<span class="hljs-meta">@color</span>/colorAccent&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barre d'état multicolore</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Parfois, les concepteurs sur différents écrans dessinent la barre d'état de différentes couleurs. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uo/ev/nl/uoevnldknz2rtfq5lcqpn1mpj4g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce n'est pas grave, la façon la plus simple de travailler est avec </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">différents sujets dans différentes activités</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La manière la plus intéressante est de changer les couleurs </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directement lors de l'exécution</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(...)</span></span>: View {<font></font>
    requireActivity().window.statusBarColor = requireContext().getColor(R.color.colorPrimary)<font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le paramètre est modifié via un drapeau spécial. </font><font style="vertical-align: inherit;">Mais l'essentiel est de ne pas oublier de changer la couleur en arrière lorsque l'utilisateur quitte l'écran en arrière. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barre d'état transparente. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est plus difficile. </font><font style="vertical-align: inherit;">Le plus souvent, la transparence est associée aux cartes, car c'est sur les cartes que la transparence est la plus visible. </font><font style="vertical-align: inherit;">Dans ce cas, comme précédemment, nous définissons un paramètre spécial:</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;    <font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentStatus"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, bien sûr, il existe une astuce bien connue - mettre en retrait plus haut, sinon la barre d'état sera superposée à l'icône et elle sera moche.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/49/8f/c8/498fc8wuip6i-o4eutfnviumuio.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais sur d'autres écrans, tout se brise. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/if/-0/0q/if-00qq6b7zidoz-_nfyehlev7s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment résoudre le problème? La première méthode qui me vient à l'esprit est différentes activités: nous avons différents sujets, différents paramètres, ils fonctionnent différemment. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travaillez avec le clavier.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous évitons les encarts non seulement avec la barre d'état, mais aussi lorsque vous travaillez avec le clavier. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s-/jk/mz/s-jkmzxzi-5xqr1ei0ku6pfubpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Personne n'aime l'option de gauche, mais pour la transformer en option de droite, il existe une solution simple.</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;activity<font></font>
    ...<font></font>
    android:windowSoftInputMode=<span class="hljs-string">"adjustResize"</span>&gt;<font></font>
    ...<font></font>
&lt;/activity&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'activité peut maintenant être redimensionnée lorsque le clavier apparaît. Cela fonctionne simplement et sévèrement. Mais n'oubliez pas une autre astuce - enveloppez tout </font></font><code>ScrollView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Du coup le clavier occupera tout l'écran et il y aura une petite bande dessus? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est parfois plus difficile de changer la disposition lorsque le clavier apparaît. Par exemple, sinon organisez les boutons ou masquez le logo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q3/ia/zl/q3iazltlnajt-cpvdzc0u2i8zcs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons entraîné tant de béquilles avec un clavier et une barre d'état transparente, maintenant il est difficile de nous arrêter. Accédez à StackOverflow et copiez le beau code.</font></font><br>
<br>
<pre><code class="kotlin hljs">boolean isOpened = <span class="hljs-literal">false</span>;<font></font>
<font></font>
<span class="hljs-keyword">public</span> void setListenerToRootView() {
    <span class="hljs-keyword">final</span> View activityRootView = getWindow().getDecorView().findViewById(android.R.id.content);<font></font>
    activityRootView.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {<font></font>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> void onGlobalLayout() {<font></font>
    <font></font>
            int heightDiff = activityRootView.getRootView().getHeight() - activityRootView.getHeight();      <font></font>
            <span class="hljs-keyword">if</span> (heightDiff &gt; <span class="hljs-number">100</span>) { <span class="hljs-comment">// 99% of the time the height diff will be due to a keyboard.       </span>
                Toast.makeText(getApplicationContext(), <span class="hljs-string">"Gotcha!!! softKeyboardup"</span>, <span class="hljs-number">0</span>).show();<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (isOpened == <span class="hljs-literal">false</span>) {
                   <span class="hljs-comment">//Do two things, make the view top visible and the editText smaller</span><font></font>
                }<font></font>
                isOpened = <span class="hljs-literal">true</span>;<font></font>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isOpened == <span class="hljs-literal">true</span>) {<font></font>
                Toast.makeText(getApplicationContext(), <span class="hljs-string">"softkeyborad Down!!!"</span>, <span class="hljs-number">0</span>).show();<font></font>
                isOpened = <span class="hljs-literal">false</span>;<font></font>
            }    <font></font>
        }<font></font>
    });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, même la probabilité d'apparition du clavier est calculée. </font><font style="vertical-align: inherit;">Le code fonctionne, dans l'un des projets que nous avons même utilisé, mais pendant longtemps. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De nombreuses béquilles dans les exemples sont associées à l'utilisation de différentes activités. </font><font style="vertical-align: inherit;">Mais ils sont mauvais non seulement parce que ce sont des béquilles, mais aussi pour d'autres raisons: le problème du «démarrage à froid», l'asynchronie. </font><font style="vertical-align: inherit;">J'ai décrit les problèmes plus en détail dans l'article « </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permis de conduire une voiture, ou pourquoi les applications devraient être à activité unique</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ». </font><font style="vertical-align: inherit;">En outre, la documentation de Google indique que l'approche recommandée est une application à activité unique.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'avons-nous fait avant Android 10</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous (chez Redmadrobot) développons des applications d'assez haute qualité, mais nous avons longtemps évité les encarts. Comment avons-nous réussi à les éviter sans grosses béquilles et en une seule activité? </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque. Captures d'écran et code tirés de mon projet pour animaux de compagnie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Imaginez l'écran de l'application. Lorsque nous avons développé nos applications, nous n'avons jamais pensé qu'il pourrait y avoir une barre de navigation transparente ci-dessous. Y a-t-il une barre noire en dessous? Alors quoi, les utilisateurs y sont habitués. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ce/ab/6v/ceab6v6m5dqnbl9zpotdi1vqmre.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En haut, nous avons initialement défini le paramètre selon lequel la barre d'état est noire avec transparence. À quoi cela ressemble-t-il en termes de mise en page et de code?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0g/tu/of/0gtuoffisoeudtgxlnmqd-jicnk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'abstraction sur la figure: le bloc rouge est l'activité de l'application, le bleu est le fragment avec le bot de navigation (avec Tabs), et à l'intérieur les fragments verts avec le contenu sont commutés. On peut voir que la barre d'outils n'est pas sous la barre d'état. Comment y sommes-nous parvenus? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android a un drapeau délicat </font></font><code>fitSystemWindow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si vous le définissez sur true, le conteneur s'ajoutera un remplissage pour que rien à l'intérieur ne tombe sous la barre d'état. Je pense que ce drapeau est la béquille officielle de Google pour ceux qui ont peur des encarts. Tout utiliser fonctionnera relativement bien sans encarts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'indicateur </font></font><code>FitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajoute un remplissage au conteneur que vous avez spécifié. Mais la hiérarchie est importante: si l'un des parents définit ce drapeau sur "true", sa distribution ne sera pas prise en compte, car le conteneur a déjà appliqué l'indentation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le drapeau fonctionne, mais un autre problème apparaît. </font><font style="vertical-align: inherit;">Imaginez un écran avec deux onglets. </font><font style="vertical-align: inherit;">Lors du basculement, une transaction est lancée, ce qui provoque un </font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fragment l'un sur l'autre, et tout se casse. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/02/_u/lv02_ui9sepxlvi7djz_xpem2sy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxième fragment a également un indicateur </font></font><code>FitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et cela ne devrait pas se produire. </font><font style="vertical-align: inherit;">Mais que s'est-il passé, pourquoi? </font><font style="vertical-align: inherit;">La réponse est que c'est une béquille, et parfois cela ne fonctionne pas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais nous avons trouvé une solution sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stack Overflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : utilisez root pour pas des fragments </font></font><code>FrameLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais </font></font><code>CoordinatorLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il a été créé à d'autres fins, mais cela fonctionne ici.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ça marche?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons à la source ce qui se passe </font></font><code>CoordinatorLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> void onAttachedToWindow() {   
    <span class="hljs-keyword">super</span>.onAttachedToWindow();<font></font>
    ...    <font></font>
    <span class="hljs-keyword">if</span> (mLastInsets == <span class="hljs-literal">null</span> &amp;&amp; ViewCompat.getFitsSystemWindows(<span class="hljs-keyword">this</span>)) {         
        <span class="hljs-comment">// We're set to fitSystemWindows but we haven't had any insets yet...</span>
        <span class="hljs-comment">// We should request a new dispatch of window insets</span>
        ViewCompat.requestApplyInsets(<span class="hljs-keyword">this</span>);<font></font>
    }     <font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous voyons un beau commentaire selon lequel des encarts sont nécessaires ici, mais ils ne le sont pas. </font><font style="vertical-align: inherit;">Nous devons leur demander à nouveau lorsque nous demandons une fenêtre. </font><font style="vertical-align: inherit;">Nous avons compris que les encarts fonctionnent d'une manière ou d'une autre à l'intérieur, mais nous ne voulons pas travailler avec eux et partir </font></font><code>Coordinator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au printemps 2019, nous avons développé l'application, date à laquelle Google I / O vient de passer. </font><font style="vertical-align: inherit;">Nous n'avons pas encore tout compris, nous avons donc continué à nous accrocher aux préjugés. </font><font style="vertical-align: inherit;">Mais nous avons remarqué que la commutation des onglets en bas est en quelque sorte lente, car nous avons une disposition complexe, chargée avec l'interface utilisateur. </font><font style="vertical-align: inherit;">Nous trouvons un moyen simple de résoudre ce problème - changez </font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour </font></font><code>show/hide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que chaque fois que vous ne recréez pas la mise en page.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/7l/vz/hx7lvzsl8-kfv3qqac2pbvllt8q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous changeons, et encore une fois rien ne fonctionne - tout est cassé! </font><font style="vertical-align: inherit;">Apparemment, il n'est tout simplement pas possible de disperser les béquilles, vous devez comprendre pourquoi elles ont fonctionné. </font><font style="vertical-align: inherit;">Nous étudions le code et il s'avère que tout ViewGroup est également capable de travailler avec des encarts.</font></font><br>
<br>
<pre><code class="kotlin hljs">
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {    <font></font>
    insets = <span class="hljs-keyword">super</span>.dispatchApplyWindowInsets(insets);     
    <span class="hljs-keyword">if</span> (!insets.isConsumed()) {         
        <span class="hljs-keyword">final</span> int count = getChildCount();        
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; count; i++) {<font></font>
            insets = getChildAt(i).dispatchApplyWindowInsets(insets);             <font></font>
            <span class="hljs-keyword">if</span> (insets.isConsumed()) {          
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> insets;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a une telle logique à l'intérieur: si au moins quelqu'un a déjà traité des encarts, alors toutes les vues suivantes à l'intérieur du ViewGroup ne les recevront pas. </font><font style="vertical-align: inherit;">Qu'est-ce que cela signifie pour nous? </font><font style="vertical-align: inherit;">Permettez-moi de vous montrer un exemple de notre FrameLayout, qui change d'onglet. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/h1/fo/nn/h1fonnc4qrqpmj_x-fc8m47ptci.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À l'intérieur, il y a le premier fragment dont le drapeau est réglé </font></font><code>fitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela signifie que le premier fragment traite les encarts. </font><font style="vertical-align: inherit;">Après cela, nous appelons le </font></font><code>HIDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">premier fragment et le </font></font><code>SHOW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">second. </font><font style="vertical-align: inherit;">Mais le premier reste dans la mise en page - sa vue est laissée, juste cachée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le conteneur passe par sa Vue: il prend le premier fragment, lui donne des encarts, et de lui </font></font><code>fitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- il les a pris et les a traités. </font><font style="vertical-align: inherit;">Parfaitement, FrameLayout a regardé que les encarts étaient traités et ne les a pas donnés au deuxième fragment. </font><font style="vertical-align: inherit;">Tout fonctionne comme il se doit. </font><font style="vertical-align: inherit;">Mais cela ne nous convient pas, que devons-nous faire?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous écrivons notre propre ViewGroup</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous venions de Java, et là OOP dans toute sa splendeur, nous avons donc décidé d'hériter. </font><font style="vertical-align: inherit;">Nous avons écrit notre propre ViewGroup, à partir duquel nous avons redéfini la méthode </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il fonctionne comme nous en avons besoin: il rend toujours aux enfants les encarts qui sont venus, que nous les ayons traités ou non.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowInsetFrameLayout</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
    context: Context,      <font></font>
    attrs: AttributeSet? = <span class="hljs-literal">null</span>,     <font></font>
    defStyleRes: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><font></font>
) : FrameLayout(context, attrs, defStyleRes) {<font></font>
<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchApplyWindowInsets</span><span class="hljs-params">(insets: <span class="hljs-type">WindowInsets</span>)</span></span>: WindowInsets { 
        <span class="hljs-keyword">for</span> (child <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span> until childCount)) {<font></font>
            getChildAt(child).dispatchApplyWindowInsets(insets)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> insets.consumeSystemWindowInsets()<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ViewGroup personnalisé fonctionne, le projet est aussi tout ce dont nous avons besoin. </font><font style="vertical-align: inherit;">Mais il ne parvient toujours pas à une solution générale. </font><font style="vertical-align: inherit;">Lorsque nous avons compris ce qu'ils nous ont dit sur Google IO, nous avons réalisé que nous ne serions plus en mesure d'agir comme ça.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 10</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android 10 nous a montré deux concepts d'interface utilisateur importants auxquels il est strictement recommandé d'adhérer: bord à bord et navigation gestuelle. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Côte à côte.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ce </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">concept</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> suggère que le contenu de l'application devrait occuper </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tout l'espace possible</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur l'écran. Pour nous, en tant que développeurs, cela signifie que les applications doivent être placées </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sous les panneaux système de la barre d'état et de la barre de navigation.</font></font></strong><br>
<br>
<img src="https://habrastorage.org/webt/cr/gl/nh/crglnh9iw__fu4lct0gavaibqey.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Auparavant, nous pouvions en quelque sorte ignorer cela ou être placés uniquement sous la barre d'état. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quant aux listes, elles doivent défiler non seulement jusqu'au dernier élément, mais aussi plus loin </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour ne pas rester sous la barre de navigation.</font></font></strong><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tl/pl/it/tlplit1o65rn55edkixuuojxtha.png" width="350"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigation gestuelle. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce deuxième concept important est la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">navigation gestuelle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il vous permet de contrôler l'application avec vos doigts depuis le bord de l'écran. </font><font style="vertical-align: inherit;">Le mode gestuel n'est pas standard, tout semble différent, mais maintenant vous ne pouvez pas basculer entre deux barres de navigation différentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ce moment, nous avons réalisé que tout n'est pas si simple. </font><font style="vertical-align: inherit;">Il ne sera pas possible d'éviter davantage les encarts si nous voulons développer des applications de qualité. </font><font style="vertical-align: inherit;">Il est temps d'étudier la documentation et de comprendre ce que sont les encarts.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encarts </font><font style="vertical-align: inherit;">Que devez-vous savoir à leur sujet?</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des encarts ont été créés pour effrayer les développeurs.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ils le font parfaitement depuis le moment où il est apparu dans Android 5. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, tout n'est pas si effrayant. Le concept des encarts est simple - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ils signalent une superposition d'interface utilisateur système sur l'écran de l'application.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il peut s'agir d'une barre de navigation, d'une barre d'état ou d'un clavier. Le clavier est également une interface utilisateur système standard, qui se superpose à l'application. Il n'est pas nécessaire d'essayer de le traiter avec des béquilles, seulement des encarts. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le but des encarts est de résoudre les conflits</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Par exemple, s'il y a un autre élément au-dessus de notre bouton, nous pouvons déplacer le bouton afin que l'utilisateur puisse continuer à utiliser l'application. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour gérer l'encart,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilisez </font></font><code>Windowlnsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour Android 10 et </font></font><code>WindowInsetsCompat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour les autres versions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe </font><strong><font style="vertical-align: inherit;">5 types différents d'encarts</font></strong><font style="vertical-align: inherit;"> dans Android 10</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et un "bonus", qui n'est pas appelé encart, mais sinon. </font><font style="vertical-align: inherit;">Nous traiterons tous les types, car la plupart ne connaissent qu'une seule chose: les insertions de fenêtres système.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encarts de fenêtre système</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Introduit dans Android 5.0 (API 21). </font><font style="vertical-align: inherit;">Obtenu par la méthode </font></font><code>getSystemWindowInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit du principal type d'encarts avec lequel vous devez apprendre à travailler, car les autres fonctionnent de la même manière. </font><font style="vertical-align: inherit;">Ils sont nécessaires pour traiter la barre d'état, tout d'abord, puis la barre de navigation et le clavier. </font><font style="vertical-align: inherit;">Par exemple, ils résolvent un problème lorsque la barre de navigation se trouve au-dessus de l'application. </font><font style="vertical-align: inherit;">Comme dans l'image: le bouton est resté sous la barre de navigation, l'utilisateur ne peut pas cliquer dessus et est très mécontent.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/yj/tt/nxyjttdppbkrnrnqkspovzp4hko.png" width="350"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inserts d'éléments taraudables</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apparu uniquement dans Android 10. Obtenu par la méthode </font></font><code>getTappableElementInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces encarts </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont utiles que </font><strong><font style="vertical-align: inherit;">pour gérer divers modes de barre de navigation</font></strong><font style="vertical-align: inherit;"> . Comme le dit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Bane</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lui-même </font><font style="vertical-align: inherit;">, vous pouvez oublier ce type d'encarts et contourner uniquement les encarts de fenêtre système. Mais si vous voulez que l'application soit 100% cool, pas 99,9% cool, vous devez l'utiliser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regarde l'image. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/yd/fk/rlydfkwy39pfrc7jfhizhqdkg0q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En haut, la couleur pourpre indique les encarts de la fenêtre système, qui se présenteront dans différents modes de la barre de navigation. On peut voir qu'à droite et à gauche ils sont égaux à la barre de navigation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rappelez-vous comment fonctionne la navigation gestuelle: dans le bon mode, nous ne cliquons jamais sur un nouveau panneau, mais faisons toujours glisser nos doigts de bas en haut. </font><font style="vertical-align: inherit;">Cela signifie que les boutons ne peuvent pas être supprimés. </font><font style="vertical-align: inherit;">Nous pouvons continuer à appuyer sur notre bouton FAB (Floating Action Button), personne n'interférera. </font><font style="vertical-align: inherit;">Par conséquent, il </font></font><code>TappableElementInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera vide car FAB n'est pas nécessaire de se déplacer. </font><font style="vertical-align: inherit;">Mais si nous montons un peu plus haut, ça va. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La différence n'apparaît qu'avec la navigation gestuelle et la barre de navigation transparente</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (adaptation des couleurs). </font><font style="vertical-align: inherit;">Ce n'est pas une situation très agréable. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/ei/qz/zveiqz33n9dc290ib9yhrrjl09u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout fonctionnera, mais ça a l'air désagréable. </font><font style="vertical-align: inherit;">L'utilisateur peut être dérouté par la proximité des éléments. </font><font style="vertical-align: inherit;">On peut expliquer que l'un est pour les gestes et l'autre pour le pressage, mais toujours pas beau. </font><font style="vertical-align: inherit;">Par conséquent, élevez le FAB plus haut ou laissez-le à droite.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encarts gestuels du système</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apparu uniquement dans Android 10. Obtenu par la méthode </font></font><code>getSystemGestureInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces encarts sont liés à la navigation gestuelle. Initialement, il a été supposé que l'interface utilisateur du système est dessinée au-dessus de l'application, mais les insertions de gestes système indiquent que ce n'est pas l'interface utilisateur qui est dessinée, mais le système lui-même gère les gestes. Ils décrivent où le système gérera les gestes par défaut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les zones de ces encarts sont approximativement celles marquées en jaune sur le schéma. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/8d/jl/vv8djlgxe4cnjchozbllrysagd0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais je veux vous avertir - ils ne seront pas toujours comme ça. Nous ne saurons jamais quels nouveaux écrans Samsung et d'autres fabricants proposeront. Il existe déjà des appareils dans lesquels l'écran est de tous les côtés. Peut-être que les encarts ne seront pas du tout là où nous nous attendons. Par conséquent, vous devez travailler avec eux comme avec certaines abstractions: il existe de tels encarts dans les encarts de mouvement du système dans lesquels le système lui-même traite les gestes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces encarts peuvent être remplacés. </font><font style="vertical-align: inherit;">Par exemple, vous développez un éditeur de photos. </font><font style="vertical-align: inherit;">Dans certains endroits, vous voulez gérer vous-même les gestes, même s'ils sont près du bord de l'écran. </font><font style="vertical-align: inherit;">Indiquez au système que vous traiterez vous-même le point à l'écran dans le coin de la photo. </font><font style="vertical-align: inherit;">Il peut être redéfini en disant au système: "Je traiterai toujours le carré autour du point moi-même."</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encarts gestuels système obligatoires</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apparu uniquement dans Android 10. Il s'agit d'un sous-type d'inserts de gestes système, mais ils ne peuvent pas être remplacés par l'application. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous utilisons la méthode </font></font><code>getMandatorySystemGestureInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour déterminer la zone où ils ne fonctionneront pas. </font><font style="vertical-align: inherit;">Cela a été fait intentionnellement de sorte qu'il était impossible de développer une application «désespérée»: redéfinissez le geste de navigation de bas en haut, ce qui vous permet de quitter l'application vers l'écran principal. </font><font style="vertical-align: inherit;">Ici, le </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">système traite toujours les gestes lui-même</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/89/gl/df/89gldfknoq8z9dje_naytwp0pti.png" width="450"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce ne sera pas nécessairement sur le dessous de l'appareil et pas nécessairement de cette taille. </font><font style="vertical-align: inherit;">Travaillez avec lui comme une abstraction. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agissait de types d'encarts relativement nouveaux. </font><font style="vertical-align: inherit;">Mais il y a ceux qui sont apparus avant même Android 5 et ont été appelés différemment.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inserts stables</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Introduit avec Android 5.0 (API 21). Obtenu par la méthode </font></font><code>getStableInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Même les développeurs expérimentés ne peuvent pas toujours dire pourquoi ils sont nécessaires. Je vais vous dire un secret: ces encarts ne sont utiles que pour les applications plein écran: lecteurs vidéo, jeux. Par exemple, en mode lecture, toute interface utilisateur système est masquée, y compris la barre d'état, qui se déplace au-delà du bord de l'écran. Mais cela vaut la peine de toucher l'écran, car la barre d'état apparaîtra en haut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous placez un bouton RETOUR en haut de l'écran, alors qu'il traite correctement les insertions de la fenêtre système, puis avec chaque onglet, une interface utilisateur apparaît sur l'écran d'en haut, et le bouton saute vers le bas. Si vous ne touchez pas l'écran pendant un certain temps, la barre d'état disparaît, le bouton rebondit car les encarts de la fenêtre système ont disparu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour de tels cas, les inserts stables sont parfaits. </font><font style="vertical-align: inherit;">Ils disent que maintenant aucun élément n'est dessiné sur votre application, mais qu'ils peuvent le faire. </font><font style="vertical-align: inherit;">Avec ces encarts, vous pouvez connaître à l'avance la valeur de la barre d'état dans ce mode, par exemple, et positionner le bouton où vous le souhaitez. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque. </font><font style="vertical-align: inherit;">La méthode </font></font></em><code><em>getStableInsets()</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'apparaissait qu'avec l'API 21. Auparavant, il y avait plusieurs méthodes pour chaque côté de l'écran.&nbsp;</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons examiné 5 types d'encarts, mais il y en a un autre qui ne s'applique pas directement aux encarts. </font><font style="vertical-align: inherit;">Il aide à gérer les franges et les découpes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frange et décolleté</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les écrans ne sont plus carrés. </font><font style="vertical-align: inherit;">Ils sont oblongs, avec une ou plusieurs découpes pour la caméra et une frange de tous les côtés. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ls/kv/sc/lskvscp_j-hy2gesyynicb346cq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusqu'à 28 API, nous n'avons pas pu les traiter. </font><font style="vertical-align: inherit;">J'ai dû deviner à travers des encarts ce qui se passait là-bas. </font><font style="vertical-align: inherit;">Mais avec l'API 28 et au-delà (de l'ancien Android), la classe est officiellement apparue </font></font><code>DisplayCutout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">C'est dans les mêmes encarts à partir desquels vous pouvez obtenir tous les autres types. </font><font style="vertical-align: inherit;">La classe vous permet de connaître l'emplacement et la taille des artefacts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus des informations de localisation, un ensemble d'indicateurs y est fourni pour le développeur </font></font><code>WindowManager.LayoutParams</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ils vous permettent d'inclure différents comportements autour des découpes. </font><font style="vertical-align: inherit;">Votre contenu peut être affiché autour d'eux, ou peut ne pas être affiché: en mode paysage et portrait de différentes manières. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Drapeaux</font></font><code>window.attributes.layoutInDisplayCutoutMode =</code><br>
<br>
<ul>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En portrait - il y a, et en paysage - une barre noire par défaut.</font></font></li>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pas du tout - une bande noire.</font></font></li>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - est toujours.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'affichage peut être contrôlé, mais nous travaillons avec eux de la même manière qu'avec les autres encarts.</font></font><br>
<br>
<pre><code class="kotlin hljs">insets.displayCutout<font></font>
    .boundingRects<font></font>
    .forEach { rect -&gt; ... }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le rappel avec des encarts avec un tableau nous vient </font></font><code>displayCutout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ensuite, nous pouvons le parcourir, traiter toutes les découpes et les franges qui se trouvent dans l'application. </font><font style="vertical-align: inherit;">Vous pouvez en savoir plus sur la façon de travailler avec eux </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans l'article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compris avec 6 types d'encarts. </font><font style="vertical-align: inherit;">Voyons maintenant comment cela fonctionne.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment ça fonctionne</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des encarts sont nécessaires, tout d'abord, lorsque quelque chose est dessiné au-dessus de l'application, par exemple, la barre de navigation. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ft/ct/_w/ftct_wh_dc64t9rw6ir_7zpqg8m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sans encarts, l'application n'aura pas de barre de navigation et de barre d'état transparentes. </font><font style="vertical-align: inherit;">Ne soyez pas surpris que vous ne veniez pas </font></font><code>SystemWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cela arrive.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inserts répartis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ensemble de la hiérarchie de l'interface utilisateur ressemble à un arbre avec une vue à ses extrémités. </font><font style="vertical-align: inherit;">Les nœuds sont généralement un ViewGroup. </font><font style="vertical-align: inherit;">Ils héritent également de View, de sorte que les encarts leur parviennent d'une manière spéciale </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">À partir de la vue racine, le système envoie des encarts à travers l'arborescence. </font><font style="vertical-align: inherit;">Voyons comment fonctionne View dans ce cas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jy/rw/hk/jyrwhkavrimytpqs4je0ltfn7-w.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le système fait appel à la méthode </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans laquelle s'insèrent les encarts. </font><font style="vertical-align: inherit;">Cette vue devrait renvoyer quelque chose. </font><font style="vertical-align: inherit;">Que faire pour gérer ce comportement? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par souci de simplicité, nous considérons uniquement les WindowInsets.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inserts de manutention</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, la redéfinition de la méthode </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et de l'implémentation à l'intérieur de sa propre logique </font><font style="vertical-align: inherit;">semble logique </font><font style="vertical-align: inherit;">: des encarts sont venus, nous avons tout implémenté à l'intérieur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous ouvrez la classe View et regardez le Javadoc écrit au-dessus de cette méthode, vous pouvez voir: "Ne remplacez pas cette méthode!"</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous traitons les encarts par délégation ou héritage.</font></font></blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisez la délégation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Google a donné la possibilité d'exposer son propre délégué, qui est responsable de la gestion des encarts. </font><font style="vertical-align: inherit;">Vous pouvez l'installer via la méthode </font></font><code>setOnApplyWindowInsetsListener(listener)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous avons défini un rappel qui gère ces encarts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si, pour une raison quelconque, cela ne nous convient pas, vous pouvez </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hériter de View et remplacer une autre méthode</font></font></strong> <code>onApplyWindowInsets(WindowInsets insets)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nous y substituons nos propres encarts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google n'a pas choisi entre la délégation et l'héritage, mais a permis de tout faire ensemble. </font><font style="vertical-align: inherit;">C'est formidable car nous n'avons pas à redéfinir toutes les barres d'outils ou ListView pour gérer les encarts. </font><font style="vertical-align: inherit;">Nous pouvons prendre n'importe quelle vue prête à l'emploi, même une bibliothèque, et y définir le délégué, qui gérera les encarts sans redéfinition. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que retournerons-nous?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi retourner quelque chose?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ce faire, vous devez comprendre le fonctionnement de la distribution des encarts, c'est-à-dire ViewGroup. </font><font style="vertical-align: inherit;">Que fait-elle en elle. </font><font style="vertical-align: inherit;">Examinons de plus près le comportement par défaut en utilisant l'exemple que j'ai montré plus tôt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les encarts système sont venus en haut et en bas, par exemple, 100 pixels chacun. </font><font style="vertical-align: inherit;">Le ViewGroup les envoie à la première vue dont il dispose. </font><font style="vertical-align: inherit;">Cette vue les a traités d'une manière ou d'une autre et renvoie des encarts: en haut, elle diminue à 0, mais en bas, elle part. </font><font style="vertical-align: inherit;">En haut, elle a ajouté un rembourrage ou une marge, mais en bas, elle n'a pas touché et a signalé cela. </font><font style="vertical-align: inherit;">Ensuite, le ViewGroup transmet des encarts à la deuxième vue. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tj/-a/rw/tj-arwxjkus-n6xnvl099lqbqqg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La vue suivante traite et affiche les encarts. </font><font style="vertical-align: inherit;">Le ViewGroup voit maintenant que les encarts sont traités à la fois au-dessus et en dessous - il ne reste plus rien, tous les paramètres sont nuls. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La troisième vue ne sait même pas qu'il y avait des encarts et quelque chose se passait</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">ViewGroup renverra les encarts à celui qui les a exposés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque nous avons commencé à traiter ce sujet, nous avons noté l'idée par nous-mêmes - renvoyons toujours les mêmes encarts qui sont venus. </font><font style="vertical-align: inherit;">Nous voulions éviter une telle situation lorsque certains View ne reconnaissaient même pas qu'il y avait des encarts. </font><font style="vertical-align: inherit;">L'idée semblait logique. </font><font style="vertical-align: inherit;">Mais il s'est avéré que non. </font><font style="vertical-align: inherit;">Google n'a en vain pas ajouté de comportement aux encarts, comme dans l'exemple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela est nécessaire pour que les encarts atteignent toujours toute la hiérarchie de la vue et que vous puissiez toujours travailler avec eux. </font><font style="vertical-align: inherit;">Dans ce cas, il n'y aura pas de situation lorsque nous basculons deux fragments, l'un a traité et le second n'a pas encore été reçu. </font><font style="vertical-align: inherit;">Dans la partie pratique, nous reviendrons sur ce point.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entraine toi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La théorie est terminée. </font><font style="vertical-align: inherit;">Voyons à quoi cela ressemble dans le code, car en théorie tout est toujours fluide. </font><font style="vertical-align: inherit;">Nous utiliserons AndroidX. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque. </font><font style="vertical-align: inherit;">Dans </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox,</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tout est déjà implémenté dans le code, prise en charge complète de tous les goodies du nouvel Android. </font><font style="vertical-align: inherit;">Afin de ne pas vérifier les versions d'Android et de ne pas rechercher le type requis d'Insets, utilisez toujours la </font></font></em><code><em>view.setOnApplyWindowInsetsListener { v, insets -&gt; ... }</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">version d'AndroidX - à la </font></font></em><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">place </font></em></font><code><em>ViewCompat.setOnApplyWindowInsetsListener(view) { v, insets -&gt; ... }</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un écran avec une barre de navigation sombre. </font><font style="vertical-align: inherit;">Il ne chevauche aucun élément sur le dessus. </font><font style="vertical-align: inherit;">Tout est comme d'habitude.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/3r/wq/sp/3rwqspgcdlgie2m00lmedkwzgi8.png" width="350"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il s'avère que nous devons maintenant le rendre transparent. </font><font style="vertical-align: inherit;">Comment?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Activez la transparence</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le plus simple est d'indiquer au sujet que la barre d'état et la barre de navigation sont transparentes.</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.MaterialComponents.Light"</span>&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentStatus"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentNavigation"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À ce moment, tout commence à se chevaucher à la fois d'en haut et d'en bas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est intéressant de noter qu'il existe deux indicateurs, et il y a toujours trois options. Si vous spécifiez la transparence pour la barre de navigation, la barre d'état deviendra transparente par elle-même - une telle limitation. </font><font style="vertical-align: inherit;">Vous ne pouvez pas écrire la première ligne, mais j'aime toujours la clarté, alors j'écris 2 lignes pour que les abonnés puissent comprendre ce qui se passe, et ne pas creuser à l'intérieur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous choisissez cette méthode, la barre de navigation et la barre d'état deviennent noires avec transparence. </font><font style="vertical-align: inherit;">Si l'application est blanche, vous ne pouvez ajouter des couleurs qu'à partir du code. </font><font style="vertical-align: inherit;">Comment faire?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Activez la transparence avec la couleur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est bon que nous ayons une application d'activité unique, nous avons donc mis deux drapeaux dans une activité.</font></font><br>
<br>
<pre><code class="kotlin hljs">rootView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or  <font></font>
    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION<font></font>
<font></font>
&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.MaterialComponents.Light"</span>&gt;<font></font>
    &lt;!-- Set the navigation bar to <span class="hljs-number">50</span>% translucent white --&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:navigationBarColor"</span>&gt;#<span class="hljs-number">80F</span>FFFFF&lt;/item&gt; <font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a beaucoup de drapeaux là-bas, mais ce sont ces deux-là qui aideront à rendre la transparence dans la barre de navigation et la barre d'état. </font><font style="vertical-align: inherit;">La couleur peut être spécifiée via le thème. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est le comportement étrange d'Android: quelque chose à travers le thème et quelque chose à travers les drapeaux. </font><font style="vertical-align: inherit;">Mais nous pouvons spécifier des paramètres à la fois dans le code et dans le sujet. </font><font style="vertical-align: inherit;">Ce n'est pas si mauvais pour Android, juste sur les anciennes versions d'Android, le drapeau spécifié dans le sujet sera ignoré. </font></font><code>navigationBarColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela mettra en évidence que sur Android 5, ce n'est pas le cas, mais tout ira de pair. </font><font style="vertical-align: inherit;">Dans GitFox, c'est à partir du code que j'ai défini la couleur de la barre de navigation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons commis des fraudes - indiqué que la barre de navigation est blanche et transparente. </font><font style="vertical-align: inherit;">Maintenant, l'application ressemble à ceci.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/vs/mz/eovsmz1tczlc9vl_kg2yihxs0u0.png" width="350"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quoi de plus simple que de manipuler des encarts?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En effet, élémentaire.</font></font><br>
<br>
<pre><code class="kotlin hljs">ViewCompat<font></font>
    .setOnApplyWindowInsetsListener(bottomNav) { view, insets -&gt;  <font></font>
        view.updatePadding(bottom = insets.systemWindowInsetBottom) <font></font>
        insets<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous prenons la méthode </font></font><code>setOnApplyWindowInsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la transmettons </font></font><code>bottomNav</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous disons que lorsque les encarts viennent, installez le rembourrage inférieur qui est entré </font></font><code>systemWindowInsetBottom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous le voulons en dessous, mais tous nos éléments cliquables sont au-dessus. </font><font style="vertical-align: inherit;">Nous renvoyons entièrement les encarts afin que toutes les autres vues de notre hiérarchie les reçoivent également. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout a l'air génial.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zl/8e/ku/zl8ekuc_pvpc2wrmeop-khxmomg.png" width="350"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il ya un hic. </font><font style="vertical-align: inherit;">Si dans la mise en page, nous avons indiqué une sorte de rembourrage dans la barre de navigation ci-dessous, alors ici, il a été supprimé - définissez des </font></font><code>updatePadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encarts égaux. </font><font style="vertical-align: inherit;">Notre mise en page ne ressemble pas à ce que nous souhaiterions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour enregistrer les valeurs de la mise en page, vous devez d'abord enregistrer ce qui se trouve dans le rembourrage inférieur. </font><font style="vertical-align: inherit;">Plus tard, lorsque les encarts arrivent, ajoutez et définissez les valeurs résultantes.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> bottomNavBottomPadding = bottomNav.paddingBottom<font></font>
ViewCompat<font></font>
    .setOnApplyWindowInsetsListener(bottomNav) { view, insets -&gt;                 <font></font>
        view.updatePadding(<font></font>
        bottom = bottomNavBottomPadding + insets.systemWindowInsetBottom<font></font>
    )<font></font>
    Insets<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'est pas pratique d'écrire de cette façon: partout dans le code où vous utilisez des encarts, vous devez enregistrer la valeur de la mise en page, puis les ajouter à l'interface utilisateur. </font><font style="vertical-align: inherit;">Mais il y a Kotlin, et c'est merveilleux - vous pouvez écrire votre propre extension, qui fera tout cela pour nous.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez Kotlin!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous nous en souvenons </font></font><code>initialPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le donnons au gestionnaire lorsque de nouveaux encarts arrivent (avec eux). </font><font style="vertical-align: inherit;">Cela les aidera à s'additionner ou à construire une sorte de logique par le haut.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">doOnApplyWindowInsets</span><span class="hljs-params">(block: (<span class="hljs-type">View</span>, <span class="hljs-type">WindowInsetsCompat</span>, <span class="hljs-type">Rect</span>) -&gt; <span class="hljs-type">WindowInsetsCompat</span>)</span></span> {    <font></font>
<font></font>
    <span class="hljs-keyword">val</span> initialPadding = recordInitialPaddingForView(<span class="hljs-keyword">this</span>)<font></font>
<font></font>
    ViewCompat.setOnApplyWindowInsetsListener(<span class="hljs-keyword">this</span>) { v, insets -&gt;        <font></font>
        block(v, insets, initialPadding)<font></font>
    }<font></font>
    <font></font>
    requestApplyInsetsWhenAttached()<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recordInitialPaddingForView</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> =<font></font>
   Rect(view.paddingLeft, view.paddingTop, view.paddingRight, view.paddingBottom)<font></font>
<font></font>
  .<font></font>
<font></font>
bottomNav.doOnApplyWindowInsets { view, insets, padding -&gt;   <font></font>
    view.updatePadding(<font></font>
        bottom = padding.bottom + insets.systemWindowInsetBottom<font></font>
    ) <font></font>
    insets<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons redéfinir la lambda. </font><font style="vertical-align: inherit;">Il a non seulement des inserts, mais aussi des rembourrages. </font><font style="vertical-align: inherit;">Nous pouvons les ajouter non seulement d'en bas, mais aussi d'en haut, si c'est une barre d'outils qui traite la barre d'état.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelque chose oublié!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un appel à une méthode incompréhensible.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">doOnApplyWindowInsets</span><span class="hljs-params">(block: (<span class="hljs-type">View</span>, <span class="hljs-type">WindowInsetsCompat</span>, <span class="hljs-type">Rect</span>) -&gt; <span class="hljs-type">WindowInsetsCompat</span>)</span></span> {<font></font>
<font></font>
    <span class="hljs-keyword">val</span> initialPadding = recordInitialPaddingForView(<span class="hljs-keyword">this</span>)<font></font>
     <font></font>
    ViewCompat.setOnApplyWindowInsetsListener(<span class="hljs-keyword">this</span>) { v, insets -&gt;        <font></font>
        block(v, insets, initialPadding)<font></font>
    }<font></font>
      <font></font>
    requestApplyInsetsWhenAttached() <font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recordInitialPaddingForView</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> =<font></font>
      Rect(view.paddingLeft, view.paddingTop, view.paddingRight, view.paddingBottom)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela est dû au fait que vous ne pouvez pas simplement espérer que le système vous enverra des encarts. </font><font style="vertical-align: inherit;">Si nous créons une vue à partir du code ou l'installons un </font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peu plus tard, le système lui-même peut ne pas transmettre la dernière valeur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons vérifier que lorsque la vue est à l'écran, nous avons dit au système: "Des encarts sont arrivés, nous voulons les traiter." </font><font style="vertical-align: inherit;">Nous définissons l'écouteur et devons faire une demande </font></font><code>requestsApplyInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. "</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">requestApplyInsetsWhenAttached</span><span class="hljs-params">()</span></span> {    
    <span class="hljs-keyword">if</span> (isAttachedToWindow) {        <font></font>
        requestApplyInsets()<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        addOnAttachStateChangeListener(<span class="hljs-keyword">object</span> : View.OnAttachStateChangeListener {            
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> {<font></font>
                v.removeOnAttachStateChangeListener(<span class="hljs-keyword">this</span>)<font></font>
                v.requestApplyInsets()           <font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> = <span class="hljs-built_in">Unit</span><font></font>
        })<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous avons créé un code View et ne l'avons pas encore attaché à notre mise en page, nous devons alors nous abonner à l'heure à laquelle nous le faisons. </font><font style="vertical-align: inherit;">C'est seulement alors que nous demandons des encarts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais là encore, il y a Kotlin: ils ont écrit une simple extension et nous n'avons plus à y penser.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refining RecyclerView</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parlons maintenant de la finalisation de RecyclerView. Le dernier élément tombe sous la barre de navigation et reste en dessous - laid. Il est également gênant de cliquer dessus. Si ce n'est pas un nouveau panneau, mais l'ancien, un grand, alors en général l'élément entier peut disparaître en dessous. Que faire? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jc/qa/f7/jcqaf7okahkrhrrnols54exqhdu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première idée consiste à ajouter un élément ci-dessous et à définir la hauteur pour s'adapter aux encarts. Mais si nous avons une application avec des centaines de listes, nous devrons en quelque sorte souscrire chaque liste à des encarts, y ajouter un nouvel élément et définir la hauteur. De plus, RecyclerView est asynchrone, on ne sait pas quand cela fonctionnera. Il y a beaucoup de problèmes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il y a un autre hack officiel. Étonnamment, cela fonctionne efficacement.</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;androidx.recyclerview.widget.RecyclerView <font></font>
        android:id=<span class="hljs-string">"@+id/recyclerView"</span>        
    android:layout_width=<span class="hljs-string">"match_parent"</span>    
    android:layout_height=<span class="hljs-string">"match_parent"</span>             
    android:clipToPadding=<span class="hljs-string">"false"</span> /&gt;<font></font>
<font></font>
recyclerView.doOnApplyWindowInsets { view, insets, padding -&gt;    <font></font>
    view.updatePadding(<font></font>
        bottom = padding.bottom + insets.systemWindowInsetBottom<font></font>
    )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un tel drapeau dans la mise en page </font></font><code>clipToPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Par défaut, c'est toujours vrai. Cela suggère que vous n'avez pas besoin de dessiner des éléments qui apparaissent là où le rembourrage est exposé. Mais s'il est défini </font></font><code>clipToPadding="false"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous pouvez dessiner. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, si vous définissez le remplissage en bas, dans RecyclerView cela fonctionnera comme ceci: en bas, le remplissage est défini et l'élément est dessiné dessus jusqu'à ce que nous fassions défiler. Une fois arrivé à la fin, RecyclerView fera défiler les éléments jusqu'à la position dont nous avons besoin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En définissant un tel indicateur, nous pouvons travailler avec RecyclerView comme avec une vue normale. Ne pensez pas qu'il y a des éléments qui défilent - définissez simplement le remplissage ci-dessous, comme, par exemple, dans la barre de navigation inférieure.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous avons toujours renvoyé les encarts comme s'ils n'avaient pas été traités. </font><font style="vertical-align: inherit;">Les encarts entiers nous sont parvenus, nous avons fait quelque chose avec eux, réglé les rembourrages et renvoyé tous les encarts entiers. </font><font style="vertical-align: inherit;">Cela est nécessaire pour que tout ViewGroup transmette toujours ces encarts à tous les View. </font><font style="vertical-align: inherit;">Ça marche.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bogue d'application</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans de nombreuses applications sur Google Play qui ont déjà traité des encarts, j'ai remarqué un petit bug. Maintenant, je vais parler de lui. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un écran avec navigation au sous-sol. À droite se trouve le même écran qui montre la hiérarchie. Le fragment vert affiche le contenu à l'écran, à l'intérieur il a un RecyclerView. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hl/e6/jo/hle6jod0ws19fydq734lqnuaixu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qui a manipulé les encarts ici? Barre d'outils: il a appliqué un remplissage sur le dessus pour que son contenu se déplace sous la barre d'état. Par conséquent, la barre de navigation inférieure appliquait des encarts par le bas et montait au-dessus de la barre de navigation. Mais RecyclerView ne gère en aucun cas les encarts, il ne relève pas d'eux, il n'a pas besoin de traiter les encarts - tout est fait correctement.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r3/xc/qi/r3xcqipovgqu-zbbxruxsy-wqvk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais ici, il s'avère que nous voulons utiliser le fragment vert RecyclerView dans un autre endroit où la barre de navigation inférieure n'est plus là. À ce stade, RecyclerView commence déjà à gérer les encarts par le bas. Nous devons lui appliquer un remplissage pour faire défiler correctement sous la barre de navigation. Par conséquent, dans RecyclerView, nous ajoutons également le traitement des encarts. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ws/m-/vewsm-_o80cw7mbn9tyk0bu_mfs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous revenons à notre écran, où tout le monde traite les encarts. Rappelez-vous, personne ne signale qu'il les a traités? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/um/vd/x8/umvdx8faxxk48r-inx-cxhkjqdm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous voyons cette situation: RecyclerView a traité les encarts par le bas, bien qu'il n'atteigne pas la barre de navigation - un espace est apparu en bas. J'ai remarqué cela dans les applications, et assez grand et populaire.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i9/3_/ar/i93_arxauyvbitayfpyonkxnudy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si tel est le cas, nous nous souvenons que nous renvoyons toutes les encarts à traiter. Donc (il s'avère!) Il faut signaler que les encarts sont traités: la barre de navigation doit signaler que les encarts sont traités. Ils ne devraient pas accéder à RecyclerView. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jf/r2/vi/jfr2vi8jpsas_ptxjjqh_qhg1vk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ce faire, installez la barre de navigation inférieure </font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Soustrayez à l'intérieur </font></font><code>bottom + insets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qu'ils ne sont pas traités, retournez 0.</font></font><br>
<br>
<pre><code class="kotlin hljs">doOnApplyWindowInsets { view, insets, initialPadding -&gt;    <font></font>
    view.updatePadding(<font></font>
        bottom = initialPadding.bottom + insets.systemWindowInsetBottom<font></font>
    )<font></font>
    insets.replaceSystemWindowInsets(<font></font>
        Rect(<font></font>
            insets.systemWindowInsetLeft,            <font></font>
            insets.systemWindowInsetTop,            <font></font>
            insets.systemWindowInsetRight,<font></font>
            <span class="hljs-number">0</span><font></font>
        )<font></font>
    )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous retournons de nouveaux encarts, dans lesquels tous les anciens paramètres sont égaux, mais </font></font><code>bottom + insets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">égaux à 0. Il semble que tout va bien. </font><font style="vertical-align: inherit;">Nous commençons et encore un non-sens - RecyclerView gère toujours les encarts pour une raison quelconque. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lp/yw/ut/lpywut3fvlk5w-nwbd3-wnrceaw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'ai pas immédiatement compris que le problème est que le conteneur pour ces trois vues est LinearLayout. </font><font style="vertical-align: inherit;">À l'intérieur d'eux se trouve une barre d'outils, un extrait avec un RecyclerView et au bas de la barre de navigation inférieure. </font><font style="vertical-align: inherit;">LinearLayout prend ses enfants en ordre et leur applique des encarts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'avère que la barre de navigation inférieure sera la dernière. </font><font style="vertical-align: inherit;">Il a dit à quelqu'un qu'il avait traité tous les encarts, mais il était trop tard. </font><font style="vertical-align: inherit;">Tous les encarts ont été traités de haut en bas, RecyclerView les a déjà reçus et cela ne nous sauve pas. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uj/mm/jd/ujmmjdgumv0bl6e0ewydx7ueq5g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que faire? </font><font style="vertical-align: inherit;">LinearLayout ne fonctionne pas comme je le souhaite, il les transfère de haut en bas et je dois d'abord obtenir celui du bas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redéfinir tout</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le développeur Java a joué en moi - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tout</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doit être </font><strong><font style="vertical-align: inherit;">redéfini</font></strong><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Eh bien, </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redéfinissez </font><font style="vertical-align: inherit;">maintenant </font><font style="vertical-align: inherit;">, définissez </font></font><code>yLinearLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui ira toujours de bas en haut. </font><font style="vertical-align: inherit;">Il enverra d'abord des encarts à la barre de navigation inférieure, puis à tout le monde.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {     <font></font>
    insets = <span class="hljs-keyword">super</span>.dispatchApplyWindowInsets(insets);     
    <span class="hljs-keyword">if</span> (!insets.isConsumed()) {        
        <span class="hljs-keyword">final</span> int count = getChildCount();
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; count; i++) {<font></font>
            insets = getChildAt(i).dispatchApplyWindowInsets(insets);<font></font>
            <span class="hljs-keyword">if</span> (insets.isConsumed()) {
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> insets;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais je me suis arrêté à temps, me souvenant du commentaire qu'il n'était pas nécessaire de redéfinir cette méthode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, un peu plus haut est le salut: ViewGroup recherche un délégué qui traite les encarts, puis appelle la super méthode sur View et active son propre traitement. </font><font style="vertical-align: inherit;">Dans ce code, nous obtenons des encarts, et s'ils n'ont pas encore été traités, nous commençons la logique standard pour nos enfants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai écrit une simple extension. </font><font style="vertical-align: inherit;">Il permet, en s'appliquant </font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à une seule vue, de dire à qui ces encarts passent.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">addSystemBottomPadding</span><span class="hljs-params">(    
    targetView: <span class="hljs-type">View</span> = this
)</span></span> {<font></font>
    doOnApplyWindowInsets { _, insets, initialPadding -&gt;           <font></font>
        targetView.updatePadding(<font></font>
            bottom = initialPadding.bottom + insets.systemWindowInsetBottom<font></font>
        )<font></font>
        insets.replaceSystemWindowInsets(<font></font>
            Rect(<font></font>
                insets.systemWindowInsetLeft,<font></font>
                insets.systemWindowInsetTop,     <font></font>
                insets.systemWindowInsetRight,<font></font>
                <span class="hljs-number">0</span><font></font>
            )<font></font>
        )<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, il </font></font><code>targetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est égal par défaut à la même vue au-dessus de laquelle nous appliquons </font></font><code>addSystemBottomPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous pouvons le redéfinir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur mon LinearLayout, j'ai suspendu un tel gestionnaire, en passant </font></font><code>targetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- c'est ma barre de navigation inférieure.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'abord, il donnera des encarts à la barre de navigation inférieure.&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela traitera les encarts, retournera le fond zéro.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, par défaut, ils iront de haut en bas: Barre d'outils, fragment avec RecyclerView.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puis, peut-être, il enverra à nouveau des encarts à la barre de navigation inférieure. </font><font style="vertical-align: inherit;">Mais ce n'est plus important, tout fonctionnera si bien.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai réalisé exactement ce que je voulais: tous les encarts sont traités dans l'ordre dans lequel ils sont nécessaires.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s3/b0/nc/s3b0nc07bayude3nvrvevkxnwyc.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Important</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelques points importants à garder à l'esprit. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le clavier est l'interface utilisateur du système au-dessus de votre application.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pas besoin de la traiter d'une manière spéciale. Si vous regardez le clavier Google, ce n'est pas seulement une mise en page avec des boutons sur laquelle vous pouvez cliquer. Il existe des centaines de modes pour ce clavier: recherche de gifs et de mèmes, entrée vocale, redimensionnement de 10 pixels en hauteur aux tailles d'écran. Ne pensez pas au clavier, mais abonnez-vous aux encarts. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le tiroir de navigation ne prend toujours pas en charge la navigation gestuelle</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">À Google IO, ils ont promis que tout fonctionnerait hors de la boîte. </font><font style="vertical-align: inherit;">Mais dans Android 10, Navigation Drawer ne prend toujours pas en charge cela. </font><font style="vertical-align: inherit;">Si vous passez à Android 10 et activez la navigation par gestes, le tiroir de navigation tombera. </font><font style="vertical-align: inherit;">Maintenant, vous devez cliquer sur le menu hamburger pour le faire apparaître, ou une combinaison de circonstances aléatoires vous permet de l'étirer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la version pré-alpha d'Android, Navigation Drawer fonctionne, mais je n'ai pas osé mettre à jour - c'est pré-alpha. </font><font style="vertical-align: inherit;">Par conséquent, même si vous installez la dernière version de GitFox à partir du référentiel, il y a un tiroir de navigation, mais il ne peut pas être extrait. </font><font style="vertical-align: inherit;">Dès que le support officiel sera disponible, je mettrai à jour et tout fonctionnera bien.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste de contrôle de préparation pour Android 10</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Définissez la transparence de la barre de navigation et de la barre d'état depuis le début du projet</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Google recommande fortement de maintenir une barre de navigation transparente. Pour nous, c'est une partie pratique importante. Si le projet fonctionne, mais que vous ne l'avez pas activé, prenez le temps de prendre en charge Android 10. Activez-les d'abord dans le sujet, comme translucide, et corrigez la mise en page où il s'est cassé. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez des extensions à Kotlin</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - c'est plus facile avec elles. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez à toute la barre d'outils au-dessus du rembourrage.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les barres d'outils sont toujours en haut, et c'est ce que vous devez faire. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour tous les RecyclerViews, ajoutez un rembourrage par le bas</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et la possibilité de faire défiler </font></font><code>clipToPadding="false"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pensez à tous les boutons sur les bords de l'écran </font></font></strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(FAB)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Les FAB ne seront probablement pas là où vous vous attendez.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne remplacez pas ou ne faites pas vos propres implémentations pour tous les LinearLayout</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et autres cas similaires. Faites l'astuce, comme dans GitFox, ou prenez mon extension prête à l'emploi pour vous aider. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vérifiez les gestes sur les bords de l'écran pour une vue personnalisée</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le tiroir de navigation ne le prend pas en charge. Mais ce n'est pas si difficile de le supporter avec vos mains, de redéfinir les encarts pour les gestes à l'écran avec le tiroir de navigation. Vous avez peut-être des éditeurs d'images où les gestes fonctionnent. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le défilement dans ViewPager ne fonctionne pas du bord, mais uniquement du centre vers la droite et la gauche</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Google dit que c'est normal. Si vous tirez le ViewPager depuis le bord, il est perçu comme appuyant sur le bouton "Retour". </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans un nouveau projet, intégrez immédiatement toute la transparence</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vous pouvez dire aux concepteurs que vous n'avez pas de barre de navigation ni de barre d'état. </font><font style="vertical-align: inherit;">Le carré entier est le contenu de votre application. </font><font style="vertical-align: inherit;">Et les développeurs sauront déjà où et quoi soulever. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liens utiles:</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@rmr_spb dans un télégramme - enregistrements de mitaps internes de Redmadrobot SPb.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout le code source dans cet article et encore plus dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il y a une branche Android 10 distincte, où vous pouvez voir en validant comment je suis arrivé à tout cela et comment j'ai pris en charge le nouvel Android.</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliothèque Insetter de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chris Bane. </font><font style="vertical-align: inherit;">Il contient 5-6 extensions que j'ai montrées. </font><font style="vertical-align: inherit;">Pour l'utiliser dans votre projet, contactez la bibliothèque, il est probable qu'elle passe à Android Jetpack. </font><font style="vertical-align: inherit;">Je les ai développés dans mon projet et, il me semble, ils se sont améliorés.</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Article de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chris Bane.</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>   FunCorn,    ,      .</li>
<li> «<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Why would I want to fitsSystemWindows?</a>»  .</li>
</ul><br>
<blockquote>    AppConf,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">youtube-</a>      .            ,     - .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsConf</a>     ,            .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>, stay tuned!</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr488160/index.html">Windows Server 2019 contre Instantanés VMware avec mise au repos: une solution élégante au problème</a></li>
<li><a href="../fr488162/index.html">Plus la note est élevée, plus il y a d'argent et vice versa</a></li>
<li><a href="../fr488164/index.html">Bataille de la SEC contre Telegram</a></li>
<li><a href="../fr488190/index.html">Encore une fois sur l'épuisement émotionnel</a></li>
<li><a href="../fr488194/index.html">Pourquoi écrivons-nous des programmes de si mauvaise qualité?</a></li>
<li><a href="../fr488198/index.html">De quoi les Timlids ont-ils peur et pourquoi devraient-ils arrêter de faire cela</a></li>
<li><a href="../fr488200/index.html">Le débat sur le premier langage de programmation: la décision finale</a></li>
<li><a href="../fr488202/index.html">PVS-Studio est maintenant dans Chocolatey: vérification de Chocolatey à partir d'Azure DevOps</a></li>
<li><a href="../fr488208/index.html">Anniversaire DUMP2020 - 4 jours que vous n'oublierez pas</a></li>
<li><a href="../fr488210/index.html">Reconnaître des objets sur Android à l'aide de TensorFlow: de la préparation des données au lancement sur l'appareil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>