<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🔧 ☃️ ☑️ Comment compiler un décorateur - C ++, Python et sa propre implémentation. Partie 1 👬 🧘🏼 🛷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cette série d'articles sera consacrée à la possibilité de créer un décorateur en C ++, les caractéristiques de leur travail en Python, et l'une des op...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Comment compiler un décorateur - C ++, Python et sa propre implémentation. Partie 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504694/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette série d'articles sera consacrée à la possibilité de créer un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">décorateur</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en C ++, les caractéristiques de leur travail en Python, et l'une des options pour implémenter cette fonctionnalité dans son propre langage compilé sera considérée, en utilisant l'approche générale pour créer des fermetures - conversion de fermeture et modernisation de l'arbre de syntaxe.</font></font></p><br>
<img src="https://habrastorage.org/webt/mm/gu/wn/mmguwnnsrlpzur2dgs8pf0woq7m.png"><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avertissement</font></font></b>
                        <div class="spoiler_text">        ,    Python —    .   Python  ,    (). -   ( ),        -    ( ,    ..),   Python  «»      .<br>
</div>
                    </div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Décorateur en C ++</font></font></h2><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout a commencé avec le fait que mon ami </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VoidDruid a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> décidé d'écrire un petit compilateur en guise de diplôme, dont la caractéristique principale est les décorateurs. Même pendant la pré-défense, lorsqu'il a souligné tous les avantages de son approche, qui comprenait la modification de l'AST, je me suis demandé: est-il vraiment impossible de mettre en œuvre ces mêmes décorateurs dans le grand et puissant C ++ et de se passer de termes et d'approches compliqués? Sur ce sujet, je n'ai trouvé aucune approche simple et générale pour résoudre ce problème (à propos, je n'ai trouvé que des articles sur la mise en œuvre du modèle de conception), puis je me suis assis pour écrire mon propre décorateur.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, avant de passer à une description directe de mon implémentation, je voudrais parler un peu de la façon dont les lambdas et les fermetures en C ++ sont arrangés et quelle est la différence entre eux. </font><font style="vertical-align: inherit;">Faites immédiatement une réserve que s'il n'y a aucune mention d'une norme spécifique, alors par défaut, je veux dire C ++ 20. </font><font style="vertical-align: inherit;">En bref, les lambdas sont des fonctions anonymes et les fermetures sont des fonctions qui utilisent des objets de leur environnement. </font><font style="vertical-align: inherit;">Ainsi, par exemple, à partir de C ++ 11, un lambda peut être déclaré et appelé comme ceci:</font></font><br>
<br>
</p><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{<font></font>
    [] (<span class="hljs-keyword">int</span> a) <font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    }(<span class="hljs-number">10</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou attribuez sa valeur à une variable et appelez-la plus tard.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{
    <span class="hljs-keyword">auto</span> lambda = [] (<span class="hljs-keyword">int</span> a) <font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
    lambda(<span class="hljs-number">10</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais que se passe-t-il pendant la compilation et qu'est-ce que lambda? </font><font style="vertical-align: inherit;">Afin de vous immerger dans la structure interne du lambda, allez simplement sur le site Web </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppinsights.io</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et exécutez notre premier exemple. </font><font style="vertical-align: inherit;">Ensuite, j'ai joint une conclusion possible:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> __<span class="hljs-title">lambda_60_19</span>
{</span>
<span class="hljs-keyword">public</span>: 
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> <span class="hljs-keyword">const</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>.<span class="hljs-keyword">operator</span>&lt;&lt;(a).<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">using</span> retType_60_19 = <span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">int</span>);
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">retType_60_19</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
    </span>{
        <span class="hljs-keyword">return</span> __invoke;<font></font>
    };<font></font>
    <font></font>
<span class="hljs-keyword">private</span>: 
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __invoke(<span class="hljs-keyword">int</span> a)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>.<span class="hljs-keyword">operator</span>&lt;&lt;(a).<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>);<font></font>
    }    <font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, lors de la compilation, le lambda se transforme en classe, ou plutôt en foncteur (un objet pour lequel l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opérateur ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est défini </font><font style="vertical-align: inherit;">) avec un nom unique généré automatiquement, qui a un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opérateur ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui accepte les paramètres que nous avons passés à notre lambda et que son corps contient le code que notre lambda doit exécuter. </font><font style="vertical-align: inherit;">Avec cela, tout est clair, mais qu'en est-il des deux autres méthodes, pourquoi sont-elles? </font><font style="vertical-align: inherit;">Le premier est l'opérateur de transtypage en un pointeur de fonction, dont le prototype coïncide avec notre lambda, et le second est le code qui devrait être exécuté lorsque notre lambda est appelé sur une affectation préliminaire à son pointeur, par exemple comme ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">void</span> (*p_lambda) (<span class="hljs-keyword">int</span>) = lambda;<font></font>
p_lambda(<span class="hljs-number">10</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, il y a moins d'une énigme, mais qu'en est-il des fermetures? </font><font style="vertical-align: inherit;">Écrivons l'exemple le plus simple d'une fermeture qui capture la variable «a» par référence et l'augmente d'une unité.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">auto</span> closure = [&amp;a] () { a += <span class="hljs-number">1</span>; };<font></font>
    closure();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, le mécanisme de création de fermetures et de lambdas en C ++ est presque le même, donc ces concepts sont souvent confondus et les lambdas et les fermetures sont simplement appelées lambdas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais revenons à la représentation interne de la fermeture en C ++.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> __<span class="hljs-title">lambda_61_20</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span>
    </span>{<font></font>
        a += <span class="hljs-number">1</span>;<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> &amp; a;
<span class="hljs-keyword">public</span>:<font></font>
    __lambda_61_20(<span class="hljs-keyword">int</span> &amp; _a)<font></font>
    : a{_a}<font></font>
    {}<font></font>
};</code></pre><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir, nous avons ajouté un nouveau constructeur non par défaut qui prend notre paramètre par référence et l'enregistre en tant que membre de la classe. </font><font style="vertical-align: inherit;">En fait, c'est pourquoi vous devez être extrêmement prudent lorsque vous définissez [&amp;] ou [=], car tout le contexte sera stocké dans la fermeture, et cela peut être assez sous-optimal de la mémoire. </font><font style="vertical-align: inherit;">De plus, nous avons perdu l'opérateur de transtypage en un pointeur de fonction, car maintenant, pour son contexte d'appel normal, il est nécessaire. </font><font style="vertical-align: inherit;">Et maintenant, le code ci-dessus ne se compilera pas:</font></font><br>
<br>
</p><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">auto</span> closure = [&amp;a] () { a += <span class="hljs-number">1</span>; };<font></font>
    closure();<font></font>
    <span class="hljs-keyword">void</span> (*ptr)(<span class="hljs-keyword">int</span>) = closure;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, si vous devez toujours passer la fermeture quelque part, personne n'a annulé l'utilisation de la fonction std ::.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt; function = closure;<font></font>
function();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que nous avons approximativement compris ce que sont les lambdas et les fermetures en C ++, passons directement à l'écriture du décorateur. </font><font style="vertical-align: inherit;">Mais d'abord, vous devez décider de nos besoins.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, le décorateur doit prendre notre fonction ou méthode en entrée, y ajouter les fonctionnalités dont nous avons besoin (par exemple, cela sera omis) et retourner une nouvelle fonction lors de son appel, qui exécute notre code et le code de fonction / méthode. À ce stade, tout pythoniste qui se respecte dira: «Mais comment ça! Le décorateur doit remplacer l'objet d'origine et tout appel à celui-ci par son nom doit appeler une nouvelle fonction! » C'est juste la principale limitation de C ++, nous ne pouvons pas empêcher l'utilisateur d'invoquer l'ancienne fonction. Bien sûr, il existe une option pour obtenir son adresse en mémoire et la broyer (dans ce cas, y accéder entraînera une fin anormale du programme) ou remplacer son corps par un avertissement qu'il ne doit pas être utilisé dans la console, mais cela est lourd de conséquences graves. Si la première option semble assez difficile,alors le second, lors de l'utilisation de diverses optimisations du compilateur, peut également entraîner un plantage, et nous ne les utiliserons donc pas. De plus, l'utilisation de n'importe quelle magie macro ici est redondante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons donc à l'écriture de notre décorateur. </font><font style="vertical-align: inherit;">La première option qui m'est venue à l'esprit était la suivante:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> Decorator<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ...Args&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">make</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;R(Args...)&gt;&amp; f)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Do something"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> [=](Args... args) <font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> f(<span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...);<font></font>
        };<font></font>
    }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit une structure avec une méthode statique qui prend std :: function et retourne une fermeture qui prendra les mêmes paramètres que notre fonction et lorsqu'elle sera appelée, elle appellera simplement notre fonction et retournera son résultat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créons une fonction simple que nous voulons décorer.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"here"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et notre principal ressemblera à ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span>)&gt; f = myFunc;
    <span class="hljs-keyword">auto</span> decorated = Decorator::make(f);<font></font>
    decorated(<span class="hljs-number">10</span>);<font></font>
}</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout fonctionne, tout va bien et en général Hourra. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, cette solution pose plusieurs problèmes. </font><font style="vertical-align: inherit;">Commençons dans l'ordre:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce code ne peut être compilé qu'avec les versions C ++ 14 et supérieures, car il n'est pas possible de connaître le type retourné à l'avance. </font><font style="vertical-align: inherit;">Malheureusement, je dois vivre avec cela et je n'ai pas trouvé d'autres options.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make requiert que std :: function lui soit passé, et passer une fonction par son nom conduit à des erreurs de compilation. </font><font style="vertical-align: inherit;">Et ce n'est pas du tout aussi pratique que nous le souhaiterions! </font><font style="vertical-align: inherit;">Nous ne pouvons pas écrire de code comme ceci:</font></font><br>
<br>
<pre><code class="cpp hljs">Decorator::make([](){});<font></font>
Decorator::make(myFunc);<font></font>
<span class="hljs-keyword">void</span>(*ptr)(<span class="hljs-keyword">int</span>) = myFunc;<font></font>
Decorator::make(ptr);</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, il n'est pas possible de décorer une méthode de classe.</font></font><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, après une courte conversation avec des collègues, l'option suivante a été inventée pour C ++ 17 et supérieur:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> Decorator<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Function&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">make</span><span class="hljs-params">(Function&amp;&amp; func)</span>
    </span>{
        <span class="hljs-keyword">return</span> [func = <span class="hljs-built_in">std</span>::forward&lt;Function&gt;(func)] (<span class="hljs-keyword">auto</span> &amp;&amp; ...args) <font></font>
        {<font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Do something"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::invoke(<font></font>
                func,<font></font>
                <span class="hljs-built_in">std</span>::forward&lt;<span class="hljs-keyword">decltype</span>(args)&gt;(args)...<font></font>
            );<font></font>
        };<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les avantages de cette option particulière sont que maintenant nous pouvons décorer absolument n'importe quel objet qui a un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opérateur ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ainsi, par exemple, nous pouvons passer le nom d'une fonction libre, un pointeur, un lambda, n'importe quel foncteur, std :: function, et bien sûr une méthode de classe. </font><font style="vertical-align: inherit;">Dans ce dernier cas, il faudra également lui passer un contexte lors de l'appel de la fonction décodée.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Options d'application</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> decorated_1 = Decorator::make(myFunc);<font></font>
    decorated_1(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<font></font>
<font></font>
    <span class="hljs-keyword">auto</span> my_lambda = [] (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) <font></font>
    { <font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <font></font>
    };<font></font>
    <span class="hljs-keyword">auto</span> decorated_2 = Decorator::make(my_lambda);<font></font>
    decorated_2(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<font></font>
<font></font>
    <span class="hljs-keyword">int</span> (*ptr)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) = myFunc;
    <span class="hljs-keyword">auto</span> decorated_3 = Decorator::make(ptr);<font></font>
    decorated_3(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; fun = myFunc;
    <span class="hljs-keyword">auto</span> decorated_4 = Decorator::make(fun);<font></font>
    decorated_4(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);<font></font>
<font></font>
    <span class="hljs-keyword">auto</span> decorated_5 = Decorator::make(decorated_4);<font></font>
    decorated_5(<span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<font></font>
<font></font>
    <span class="hljs-keyword">auto</span> decorated_6 = Decorator::make(&amp;MyClass::func);<font></font>
    decorated_6(MyClass(<span class="hljs-number">10</span>));<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, ce code peut être compilé avec C ++ 14 s'il existe une extension pour utiliser std :: invoke, qui doit être remplacée par std :: __ invoke. </font><font style="vertical-align: inherit;">S'il n'y a pas d'extension, vous devrez renoncer à la possibilité de décorer les méthodes de classe et cette fonctionnalité deviendra indisponible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de ne pas écrire le lourd "std :: forward &lt;decltype (args)&gt; (args) ...", vous pouvez utiliser la fonctionnalité disponible avec C ++ 20 et faire de notre lambda passe-partout!</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> Decorator<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Function&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">make</span><span class="hljs-params">(Function&amp;&amp; func)</span>
    </span>{
        <span class="hljs-keyword">return</span> [func = <span class="hljs-built_in">std</span>::forward&lt;Function&gt;(func)] <font></font>
        &lt;<span class="hljs-keyword">typename</span> ...Args&gt; (Args &amp;&amp; ...args) <font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::invoke(<font></font>
                func,<font></font>
                <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...<font></font>
            );<font></font>
        };<font></font>
    }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout est parfaitement sûr et fonctionne même comme nous le voulons (ou du moins fait semblant). </font><font style="vertical-align: inherit;">Ce code est compilé pour les versions gcc et clang 10-x et vous pouvez le trouver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il y aura également des implémentations pour diverses normes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les prochains articles, nous allons passer à l'implémentation canonique des décorateurs en utilisant l'exemple Python et leur structure interne.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr504682/index.html">Nostalgia Post: j2me, Gravity Defied, 64kb</a></li>
<li><a href="../fr504686/index.html">Comment dessiner un chat</a></li>
<li><a href="../fr504688/index.html">Les masques sont inutiles: critique scientifique de la politique sociale à KOVID-19</a></li>
<li><a href="../fr504690/index.html">L'histoire de la façon dont j'ai configuré Azure AD B2C sur React et React Native, partie 3 (didacticiel)</a></li>
<li><a href="../fr504692/index.html">Bases de ZFS: stockage et performances</a></li>
<li><a href="../fr504696/index.html">Nouvelles du monde d'OpenStreetMap n ° 513 (12.05.2020-18.05.2020)</a></li>
<li><a href="../fr504698/index.html">Intégration sur un site distant</a></li>
<li><a href="../fr504700/index.html">Tablette graphique soviétique "sketch"</a></li>
<li><a href="../fr504702/index.html">Les gens ne veulent pas connaître l'anglais</a></li>
<li><a href="../fr504706/index.html">Gestion automatique de l'alimentation Wi-Fi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>