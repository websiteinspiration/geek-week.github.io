<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚆 👺 🍹 O livro "Concorrência Java na Prática" 📚 🧑🏿‍🤝‍🧑🏻 🧘🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá, habrozhiteli! Os fluxos são uma parte fundamental da plataforma Java. Os processadores com vários núcleos são comuns e o uso efetivo da simultane...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>O livro "Concorrência Java na Prática"</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489038/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/1r/ku/4r/1rku4rb0w0tevxfiae9gxkkkzse.jpeg" align="left" alt="imagem"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olá, habrozhiteli! Os fluxos são uma parte fundamental da plataforma Java. Os processadores com vários núcleos são comuns e o uso efetivo da simultaneidade tornou-se necessário para criar qualquer aplicativo de alto desempenho. Uma máquina virtual Java aprimorada, suporte para classes de alto desempenho e um rico conjunto de componentes para tarefas de paralelização foram ao mesmo tempo uma inovação no desenvolvimento de aplicativos paralelos. No Java Concurrency in Practice, os próprios criadores da tecnologia inovadora explicam não apenas como eles funcionam, mas também falam sobre padrões de design. É fácil criar um programa competitivo que parece funcionar. No entanto, o desenvolvimento, teste e depuração de programas multiencadeados apresentam muitos problemas. O código para de funcionar exatamente quando é mais importante: sob carga pesada.No "Java Concurrency in Practice", você encontrará teoria e métodos específicos para criar aplicativos paralelos confiáveis, escaláveis ​​e suportados. Os autores não oferecem uma lista de APIs e mecanismos de simultaneidade; eles introduzem regras, padrões e modelos de design que são independentes da versão Java e permanecem relevantes e eficazes por muitos anos.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excerto. </font><font style="vertical-align: inherit;">Segurança da linha</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode se surpreender ao saber que a programação competitiva está associada a threads ou bloqueios </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1), assim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como a engenharia civil não está associada a rebites e vigas em I. </font><font style="vertical-align: inherit;">Obviamente, a construção de pontes requer o uso correto de um grande número de rebites e vigas em I, e o mesmo se aplica à construção de programas competitivos, que exigem o uso correto de roscas e travas. </font><font style="vertical-align: inherit;">Mas estes são apenas mecanismos - meios para alcançar a meta. </font><font style="vertical-align: inherit;">Escrever código seguro para threads é, em essência, controlar o acesso a um estado e, em particular, a um estado mutável.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, o estado de um objeto é seus dados armazenados em variáveis ​​de estado, como instância e campos estáticos ou campos de outros objetos dependentes. O estado do hash do HashMap é parcialmente armazenado no próprio HashMap, mas também em muitos objetos Map.Entry. O estado de um objeto inclui qualquer dado que possa afetar seu comportamento. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b>     lock  block,      «»,     ,  .            blocking.   lock    «», «  ».     lock ,  ,   ,    «».  —          .       ,          , ,         . — . . .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vários threads podem acessar uma variável compartilhada, modificada - altera seu valor. De fato, estamos tentando proteger dados, não códigos, de acesso competitivo não controlado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A criação de um objeto seguro para threads requer sincronização para coordenar o acesso a um estado mutado, falha no cumprimento, o que pode levar à corrupção de dados e outras consequências indesejáveis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sempre que mais de um thread acessa uma variável de estado e um dos threads possivelmente grava nela, todos os threads devem coordenar seu acesso a ela usando a sincronização. A sincronização em Java é fornecida pela palavra-chave sincronizada, que fornece bloqueio exclusivo, bem como variáveis ​​voláteis e atômicas e bloqueios explícitos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resista à tentação de pensar que existem situações que não requerem sincronização. </font><font style="vertical-align: inherit;">O programa pode funcionar e passar nos testes, mas permanece com defeito e falha a qualquer momento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se vários encadeamentos acessam a mesma variável com um estado mutado sem sincronização adequada, seu programa está com defeito. </font><font style="vertical-align: inherit;">Há três maneiras de corrigi-lo:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não compartilhe a variável state em todos os threads</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">torne a variável de estado não mutável;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use a sincronização de estado sempre que acessar a variável de estado.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As correções podem exigir alterações significativas no design, por isso é muito mais fácil projetar uma classe segura para threads imediatamente do que atualizá-la mais tarde.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É difícil descobrir se vários threads acessarão esta ou aquela variável. Felizmente, soluções técnicas orientadas a objetos que ajudam a criar classes bem organizadas e fáceis de manter - como encapsulamento e ocultação de dados - também ajudam a criar classes seguras para threads. Quanto menos encadeamentos tiverem acesso a uma variável específica, mais fácil será garantir a sincronização e definir as condições sob as quais essa variável pode ser acessada. A linguagem Java não o força a encapsular o estado - é perfeitamente aceitável armazenar o estado em campos públicos (mesmo campos estáticos públicos) ou publicar um link para um objeto que, de outra forma, é interno - mas quanto melhor o estado do seu programa for encapsulado,mais fácil é tornar o thread do programa seguro e ajudar os mantenedores a mantê-lo dessa maneira.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao projetar classes seguras para threads, boas soluções técnicas orientadas a objetos: encapsulamento, mutabilidade e uma especificação clara de invariantes serão seus assistentes.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se boas soluções técnicas de design orientado a objetos divergem das necessidades do desenvolvedor, vale a pena sacrificar as regras de bom design por uma questão de desempenho ou compatibilidade com o código legado. </font><font style="vertical-align: inherit;">Às vezes, abstração e encapsulamento estão em desacordo com o desempenho - embora não com a frequência que muitos desenvolvedores acreditam - mas a melhor prática é tornar o código correto primeiro e depois rápido. </font><font style="vertical-align: inherit;">Tente usar a otimização apenas se medidas de produtividade e necessidades indicarem que você deve fazê-lo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No código competitivo, você deve aderir a essa prática ainda mais do que o habitual. Como os erros competitivos são extremamente difíceis de reproduzir e não são fáceis de depurar, a vantagem de um pequeno ganho de desempenho em algumas ramificações de código raramente usadas pode ser bastante insignificante em comparação ao risco de o programa travar em condições operacionais.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Se você decidir quebrar o encapsulamento, nem tudo estará perdido. Seu programa ainda pode tornar o thread seguro, mas o processo será mais complicado e mais caro, e o resultado não será confiável. O capítulo 4 descreve as condições sob as quais o encapsulamento de variáveis ​​de estado pode ser mitigado com segurança.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Até agora, usamos os termos “thread safe class” e “thread safe program” quase de forma intercambiável. Um programa de thread safe é construído inteiramente a partir de classes de thread safe? Opcional: um programa que consiste inteiramente de classes seguras de encadeamento pode não ser seguro, e um programa seguro de encadeamento pode conter classes que não são seguras. Questões relacionadas ao layout das classes de thread-safe também são discutidas no Capítulo 4. De qualquer forma, o conceito de uma classe de thread-safe só faz sentido se a classe encapsular seu próprio estado. O termo "segurança de encadeamento" pode ser aplicado ao código, mas fala do estado e só pode ser aplicado àquela matriz de código que encapsula seu estado (pode ser um objeto ou o programa inteiro).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1 </font><font style="vertical-align: inherit;">O que é segurança de rosca?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Definir a segurança da linha não é fácil. </font><font style="vertical-align: inherit;">Uma rápida pesquisa no Google oferece várias opções como estas: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... podem ser chamadas a partir de vários threads de programa sem interações indesejadas entre threads. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... pode ser chamado por dois ou mais threads ao mesmo tempo, sem exigir nenhuma outra ação do chamador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dadas essas definições, não é surpreendente que achemos confusos a segurança dos threads! </font><font style="vertical-align: inherit;">Como distinguir uma classe de thread-safe de uma classe não segura? </font><font style="vertical-align: inherit;">O que queremos dizer com a palavra "seguro"? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No centro de qualquer definição razoável de segurança do fio está a noção de correção.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A correção implica que uma classe esteja em conformidade com sua especificação. </font><font style="vertical-align: inherit;">A especificação define invariantes que limitam o estado de um objeto e pós-condições que descrevem os efeitos das operações. </font><font style="vertical-align: inherit;">Como você sabe que as especificações para as classes estão corretas? </font><font style="vertical-align: inherit;">De jeito nenhum, mas isso não nos impede de usá-los depois que nos convencemos de que o código funciona. </font><font style="vertical-align: inherit;">Então, vamos supor que a correção de thread único seja algo visível. </font><font style="vertical-align: inherit;">Agora podemos assumir que a classe de thread-safe se comporta corretamente durante o acesso de vários threads.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma classe é segura para threads se se comportar corretamente durante o acesso de vários threads, independentemente de como esses threads são agendados ou intercalados pelo ambiente de trabalho e sem sincronização adicional ou outra coordenação por parte do código de chamada.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um programa multithread não pode ser seguro para threads se não estiver correto, mesmo em um ambiente de thread único </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Se o objeto for implementado corretamente, nenhuma sequência de operações - acessando métodos públicos e lendo ou gravando em campos públicos - deve violar seus invariantes ou pós-condições. </font><font style="vertical-align: inherit;">Nenhum conjunto de operações executadas sequencialmente ou competitivamente em instâncias de uma classe segura para encadeamento pode fazer com que uma instância esteja em um estado inválido. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3) </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o uso livre do termo correção incomodá-lo aqui, você pode pensar em uma classe de thread-safe como uma classe defeituosa em um ambiente competitivo, bem como em um ambiente de thread único.</font></font></i><br>
 <br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As classes thread-safe encapsulam qualquer sincronização necessária e não precisam de ajuda do cliente.</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1.1 </font><font style="vertical-align: inherit;">Exemplo: servlet sem suporte de estado interno</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No Capítulo 1, listamos as estruturas que criam threads e chamam componentes deles que você é responsável pela segurança da thread. </font><font style="vertical-align: inherit;">Agora pretendemos desenvolver um serviço de fatoração de servlet e expandir gradualmente sua funcionalidade, mantendo a segurança do encadeamento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A Listagem 2.1 mostra um servlet simples que descompacta um número de uma consulta, os fatora e agrupa os resultados em resposta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 2.1. </font><font style="vertical-align: inherit;">Servlet sem suporte de estado interno</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@ThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatelessFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A classe StatelessFactorizer, como a maioria dos servlets, não possui estado interno: não contém campos e não se refere a campos de outras classes. </font><font style="vertical-align: inherit;">O estado para um cálculo específico existe apenas em variáveis ​​locais que são armazenadas na pilha de fluxos e estão disponíveis apenas para o fluxo em execução. </font><font style="vertical-align: inherit;">Um thread que acessa StatelessFactorizer não pode afetar o resultado de outro thread fazendo o mesmo, porque esses threads não compartilham o estado.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objetos sem suporte de estado interno são sempre seguros para threads.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O fato de a maioria dos servlets poder ser implementada sem suporte interno do estado reduz significativamente a carga de segmentar os próprios servlets. </font><font style="vertical-align: inherit;">E somente quando os servlets precisam se lembrar de algo, os requisitos para a segurança de seus threads aumentam.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2 </font><font style="vertical-align: inherit;">Atomicidade</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que acontece quando um item de estado é adicionado a um objeto sem suporte interno ao estado? Suponha que desejemos adicionar um contador de visitas que mede o número de solicitações processadas. Você pode adicionar um campo do tipo long ao servlet e incrementá-lo com cada solicitação, conforme mostrado em UnsafeCountingFactorizer na Listagem 2.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 2.2. Um servlet que conta solicitações sem a sincronização necessária. Isso não deve ser feito.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/lj/hg/geljhgzyo9aogxu-ttztrzuawqo.jpeg" alt="imagem"></div><br>
<pre><code class="java hljs"><span class="hljs-meta">@NotThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeCountingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count; }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            ++count;<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, a classe UnsafeCountingFactorizer não é segura para threads, mesmo que funcione bem em um ambiente de thread único. Como o UnsafeSequence, é propenso a atualizações perdidas. Embora a contagem da operação de incremento ++ tenha sintaxe compacta, ela não é atômica, ou seja, indivisível, mas uma sequência de três operações: entrega do valor atual, adição de um valor a ele e gravação do novo valor. Nas operações “ler, alterar, gravar”, o estado resultante é derivado do anterior.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na fig. </font><font style="vertical-align: inherit;">1.1 é mostrado o que pode acontecer se dois threads tentarem aumentar o contador ao mesmo tempo, sem sincronização. </font><font style="vertical-align: inherit;">Se o contador for 9, devido à coordenação malsucedida do tempo, os dois threads verão o valor 9, adicionam um a ele e configuram o valor para 10. Portanto, o contador de ocorrências começará a ficar um para o outro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode pensar que ter um contador de ocorrências um pouco impreciso em um serviço da web é uma perda aceitável, e às vezes é. </font><font style="vertical-align: inherit;">Mas se o contador for usado para criar seqüências ou identificadores exclusivos de objetos, o retorno do mesmo valor de várias ativações poderá levar a sérios problemas de integridade dos dados. </font><font style="vertical-align: inherit;">A possibilidade do aparecimento de resultados incorretos devido à coordenação temporal malsucedida surge em uma condição de corrida.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1 </font><font style="vertical-align: inherit;">Condições da corrida</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A classe UnsafeCountingFactorizer possui várias condições de corrida </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O tipo mais comum de condição de corrida é a situação de "verificar e depois agir", em que uma observação potencialmente obsoleta é usada para decidir o que fazer a seguir. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4)</font></font></b> <i>          (data race).   ,            .        ,    ,       ,   ,         ,      .               Java.       ,        ,             . UnsafeCountingFactorizer   .       16.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muitas vezes encontramos uma condição de raça na vida real. Suponha que você planeje encontrar um amigo ao meio-dia no Starbucks Café na Universitetskiy Prospekt. Mas você descobrirá que existem duas Starbucks na University Avenue. Às 12:10, você não vê seu amigo no café A e vai para o café B, mas ele também não está lá. Seu amigo está atrasado ou ele chegou ao café A imediatamente depois que você saiu, ou ele estava no café B, mas foi procurá-lo e agora está a caminho do café A. Vamos aceitar o último, ou seja, o pior cenário. Agora 12:15, e vocês dois estão se perguntando se seu amigo cumpriu sua promessa. Você vai voltar para outro café? Quantas vezes você vai e volta? Se você não concordou com um protocolo, pode passar o dia inteiro andando pela University Avenue com euforia com cafeína.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema com a abordagem “dar um passeio e ver se ele está lá” é que um passeio pela rua entre dois cafés leva vários minutos e, durante esse período, o estado do sistema pode mudar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O exemplo da Starbucks ilustra a dependência do resultado na coordenação de eventos em tempo relativo (em quanto tempo você espera por um amigo enquanto está em um café etc.). </font><font style="vertical-align: inherit;">A observação de que ele não está no café A se torna potencialmente inválida: assim que você sai pela porta da frente, ele pode entrar pela porta dos fundos. </font><font style="vertical-align: inherit;">A maioria das condições de corrida causa problemas como uma exceção inesperada, dados sobrescritos e corrupção de arquivos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2 </font><font style="vertical-align: inherit;">Exemplo: condições de corrida na inicialização lenta</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um truque comum usando a abordagem "verificar e depois agir" é a inicialização lenta (LazyInitRace). Seu objetivo é adiar a inicialização do objeto até que seja necessário e garantir que ele seja inicializado apenas uma vez. Na Listagem 2.3, o método getInstance verifica se o ExpensiveObject é inicializado e retorna uma instância existente ou, caso contrário, cria uma nova instância e a retorna após manter uma referência a ela. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 2.3. A condição de corrida está na inicialização lenta. Isso não deve ser feito.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/lj/hg/geljhgzyo9aogxu-ttztrzuawqo.jpeg" alt="imagem"></div><br>
<pre><code class="java hljs"><span class="hljs-meta">@NotThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyInitRace</span> </span>{
      <span class="hljs-keyword">private</span> ExpensiveObject instance = <span class="hljs-keyword">null</span>;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> ExpensiveObject <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)<font></font>
                instance = <span class="hljs-keyword">new</span> ExpensiveObject();
            <span class="hljs-keyword">return</span> instance;<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A classe LazyInitRace contém condições de corrida. Suponha que os encadeamentos A e B executem o método getInstance ao mesmo tempo. A vê que o campo da instância é nulo e cria um novo ExpensiveObject. O segmento B também verifica se o campo da instância é o mesmo nulo. A presença de null no campo neste momento depende da coordenação do tempo, incluindo os caprichos do planejamento e a quantidade de tempo necessária para criar uma instância do ExpensiveObject e definir o valor no campo da instância. Se o campo da instância for nulo quando B a verificar, dois elementos de código que chamam o método getInstance podem obter dois resultados diferentes, mesmo que o método getInstance deva sempre retornar a mesma instância.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O contador de visitas no UnsafeCountingFactorizer também contém condições de corrida. A abordagem "ler, alterar, escrever" implica que, para aumentar o contador, o fluxo deve conhecer seu valor anterior e garantir que ninguém mais altere ou use esse valor durante o processo de atualização.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como a maioria dos erros competitivos, as condições da corrida nem sempre levam ao fracasso: a coordenação temporária é bem-sucedida. </font><font style="vertical-align: inherit;">Mas se a classe LazyInitRace for usada para instanciar o registro de todo o aplicativo, quando retornar instâncias diferentes de várias ativações, os registros serão perdidos ou as ações receberão representações conflitantes do conjunto de objetos registrados. </font><font style="vertical-align: inherit;">Ou se a classe UnsafeSequence for usada para gerar identificadores de entidade em uma estrutura de conservação de dados, dois objetos diferentes poderão ter o mesmo identificador, violando as restrições de identidade.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3 </font><font style="vertical-align: inherit;">Ações compostas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LazyInitRace e UnsafeCountingFactorizer contêm uma sequência de operações que devem ser atômicas. </font><font style="vertical-align: inherit;">Mas, para evitar uma condição de corrida, deve haver um obstáculo para outros threads usarem a variável enquanto um segmento a modifica.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As operações A e B são atômicas se, do ponto de vista do encadeamento executando a operação A, a operação B foi totalmente executada por outro encadeamento ou nem parcialmente executada.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A atomicidade da operação de incremento no UnsafeSequence evitaria a condição de corrida mostrada na Fig. 1.1 As operações "verificar e depois agir" e "ler, alterar, escrever" devem sempre ser atômicas. Eles são chamados de ações compostas - sequências de operações que devem ser executadas atomicamente para manter a segurança do thread. Na próxima seção, consideraremos o bloqueio - um mecanismo incorporado ao Java que fornece atomicidade. Enquanto isso, corrigiremos o problema de outra maneira aplicando a classe segura de thread existente, conforme mostrado no Countingfactorizer na Listagem 2.4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 2.4. Solicitações de contagem de servlets usando AtomicLong</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@ThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicLong count = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count.get(); }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            count.incrementAndGet();<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O pacote java.util.concurrent.atomic contém variáveis ​​atômicas para gerenciar estados de classe. Substituindo o tipo de contador de long por AtomicLong, garantimos que todas as ações que se referem ao estado do contador sejam atomic1. Como o estado do servlet é o estado do contador e o contador é seguro para threads, nosso servlet se torna seguro para threads. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando um único elemento de estado é adicionado a uma classe que não oferece suporte ao estado interno, a classe resultante será protegida por thread se o estado for completamente controlado pelo objeto seguro de thread. Mas, como veremos na próxima seção, a transição de uma variável de estado para a próxima não será tão simples quanto a transição de zero para uma.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Onde for conveniente, use objetos seguros para threads existentes, como AtomicLong, para controlar o estado da sua classe. </font><font style="vertical-align: inherit;">Os possíveis estados de objetos seguros para threads existentes e suas transições para outros estados são mais fáceis de manter e verificar a segurança de threads do que variáveis ​​de estado arbitrárias.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»Mais informações sobre o livro podem ser encontradas no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site da editora</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conteúdo</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trecho do</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
cupom Khabrozhiteley de 25% de desconto no cupom - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Após o pagamento da versão impressa do livro, um livro eletrônico é enviado por e-mail.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt489022/index.html">Usando RabbitMQ com MonsterMQ Parte 2</a></li>
<li><a href="../pt489024/index.html">Biblioteca Webix JavaScript através dos olhos de um iniciante. Parte 5. Trabalhe com dados no lado do usuário</a></li>
<li><a href="../pt489026/index.html">Alterar os algoritmos do Google AdSense pode levar os proprietários de sites e webmasters</a></li>
<li><a href="../pt489028/index.html">Sobre trabalho remoto</a></li>
<li><a href="../pt489034/index.html">O novo aplicativo móvel UIS - tormento ou salvação para quem procura contratos públicos?</a></li>
<li><a href="../pt489040/index.html">AI do Contact Center: boa conversa com terceiros</a></li>
<li><a href="../pt489042/index.html">Grande reabertura da loja: carregamento de dados no Android usando corotina</a></li>
<li><a href="../pt489044/index.html">Física do texto. Parte 1. Símbolos</a></li>
<li><a href="../pt489046/index.html">Monster Truck GAZ66 autônomo 1/16</a></li>
<li><a href="../pt489048/index.html">Log e rastreamento de consultas são práticas recomendadas. Relatório Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>