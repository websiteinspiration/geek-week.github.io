<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👨🏾 👨🏽‍🎨 🔉 Table de hachage simple pour GPU 🥅 💺 🚺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai posté sur Github un nouveau projet appelé A Simple GPU Hash Table . 
 
 Il s'agit d'une simple table de hachage pour le GPU, capable de traiter d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Table de hachage simple pour GPU</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/492560/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/fd/e_/m2fde_n27bcwfhvj00ovkweqofm.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai posté sur Github un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouveau projet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> appelé </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">A Simple GPU Hash Table</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit d'une simple table de hachage pour le GPU, capable de traiter des centaines de millions d'inserts par seconde. </font><font style="vertical-align: inherit;">Sur mon ordinateur portable équipé d'une NVIDIA GTX 1060, le code insère 64 millions de paires clé-valeur générées aléatoirement en 210 ms environ et supprime 32 millions de paires en 64 ms environ. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, la vitesse sur l'ordinateur portable est d'environ 300 millions d'insertions / sec et 500 millions de suppressions / sec. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tableau est écrit en CUDA, bien que la même technique puisse être appliquée à HLSL ou GLSL. </font><font style="vertical-align: inherit;">L'implémentation présente plusieurs limitations qui garantissent des performances élevées sur la carte vidéo:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seules les clés 32 bits et les mêmes valeurs sont traitées.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La table de hachage a une taille fixe.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et cette taille doit être égale à deux degrés.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour les clés et les valeurs, vous devez réserver un marqueur de délimitation simple (dans le code ci-dessus, il s'agit de 0xffffffff).</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table de hachage sans serrures</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La table de hachage utilise l'adressage ouvert avec </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">détection linéaire</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est-à-dire qu'il s'agit simplement d'un tableau de paires clé-valeur qui est stocké en mémoire et qui présente d'excellentes performances de cache. </font><font style="vertical-align: inherit;">Ce n'est pas le cas avec le chaînage, ce qui signifie rechercher un pointeur dans une liste chaînée. </font><font style="vertical-align: inherit;">Une table de hachage est un simple tableau stockant des éléments </font></font><code>KeyValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KeyValue</span>
{</span>
    <span class="hljs-keyword">uint32_t</span> key;
    <span class="hljs-keyword">uint32_t</span> value;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La taille de la table est égale à deux en puissance et non à un nombre premier, car pour utiliser pow2 / AND-mask, une instruction rapide suffit et l'opérateur du module est beaucoup plus lent. Ceci est important dans le cas de la détection linéaire, car dans une recherche linéaire dans le tableau, l'indice de créneau doit être enveloppé dans chaque créneau. Et par conséquent, le coût de l'opération est ajouté modulo dans chaque emplacement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La table stocke uniquement la clé et la valeur de chaque élément, pas le hachage de clé. Étant donné que la table ne stocke que des clés 32 bits, le hachage est calculé très rapidement. Le code ci-dessus utilise le hachage Murmur3, qui n'effectue que quelques décalages, XOR et multiplications.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La table de hachage utilise une technique de protection de verrouillage qui ne dépend pas de l'ordre de placement de la mémoire. Même si certaines opérations d'écriture violent l'ordre d'autres opérations de ce type, la table de hachage conservera toujours l'état correct. Nous en parlerons ci-dessous. La technique fonctionne très bien avec les cartes vidéo dans lesquelles des milliers de threads rivalisent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les clés et les valeurs de la table de hachage sont initialisées pour être vides. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code peut être modifié afin de pouvoir traiter à la fois les clés et les valeurs 64 bits. Les clés nécessitent des opérations atomiques de lecture, d'écriture et d'échange (comparaison et échange). Et les valeurs nécessitent des opérations de lecture et d'écriture atomiques. Heureusement, dans CUDA, les opérations de lecture-écriture pour les valeurs 32 bits et 64 bits sont atomiques tant qu'elles sont naturellement alignées (voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), et les cartes vidéo modernes prennent en charge les opérations atomiques 64 bits de comparaison avec l'échange. </font><font style="vertical-align: inherit;">Bien sûr, lors du passage à 64 bits, les performances diminueront légèrement.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">État de la table de hachage</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque paire clé-valeur dans une table de hachage peut avoir l'un des quatre états suivants:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La clé et le sens sont vides. </font><font style="vertical-align: inherit;">Dans cet état, la table de hachage est initialisée.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La clé a été enregistrée, mais la valeur n'est pas encore. </font><font style="vertical-align: inherit;">Si un autre thread d'exécution lit des données à ce moment, il renvoie une valeur vide. </font><font style="vertical-align: inherit;">C'est normal, la même chose se produirait si un autre fil d'exécution fonctionnait un peu plus tôt, et nous parlons d'une structure de données compétitive.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La clé et la valeur sont enregistrées.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La valeur est disponible pour d'autres threads d'exécution, mais la clé ne l'est pas encore. </font><font style="vertical-align: inherit;">Cela peut se produire car le modèle de programmation CUDA implique un modèle de mémoire mal ordonné. </font><font style="vertical-align: inherit;">C'est normal, en tout état de cause, la clé est toujours vide, même si la valeur ne l'est pas.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une nuance importante est que dès que la clé a été enregistrée dans la fente, elle ne bouge plus - même si la clé est supprimée, nous en parlerons ci-dessous. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code de table de hachage fonctionne même avec des modèles de mémoire mal ordonnés qui ne connaissent pas l'ordre de lecture et d'écriture dans la mémoire. </font><font style="vertical-align: inherit;">Lorsque nous analysons l'insertion, la recherche et la suppression dans la table de hachage, n'oubliez pas que chaque paire clé-valeur est dans l'un des quatre états décrits ci-dessus.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insérer dans une table de hachage</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fonction CUDA qui insère des paires clé-valeur dans une table de hachage ressemble à ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">uint32_t</span> prev = atomicCAS(&amp;hashtable[slot].key, kEmpty, key);
        <span class="hljs-keyword">if</span> (prev == kEmpty || prev == key)<font></font>
        {<font></font>
            hashtable[slot].value = value;<font></font>
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity<span class="hljs-number">-1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour insérer une clé, le code parcourt le tableau de table de hachage en commençant par le hachage de la clé insérée. Dans chaque emplacement de la matrice, une opération de comparaison atomique est effectuée avec l'échange, dans laquelle la clé de cet emplacement est comparée à une clé vide. Si une incompatibilité est détectée, la clé de l'emplacement est mise à jour vers la clé insérée, puis la clé d'origine de l'emplacement est renvoyée. Si cette clé d'origine était vide ou correspondait à la clé insérée, le code a trouvé un emplacement approprié pour l'insertion et apporte la valeur insérée dans l'emplacement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si dans un seul appel du noyau</font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a plusieurs éléments avec la même clé, alors n'importe laquelle de leurs valeurs peut être écrite dans l'emplacement de clé. </font><font style="vertical-align: inherit;">Ceci est considéré comme normal: l'une des opérations d'écriture de valeur-clé au cours de l'appel réussira, mais comme tout cela se produit en parallèle dans plusieurs threads d'exécution, nous ne pouvons pas prédire quelle opération d'écriture dans la mémoire sera la dernière.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche de table de hachage</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code de recherche de clé:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">gpu_hashtable_lookup</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> hashtable[slot].value;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> kEmpty;<font></font>
            }<font></font>
            slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour trouver la valeur de la clé stockée dans la table, nous parcourons le tableau en commençant par le hachage de la clé souhaitée. </font><font style="vertical-align: inherit;">Dans chaque emplacement, nous vérifions si la clé est celle que nous recherchons, et si c'est le cas, retournons ensuite sa valeur. </font><font style="vertical-align: inherit;">Nous vérifions également si la clé est vide, et si oui, nous interrompons la recherche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous ne pouvons pas trouver la clé, le code renvoie une valeur vide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toutes ces opérations de recherche peuvent être effectuées de manière compétitive lors des insertions et des suppressions. </font><font style="vertical-align: inherit;">Chaque paire du tableau aura l'un des quatre états décrits ci-dessus pour le flux.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppression de table de hachage</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code de suppression de clé:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_delete</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
        {<font></font>
            hashtable[slot].value = kEmpty;<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La suppression d'une clé est inhabituelle: nous laissons la clé dans le tableau et marquons sa valeur (pas la clé elle-même) vide. </font><font style="vertical-align: inherit;">Ce code est très similaire à </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sauf que lorsqu'une correspondance est trouvée pour la clé, il rend sa valeur vide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme mentionné ci-dessus, une fois que la clé est écrite dans l'emplacement, elle ne bouge plus. </font><font style="vertical-align: inherit;">Même lorsque vous supprimez un élément du tableau, la clé reste en place, seule sa valeur devient vide. </font><font style="vertical-align: inherit;">Cela signifie que nous n'avons pas besoin d'utiliser l'opération atomique d'écriture de la valeur de l'emplacement, car peu importe si la valeur actuelle est vide ou non - elle deviendra toujours vide.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redimensionner une table de hachage</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez redimensionner la table de hachage en créant une table plus grande et en y insérant des éléments non vides de l'ancienne table. </font><font style="vertical-align: inherit;">Je n'ai pas implémenté cette fonctionnalité car je voulais garder l'exemple de code simple. </font><font style="vertical-align: inherit;">De plus, dans les programmes CUDA, l'allocation de mémoire se fait souvent dans le code hôte, et non dans le noyau CUDA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A A Lock-Free Wait-Free Hash Table</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> décrit comment modifier une telle structure de données protégée par un verrou.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compétitivité</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les extraits de code ci - </font><font style="vertical-align: inherit;">dessus, les fonctions </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">procédé à </font><font style="vertical-align: inherit;">une seule paire de valeurs de clé à la fois. </font><font style="vertical-align: inherit;">Et ci </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">dessous </font><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ils </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traitent un tableau de paires en parallèle, chaque paire dans un thread d'exécution GPU distinct:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU code to invoke the CUDA kernel on the GPU</span>
<span class="hljs-keyword">uint32_t</span> threadblocksize = <span class="hljs-number">1024</span>;
<span class="hljs-keyword">uint32_t</span> gridsize = (numkvs + threadblocksize - <span class="hljs-number">1</span>) / threadblocksize;<font></font>
gpu_hashtable_insert_kernel&lt;&lt;&lt;gridsize, threadblocksize&gt;&gt;&gt;(hashtable, kvs, numkvs);<font></font>
<font></font>
<span class="hljs-comment">// GPU code to process numkvs key/values in parallel</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert_kernel</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">const</span> KeyValue* kvs, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> numkvs)</span>
</span>{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid = blockIdx.x*blockDim.x + threadIdx.x;
    <span class="hljs-keyword">if</span> (threadid &lt; numkvs)<font></font>
    {<font></font>
        gpu_hashtable_insert(hashtable, kvs[threadid].key, kvs[threadid].value);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une table de hachage verrouillable prend en charge les insertions, recherches et suppressions simultanées. Étant donné que les paires clé-valeur sont toujours dans l'un des quatre états et que les clés ne bougent pas, la table garantit l'exactitude même lorsque vous utilisez différents types d'opérations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, si nous traitons un paquet d'insertions et de suppressions en parallèle, et si des clés en double sont contenues dans le tableau d'entrée de paires, nous ne pourrons pas prédire quelles paires gagneront - elles seront écrites dans la table de hachage en dernier. Supposons que nous ayons appelé un code d'insertion avec un tableau d'entrée de paires </font></font><code>A/0 B/1 A/2 C/3 A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lorsque le code est terminé, les paires </font></font><code>B/1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et sont </font></font><code>C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">garanties d'être présentes dans le tableau, mais en même temps l'une des paires y apparaîtra </font></font><code>A/0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>A/2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou</font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cela peut ou non être un problème - tout dépend de l'application. Vous savez peut-être à l'avance qu'il n'y a pas de clés en double dans le tableau d'entrée, ou peu importe pour vous la dernière valeur écrite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si cela vous pose problème, vous devez diviser les paires en double en différents appels système CUDA. Dans CUDA, toute opération d'appel de noyau se termine toujours avant le prochain appel de noyau (au moins dans le même thread. Dans différents threads, le noyau s'exécute en parallèle). Si dans l'exemple ci-dessus, appelez un noyau avec </font></font><code>A/0 B/1 A/2 C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et l'autre avec </font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la clé </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obtiendra une valeur </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parlons maintenant de la fonction </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et de l' </font></font><code>delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisation d'un pointeur simple (simple) ou variable (volatile) vers un tableau de paires dans une table de hachage.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La documentation de CUDA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indique que:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le compilateur peut, à sa discrétion, optimiser les opérations de lecture et d'écriture dans la mémoire globale ou partagée ... Ces optimisations peuvent être désactivées à l'aide du mot-clé </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: ... tout lien vers cette variable est compilé en une véritable instruction de lecture ou d'écriture en mémoire.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les considérations d'exactitude ne nécessitent pas d'application </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si le thread d'exécution utilise la valeur mise en cache d'une opération de lecture antérieure, cela signifie qu'il utilisera des informations un peu obsolètes. </font><font style="vertical-align: inherit;">Mais encore, ce sont des informations sur l'état correct de la table de hachage à un certain moment de l'appel du noyau. </font><font style="vertical-align: inherit;">Si vous devez utiliser les dernières informations, vous pouvez utiliser le pointeur </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais les performances diminueront légèrement: selon mes tests, lorsque vous supprimez 32 millions d'éléments, la vitesse passe de 500 millions de suppressions / s à 450 millions de suppressions / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le test d'insertion de 64 millions d'éléments et de suppression de 32 millions d'entre eux, il n'y a </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pratiquement pas de </font><font style="vertical-align: inherit;">concurrence entre </font><font style="vertical-align: inherit;">et la table de hachage pour le GPU:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f10/342/41f/f1034241fbcf8c6f9ac61e2061aabf4a.png"></div><br>
<code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70 691 ms ont été consacrées à l'insertion et à la suppression d'éléments lors de la publication ultérieure </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(la libération de millions d'éléments prend beaucoup de temps, car de </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombreuses allocations de mémoire sont effectuées à l' </font><font style="vertical-align: inherit;">intérieur </font><font style="vertical-align: inherit;">). Honnêtement, il y a </font></font><code>std:unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des limitations complètement différentes. Il s'agit d'un seul thread d'exécution du processeur, il prend en charge des valeurs-clés de toute taille, fonctionne bien à des taux d'utilisation élevés et affiche des performances stables après de nombreuses suppressions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La durée de la table de hachage pour le GPU et la communication inter-programme était de 984 ms. Cela inclut le temps nécessaire pour placer la table en mémoire et la supprimer (allocation unique de 1 Go de mémoire, ce qui prend du temps dans CUDA), l'insertion et la suppression d'éléments, ainsi que leur itération. Également pris en compte toutes les copies vers et depuis la mémoire de la carte vidéo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La table de hachage elle-même a pris 271 ms. Cela inclut le temps passé par la carte vidéo pour insérer et supprimer des éléments, et ne prend pas en compte le temps nécessaire pour copier dans la mémoire et parcourir le tableau résultant. Si la table GPU vit longtemps ou si la table de hachage est entièrement contenue dans la mémoire de la carte vidéo (par exemple, pour créer une table de hachage qui sera utilisée par un autre code GPU et non par le processeur central), le résultat du test est pertinent.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La table de hachage de la carte vidéo présente des performances élevées en raison de sa bande passante élevée et de sa parallélisation active.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">désavantages</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'architecture de table de hachage a plusieurs problèmes à garder à l'esprit:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le clustering interfère avec le palpage linéaire, à cause de quoi les clés du tableau sont loin d'être idéales.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les clés ne sont pas supprimées à l'aide de la fonction </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et au fil du temps encombrent la table.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conséquence, les performances de la table de hachage peuvent diminuer progressivement, surtout si elle existe depuis longtemps et que de nombreuses insertions et suppressions y sont effectuées. </font><font style="vertical-align: inherit;">Une façon d'atténuer ces lacunes est de ressasser une nouvelle table avec un taux d'utilisation assez bas et de filtrer les clés distantes lors du resshachage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour illustrer les problèmes décrits, j'utilise le code ci-dessus pour créer une table pour 128 millions d'éléments, j'insérerai cycliquement 4 millions d'éléments jusqu'à remplir 124 millions d'emplacements (l'utilisation est d'environ 0,96). </font><font style="vertical-align: inherit;">Voici le tableau des résultats, chaque ligne est un appel au cœur CUDA avec l'insertion de 4 millions de nouveaux éléments dans une table de hachage:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taux d'utilisation </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durée d'insertion 4 194 304 éléments</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11,608448 ms (361,314798 millions de clés / sec.)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,03</font></font></td>
<td>11,751424  (356,918799  /.)</td>
</tr>
<tr>
<td>0,06</td>
<td>11,942592  (351,205515  /.)</td>
</tr>
<tr>
<td>0,09</td>
<td>12,081120  (347,178429  /.)</td>
</tr>
<tr>
<td>0,12</td>
<td>12,242560  (342,600233  /.)</td>
</tr>
<tr>
<td>0,16</td>
<td>12,396448  (338,347235  /.)</td>
</tr>
<tr>
<td>0,19</td>
<td>12,533024  (334,660176  /.)</td>
</tr>
<tr>
<td>0,22</td>
<td>12,703328  (330,173626  /.)</td>
</tr>
<tr>
<td>0,25</td>
<td>12,884512  (325,530693  /.)</td>
</tr>
<tr>
<td>0,28</td>
<td>13,033472  (321,810182  /.)</td>
</tr>
<tr>
<td>0,31</td>
<td>13,239296  (316,807174  /.)</td>
</tr>
<tr>
<td>0,34</td>
<td>13,392448  (313,184256  /.)</td>
</tr>
<tr>
<td>0,37</td>
<td>13,624000  (307,861434  /.)</td>
</tr>
<tr>
<td>0,41</td>
<td>13,875520  (302,280855  /.)</td>
</tr>
<tr>
<td>0,44</td>
<td>14,126528  (296,909756  /.)</td>
</tr>
<tr>
<td>0,47</td>
<td>14,399328  (291,284699  /.)</td>
</tr>
<tr>
<td>0,50</td>
<td>14,690304  (285,515123  /.)</td>
</tr>
<tr>
<td>0,53</td>
<td>15,039136  (278,892623  /.)</td>
</tr>
<tr>
<td>0,56</td>
<td>15,478656  (270,973402  /.)</td>
</tr>
<tr>
<td>0,59</td>
<td>15,985664  (262,379092  /.)</td>
</tr>
<tr>
<td>0,62</td>
<td>16,668673  (251,627968  /.)</td>
</tr>
<tr>
<td>0,66</td>
<td>17,587200  (238,486174  /.)</td>
</tr>
<tr>
<td>0,69</td>
<td>18,690048  (224,413765  /.)</td>
</tr>
<tr>
<td>0,72</td>
<td>20,278816  (206,831789  /.)</td>
</tr>
<tr>
<td>0,75</td>
<td>22,545408  (186,038058  /.)</td>
</tr>
<tr>
<td>0,78</td>
<td>26,053312  (160,989275  /.)</td>
</tr>
<tr>
<td>0,81</td>
<td>31,895008  (131,503463  /.)</td>
</tr>
<tr>
<td>0,84</td>
<td>42,103294  (99,619378  /.)</td>
</tr>
<tr>
<td>0,87</td>
<td>61,849056  (67,815164  /.)</td>
</tr>
<tr>
<td>0,90</td>
<td>105,695999  (39,682713  /.)</td>
</tr>
<tr>
<td>0,94</td>
<td>240,204636  (17,461378  /.)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À mesure que l'utilisation augmente, la productivité diminue. Ceci n'est pas souhaitable dans la plupart des cas. Si une application insère des éléments dans un tableau puis les supprime (par exemple, lors du comptage des mots dans un livre), ce n'est pas un problème. Mais si l'application utilise une table de hachage longue durée (par exemple, dans un éditeur graphique pour stocker des parties d'images non vides lorsque l'utilisateur insère et supprime souvent des informations), ce comportement peut être gênant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et il a mesuré la profondeur de sondage de la table de hachage après 64 millions d'insertions (facteur d'utilisation 0,5). La profondeur moyenne était de 0,4774, de sorte que la plupart des clés étaient situées soit dans le meilleur emplacement possible, soit dans un emplacement à partir de la meilleure position. La profondeur de sondage maximale était de 60.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai ensuite mesuré la profondeur de sondage dans le tableau avec 124 millions d'inserts (taux d'utilisation de 0,97). La profondeur moyenne était déjà de 10,1757 et le maximum - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6474</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (!!). Les performances de sondage linéaire chutent considérablement à des taux d'utilisation élevés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est préférable de garder cette table de hachage basse. Mais ensuite, nous augmentons la productivité en consommant de la mémoire. Heureusement, dans le cas de clés et de valeurs 32 bits, cela peut être justifié. Si dans l'exemple ci-dessus dans le tableau pour 128 millions d'éléments le coefficient d'utilisation de 0,25 est stocké, alors nous ne pouvons pas y placer plus de 32 millions d'éléments, et les 96 millions d'emplacements restants seront perdus - 8 octets pour chaque paire, 768 Mo de mémoire perdue.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter que nous parlons de la perte de mémoire de la carte vidéo, qui est une ressource plus précieuse que la mémoire système. </font><font style="vertical-align: inherit;">Bien que la plupart des cartes graphiques de bureau modernes qui prennent en charge CUDA disposent d'au moins 4 Go de mémoire (au moment de la rédaction, NVIDIA 2080 Ti en a 11 Go), la perte de tels volumes ne sera pas la décision la plus sage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus tard, j'écrirai plus sur la création de tables de hachage pour les cartes vidéo qui n'ont aucun problème avec la profondeur du sondage, ainsi que sur les façons de réutiliser les emplacements distants.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesure de la profondeur de détection</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour déterminer la profondeur du sondage de clé, nous pouvons extraire le hachage de clé (son index idéal dans le tableau) de son index de table réel:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// get_key_index() -&gt; index of key in hash table</span>
<span class="hljs-keyword">uint32_t</span> probelength = (get_key_index(key) - hash(key)) &amp; (hashtablecapacity<span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En raison de la magie de deux nombres binaires dans le code supplémentaire et du fait que la capacité de la table de hachage est égale à deux en puissance, cette approche fonctionnera même lorsque l'index de clé est déplacé au début de la table. </font><font style="vertical-align: inherit;">Prenez une clé hachée à 1 mais insérée dans l'emplacement 3. Ensuite, pour une table de capacité 4, nous obtenons </font></font><code>(3 — 1) &amp; 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce qui équivaut à 2.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous avez des questions ou des commentaires, écrivez-moi sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou ouvrez un nouveau sujet dans le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">référentiel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce code est inspiré de quelques grands articles:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La table de hachage sans verrou la plus simple au monde</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une table de hachage sans attente sans verrouillage</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À l'avenir, je continuerai d'écrire sur les implémentations de table de hachage pour les cartes vidéo et analyserai leurs performances. </font><font style="vertical-align: inherit;">J'ai l'intention de chaîner, de hacher Robin Hood et de coucou en utilisant des opérations atomiques dans des structures de données qui conviennent aux cartes vidéo.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr492540/index.html">Le jeu "Attendez un instant!" sur arduino</a></li>
<li><a href="../fr492546/index.html">Vérification de la vulnérabilité de tout site utilisant Nikto</a></li>
<li><a href="../fr492548/index.html">Apprentissage automatique Unity: apprendre aux agents MO à sauter par-dessus les murs</a></li>
<li><a href="../fr492552/index.html">Comment vivre et travailler en quarantaine à Barcelone</a></li>
<li><a href="../fr492558/index.html">Bonjour, c'est COVID19: le coronavirus vit-il à la surface d'un smartphone?</a></li>
<li><a href="../fr492562/index.html">Trois webinaires Apache Ignite utiles dans votre programme de quarantaine</a></li>
<li><a href="../fr492566/index.html">Analyse de la combinaison d'un algorithme de recherche de clics gourmand avec énumération partielle des sommets des graphes</a></li>
<li><a href="../fr492568/index.html">Obtenez un extrait de Rosreestr via FSIS USRN et python. Partie 2</a></li>
<li><a href="../fr492572/index.html">L'état actuel du monde Java: tendances et faits pour l'un des langages de programmation les plus populaires</a></li>
<li><a href="../fr492574/index.html">Réflexions sur la probabilité de décollage: Apple AirPods avec Momentum True Wireless 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>