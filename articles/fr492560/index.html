<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë®üèæ üë®üèΩ‚Äçüé® üîâ Table de hachage simple pour GPU ü•Ö üí∫ üö∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai post√© sur Github un nouveau projet appel√© A Simple GPU Hash Table . 
 
 Il s'agit d'une simple table de hachage pour le GPU, capable de traiter d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Table de hachage simple pour GPU</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/492560/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/fd/e_/m2fde_n27bcwfhvj00ovkweqofm.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai post√© sur Github un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouveau projet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> appel√© </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">A Simple GPU Hash Table</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit d'une simple table de hachage pour le GPU, capable de traiter des centaines de millions d'inserts par seconde. </font><font style="vertical-align: inherit;">Sur mon ordinateur portable √©quip√© d'une NVIDIA GTX 1060, le code ins√®re 64 millions de paires cl√©-valeur g√©n√©r√©es al√©atoirement en 210 ms environ et supprime 32 millions de paires en 64 ms environ. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, la vitesse sur l'ordinateur portable est d'environ 300 millions d'insertions / sec et 500 millions de suppressions / sec. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tableau est √©crit en CUDA, bien que la m√™me technique puisse √™tre appliqu√©e √† HLSL ou GLSL. </font><font style="vertical-align: inherit;">L'impl√©mentation pr√©sente plusieurs limitations qui garantissent des performances √©lev√©es sur la carte vid√©o:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seules les cl√©s 32 bits et les m√™mes valeurs sont trait√©es.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La table de hachage a une taille fixe.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et cette taille doit √™tre √©gale √† deux degr√©s.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour les cl√©s et les valeurs, vous devez r√©server un marqueur de d√©limitation simple (dans le code ci-dessus, il s'agit de 0xffffffff).</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table de hachage sans serrures</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La table de hachage utilise l'adressage ouvert avec </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©tection lin√©aire</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est-√†-dire qu'il s'agit simplement d'un tableau de paires cl√©-valeur qui est stock√© en m√©moire et qui pr√©sente d'excellentes performances de cache. </font><font style="vertical-align: inherit;">Ce n'est pas le cas avec le cha√Ænage, ce qui signifie rechercher un pointeur dans une liste cha√Æn√©e. </font><font style="vertical-align: inherit;">Une table de hachage est un simple tableau stockant des √©l√©ments </font></font><code>KeyValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KeyValue</span>
{</span>
    <span class="hljs-keyword">uint32_t</span> key;
    <span class="hljs-keyword">uint32_t</span> value;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La taille de la table est √©gale √† deux en puissance et non √† un nombre premier, car pour utiliser pow2 / AND-mask, une instruction rapide suffit et l'op√©rateur du module est beaucoup plus lent. Ceci est important dans le cas de la d√©tection lin√©aire, car dans une recherche lin√©aire dans le tableau, l'indice de cr√©neau doit √™tre envelopp√© dans chaque cr√©neau. Et par cons√©quent, le co√ªt de l'op√©ration est ajout√© modulo dans chaque emplacement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La table stocke uniquement la cl√© et la valeur de chaque √©l√©ment, pas le hachage de cl√©. √âtant donn√© que la table ne stocke que des cl√©s 32 bits, le hachage est calcul√© tr√®s rapidement. Le code ci-dessus utilise le hachage Murmur3, qui n'effectue que quelques d√©calages, XOR et multiplications.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La table de hachage utilise une technique de protection de verrouillage qui ne d√©pend pas de l'ordre de placement de la m√©moire. M√™me si certaines op√©rations d'√©criture violent l'ordre d'autres op√©rations de ce type, la table de hachage conservera toujours l'√©tat correct. Nous en parlerons ci-dessous. La technique fonctionne tr√®s bien avec les cartes vid√©o dans lesquelles des milliers de threads rivalisent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les cl√©s et les valeurs de la table de hachage sont initialis√©es pour √™tre vides. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code peut √™tre modifi√© afin de pouvoir traiter √† la fois les cl√©s et les valeurs 64 bits. Les cl√©s n√©cessitent des op√©rations atomiques de lecture, d'√©criture et d'√©change (comparaison et √©change). Et les valeurs n√©cessitent des op√©rations de lecture et d'√©criture atomiques. Heureusement, dans CUDA, les op√©rations de lecture-√©criture pour les valeurs 32 bits et 64 bits sont atomiques tant qu'elles sont naturellement align√©es (voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), et les cartes vid√©o modernes prennent en charge les op√©rations atomiques 64 bits de comparaison avec l'√©change. </font><font style="vertical-align: inherit;">Bien s√ªr, lors du passage √† 64 bits, les performances diminueront l√©g√®rement.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtat de la table de hachage</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque paire cl√©-valeur dans une table de hachage peut avoir l'un des quatre √©tats suivants:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cl√© et le sens sont vides. </font><font style="vertical-align: inherit;">Dans cet √©tat, la table de hachage est initialis√©e.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cl√© a √©t√© enregistr√©e, mais la valeur n'est pas encore. </font><font style="vertical-align: inherit;">Si un autre thread d'ex√©cution lit des donn√©es √† ce moment, il renvoie une valeur vide. </font><font style="vertical-align: inherit;">C'est normal, la m√™me chose se produirait si un autre fil d'ex√©cution fonctionnait un peu plus t√¥t, et nous parlons d'une structure de donn√©es comp√©titive.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cl√© et la valeur sont enregistr√©es.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La valeur est disponible pour d'autres threads d'ex√©cution, mais la cl√© ne l'est pas encore. </font><font style="vertical-align: inherit;">Cela peut se produire car le mod√®le de programmation CUDA implique un mod√®le de m√©moire mal ordonn√©. </font><font style="vertical-align: inherit;">C'est normal, en tout √©tat de cause, la cl√© est toujours vide, m√™me si la valeur ne l'est pas.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une nuance importante est que d√®s que la cl√© a √©t√© enregistr√©e dans la fente, elle ne bouge plus - m√™me si la cl√© est supprim√©e, nous en parlerons ci-dessous. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code de table de hachage fonctionne m√™me avec des mod√®les de m√©moire mal ordonn√©s qui ne connaissent pas l'ordre de lecture et d'√©criture dans la m√©moire. </font><font style="vertical-align: inherit;">Lorsque nous analysons l'insertion, la recherche et la suppression dans la table de hachage, n'oubliez pas que chaque paire cl√©-valeur est dans l'un des quatre √©tats d√©crits ci-dessus.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ins√©rer dans une table de hachage</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fonction CUDA qui ins√®re des paires cl√©-valeur dans une table de hachage ressemble √† ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">uint32_t</span> prev = atomicCAS(&amp;hashtable[slot].key, kEmpty, key);
        <span class="hljs-keyword">if</span> (prev == kEmpty || prev == key)<font></font>
        {<font></font>
            hashtable[slot].value = value;<font></font>
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity<span class="hljs-number">-1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ins√©rer une cl√©, le code parcourt le tableau de table de hachage en commen√ßant par le hachage de la cl√© ins√©r√©e. Dans chaque emplacement de la matrice, une op√©ration de comparaison atomique est effectu√©e avec l'√©change, dans laquelle la cl√© de cet emplacement est compar√©e √† une cl√© vide. Si une incompatibilit√© est d√©tect√©e, la cl√© de l'emplacement est mise √† jour vers la cl√© ins√©r√©e, puis la cl√© d'origine de l'emplacement est renvoy√©e. Si cette cl√© d'origine √©tait vide ou correspondait √† la cl√© ins√©r√©e, le code a trouv√© un emplacement appropri√© pour l'insertion et apporte la valeur ins√©r√©e dans l'emplacement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si dans un seul appel du noyau</font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a plusieurs √©l√©ments avec la m√™me cl√©, alors n'importe laquelle de leurs valeurs peut √™tre √©crite dans l'emplacement de cl√©. </font><font style="vertical-align: inherit;">Ceci est consid√©r√© comme normal: l'une des op√©rations d'√©criture de valeur-cl√© au cours de l'appel r√©ussira, mais comme tout cela se produit en parall√®le dans plusieurs threads d'ex√©cution, nous ne pouvons pas pr√©dire quelle op√©ration d'√©criture dans la m√©moire sera la derni√®re.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche de table de hachage</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code de recherche de cl√©:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">gpu_hashtable_lookup</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> hashtable[slot].value;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> kEmpty;<font></font>
            }<font></font>
            slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour trouver la valeur de la cl√© stock√©e dans la table, nous parcourons le tableau en commen√ßant par le hachage de la cl√© souhait√©e. </font><font style="vertical-align: inherit;">Dans chaque emplacement, nous v√©rifions si la cl√© est celle que nous recherchons, et si c'est le cas, retournons ensuite sa valeur. </font><font style="vertical-align: inherit;">Nous v√©rifions √©galement si la cl√© est vide, et si oui, nous interrompons la recherche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous ne pouvons pas trouver la cl√©, le code renvoie une valeur vide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toutes ces op√©rations de recherche peuvent √™tre effectu√©es de mani√®re comp√©titive lors des insertions et des suppressions. </font><font style="vertical-align: inherit;">Chaque paire du tableau aura l'un des quatre √©tats d√©crits ci-dessus pour le flux.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppression de table de hachage</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code de suppression de cl√©:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_delete</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
        {<font></font>
            hashtable[slot].value = kEmpty;<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La suppression d'une cl√© est inhabituelle: nous laissons la cl√© dans le tableau et marquons sa valeur (pas la cl√© elle-m√™me) vide. </font><font style="vertical-align: inherit;">Ce code est tr√®s similaire √† </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sauf que lorsqu'une correspondance est trouv√©e pour la cl√©, il rend sa valeur vide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme mentionn√© ci-dessus, une fois que la cl√© est √©crite dans l'emplacement, elle ne bouge plus. </font><font style="vertical-align: inherit;">M√™me lorsque vous supprimez un √©l√©ment du tableau, la cl√© reste en place, seule sa valeur devient vide. </font><font style="vertical-align: inherit;">Cela signifie que nous n'avons pas besoin d'utiliser l'op√©ration atomique d'√©criture de la valeur de l'emplacement, car peu importe si la valeur actuelle est vide ou non - elle deviendra toujours vide.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redimensionner une table de hachage</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez redimensionner la table de hachage en cr√©ant une table plus grande et en y ins√©rant des √©l√©ments non vides de l'ancienne table. </font><font style="vertical-align: inherit;">Je n'ai pas impl√©ment√© cette fonctionnalit√© car je voulais garder l'exemple de code simple. </font><font style="vertical-align: inherit;">De plus, dans les programmes CUDA, l'allocation de m√©moire se fait souvent dans le code h√¥te, et non dans le noyau CUDA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A A Lock-Free Wait-Free Hash Table</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©crit comment modifier une telle structure de donn√©es prot√©g√©e par un verrou.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comp√©titivit√©</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les extraits de code ci - </font><font style="vertical-align: inherit;">dessus, les fonctions </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proc√©d√© √† </font><font style="vertical-align: inherit;">une seule paire de valeurs de cl√© √† la fois. </font><font style="vertical-align: inherit;">Et ci </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">dessous </font><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ils </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traitent un tableau de paires en parall√®le, chaque paire dans un thread d'ex√©cution GPU distinct:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU code to invoke the CUDA kernel on the GPU</span>
<span class="hljs-keyword">uint32_t</span> threadblocksize = <span class="hljs-number">1024</span>;
<span class="hljs-keyword">uint32_t</span> gridsize = (numkvs + threadblocksize - <span class="hljs-number">1</span>) / threadblocksize;<font></font>
gpu_hashtable_insert_kernel&lt;&lt;&lt;gridsize, threadblocksize&gt;&gt;&gt;(hashtable, kvs, numkvs);<font></font>
<font></font>
<span class="hljs-comment">// GPU code to process numkvs key/values in parallel</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert_kernel</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">const</span> KeyValue* kvs, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> numkvs)</span>
</span>{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid = blockIdx.x*blockDim.x + threadIdx.x;
    <span class="hljs-keyword">if</span> (threadid &lt; numkvs)<font></font>
    {<font></font>
        gpu_hashtable_insert(hashtable, kvs[threadid].key, kvs[threadid].value);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une table de hachage verrouillable prend en charge les insertions, recherches et suppressions simultan√©es. √âtant donn√© que les paires cl√©-valeur sont toujours dans l'un des quatre √©tats et que les cl√©s ne bougent pas, la table garantit l'exactitude m√™me lorsque vous utilisez diff√©rents types d'op√©rations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, si nous traitons un paquet d'insertions et de suppressions en parall√®le, et si des cl√©s en double sont contenues dans le tableau d'entr√©e de paires, nous ne pourrons pas pr√©dire quelles paires gagneront - elles seront √©crites dans la table de hachage en dernier. Supposons que nous ayons appel√© un code d'insertion avec un tableau d'entr√©e de paires </font></font><code>A/0 B/1 A/2 C/3 A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lorsque le code est termin√©, les paires </font></font><code>B/1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et sont </font></font><code>C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">garanties d'√™tre pr√©sentes dans le tableau, mais en m√™me temps l'une des paires y appara√Ætra </font></font><code>A/0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>A/2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou</font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cela peut ou non √™tre un probl√®me - tout d√©pend de l'application. Vous savez peut-√™tre √† l'avance qu'il n'y a pas de cl√©s en double dans le tableau d'entr√©e, ou peu importe pour vous la derni√®re valeur √©crite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si cela vous pose probl√®me, vous devez diviser les paires en double en diff√©rents appels syst√®me CUDA. Dans CUDA, toute op√©ration d'appel de noyau se termine toujours avant le prochain appel de noyau (au moins dans le m√™me thread. Dans diff√©rents threads, le noyau s'ex√©cute en parall√®le). Si dans l'exemple ci-dessus, appelez un noyau avec </font></font><code>A/0 B/1 A/2 C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et l'autre avec </font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la cl√© </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obtiendra une valeur </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parlons maintenant de la fonction </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et de l' </font></font><code>delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisation d'un pointeur simple (simple) ou variable (volatile) vers un tableau de paires dans une table de hachage.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La documentation de CUDA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indique que:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le compilateur peut, √† sa discr√©tion, optimiser les op√©rations de lecture et d'√©criture dans la m√©moire globale ou partag√©e ... Ces optimisations peuvent √™tre d√©sactiv√©es √† l'aide du mot-cl√© </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: ... tout lien vers cette variable est compil√© en une v√©ritable instruction de lecture ou d'√©criture en m√©moire.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les consid√©rations d'exactitude ne n√©cessitent pas d'application </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si le thread d'ex√©cution utilise la valeur mise en cache d'une op√©ration de lecture ant√©rieure, cela signifie qu'il utilisera des informations un peu obsol√®tes. </font><font style="vertical-align: inherit;">Mais encore, ce sont des informations sur l'√©tat correct de la table de hachage √† un certain moment de l'appel du noyau. </font><font style="vertical-align: inherit;">Si vous devez utiliser les derni√®res informations, vous pouvez utiliser le pointeur </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais les performances diminueront l√©g√®rement: selon mes tests, lorsque vous supprimez 32 millions d'√©l√©ments, la vitesse passe de 500 millions de suppressions / s √† 450 millions de suppressions / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le test d'insertion de 64 millions d'√©l√©ments et de suppression de 32 millions d'entre eux, il n'y a </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pratiquement pas de </font><font style="vertical-align: inherit;">concurrence entre </font><font style="vertical-align: inherit;">et la table de hachage pour le GPU:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f10/342/41f/f1034241fbcf8c6f9ac61e2061aabf4a.png"></div><br>
<code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70 691 ms ont √©t√© consacr√©es √† l'insertion et √† la suppression d'√©l√©ments lors de la publication ult√©rieure </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(la lib√©ration de millions d'√©l√©ments prend beaucoup de temps, car de </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombreuses allocations de m√©moire sont effectu√©es √† l' </font><font style="vertical-align: inherit;">int√©rieur </font><font style="vertical-align: inherit;">). Honn√™tement, il y a </font></font><code>std:unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des limitations compl√®tement diff√©rentes. Il s'agit d'un seul thread d'ex√©cution du processeur, il prend en charge des valeurs-cl√©s de toute taille, fonctionne bien √† des taux d'utilisation √©lev√©s et affiche des performances stables apr√®s de nombreuses suppressions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La dur√©e de la table de hachage pour le GPU et la communication inter-programme √©tait de 984 ms. Cela inclut le temps n√©cessaire pour placer la table en m√©moire et la supprimer (allocation unique de 1 Go de m√©moire, ce qui prend du temps dans CUDA), l'insertion et la suppression d'√©l√©ments, ainsi que leur it√©ration. √âgalement pris en compte toutes les copies vers et depuis la m√©moire de la carte vid√©o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La table de hachage elle-m√™me a pris 271 ms. Cela inclut le temps pass√© par la carte vid√©o pour ins√©rer et supprimer des √©l√©ments, et ne prend pas en compte le temps n√©cessaire pour copier dans la m√©moire et parcourir le tableau r√©sultant. Si la table GPU vit longtemps ou si la table de hachage est enti√®rement contenue dans la m√©moire de la carte vid√©o (par exemple, pour cr√©er une table de hachage qui sera utilis√©e par un autre code GPU et non par le processeur central), le r√©sultat du test est pertinent.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La table de hachage de la carte vid√©o pr√©sente des performances √©lev√©es en raison de sa bande passante √©lev√©e et de sa parall√©lisation active.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©savantages</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'architecture de table de hachage a plusieurs probl√®mes √† garder √† l'esprit:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le clustering interf√®re avec le palpage lin√©aire, √† cause de quoi les cl√©s du tableau sont loin d'√™tre id√©ales.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cl√©s ne sont pas supprim√©es √† l'aide de la fonction </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et au fil du temps encombrent la table.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cons√©quence, les performances de la table de hachage peuvent diminuer progressivement, surtout si elle existe depuis longtemps et que de nombreuses insertions et suppressions y sont effectu√©es. </font><font style="vertical-align: inherit;">Une fa√ßon d'att√©nuer ces lacunes est de ressasser une nouvelle table avec un taux d'utilisation assez bas et de filtrer les cl√©s distantes lors du resshachage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour illustrer les probl√®mes d√©crits, j'utilise le code ci-dessus pour cr√©er une table pour 128 millions d'√©l√©ments, j'ins√©rerai cycliquement 4 millions d'√©l√©ments jusqu'√† remplir 124 millions d'emplacements (l'utilisation est d'environ 0,96). </font><font style="vertical-align: inherit;">Voici le tableau des r√©sultats, chaque ligne est un appel au c≈ìur CUDA avec l'insertion de 4 millions de nouveaux √©l√©ments dans une table de hachage:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taux d'utilisation </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dur√©e d'insertion 4 194 304 √©l√©ments</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11,608448 ms (361,314798 millions de cl√©s / sec.)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,03</font></font></td>
<td>11,751424  (356,918799  /.)</td>
</tr>
<tr>
<td>0,06</td>
<td>11,942592  (351,205515  /.)</td>
</tr>
<tr>
<td>0,09</td>
<td>12,081120  (347,178429  /.)</td>
</tr>
<tr>
<td>0,12</td>
<td>12,242560  (342,600233  /.)</td>
</tr>
<tr>
<td>0,16</td>
<td>12,396448  (338,347235  /.)</td>
</tr>
<tr>
<td>0,19</td>
<td>12,533024  (334,660176  /.)</td>
</tr>
<tr>
<td>0,22</td>
<td>12,703328  (330,173626  /.)</td>
</tr>
<tr>
<td>0,25</td>
<td>12,884512  (325,530693  /.)</td>
</tr>
<tr>
<td>0,28</td>
<td>13,033472  (321,810182  /.)</td>
</tr>
<tr>
<td>0,31</td>
<td>13,239296  (316,807174  /.)</td>
</tr>
<tr>
<td>0,34</td>
<td>13,392448  (313,184256  /.)</td>
</tr>
<tr>
<td>0,37</td>
<td>13,624000  (307,861434  /.)</td>
</tr>
<tr>
<td>0,41</td>
<td>13,875520  (302,280855  /.)</td>
</tr>
<tr>
<td>0,44</td>
<td>14,126528  (296,909756  /.)</td>
</tr>
<tr>
<td>0,47</td>
<td>14,399328  (291,284699  /.)</td>
</tr>
<tr>
<td>0,50</td>
<td>14,690304  (285,515123  /.)</td>
</tr>
<tr>
<td>0,53</td>
<td>15,039136  (278,892623  /.)</td>
</tr>
<tr>
<td>0,56</td>
<td>15,478656  (270,973402  /.)</td>
</tr>
<tr>
<td>0,59</td>
<td>15,985664  (262,379092  /.)</td>
</tr>
<tr>
<td>0,62</td>
<td>16,668673  (251,627968  /.)</td>
</tr>
<tr>
<td>0,66</td>
<td>17,587200  (238,486174  /.)</td>
</tr>
<tr>
<td>0,69</td>
<td>18,690048  (224,413765  /.)</td>
</tr>
<tr>
<td>0,72</td>
<td>20,278816  (206,831789  /.)</td>
</tr>
<tr>
<td>0,75</td>
<td>22,545408  (186,038058  /.)</td>
</tr>
<tr>
<td>0,78</td>
<td>26,053312  (160,989275  /.)</td>
</tr>
<tr>
<td>0,81</td>
<td>31,895008  (131,503463  /.)</td>
</tr>
<tr>
<td>0,84</td>
<td>42,103294  (99,619378  /.)</td>
</tr>
<tr>
<td>0,87</td>
<td>61,849056  (67,815164  /.)</td>
</tr>
<tr>
<td>0,90</td>
<td>105,695999  (39,682713  /.)</td>
</tr>
<tr>
<td>0,94</td>
<td>240,204636  (17,461378  /.)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä mesure que l'utilisation augmente, la productivit√© diminue. Ceci n'est pas souhaitable dans la plupart des cas. Si une application ins√®re des √©l√©ments dans un tableau puis les supprime (par exemple, lors du comptage des mots dans un livre), ce n'est pas un probl√®me. Mais si l'application utilise une table de hachage longue dur√©e (par exemple, dans un √©diteur graphique pour stocker des parties d'images non vides lorsque l'utilisateur ins√®re et supprime souvent des informations), ce comportement peut √™tre g√™nant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et il a mesur√© la profondeur de sondage de la table de hachage apr√®s 64 millions d'insertions (facteur d'utilisation 0,5). La profondeur moyenne √©tait de 0,4774, de sorte que la plupart des cl√©s √©taient situ√©es soit dans le meilleur emplacement possible, soit dans un emplacement √† partir de la meilleure position. La profondeur de sondage maximale √©tait de 60.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai ensuite mesur√© la profondeur de sondage dans le tableau avec 124 millions d'inserts (taux d'utilisation de 0,97). La profondeur moyenne √©tait d√©j√† de 10,1757 et le maximum - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6474</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (!!). Les performances de sondage lin√©aire chutent consid√©rablement √† des taux d'utilisation √©lev√©s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est pr√©f√©rable de garder cette table de hachage basse. Mais ensuite, nous augmentons la productivit√© en consommant de la m√©moire. Heureusement, dans le cas de cl√©s et de valeurs 32 bits, cela peut √™tre justifi√©. Si dans l'exemple ci-dessus dans le tableau pour 128 millions d'√©l√©ments le coefficient d'utilisation de 0,25 est stock√©, alors nous ne pouvons pas y placer plus de 32 millions d'√©l√©ments, et les 96 millions d'emplacements restants seront perdus - 8 octets pour chaque paire, 768 Mo de m√©moire perdue.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter que nous parlons de la perte de m√©moire de la carte vid√©o, qui est une ressource plus pr√©cieuse que la m√©moire syst√®me. </font><font style="vertical-align: inherit;">Bien que la plupart des cartes graphiques de bureau modernes qui prennent en charge CUDA disposent d'au moins 4 Go de m√©moire (au moment de la r√©daction, NVIDIA 2080 Ti en a 11 Go), la perte de tels volumes ne sera pas la d√©cision la plus sage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus tard, j'√©crirai plus sur la cr√©ation de tables de hachage pour les cartes vid√©o qui n'ont aucun probl√®me avec la profondeur du sondage, ainsi que sur les fa√ßons de r√©utiliser les emplacements distants.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesure de la profondeur de d√©tection</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour d√©terminer la profondeur du sondage de cl√©, nous pouvons extraire le hachage de cl√© (son index id√©al dans le tableau) de son index de table r√©el:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// get_key_index() -&gt; index of key in hash table</span>
<span class="hljs-keyword">uint32_t</span> probelength = (get_key_index(key) - hash(key)) &amp; (hashtablecapacity<span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En raison de la magie de deux nombres binaires dans le code suppl√©mentaire et du fait que la capacit√© de la table de hachage est √©gale √† deux en puissance, cette approche fonctionnera m√™me lorsque l'index de cl√© est d√©plac√© au d√©but de la table. </font><font style="vertical-align: inherit;">Prenez une cl√© hach√©e √† 1 mais ins√©r√©e dans l'emplacement 3. Ensuite, pour une table de capacit√© 4, nous obtenons </font></font><code>(3 ‚Äî 1) &amp; 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce qui √©quivaut √† 2.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous avez des questions ou des commentaires, √©crivez-moi sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou ouvrez un nouveau sujet dans le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©f√©rentiel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce code est inspir√© de quelques grands articles:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La table de hachage sans verrou la plus simple au monde</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une table de hachage sans attente sans verrouillage</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä l'avenir, je continuerai d'√©crire sur les impl√©mentations de table de hachage pour les cartes vid√©o et analyserai leurs performances. </font><font style="vertical-align: inherit;">J'ai l'intention de cha√Æner, de hacher Robin Hood et de coucou en utilisant des op√©rations atomiques dans des structures de donn√©es qui conviennent aux cartes vid√©o.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr492540/index.html">Le jeu "Attendez un instant!" sur arduino</a></li>
<li><a href="../fr492546/index.html">V√©rification de la vuln√©rabilit√© de tout site utilisant Nikto</a></li>
<li><a href="../fr492548/index.html">Apprentissage automatique Unity: apprendre aux agents MO √† sauter par-dessus les murs</a></li>
<li><a href="../fr492552/index.html">Comment vivre et travailler en quarantaine √† Barcelone</a></li>
<li><a href="../fr492558/index.html">Bonjour, c'est COVID19: le coronavirus vit-il √† la surface d'un smartphone?</a></li>
<li><a href="../fr492562/index.html">Trois webinaires Apache Ignite utiles dans votre programme de quarantaine</a></li>
<li><a href="../fr492566/index.html">Analyse de la combinaison d'un algorithme de recherche de clics gourmand avec √©num√©ration partielle des sommets des graphes</a></li>
<li><a href="../fr492568/index.html">Obtenez un extrait de Rosreestr via FSIS USRN et python. Partie 2</a></li>
<li><a href="../fr492572/index.html">L'√©tat actuel du monde Java: tendances et faits pour l'un des langages de programmation les plus populaires</a></li>
<li><a href="../fr492574/index.html">R√©flexions sur la probabilit√© de d√©collage: Apple AirPods avec Momentum True Wireless 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>