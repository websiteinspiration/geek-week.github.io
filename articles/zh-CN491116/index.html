<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😮 📠 😸 现代识别标准：OAuth 2.0，OpenID Connect，WebAuthn 👇🏼 🔇 😋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="放还是不放？就是那个问题…
 
 现在，在许多站点上，我们看到了使用社交网络进行注册或登录的机会，并且某些站点提供了使用外部安全密钥或指纹的功能。它是什么？设计合理的安全标准或专有实施？我们可以信任这些技术并将其用于网站开发和日常生活吗？让我们做对。因此，现在有几种用于标识OAuth 2.0，Ope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>现代识别标准：OAuth 2.0，OpenID Connect，WebAuthn</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491116/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">放还是不放？</font><font style="vertical-align: inherit;">就是那个问题…</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，在许多站点上，我们看到了使用社交网络进行注册或登录的机会，并且某些站点提供了使用外部安全密钥或指纹的功能。它是什么？设计合理的安全标准或专有实施？我们可以信任这些技术并将其用于网站开发和日常生活吗？让我们做对。因此，现在有几种用于标识OAuth 2.0，OpenID Connect，WebAuthn，SAML 2.0，凭据管理API等用户的标准和技术。在本文中，我将讨论三种最有前途的协议OAuth 2.0，OpenID Connect和WebAuthn。为了了解如何将它们付诸实践，我们将做三个实验室工作。我们将使用GitHub和Google作为识别用户的平台。在大多数帐户上。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gr/ue/zz/gruezz06ldvs0qknw9wpmjkfwuy.jpeg" alt="图片"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OAuth 2.0</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从最著名的OAuth 2.0协议开始。</font><font style="vertical-align: inherit;">它于2012年作为RFC 6749发布：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OAuth 2.0授权框架</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用OAuth 2.0，用户允许特定站点从社交网络接收其私人数据，但无需将其登录名/密码传输到该站点。</font><font style="vertical-align: inherit;">例如，当您通过Facebook在站点上注册时，您只授予该站点权限即可从Facebook获取您的姓名，电子邮件地址和其他私人数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们处理技术实施。</font><font style="vertical-align: inherit;">为简单起见，我将称呼在社交网络上存储用户凭据的任何站点。</font><font style="vertical-align: inherit;">MySite将命名任何要从社交网络获取用户数据的站点或应用程序。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rm/ea/-i/rmea-i9jk6jazdlwkiltnftc5_i.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该标准定义了以下角色：</font></font><br>
<br>
<ul>
<li>Resource Owner — ,    MySite          . </li>
<li>Client (  MySite) —    ,        Authorization Server  Resource Server     .</li>
<li>Authorization Server —    / ,   .</li>
<li>Resource Server —    ,      API. Authorization Server  Resource Server      .</li>
</ul><br>
<h3>Authorization flow</h3><br>
<ul>
<li>     MySite  :</li>
<li> MySite  Name ( ), Homepage (   MySite)  Callback (,        ) </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">社交网络给出客户端ID（有时称为AppID）和客户端密钥。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开发者ID必须在客户ID和客户密码中注册。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在过程本身。</font><font style="vertical-align: inherit;">具体实现的细节可能有所不同，但一般逻辑将始终如下：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8u/pw/wi/8upwwi59teredqa6a2qxfuwfcag.png" alt="图片"><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源所有者登录到客户端（MySite），选择“使用社交网络登录”选项，站点将用户重定向到授权服务器上的社交网络。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">授权服务器检查用户是否具有活动会话，如果没有，则显示登录表单。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源所有者输入他的用户名/密码，并确认MySite可以使用某些私人数据，例如用户名或电子邮件地址。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">授权服务器验证用户并使用验证结果和“授权码”重定向到回调地址</font></font></li>
<li>  Client  “Authorization Code”, Client ID  Client Secret.</li>
<li>Authorization Server      “access token”   JWT (JSON Web Token),    .    JWT    “refresh token”, c        .</li>
<li>  Client         API,    “access token”.</li>
<li>Resource Server  “access token” (,    Authorization Server)      . </li>
</ol><br>
<h3>OAuth 2.0   (GitHub)</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于如何使用社交网络实施OAuth 2.0授权的说明很多。</font><font style="vertical-align: inherit;">我个人喜欢以下文章：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用GitHub OAuth 2.0和NodeJS进行身份验证</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它详细说明了步骤并提供了测试程序。</font><font style="vertical-align: inherit;">但是要真正理解该算法，最好动手完成所有步骤（来自浏览器的http请求或curl的调用）。</font><font style="vertical-align: inherit;">走。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，在GitHub上注册您的应用程序：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/settings/applications/new</font></font></a> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
设置参数：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主页：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MySite /主页</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回调：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MySite /回调</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了授权在其自己的站点内工作，这些地址必须真实，但这对于实验室工作不是必需的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从GitHub获取：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户端ID：ab8ec08a620c2</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户端密钥：e6fdd52b0a99e8fbe76b05c1b7bb93c1e</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，在所有实验室工作中，所有价值都是假的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是在GitHub网站上获取客户端ID和密钥的样子：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2b/vz/uo/2bvzuofpefaonhdqppk9cvinmac.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在开始授权。</font><font style="vertical-align: inherit;">我们认为第1步已经完成：用户登录MySite并选择“使用GitHub登录”。</font><font style="vertical-align: inherit;">呼叫流程的第2步是REST格式的呼叫：</font></font><br>
<br>
<pre><code class="xml hljs">https://github.com/login/oauth/authorize?client_id=ab8ec08a620c2</code></pre><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该地址是github上的登录点</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client_id是注册期间发布的客户ID</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此次调用的结果是，GitHub显示了一个授权窗口：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/0f/uq/fh0fuqockmtpmm2yrqkdxlf3gok.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
步骤3：输入登录名/密码以访问GitHub </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
步骤4：GitHub将请求重定向到首页，在此请求中，我们看到代码：</font></font><br>
<br>
<pre><code class="xml hljs">http://MySite/home?code=a29b348f63d21</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此地址上没有工作站点，但是对我们来说，最主要的是知道发送的代码构成下一个步骤5：</font></font><br>
<br>
<pre><code class="xml hljs">https://github.com/login/oauth/access_token?client_id=ab8ec08a620c2&amp;<font></font>
client_secret=e6fdd52b0a99e8fbe76b05c1b7bb93c1e&amp;<font></font>
code=a29b348f63d21</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该地址是GitHub上的访问令牌接收点</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client_id是注册期间发布的客户ID</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client_secret是注册期间发布的客户端密钥</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码是刚刚发送的代码</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
步骤6：作为回应，收到访问令牌：</font></font><br>
<br>
<pre><code class="json hljs">access_token=<span class="hljs-number">31</span>b71cbd372acdbb20ec1644b824f3dd0&amp;scope=&amp;token_type=bearer</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
步骤7：将access_token插入请求标头，然后调用GitHub API： </font></font><br>
<br>
<pre><code class="xml hljs">curl -H "Authorization: token 31b71cbd372acdbb20ec1644b824f3dd0" https://api.github.com/user</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
步骤8：作为回应，我们获得了JSON，其中包含有关我的有用信息，您可以使用这些信息在MySite上创建配置文件：</font></font><br>
<br>
<pre><code class="json hljs">{
  <span class="hljs-attr">"login"</span>: <span class="hljs-string">"AlexeySushkov"</span>,
  <span class="hljs-attr">"html_url"</span>: <span class="hljs-string">"https://github.com/AlexeySushkov"</span>,
  <span class="hljs-attr">"repos_url"</span>: <span class="hljs-string">"https://api.github.com/users/AlexeySushkov/repos"</span>,
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Alexey Sushkov"</span>,
  <span class="hljs-attr">"blog"</span>: <span class="hljs-string">"http://sushkov.ru"</span>,
  <span class="hljs-attr">"location"</span>: <span class="hljs-string">"St.Petersburg, Russia"</span>,
  <span class="hljs-attr">"email"</span>: <span class="hljs-string">"alexey.p.sushkov@gmail.com"</span>,<font></font>
 ..<font></font>
}  <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，我们仅研究了一种OAuth 2.0方案。</font><font style="vertical-align: inherit;">有几种方案，每种方案的使用取决于应用程序，安全性考虑因素，部署方法等。</font><font style="vertical-align: inherit;">可以找到所有方案的描述，例如，在这里：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nutshell中的OAuth 2.0</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Openid连接</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对OAuth 2.0有点了解。</font><font style="vertical-align: inherit;">现在，让我们找出为什么需要OpenID Connect，它是OAuth 2.0的附加组件：</font></font><br>
<br>
<ul>
<li>C  OAuth 2.0     ..      access token,         .  access token                       MySite. OpenID Connect —        (identity).        . </li>
<li>OpenID Connect         “service discovery”.      SSO (Single Sign-On),            .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从技术角度看一下标准。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenID Connect（OIDC）是由</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenID Foundation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">联盟开发的开放OpenID标准</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">OIDC扩展了OAuth 2.0的主要功能：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除访问令牌和刷新令牌外，授权服务器还返回“身份令牌”（ID令牌）。</font><font style="vertical-align: inherit;">它包含在同一JWT中。</font><font style="vertical-align: inherit;">可以从ID令牌中提取以下信息：用户名，登录时间，ID令牌到期日期。</font><font style="vertical-align: inherit;">令牌ID可以在参与者之间转移。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OIDC提供了附加的API，使您可以请求有关用户及其当前会话的信息。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenID Connect中的交互图看起来与OAuth相同。</font><font style="vertical-align: inherit;">请求内容的唯一区别是：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在最初的代码请求中，添加了一个附加属性scope = openid。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该算法的结果是，客户端除了访问和刷新令牌外，还会收到令牌ID。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenID Connect：实验室（Google）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们看看Google在这个主题上能取悦我们什么。</font><font style="vertical-align: inherit;">有关配置和使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google的OpenID Connect的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">详细说明，以及使用</font><font style="vertical-align: inherit;">Google API的沙箱的</font><font style="vertical-align: inherit;">详细说明</font><font style="vertical-align: inherit;">：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google OAuth 2.0 Playground</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，与OAuth 2.0的情况一样，我们将逐步进行操作并查看传入的数据。</font><font style="vertical-align: inherit;">同样，我们认为该应用程序已注册，已收到客户端ID和客户端密钥，并通过了步骤1。</font><font style="vertical-align: inherit;">呼叫流程的第2步是REST格式的呼叫：</font></font><br>
<br>
<pre><code class="xml hljs">https://accounts.google.com/o/oauth2/v2/auth?<font></font>
response_type=code&amp;<font></font>
client_id=140797064495-b8b79j42m97nkkrlndfstikv8.apps.googleusercontent.com&amp;<font></font>
scope=openid%20email&amp;<font></font>
redirect_uri=http%3A//c18529.shared.hc.ru/wp-login.php&amp;<font></font>
state=765439764<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google有点复杂，因为 </font><font style="vertical-align: inherit;">他们更加注意安全性：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地址是Google的登录点 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">response_type =代码-希望收到响应代码</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client_id-注册期间发布的客户ID</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scope = openid电子邮件-我们要访问哪些数据</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redirect_uri-在应用程序注册期间指定的redirect_uri</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">state-客户端生成的编号，在客户端和AS之间传输以防止入侵者干扰。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
步骤3：没有密码输入表单，因为 </font><font style="vertical-align: inherit;">我已经登录到Google。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
步骤4：Google将请求重定向到首页，在此请求中，我们看到以下代码：</font></font><br>
<br>
<pre><code class="xml hljs">http://MySite?state=123&amp;code=4/xAFkcMzhyJhUErRJYwIyntSYN-WeJjfZHLiwWL4IaT-WkHzMU18xABlPmev-M_87wVbqTkQ1y93w6GB5&amp;scope=email+openid+https://www.googleapis.com/auth/userinfo.email&amp;authuser=0&amp;prompt=none
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与GitHub一样，此地址上没有可用的网站，但这不是必需的，对我们来说，主要的事情是知道代码以形成下一步5。这也更加复杂，因为 </font><font style="vertical-align: inherit;">Google需要POST请求，而不是GET请求：</font></font><br>
<br>
<pre><code class="xml hljs">curl -d "code=4/xAFkcMzhyJhUErRJYwIyntSYN-WeJjfZHLiwWL4IaT-WkHzMU18xABlPmev-M_87wVbqTkQ1y93w6GB5&amp;client_id=140797064495-b8b79j42m97nkkrlndfstikv8.apps.googleusercontent.com&amp;<font></font>
client_secret=HMVctrTicW6RC1Q8T&amp;<font></font>
redirect_uri=http%3A//c18529.shared.hc.ru/wp-login.php&amp;<font></font>
grant_type=authorization_code" <font></font>
-H "Content-Type: application/x-www-form-urlencoded" -X POST https://oauth2.googleapis.com/token<font></font>
</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地址是Google上的令牌接收点</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码是刚刚发送的代码</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client_id是注册期间发布的客户ID</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client_secret是注册期间发布的客户端密钥</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grant_type = authorization_code-标准中唯一的有效值</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
步骤6：作为回应，收到access_token和id_token：</font></font><br>
<br>
<pre><code class="json hljs">{
  <span class="hljs-attr">"access_token"</span>: <span class="hljs-string">"ya29.Il_AB0KeKnjBJx0dhjm2nCLt1B-Mq0aQBW5T302JnlZfsxW1AXqLFfDJZRMi2R2WKG4OX4msKLjx4E4CSl4G_4ajAy3aqrf4pM0ic0jJr092pA67H9aktJktCbx"</span>,
  <span class="hljs-attr">"expires_in"</span>: <span class="hljs-number">3327</span>,
  <span class="hljs-attr">"scope"</span>: <span class="hljs-string">"openid https://www.googleapis.com/auth/userinfo.email"</span>,
  <span class="hljs-attr">"token_type"</span>: <span class="hljs-string">"Bearer"</span>,
  <span class="hljs-attr">"id_token"</span>: <span class="hljs-string">"eyJhbGciOiJSUzI1NiIsImtpZCI6IjE3ZDU1ZmY0ZTEwOTkxZDZiMGVmZDM5MmI5MWEzM2U1
………………………………_…………………………………………………….._4mUTiMNSAHljap1hLD2hAzgOZWuQ"</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在如何处理这笔财富？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第7步：使用access_token，一切都变得清晰：我们将其包含在API调用中，例如GMail：</font></font><br>
 <br>
<pre><code class="xml hljs">curl -H "Authorization: Bearer ya29.a0Adw1xeWvFoxHKNICHnV6vFFj5TZdPQVlYD98h8wjW95ZEbHVui_pk7HGRoq3Q7MlVLV23xkVM0yyjSP8ClSlvfUy3b_IqvKQW5Lvwj38QzJhee-aH1grerB4pRpMzn_FGueigG_RGI56pKPgFBTr49cpynQy" https://www.googleapis.com/gmail/v1/users/alexey.p.sushkov@gmail.com/profile</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
步骤8：作为回应，我们获得了带有有用信息的JSON：</font></font><br>
<br>
<pre><code class="json hljs">{
 <span class="hljs-attr">"emailAddress"</span>: <span class="hljs-string">"alexey.p.sushkov@gmail.com"</span>,
 <span class="hljs-attr">"messagesTotal"</span>: <span class="hljs-number">372543</span>,<font></font>
...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们检查一下id_token包含用于验证用户身份和维护会话的信息的语句。</font><font style="vertical-align: inherit;">为此，您需要解密内容。</font><font style="vertical-align: inherit;">最简单的方法是通过</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oauth2.googleapis.com/tokeninfo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font><font style="vertical-align: inherit;">Google API联系，</font><font style="vertical-align: inherit;">并将接收到的id_token指定为参数：</font></font><br>
<br>
<pre><code class="xml hljs">https://oauth2.googleapis.com/tokeninfo?id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6IjE3ZDU1ZmY0ZTEwOTkxZDZiMGVmZDM5MmI5MWEzM2U1NGMwZTIxOGIiLCJ0eXAiOi<font></font>
………………………_……………………………...<font></font>
SVQ5GQni3irfOzOXYEiqijp6TjGa_a-3jKcEsU5TbasZmAIejsdVcNy2_4mUTiMNSAHljap1hLD2hAzgOZWuQ</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
得到了JSON：</font></font><br>
<pre><code class="json hljs">{
  <span class="hljs-attr">"iss"</span>: <span class="hljs-string">"https://accounts.google.com"</span>,
  <span class="hljs-attr">"email"</span>: <span class="hljs-string">"alexey.p.sushkov@gmail.com"</span>,
  <span class="hljs-attr">"email_verified"</span>: <span class="hljs-string">"true"</span>,
  <span class="hljs-attr">"iat"</span>: <span class="hljs-string">"1583257010"</span>,
  <span class="hljs-attr">"exp"</span>: <span class="hljs-string">"1583260610"</span>,
  <span class="hljs-attr">"typ"</span>: <span class="hljs-string">"JWT"</span><font></font>
...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们看到id_token包含有关用户登录，接收时间和令牌寿命的信息。</font><font style="vertical-align: inherit;">我们可以得出结论，来自Google的OpenID Connect正在运行，并且可以用于相关方案。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网络认证</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Web身份验证API</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（也称为WebAuthn）：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该标准允许用户使用外部安全密钥（例如USB密钥）或指纹，然后通过其他生物特征数据（面部，视网膜）在网站和应用程序中标识自己。 </font></font></li>
<li>   —     /             «Public key cryptography». Public key cryptography —   ,     . Private key ( )      ,  public key ( )    .</li>
<li>    W3C (World Wide Web Consortium)  FIDO,   Google, Mozilla, Microsoft, Yubico. W3C    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">HTTP, HTML, XML   </a>.          WebAuthn. WebAuthn    : Chrome, Firefox, Edge, Safari.</li>
</ul><br>
<h3></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与OAuth 2.0相比，WebAuthn添加了以下角色：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Authenticator</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：一个外部安全密钥（物理介质或指纹扫描仪），该密钥使用各种技术（例如，Bluetooth / NFC / USB）对用户进行身份验证。</font><font style="vertical-align: inherit;">服务于：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成公钥证书（公钥/私钥对）。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">身份验证器将私钥安全地存储在其内存中</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将公钥传递给外部系统</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用私钥签名数据并将结果传输到外部系统 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Authenticator使用CTAP协议（客户端到Authenticator协议）与浏览器进行交互。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信赖方</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：执行与OAuth 2.0中的“授权服务器”相同的功能，即验证用户的身份。</font><font style="vertical-align: inherit;">仅在OAuth 2.0中，它是用户名/密码，在WenAuthn中，它是公钥凭据。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户代理</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：集成了浏览器和网络应用程序，其功能与OAuth 2.0中的客户端相同，即，一方面与用户交互并为其提供GUI，另一方面与存储用户凭据的系统进行交互。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">授权流程</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在开始身份验证过程之前，就像在OAuth 2.0中一样，您需要执行准备步骤，仅在OAuth 2.0中我们注册了应用程序，在WebAuth 2.0中我们注册了用户。</font><font style="vertical-align: inherit;">Web身份验证API指定两个调用：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">navigator.credentials.create-创建用户凭证</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">navigator.credentials.get-验证用户凭据 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，要注册，您必须调用navigator.credentials.create。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，用户的身份验证器将存储特定站点的私钥，而公钥将存储在依赖方中。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/n3/lp/44/n3lp44opraxnvlnfnn4cf8ycoiq.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
之后，身份验证过程将如下所示：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oe/g-/or/oeg-ormuycpydsvjdmueignudf8.png" alt="图片"><br>
<br>
<ol>
<li>             “WebAuthn”.    , ,  WebAuthn,  “   ”  “    ”.    Relying Party  Challenge. Challenge —    ,   Code  OAuth 2.0.</li>
<li>Relying Party  Challenge.     ,     REST API. </li>
<li>   Authenticator-    CTAP (Client to Authenticator Protocols).   navigator.credentials.get c :<br>
<br>
<ul>
<li>Challenge</li>
<li> </li>
</ul></li>
<li>Authenticator    ,     ,    .</li>
<li>   ,  Authenticator     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该应用程序将签名的数据发送给依赖方。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信赖方使用公钥解密数据，检查质询并授权用户。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要修复材料，我们需要进行实验室工作：</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebAuthn：实验（Google）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要实施WebAuthn，只能放弃http请求，因为您需要调用浏览器API与Authenticator交互。但是，在这里Google很高兴，通过一步一步的说明制作了一个沙箱：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的第一个WebAuthn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为工作的结果，我们获得了一个实现指纹身份验证的JS客户端-服务器应用程序。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个可运行的deme位于</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果在带有指纹传感器的智能手机上运行它，则可以看到工作结果。像往常一样，首先准备-注册用户：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jb/kk/kt/jbkkkt1mdwiu_ymyjlsazwnz5ti.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建用户名/密码，然后附加指纹：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pk/mk/ck/pkmkckm1ly_ggv10dag6h4kg444.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
之后，程序显示该指纹附加了哪个公钥：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tw/ba/c1/twbac1dgahkkwyszwitwcnheuti.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，您可以启动身份验证脚本。</font><font style="vertical-align: inherit;">和往常一样，我们认为第1步已经完成，并且我们已经在现场。</font><font style="vertical-align: inherit;">要转到步骤2，请单击“尝试重新认证”。</font><font style="vertical-align: inherit;">浏览器将执行第3步并与Authenticator交互，在第4步中将要求您放手指：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sj/gn/e-/sjgne-txsfiph3qxxojrdq8uhkq.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并且如果已连接手指，则第5步和第6步将成功通过，在第7步中，应用程序将再次显示带有相应公钥的窗口：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fr/nw/h5/frnwh5fjkq0xo6mrlvikq7wyctc.png" alt="图片"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们研究了三种最常见且最有前途的用户识别协议：OAuth 2.0，OpenID Connect，WebAuthn。</font><font style="vertical-align: inherit;">我们了解了其适用范围：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OAuth 2.0-用于通过社交网络将用户注册并登录到站点。</font><font style="vertical-align: inherit;">并从社交网络获取用户数据。</font></font></li>
<li>OpenID Connect —               .  OpenID Connect         SSO .</li>
<li>WebAuthn —               .</li>
</ul><br>
<h3></h3><br>
<ul>
<li>,           ,      .</li>
<li>      ,     ,        .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">验证用户到Facebook或Google之类的云平台的身份很有意义，因为 </font><font style="vertical-align: inherit;">他们聘请了能够提供所有安全细微差别的最佳安全专家。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我建议对未来保持乐观，因为 </font><font style="vertical-align: inherit;">WebAuthn协议-摆脱密码时代的真正机会！</font></font></li>
</ul><br>
<b><font color="#B22222"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这仅仅是开始！</font></font></font></b><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录：其他身份验证协议</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了完整起见，我将列出用于识别用户的其他相关协议和技术：</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SAML 2.0（安全性声明标记语言）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2005年的协议已经成熟，但是用于构建SSO系统的方案集有限。</font><font style="vertical-align: inherit;">使用基于XML的数据格式。</font><font style="vertical-align: inherit;">可以在文章中找到更多详细信息：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“谁使用SAML 2.0身份验证协议”</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凭证管理API</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
开发由与WebAuthn-W3C相同的组织进行。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凭据管理标准</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许您：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储订户的身份，这使用户无需输入密码即可访问站点，但可以使用商店中的密码。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择必要的帐户以进入某些站点。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许您使用在另一台设备上的一台设备上输入的登录名/密码。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
凭据管理API的常见实现示例是Google的密码管理器：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passwords.google.com</font></font></a> <br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开放式认证倡议（OATH）</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣誓资源</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于OAuth 2.0的协议的完整列表</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenID Connect-之前已详细审查</font></font></li>
<li><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">OAuth 2.0的</font></a><font style="vertical-align: inherit;"> UMA 1.0 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户管理的访问（UMA）配置文件</font></font></a></li>
<li><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">用于OAuth 2.0授权的</font></a><font style="vertical-align: inherit;"> UMA 2.0 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户管理的访问（UMA）2.0授予</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IndieAuth </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接到W3C标准</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN491106/index.html">为什么需要半同步复制？</a></li>
<li><a href="../zh-CN491108/index.html">使用helmfile在许多k8s环境中进行组织部署</a></li>
<li><a href="../zh-CN491110/index.html">在C＃中将rtf转换为xml</a></li>
<li><a href="../zh-CN491112/index.html">网络纯真之路-Cisco DNA</a></li>
<li><a href="../zh-CN491114/index.html">明智的搬迁或如何选择一家公司工作而不后悔</a></li>
<li><a href="../zh-CN491118/index.html">开发人员心：第五代控制台的Devkit（第1部分）</a></li>
<li><a href="../zh-CN491120/index.html">$ mol：4年后</a></li>
<li><a href="../zh-CN491122/index.html">HiSuite备份的取证分析</a></li>
<li><a href="../zh-CN491130/index.html">要记住的Vue功能</a></li>
<li><a href="../zh-CN491132/index.html">当布隆过滤器不合适时</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>