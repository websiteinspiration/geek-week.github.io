<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏾 💢 🧘 深さが不明確なネストされたリストのアンパック 🙋🏿 📗 🤤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今日は、深さが無限のネストされたリストのアンパックについてお話します。これはかなり重要なタスクなので、実装とは何か、長所と短所、およびパフォーマンスの比較についてここでお話したいと思います。
 

この記事は、以下のいくつかのセクションで構成されます。
 

- 機能
- データ
- 結果
- 調査...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>深さが不明確なネストされたリストのアンパック</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465531/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今日は、深さが無限のネストされたリストのアンパックについてお話します。</font><font style="vertical-align: inherit;">これはかなり重要なタスクなので、実装とは何か、長所と短所、およびパフォーマンスの比較についてここでお話したいと思います。</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事は、以下のいくつかのセクションで構成されます。</font></font></p><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></li>
</ul><a name="habracut"></a><br>
<h1 id="chast-1-funkcii"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1.機能</font></font></h1><br>
<h2 id="zaimstvovannye-realizacii"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">借りた実装</font></font></h2><br>
<h3 id="outer_flatten_1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outer_flatten_1</font></font></h3><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer_flatten_1</span>(<span class="hljs-params">array: Iterable</span>) -&gt; List:</span>
    <span class="hljs-string">"""
    Based on C realization of this solution
    More on:

    https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html

    https://github.com/MSeifert04/iteration_utilities/blob/384948b4e82e41de47fa79fb73efc56c08549b01/src/deepflatten.c
    """</span>
    <span class="hljs-keyword">return</span> deepflatten(array)</code></pre></div></div><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この関数を外部パッケージからの解析に使用しました。</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装はCで行われ、Pythonの高レベルの関数呼び出しインターフェイスが残されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cでの関数の実装はかなり面倒です。スポイラーのリンクをクリックすると、それを確認できます。</font><font style="vertical-align: inherit;">関数はイテレータです。</font></font></p><br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Iterator, Generator
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> iteration_utilities <span class="hljs-keyword">import</span> deepflatten
<span class="hljs-meta">&gt;&gt;&gt; </span>isinstance(deepflatten(a), Iterator)
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>isinstance(deepflatten(a), Generator)
<span class="hljs-literal">False</span></code></pre><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで実装されたアルゴリズムの複雑さについて言うのは難しいので、私はこの関心をHabrユーザーに任せます。</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的に、このライブラリの他のすべての関数は非常に高速で、Cにも実装されていることにも注意したいと思います。</font></font></p><br>
<h3 id="outer_flatten_2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outer_flatten_2</font></font></h3><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer_flatten_2</span>(<span class="hljs-params">array: Iterable</span>) -&gt; List:</span>
    <span class="hljs-string">"""
    recursive algorithm, vaguely reminiscent of recursion_flatten. Based on next pattern:

    .. code:: python

        try:
            tree = iter(node)
        except TypeError:
            yield node

    more on:
    https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.collapse
    """</span>
    <span class="hljs-keyword">return</span> collapse(array)</code></pre></div></div><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされたリストをアンパックするこのメソッドの実装は、外部パッケージ、つまりmore_itertoolsにもあります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、関数は純粋なpythonで実行されますが、最適ではありません。</font><font style="vertical-align: inherit;">詳細な実装は</font><font style="vertical-align: inherit;">、ドキュメント</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で確認できます</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアルゴリズムの複雑さはO（n * m）です。</font></font></p><br>
<h2 id="sobstvennye-realizacii"> </h2><br>
<h3 id="niccolum_flatten">niccolum_flatten</h3><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">niccolum_flatten</span>(<span class="hljs-params">array: Iterable</span>) -&gt; List:</span>
    <span class="hljs-string">"""
    Non recursive algorithm
    Based on pop/insert elements in current list
    """</span><font></font>
<font></font>
    new_array = array[:]<font></font>
    ind = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">while</span> isinstance(new_array[ind], list):<font></font>
                item = new_array.pop(ind)<font></font>
                <span class="hljs-keyword">for</span> inner_item <span class="hljs-keyword">in</span> reversed(item):<font></font>
                    new_array.insert(ind, inner_item)<font></font>
            ind += <span class="hljs-number">1</span>
        <span class="hljs-keyword">except</span> IndexError:
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">return</span> new_array</code></pre></div></div><br>
<p>        @ru_python_beginners       ,    .</p><br>
<p>   ,      (   ),     while True ,     —         .</p><br>
<p>,   ,      , ..     (..       ),                .</p><br>
<p>   O(n^3*m)         </p><br>
<h3 id="tishka_flatten">tishka_flatten</h3><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tishka_flatten</span>(<span class="hljs-params">data: Iterable</span>) -&gt; List:</span>
    <span class="hljs-string">"""
    Non recursive algorithm
    Based on append/extend elements to new list

    """</span>
    nested = <span class="hljs-literal">True</span>
    <span class="hljs-keyword">while</span> nested:<font></font>
        new = []<font></font>
        nested = <span class="hljs-literal">False</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data:
            <span class="hljs-keyword">if</span> isinstance(i, list):<font></font>
                new.extend(i)<font></font>
                nested = <span class="hljs-literal">True</span>
            <span class="hljs-keyword">else</span>:<font></font>
                new.append(i)<font></font>
        data = new<font></font>
    <span class="hljs-keyword">return</span> data</code></pre></div></div><br>
<p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link">Tishka17</a>.    ,    while nested        nested = False, ,  ,       ,    nested = True  extend'    .  ,         ,     —      .     —    ,   ,    .<br>
   O(n*m).</p><br>
<h3 id="zart_flatten">zart_flatten</h3><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zart_flatten</span>(<span class="hljs-params">a: Iterable</span>) -&gt; List:</span>
    <span class="hljs-string">"""
    Non recursive algorithm
    Based on pop from old and append elements to new list
    """</span><font></font>
    queue, out = [a], []<font></font>
    <span class="hljs-keyword">while</span> queue:<font></font>
        elem = queue.pop(<span class="hljs-number">-1</span>)
        <span class="hljs-keyword">if</span> isinstance(elem, list):<font></font>
            queue.extend(elem)<font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            out.append(elem)<font></font>
    <span class="hljs-keyword">return</span> out[::<span class="hljs-number">-1</span>]</code></pre></div></div><br>
<p>,       .   ,     .    ,   ,    ,       ,   ,   —   .     extend/append .   —      ,     .</p><br>
<p>   O(n*m).</p><br>
<h3 id="recursive_flatten_iterator">recursive_flatten_iterator</h3><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recursive_flatten_iterator</span>(<span class="hljs-params">arr: Iterable</span>) -&gt; Iterator:</span>
    <span class="hljs-string">"""
    Recursive algorithm based on iterator
    Usual solution to this problem
    """</span><font></font>
<font></font>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr:
        <span class="hljs-keyword">if</span> isinstance(i, list):
            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> recursion_flatten(i)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">yield</span> i</code></pre></div></div><br>
<p>,       —    yield from.     —      ,   ,      ,   ,      .</p><br>
<p>   O(n*m).</p><br>
<h3 id="recursive_flatten_generator">recursive_flatten_generator</h3><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recursive_flatten_generator</span>(<span class="hljs-params">array: Iterable</span>) -&gt; List:</span>
    <span class="hljs-string">"""
    Recursive algorithm
    Looks like recursive_flatten_iterator, but with extend/append

    """</span><font></font>
    lst = []<font></font>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array:
        <span class="hljs-keyword">if</span> isinstance(i, list):<font></font>
            lst.extend(recursive_flatten_list(i))<font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            lst.append(i)<font></font>
    <span class="hljs-keyword">return</span> lst</code></pre></div></div><br>
<p>     ,     ,    extend/append .</p><br>
<p>   O(n*m).</p><br>
<h3 id="tishka_flatten_with_stack">tishka_flatten_with_stack</h3><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tishka_flatten_with_stack</span>(<span class="hljs-params">seq: Iterable</span>) -&gt; List:</span>
    <span class="hljs-string">"""
    Non recursive algorithm
    Based on zart_flatten, but build on try/except pattern
    """</span><font></font>
    stack = [iter(seq)]<font></font>
    new = []<font></font>
    <span class="hljs-keyword">while</span> stack:<font></font>
        i = stack.pop()<font></font>
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
                data = next(i)<font></font>
                <span class="hljs-keyword">if</span> isinstance(data, list):<font></font>
                    stack.append(i)<font></font>
                    i = iter(data)<font></font>
                <span class="hljs-keyword">else</span>:<font></font>
                    new.append(data)<font></font>
        <span class="hljs-keyword">except</span> StopIteration:
            <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">return</span> new</code></pre></div></div><br>
<p> 1 ,   , ,   ,    zart_flatten,       extend/append ,   —     ,     .       zart_flatten,     while True.</p><br>
<p>   O(n*m).</p><br>
<h1 id="chast-2-dannye"> 2. </h1><br>
<p>            ,          :</p><br>
<h3 id="create_data_decreasing_depth">create_data_decreasing_depth</h3><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_data_decreasing_depth</span>(<span class="hljs-params">
        data: Union[List, Iterator],
        length: int,
        max_depth: int,
        _current_depth: int = None,
        _result: List = None
</span>) -&gt; List:</span>
    <span class="hljs-string">"""
    creates data in depth on decreasing.

    Examples:

    &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(1, 11)), length=5, max_depth=3)
    &gt;&gt;&gt; assert data == [[[1, 2, 3, 4, 5], 6, 7, 8, 9, 10]]
    &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(1, 11)), length=2, max_depth=3)
    &gt;&gt;&gt; assert data == [[[1, 2], 3, 4], 5, 6], [[7, 8,] 9, 10]]
    """</span>
    _result = _result <span class="hljs-keyword">or</span> []<font></font>
    _current_depth = _current_depth <span class="hljs-keyword">or</span> max_depth<font></font>
    data = iter(data)<font></font>
    <span class="hljs-keyword">if</span> _current_depth - <span class="hljs-number">1</span>:<font></font>
        _result.append(create_data_decreasing_depth(<font></font>
            data=data,<font></font>
            length=length,<font></font>
            max_depth=max_depth,<font></font>
            _current_depth=_current_depth - <span class="hljs-number">1</span>,<font></font>
            _result=_result))<font></font>
    <span class="hljs-keyword">try</span>:<font></font>
        _current_length = length<font></font>
        <span class="hljs-keyword">while</span> _current_length:<font></font>
            item = next(data)<font></font>
            _result.append(item)<font></font>
            _current_length -= <span class="hljs-number">1</span><font></font>
<font></font>
        <span class="hljs-keyword">if</span> max_depth == _current_depth:<font></font>
            _result += create_data_decreasing_depth(<font></font>
                data=data,<font></font>
                length=length,<font></font>
                max_depth=max_depth)<font></font>
        <span class="hljs-keyword">return</span> _result<font></font>
<font></font>
    <span class="hljs-keyword">except</span> StopIteration:
        <span class="hljs-keyword">return</span> _result</code></pre></div></div><br>
<p>       </p><br>
<pre><code class="python hljs">    &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)), length=<span class="hljs-number">5</span>, max_depth=<span class="hljs-number">3</span>)<font></font>
    &gt;&gt;&gt; <span class="hljs-keyword">assert</span> data == [[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]]<font></font>
    &gt;&gt;&gt; data = create_data_decreasing_depth(list(range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)), length=<span class="hljs-number">2</span>, max_depth=<span class="hljs-number">3</span>)<font></font>
    &gt;&gt;&gt; <span class="hljs-keyword">assert</span> data == [[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>,] <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]]</code></pre><br>
<h3 id="create_data_increasing_depth">create_data_increasing_depth</h3><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_data_increasing_depth</span>(<span class="hljs-params">
        data: Union[List, Iterator],
        length: int,
        max_depth: int,
        _current_depth: int = None,
        _result: List = None
</span>) -&gt; List:</span>
    <span class="hljs-string">"""
    creates data in depth to increase.

    Examples:

    &gt;&gt;&gt; data = create_data_increasing_depth(list(range(1, 11)), length=5, max_depth=3)
    &gt;&gt;&gt; assert data == [1, 2, 3, 4, 5, [6, 7, 8, 9, 10]]
    &gt;&gt;&gt; data = create_data_increasing_depth(list(range(1, 11)), length=2, max_depth=3)
    &gt;&gt;&gt; assert data == [1, 2, [3, 4, [5, 6]]], 7, 8, [9, 10]]
    """</span>
    _result = _result <span class="hljs-keyword">or</span> []<font></font>
    _current_depth = _current_depth <span class="hljs-keyword">or</span> max_depth<font></font>
    data = iter(data)<font></font>
    <span class="hljs-keyword">try</span>:<font></font>
        _current_length = length<font></font>
        <span class="hljs-keyword">while</span> _current_length:<font></font>
            item = next(data)<font></font>
            _result.append(item)<font></font>
            _current_length -= <span class="hljs-number">1</span><font></font>
<font></font>
    <span class="hljs-keyword">except</span> StopIteration:
        <span class="hljs-keyword">return</span> _result<font></font>
<font></font>
    <span class="hljs-keyword">if</span> _current_depth - <span class="hljs-number">1</span>:<font></font>
        tmp_res = create_data_increasing_depth(<font></font>
            data=data,<font></font>
            length=length,<font></font>
            max_depth=max_depth,<font></font>
            _current_depth=_current_depth - <span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> tmp_res:<font></font>
            _result.append(tmp_res)<font></font>
<font></font>
    <span class="hljs-keyword">if</span> max_depth == _current_depth:<font></font>
        tmp_res = create_data_increasing_depth(<font></font>
            data=data,<font></font>
            length=length,<font></font>
            max_depth=max_depth)<font></font>
        <span class="hljs-keyword">if</span> tmp_res:<font></font>
            _result += tmp_res<font></font>
    <span class="hljs-keyword">return</span> _result</code></pre></div></div><br>
<p>       </p><br>
<pre><code class="python hljs">    &gt;&gt;&gt; data = create_data_increasing_depth(list(range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)), length=<span class="hljs-number">5</span>, max_depth=<span class="hljs-number">3</span>)<font></font>
    &gt;&gt;&gt; <span class="hljs-keyword">assert</span> data == [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]]<font></font>
    &gt;&gt;&gt; data = create_data_increasing_depth(list(range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)), length=<span class="hljs-number">2</span>, max_depth=<span class="hljs-number">3</span>)<font></font>
    &gt;&gt;&gt; <span class="hljs-keyword">assert</span> data == [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]], <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>]]</code></pre><br>
<h3 id="generate_data">generate_data</h3><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_data</span>() -&gt; List[Tuple[str, Dict[str, Union[range, Num]]]]:</span>
    <span class="hljs-string">"""
    Generated collections of Data by pattern

    {amount_item}_amount_{length}_length_{max_depth}_max_depth

    where:

    .. py:attribute:: amount_item:

        len of flatten elements

    .. py:attribute:: length:

        len of elements at the same level of nesting

    .. py:attribute:: max_depth:

        highest possible level of nesting
    """</span><font></font>
<font></font>
    data = []<font></font>
    amount_of_elements = [<span class="hljs-number">10</span> ** i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
    data_template = <span class="hljs-string">'{amount_item}_amount_{length}_length_{max_depth}_max_depth'</span><font></font>
<font></font>
    <span class="hljs-comment"># amount_item doesn't need to be [1]</span>
    <span class="hljs-keyword">for</span> amount_item <span class="hljs-keyword">in</span> amount_of_elements[<span class="hljs-number">1</span>:]:
        <span class="hljs-keyword">for</span> max_depth <span class="hljs-keyword">in</span> amount_of_elements:
            <span class="hljs-comment"># for exclude flatten list after generate data by create_data_increasing_depth</span>
            <span class="hljs-keyword">if</span> amount_item &gt; max_depth:
                <span class="hljs-comment"># generate four types of length</span>
                <span class="hljs-keyword">for</span> length <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, max_depth + <span class="hljs-number">1</span>, math.ceil(max_depth / <span class="hljs-number">4</span>)):
                    <span class="hljs-comment"># min length must be 1</span>
                    length = length <span class="hljs-keyword">or</span> <span class="hljs-number">1</span><font></font>
<font></font>
                    data_name = data_template.format(<font></font>
                        amount_item=amount_item,<font></font>
                        length=length,<font></font>
                        max_depth=max_depth<font></font>
                    )<font></font>
<font></font>
                    data_value = {<font></font>
                        <span class="hljs-string">'data'</span>: range(amount_item),
                        <span class="hljs-string">'length'</span>: length,
                        <span class="hljs-string">'max_depth'</span>: max_depth<font></font>
                    }<font></font>
<font></font>
                    data.append((data_name, data_value))<font></font>
<font></font>
                    <span class="hljs-comment"># for not to produce more than 1 flat entity</span>
                    <span class="hljs-keyword">if</span> max_depth == <span class="hljs-number">1</span>:
                        <span class="hljs-keyword">break</span><font></font>
<font></font>
    <span class="hljs-comment"># this order is convenient for me</span>
    data = sorted(data, key=<span class="hljs-keyword">lambda</span> x: [x[<span class="hljs-number">1</span>][<span class="hljs-string">'data'</span>][<span class="hljs-number">-1</span>], x[<span class="hljs-number">1</span>][<span class="hljs-string">'max_depth'</span>], x[<span class="hljs-number">1</span>][<span class="hljs-string">'length'</span>]])
    <span class="hljs-keyword">return</span> data</code></pre></div></div><br>
<p>       .     ,   </p><br>
<pre><code class="python hljs">data_template = <span class="hljs-string">'{amount_item}_amount_{length}_length_{max_depth}_max_depth'</span></code></pre><br>
<p>:</p><br>
<ul>
<li>amount —     </li>
<li>length —      </li>
<li>max_depth —    </li>
</ul><br>
<p>          . ,  ,    ,     ():</p><br>
<pre><code class="plaintext hljs">10_amount_1_length_1_max_depth<font></font>
100_amount_1_length_1_max_depth<font></font>
100_amount_1_length_10_max_depth<font></font>
100_amount_3_length_10_max_depth<font></font>
100_amount_6_length_10_max_depth<font></font>
100_amount_9_length_10_max_depth<font></font>
1000_amount_1_length_1_max_depth<font></font>
1000_amount_1_length_10_max_depth<font></font>
1000_amount_3_length_10_max_depth<font></font>
1000_amount_6_length_10_max_depth<font></font>
1000_amount_9_length_10_max_depth<font></font>
1000_amount_1_length_100_max_depth<font></font>
1000_amount_25_length_100_max_depth<font></font>
1000_amount_50_length_100_max_depth<font></font>
1000_amount_75_length_100_max_depth<font></font>
1000_amount_100_length_100_max_depth<font></font>
10000_amount_1_length_1_max_depth<font></font>
10000_amount_1_length_10_max_depth<font></font>
10000_amount_3_length_10_max_depth<font></font>
10000_amount_6_length_10_max_depth<font></font>
10000_amount_9_length_10_max_depth<font></font>
10000_amount_1_length_100_max_depth<font></font>
10000_amount_25_length_100_max_depth<font></font>
10000_amount_50_length_100_max_depth<font></font>
10000_amount_75_length_100_max_depth<font></font>
10000_amount_100_length_100_max_depth<font></font>
10000_amount_1_length_1000_max_depth<font></font>
10000_amount_250_length_1000_max_depth<font></font>
10000_amount_500_length_1000_max_depth<font></font>
10000_amount_750_length_1000_max_depth<font></font>
10000_amount_1000_length_1000_max_depth</code></pre><br>
<h1 id="chast-3-rezultaty"> 3. </h1><br>
<p>  CPU —   line_profiler<br>
   — timeit + matplotlib</p><br>
<h4 id="cpu-profayler">CPU </h4><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="plaintext hljs">$ kernprof -l funcs.py<font></font>
<font></font>
$ python -m line_profiler funcs.py.lprof<font></font>
Timer unit: 1e-06 s<font></font>
<font></font>
Total time: 1.7e-05 s<font></font>
File: funcs.py<font></font>
Function: outer_flatten_1 at line 11<font></font>
<font></font>
Line #      Hits         Time  Per Hit   % Time  Line Contents<font></font>
==============================================================<font></font>
    11                                           @profile<font></font>
    12                                           def outer_flatten_1(array: Iterable) -&gt; List:<font></font>
    13                                               """<font></font>
    14                                               Based on C realization of this solution<font></font>
    15                                               More on:<font></font>
    16<font></font>
    17                                               https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html<font></font>
    18<font></font>
    19                                               https://github.com/MSeifert04/iteration_utilities/blob/384948b4e82e41de47fa79fb73efc56c08549b01/src/deepflatten.c<font></font>
    20                                               """<font></font>
    21         2         17.0      8.5    100.0      return deepflatten(array)<font></font>
<font></font>
Total time: 3.3e-05 s<font></font>
File: funcs.py<font></font>
Function: outer_flatten_2 at line 24<font></font>
<font></font>
Line #      Hits         Time  Per Hit   % Time  Line Contents<font></font>
==============================================================<font></font>
    24                                           @profile<font></font>
    25                                           def outer_flatten_2(array: Iterable) -&gt; List:<font></font>
    26                                               """<font></font>
    27                                               recursive algorithm, vaguely reminiscent of recursion_flatten. Based on next pattern:<font></font>
    28<font></font>
    29                                               .. code:: python<font></font>
    30<font></font>
    31                                                   try:<font></font>
    32                                                       tree = iter(node)<font></font>
    33                                                   except TypeError:<font></font>
    34                                                       yield node<font></font>
    35<font></font>
    36                                               more on:<font></font>
    37                                               https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.collapse<font></font>
    38                                               """<font></font>
    39         2         33.0     16.5    100.0      return collapse(array)<font></font>
<font></font>
Total time: 0.105099 s<font></font>
File: funcs.py<font></font>
Function: niccolum_flatten at line 42<font></font>
<font></font>
Line #      Hits         Time  Per Hit   % Time  Line Contents<font></font>
==============================================================<font></font>
    42                                           @profile<font></font>
    43                                           def niccolum_flatten(array: Iterable) -&gt; List:<font></font>
    44                                               """<font></font>
    45                                               Non recursive algorithm<font></font>
    46                                               Based on pop/insert elements in current list<font></font>
    47                                               """<font></font>
    48<font></font>
    49         2         39.0     19.5      0.0      new_array = array[:]<font></font>
    50         2          6.0      3.0      0.0      ind = 0<font></font>
    51         2          2.0      1.0      0.0      while True:<font></font>
    52     20002       7778.0      0.4      7.4          try:<font></font>
    53     21010      13528.0      0.6     12.9              while isinstance(new_array[ind], list):<font></font>
    54      1008       1520.0      1.5      1.4                  item = new_array.pop(ind)<font></font>
    55     21014      13423.0      0.6     12.8                  for inner_item in reversed(item):<font></font>
    56     20006      59375.0      3.0     56.5                      new_array.insert(ind, inner_item)<font></font>
    57     20000       9423.0      0.5      9.0              ind += 1<font></font>
    58         2          2.0      1.0      0.0          except IndexError:<font></font>
    59         2          2.0      1.0      0.0              break<font></font>
    60         2          1.0      0.5      0.0      return new_array<font></font>
<font></font>
Total time: 0.137481 s<font></font>
File: funcs.py<font></font>
Function: tishka_flatten at line 63<font></font>
<font></font>
Line #      Hits         Time  Per Hit   % Time  Line Contents<font></font>
==============================================================<font></font>
    63                                           @profile<font></font>
    64                                           def tishka_flatten(data: Iterable) -&gt; List:<font></font>
    65                                               """<font></font>
    66                                               Non recursive algorithm<font></font>
    67                                               Based on append/extend elements to new list<font></font>
    68<font></font>
    69                                               """<font></font>
    70         2         17.0      8.5      0.0      nested = True<font></font>
    71      1012       1044.0      1.0      0.8      while nested:<font></font>
    72      1010       1063.0      1.1      0.8          new = []<font></font>
    73      1010        992.0      1.0      0.7          nested = False<font></font>
    74    112018      38090.0      0.3     27.7          for i in data:<font></font>
    75    111008      50247.0      0.5     36.5              if isinstance(i, list):<font></font>
    76      1008       1431.0      1.4      1.0                  new.extend(i)<font></font>
    77      1008       1138.0      1.1      0.8                  nested = True<font></font>
    78                                                       else:<font></font>
    79    110000      42052.0      0.4     30.6                  new.append(i)<font></font>
    80      1010       1406.0      1.4      1.0          data = new<font></font>
    81         2          1.0      0.5      0.0      return data<font></font>
<font></font>
Total time: 0.062931 s<font></font>
File: funcs.py<font></font>
Function: zart_flatten at line 84<font></font>
<font></font>
Line #      Hits         Time  Per Hit   % Time  Line Contents<font></font>
==============================================================<font></font>
    84                                           @profile<font></font>
    85                                           def zart_flatten(a: Iterable) -&gt; List:<font></font>
    86                                               """<font></font>
    87                                               Non recursive algorithm<font></font>
    88                                               Based on pop from old and append elements to new list<font></font>
    89                                               """<font></font>
    90         2         20.0     10.0      0.0      queue, out = [a], []<font></font>
    91     21012      12866.0      0.6     20.4      while queue:<font></font>
    92     21010      16849.0      0.8     26.8          elem = queue.pop(-1)<font></font>
    93     21010      17768.0      0.8     28.2          if isinstance(elem, list):<font></font>
    94      1010       1562.0      1.5      2.5              queue.extend(elem)<font></font>
    95                                                   else:<font></font>
    96     20000      13813.0      0.7     21.9              out.append(elem)<font></font>
    97         2         53.0     26.5      0.1      return out[::-1]<font></font>
<font></font>
Total time: 0.052754 s<font></font>
File: funcs.py<font></font>
Function: recursive_flatten_generator at line 100<font></font>
<font></font>
Line #      Hits         Time  Per Hit   % Time  Line Contents<font></font>
==============================================================<font></font>
   100                                           @profile<font></font>
   101                                           def recursive_flatten_generator(array: Iterable) -&gt; List:<font></font>
   102                                               """<font></font>
   103                                               Recursive algorithm<font></font>
   104                                               Looks like recursive_flatten_iterator, but with extend/append<font></font>
   105<font></font>
   106                                               """<font></font>
   107      1010       1569.0      1.6      3.0      lst = []<font></font>
   108     22018      13565.0      0.6     25.7      for i in array:<font></font>
   109     21008      17060.0      0.8     32.3          if isinstance(i, list):<font></font>
   110      1008       6624.0      6.6     12.6              lst.extend(recursive_flatten_generator(i))<font></font>
   111                                                   else:<font></font>
   112     20000      13622.0      0.7     25.8              lst.append(i)<font></font>
   113      1010        314.0      0.3      0.6      return lst<font></font>
<font></font>
Total time: 0.054103 s<font></font>
File: funcs.py<font></font>
Function: recursive_flatten_iterator at line 116<font></font>
<font></font>
Line #      Hits         Time  Per Hit   % Time  Line Contents<font></font>
==============================================================<font></font>
   116                                           @profile<font></font>
   117                                           def recursive_flatten_iterator(arr: Iterable) -&gt; Iterator:<font></font>
   118                                               """<font></font>
   119                                               Recursive algorithm based on iterator<font></font>
   120                                               Usual solution to this problem<font></font>
   121<font></font>
   122                                               """<font></font>
   123<font></font>
   124     22018      20200.0      0.9     37.3      for i in arr:<font></font>
   125     21008      19363.0      0.9     35.8          if isinstance(i, list):<font></font>
   126      1008       6856.0      6.8     12.7              yield from recursive_flatten_iterator(i)<font></font>
   127                                                   else:<font></font>
   128     20000       7684.0      0.4     14.2              yield i<font></font>
<font></font>
Total time: 0.056111 s<font></font>
File: funcs.py<font></font>
Function: tishka_flatten_with_stack at line 131<font></font>
<font></font>
Line #      Hits         Time  Per Hit   % Time  Line Contents<font></font>
==============================================================<font></font>
   131                                           @profile<font></font>
   132                                           def tishka_flatten_with_stack(seq: Iterable) -&gt; List:<font></font>
   133                                               """<font></font>
   134                                               Non recursive algorithm<font></font>
   135                                               Based on zart_flatten, but build on try/except pattern<font></font>
   136                                               """<font></font>
   137         2         24.0     12.0      0.0      stack = [iter(seq)]<font></font>
   138         2          5.0      2.5      0.0      new = []<font></font>
   139      1012        357.0      0.4      0.6      while stack:<font></font>
   140      1010        435.0      0.4      0.8          i = stack.pop()<font></font>
   141      1010        328.0      0.3      0.6          try:<font></font>
   142      1010        330.0      0.3      0.6              while True:<font></font>
   143     22018      17272.0      0.8     30.8                  data = next(i)<font></font>
   144     21008      18951.0      0.9     33.8                  if isinstance(data, list):<font></font>
   145      1008        997.0      1.0      1.8                      stack.append(i)<font></font>
   146      1008       1205.0      1.2      2.1                      i = iter(data)<font></font>
   147                                                           else:<font></font>
   148     20000      15413.0      0.8     27.5                      new.append(data)<font></font>
   149      1010        425.0      0.4      0.8          except StopIteration:<font></font>
   150      1010        368.0      0.4      0.7              pass<font></font>
   151         2          1.0      0.5      0.0      return new</code></pre></div></div><br>
<h4 id="grafiki"></h4><br>
<p> :</p><br>
<p><img src="https://habrastorage.org/webt/mv/hn/er/mvhner8sf4u_w9alvn647vudda0.png"></p><br>
<p>   , :</p><br>
<p><img src="https://habrastorage.org/webt/gs/nm/pg/gsnmpgozl3yv02xdzllnuqvlif0.png"></p><br>
<h1 id="chast-4-vyvody"> 4. </h1><br>
<p>,   , ,     ,    . ,  niccolum_flatten,     ,          .  recursive_flatten_generator    recursive_flatten_iterator.</p><br>
<p> ,    ,      ,         . ,     ,  ,    , ..  .</p><br>
<h3 id="poleznye-ssylki"> </h3><br>
<p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a><br>
   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a><br>
  sphinx <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a></p><br>
<p>  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link">Niccolum</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはメールlastsal@mail.ru。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は建設的な批判に喜んでいます。</font></font></p></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja465517/index.html">DoodleBattleペーパーボードゲーム</a></li>
<li><a href="../ja465519/index.html">展覧会PRO // Movement.Expo</a></li>
<li><a href="../ja465521/index.html">Fly-fly-petal ...、またはUXデザイナーがInstagramで彼の製品を宣伝した方法についての物語</a></li>
<li><a href="../ja465525/index.html">Oracle BI EE 12cに関するモバイルレポート-1、2、3。Oracle BI EE 12c CADコースの方法論</a></li>
<li><a href="../ja465527/index.html">RFC 4357からRFC 8645への長い道のり、または暗号化キーの管理方法</a></li>
<li><a href="../ja465535/index.html">誰がIPv6を実装し、その開発を妨げているもの</a></li>
<li><a href="../ja465537/index.html">Yandex：大人のスマートホーム</a></li>
<li><a href="../ja465539/index.html">766 km-LoRaWANの新記録</a></li>
<li><a href="../ja465541/index.html">エンタープライズからSMBへ：SaaSモデルを使用した収益化により、中小企業向けの企業ソリューションの適応に関する経験を共有します</a></li>
<li><a href="../ja465545/index.html">州のさまざまな側面：Facebookが米国議会でどのように揚げられたのか、テレグラムはFSBと戦った</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>