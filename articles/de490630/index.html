<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👾 👧🏿 🤳🏻 Laden von NumPy-Arrays von der Festplatte: Vergleich von memmap () und Zarr / HDF5 ⚔️ 💃🏼 🙍🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Ihr NumPy-Array zu groß ist, um in den Arbeitsspeicher zu passen, können Sie es verarbeiten, indem Sie es in Fragmente aufteilen . Sie können die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Laden von NumPy-Arrays von der Festplatte: Vergleich von memmap () und Zarr / HDF5</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/490630/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Ihr NumPy-Array zu groß ist, um in den Arbeitsspeicher zu passen, können Sie es verarbeiten, indem Sie es in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmente aufteilen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie können dies entweder im transparenten Modus oder explizit tun, indem Sie diese Fragmente einzeln von der Festplatte laden. </font><font style="vertical-align: inherit;">
In dieser Situation können Sie auf zwei Werkzeugklassen zurückgreifen:</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/2n/8r/ck/2n8rckf95tnhx1yrkvvlfy2cf_4.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumPy-Methode </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ein transparenter Mechanismus, mit dem Sie eine Datei auf einer Festplatte so wahrnehmen können, als ob sich alles im Speicher befindet.&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr- und HDF5-Datenspeicherformate, die einander ähnlich sind und bei Bedarf das Laden von der Festplatte und das Speichern komprimierter Fragmente des Arrays auf der Festplatte ermöglichen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede dieser Methoden hat ihre eigenen Stärken und Schwächen.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Material, dessen Übersetzung wir heute veröffentlichen, widmet sich der Analyse der Merkmale dieser Methoden der Arbeit mit Daten und der Geschichte, in welchen Situationen sie sich als nützlich erweisen können. </font><font style="vertical-align: inherit;">Besonderes Augenmerk wird auf Datenformate gelegt, die für die Durchführung von Berechnungen optimiert sind und nicht unbedingt dazu bestimmt sind, diese Daten an andere Programmierer zu übertragen.</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was passiert beim Lesen von Daten von einer Festplatte oder beim Schreiben von Daten auf eine Festplatte?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn eine Datei zum ersten Mal von der Festplatte gelesen wird, kopiert das Betriebssystem die Daten nicht nur in den Prozessspeicher. </font><font style="vertical-align: inherit;">Zunächst kopiert es diese Daten in seinen Speicher und speichert eine Kopie davon im sogenannten „Puffer-Cache“. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was nützt das hier? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsache ist, dass das Betriebssystem Daten im Cache speichert, falls Sie dieselben Daten erneut aus derselben Datei lesen müssen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c5/896/e36/8c5896e36f5312d8e00b92103b7d037f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Daten erneut gelesen werden, gelangen sie nicht von der Festplatte in den Programmspeicher, sondern aus dem um Größenordnungen schnelleren RAM.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/382/7a3/cf33827a346960cbcc33f54835b9bce3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der vom Cache belegte Speicher für etwas anderes benötigt wird, wird der Cache automatisch geleert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Daten auf die Festplatte geschrieben werden, bewegen sie sich in die entgegengesetzte Richtung. </font><font style="vertical-align: inherit;">Zunächst werden sie nur in den Puffercache geschrieben. </font><font style="vertical-align: inherit;">Dies bedeutet, dass Schreibvorgänge normalerweise sehr schnell sind, da sich das Programm nicht auf eine langsame Festplatte konzentrieren muss. </font><font style="vertical-align: inherit;">Sie muss während der Aufnahme nur mit RAM arbeiten.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed3/6be/592/ed36be592685ca4f42954971e000eb89.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen werden die Daten aus dem Cache auf die Festplatte geleert.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffc/0bb/0fc/ffc0bb0fc60c346671dfba89e8c78c1c.png"></div><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeiten mit einem Array mit memmap ()</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">können wir eine Datei auf der Festplatte so wahrnehmen, als wäre sie ein im Speicher gespeichertes Array. </font><font style="vertical-align: inherit;">Das für das Programm transparente Betriebssystem führt Lese- / Schreibvorgänge aus und greift entweder auf den Puffercache oder die Festplatte zu, je nachdem, ob die angeforderten Daten im Speicher zwischengespeichert sind oder nicht. </font><font style="vertical-align: inherit;">Ein solcher Algorithmus wird hier ausgeführt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Befinden sich die Daten im Cache? </font><font style="vertical-align: inherit;">Wenn ja - großartig - können Sie sie direkt kontaktieren.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sind die Daten auf der Festplatte? </font><font style="vertical-align: inherit;">Der Zugriff auf sie ist langsamer, aber Sie müssen sich keine Sorgen machen, sie werden im transparenten Modus geladen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als zusätzliches Plus </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann angemerkt werden, dass in den meisten Fällen der Puffercache für die Datei in den Programmspeicher eingebaut wird. </font><font style="vertical-align: inherit;">Dies bedeutet, dass das System keine zusätzliche Kopie der Daten im Programmspeicher außerhalb des Puffers verwalten muss.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47e/922/86e/47e92286e0761142e8f411c84d188e76.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Methode </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist in NumPy integriert:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<font></font>
array = np.memmap(<span class="hljs-string">"mydata/myarray.arr"</span>, mode=<span class="hljs-string">"r"</span>,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtype=np.int16, shape=(<span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie diesen Code ausführen, steht Ihnen ein Array zur Verfügung, dessen Arbeit für das Programm vollständig transparent ist - unabhängig davon, ob die Arbeit mit dem Puffercache oder mit der Festplatte ausgeführt wird.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einschränkungen für Memmap ()</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl es sich in bestimmten Situationen </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recht gut zeigen kann, weist diese Methode auch Einschränkungen auf:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten müssen im Dateisystem gespeichert werden. </font><font style="vertical-align: inherit;">Daten können nicht aus einem Binärspeicher wie AWS S3 heruntergeladen werden.</font></font></li>
<li>        ,      .   ,       . ,           ,  ,      .</li>
<li>   N-        ,      ,        ,        .         .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns den letzten Punkt erklären. </font><font style="vertical-align: inherit;">Stellen Sie sich vor, wir haben ein zweidimensionales Array mit 32-Bit-Ganzzahlen (4 Byte). </font><font style="vertical-align: inherit;">Pro Festplatte werden 4096 Bytes gelesen. </font><font style="vertical-align: inherit;">Wenn Sie Daten, die sich in einer Datei befinden, nacheinander von einer Festplatte lesen (z. B. in Array-Zeilen), haben wir nach jedem Lesevorgang 1024 Ganzzahlen. </font><font style="vertical-align: inherit;">Wenn Sie jedoch Daten lesen, deren Speicherort in der Datei nicht mit dem Speicherort im Array übereinstimmt (z. B. Daten in Spalten), können Sie bei jedem Lesevorgang nur eine erforderliche Nummer abrufen. </font><font style="vertical-align: inherit;">Infolgedessen stellt sich heraus, dass Sie tausendmal mehr Lesevorgänge ausführen müssen, um die gleiche Datenmenge zu erhalten.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr und HDF5</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die oben genannten Einschränkungen zu überwinden, können Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder HDF5 </font><font style="vertical-align: inherit;">-Datenspeicherformate verwenden </font><font style="vertical-align: inherit;">, die sehr ähnlich sind:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können mit HDF5-Dateien in Python mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pytables</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h5py arbeiten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dieses Format ist älter als Zarr und unterliegt weiteren Einschränkungen. Das Plus ist jedoch, dass es in Programmen verwendet werden kann, die in verschiedenen Sprachen geschrieben sind.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr ist ein Format, das mit dem gleichnamigen Python-Paket implementiert wurde. </font><font style="vertical-align: inherit;">Es ist viel moderner und flexibler als HDF5, aber Sie können es (zumindest für den Moment) nur in der Python-Umgebung verwenden. </font><font style="vertical-align: inherit;">Meiner Meinung nach lohnt es sich in den meisten Situationen, Zarr zu wählen, wenn HDF5 nicht mehrsprachig unterstützt werden muss. </font><font style="vertical-align: inherit;">Zarr hat zum Beispiel eine bessere Multithreading-Unterstützung.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weiter werden wir nur Zarr diskutieren, aber wenn Sie sich für das HDF5-Format und seinen tieferen Vergleich mit Zarr interessieren, können Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Video </font><font style="vertical-align: inherit;">ansehen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Zarr</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Zarr können Sie Daten speichern und in Form von Arrays in den Speicher laden. Außerdem können Sie diese Daten in Form von Arrays schreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So laden Sie ein Array mit Zarr:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> zarr, numpy <span class="hljs-keyword">as</span> np
<span class="hljs-meta">&gt;&gt;&gt; </span>z = zarr.open(<span class="hljs-string">'example.zarr'</span>, mode=<span class="hljs-string">'a'</span>,
<span class="hljs-meta">... </span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shape=(<span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>),
<span class="hljs-meta">... </span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunks=(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>), dtype=np.int16)
<span class="hljs-meta">&gt;&gt;&gt; </span>type(z)<font></font>
&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">zarr</span>.<span class="hljs-title">core</span>.<span class="hljs-title">Array</span>'&gt;
&gt;&gt;&gt; <span class="hljs-title">type</span>(<span class="hljs-params">z[<span class="hljs-number">100</span>:<span class="hljs-number">200</span>]</span>)
&lt;<span class="hljs-title">class</span> '<span class="hljs-title">numpy</span>.<span class="hljs-title">ndarray</span>'&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass wir bis zum Eingang eines Teils des Objekts nicht zur Verfügung stehen </font></font><code>numpy.ndarray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eine Entität </font></font><code>zarr.core.array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besteht nur aus Metadaten. </font><font style="vertical-align: inherit;">Es werden nur Daten von der Festplatte geladen, die im Slice enthalten sind.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum habe ich Zarr gewählt?</font></font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr umgeht die </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oben diskutierten </font><font style="vertical-align: inherit;">Einschränkungen </font><font style="vertical-align: inherit;">:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenfragmente können auf der Festplatte, im AWS S3-Speicher oder in einem Speichersystem gespeichert werden, das die Möglichkeit bietet, mit Datensätzen im Schlüssel- / Wertformat zu arbeiten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Größe und Struktur des Datenfragments wird vom Programmierer bestimmt. </font><font style="vertical-align: inherit;">Beispielsweise können Daten so organisiert werden, dass Informationen, die sich auf verschiedenen Achsen eines mehrdimensionalen Arrays befinden, effektiv gelesen werden können. </font><font style="vertical-align: inherit;">Dies gilt für HDF5.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmente können komprimiert werden. </font><font style="vertical-align: inherit;">Gleiches gilt für HDF5.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns näher auf die letzten beiden Punkte eingehen.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmentabmessungen</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir arbeiten mit einem Array von 30.000 x 3.000 Elementen. </font><font style="vertical-align: inherit;">Wenn Sie dieses Array lesen und sich entlang seiner Achse </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und entlang seiner Achse bewegen müssen </font></font><code>Y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, können Sie Fragmente speichern, die die Daten dieses Arrays enthalten, wie unten gezeigt (in der Praxis benötigen Sie höchstwahrscheinlich mehr als 9 Fragmente):</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c3/ef4/df7/8c3ef4df7f8f782bbc28e998913f8e34.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können Daten, die sich sowohl auf der Achse </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als auch auf der Achse </font></font><code>Y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befinden, effizient geladen werden. </font><font style="vertical-align: inherit;">Abhängig davon, welche Art von Daten im Programm benötigt werden, können Sie beispielsweise Fragmente (1, 0), (1, 1), (1, 2) oder Fragmente (0, 1), (1, 1) herunterladen. (2, 1).</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenkompression</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes Fragment kann komprimiert werden. </font><font style="vertical-align: inherit;">Dies bedeutet, dass Daten schneller in das Programm gelangen können, als auf der Festplatte unkomprimierte Informationen gelesen werden können. </font><font style="vertical-align: inherit;">Wenn die Daten dreimal komprimiert werden, bedeutet dies, dass sie dreimal schneller von der Festplatte heruntergeladen werden können als nicht komprimierte Daten, abzüglich der Zeit, die der Prozessor zum Entpacken benötigt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/677/f42/f3f/677f42f3fc5539051f4adeb8f391684a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem die Fragmente heruntergeladen wurden, können sie aus dem Programmspeicher entfernt werden.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung: memmap () oder Zarr?</font></font></font></h2><br><font style="vertical-align: inherit;"></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welches ist </font><font style="vertical-align: inherit;">
besser zu benutzen - </font><font style="vertical-align: inherit;">oder Zarr? </font></font><br>
<br>
<code>Memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In solchen Fällen sieht es interessant aus:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt viele Prozesse, die Teile derselben Datei lesen. </font><font style="vertical-align: inherit;">Diese Prozesse können dank der Anwendung </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">denselben Puffercache gemeinsam nutzen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass nur eine Kopie der Daten gespeichert werden muss, unabhängig davon, wie viele Prozesse ausgeführt werden.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Entwickler hat keine Lust, den Speicher manuell zu verwalten. </font><font style="vertical-align: inherit;">Er plant, sich einfach auf die Funktionen des Betriebssystems zu verlassen, die alle Speicherverwaltungsprobleme automatisch und unsichtbar für den Entwickler lösen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zarr ist besonders in folgenden Situationen nützlich (in einigen von ihnen gilt, wie noch erwähnt wird, auch das HDF5-Format):</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten werden von Remote-Quellen heruntergeladen, nicht vom lokalen Dateisystem.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist sehr wahrscheinlich, dass der Engpass des Systems von der Festplatte gelesen wird. </font><font style="vertical-align: inherit;">Die Datenkomprimierung ermöglicht eine effizientere Nutzung der Hardwarefunktionen. </font><font style="vertical-align: inherit;">Dies gilt auch für HDF5.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie mehrdimensionale Arrays entlang verschiedener Achsen erhalten möchten, hilft Zarr bei der Optimierung solcher Operationen, indem die geeignete Größe und Struktur von Fragmenten ausgewählt wird. </font><font style="vertical-align: inherit;">Dies gilt für HDF5.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich würde zwischen </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr </font><font style="vertical-align: inherit;">wählen </font><font style="vertical-align: inherit;">und zunächst versuchen, Zarr zu verwenden - aufgrund der Flexibilität, die dieses Paket bietet, und des darin enthaltenen Datenspeicherformats. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liebe Leser! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie lösen Sie das Problem der Arbeit mit großen NumPy-Arrays?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de490620/index.html">Wenn ich die Worte "Wiederherstellung des neuronalen Netzwerks" höre, klettere ich, um Backups zu überprüfen</a></li>
<li><a href="../de490622/index.html">Bekämpfung von Speicherlecks in Webanwendungen</a></li>
<li><a href="../de490624/index.html">Funktionsrichtlinien-HTTP-Header- und Webbrowser-Steuerung</a></li>
<li><a href="../de490626/index.html">Eine vollständige Anleitung zu Daten- * HTML-Attributen</a></li>
<li><a href="../de490628/index.html">Was tun, wenn CSS das Parsen von Seiten blockiert?</a></li>
<li><a href="../de490634/index.html">Digitale Veranstaltungen in Moskau vom 2. bis 8. März</a></li>
<li><a href="../de490636/index.html">Digitale Events in St. Petersburg vom 2. bis 8. März</a></li>
<li><a href="../de490640/index.html">Überladen in C ++. Teil III. Überladen neuer / Löschanweisungen</a></li>
<li><a href="../de490642/index.html">Plugin zur Überwachung von K8s-Anwendungen DevOpsProdigy KubeGraf v1.3.0: neue Version und neue Funktionen</a></li>
<li><a href="../de490644/index.html">Einfaches RPM-Repository mit Inotify und Webdav</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>