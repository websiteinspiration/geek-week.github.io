<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏾 🤷🏻 🤛 安全ベビーベッド：CSRF 🎀 😼 🖕🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OWASP Top 10 2017 CSRF攻撃の脆弱性の最後に公開されたリストでは「削除されましたが、忘れられていません」に分類されているという事実にもかかわらず、CSRF攻撃を防御する方法をもう一度思い出すことは不必要ではないと判断しましたOWASPによって提供される同じルール。
 
 CSRF...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>安全ベビーベッド：CSRF</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acribia/blog/476880/"><img src="https://habrastorage.org/webt/n2/kv/kj/n2kvkjqgxl8zvlq8y_sqcreecka.jpeg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OWASP Top 10 2017 CSRF攻撃の脆弱性の最後に公開されたリストでは「削除されましたが、忘れられていません」に分類されているという事実にもかかわらず、CSRF攻撃を防御する方法をもう一度思い出すことは不必要ではないと判断しましたOWASPによって提供される同じルール。</font></font><br>
<a name="habracut"></a><br>
<u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSRFトークンの</font></font></b></u><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 使用</font><u><b><font style="vertical-align: inherit;">トークンの</font></b></u><font style="vertical-align: inherit;">使用（ステートレスメソッドとステートフルメソッドの両方）は、保護の主要で最も一般的な方法です。トークンは、暗号化された堅牢な疑似乱数ジェネレータによって生成された、ユーザーセッションごとに一意である必要があります。 OWASPでは、HMACを使用した暗号化にAES256-GCMおよびSHA256 / 512アルゴリズムを使用することも推奨しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トークンの操作にはいくつかのアプローチがあります：シンクロナイザートークン、暗号化ベースのトークンパターン、HMACベースのトークン</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シンクロナイザートークン</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
シンクロナイザートークンアプローチ（ステートフルメソッド）を使用する場合、それはすべてのリクエストでトークンを送信することを意味し、サーバー側でいくつかの変更を意味します。トークンが有効でない場合、サーバーは要求を拒否します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエストをサーバーに送信するときは、ヘッダーではなくリクエストパラメータにトークンを追加することをお勧めします。</font><font style="vertical-align: inherit;">それでもトークンをリクエストヘッダーに挿入する場合は、サーバーにログオンしていないことを確認してください。</font><font style="vertical-align: inherit;">受信したトークンは</font><i><font style="vertical-align: inherit;">、クライアント側の非表示フィールドに</font></i><font style="vertical-align: inherit;">保存できます</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i><br>
<br>
<pre><code class="java hljs">&lt;form action=<span class="hljs-string">"/post.php"</span> method=<span class="hljs-string">"post"</span>&gt;<font></font>
<font></font>
&lt;input type=<span class="hljs-string">"hidden"</span> name=<span class="hljs-string">"CSRFToken"</span> value=<span class="hljs-string">"l5824xNMAYFesBxing975yR8HPJlHZ"</span>&gt;<font></font>
...<font></font>
&lt;/form&gt;</code></pre><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘッダー：</font></font></i><br>
<br>
<pre><code class="java hljs">POST /page HTTP/<span class="hljs-number">1.1</span><font></font>
Accept: application/json, application/xml, text/json, text/x-json, text/javascript,<font></font>
text/xml<font></font>
User-Agent: Mozilla/<span class="hljs-number">5.0</span> (Windows NT <span class="hljs-number">10.0</span>; Win64; x64) AppleWebKit/<span class="hljs-number">537.36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">74.0</span><span class="hljs-number">.3729</span><span class="hljs-number">.169</span> Safari/<span class="hljs-number">537.36</span><font></font>
Content-Type: application/json<font></font>
Host: example.com<font></font>
X-CSRF-TOKEN: l5824xNMAYFesBxing975yR8HPJlHZ</code></pre><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはクッキーに</font></font></i><br>
<br>
<pre><code class="java hljs">POST /page HTTP/<span class="hljs-number">1.1</span><font></font>
Host: example.com<font></font>
Set-Cookie: CSRFToken=l5824xNMAYFesBxing975yR8HPJlHZ;<font></font>
Content-Type: application/x-www-form-urlencoded</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OWASPでは、トークンをヘッダーに保存することをお勧めします。これは、トークンが開かれたり期限切れになったりしても、ブラウザーが原因で攻撃者がリクエストを偽造できないことを説明しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、提案された方法のセキュリティレベルを高めるために、ランダムなトークンパラメータ名および/または各リクエストのトークンを生成することが提案されています。このアプローチを使用すると、攻撃者が盗んだトークンを使用できる時間が最小限になります。ただし、これはユーザビリティの問題につながる可能性があります。たとえば、「戻る」ボタンをクリックすると、前のページに含まれていた無効なトークンがサーバーに送信される可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GETリクエストを使用してトークンを送信することはお勧めしません。このアプローチでは、ブラウザーの履歴、ログファイル、リファラーヘッダーなどでトークンが明らかになる可能性があるためです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗号化ベースのトークン</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このアプローチは暗号化/復号化を使用してトークンを検証するため、ステートレスであり、サーバー側にトークンを格納する必要がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーは、セッションIDとタイムスタンプ（リプレイ攻撃を防ぐため）で構成されるトークンを生成します。暗号化については、GSM / GSM-SIVブロック暗号化モードでAES256暗号化アルゴリズムを使用することをお勧めします。 ECBモードの使用はお勧めしません。サーバーによって暗号化されたトークンは、「Synchronizer Token」の場合と同じ方法で、非表示フォームフィールドまたは応答ヘッダー/パラメーターでクライアントに返されます。トークンを受信すると、サーバーはそれを復号化する必要があります。その後、セッション識別子を確認し、現在の時刻のタイムスタンプも確認して、設定されたトークンの有効期間を超えていないことを確認します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 セッションIDの検証は成功したが、タイムマップが失敗した場合、リクエストは有効であると見なすことができます。その他の場合はすべて、リクエストを拒否して登録し、そのようなリクエストへの応答方法をさらに理解することをお勧めします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HMACベースのトークン</font></font><br>
</b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 また、トークンの格納も必要ありません。操作の原理は暗号化ベースのトークンと同様ですが、トークンを暗号化する代わりに、HMAC（ハッシュベースのメッセージ認証コード）関数を使用してトークンを生成します（SHA256またはより強力なアルゴリズムを使用することをお勧めします）。この場合、トークンは、ユーザーセッション識別子+タイムスタンプのHMAC関数の結果です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トークンの自動化</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSRF攻撃に対抗する際の主な問題は、開発者がトークンを操作する機能を追加するのを忘れることが多いことです。このような問題を回避するには、このプロセスを自動化する価値があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•formタグを介して、またはajaxを使用するときに、トークンをリクエストに自動的に追加するラッパーを記述します。たとえば、Spring Securityは&lt;form：form&gt;タグが使用されるたびに同様のアプローチを使用し</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。•トラフィックをインターセプトし、すべての脆弱なリソースにトークンを追加するフックを記述します。トークンを必要とする状態変更が実行しているリクエストを分析することは非常に難しいため、すべてのPOST応答にトークンを含めることをお勧めしますが、パフォーマンスのコストを検討する価値があります</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•ページのレンダリング時に自動的にトークンを追加します。このアプローチはCSRFガードで使用されます。トークンは、すべてのhref属性とsrc属性、非表示フィールド、およびすべてのフォームに追加され</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。独自の自動トークン生成システムを作成する前に、フレームワークにCSRF攻撃に対するデフォルトの保護機能があるかどうかを確認することをお勧めします。たとえば、同じDjangoフレームワークはCSRFに対する保護を実装しています。</font></font><br>
 <br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ログインCSRF</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ログインフォームで</font><b><font style="vertical-align: inherit;">CSRF</font></b><font style="vertical-align: inherit;">を使用して、攻撃者は</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
被害者として</font><font style="vertical-align: inherit;">ログインできます</font><font style="vertical-align: inherit;">。このような脆弱性は、PayPalやGoogleなどの大手企業が直面していました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 ログインフォームでCSRFを処理するには、ユーザーが認証される前に作成される事前セッションを作成し、ログインフォームにトークンを含めます。</font></font><br>
 <br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Samesite Cookie</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
SameSite Cookieは、CSRF攻撃に対抗することを目的とするRFC6265bisで説明されている属性です。次のように動作します。保護の方法の1つは、オリジンとリファラーヘッダーをチェックすることです。これにより、リクエストの送信元を理解できますが、このアプローチでは、検証メカニズムの実装が必要です。 SameSite属性を使用して、無関係なリソースからのリクエストによるCookieの送信を制限します。この属性には、Strict、Lax、Noneなど、いくつかの可能な値があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 strict値を使用すると、ブラウザは現在のリソースのドメイン名と一致しないソースからCookieを送信しなくなります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値laxは、HTTPSプロトコルを使用して安全な方法で移行が行われた外部リソースからのCookieをブロックしないことを可能にします。</font><font style="vertical-align: inherit;">Laxは、使いやすさとセキュリティのバランスをとっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
属性の設定は非常に簡単です：</font></font><br>
<br>
<pre><code class="java hljs">Set-Cookie: JSESSIONID=xxxxx; SameSite=Strict<font></font>
Set-Cookie: JSESSIONID=xxxxx; SameSite=Lax</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
執筆時点では、ブラウザによる属性のサポートは次のよう</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yv/ku/ck/yvkuckcnwzycekgofxa9t0kuoy4.png" alt="画像"><br>
 <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
になっています。この属性は、CSRFトークンを使用せずに行う方法ではなく、保護の追加手段として使用する必要があることを覚えておくことが重要です。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘッダーの確認</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
上記のように、保護方法の1つは、リクエストヘッダーのリファラーとオリジンの値を確認することです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 このチェックの本質は、サーバー側のヘッダーの値をチェックすることです。それらがリソースと一致する場合、要求は正しいと見なされ、そうでない場合は拒否されます。 Originヘッダーがない場合は、Referrerの値が現在のリソースと一致していることを確認する必要があります。 OWASPは、OriginまたはReferrerヘッダーを含まない要求を拒否することをお勧めします。また、そのような要求をすべてログに記録して、それらを分析し、それらの処理方法を決定することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、アプリケーションがプロキシサーバーの背後にある場合は、ヘッダーのURLが異なるため、状況は複雑になります。この場合、いくつかのオプションがあります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•リクエストの発信元が常にわかるようにアプリケーションを構成します。このアプローチの問題は、アプリケーションが複数の環境（たとえば、開発、QA、本番環境）にデプロイされている場合に正しい値を設定することであり、サポートの問題につながり</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。•Hostヘッダーを使用します。このヘッダーにより、環境に関係なくリクエストのソースを特定できるようになります</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。•X-Forwarded-Hostヘッダーを使用</font><font style="vertical-align: inherit;">します</font><font style="vertical-align: inherit;">。この目的は、プロキシサーバーが受信した元のヘッダーを保存することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明されて</font><font style="vertical-align: inherit;">いる</font><font style="vertical-align: inherit;">すべてのメソッドは、オリジンヘッダーとリファラーヘッダーが存在する場合にのみ機能します。ただし、これらのヘッダーが欠落している場合があります。これらのヘッダーがリクエストに含まれていないいくつかのケースを次に示します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•IE 11には、信頼済みサイトのOriginヘッダーは含まれていません。リファラーヘッダーのみに依存するまま</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
です。リダイレクトの場合、Originはリクエストに含まれません。これは、別のソースに送信してはならない機密情報が含まれている可能性がある</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ためです。 / DELETE / PUTリクエスト</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、少量のトラフィックは上記のカテゴリに分類されますが、多くの場合、ユーザーのこの小さな部分でさえも失いたくないので、オリジン/リファラーのnull値または信頼されたドメインのリストに対応する値でリクエストすることは有効であると見なされます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cookieの二重送信</font></font><br>
</b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 このアプローチは実装が非常に簡単で、サーバー側（ステートレス）にトークンを格納する必要はありません。</font><font style="vertical-align: inherit;">このメソッドの本質は、ユーザーがリクエストパラメータとCookieでトークンを送信することです。</font><font style="vertical-align: inherit;">状態の変更が必要なリクエストごとに、Cookieおよびリクエスト内のトークンの値を確認します。</font><font style="vertical-align: inherit;">セッションIDの検証は成功したが、タイムマップは成功しなかった場合、リクエストは有効と見なされる可能性があります。</font></font><br>
<cut></cut></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja476870/index.html">数学者は「ひまわりの問題」を飼いならし始める</a></li>
<li><a href="../ja476872/index.html">テストとプロジェクトの経済性</a></li>
<li><a href="../ja476874/index.html">「今日、ICSはエアギャップも独自のプロトコルも保護しません」-ウラジミールカランタエフへのインタビュー</a></li>
<li><a href="../ja476876/index.html">将来のアプリケーションのアイデアをテストします。プレタイプ。または多くのお金を節約する方法</a></li>
<li><a href="../ja476878/index.html">GP LED電球</a></li>
<li><a href="../ja476888/index.html">2020年に続くUXデザインのトレンド</a></li>
<li><a href="../ja476890/index.html">Houdiniで働く人々のために。Nature of VexおよびBites of Pythonコースについて</a></li>
<li><a href="../ja476900/index.html">Arduinoの自律デバイスは、温度の上昇（低下）を通知します</a></li>
<li><a href="../ja476902/index.html">バリモア、ボクシムプラントの話題は何ですか？実装されたWebソケット、サー</a></li>
<li><a href="../ja476904/index.html">別のモックライブラリ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>