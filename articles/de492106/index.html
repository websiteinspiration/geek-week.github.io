<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🔧 👇🏻 🔵 Typoskript: fehlerhaftes Verhalten oder Ablässe der Zuverlässigkeit ☦️ ⛑️ 👈🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Ziel ist es zu zeigen, wo TS die Illusion von Sicherheit vermittelt, sodass Sie Fehler erhalten können, während das Programm ausgeführt wird. 
 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Typoskript: fehlerhaftes Verhalten oder Ablässe der Zuverlässigkeit</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492106/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ziel ist es zu zeigen, wo TS die Illusion von Sicherheit vermittelt, sodass Sie Fehler erhalten können, während das Programm ausgeführt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden nicht über Bugs sprechen, in TS gibt es genug </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.500 offene Bugs und 6.000 geschlossene ('is: issue is: open label: Bug'). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Beispiele werden betrachtet mit:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strikte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TS- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Modus ist</font></a><font style="vertical-align: inherit;"> aktiviert (schrieb einen Artikel, während er verstand)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne explizites "any": "as any", "Objects", "Function", {[key: string]: unknown}</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne implizites "any": (noImplicitAny): untypisierte Importe (reine JS-Dateien), falsche Typinferenz</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne falsche Vermutungen über Typen: Antwort vom Server, Eingabe von Bibliotheken von Drittanbietern</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Inhalt: </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nominaltypen, benutzerdefinierte Typen - wenn die Dinge gleich, aber so unterschiedlich erscheinen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typvarianz, genaue Typen - über die Beziehung zwischen Typen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verfeinerung ungültig machen - über Vertrauen sprechen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmen - lohnt es sich zuzugeben, wenn man durcheinander ist?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsichere Operationen - Vertrauen ist nicht immer gut</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonusfälle - Typprüfung in der PR-Überprüfungsphase</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></li>
</ul><a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ist es schwierig, eine Funktion zum Hinzufügen von zwei Zahlen in JS zu schreiben? </font><font style="vertical-align: inherit;">Nehmen Sie eine naive Implementierung</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>{
	<span class="hljs-keyword">return</span> a + b;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns unsere Implementierung von `sum (2, 2) === 4` überprüfen. Scheint alles zu funktionieren? </font><font style="vertical-align: inherit;">Nicht wirklich, wenn wir eine Funktion beschreiben, sollten wir über alle Arten von Eingabewerten nachdenken sowie darüber, was die Funktion zurückgeben kann</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-number">1.1</span> + <span class="hljs-number">2.7</span>   <span class="hljs-comment">// 3.8000000000000003</span>
<span class="hljs-literal">NaN</span> + <span class="hljs-number">2</span>     <span class="hljs-comment">// NaN</span>
<span class="hljs-number">99999999999999992</span> + <span class="hljs-number">99999999999999992</span> <span class="hljs-comment">// 200000000000000000</span>
<span class="hljs-number">2n</span> + <span class="hljs-number">2</span>      <span class="hljs-comment">// Uncaught TypeError: </span>
            <span class="hljs-comment">// Cannot mix BigInt and other types, use explicit conversions.</span>
{} + <span class="hljs-literal">true</span>   <span class="hljs-comment">// 1</span>
<span class="hljs-number">2</span> + <span class="hljs-string">'2'</span>     <span class="hljs-comment">// '22'</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solidität ist die Fähigkeit des Analysators, zu beweisen, dass während der Ausführung des Programms keine Fehler vorliegen. Wenn das Programm vom Analysegerät akzeptiert wurde, ist es garantiert sicher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sicheres Programm ist ein Programm, das für immer ohne Fehler arbeiten kann. Jene. Das Programm wird nicht abstürzen oder Fehler auslösen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Richtiges Programm - ein Programm, das tut, was es sollte und nicht tut, was es nicht sollte. Die Richtigkeit hängt von der Ausführung der Geschäftslogik ab. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typen können beweisen, dass das Programm als Ganzes sicher ist, und Tests, dass das Programm nur innerhalb der Testdaten sicher und korrekt ist (100% Abdeckung, das Fehlen von „Mutanten“ von Stryker, Bestehen eines eigenschaftsbasierten Tests usw. können nichts beweisen, und Lizenzen reduziert Risiken). Es gibt Legenden, nach denen Theorembeweiser die Richtigkeit des Programms beweisen können.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wichtig, die TS-Philosophie zu verstehen, zu verstehen, was das Tool zu lösen versucht und was wichtig ist, was es nicht zu lösen versucht. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Hinweis zu Soundness</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
TS überspringt einige Vorgänge, die bei der Kompilierung nicht sicher sind. </font><font style="vertical-align: inherit;">Orte mit schlechtem Verhalten wurden sorgfältig durchdacht. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entwurfsziele</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nicht das Ziel für TS - Um ein Typensystem mit einer Sicherheitsgarantie zu erstellen, konzentrieren Sie sich stattdessen auf das Gleichgewicht zwischen Sicherheit und Produktivität. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispielstruktur: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem ist kein sicheres Verhalten. Die Liste ist möglicherweise nicht vollständig. Dies habe ich in Artikeln, Berichten und TS Git Probleme. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Vorschlag ist eine TS-Ausgabe, die vor drei bis vier Jahren geöffnet wurde und eine Reihe von Kommentaren und interessanten Erklärungen der Autoren enthält. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tipp - IMHO des Autors, was der Autor als bewährte Verfahren ansieht</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturelle vs nominelle Typisierung</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturelle vs. nominelle Typisierung 1. Problem</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturelle Typisierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Beim Vergleich von Typen werden deren Namen oder Deklarationsorte nicht berücksichtigt, und Typen werden gemäß der "Struktur" verglichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir möchten den Brief "sendEmail" an die richtige Adresse "ValidatedEmail" senden. Es gibt eine Funktion zum Überprüfen der Adresse "validateEmail", die die richtige Adresse "ValidatedEmail" zurückgibt. </font><font style="vertical-align: inherit;">Leider können Sie mit TS eine beliebige Zeichenfolge an "sendEmail" senden, da </font><font style="vertical-align: inherit;">`ValidatedEmail` für TS unterscheidet sich nicht von` string`</font></font><br>
<br>
<pre><code class="javascript hljs">type ValidatedEmail = string;<font></font>
declare <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateEmail</span>(<span class="hljs-params">email: string</span>): <span class="hljs-title">ValidatedEmail</span>;

<span class="hljs-title">declare</span> <span class="hljs-title">function</span> <span class="hljs-title">sendEmail</span>(<span class="hljs-params">mail: ValidatedEmail</span>): <span class="hljs-title">void</span>;
<span class="hljs-title">sendEmail</span>(<span class="hljs-params">validateEmail(<span class="hljs-string">"asdf@gmail.com"</span></span>));

// <span class="hljs-title">Should</span> <span class="hljs-title">be</span> <span class="hljs-title">error</span>!
<span class="hljs-title">sendEmail</span>(<span class="hljs-params"><span class="hljs-string">"asdf@gmail.com"</span></span>);</span></code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturelle vs nominelle Typisierung 1. Angebot</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/microsoft/TypeScript/issues/202</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Geben Sie das Schlüsselwort "nominal" ein, damit die Typen "Nominal" aktiviert werden. </font><font style="vertical-align: inherit;">Jetzt können wir verbieten, nur "string" zu übergeben, wo "ValidatedEmail" erwartet wird</font></font><br>
<br>
<pre><code class="javascript hljs">nominal type ValidatedEmail = string;<font></font>
declare <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateEmail</span>(<span class="hljs-params">email: string</span>): <span class="hljs-title">ValidatedEmail</span>;

<span class="hljs-title">declare</span> <span class="hljs-title">function</span> <span class="hljs-title">sendEmail</span>(<span class="hljs-params">mail: ValidatedEmail</span>): <span class="hljs-title">void</span>;
<span class="hljs-title">sendEmail</span>(<span class="hljs-params">validateEmail(<span class="hljs-string">'asdf@gmail.com'</span></span>));

// <span class="hljs-title">Error</span>!
<span class="hljs-title">sendEmail</span>(<span class="hljs-params"><span class="hljs-string">'asdf@gmail.com'</span></span>);</span></code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturelle oder nominelle Eingabe 1. Tipp</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können einen "undurchsichtigen" Typ erstellen, der etwas "T" nimmt und ihm Einzigartigkeit verleiht, indem wir ihn mit einem Typ kombinieren, der aus dem übergebenen "K" erstellt wurde. </font><font style="vertical-align: inherit;">`K` kann entweder ein eindeutiges Symbol (` eindeutiges Symbol`) oder eine Zeichenfolge sein (dann muss sichergestellt werden, dass diese Zeichenfolgen eindeutig sind).</font></font><br>
<br>
<pre><code class="javascript hljs">type Opaque&lt;K extends symbol | string, T&gt; <font></font>
	= T &amp; { [X <span class="hljs-keyword">in</span> K]: never };<font></font>
<font></font>
declare <span class="hljs-keyword">const</span> validatedEmailK: unique symbol;<font></font>
type ValidatedEmail = Opaque&lt;<span class="hljs-keyword">typeof</span> validatedEmailK, string&gt;;
<span class="hljs-comment">// type ValidatedEmail = Opaque&lt;'ValidatedEmail', string&gt;;</span><font></font>
<font></font>
declare <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateEmail</span>(<span class="hljs-params">email: string</span>): <span class="hljs-title">ValidatedEmail</span>;

<span class="hljs-title">declare</span> <span class="hljs-title">function</span> <span class="hljs-title">sendEmail</span>(<span class="hljs-params">mail: ValidatedEmail</span>): <span class="hljs-title">void</span>;
<span class="hljs-title">sendEmail</span>(<span class="hljs-params">validateEmail(<span class="hljs-string">'asdf@gmail.com'</span></span>));

// <span class="hljs-title">Argument</span> <span class="hljs-title">of</span> <span class="hljs-title">type</span> '"<span class="hljs-title">asdf</span>@<span class="hljs-title">gmail</span>.<span class="hljs-title">com</span>"' <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">assignable</span>
//  <span class="hljs-title">to</span> <span class="hljs-title">parameter</span> <span class="hljs-title">of</span> <span class="hljs-title">type</span> '<span class="hljs-title">Opaque</span>&lt;<span class="hljs-title">unique</span> <span class="hljs-title">symbol</span>, <span class="hljs-title">string</span>&gt;'.
<span class="hljs-title">sendEmail</span>(<span class="hljs-params"><span class="hljs-string">'asdf@gmail.com'</span></span>);</span></code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturelle vs. nominelle Typisierung 2. Problem</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eine Dollar- und eine Euro-Klasse. Jede der Klassen hat eine Additionsmethode zum Addieren des Dollars zum Dollar und des Euro zum Euro. </font><font style="vertical-align: inherit;">Für TS sind diese Klassen strukturell gleich und wir können den Dollar zum Euro hinzufügen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dollar</span> </span>{
  <span class="hljs-attr">value</span>: number;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(value: number) {
    <span class="hljs-keyword">this</span>.value = value;<font></font>
  }<font></font>
<font></font>
  add(dollar: Dollar): Dollar {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dollar(dollar.value + <span class="hljs-keyword">this</span>.value);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Euro</span> </span>{
  <span class="hljs-attr">value</span>: number;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(value: number) {
    <span class="hljs-keyword">this</span>.value = value;<font></font>
  }<font></font>
<font></font>
  add(euro: Euro): Euro {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Euro(euro.value + <span class="hljs-keyword">this</span>.value);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> dollars100 = <span class="hljs-keyword">new</span> Dollar(<span class="hljs-number">100</span>);
<span class="hljs-keyword">const</span> euro100 = <span class="hljs-keyword">new</span> Euro(<span class="hljs-number">100</span>);<font></font>
<font></font>
<span class="hljs-comment">// Correct</span><font></font>
dollars100.add(dollars100);<font></font>
euro100.add(euro100);<font></font>
<font></font>
<span class="hljs-comment">// Should be error!</span>
dollars100.add(euro100);</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturelle vs nominelle Typisierung 2. Angebot</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/microsoft/TypeScript/issues/202</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Der Satz ist alle gleich, mit "nominal", aber seitdem </font><font style="vertical-align: inherit;">Da Klassen auf magische Weise nominal werden können (dazu später mehr), werden die Möglichkeiten einer expliziteren Transformation in Betracht gezogen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturelle oder nominelle Eingabe 1. Tipp</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Klasse ein privates Feld hat (nativ mit "#" oder von TS c "privat"), wird die Klasse auf magische Weise zu "Nominal". Der Name und der Wert können beliebig sein. </font><font style="vertical-align: inherit;">Das `!` (Definite Assignment Assertion) wird verwendet, um zu verhindern, dass TS auf ein nicht initialisiertes Feld schwört (strictNullChecks, strictPropertyInitialization-Flags sind aktiviert).</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dollar</span> </span>{
  <span class="hljs-comment">// #desc!: never;</span><font></font>
  private desc!: never;<font></font>
  value: number;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(value: number) {
    <span class="hljs-keyword">this</span>.value = value;<font></font>
  }<font></font>
<font></font>
  add(dollar: Dollar) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dollar(dollar.value + <span class="hljs-keyword">this</span>.value);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Euro</span> </span>{
  <span class="hljs-comment">// #desc!: never;</span><font></font>
  private desc!: never;<font></font>
  value: number;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(value: number) {
    <span class="hljs-keyword">this</span>.value = value;<font></font>
  }<font></font>
<font></font>
  add(euro: Euro) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Euro(euro.value + <span class="hljs-keyword">this</span>.value);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> dollars100 = <span class="hljs-keyword">new</span> Dollar(<span class="hljs-number">100</span>);
<span class="hljs-keyword">const</span> euro100 = <span class="hljs-keyword">new</span> Euro(<span class="hljs-number">100</span>);<font></font>
<font></font>
<span class="hljs-comment">// Correct</span><font></font>
dollars100.add(dollars100);<font></font>
euro100.add(euro100);<font></font>
<font></font>
<span class="hljs-comment">// Error: Argument of type 'Euro' is not assignable to parameter of type 'Dollar</span><font></font>
dollars100.add(euro100);<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typvarianz 1. Problem</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz gesagt, eine Programmieroption ist die Möglichkeit, Supertype / Subtype dort zu übergeben, wo Type erwartet wird. </font><font style="vertical-align: inherit;">Zum Beispiel gibt es eine Hierarchie Form -&gt; Kreis -&gt; Rechteck. Ist es möglich, eine Form / ein Rechteck zu übertragen oder zurückzugeben, wenn Kreis erwartet wird? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Variante in der Programmierung </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SO</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können den Typ mit dem Feld, in dem die Zahl liegt, an eine Funktion übergeben, die das Feld als Zeichenfolge oder Zahl erwartet, und das übertragene Objekt im Körper mutieren und das Feld in eine Zeichenfolge ändern. </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">`{status: number} als {status: number | </font><font style="vertical-align: inherit;">string} as {status: string} `Hier ist ein Trick wie das Verwandeln einer Zahl in einen String, der einen </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überraschungsfehler</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verursacht.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeStatus</span>(<span class="hljs-params">arg: { status: number | string }</span>) </span>{<font></font>
  arg.status = <span class="hljs-string">"NotFound"</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> error: { <span class="hljs-attr">status</span>: number } = { <span class="hljs-attr">status</span>: <span class="hljs-number">404</span> };<font></font>
changeStatus(error);<font></font>
<font></font>
<span class="hljs-comment">// Error: toFixed is not a function</span>
<span class="hljs-built_in">console</span>.log(error.status.toFixed());</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typabweichung 1. Angebot</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/Microsoft/TypeScript/issues/10717</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Es wird vorgeschlagen, "in / out" einzuführen, um die Kovarianz / Kontravarianz für Generika explizit zu begrenzen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeStatus</span>&lt;
  <span class="hljs-title">out</span> <span class="hljs-title">T</span> <span class="hljs-title">extends</span> </span>{
    <span class="hljs-attr">status</span>: number | string;<font></font>
  }<font></font>
&gt;(arg: T) {<font></font>
  arg.status = <span class="hljs-string">"NotFound"</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> error: { <span class="hljs-attr">status</span>: number } = { <span class="hljs-attr">status</span>: <span class="hljs-number">404</span> };
<span class="hljs-comment">// Error!</span><font></font>
changeStatus(error);<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(error.status.toFixed());</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typvarianz 1. Tipp</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir mit unveränderlichen Strukturen arbeiten, tritt kein solcher Fehler auf (wir haben das Flag strictFunctionTypes bereits aktiviert).</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeStatus</span>(<span class="hljs-params">arg: Readonly&lt;{ status: number | string }&gt;</span>) </span>{
  <span class="hljs-comment">// Error: Cannot assign, status is not writable</span>
  arg.status = <span class="hljs-string">"NotFound"</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> error: Readonly&lt;{ <span class="hljs-attr">status</span>: number }&gt; = { <span class="hljs-attr">status</span>: <span class="hljs-number">404</span> };<font></font>
changeStatus(error);<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(error.status.toFixed());</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typvarianz 1. Bonus</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Readonly kann dem veränderlichen </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/Microsoft/TypeScript/issues/13347 </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/microsoft/TypeScript/pull/6532#issuecomment-174356151</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
zugewiesen werden. Selbst wenn wir den Readonly-Typ erstellt haben, wird TS nicht verbieten, an die Funktion zu übergeben, bei der nicht erwartet Readonly `Readonly &lt;{readonly status: number}&gt; als {status: number | </font><font style="vertical-align: inherit;">Zeichenfolge} als {Status: Zeichenfolge} `</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeStatus</span>(<span class="hljs-params">arg: { status: number | string }</span>) </span>{<font></font>
  arg.status = <span class="hljs-string">"NotFound"</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> error: Readonly&lt;{ readonly status: number }&gt; <font></font>
  = { <span class="hljs-attr">status</span>: <span class="hljs-number">404</span> };<font></font>
changeStatus(error);<font></font>
<font></font>
<span class="hljs-comment">// Error: toFixed is not a function</span>
<span class="hljs-built_in">console</span>.log(error.status.toFixed());</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typvarianz 2. Problem</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objekte können zusätzliche Felder enthalten, die die ihnen entsprechenden Typen nicht haben: `{message: string; </font><font style="vertical-align: inherit;">status: string} as {message: string} `. </font><font style="vertical-align: inherit;">Aufgrund dessen sind einige Operationen möglicherweise nicht sicher</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> error: { <span class="hljs-attr">message</span>: string; status: string } = {
  <span class="hljs-attr">message</span>: <span class="hljs-string">"No data"</span>,
  <span class="hljs-attr">status</span>: <span class="hljs-string">"NotFound"</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateError</span>(<span class="hljs-params">arg: { message: string }</span>) </span>{
  <span class="hljs-keyword">const</span> defaultError = { <span class="hljs-attr">message</span>: <span class="hljs-string">"Not found"</span>, <span class="hljs-attr">status</span>: <span class="hljs-number">404</span> };
  <span class="hljs-keyword">const</span> newError: { <span class="hljs-attr">message</span>: string; status: number }<font></font>
    = { ...defaultError, ...arg };<font></font>
  <font></font>
  <span class="hljs-comment">// Error: toFixed is not a function</span>
  <span class="hljs-built_in">console</span>.log(newError.status.toFixed());<font></font>
}<font></font>
<font></font>
updateError(error);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TS dachte, dass als Ergebnis der Zusammenführung der Status "{... {Nachricht: Zeichenfolge, Status: Nummer}, ... {Nachricht: Zeichenfolge}}" eine Zahl sein wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Wirklichkeit `{... {Nachricht:" Nicht gefunden ", Status: 404}, ... {Nachricht:" Keine Daten ", Status:" NotFound "},}` Status - Zeichenfolge.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typabweichung 2. Angebot</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/microsoft/TypeScript/issues/12936</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Einführung eines "Exact" -Typs oder einer ähnlichen Syntax, um zu sagen, dass ein Typ keine zusätzlichen Felder enthalten kann.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> error: Exact&lt;{ <span class="hljs-attr">message</span>: string; }&gt; = {
  <span class="hljs-attr">message</span>: <span class="hljs-string">"No data"</span>,<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateError</span>(<span class="hljs-params">arg: Exact&lt;{ message: string }&gt;</span>) </span>{
  <span class="hljs-keyword">const</span> defaultError = {  <span class="hljs-attr">message</span>: <span class="hljs-string">"Not found"</span>, <span class="hljs-attr">status</span>: <span class="hljs-number">404</span>, };
  <span class="hljs-comment">// Can spread only Exact type!</span>
  <span class="hljs-keyword">const</span> newError = { ...defaultError, ...arg };
  <span class="hljs-built_in">console</span>.log(newError.status.toFixed());<font></font>
}<font></font>
<font></font>
updateError(error);</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typvarianz 2. Tipp</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Führen Sie Objekte zusammen, indem Sie Felder explizit auflisten oder unbekannte Felder herausfiltern.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> error: { <span class="hljs-attr">message</span>: string; status: string } = {
  <span class="hljs-attr">message</span>: <span class="hljs-string">"No data"</span>,
  <span class="hljs-attr">status</span>: <span class="hljs-string">"NotFound"</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateError</span>(<span class="hljs-params">arg: { message: string }</span>) </span>{
  <span class="hljs-keyword">const</span> defaultError = { <span class="hljs-attr">message</span>: <span class="hljs-string">"Not found"</span>, <span class="hljs-attr">status</span>: <span class="hljs-number">404</span> };
  <span class="hljs-comment">// Merge explicitly or filter unknown fields</span>
  <span class="hljs-keyword">const</span> newError = { ...defaultError, <span class="hljs-attr">message</span>: arg.message };
  <span class="hljs-built_in">console</span>.log(newError.status.toFixed());<font></font>
}<font></font>
<font></font>
updateError(error);</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ungültigmachung der Verfeinerung. </font><font style="vertical-align: inherit;">Problem</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir etwas über den externen Zustand bewiesen haben, ist das Aufrufen von Funktionen nicht sicher, weil </font><font style="vertical-align: inherit;">Es gibt keine Garantie dafür, dass Funktionen diesen externen Zustand nicht ändern:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logAge</span>(<span class="hljs-params">name: string, age: number</span>) </span>{
  <span class="hljs-comment">// 2nd call -  Error: toFixed is not a function</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${name}</span> will lose <span class="hljs-subst">${age.toFixed()}</span>`</span>);<font></font>
  person.age = <span class="hljs-string">"PLACEHOLDER"</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> person: { <span class="hljs-attr">name</span>: string; age: number | string } = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Person"</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">42</span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> person.age === <span class="hljs-string">"number"</span>) {<font></font>
  logAge(person.name, person.age);<font></font>
  <span class="hljs-comment">// refinement should be invalidated</span><font></font>
  logAge(person.name, person.age);<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ungültigmachung der Verfeinerung. </font><font style="vertical-align: inherit;">Satz</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/microsoft/TypeScript/issues/7770#issuecomment-334919251</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Fügen Sie den Modifikator "pure" für Funktionen hinzu, damit Sie diesen Funktionen zumindest vertrauen können</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ungültigmachung der Verfeinerung. </font><font style="vertical-align: inherit;">Trinkgeld</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie unveränderliche Datenstrukturen, dann ist der Funktionsaufruf a priori sicher für frühere Überprüfungen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonus</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Flusstyp ist so stark, dass er nicht alle oben aufgeführten Probleme aufweist, aber so ausgeführt wird, dass ich die Verwendung nicht empfehlen würde.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmen. </font><font style="vertical-align: inherit;">Problem</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TS hilft in keiner Weise, mit Ausnahmen zu arbeiten, da auf der Funktionssignatur nichts klar ist.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { JokeError } <span class="hljs-keyword">from</span> <span class="hljs-string">"../helpers"</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getJoke</span>(<span class="hljs-params">isFunny: boolean</span>): <span class="hljs-title">string</span> </span>{
  <span class="hljs-keyword">if</span> (isFunny) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> JokeError(<span class="hljs-string">"No funny joke"</span>);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Duh"</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> joke: string = getJoke(<span class="hljs-literal">true</span>);
<span class="hljs-built_in">console</span>.log(joke);
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmen. </font><font style="vertical-align: inherit;">Satz</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/microsoft/TypeScript/issues/13219</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Es wird vorgeschlagen, eine Syntax einzuführen, mit der Ausnahmen in einer Funktionssignatur explizit beschrieben werden können</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { JokeError } <span class="hljs-keyword">from</span> <span class="hljs-string">'../helpers'</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getJoke</span>(<span class="hljs-params">isFunny: boolean</span>): <span class="hljs-title">string</span> | <span class="hljs-title">throws</span> <span class="hljs-title">JokeError</span> </span>{
  <span class="hljs-comment">/*...*/</span>}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getJokeSafe</span>(<span class="hljs-params">isFunny: boolean</span>): <span class="hljs-title">string</span> </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> getJoke(isFunny);<font></font>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> JokeError) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<font></font>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Should infer error correctly, should cast to never</span>
      <span class="hljs-keyword">return</span> error <span class="hljs-keyword">as</span> never;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(getJokeSafe(<span class="hljs-literal">true</span>));</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmen. </font><font style="vertical-align: inherit;">Bonus</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/microsoft/TypeScript/issues/6283</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Aus irgendeinem Grund ignoriert die Typdefinition für Promise in TS die Art des Fehlers</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> promise1: <span class="hljs-built_in">Promise</span>&lt;number&gt; = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">42</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> promise: <span class="hljs-built_in">Promise</span>&lt;never&gt; = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>());<font></font>
<font></font>
<span class="hljs-comment">// typescript/lib</span><font></font>
interface PromiseConstructor {<font></font>
  <span class="hljs-keyword">new</span> &lt;T&gt;(<font></font>
    executor: (<font></font>
      resolve: <span class="hljs-function">(<span class="hljs-params">value?: T | PromiseLike&lt;T&gt;</span>) =&gt;</span> <span class="hljs-keyword">void</span>,
      <span class="hljs-attr">reject</span>: <span class="hljs-function">(<span class="hljs-params">reason?: any</span>) =&gt;</span> <span class="hljs-keyword">void</span>
    ) =&gt; <span class="hljs-keyword">void</span>
  ): <span class="hljs-built_in">Promise</span>&lt;T&gt;;<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmen. </font><font style="vertical-align: inherit;">Trinkgeld</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen Sie einen der beiden Container wie Promise mit nur der besten Eingabe. </font><font style="vertical-align: inherit;">( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entweder Implementierungsbeispiel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { Either, exhaustiveCheck, JokeError } <span class="hljs-keyword">from</span> <span class="hljs-string">"../helpers"</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getJoke</span>(<span class="hljs-params">isFunny: boolean</span>): <span class="hljs-title">Either</span>&lt;<span class="hljs-title">JokeError</span>, <span class="hljs-title">string</span>&gt; </span>{
  <span class="hljs-keyword">if</span> (isFunny) {
    <span class="hljs-keyword">return</span> Either.left(<span class="hljs-keyword">new</span> JokeError(<span class="hljs-string">"No funny joke"</span>));<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> Either.right(<span class="hljs-string">"Duh"</span>);<font></font>
}<font></font>
<font></font>
getJoke(<span class="hljs-literal">true</span>)
  <span class="hljs-comment">// (parameter) error: JokeError</span>
  .mapLeft(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> JokeError) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"JokeError"</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      exhaustiveCheck(error);<font></font>
    }<font></font>
  })<font></font>
  <span class="hljs-comment">// (parameter) joke: string</span>
  .mapRight(<span class="hljs-function"><span class="hljs-params">joke</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(joke));
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsichere Operationen. </font><font style="vertical-align: inherit;">Problem</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir ein Tupel fester Größe haben, kann TS garantieren, dass der angeforderte Index etwas enthält. </font><font style="vertical-align: inherit;">Dies funktioniert nicht für das Array und TS wird uns vertrauen</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ReadOnly fixed size tuple</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> constNumbers: readonly [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <font></font>
  = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<font></font>
<font></font>
<span class="hljs-comment">// Error: Object is possibly 'undefined'.</span>
<span class="hljs-built_in">console</span>.log(constNumbers[<span class="hljs-number">100</span>].toFixed());<font></font>
<font></font>
<span class="hljs-keyword">const</span> dynamicNumbers: number[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-built_in">console</span>.log(dynamicNumbers[<span class="hljs-number">100</span>].toFixed());
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsichere Operationen. </font><font style="vertical-align: inherit;">Satz</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/microsoft/TypeScript/issues/13778</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Es wird vorgeschlagen, dem Rückgabetyp "T" für den Indexzugriff auf das Array "undefined" hinzuzufügen. </font><font style="vertical-align: inherit;">In diesem Fall müssen Sie jedoch beim Zugriff auf einen beliebigen Index `?` Verwenden oder explizite Überprüfungen durchführen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// interface Array&lt;T&gt; {</span>
<span class="hljs-comment">//   [n: number]: T | undefined;</span>
<span class="hljs-comment">// }</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> dynamicNumbers: number[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-comment">// Error: Object is possibly 'undefined'.</span>
<span class="hljs-built_in">console</span>.log(dynamicNumbers[<span class="hljs-number">100</span>].toFixed());<font></font>
<font></font>
<span class="hljs-comment">// Optional chaining `?`</span>
<span class="hljs-built_in">console</span>.log(dynamicNumbers[<span class="hljs-number">100</span>]?.toFixed());<font></font>
<font></font>
<span class="hljs-comment">// type refinement</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> dynamicNumbers[<span class="hljs-number">100</span>] === <span class="hljs-string">'number'</span>) {
  <span class="hljs-built_in">console</span>.log(dynamicNumbers[<span class="hljs-number">100</span>].toFixed());<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsichere Operationen. </font><font style="vertical-align: inherit;">Trinkgeld</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um keine Entitäten zu erzeugen, die über den Bedarf hinausgehen, nehmen wir den zuvor bekannten Container "Entweder" und schreiben eine sichere Funktion für die Arbeit mit dem Index, die "Entweder &lt;null, T&gt;" zurückgibt.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { Either } <span class="hljs-keyword">from</span> <span class="hljs-string">"../helpers"</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeIndex</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">
  array: T[],
  index: number,
</span>): <span class="hljs-title">Either</span>&lt;<span class="hljs-title">null</span>, <span class="hljs-title">T</span>&gt; </span>{
  <span class="hljs-keyword">if</span> (index <span class="hljs-keyword">in</span> array) {
    <span class="hljs-keyword">return</span> Either.right(array[index]);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> Either.left(<span class="hljs-literal">null</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> dynamicNumbers: number[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<font></font>
<font></font>
safeIndex(dynamicNumbers, <span class="hljs-number">100</span>)<font></font>
  .mapLeft(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Nothing"</span>))<font></font>
  .mapRight(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el + <span class="hljs-number">2</span>)<font></font>
  .mapRight(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(el.toFixed()));
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonus </font><font style="vertical-align: inherit;">Funktionen zum Nachladen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir sagen wollen, dass eine Funktion ein paar Zeilen benötigt und eine Zeichenfolge zurückgibt oder ein paar Zahlen und eine Zahl zurückgibt, sind diese Signaturen in der Implementierung zusammenhängend, und der Programmierer sollte ihre Richtigkeit garantieren, jedoch auf TS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS betrachten die Alternative durch generische und bedingte Typen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a: string, b: string</span>): <span class="hljs-title">string</span>;
<span class="hljs-title">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a: number, b: number</span>): <span class="hljs-title">number</span>;
<span class="hljs-title">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a: string | number,
             b: string | number,
</span>): <span class="hljs-title">string</span> | <span class="hljs-title">number</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${a}</span> + <span class="hljs-subst">${b}</span>`</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> sum: number = add(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// Error: toFixed is not a function</span>
sum.toFixed();</code></pre><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonus </font><font style="vertical-align: inherit;">Typ Wache</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TS vertraut dem Programmierer, dass "isSuperUser" korrekt bestimmt, wer "SuperUser" ist, und wenn "Vasya" hinzugefügt wird, werden keine Eingabeaufforderungen angezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS ist es wert, darüber nachzudenken, wie wir Typen unterscheiden können, die sich bereits in der Phase ihrer gewerkschaftlich gekennzeichneten Vereinigung befinden</font></font><br>
<br>
<pre><code class="javascript hljs">type SimpleUser = { <span class="hljs-attr">name</span>: string };<font></font>
type SuperUser = { <font></font>
  <span class="hljs-attr">name</span>: string; <font></font>
  isAdmin: <span class="hljs-literal">true</span>; <font></font>
  permissions: string[] <font></font>
};<font></font>
type Vasya = { <span class="hljs-attr">name</span>: string; isAdmin: <span class="hljs-literal">true</span>; isGod: <span class="hljs-literal">true</span> };<font></font>
type User = SimpleUser | SuperUser | Vasya;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSuperUser</span>(<span class="hljs-params">user: User</span>): <span class="hljs-title">user</span> <span class="hljs-title">is</span> <span class="hljs-title">SuperUser</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">"isAdmin"</span> <span class="hljs-keyword">in</span> user &amp;&amp; user.isAdmin;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomethings</span>(<span class="hljs-params">user: User</span>) </span>{
  <span class="hljs-comment">// Error: Cannot read property 'join' of undefined</span>
  <span class="hljs-keyword">if</span> (isSuperUser(user)) {
    <span class="hljs-built_in">console</span>.log(user.permissions.join(<span class="hljs-string">","</span>));<font></font>
  }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlussfolgerungen zu den Tipps</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Nominaltypen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Opaker Typ, private Felder </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Typvarianz: Exakte Typen, DeepReadonly-Typ </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ausnahmen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Entweder Monade </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Verfeinerung ungültig machen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Reine Funktionen </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Unsichere Operationen (</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Indexzugriff </font><b><font style="vertical-align: inherit;">)</font></b><font style="vertical-align: inherit;"> : Entweder / Vielleicht Monaden </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unveränderliche Daten, reine Funktionen, Monaden ... Herzlichen Glückwunsch haben wir bewiesen, dass FP cool ist!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TS möchte ein Gleichgewicht zwischen Korrektheit und Produktivität herstellen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tests können Sicherheit und Richtigkeit nur für Testdaten nachweisen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typen können die Gesamtsicherheit eines Programms belegen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mutation - schlecht, okay?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da DZ empfehlen würde, mit Flow zu spielen, nachdem ein einfacher Fehler korrigiert wurde:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// https://flow.org/try/</span>
declare <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params">arg: { name: string, surname?: string }</span>): <span class="hljs-title">void</span>;
<span class="hljs-title">const</span> <span class="hljs-title">person</span>: </span>{ name: string } =  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Negasi'</span> };
<span class="hljs-comment">// Error</span>
log(person);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispielcode, Lösung und Analyse des Problems, nützliche Links im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de492078/index.html">Die wichtigsten und nützlichsten Materialien zum Coronavirus COVID-19</a></li>
<li><a href="../de492082/index.html">So vereinfachen und verwalten Sie die Verwaltung von Heimgeräten (teilen Sie Ideen zu Kauri Safe Smart Home)</a></li>
<li><a href="../de492086/index.html">Coronavirus gegen russisches IT-Geschäft: Sind Unternehmen bereit, Mitarbeiter an einen entfernten Standort zu verlegen?</a></li>
<li><a href="../de492088/index.html">Testen der Amazon Lumberyard Game Engine. Ansätze und Tools</a></li>
<li><a href="../de492102/index.html">Erstellung eines VK-Chatbots basierend auf VkBotCore C #</a></li>
<li><a href="../de492108/index.html">So kommen Sie ins Silicon Valley: 7 Möglichkeiten für den Start</a></li>
<li><a href="../de492110/index.html">Verwendung eines Cloud-Tokens mit Unterstützung für russische Kryptografie auf der Android-Plattform</a></li>
<li><a href="../de492112/index.html">Alexander Plyushchev über die Politisierung des Internets, die Digitalisierung von Macht und Robotern, die Journalisten ersetzen werden (aber das ist nicht richtig)</a></li>
<li><a href="../de492116/index.html">Der Versuch, mit auffälligen Unterschieden in der Coronavirus-Mortalität in Italien und Südkorea umzugehen</a></li>
<li><a href="../de492118/index.html">5 Mythen über UPS, ihre Widerlegung und die reale Situation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>