<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🏭 🌘 🗄️ データベース設計基準 🥠 ☄️ 👨🏽‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="プロジェクト間を移動すると、残念ながら、SQLは数十年前から存在しているにもかかわらず、データベース設計の統一された標準の欠如に直面しています。その理由の一部は、ほとんどの開発者がデータベースのアーキテクチャを理解していないためだと思います。開発者の採用における長年の仕事の中で、データベースを正しく...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>データベース設計基準</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/484188/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pa/zj/ej/pazjejv8zvpor7tzaggxr54csd4.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクト間を移動すると、残念ながら、SQLは数十年前から存在しているにもかかわらず、データベース設計の統一された標準の欠如に直面しています。その理由の一部は、ほとんどの開発者がデータベースのアーキテクチャを理解していないためだと思います。開発者の採用における長年の仕事の中で、データベースを正しく正規化できる人とは数回会っただけです。正直なところ、これは難しい作業ですが、インタビューした開発者の多くは、SQLに堪能であっても、データベース設計のスキルを持っていませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、DBの正規化についてのものではありません。これを学びたいのであれば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で簡単に基本を説明しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
稼働中のデータベースがある場合、次の質問に答える必要があります。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このデータベースを</font><i><font style="vertical-align: inherit;">使用</font></i><font style="vertical-align: inherit;">しますか？」</font><font style="vertical-align: inherit;">これらの標準が広く使用されている場合、新しいデータベースで作業を開始するたびに新しい標準のセットを調べて覚える必要がないため、データベースを簡単に使用できます。</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CamelCaseの命名またはアンダースコア？</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は常に、テーブルが</font></font><code>CustomerOrders</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font><font style="vertical-align: inherit;">スタイルで名前が付けられているデータベースに遭遇します</font></font><code>customer_orders</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。どちらを使用するのが良いですか？おそらく、すでに確立されている標準を適用したいかもしれませんが、新しいデータベースを作成する場合は、アンダースコアを使用してアクセシビリティを高めることをお勧めします。 「過小評価」という表現は「過小評価」とは意味が異なりますが、下線を付けると、最初は常に</font></font><code>under_value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、2番目は-になり</font></font><code>undervalue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。また、CamelCaseを使用する</font></font><code>Undervalue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>UnderValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、大文字と小文字を区別しないSQLの点で同じ</font><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">を取得</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">ます。あなたが視力の問題があり、絶えず、その後、単語を強調するために、ヘッドセットやピンで実験下線されている場合はさらに、ある</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しやすく</font><font style="vertical-align: inherit;">読み</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、CamelCaseは英語が母国語でない人には読みにくいです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要約すると、これは厳密な推奨ではなく、個人的な好みです。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テーブル名に複数または単数ですか？</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベース理論の専門家は、テーブルを単数（顧客）にするか複数（顧客）にするかについて長い間議論してきました。理論を深く掘り下げることなく、プラグマティズムを使用するだけで、このGordianノットを切り上げましょう。複数のテーブル名は、予約済みキーワードと競合する可能性が低くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーはいます</font></font><code>users</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か？ SQLにはキーワードがあり</font></font><code>user</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。制限付きのテーブルが必要</font></font><code>constraints</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですか？</font></font><code>constraint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予約語です。単語は</font></font><code>audit</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 予約されていますが、テーブルが必要</font></font><code>audit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですか？</font><font style="vertical-align: inherit;">名詞</font><font style="vertical-align: inherit;">の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形を</font><font style="vertical-align: inherit;">使用するだけ</font><font style="vertical-align: inherit;">で、予約語のほとんどがSQLで気になりません。優れたSQLパーサーを備えたPostgreSQLでさえ、テーブルに出くわしました</font></font><code>user</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数形を使用するだけで、競合の可能性ははるかに低くなります。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDの列に「id」という名前を付けないでください</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私自身、何年にもわたって罪を犯してきました。</font><font style="vertical-align: inherit;">かつて私はパリのクライアントと一緒に働いていましたが、識別子のある列に名前を付けたときにDBAから不満がありました</font></font><code>id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私は彼がただの独り言だと思った。</font><font style="vertical-align: inherit;">実際、列の名前</font></font><code>customers.id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は明確ですが</font></font><code>customers.customer_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、情報の繰り返しです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして後で私はこれをデバッグしなければなりませんでした：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> thread.*
  <span class="hljs-keyword">FROM</span> email <span class="hljs-keyword">thread</span>
  <span class="hljs-keyword">JOIN</span> email selected      <span class="hljs-keyword">ON</span> selected.id = thread.id
  <span class="hljs-keyword">JOIN</span> <span class="hljs-built_in">character</span> recipient <span class="hljs-keyword">ON</span> recipient.id = thread.recipient_id
  <span class="hljs-keyword">JOIN</span> station_area sa     <span class="hljs-keyword">ON</span> sa.id = recipient.id
  <span class="hljs-keyword">JOIN</span> station st          <span class="hljs-keyword">ON</span> st.id = sa.id
  <span class="hljs-keyword">JOIN</span> star origin         <span class="hljs-keyword">ON</span> origin.id = thread.id
  <span class="hljs-keyword">JOIN</span> star destination    <span class="hljs-keyword">ON</span> destination.id = st.id
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> route
       <span class="hljs-keyword">ON</span> ( route.from_id = origin.id
            <span class="hljs-keyword">AND</span> <font></font>
            route.to_id = destination.id )<font></font>
 <span class="hljs-keyword">WHERE</span> selected.id                = ?
   <span class="hljs-keyword">AND</span> ( thread.sender_id         = ? 
         <span class="hljs-keyword">OR</span> ( thread.recipient_id = ?
              <span class="hljs-keyword">AND</span> ( origin.id = destination.id
                    <span class="hljs-keyword">OR</span> ( route.distance <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
                         <span class="hljs-keyword">AND</span>
                         <span class="hljs-keyword">now</span>() &gt;= thread.datesent<font></font>
                         + ( route.distance * <span class="hljs-built_in">interval</span> <span class="hljs-string">'30 seconds'</span> )<font></font>
        ))))<font></font>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> datesent <span class="hljs-keyword">ASC</span>, thread.parent_id <span class="hljs-keyword">ASC</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題に気づきましたか？</font><font style="vertical-align: inherit;">SQLのような、完全なID名を使用した場合</font></font><code>email_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>star_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>station_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そのバグはすぐになるだろう</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、私はこのコードを書いたようにして</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、私は私が間違っていたかを理解しようとしたとき、後で、及びません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自分でお願いし、IDにはフルネームを使用してください。</font><font style="vertical-align: inherit;">よろしくお願いします。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列名</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列にはできるだけわかりやすい名前を付けてください。</font><font style="vertical-align: inherit;">列が</font></font><code>temperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これと</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">何の関係もないとし</font><font style="vertical-align: inherit;">ましょう</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span>, <span class="hljs-string">'too cold'</span>
  <span class="hljs-keyword">FROM</span> areas
 <span class="hljs-keyword">WHERE</span> temperature &lt; <span class="hljs-number">32</span>;  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はフランスに住んでいて、私たちにとって32度の気温は「寒すぎる」でしょう。</font><font style="vertical-align: inherit;">したがって、列に名前を付けることをお勧めします</font></font><code>fahrenheit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span>, <span class="hljs-string">'too cold'</span>
  <span class="hljs-keyword">FROM</span> areas
 <span class="hljs-keyword">WHERE</span> fahrenheit &lt; <span class="hljs-number">32</span>;  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これですべてが完全に明確になりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外部キーに制限がある場合は、可能な限り、制限の両側の列に同じ名前を付けてください。</font><font style="vertical-align: inherit;">以下は、完全に考え抜かれた、妥当なSQLです。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> *
  <span class="hljs-keyword">FROM</span> some_table       s
  <span class="hljs-keyword">JOIN</span> some_other_table o
    <span class="hljs-keyword">ON</span> o.owner = s.person_id;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは本当に大丈夫です。</font><font style="vertical-align: inherit;">しかし、テーブルの定義を見ると</font></font><code>some_other_table.owner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、外部キーcに制限がある</font><font style="vertical-align: inherit;">ことがわかります</font></font><code>companies.company_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、本質的にこのSQLは間違っています。</font><font style="vertical-align: inherit;">同じ名前を使用する必要がありました：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> *
  <span class="hljs-keyword">FROM</span> some_table       s
  <span class="hljs-keyword">JOIN</span> some_other_table o
    <span class="hljs-keyword">ON</span> o.company_id = s.person_id;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでバグがあることがすぐにわかります。コードの1行を確認するだけで、テーブル定義を参照する必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これは常に実行できるわけではないことに注意してください。</font><font style="vertical-align: inherit;">あなたは、元の倉庫と終了を持つテーブルがある場合は、比較することもできます</font></font><code>source_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し</font></font><code>destination_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て</font></font><code>warehouse_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この場合、名前</font></font><code>source_warehouse_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">を指定することをお勧めします</font></font><code>destination_warehouse_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、上記の例で</font></font><code>owner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、目的よりも目的を説明する方が適切である</font><font style="vertical-align: inherit;">ことにも注意してください</font></font><code>company_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これが混乱を招くと思われる場合は、列に名前を付けることができます</font></font><code>owning_company_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に、名前から列の目的がわかります。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL値を避ける</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアドバイスは多くの経験豊富なデータベース開発者に知られていますが、残念ながら、十分な頻度で説明していません。理由はありませんが、データベースでNULL値を許可しないでください。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは重要ですが、かなり複雑なトピックです。</font><font style="vertical-align: inherit;">最初に理論について説明し、次にデータベースのアーキテクチャに及ぼす影響について説明します。最後に、NULL値の存在によって引き起こされる深刻な問題の実際の例を分析します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースの種類</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースには、さまざまな</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ（</font><font style="vertical-align: inherit;">INTEGER、JSON、DATETIMEなど）</font><font style="vertical-align: inherit;">を含めることができます</font><font style="vertical-align: inherit;">。タイプは列に関連付けられており、追加される値はすべてこのタイプに対応している必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、タイプとは何ですか？</font><font style="vertical-align: inherit;">これは、名前、有効な値のセット、および有効な操作のセットです。</font><font style="vertical-align: inherit;">彼らは私たちが望ましくない行動を回避するのに役立ちます。</font><font style="vertical-align: inherit;">たとえば、文字列と数値を比較しようとすると、Javaではどうなりますか？</font></font><br>
<br>
<pre><code class="sql hljs">CustomerAccount.java:5: error: bad operand types for binary operator '&gt;'<font></font>
        if ( current &gt; threshold ) {<font></font>
                   ^<font></font>
  first type:  String<font></font>
  second type: int</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
が</font></font><code>current &gt; threshold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比較できないタイプ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">比較</font><font style="vertical-align: inherit;">していることに気付かなくても</font><font style="vertical-align: inherit;">、コンパイラーはこれをキャッチします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
皮肉なことに、データを保存するデータベース（およびデータ破損に対する最後の防御ライン）は、型とひどく連携します。ただうんざり。たとえば、テーブル</font></font><code>customers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にサロゲートデジタルキーがある場合、これを行うことができます。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span>, birthdate
  <span class="hljs-keyword">FROM</span> customers
 <span class="hljs-keyword">WHERE</span> customer_id &gt; weight;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これは意味がなく、実際にはコンパイルエラーが発生します。多くのプログラミング言語では、このような型エラーを簡単にキャッチできますが、データベースではその逆です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはデータベースの世界では通常の状況です。おそらく、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のSQL標準が1992年にリリースされた</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため</font><font style="vertical-align: inherit;">です。これらの年はコンピュータの速度が遅く、実装を複雑にするすべての要素がデータベースを確実に遅くしていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、NULL値がシーンに表示されます。 SQL標準では、述語</font></font><code>IS NULL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">との</font><font style="vertical-align: inherit;">1か所のみで正しく実装されていました</font></font><code>IS NOT NULL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 NULL値は定義上不明であるため、そのために設計された演算子を持つことはできません。したがって、存在し</font></font><code>IS NULL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>IS NOT NULL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わりに</font></font><code>= NULL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>!= NULL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして、NULL値の比較は、新しいNULL値の出現につながります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが奇妙に聞こえる場合は、NULLの代わりに「不明」と書く方がはるかに簡単です。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULLの</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不明な値を</font><font style="vertical-align: inherit;">比較すると</font><font style="vertical-align: inherit;">、</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULLの</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不明な値になります。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ええ、わかりました！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null値はどういう意味ですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理論のクラムで武装して、我々はその実際的な帰結を考慮します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
年間の給与が5万ドルを超えるすべての従業員に500ドルのボーナスを支払う必要があります。次のコードを記述します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> employee_number, <span class="hljs-keyword">name</span>
  <span class="hljs-keyword">FROM</span> employees
 <span class="hljs-keyword">WHERE</span> salary &gt; <span class="hljs-number">50000</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上司の収入が5万ドルを超えていたのに解雇されましたが、彼の給与はデータベースになく（列は</font></font><code>employees.salary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULLです）、比較演算子はNULLと50 000を比較できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこの列にNULLがあるのですか。多分給料は機密です。情報がまだ届いていないのかもしれません。たぶんこれはコンサルタントであり、給料はもらえません。多分、彼は給与ではなく時給を持っています。</font><font style="vertical-align: inherit;">データが欠落し</font><font style="vertical-align: inherit;">て</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いる</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理由</font><font style="vertical-align: inherit;">は</font><i><font style="vertical-align: inherit;">たくさん</font></i><font style="vertical-align: inherit;">あります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列内の情報の有無は、それが</font><i><font style="vertical-align: inherit;">他の</font></i><font style="vertical-align: inherit;">何かに依存していることを示唆してい</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主キーとデータベースを非正規化する代わりに。</font><font style="vertical-align: inherit;">したがって、NULL値が存在する可能性がある列は、新しいテーブルを作成するのに適した候補です。</font><font style="vertical-align: inherit;">このケースでは、テーブルを有していてもよく</font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>_</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など。D.にあなたはまだ盲目の労働組合の賃金や上司で、それがないために解雇しています。</font><font style="vertical-align: inherit;">しかし、あなたの基地は、問題が給与問題以上のものであることを示唆するのに十分な情報を提供し始めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、はい、それは愚かな例でしたが、それは最後のわらでした。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL値は論理的に不可能な状況につながります</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私にはNULL値に関しては知識が豊富だと思われるかもしれません。</font><font style="vertical-align: inherit;">しかし、現実に非常に近い別の例を見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数年前、私はロンドンでドメインレジストラーとして働いていて、80行のSQLクエリが誤ったデータを返す理由を理解しようとしました。</font><font style="vertical-align: inherit;">そのような状況では、情報は間違いなく返されるはずでしたが、これは起こりませんでした。</font><font style="vertical-align: inherit;">私は認めるのは恥ずかしいですが、理由がそのような条件の組み合わせであることを理解するのに1日かかりました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OUTER JOINを使用しました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL値を簡単に生成する可能性があります。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL値を使用すると、SQLが誤った答えを返す可能性があります。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの開発者は後者の側面を認識していません。そのため、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースDatabase In Depthの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例を見てみましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">2つのテーブルの簡単な図：</font></font><br>
<br>
<code>suppliers</code><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">supplier_id</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">市</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s1</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">London</font></font><br>
</td>
</tr>
</tbody></table></div><br>
<code>parts</code><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">part_id</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">市</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヌル</font></font><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な例を見つけるのは難しいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードはを返します</font></font><code>p1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> part_id
  <span class="hljs-keyword">FROM</span> parts;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは何をしますか？</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> part_id
  <span class="hljs-keyword">FROM</span> parts
 <span class="hljs-keyword">WHERE</span> city = city;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のNULLまたは同じNULLであってもNULL値を比較できないため、何も返しません。</font><font style="vertical-align: inherit;">私たちが知らなくても、各行の都市は同じでなければならないので、奇妙に見えますか？</font><font style="vertical-align: inherit;">次に、次のコードは何を返しますか？</font><font style="vertical-align: inherit;">さらに読む前にこれを理解するようにしてください。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> s.supplier_id, p.part_id
  <span class="hljs-keyword">FROM</span> suppliers s, parts p
 <span class="hljs-keyword">WHERE</span> p.city &lt;&gt; s.city
    <span class="hljs-keyword">OR</span> p.city &lt;&gt; <span class="hljs-string">'Paris'</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
都市</font></font><code>NULL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>p.city</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">比較できないため、応答ラインを取得できませんでした。</font><font style="vertical-align: inherit;">そのため、条件分岐のいずれもに</font></font><code>WHERE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つながり</font><font style="vertical-align: inherit;">ません</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、不明な都市はパリかそうでないかのどちらかです。</font><font style="vertical-align: inherit;">パリの場合、最初の条件が真になります（</font></font><code>&lt;&gt; 'London'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">これがパリでない場合、2番目の条件（</font></font><code>&lt;&gt; 'Paris'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">はtrueになります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、条件はである</font></font><code>WHERE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要がありますが</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そうではないため、SQLは論理的に不可能な結果を​​生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロンドンで出会ったバグです。</font><font style="vertical-align: inherit;">NULL値を生成または含む可能性のあるSQLを作成するたびに、誤った結果が返されるリスクがあります。</font><font style="vertical-align: inherit;">これはまれに発生しますが、特定することは非常に困難です。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合計</font></font></h1><br>
<ul>
<li><font style="vertical-align: inherit;"></font><code>__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わりに</font><font style="vertical-align: inherit;">使用してください</font></font><code>CamelCase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テーブル名は複数形でなければなりません。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">識別子を持つフィールドに拡張名を付けます（</font></font><code>item_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わりに</font></font><code>id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あいまいな列名は避けてください。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能であれば、参照する列と同じ方法で、外部キーを使用して列に名前を付けます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能な限り、すべての列定義にNOT NULLを追加してください。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能な限り、NULL値を生成する可能性のあるSQLの記述は避けてください。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不完全ではありますが、このデータベース設計ガイドはあなたの人生を楽にします。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja484176/index.html">Unityでのステータステンプレートの実装</a></li>
<li><a href="../ja484178/index.html">Planet Earth用のインテリジェントイーサネットスイッチ</a></li>
<li><a href="../ja484180/index.html">Rostelecom仮想PBX：APIを介して実行できる内容と方法</a></li>
<li><a href="../ja484182/index.html">Xenobots：カエル細胞からの生きているナノロボット</a></li>
<li><a href="../ja484186/index.html">LDAP-「認証」はアンチパターンです</a></li>
<li><a href="../ja484192/index.html">Tarantool Cartridgeへのアプリケーションのデプロイが簡単で簡単（パート2）</a></li>
<li><a href="../ja484194/index.html">子供のKubernetes</a></li>
<li><a href="../ja484196/index.html">マイクからのJSサウンドまたは音声コメントの録音</a></li>
<li><a href="../ja484198/index.html">コインの裏側：テスラ株の成長で誰が勝って負けたのか</a></li>
<li><a href="../ja484200/index.html">それらを達成するための目標を設定する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>