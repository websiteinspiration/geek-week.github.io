<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ú≥Ô∏è üó∫Ô∏è ü§õ Estruturas de dados imut√°veis ‚Äã‚Äãde √∫ltima gera√ß√£o üë©üèæ‚ÄçüöÄ üêá üë≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Durante anos, especialistas em C ++ discutem a sem√¢ntica de valores, imutabilidade e compartilhamento de recursos por meio da comunica√ß√£o. Sobre um no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Estruturas de dados imut√°veis ‚Äã‚Äãde √∫ltima gera√ß√£o</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/487100/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante anos, especialistas em C ++ discutem a sem√¢ntica de valores, imutabilidade e compartilhamento de recursos por meio da comunica√ß√£o. </font><font style="vertical-align: inherit;">Sobre um novo mundo sem mutexes e ra√ßas, sem padr√µes de Comando e Observador. </font><font style="vertical-align: inherit;">De fato, nem tudo √© t√£o simples. </font><font style="vertical-align: inherit;">O principal problema ainda est√° em nossas estruturas de dados.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/pu/18/6opu18ei6gi5dbo8dvcsgopyebq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estruturas de dados imut√°veis ‚Äã‚Äãn√£o alteram seus valores. Para fazer algo com eles, voc√™ precisa criar novos valores. Os valores antigos permanecem no mesmo local, para que possam ser lidos de diferentes fluxos sem problemas e bloqueios. Como resultado, os recursos podem ser compartilhados de maneira mais racional e ordenada, porque valores antigos e novos podem usar dados comuns. Gra√ßas a isso, eles s√£o muito mais r√°pidos para comparar e armazenar de forma compacta o hist√≥rico das opera√ß√µes com a possibilidade de cancelamento. Tudo isso se encaixa perfeitamente em sistemas interativos e multiencadeados: essas estruturas de dados simplificam a arquitetura dos aplicativos de desktop e permitem que os servi√ßos sejam melhor dimensionados. Estruturas imut√°veis ‚Äã‚Äãs√£o o segredo do sucesso de Clojure e Scala, e at√© a comunidade JavaScript agora se beneficia delas, porque elas t√™m a biblioteca Immutable.js,escrito nas entranhas da empresa Facebook.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sob o corte - v√≠deo e tradu√ß√£o do relat√≥rio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da confer√™ncia C ++ Russia 2019 Moscow. </font><font style="vertical-align: inherit;">Juan fala sobre o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , uma biblioteca de estruturas imut√°veis ‚Äã‚Äãpara C ++. </font><font style="vertical-align: inherit;">No post:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vantagens arquitet√¥nicas da imunidade;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cria√ß√£o de um tipo de vetor persistente eficaz baseado em √°rvores RRB;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an√°lise da arquitetura no exemplo de um editor de texto simples.</font></font></li>
</ul><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/dbFfpTp3EhA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A trag√©dia da arquitetura baseada em valor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para entender a import√¢ncia de estruturas de dados imut√°veis, discutimos a sem√¢ntica de valores. Esse √© um recurso muito importante do C ++; considero uma das principais vantagens dessa linguagem. Por tudo isso, √© muito dif√≠cil usar a sem√¢ntica de valores como gostar√≠amos. Acredito que essa √© a trag√©dia da arquitetura baseada em valor, e o caminho para essa trag√©dia √© pavimentado com boas inten√ß√µes. Suponha que precisamos escrever software interativo com base em um modelo de dados com uma representa√ß√£o de um documento edit√°vel pelo usu√°rio. Quando a arquitectura com base nos valores que est√£o no centro deste modelo usa tipos simples e conveniente de valores que j√° existem na l√≠ngua: </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>tuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A l√≥gica do aplicativo √© criada a partir de fun√ß√µes que recebem documentos por valor e retornam uma nova vers√£o de um documento por valor. Este documento pode mudar dentro da fun√ß√£o (como acontece abaixo), mas a sem√¢ntica dos valores em C ++, aplicada ao argumento por valor e o tipo de retorno por valor, garante que n√£o haja efeitos colaterais. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/7e/0y/fh7e0ybdwuqnh3iona30quev4ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse recurso √© muito f√°cil de analisar e testar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/5c/4x/cb5c4xq-hps1x76mn-fmweshklu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como estamos trabalhando com valores, tentaremos implementar o desfazer da a√ß√£o. Isso pode ser dif√≠cil, mas com a nossa abordagem √© uma tarefa trivial: temos </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com diferentes estados v√°rias c√≥pias do documento.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d-/vh/nd/d-vhndh9j8leugdcjoyf3b4yhqq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que tamb√©m tenhamos uma interface do usu√°rio e, para garantir sua capacidade de resposta, o mapeamento da interface do usu√°rio precise ser feito em um encadeamento separado. O documento √© enviado para outro fluxo por mensagem e a intera√ß√£o tamb√©m ocorre com base nas mensagens, e n√£o atrav√©s do compartilhamento do estado usando </font></font><code>mutexes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Quando a c√≥pia √© recebida pelo segundo fluxo, voc√™ pode executar todas as opera√ß√µes necess√°rias. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/xx/kc/toxxkcwck44iayev1hywf-wqllk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salvar um documento em disco geralmente √© muito lento, especialmente se o documento for grande. Portanto, o uso </font></font><code>std::async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desta opera√ß√£o √© realizado de forma ass√≠ncrona. Usamos um lambda, colocamos um sinal de igual dentro dele para ter uma c√≥pia e agora voc√™ pode salvar sem outros tipos primitivos de sincroniza√ß√£o.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ey/jj/veeyjjijubbrc49-ghusxnuft4e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, suponha que tamb√©m tenhamos um fluxo de controle de som. Como eu disse, trabalhei muito com software de m√∫sica e o som √© outra representa√ß√£o do nosso documento, ele deve estar em um fluxo separado. Portanto, tamb√©m √© necess√°ria uma c√≥pia do documento para esse fluxo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, obtivemos um esquema muito bonito, mas n√£o muito realista. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dj/w2/hu/djw2hu7q55lbi2nmgmwok1i_cb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele constantemente precisa copiar documentos, o hist√≥rico de a√ß√µes para cancelamento leva gigabytes e, para cada renderiza√ß√£o da interface do usu√°rio, √© necess√°rio fazer uma c√≥pia profunda do documento. Em geral, todas as intera√ß√µes s√£o muito caras.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uq/sv/8-/uqsv8-sx3hphtcm9wvozi1z83fs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que o desenvolvedor do C ++ est√° fazendo nessa situa√ß√£o? Em vez de aceitar um documento por valor, a l√≥gica do aplicativo agora aceita um link para o documento e o atualiza, se necess√°rio. Nesse caso, voc√™ n√£o precisa retornar nada. Mas agora n√£o estamos lidando com valores, mas com objetos e locais. Isso cria novos problemas: se houver um link para o estado com acesso compartilhado, voc√™ precisar√° dele </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Isso √© extremamente caro, portanto haver√° alguma representa√ß√£o da nossa interface do usu√°rio na forma de uma √°rvore extremamente complexa de v√°rios Widgets.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos esses elementos devem receber atualiza√ß√µes quando um documento √© alterado, portanto, √© necess√°rio algum mecanismo de enfileiramento para sinais de altera√ß√£o. Al√©m disso, o hist√≥rico do documento n√£o √© mais um conjunto de estados; ser√° uma implementa√ß√£o do padr√£o de equipe. A opera√ß√£o deve ser implementada duas vezes, em uma dire√ß√£o e na outra, e verifique se tudo √© sim√©trico. Salvar em um encadeamento separado j√° √© muito dif√≠cil, portanto, isso ter√° que ser abandonado. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dl/lr/sj/dllrsjhkvqxxckjx1r69lflqck4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os usu√°rios j√° est√£o acostumados com a imagem da ampulheta, ent√£o tudo bem se eles esperarem um pouco. Outra coisa √© assustadora - o monstro das massas agora governa nosso c√≥digo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em que ponto tudo correu ladeira abaixo? </font><font style="vertical-align: inherit;">N√≥s projetamos nosso c√≥digo muito bem e tivemos que comprometer devido √† c√≥pia. </font><font style="vertical-align: inherit;">Mas em C ++, a c√≥pia √© necess√°ria para passar por valor apenas para dados mut√°veis. </font><font style="vertical-align: inherit;">Se o objeto for imut√°vel, o operador de atribui√ß√£o poder√° ser implementado para que ele copie apenas o ponteiro para a representa√ß√£o interna e nada mais.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere uma estrutura de dados que poderia nos ajudar. </font><font style="vertical-align: inherit;">No vetor abaixo, todos os m√©todos est√£o marcados como </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, portanto, √© imut√°vel. </font><font style="vertical-align: inherit;">Na execu√ß√£o </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o vetor n√£o √© atualizado; em vez disso, um novo vetor √© retornado, ao qual os dados transferidos s√£o adicionados. </font><font style="vertical-align: inherit;">Infelizmente, n√£o podemos usar colchetes com essa abordagem devido √† forma como eles s√£o definidos. </font><font style="vertical-align: inherit;">Em vez disso, voc√™ pode usar a fun√ß√£o</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que retorna uma nova vers√£o com um item atualizado. Nossa estrutura de dados agora possui uma propriedade chamada persist√™ncia na programa√ß√£o funcional. Isso n√£o significa que salvamos essa estrutura de dados no disco r√≠gido, mas o fato de que, quando atualizado, o conte√∫do antigo n√£o √© exclu√≠do - em vez disso, √© criada uma nova bifurca√ß√£o do nosso mundo, ou seja, a estrutura. Gra√ßas a isso, podemos comparar valores passados ‚Äã‚Äãcom presentes - isso √© feito com a ajuda de dois </font></font><code>assert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-keyword">const</span> auto v1 = v0.push_back(<span class="hljs-number">15</span>);
<span class="hljs-keyword">const</span> auto v2 = v1.push_back(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> auto v3 = v2.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">42</span>);<font></font>
<font></font>
assert(v2.size() == v0.size() + <span class="hljs-number">2</span>);<font></font>
assert(v3[<span class="hljs-number">0</span>] - v1[<span class="hljs-number">0</span>] == <span class="hljs-number">27</span>);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As altera√ß√µes agora podem ser verificadas diretamente, elas n√£o s√£o mais propriedades ocultas da estrutura de dados. Esse recurso √© especialmente valioso em sistemas interativos, onde precisamos constantemente alterar dados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra propriedade importante √© o compartilhamento estrutural. Agora n√£o estamos copiando todos os dados para cada nova vers√£o da estrutura de dados. Mesmo com </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nem todos os dados s√£o copiados, mas apenas uma pequena parte deles. Todos os nossos garfos t√™m acesso comum a uma visualiza√ß√£o compacta, proporcional ao n√∫mero de altera√ß√µes, n√£o ao n√∫mero de c√≥pias. Da mesma forma, a compara√ß√£o √© muito r√°pida: se tudo estiver armazenado em um bloco de mem√≥ria, em um ponteiro, voc√™ poder√° simplesmente comparar os ponteiros e n√£o examinar os elementos que est√£o dentro deles, se forem iguais. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como esse vetor, parece-me, √© extremamente √∫til, eu o implementei em uma biblioteca separada: isto √© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - uma biblioteca de estruturas imut√°veis, um projeto de c√≥digo aberto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao escrev√™-lo, eu queria que seu uso fosse familiar aos desenvolvedores de C ++. </font><font style="vertical-align: inherit;">Existem muitas bibliotecas que implementam os conceitos de programa√ß√£o funcional em C ++, mas d√£o a impress√£o de que os desenvolvedores escrevem para Haskell e n√£o para C ++. </font><font style="vertical-align: inherit;">Isso cria inconveni√™ncia. </font><font style="vertical-align: inherit;">Al√©m disso, consegui um bom desempenho. </font><font style="vertical-align: inherit;">As pessoas usam C ++ quando os recursos dispon√≠veis s√£o limitados. </font><font style="vertical-align: inherit;">Finalmente, queria que a biblioteca fosse personaliz√°vel. </font><font style="vertical-align: inherit;">Este requisito est√° relacionado ao requisito de desempenho.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em busca de um vetor m√°gico</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na segunda parte do relat√≥rio, consideraremos como esse vetor imut√°vel √© estruturado. A maneira mais f√°cil de entender os princ√≠pios dessa estrutura de dados √© come√ßando com uma lista regular. Se voc√™ estiver um pouco familiarizado com a programa√ß√£o funcional (usando Lisp ou Haskell como exemplo), voc√™ sabe que as listas s√£o as estruturas de dados imut√°veis ‚Äã‚Äãmais comuns. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ou/d6/rnoud6a8vaqpet2jg-n18be85fk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para come√ßar, vamos assumir que temos uma lista com um √∫nico n√≥ </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ao adicionar novos elementos ao topo da lista, novos n√≥s s√£o criados, cada um com um ponteiro para um n√≥ existente. Portanto, no exemplo do slide, n√£o temos tr√™s c√≥pias de uma lista, mas tr√™s elementos na mem√≥ria, ou seja, </font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eles </font></font><code>v0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicam elementos diferentes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/nf/bh/bmnfbhtdmbu_kdm_xlpuxleld2w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tamb√©m podemos criar uma bifurca√ß√£o da realidade, ou seja, criar uma nova lista que tenha o mesmo final, mas um come√ßo diferente.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tais estruturas de dados s√£o estudadas h√° muito tempo: Chris Okasaki escreveu o trabalho fundamental de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estruturas de dados puramente funcionais</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Al√©m disso, a estrutura de dados da </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finger Tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proposta por Ralf Hinze e Ross Paterson √© muito interessante </font><font style="vertical-align: inherit;">. Mas para C ++, essas estruturas de dados n√£o funcionam bem. Eles usam n√≥s pequenos e sabemos que em C ++ pequenos n√≥s significam falta de efici√™ncia do armazenamento em cache. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, eles geralmente contam com propriedades que o C ++ n√£o possui, como pregui√ßa. Portanto, o trabalho de Phil Bagwell sobre estruturas de dados imut√°veis ‚Äã‚Äã√© muito mais √∫til para n√≥s - um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escrito no in√≠cio dos anos 2000, bem como o trabalho de Rich Hickey - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, autor de Clojure. Rich Hickey criou uma lista, que na verdade n√£o √© uma lista, mas baseada em estruturas de dados modernas: vetores e mapas de hash. Essas estruturas de dados t√™m efici√™ncia de armazenamento em cache e interagem bem com processadores modernos, para os quais √© indesej√°vel trabalhar com pequenos n√≥s. Tais estruturas podem ser usadas em C ++. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como construir um vetor imune? No cora√ß√£o de qualquer estrutura, mesmo remotamente semelhante a um vetor, deve haver uma matriz. Mas a matriz n√£o possui compartilhamento estrutural. Para alterar qualquer elemento da matriz, sem perder a propriedade persistence, voc√™ deve copiar a matriz inteira. Para n√£o fazer isso, a matriz pode ser dividida em partes separadas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, ao atualizar um elemento vetorial, precisamos copiar apenas uma parte, e n√£o o vetor inteiro. Mas essas partes em si n√£o s√£o uma estrutura de dados; elas devem ser combinadas de uma maneira ou de outra. Coloque-os em outra matriz. Mais uma vez, surge o problema de que a matriz pode ser muito grande e, em seguida, copi√°-la novamente levar√° muito tempo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dividimos esse array em peda√ßos, os colocamos novamente em um array separado e repetimos esse procedimento at√© que exista apenas um array raiz. A estrutura resultante √© chamada de √°rvore residual. Essa √°rvore √© descrita pela constante M = 2B, ou seja, o fator de ramifica√ß√£o. Esse indicador de ramifica√ß√£o deve ter uma pot√™ncia de dois, e logo descobriremos o porqu√™. No exemplo do slide, s√£o usados ‚Äã‚Äãblocos de quatro caracteres, mas, na pr√°tica, s√£o usados ‚Äã‚Äãblocos de 32 caracteres. Existem experimentos com os quais voc√™ pode encontrar o tamanho ideal de bloco para uma arquitetura espec√≠fica. Isso permite alcan√ßar a melhor propor√ß√£o de acesso compartilhado estrutural ao tempo de acesso: quanto menor a √°rvore, menor o tempo de acesso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lendo isso, os desenvolvedores que escrevem em C ++ provavelmente pensam: mas qualquer estrutura baseada em √°rvore √© muito lenta! As √°rvores crescem com um aumento no n√∫mero de elementos nelas e, por isso, o tempo de acesso √© reduzido. √â por isso que os programadores preferem </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, em vez de </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Apresso-me a tranquiliz√°-lo: nossa √°rvore cresce muito lentamente. Um vetor contendo todos os valores poss√≠veis de um int de 32 bits tem apenas 7 n√≠veis de altura. Pode ser demonstrado experimentalmente que, com esse tamanho de dados, a propor√ß√£o do cache para o volume de carga afeta significativamente o desempenho que a profundidade da √°rvore. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver como √© realizado o acesso a um elemento de uma √°rvore. Suponha que voc√™ precise acessar o elemento 17. N√≥s pegamos uma representa√ß√£o bin√°ria do √≠ndice e dividimos em grupos do tamanho de um fator de ramifica√ß√£o.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c1/gz/o1/c1gzo1qqm9pycpehqerzzkvwvwm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em cada grupo, usamos o valor bin√°rio correspondente e, assim, descemos na √°rvore. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, suponha que precisamos fazer uma altera√ß√£o nessa estrutura de dados, ou seja, executar o m√©todo </font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/l8/xi/3y/l8xi3yorosfghnwt9gmcijtk83a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fazer isso, primeiro voc√™ precisa copiar o bloco em que o elemento est√° localizado e, em seguida, copiar cada n√≥ interno no caminho para o elemento. Por um lado, muitos dados precisam ser copiados, mas ao mesmo tempo uma parte significativa desses dados √© comum, isso compensa o seu volume. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A prop√≥sito, existe uma estrutura de dados muito mais antiga que √© muito semelhante √† que eu descrevi. Estas s√£o p√°ginas de mem√≥ria com uma √°rvore da tabela de p√°ginas. Seu gerenciamento tamb√©m √© realizado por meio de uma chamada </font></font><code>fork</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos tentar melhorar nossa estrutura de dados. Suponha que precisamos conectar dois vetores. A estrutura de dados descrita at√© o momento tem as mesmas limita√ß√µes </font></font><code>std::vector:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que possui c√©lulas vazias em sua parte mais √† direita. Como a estrutura √© perfeitamente equilibrada, essas c√©lulas vazias n√£o podem estar no meio da √°rvore. Portanto, se houver um segundo vetor que queremos combinar com o primeiro, precisaremos copiar os elementos para c√©lulas vazias, o que criar√° c√©lulas vazias no segundo vetor e, no final, teremos que copiar todo o segundo vetor. Essa opera√ß√£o possui complexidade computacional O (n), onde n √© o tamanho do segundo vetor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos tentar alcan√ßar um resultado melhor. Existe uma vers√£o modificada da nossa estrutura de dados denominada √°rvore balanceada de raiz relaxada. Nessa estrutura, os n√≥s que n√£o est√£o no caminho mais √† esquerda podem ter c√©lulas vazias. Portanto, nesses n√≥s incompletos (ou relaxados), √© necess√°rio calcular o tamanho da sub√°rvore. Agora voc√™ pode executar uma opera√ß√£o de jun√ß√£o complexa, mas logar√≠tmica. Esta opera√ß√£o de complexidade de tempo constante √© O (log (32)). Como as √°rvores s√£o rasas, o tempo de acesso √© constante, embora relativamente longo. Devido ao fato de termos uma opera√ß√£o de uni√£o, uma vers√£o relaxada dessa estrutura de dados √© chamada confluente: al√©m de persistente, e voc√™ pode bifurcar, duas dessas estruturas podem ser combinadas em uma.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qr/rj/hz/qrrjhzfbr-22n0cdr-vvhke1pvq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No exemplo com o qual trabalhamos at√© agora, a estrutura de dados √© muito elegante, mas, na pr√°tica, as implementa√ß√µes no Clojure e outras linguagens funcionais parecem diferentes. Eles criam cont√™ineres para cada valor, ou seja, cada elemento do vetor est√° em uma c√©lula separada e os n√≥s folha cont√™m ponteiros para esses elementos. Mas essa abordagem √© extremamente ineficiente, em C ++ geralmente n√£o coloca todo valor em um cont√™iner. Portanto, seria melhor se esses elementos estivessem localizados diretamente nos n√≥s. Ent√£o surge outro problema: elementos diferentes t√™m tamanhos diferentes. Se o elemento tiver o mesmo tamanho do ponteiro, nossa estrutura ser√° semelhante √† mostrada abaixo:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/78/s4/_k/78s4_kqqdc_fi8_ydkopktou0m4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por√©m, se os elementos forem grandes, a estrutura de dados perder√° as propriedades que medimos (tempo de acesso O (log (32) ())), porque copiar uma das folhas agora leva mais tempo. Portanto, alterei essa estrutura de dados para aumentar o tamanho o n√∫mero de elementos contidos nela diminuiu o n√∫mero desses elementos nos n√≥s das folhas. Pelo contr√°rio, se os elementos forem pequenos, eles agora podem se encaixar mais.A nova vers√£o da √°rvore √© chamada de incorpora√ß√£o de √°rvore balanceada com base em radix.√â descrita n√£o por uma constante, mas por duas: uma delas descreve n√≥s internos e o segundo frondoso. A implementa√ß√£o da √°rvore em C ++ pode calcular o tamanho ideal do elemento folha, dependendo do tamanho dos ponteiros e dos pr√≥prios elementos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nossa √°rvore j√° est√° funcionando muito bem, mas ainda pode ser melhorada. D√™ uma olhada em uma fun√ß√£o semelhante a uma fun√ß√£o </font></font><code>iota</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = v.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele pega uma entrada </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, executa </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no final do vetor para cada n√∫mero inteiro entre </font></font><code>first</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>last</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e retorna o que aconteceu. Tudo est√° em ordem com a corre√ß√£o dessa fun√ß√£o, mas funciona ineficientemente. Cada chamada </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copia o bloco mais √† esquerda desnecessariamente: a pr√≥xima chamada pressiona outro elemento e a c√≥pia √© repetida novamente, e os dados copiados pelo m√©todo anterior s√£o exclu√≠dos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ pode tentar outra implementa√ß√£o dessa fun√ß√£o, na qual abandonamos a persist√™ncia dentro da fun√ß√£o. Pode ser usado </font></font><code>transient vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com uma API mut√°vel que seja compat√≠vel com a API comum </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dentro dessa fun√ß√£o, cada chamada </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">altera a estrutura de dados.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    auto t = v.transient();<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        t.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> t.persistent();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa implementa√ß√£o √© mais eficiente e permite reutilizar novos elementos no caminho certo. No final da fun√ß√£o, </font></font><code>.persistent()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© feita </font><font style="vertical-align: inherit;">uma chamada </font><font style="vertical-align: inherit;">que retorna imut√°vel </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Os poss√≠veis efeitos colaterais permanecem invis√≠veis de fora da fun√ß√£o. O original </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">era e permanece imut√°vel, apenas os dados criados dentro da fun√ß√£o s√£o alterados. Como eu disse, uma vantagem importante dessa abordagem √© que voc√™ pode usar </font></font><code>std::back_inserter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmos padr√£o que exigem APIs mut√°veis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere outro exemplo.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        <font></font>
            .push_back(<span class="hljs-string">'i'</span>)        <font></font>
            .push_back(<span class="hljs-string">'!'</span>);       <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A fun√ß√£o n√£o aceita e retorna </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas uma cadeia de chamadas √© executada dentro </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Aqui, como no exemplo anterior, pode ocorrer c√≥pia desnecess√°ria dentro da chamada </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Observe que o primeiro valor executado </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© o valor nomeado e o restante √© o valor r, ou seja, links an√¥nimos. Se voc√™ usar a contagem de refer√™ncia, o m√©todo </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poder√° se referir a contadores de refer√™ncia para n√≥s para os quais a mem√≥ria est√° alocada na √°rvore. E no caso do valor-r, se o n√∫mero de links for um, fica claro que nenhuma outra parte do programa acessa esses n√≥s. Aqui, o desempenho √© exatamente o mesmo do caso </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        ‚üµ named <span class="hljs-keyword">value</span>: v<font></font>
            .push_back(<span class="hljs-string">'i'</span>)        ‚üµ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span>
            .push_back(<span class="hljs-string">'!'</span>);       ‚üµ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, para ajudar o compilador, podemos execut√°-lo </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pois ele </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o √© usado em nenhum outro lugar da fun√ß√£o. Tivemos uma vantagem importante, que n√£o estava na </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variante: se passarmos o valor retornado de outro say_hi para a fun√ß√£o say_hi, n√£o haver√° c√≥pias extras. No caso de c, </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existem limites nos quais a c√≥pia em excesso pode ocorrer. Em outras palavras, temos uma estrutura de dados persistente e imut√°vel, cujo desempenho depende da quantidade real de acesso compartilhado no tempo de execu√ß√£o. Se n√£o houver compartilhamento, o desempenho ser√° o mesmo de uma estrutura de dados mut√°veis. Esta √© uma propriedade extremamente importante. O exemplo que eu j√° mostrei acima pode ser reescrita com um m√©todo </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = std::move(v).push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At√© agora, falamos sobre vetores e, al√©m deles, tamb√©m existem mapas de hash. Eles s√£o dedicados a um relat√≥rio muito √∫til de Phil Nash: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Santo Graal. Uma matriz de hash mapeada para C ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ele descreve tabelas de hash implementadas com base nos mesmos princ√≠pios que acabei de falar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estou certo de que muitos de voc√™s t√™m d√∫vidas sobre o desempenho de tais estruturas. Eles trabalham rapidamente na pr√°tica? Eu fiz muitos testes e, em suma, minha resposta √© sim. Se voc√™ quiser saber mais sobre os resultados dos testes, eles ser√£o publicados no meu artigo para a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Confer√™ncia Internacional de Programa√ß√£o Funcional 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agora, acho que √© melhor discutir n√£o valores absolutos, mas o efeito que essa estrutura de dados tem no sistema como um todo. </font><font style="vertical-align: inherit;">Obviamente, a atualiza√ß√£o do nosso vetor √© mais lenta porque voc√™ precisa copiar v√°rios blocos de dados e alocar mem√≥ria para outros dados. </font><font style="vertical-align: inherit;">Mas ignorar nosso vetor √© realizado quase na mesma velocidade que um vetor normal. </font><font style="vertical-align: inherit;">Foi muito importante para mim conseguir isso, pois a leitura dos dados √© realizada com muito mais frequ√™ncia do que alter√°-los.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, devido √† atualiza√ß√£o mais lenta, n√£o h√° necessidade de copiar nada, apenas a estrutura de dados √© copiada. </font><font style="vertical-align: inherit;">Portanto, o tempo gasto na atualiza√ß√£o do vetor √©, por assim dizer, amortizado para todas as c√≥pias realizadas no sistema. </font><font style="vertical-align: inherit;">Portanto, se voc√™ aplicar essa estrutura de dados em uma arquitetura semelhante √† descrita no come√ßo do relat√≥rio, o desempenho aumentar√° significativamente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ewig</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o serei infundado e demonstrarei minha estrutura de dados usando um exemplo. </font><font style="vertical-align: inherit;">Eu escrevi um pequeno editor de texto. </font><font style="vertical-align: inherit;">Essa √© uma ferramenta interativa chamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , na qual os documentos s√£o representados por vetores imut√°veis. </font><font style="vertical-align: inherit;">Eu tenho uma c√≥pia de toda a Wikip√©dia em esperanto no meu disco, ele pesa 1 gigabyte (no come√ßo eu queria baixar a vers√£o em ingl√™s, mas √© muito grande). </font><font style="vertical-align: inherit;">Qualquer que seja o editor de texto que voc√™ use, tenho certeza de que ele n√£o gostar√° deste arquivo. </font><font style="vertical-align: inherit;">E quando voc√™ baixa esse arquivo no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pode edit√°-lo imediatamente, porque o download √© ass√≠ncrono. </font><font style="vertical-align: inherit;">A navega√ß√£o de arquivos funciona, nada trava, n√£o </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nenhuma sincroniza√ß√£o. </font><font style="vertical-align: inherit;">Como voc√™ pode ver, o arquivo baixado leva 20 milh√µes de linhas de c√≥digo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de considerar as propriedades mais importantes dessa ferramenta, vamos prestar aten√ß√£o a um detalhe engra√ßado. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eb/kt/eq/ebkteqmtvnbkncoxlb91z0g6qpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No in√≠cio da linha, destacada em branco na parte inferior da imagem, voc√™ v√™ dois h√≠fens. Essa interface do usu√°rio provavelmente √© familiar para os usu√°rios do emacs; h√≠fens indicam que o documento n√£o foi modificado de forma alguma. Se voc√™ fizer altera√ß√µes, os asteriscos ser√£o exibidos em vez de h√≠fens. Por√©m, diferentemente de outros editores, se voc√™ </font><font style="vertical-align: inherit;">apagar essas altera√ß√µes </font><font style="vertical-align: inherit;">no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (n√£o desfaz√™-lo, apenas exclua-o), h√≠fens ser√£o exibidos em vez de asteriscos, porque </font><font style="vertical-align: inherit;">todas as vers√µes anteriores do texto s√£o salvas </font><font style="vertical-align: inherit;">no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Gra√ßas a isso, n√£o √© necess√°rio um sinalizador especial para mostrar se o documento foi alterado: a presen√ßa de altera√ß√µes √© determinada por compara√ß√£o com o documento original.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere outra propriedade interessante da ferramenta: copie o texto inteiro e cole-o algumas vezes no meio do texto existente. </font><font style="vertical-align: inherit;">Como voc√™ pode ver, isso acontece instantaneamente. </font><font style="vertical-align: inherit;">A jun√ß√£o de vetores aqui √© uma opera√ß√£o logar√≠tmica, e o logaritmo de v√°rios milh√µes n√£o √© uma opera√ß√£o t√£o longa. </font><font style="vertical-align: inherit;">Se voc√™ tentar salvar esse grande documento no disco r√≠gido, levar√° muito mais tempo, porque o texto n√£o ser√° mais apresentado como um vetor obtido da vers√£o anterior desse vetor. </font><font style="vertical-align: inherit;">Ao salvar no disco, a serializa√ß√£o ocorre, perdendo a persist√™ncia.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retornar √† arquitetura baseada em valor</font></font></h2><br>
<img src="https://habrastorage.org/webt/wf/o7/b7/wfo7b78ha0wnqjzcjjeky_esh0g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos come√ßar como voc√™ n√£o pode retornar a essa arquitetura: usando o habitual controlador, modelo e exibi√ß√£o em estilo Java, que s√£o mais frequentemente usados ‚Äã‚Äãpara aplicativos interativos em C ++. N√£o h√° nada errado com eles, mas eles n√£o s√£o adequados para o nosso problema. Por um lado, o padr√£o Model-View-Controller permite a separa√ß√£o de tarefas, mas, por outro, cada um desses elementos √© um objeto, tanto do ponto de vista orientado a objetos quanto do C ++, ou seja, s√£o √°reas de mem√≥ria com mut√°vel doen√ßa. O View conhece o Model; o que √© muito pior - o Model conhece indiretamente o View, porque quase certamente h√° um retorno de chamada atrav√©s do qual o View √© notificado quando o Model √© alterado. Mesmo com a melhor implementa√ß√£o de princ√≠pios orientados a objetos, temos muitas depend√™ncias m√∫tuas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/07/so/xq/07soxqkandixucwhzk6mvfr1e84.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä medida que o aplicativo cresce e novos modelos, controladores e modos de exibi√ß√£o s√£o adicionados, surge uma situa√ß√£o em que, para alterar um segmento do programa, voc√™ precisa conhecer todas as partes associadas a ele, sobre todos os modos de exibi√ß√£o que recebem notifica√ß√µes </font></font><code>callback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, etc. Como resultado, para todos o familiar monstro da massa come√ßa a examinar essas depend√™ncias. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra arquitetura √© poss√≠vel? Existe uma abordagem alternativa ao padr√£o Model-View-Controller chamado ‚ÄúArquitetura de fluxo de dados unidirecional‚Äù. Este conceito n√£o foi inventado por mim, √© usado com bastante frequ√™ncia no desenvolvimento web. No Facebook, isso √© chamado de arquitetura Flux, mas em C ++, ainda n√£o √© aplicado.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/z6/p2/tyz6p2hutpnjwusi0edhbcwvo0s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elementos dessa arquitetura j√° nos s√£o familiares: A√ß√£o, Modelo e Vis√£o, mas o significado de blocos e setas √© diferente. Blocos s√£o valores, n√£o objetos e n√£o regi√µes com estados mut√°veis. Isso se aplica at√© ao modo de exibi√ß√£o. Al√©m disso, as setas n√£o s√£o links, porque sem objetos n√£o pode haver links. Aqui as setas s√£o fun√ß√µes. Entre A√ß√£o e Modelo, existe uma fun√ß√£o de atualiza√ß√£o que aceita o Modelo atual, ou seja, o estado atual do mundo, e A√ß√£o, que √© uma representa√ß√£o de um evento, por exemplo, um clique do mouse ou um evento de outro n√≠vel de abstra√ß√£o, por exemplo, um elemento ou s√≠mbolo √© inserido em um documento. A fun√ß√£o de atualiza√ß√£o atualiza o documento e retorna o novo estado do mundo. O modelo se conecta √† renderiza√ß√£o da fun√ß√£o View, que pega o Model e retorna a visualiza√ß√£o. Isso requer uma estrutura na qual o View possa ser representado como valores.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No desenvolvimento web, o React faz isso, mas em C ++ ainda n√£o h√° nada parecido, embora quem sabe, se houver pessoas que querem me pagar para escrever algo assim, isso poder√° aparecer em breve. Enquanto isso, voc√™ pode usar a API do modo imediato, na qual a fun√ß√£o de desenho permite criar um valor como efeito colateral. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por fim, a Visualiza√ß√£o deve ter um mecanismo que permita ao usu√°rio ou a outras fontes de eventos enviar A√ß√£o. Existe uma maneira f√°cil de implementar isso, √© apresentado abaixo:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">application <span class="hljs-title">update</span>(<span class="hljs-params">application state, action ev</span>)</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fname</span>)</span><font></font>
{<font></font>
    auto term  = terminal{};<font></font>
    auto state = application{load_buffer(fname), key_map_emacs};<font></font>
    <span class="hljs-keyword">while</span> (!state.done) {<font></font>
        draw(state);<font></font>
        auto act = term.next();<font></font>
        state = update(state, act);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com exce√ß√£o de salvar e carregar de forma ass√≠ncrona, esse √© o c√≥digo usado no editor que acabou de ser apresentado. H√° um objeto aqui </font></font><code>terminal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que permite ler e escrever na linha de comando. Al√©m disso, </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esse √© o valor do Model, ele armazena todo o estado do aplicativo. Como voc√™ pode ver na parte superior da tela, existe uma fun√ß√£o que retorna uma nova vers√£o </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O ciclo dentro da fun√ß√£o √© executado at√© que o aplicativo precise fechar, ou seja, at√© </font></font><code>!state.done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. No loop, um novo estado √© desenhado e o pr√≥ximo evento √© solicitado. Finalmente, o estado √© armazenado em uma vari√°vel local </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o loop inicia novamente. Este c√≥digo tem uma vantagem muito importante: apenas uma vari√°vel mut√°vel existe durante a execu√ß√£o do programa, √© um objeto </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os desenvolvedores do Clojure chamam essa arquitetura de √°tomo √∫nico: existe um ponto √∫nico em todo o aplicativo atrav√©s do qual todas as altera√ß√µes s√£o feitas. </font><font style="vertical-align: inherit;">A l√≥gica do aplicativo n√£o participa da atualiza√ß√£o deste ponto de forma alguma, o que cria um ciclo especialmente projetado para isso. </font><font style="vertical-align: inherit;">Gra√ßas a isso, a l√≥gica da aplica√ß√£o consiste inteiramente em fun√ß√µes puras, como fun√ß√µes </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com essa abordagem para escrever aplicativos, a maneira de pensar sobre software est√° mudando. </font><font style="vertical-align: inherit;">O trabalho agora come√ßa n√£o com o diagrama UML de interfaces e opera√ß√µes, mas com os pr√≥prios dados. </font><font style="vertical-align: inherit;">Existem algumas semelhan√ßas com o design orientado a dados. </font><font style="vertical-align: inherit;">√â verdade que o design orientado a dados geralmente √© usado para obter o m√°ximo desempenho; aqui, al√©m da velocidade, buscamos simplicidade e corre√ß√£o. </font><font style="vertical-align: inherit;">A √™nfase √© um pouco diferente, mas h√° semelhan√ßas importantes na metodologia.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> index = <span class="hljs-keyword">int</span>;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> coord<font></font>
{<font></font>
    index row = {};<font></font>
    index col = {};<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">using</span> line = immer::flex_vector&lt;<span class="hljs-keyword">char</span>&gt;;
<span class="hljs-keyword">using</span> text = immer::flex_vector&lt;line&gt;;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> file<font></font>
{<font></font>
    immer::box&lt;std::<span class="hljs-keyword">string</span>&gt; name;<font></font>
    text content;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> snapshot<font></font>
{<font></font>
    text content;<font></font>
    coord cursor;<font></font>
};<font></font>
 <font></font>
<span class="hljs-keyword">struct</span> buffer<font></font>
{<font></font>
    file <span class="hljs-keyword">from</span>;<font></font>
    text content;<font></font>
    coord cursor;<font></font>
    coord scroll;<font></font>
    std::optional&lt;coord&gt; selection_start;<font></font>
    immer::vector&lt;snapshot&gt; history;<font></font>
    std::optional&lt;std::size_t&gt; history_pos;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> application<font></font>
{<font></font>
    buffer current;<font></font>
    key_map keys;<font></font>
    key_seq input;<font></font>
    immer::vector&lt;text&gt; clipboard;<font></font>
    immer::vector&lt;message&gt; messages;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> action { key_code key; coord size; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acima est√£o os principais tipos de dados de nosso aplicativo. O corpo principal do aplicativo consiste em </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flex_vector e flex_vector </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o qual voc√™ pode executar uma opera√ß√£o de jun√ß√£o. A seguir, </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© o vetor em que ele √© armazenado </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Como voc√™ pode ver, esta √© uma representa√ß√£o muito simples do texto. </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">armazenado com a ajuda </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de um nome, ou seja, um endere√ßo no sistema de arquivos e, na verdade </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Como </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizado outro tipo, um simples, mas muito √∫til: </font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este √© um cont√™iner de elemento √∫nico. Ele permite que voc√™ coloque uma pilha e mova um objeto, copiando que pode consumir muitos recursos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro tipo importante: </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Com base nesse tipo, uma fun√ß√£o de cancelamento est√° ativa. Ele cont√©m um documento (no formato</font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e posi√ß√£o do cursor (coord). Isso permite que voc√™ retorne o cursor para a posi√ß√£o em que estava durante a edi√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O pr√≥ximo tipo √© </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este √© um termo do vim e do emacs, pois os documentos abertos s√£o chamados l√°. Em </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h√° um arquivo a partir do qual o texto foi baixado, bem como o conte√∫do do texto - isto permite que voc√™ para verificar as altera√ß√µes no documento. Para destacar parte do texto, h√° uma vari√°vel opcional </font></font><code>selection_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicando o in√≠cio da sele√ß√£o. O vetor de </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© a hist√≥ria do texto. Observe que n√£o usamos o padr√£o de equipe; o hist√≥rico consiste apenas em estados. Finalmente, se o cancelamento acabou de ser conclu√≠do, precisamos de um √≠ndice de posi√ß√£o no hist√≥rico do estado </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O pr√≥ximo tipo: </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ele cont√©m um documento aberto (buffer) </font></font><code>key_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font><code>key_seq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para atalhos de teclado, assim como um vetor da </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√°rea de transfer√™ncia e outro vetor para mensagens exibidas na parte inferior da tela. </font><font style="vertical-align: inherit;">At√© o momento, na vers√£o de estr√©ia do aplicativo, haver√° apenas um encadeamento e um tipo de a√ß√£o que recebe entrada </font></font><code>key_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>coord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Provavelmente, muitos de voc√™s j√° est√£o pensando em como implementar essas opera√ß√µes. </font><font style="vertical-align: inherit;">Se tomadas por valor e retornadas por valor, na maioria dos casos as opera√ß√µes s√£o bastante simples. </font><font style="vertical-align: inherit;">O c√≥digo do meu editor de texto √© publicado no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , para que voc√™ possa ver como ele realmente se parece. </font><font style="vertical-align: inherit;">Agora vou me debru√ßar em detalhes apenas no c√≥digo que implementa a fun√ß√£o de cancelamento.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancelar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escrever corretamente um cancelamento sem a infraestrutura apropriada n√£o √© t√£o simples. No meu editor, eu o implementei de acordo com as linhas do emacs, primeiro algumas palavras sobre seus princ√≠pios b√°sicos. O comando return est√° faltando aqui e, gra√ßas a isso, voc√™ n√£o pode perder seu emprego. Se for necess√°rio um retorno, qualquer altera√ß√£o ser√° feita no texto e todas as a√ß√µes de cancelamento se tornar√£o novamente parte do hist√≥rico de cancelamentos.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/4z/j_/s04zj_sia6mzw8reywkbznlhlem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este princ√≠pio est√° descrito acima. O losango vermelho aqui mostra uma posi√ß√£o na hist√≥ria: se um cancelamento simplesmente n√£o foi conclu√≠do, o losango vermelho est√° sempre no final. Se voc√™ cancelar, o diamante retornar√° um estado, mas, ao mesmo tempo, outro estado ser√° adicionado ao final da fila - o mesmo que o usu√°rio v√™ atualmente (S3). Se voc√™ cancelar novamente e retornar ao estado S2, o estado S2 ser√° adicionado ao final da fila. Se agora o usu√°rio fizer algum tipo de altera√ß√£o, ela ser√° adicionada ao final da fila como um novo estado de S5 e um losango ser√° movido para ele. Agora, ao desfazer a√ß√µes passadas, as a√ß√µes desfazer anteriores ser√£o roladas primeiro. Para implementar esse sistema de cancelamento, basta o seguinte c√≥digo:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">buffer <span class="hljs-title">record</span>(<span class="hljs-params">buffer before, buffer after</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (before.content != after.content) {<font></font>
        after.history = after.history.push_back({before.content, before.cursor});<font></font>
        <span class="hljs-keyword">if</span> (before.history_pos == after.history_pos)<font></font>
            after.history_pos = std::nullopt;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> after;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">buffer <span class="hljs-title">undo</span>(<span class="hljs-params">buffer buf</span>)</span><font></font>
{<font></font>
    auto idx = buf.history_pos.value_or(buf.history.size());<font></font>
    <span class="hljs-keyword">if</span> (idx &gt; <span class="hljs-number">0</span>) {<font></font>
        auto restore = buf.history[--idx];<font></font>
        buf.content = restore.content;<font></font>
        buf.cursor = restore.cursor;<font></font>
        buf.history_pos = idx;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> buf;<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem duas a√ß√µes </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realizada durante qualquer opera√ß√£o. Isso √© muito conveniente, pois n√£o precisamos saber se ocorreu alguma edi√ß√£o do documento. A fun√ß√£o √© transparente para a l√≥gica do aplicativo. Ap√≥s qualquer a√ß√£o, a fun√ß√£o verifica se o documento foi alterado. Se uma altera√ß√£o ocorreu, o </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conte√∫do e a posi√ß√£o do cursor s√£o </font><font style="vertical-align: inherit;">executados </font></font><code>history</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se a a√ß√£o n√£o levou a uma altera√ß√£o </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ou seja, a entrada recebida </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o </font><font style="vertical-align: inherit;">√© </font><font style="vertical-align: inherit;">causada pela a√ß√£o de cancelamento), </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um valor √© atribu√≠do </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se necess√°rio </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, verificamos </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se n√£o tem sentido, consideramos que </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est√° no final da hist√≥ria. Se o hist√≥rico de cancelamentos n√£o estiver vazio (ou seja,</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o no in√≠cio da hist√≥ria), o cancelamento √© realizado. </font><font style="vertical-align: inherit;">O conte√∫do e o cursor atuais s√£o substitu√≠dos e alterados </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A irrevogabilidade da opera√ß√£o de cancelamento √© alcan√ßada pela fun√ß√£o </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que tamb√©m √© chamada durante a opera√ß√£o de cancelamento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, temos uma opera√ß√£o </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que ocupa 10 linhas de c√≥digo e que sem altera√ß√µes (ou com altera√ß√µes m√≠nimas) pode ser usada em quase qualquer outro aplicativo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viagem no tempo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobre viagens no tempo. Como veremos agora, este √© um t√≥pico relacionado ao cancelamento. Demonstrarei o trabalho de uma estrutura que adicionar√° funcionalidade √∫til a qualquer aplicativo com arquitetura semelhante. A estrutura aqui √© chamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig-debug</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esta vers√£o do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inclui alguns recursos de depura√ß√£o. Agora, no navegador, voc√™ pode abrir o depurador, no qual pode examinar o estado do aplicativo.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dy/ba/7x/dyba7xjocwgjjmqvayinlfwx0y4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vimos que a √∫ltima a√ß√£o foi redimensionada, porque eu abri uma nova janela e meu gerenciador de janelas redimensionou automaticamente a janela j√° aberta. Obviamente, para serializa√ß√£o autom√°tica em JSON, eu tive que adicionar anota√ß√µes para struct da biblioteca de reflex√£o especial. Mas o resto do sistema √© bastante universal, pode ser conectado a qualquer aplicativo semelhante. Agora, no navegador, voc√™ pode ver todas as a√ß√µes conclu√≠das. Obviamente, existe um estado inicial que n√£o tem a√ß√£o. Este √© o estado que estava antes do download. Al√©m disso, clicando duas vezes, posso retornar o aplicativo ao seu estado anterior. Essa √© uma ferramenta de depura√ß√£o muito √∫til que permite rastrear a ocorr√™ncia de um mau funcionamento no aplicativo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ estiver interessado, pode ouvir meu relat√≥rio sobre o CPPCON 19, Os valores mais valiosos, examinarei esse depurador em detalhes. </font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/_oBx_NbLghY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, a arquitetura baseada em valor √© discutida em mais detalhes l√°. </font><font style="vertical-align: inherit;">Nele, tamb√©m digo como implementar a√ß√µes e organiz√°-las hierarquicamente. </font><font style="vertical-align: inherit;">Isso garante a modularidade do sistema e elimina a necessidade de manter tudo em uma grande fun√ß√£o de atualiza√ß√£o. </font><font style="vertical-align: inherit;">Al√©m disso, esse relat√≥rio fala sobre assincronia e downloads de arquivos multithread. </font><font style="vertical-align: inherit;">H√° outra vers√£o deste relat√≥rio em que meia hora de material adicional s√£o estruturas de dados imut√°veis ‚Äã‚Äãp√≥s-modernas.</font></font><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/y_m0ce1rzRI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumir</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu acho que √© hora de fazer um balan√ßo. Vou citar Andy Wingo - ele √© um excelente desenvolvedor, dedicou muito tempo ao V8 e compiladores em geral; finalmente, ele est√° envolvido no suporte ao Guile, na implementa√ß√£o do Scheme for GNU. Recentemente, ele escreveu em seu Twitter: ‚ÄúPara alcan√ßar uma ligeira acelera√ß√£o do programa, medimos todas as pequenas altera√ß√µes e deixamos apenas aquelas que d√£o um resultado positivo. Mas realmente alcan√ßamos uma acelera√ß√£o significativa, cegamente, investindo muito esfor√ßo, sem ter 100% de confian√ßa e guiados apenas pela intui√ß√£o. Que dicotomia estranha.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece-me que os desenvolvedores de C ++ est√£o tendo sucesso no primeiro g√™nero. </font><font style="vertical-align: inherit;">D√™-nos um sistema fechado e n√≥s, armados com nossas ferramentas, espremeremos tudo o que for poss√≠vel. </font><font style="vertical-align: inherit;">Mas no segundo g√™nero n√£o estamos acostumados a trabalhar. </font><font style="vertical-align: inherit;">Obviamente, a segunda abordagem √© mais arriscada e muitas vezes leva a um desperd√≠cio de grande esfor√ßo. </font><font style="vertical-align: inherit;">Por outro lado, reescrevendo completamente um programa, ele pode ser facilitado e r√°pido. </font><font style="vertical-align: inherit;">Espero ter conseguido convenc√™-lo a pelo menos tentar esta segunda abordagem.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente falou na confer√™ncia C ++ Russia 2019 Moscow e falou sobre estruturas de dados que permitem fazer coisas interessantes. </font><font style="vertical-align: inherit;">Parte da magia dessas estruturas est√° na elis√£o de c√≥pias - √© sobre isso que </font><font style="vertical-align: inherit;">Anton Polukhin e Roman Rusyaev </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falar√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na pr√≥xima confer√™ncia </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Siga as atualiza√ß√µes do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programa</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no site.</font></font></blockquote></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt487100/">https://habr.com/ru/post/pt487100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt487090/index.html">Um novo n√≠vel de otimiza√ß√£o do Windows</a></li>
<li><a href="../pt487092/index.html">Modelando processos de neg√≥cios como parte de um projeto de implementa√ß√£o de sistema ERP</a></li>
<li><a href="../pt487094/index.html">Reprocessando eventos recebidos de Kafka</a></li>
<li><a href="../pt487096/index.html">Trechos. Como facilitar o processo de trabalhar com a documenta√ß√£o</a></li>
<li><a href="../pt487098/index.html">Desenhar com formigas: imagens procedurais usando algoritmos de otimiza√ß√£o de col√¥nias de formigas</a></li>
<li><a href="../pt487106/index.html">Verificador RunUO do analisador PVS-Studio</a></li>
<li><a href="../pt487108/index.html">Perfil de jogador para celular: MyTracker Research</a></li>
<li><a href="../pt487110/index.html">Slurm SRE. Uma experi√™ncia completa com especialistas da Booking.com e do Google.com</a></li>
<li><a href="../pt487112/index.html">Edge of Madness: O c√≠rculo b√°sico</a></li>
<li><a href="../pt487116/index.html">Por que a disc√≥rdia migra de Go para Rust</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>