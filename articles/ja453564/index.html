<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📜 🏽 🥕 実現する-Unityでロジックゲームを開発する 🍙 🥊 🔜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="2人の開発者と1人のアーティストによる単純なモバイルゲームの開発プロセスを共有したいと思います。この記事は、主に技術的な実装の説明です。
 注意、たくさんのテキスト！
 
 記事はガイドでもレッスンでもありませんが、読者が役立つ情報を学んでくれることを願っています。Unityに慣れ、プログラミングの...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>実現する-Unityでロジックゲームを開発する</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453564/"><img src="https://habrastorage.org/webt/4k/h-/6e/4kh-6e4-iwvtuaz42eqb2gg81iu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2人の開発者と1人のアーティストによる単純なモバイルゲームの開発プロセスを共有したいと思います。</font><font style="vertical-align: inherit;">この記事は、主に技術的な実装の説明です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意、たくさんのテキスト！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事はガイドでもレッスンでもありませんが、読者が役立つ情報を学んでくれることを願っています。</font><font style="vertical-align: inherit;">Unityに慣れ、プログラミングの経験がある開発者向けに設計されています。</font></font><br>
<a name="habracut"></a><br>
<a name="Content"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ：</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイデア</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームプレイ</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストーリー</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">コア</font></a></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><br>
 <ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電気要素</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソルバー</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ElementsProvider</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CircuitGenerator</font></font></a></li>
</ol><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームクラス</font></font></a><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発アプローチとDI</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電気要素</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム管理</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベルローディング</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カットシーン</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加のゲームプレイ</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">収益化</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーインターフェース</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カメラの配置と図</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配色</font></font></a></li>
</ol><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エディタ拡張</font></font><br>
</a><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発生器</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソルバー</font></font></a></li>
</ol><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有用</font></font></a><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asserthelp</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SceneObjectsHelper</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチンスターター</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ギズモ</font></font></a></li>
</ol><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発の要約</font></font></a><br>
<br>
<a name="Idea"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考え</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
短期間でシンプルなモバイルゲームを作るというアイデアが</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">浮かびまし</font></a><font style="vertical-align: inherit;">た。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
条件：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームの実装が簡単</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小アート要件</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">短い開発期間（数か月）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ作成の簡単な自動化（レベル、場所、ゲーム要素）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームが有限数のレベルで構成されている場合、レベルをすばやく作成します</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
決定するために、そして実際には何をしますか？</font><font style="vertical-align: inherit;">結局のところ、アイデアはゲームのアイデアではなく、ゲームを作るために生まれました。</font><font style="vertical-align: inherit;">アプリストアからインスピレーションを求めることになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の項目に追加されます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームはプレイヤーの間で一定の人気を持っている必要があります（ダウンロード数+評価）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリストアは同様のゲームで混雑してはいけません</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
論理ゲートに基づくゲームプレイでゲームが見つかりました。</font><font style="vertical-align: inherit;">類似するものは多数ありませんでした。ゲームのダウンロード数は多く、評価も高くなっています。</font><font style="vertical-align: inherit;">それにもかかわらず、試した後、ゲームで考慮できるいくつかの欠点がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームのゲームプレイは、レベルが多くの入力と出力を持つデジタル回路であることです。</font><font style="vertical-align: inherit;">プレーヤーは、出力が論理1になるように入力の組み合わせを選択する必要があります。非常に難しく聞こえることはありません。</font><font style="vertical-align: inherit;">ゲームは自動的にレベルを生成することもあり、レベルの作成を自動化する機能は非常にシンプルに聞こえませんが、それを示唆しています。</font><font style="vertical-align: inherit;">ゲームはまた、私が本当に好きだった学習にも適しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長所：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームプレイの技術的なシンプルさ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動テストで簡単にテストできます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベルを自動生成する機能</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイナス：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初にレベルを作成する必要があります</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、インスピレーションを与えたゲームの欠陥を探ります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18：9のようなカスタムアスペクト比に適合していません</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">難しいレベルをスキップしたり、ヒントを得たりする方法はありません</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レビューでは、少数のレベルについて不満がありました</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レビューは要素の多様性の欠如について不満を述べました</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームの計画に進みます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準の論理ゲート（AND、NAND、OR、NOR、XOR、XNOR、NOR、NOT）を使用します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲートは、テキストの指定ではなく画像で表示されます。これにより、区別が容易になります。</font><font style="vertical-align: inherit;">要素には標準のANSI表記があるため、使用します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの入力を1つの出力に接続するスイッチを破棄します。</font><font style="vertical-align: inherit;">自分でクリックする必要があり、実際のデジタル要素には少し適合しないという事実によります。</font><font style="vertical-align: inherit;">はい、チップ内のトグルスイッチを想像するのは困難です。</font></font></li>
<li>    .</li>
<li>                .</li>
<li>  :  +  .</li>
<li>    .</li>
</ul><br>
<a name="Gameplay"></a><h2></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
モード1：プレーヤーは回路を受け取り、入力で値を変更するアクセス権を持っています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モード2：プレーヤーは、要素を変更できるが入力で値を変更できない回路を受け取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームプレイは事前に準備されたレベルの形になります。レベルをクリアした後、プレイヤーは何らかの結果を得る必要があります。これは、パッセージの結果に応じて、従来の3つの星の形で行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パフォーマンスインジケーターの可能性：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクションの数：ゲームの要素との対話ごとにカウンターが増加します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元の状態との結果の状態の違いの数。プレーヤーが完了しなければならなかった試行回数は考慮されません。残念ながら、それは2番目の体制には適合しません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じモードをランダムレベル生成で追加するとよいでしょう。</font><font style="vertical-align: inherit;">しかし、今のところ、後で延期します。</font></font><br>
<br>
<a name="Plot"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロット</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ゲームプレイについて考え、開発を始めると、ゲームを改善するためのさまざまなアイデアが現れました。そして、プロットを追加するという、十分に興味深いアイデアが現れました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは回路を設計するエンジニアについてです。悪くはありませんが、完全ではありません。おそらく、プレイヤーの行動に基づいてチップの製造を表示する価値はありますか？どういうわけかルーティン、理解できる単純な結果はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考え！エンジニアは彼の論理回路を使用してクールなロボットを開発します。ロボットはかなりシンプルで理解しやすいものであり、ゲームプレイに完全に適合します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の段落「アートの最小要件」を覚えていますか？プロットのカットシーンに適合しないものがあります。それから、おなじみのアーティストが助けに来て、私たちを助けることに同意しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、カットシーンのフォーマットとゲームへの統合について決定しましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロットは、スコアリングのないカットシーンまたはローカリゼーションの問題を取り除き、理解を単純化し、多くの場合、音のないモバイルデバイスでの多くの再生を行うテキストの説明として表示する必要があります。</font><font style="vertical-align: inherit;">ゲームはデジタル回路の非常に現実的な要素です。つまり、これを現実と関連付けることはかなり可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カットシーンとレベルは別々のシーンである必要があります。</font><font style="vertical-align: inherit;">特定のレベルの前に、特定のシーンが読み込まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、タスクが設定され、実行するリソースがあり、作業が沸き始めています。</font></font><br>
<br>
<a name="Development"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
プラットフォームはすぐに特定され、Unityです。</font><font style="vertical-align: inherit;">はい、少しやりすぎですが、それでも私は彼女を知っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発中、コードはテストと同時に、またはその後も書き込まれます。</font><font style="vertical-align: inherit;">ただし、全体的な説明のために、テストは以下の別のセクションに配置されています。</font><font style="vertical-align: inherit;">現在のセクションでは、テストとは別に開発プロセスについて説明します。</font></font><br>
<br>
<a name="Core"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">芯</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ゲームプレイのコアはかなりシンプルでエンジンに縛られていないように見えるため、C＃コードの形式でデザインを開始しました。</font><font style="vertical-align: inherit;">別のコアコアロジックを選択できるようです。</font><font style="vertical-align: inherit;">別のプロジェクトで取り出してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UnityはC＃ソリューションで動作し、内部のプロジェクトは通常の.Net開発者には少し珍しいです。.slnおよび.csprojファイルはUnity自体によって生成され、これらのファイル内の変更はUnity側での検討のために受け入れられません。</font><font style="vertical-align: inherit;">彼は単にそれらを上書きし、すべての変更を削除します。</font><font style="vertical-align: inherit;">新しいプロジェクトを作成するには、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブリ定義</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルを</font><font style="vertical-align: inherit;">使用する必要があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b2/84/92/b28492ps5o-_mv62mdvo1frk4l8.png"><br>
<br>
<img src="https://habrastorage.org/webt/vd/xk/_k/vdxk_k9ydjfhu1aiee8ctlx3eau.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityは適切な名前のプロジェクトを生成します。</font><font style="vertical-align: inherit;">.asmdefファイルのあるフォルダーにあるものはすべて、このプロジェクトとアセンブリに適用されます。</font></font><br>
<br>
<a name="CoreElectricalElements"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電気要素</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
タスクは、論理要素の相互の相互作用をコードで記述することです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素は複数の入力と複数の出力を持つことができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素の入力は別の要素の出力に接続する必要があります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素自体には独自のロジックが含まれている必要があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
始めましょう。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には独自の操作ロジックが含まれており、その入力にリンクしています。</font><font style="vertical-align: inherit;">要素から値を要求する場合、入力から値を取得し、それらにロジックを適用して、結果を返します。</font><font style="vertical-align: inherit;">複数の出力が存在する可能性があるため、特定の出力の値が要求されます。デフォルトは0です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入力で値を取得するために、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入力コネクタ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pがあり、それは別の-出力コネクタへのリンクを格納します。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出力コネクタ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は特定の要素を参照し、その要素へのリンクを保存します。値を要求するとき、要素から要求します。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/am/7q/yo/am7qyonro-bohnomthogk8qy8o0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
矢印はデータの方向、反対方向の要素の依存関係を示します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コネクタのインターフェースを定義します。</font><font style="vertical-align: inherit;">あなたはそれから価値を得ることができます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IConnector</span><font></font>
{<font></font>
    <span class="hljs-keyword">bool</span> Value { <span class="hljs-keyword">get</span>; }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それを別のコネクタに接続するにはどうすればよいですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より多くのインターフェースを定義します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IInputConnector</span> : <span class="hljs-title">IConnector</span><font></font>
{<font></font>
   IOutputConnector ConnectedOtherConnector { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IInputConnectorは入力コネクタであり、別のコネクタへのリンクがあります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IOutputConnector</span> : <span class="hljs-title">IConnector</span><font></font>
{<font></font>
   IElectricalElement Element { <span class="hljs-keyword">set</span>; <span class="hljs-keyword">get</span>; }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力コネクタは、値を要求する要素を参照します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IElectricalElement</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetValue</span>(<span class="hljs-params"><span class="hljs-keyword">byte</span> number = <span class="hljs-number">0</span></span>)</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
電気要素には、特定の出力の値を返すメソッドが含まれている必要があります。numberは出力の番号です。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">論理電圧レベルのみを送信しますが、IElectricalElementと呼びましたが、ロジックをまったく追加せず、単に導体のように値を伝達するだけの要素にすることもできます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは実装に移りましょう</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InputConnector</span> : <span class="hljs-title">IInputConnector</span><font></font>
{<font></font>
        <span class="hljs-keyword">public</span> IOutputConnector ConnectedOtherConnector { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Value<font></font>
        {<font></font>
            <span class="hljs-keyword">get</span><font></font>
            {                <font></font>
                <span class="hljs-keyword">return</span> ConnectedOtherConnector?.Value ?? <span class="hljs-literal">false</span>;<font></font>
            }<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
受信コネクタが接続されていない可能性があります。その場合、falseが返されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OutputConnector</span> : <span class="hljs-title">IOutputConnector</span><font></font>
{<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">byte</span> number;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OutputConnector</span>(<span class="hljs-params"><span class="hljs-keyword">byte</span> number = <span class="hljs-number">0</span></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">this</span>.number = number;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> IElectricalElement Element { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Value =&gt; Element.GetValue(number);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力には、その要素へのリンクと、要素に関連するその番号が必要です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、この番号を使用して、要素から値を要求します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ElectricalElementBase</span><font></font>
{<font></font>
        <span class="hljs-keyword">public</span> IInputConnector[] Input { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての要素の基本クラスには、入力の配列のみが含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素の実装例：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">And</span> : <span class="hljs-title">ElectricalElementBase</span>, <span class="hljs-title">IElectricalElement</span><font></font>
{<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GetValue</span>(<span class="hljs-params"><span class="hljs-keyword">byte</span> number = <span class="hljs-number">0</span></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">bool</span> outputValue = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> (Input?.Length &gt; <span class="hljs-number">0</span>)<font></font>
            {<font></font>
                outputValue = Input[<span class="hljs-number">0</span>].Value;<font></font>
<font></font>
                <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> Input)<font></font>
                {<font></font>
                    outputValue &amp;= item.Value;<font></font>
                }<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> outputValue;<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装は、ハード真理値表のない論理演算に完全に基づいています。おそらくテーブルほど明示的ではありませんが、柔軟性があり、任意の数の入力で機能します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての論理ゲートには1つの出力があるため、出力の値は入力番号に依存しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
反転要素は次のように作成されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Nand</span> : <span class="hljs-title">And</span>, <span class="hljs-title">IElectricalElement</span><font></font>
{<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> new <span class="hljs-keyword">bool</span> <span class="hljs-title">GetValue</span>(<span class="hljs-params"><span class="hljs-keyword">byte</span> number = <span class="hljs-number">0</span></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> !<span class="hljs-keyword">base</span>.GetValue(number);<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、GetValueメソッドはオーバーライドされているのではなく、仮想的にオーバーライドされていることに注意してください。</font><font style="vertical-align: inherit;">これは、NandがAndに保存した場合、Andのように動作し続けるというロジックに基づいて行われます。</font><font style="vertical-align: inherit;">コンポジションを適用することも可能でしたが、これには余計なコードが必要になるため、あまり意味がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のバルブに加えて、次の要素が作成されました：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソース-0または1の定数値ソース。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
導体-まったく同じOR導体、用途がわずかに異なるだけです。生成を参照してください。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AlwaysFalse-2番目のモードに必要な常に0を返します。</font></font><br>
<br>
<a name="Solver"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソルバー</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
次に、クラスは、回路の出力で1を生成する組み合わせを自動的に見つけるのに役立ちます。</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISolver</span><font></font>
    {<font></font>
        ICollection&lt;<span class="hljs-keyword">bool</span>[]&gt; GetSolutions(IElectricalElement root, <span class="hljs-keyword">params</span> Source[] sources);<font></font>
    }<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solver</span> : <span class="hljs-title">ISolver</span><font></font>
    {<font></font>
        <span class="hljs-keyword">public</span> ICollection&lt;<span class="hljs-keyword">bool</span>[]&gt; GetSolutions(IElectricalElement root, <span class="hljs-keyword">params</span> Source[] sources)<font></font>
        {<font></font>
            <span class="hljs-comment">// max value can be got with this count of bits(sources count), also it's count of combinations -1</span>
            <span class="hljs-comment">// for example 8 bits provide 256 combinations, and max value is 255</span>
            <span class="hljs-keyword">int</span> maxValue = Pow(sources.Length);<font></font>
<font></font>
            <span class="hljs-comment">// inputs that can solve circuit</span>
            <span class="hljs-keyword">var</span> rightInputs = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">bool</span>[]&gt;();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxValue; i++)<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> inputs = GetBoolArrayFromInt(i, sources.Length);
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; sources.Length; j++)<font></font>
                {<font></font>
                    sources[j].Value = inputs[j];<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (root.GetValue())<font></font>
                {<font></font>
                    rightInputs.Add(inputs);<font></font>
                }<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> rightInputs;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> power</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">int</span> x = <span class="hljs-number">2</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; power; i++)<font></font>
            {<font></font>
                x *= <span class="hljs-number">2</span>;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> x;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span>[] <span class="hljs-title">GetBoolArrayFromInt</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>, <span class="hljs-keyword">int</span> length</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> bitArray = <span class="hljs-keyword">new</span> BitArray(<span class="hljs-keyword">new</span>[] {<span class="hljs-keyword">value</span>});
            <span class="hljs-keyword">var</span> boolArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">bool</span>[length];<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i—)<font></font>
            {<font></font>
                boolArray[i] = bitArray[i];<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> boolArray;<font></font>
        }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策は総当たりです。</font><font style="vertical-align: inherit;">このために、ソースの数に等しい量のビットのセットで表現できる最大数が決定されます。</font><font style="vertical-align: inherit;">つまり、4つのソース= 4ビット=最大数15です。0から15までのすべての数値を並べ替えます。</font></font><br>
<br>
<a name="ElementsProvider"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ElementsProvider</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
生成の便宜上、各要素を番号で識別することを決定し、これを行うために、IElementsProviderインターフェイスを使用してElementsProviderクラスを作成しました。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IElementsProvider</span><font></font>
{<font></font>
   IList&lt;Func&lt;IElectricalElement&gt;&gt; Gates { <span class="hljs-keyword">get</span>; }<font></font>
   IList&lt;Func&lt;IElectricalElement&gt;&gt; Conductors { <span class="hljs-keyword">get</span>; }<font></font>
   IList&lt;ElectricalElementType&gt; GateTypes { <span class="hljs-keyword">get</span>; }<font></font>
   IList&lt;ElectricalElementType&gt; ConductorTypes { <span class="hljs-keyword">get</span>; }<font></font>
}<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ElementsProvider</span> : <span class="hljs-title">IElementsProvider</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> IList&lt;Func&lt;IElectricalElement&gt;&gt; Gates { <span class="hljs-keyword">get</span>; } = <span class="hljs-keyword">new</span> List&lt;Func&lt;IElectricalElement&gt;&gt;<font></font>
   {<font></font>
       () =&gt; <span class="hljs-keyword">new</span> And(),<font></font>
       () =&gt; <span class="hljs-keyword">new</span> Nand(),<font></font>
       () =&gt; <span class="hljs-keyword">new</span> Or(),<font></font>
       () =&gt; <span class="hljs-keyword">new</span> Nor(),<font></font>
       () =&gt; <span class="hljs-keyword">new</span> Xor(),<font></font>
       () =&gt; <span class="hljs-keyword">new</span> Xnor()<font></font>
   };<font></font>
<font></font>
   <span class="hljs-keyword">public</span> IList&lt;Func&lt;IElectricalElement&gt;&gt; Conductors { <span class="hljs-keyword">get</span>; } = <span class="hljs-keyword">new</span> List&lt;Func&lt;IElectricalElement&gt;&gt;<font></font>
   {<font></font>
       () =&gt; <span class="hljs-keyword">new</span> Conductor(),<font></font>
       () =&gt; <span class="hljs-keyword">new</span> Not()<font></font>
   };<font></font>
<font></font>
   <span class="hljs-keyword">public</span> IList&lt;ElectricalElementType&gt; GateTypes { <span class="hljs-keyword">get</span>; } = <span class="hljs-keyword">new</span> List&lt;ElectricalElementType&gt;<font></font>
   {<font></font>
       ElectricalElementType.And,<font></font>
       ElectricalElementType.Nand,<font></font>
       ElectricalElementType.Or,<font></font>
       ElectricalElementType.Nor,<font></font>
       ElectricalElementType.Xor,<font></font>
       ElectricalElementType.Xnor<font></font>
   };<font></font>
<font></font>
   <span class="hljs-keyword">public</span> IList&lt;ElectricalElementType&gt; ConductorTypes { <span class="hljs-keyword">get</span>; } = <span class="hljs-keyword">new</span> List&lt;ElectricalElementType&gt;<font></font>
   {<font></font>
       ElectricalElementType.Conductor,<font></font>
       ElectricalElementType.Not<font></font>
   };<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の2つのリストは、指定された数のアイテムを与える工場のようなものです。</font><font style="vertical-align: inherit;">最後の2つのリストは、Unityの機能のために使用する必要がある松葉杖です。</font><font style="vertical-align: inherit;">それについてさらに。</font></font><br>
<br>
<a name="CircuitGenerator"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CircuitGenerator</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
現在、開発の最も難しい部分は回路の生成です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクは、スキーマのリストを生成することです。スキーマのリストから、エディターで目的のスキームを選択できます。</font><font style="vertical-align: inherit;">生成は単純なバルブにのみ必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スキームの特定のパラメーターが設定されます。これらは、レイヤーの数（要素の水平線）とレイヤー内の要素の最大数です。</font><font style="vertical-align: inherit;">また、回路を生成するために必要なゲートを決定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のアプローチは、タスクを2つの部分（構造体の生成とオプションの選択）に分割することでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造ジェネレーターは、論理エレメントの位置と接続を決定します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バリアントジェネレーターは、位置の要素の有効な組み合わせを選択します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structuregener</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造は、論理要素の層と導体/インバータの層で構成されています。</font><font style="vertical-align: inherit;">構造全体には実際の要素は含まれていませんが、それらのコンテナが含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナはIElectricalElementから継承されたクラスで、内部には有効な要素のリストが含まれており、それらを切り替えることができます。</font><font style="vertical-align: inherit;">各アイテムには、リスト内に独自の番号があります。</font></font><br>
<br>
<pre><code class="cs hljs">ElectricalElementContainer : ElectricalElementBase, IElectricalElement</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナは、リスト内の項目の1つに「それ自体」を設定できます。</font><font style="vertical-align: inherit;">初期化中に、アイテムを作成するデリゲートのリストを提供する必要があります。</font><font style="vertical-align: inherit;">内部では、すべてのデリゲートを呼び出してアイテムを取得します。</font><font style="vertical-align: inherit;">次に、この要素の特定のタイプを設定できます。これにより、内部要素がコンテナーと同じ入力に接続され、コンテナーからの出力は、この要素の出力から取得されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wq/kt/bn/wqktbn6x7esbfnqxkuwh606qvqa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素のリストを設定する方法：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetElements</span>(<span class="hljs-params">IList&lt;Func&lt;IElectricalElement&gt;&gt; elements</span>)</span><font></font>
{<font></font>
            Elements = <span class="hljs-keyword">new</span> List&lt;IElectricalElement&gt;(elements.Count);
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> elements)<font></font>
            {<font></font>
                Elements.Add(item());<font></font>
            }<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、この方法でタイプを設定できます：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetType</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> number</span>)</span><font></font>
{<font></font>
            <span class="hljs-keyword">if</span> (isInitialized == <span class="hljs-literal">false</span>)<font></font>
            {<font></font>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(UnitializedElementsExceptionMessage);<font></font>
            }<font></font>
<font></font>
            SelectedType = number;<font></font>
            RealElement = Elements[number];<font></font>
            ((ElectricalElementBase) RealElement).Input = Input;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後は指定アイテムとして動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の構造が回路用に作成されました。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CircuitStructure</span> : <span class="hljs-title">ICloneable</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> IDictionary&lt;<span class="hljs-keyword">int</span>, ElectricalElementContainer[]&gt; Gates;
   <span class="hljs-keyword">public</span> IDictionary&lt;<span class="hljs-keyword">int</span>, ElectricalElementContainer[]&gt; Conductors;
   <span class="hljs-keyword">public</span> Source[] Sources;
   <span class="hljs-keyword">public</span> And FinalDevice;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここのディクショナリは、レイヤ番号をキーに格納し、このレイヤのコンテナの配列を格納します。次はソースの配列とすべてが接続されている1つのFinalDeviceです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、構造ジェネレーターはコンテナーを作成し、それらを相互に接続します。これはすべて、下から上へのレイヤーで作成されます。一番下が最も幅が広い（ほとんどの要素）。上のレイヤーには半分の数の要素が含まれており、最小に達するまで続きます。上位層のすべての要素の出力は、最終的なデバイスに接続されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロジックエレメントレイヤーには、ゲートのコンテナが含まれています。導体の層には、1つの入力と出力を持つ要素があります。要素には、導体またはNO要素があります。コンダクターは入力に来たものを出力に送り、NOエレメントは出力で反転された値を返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初にソースの配列を作成します。生成はボトムアップで行われ、最初の導体層が生成され、次にロジックの層が生成され、その出力で再び導体が生成されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pq/bj/hs/pqbjhsbn3xxxi6r6wosryczrdjc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、そのようなスキームは非常に退屈です！私たちは私たちの生活をさらに簡素化したいと考え、生成された構造をより興味深いもの（複雑なもの）にすることを決定しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、「簡略化された」と言えば、これはあなたの人生を他の何かで複雑にすることを意味します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最大レベルの変更可能性を備えた回路を生成することは、面倒で、実際的ではない作業であることが判明しました。したがって、私たちのチームは次の基準を満たすことを行うことにしました</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。このタスクの開発にはそれほど時間はかかりませんでした。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変更された構造の多かれ少なかれ適切な生成。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指揮者の間に交差点はありませんでした。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長くてハードなプログラミングの結果、ソリューションは午後4時に作成されました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードと̶̶̶̶̶̶̶̶̶̶̶を見てみましょう。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで、OverflowArrayクラスが検出されます。</font><font style="vertical-align: inherit;">歴史的な理由から、これは基本的な構造生成の後に追加され、オプションの生成に関連しているため、下にあります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;CircuitStructure&gt; <span class="hljs-title">GenerateStructure</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> lines, <span class="hljs-keyword">int</span> maxElementsInLine, StructureModification modification</span>)</span><font></font>
{<font></font>
            <span class="hljs-keyword">var</span> baseStructure = GenerateStructure(lines, maxElementsInLine);<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lines; i++)<font></font>
            {<font></font>
                <span class="hljs-keyword">int</span> maxValue = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">int</span> branchingSign = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">if</span> (modification == StructureModification.All)<font></font>
                {<font></font>
                    maxValue = <span class="hljs-number">2</span>;<font></font>
                    branchingSign = <span class="hljs-number">2</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">int</span> lengthOverflowArray = baseStructure.Gates[(i * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>].Length;
                <span class="hljs-keyword">var</span> elementArray = <span class="hljs-keyword">new</span> OverflowArray(lengthOverflowArray, maxValue);<font></font>
<font></font>
                <span class="hljs-keyword">double</span> numberOfOption = Math.Pow(<span class="hljs-number">2</span>, lengthOverflowArray);
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; numberOfOption - <span class="hljs-number">1</span>; k++)<font></font>
                {<font></font>
                    elementArray.Increase();<font></font>
                    <span class="hljs-keyword">if</span> (modification == StructureModification.Branching || modification == StructureModification.All)<font></font>
                    {<font></font>
                        <span class="hljs-keyword">if</span> (!CheckOverflowArrayForAllConnection(elementArray, branchingSign, lengthOverflowArray))<font></font>
                        {<font></font>
                            <span class="hljs-keyword">continue</span>;<font></font>
                        }<font></font>
                    }<font></font>
<font></font>
                    <span class="hljs-comment">// Clone CircuitStructure</span>
                    <span class="hljs-keyword">var</span> structure = (CircuitStructure) baseStructure.Clone();<font></font>
<font></font>
                    ConfigureInputs(lines, structure.Conductors, structure.Gates);<font></font>
                    <span class="hljs-keyword">var</span> sources = AddSourcesLayer(structure.Conductors, maxElementsInLine);
                    <span class="hljs-keyword">var</span> finalElement = AddFinalElement(structure.Conductors);<font></font>
                    structure.Sources = sources;<font></font>
                    structure.FinalDevice = finalElement;<font></font>
<font></font>
                    <span class="hljs-keyword">int</span> key = (i * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<font></font>
<font></font>
                    ModifyStructure(structure, elementArray, key, modification);<font></font>
                    ClearStructure(structure);<font></font>
                    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> structure;<font></font>
                }<font></font>
            }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードを見た後、私はそれで何が起こっているのかを理解したいと思います。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
心配しないでください！</font><font style="vertical-align: inherit;">詳細のない簡単な説明はあなたを急がせます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず最初に、通常の（ベース）構造を作成します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> baseStructure = GenerateStructure(lines, maxElementsInLine);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、簡単なチェックの結果、分岐記号（branchingSign）を適切な値に設定しましたが、なぜこれが必要なのですか？</font><font style="vertical-align: inherit;">さらにそれは明らかになります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> maxValue = <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> branchingSign = <span class="hljs-number">1</span>;
<span class="hljs-keyword">if</span> (modification == StructureModification.All)<font></font>
{<font></font>
   maxValue = <span class="hljs-number">2</span>;<font></font>
   branchingSign = <span class="hljs-number">2</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、OverflowArrayの長さを決定して初期化します。</font></font><br>
<br>
<pre><code class="cs hljs"> <span class="hljs-keyword">int</span> lengthOverflowArray = baseStructure.Gates[(i * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>].Length;
 <span class="hljs-keyword">var</span> elementArray = <span class="hljs-keyword">new</span> OverflowArray(lengthOverflowArray, maxValue);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造の操作を続けるために、OverflowArrayの考えられるバリエーションの数を見つける必要があります。</font><font style="vertical-align: inherit;">これを行うには、次の行で適用された式があります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> lengthOverflowArray = baseStructure.Gates[(i * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>].Length;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、すべての「マジック」が実行され、このすべての序文があったネストされたループが始まります。最初に、配列の値を増やします。</font></font><br>
<br>
<pre><code class="cs hljs">elementArray.Increase();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 その後、検証チェックが表示され、その結果、さらに次の反復に進みます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">if</span> (modification == StructureModification.Branching || modification == StructureModification.All)<font></font>
{<font></font>
                        <span class="hljs-keyword">if</span> (!CheckOverflowArrayForAllConnection(elementArray, branchingSign, lengthOverflowArray))<font></font>
                        {<font></font>
                            <span class="hljs-keyword">continue</span>;<font></font>
                        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列が検証チェックに合格した場合、基本構造を複製します。</font><font style="vertical-align: inherit;">さらに多くの反復のために構造を変更するため、クローニングが必要です。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">// Clone CircuitStructure</span>
<span class="hljs-keyword">var</span> structure = (CircuitStructure) baseStructure.Clone();<font></font>
ConfigureInputs(lines, structure.Conductors, structure.Gates);<font></font>
<span class="hljs-keyword">var</span> sources = AddSourcesLayer(structure.Conductors, maxElementsInLine);
<span class="hljs-keyword">var</span> finalElement = AddFinalElement(structure.Conductors);<font></font>
structure.Sources = sources;<font></font>
structure.FinalDevice = finalElement;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、構造を変更し、不要な要素を削除します。</font><font style="vertical-align: inherit;">構造変更の結果、それらは不要になりました。</font></font><br>
<br>
<pre><code class="cs hljs">ModifyStructure(structure, elementArray, key, modification);<font></font>
ClearStructure(structure);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「どこか」の深部で実行される数十の小さな機能を分析するためのポイントの詳細はわかりません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バリアントジェネレータ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その中にあるはずの構造体+要素をCircuitVariantと呼びます。 </font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> CircuitVariant<font></font>
{<font></font>
   <span class="hljs-keyword">public</span> CircuitStructure Structure;
   <span class="hljs-keyword">public</span> IDictionary&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>[]&gt; Gates;
   <span class="hljs-keyword">public</span> IDictionary&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>[]&gt; Conductors;
   <span class="hljs-keyword">public</span> IList&lt;<span class="hljs-keyword">bool</span>[]&gt; Solutions;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のフィールドは構造へのリンクです。次の2つのディクショナリは、キーがレイヤーの番号であり、値が構造内の場所にある要素の数を含む配列です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
組み合わせの選択に進みます。特定の数の有効なロジックエレメントとコンダクターを持つことができます。合計で6つの論理要素と2つの導体がある場合があります。6を</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基数とする数体系を想像して、各カテゴリの要素に対応する数字を取得できます。したがって、この16進数を増やすことで、要素のすべての組み合わせを調べることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、3桁の16進数は3つの要素になります。転送できる要素の数が6ではなく4であることを考慮に入れてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような数の放電について、私は構造を定義しました</font></font><br>
<a name="ClampedInt"></a><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> ClampedInt<font></font>
{<font></font>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Value<font></font>
        {<font></font>
            <span class="hljs-keyword">get</span> =&gt; <span class="hljs-keyword">value</span>;
            <span class="hljs-keyword">set</span> =&gt; <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = Mathf.Clamp(<span class="hljs-keyword">value</span>, <span class="hljs-number">0</span>, MaxValue);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> MaxValue;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClampedInt</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> maxValue</span>)</span><font></font>
        {<font></font>
            MaxValue = maxValue;<font></font>
            <span class="hljs-keyword">value</span> = <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">TryIncrease</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (Value + <span class="hljs-number">1</span> &lt;= MaxValue)<font></font>
            {<font></font>
                Value++;<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-comment">// overflow</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
        }<font></font>
}</code></pre><br>
<a name="OverflowArray"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次は奇妙な名前</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OverflowArrayを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持つクラス</font><font style="vertical-align: inherit;">です。その本質は、</font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ClampedInt</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">格納</font><font style="vertical-align: inherit;">し、オーバーフロー</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">が低</font></a></b><font style="vertical-align: inherit;">次で</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">発生した場合に</font></a></b><font style="vertical-align: inherit;">高次を増やし、それがすべてのセルで最大値に達するまで続きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ClampedIntに従って、対応するElectricalElementContainerの値が設定されます。したがって、すべての可能な組み合わせをソートすることが可能です。要素（たとえば、And（0）とXor（4））を含むスキームを生成する場合、要素1、2、3を含むすべてのオプションをソートする必要がないことに注意してください。このため、生成中に要素はローカル番号（たとえば、And = 0、Xor = 1）を取得し、その後、グローバル番号に変換されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、すべての要素で可能なすべての組み合わせを反復できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナの値が設定された後、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソルバー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して回路のソリューションがチェックされます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">回路が決定をパスすると、戻ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回路が生成された後、解の数がチェックされます。</font><font style="vertical-align: inherit;">制限を超えてはならず、完全に0または1からなる決定を下すべきではありません。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たくさんのコード</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IVariantsGenerator</span><font></font>
    {<font></font>
        <span class="hljs-function">IEnumerable&lt;CircuitVariant&gt; <span class="hljs-title">Generate</span>(<span class="hljs-params">IEnumerable&lt;CircuitStructure&gt; structures, ICollection&lt;<span class="hljs-keyword">int</span>&gt; availableGates, <span class="hljs-keyword">bool</span> useNot, <span class="hljs-keyword">int</span> maxSolutions = <span class="hljs-keyword">int</span>.MaxValue</span>)</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VariantsGenerator</span> : <span class="hljs-title">IVariantsGenerator</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ISolver solver;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IElementsProvider elementsProvider;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">VariantsGenerator</span>(<span class="hljs-params">ISolver solver,
                                 IElementsProvider elementsProvider</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">this</span>.solver = solver;
            <span class="hljs-keyword">this</span>.elementsProvider = elementsProvider;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;CircuitVariant&gt; <span class="hljs-title">Generate</span>(<span class="hljs-params">IEnumerable&lt;CircuitStructure&gt; structures,
                                                    ICollection&lt;<span class="hljs-keyword">int</span>&gt; availableGates,
                                                    <span class="hljs-keyword">bool</span> useNot,
                                                    <span class="hljs-keyword">int</span> maxSolutions = <span class="hljs-keyword">int</span>.MaxValue</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">bool</span> manyGates = availableGates.Count &gt; <span class="hljs-number">1</span>;
            <span class="hljs-keyword">var</span> availableLeToGeneralNumber = GetDictionaryFromAllowedElements(elementsProvider.Gates, availableGates);
            <span class="hljs-keyword">var</span> gatesList = GetElementsList(availableLeToGeneralNumber, elementsProvider.Gates);<font></font>
<font></font>
            <span class="hljs-keyword">var</span> availableConductorToGeneralNumber = useNot<font></font>
                ? GetDictionaryFromAllowedElements(elementsProvider.Conductors, <span class="hljs-keyword">new</span>[] {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>})<font></font>
                : GetDictionaryFromAllowedElements(elementsProvider.Conductors, <span class="hljs-keyword">new</span>[] {<span class="hljs-number">0</span>});<font></font>
<font></font>
            <span class="hljs-keyword">var</span> conductorsList = GetElementsList(availableConductorToGeneralNumber, elementsProvider.Conductors);<font></font>
<font></font>
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> structure <span class="hljs-keyword">in</span> structures)<font></font>
            {<font></font>
                InitializeCircuitStructure(structure, gatesList, conductorsList);<font></font>
<font></font>
                <span class="hljs-keyword">var</span> gates = GetListFromLayersDictionary(structure.Gates);
                <span class="hljs-keyword">var</span> conductors = GetListFromLayersDictionary(structure.Conductors);
                <span class="hljs-keyword">var</span> gatesArray = <span class="hljs-keyword">new</span> OverflowArray(gates.Count, availableGates.Count - <span class="hljs-number">1</span>);
                <span class="hljs-keyword">var</span> conductorsArray = <span class="hljs-keyword">new</span> OverflowArray(conductors.Count, useNot ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<font></font>
<font></font>
                <span class="hljs-keyword">do</span><font></font>
                {<font></font>
                    <span class="hljs-keyword">if</span> (useNot &amp;&amp; conductorsArray.EqualInts)<font></font>
                    {<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                    }<font></font>
<font></font>
                    SetContainerValuesAccordingToArray(conductors, conductorsArray);<font></font>
                    <span class="hljs-keyword">do</span><font></font>
                    {<font></font>
                        <span class="hljs-keyword">if</span> (manyGates &amp;&amp; gatesArray.Length &gt; <span class="hljs-number">1</span> &amp;&amp; gatesArray.EqualInts)<font></font>
                        {<font></font>
                            <span class="hljs-keyword">continue</span>;<font></font>
                        }<font></font>
<font></font>
                        SetContainerValuesAccordingToArray(gates, gatesArray);<font></font>
                        <span class="hljs-keyword">var</span> solutions = solver.GetSolutions(structure.FinalDevice, structure.Sources);
                        <span class="hljs-keyword">if</span> (solutions.Any() &amp;&amp; solutions.Count &lt;= maxSolutions<font></font>
                                            &amp;&amp; !(solutions.Any(s =&gt; s.All(b =&gt; b)) || solutions.Any(s =&gt; s.All(b =&gt; !b))))<font></font>
                        {<font></font>
                            <span class="hljs-keyword">var</span> variant = <span class="hljs-keyword">new</span> CircuitVariant<font></font>
                            {<font></font>
                                Conductors = GetElementsNumberFromLayers(structure.Conductors, availableConductorToGeneralNumber),<font></font>
                                Gates = GetElementsNumberFromLayers(structure.Gates, availableLeToGeneralNumber),<font></font>
                                Solutions = solutions,<font></font>
                                Structure = structure<font></font>
                            };<font></font>
                            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> variant;<font></font>
                        }<font></font>
                    } <span class="hljs-keyword">while</span> (!gatesArray.Increase());<font></font>
                } <span class="hljs-keyword">while</span> (useNot &amp;&amp; !conductorsArray.Increase());<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeCircuitStructure</span>(<span class="hljs-params">CircuitStructure structure, IList&lt;Func&lt;IElectricalElement&gt;&gt; gates, IList&lt;Func&lt;IElectricalElement&gt;&gt; conductors</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> lElements = GetListFromLayersDictionary(structure.Gates);
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> lElements)<font></font>
            {<font></font>
                item.SetElements(gates);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">var</span> cElements = GetListFromLayersDictionary(structure.Conductors);
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> cElements)<font></font>
            {<font></font>
                item.SetElements(conductors);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IList&lt;Func&lt;IElectricalElement&gt;&gt; GetElementsList(IDictionary&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; availableToGeneralGate, IReadOnlyList&lt;Func&lt;IElectricalElement&gt;&gt; elements)<font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> List&lt;Func&lt;IElectricalElement&gt;&gt;();
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> availableToGeneralGate)<font></font>
            {<font></font>
                list.Add(elements[item.Value]);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> list;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IDictionary&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetDictionaryFromAllowedElements</span>(<span class="hljs-params">IReadOnlyCollection&lt;Func&lt;IElectricalElement&gt;&gt; allElements, IEnumerable&lt;<span class="hljs-keyword">int</span>&gt; availableElements</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> enabledDic = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">bool</span>&gt;(allElements.Count);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; allElements.Count; i++)<font></font>
            {<font></font>
                enabledDic.Add(i, <span class="hljs-literal">false</span>);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">int</span> item <span class="hljs-keyword">in</span> availableElements)<font></font>
            {<font></font>
                enabledDic[item] = <span class="hljs-literal">true</span>;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">var</span> availableToGeneralNumber = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;();
            <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> enabledDic)<font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (item.Value)<font></font>
                {<font></font>
                    availableToGeneralNumber.Add(index, item.Key);<font></font>
                    index++;<font></font>
                }<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> availableToGeneralNumber;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetContainerValuesAccordingToArray</span>(<span class="hljs-params">IReadOnlyList&lt;ElectricalElementContainer&gt; containers, IOverflowArray overflowArray</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; containers.Count; i++)<font></font>
            {<font></font>
                containers[i].SetType(overflowArray[i].Value);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IReadOnlyList&lt;ElectricalElementContainer&gt; <span class="hljs-title">GetListFromLayersDictionary</span>(<span class="hljs-params">IDictionary&lt;<span class="hljs-keyword">int</span>, ElectricalElementContainer[]&gt; layers</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> elements = <span class="hljs-keyword">new</span> List&lt;ElectricalElementContainer&gt;();
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> layer <span class="hljs-keyword">in</span> layers)<font></font>
            {<font></font>
                elements.AddRange(layer.Value);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> elements;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IDictionary&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>[]&gt; GetElementsNumberFromLayers(IDictionary&lt;<span class="hljs-keyword">int</span>, ElectricalElementContainer[]&gt; layers, IDictionary&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; elementIdToGlobal = <span class="hljs-literal">null</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> dic = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>[]&gt;(layers.Count);<font></font>
<font></font>
            <span class="hljs-keyword">bool</span> convert = elementIdToGlobal != <span class="hljs-literal">null</span>;<font></font>
<font></font>
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> layer <span class="hljs-keyword">in</span> layers)<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> values = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[layer.Value.Length];
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; layer.Value.Length; i++)<font></font>
                {<font></font>
                    <span class="hljs-keyword">if</span> (!convert)<font></font>
                    {<font></font>
                        values[i] = layer.Value[i].SelectedType;<font></font>
                    }<font></font>
                    <span class="hljs-keyword">else</span><font></font>
                    {<font></font>
                        values[i] = elementIdToGlobal[layer.Value[i].SelectedType];<font></font>
                    }<font></font>
                }<font></font>
<font></font>
                dic.Add(layer.Key, values);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> dic;<font></font>
        }<font></font>
    }</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ジェネレーターは、yieldステートメントを使用してバリアントを返します。</font><font style="vertical-align: inherit;">したがって、StructureGeneratorとVariantsGeneratorを使用して、CircuitGeneratorはIEnumerableを生成します（yieldアプローチは将来的に役立つため、以下を参照してください）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。</font><font style="vertical-align: inherit;">各構造のオプションを個別に生成できます。</font><font style="vertical-align: inherit;">これは並列化できますが、AsParallelの追加は機能しませんでした（おそらく、収量が妨げられます）。</font><font style="vertical-align: inherit;">このオプションは破棄されるため、手動による並列化は長くなります。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際、私は並列生成を試みましたが、うまくいきましたが、リポジトリに移動しなかったため、いくつかの困難がありました。</font></font></i><br>
<br>
<a name="GameClasses"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームクラス</font></font></h3><br>
<a name="Approach"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発アプローチとDI</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
プロジェクトは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存性注入</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（DI）の</font><font style="vertical-align: inherit;">下に構築され</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これは、クラスがインターフェースに対応するある種のオブジェクトを必要とするだけで、このオブジェクトの作成に関与しないことを意味します。</font><font style="vertical-align: inherit;">利点は何ですか：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存関係オブジェクトの作成と初期化の場所は1か所で定義され、依存クラスのロジックから分離されているため、コードの重複がありません。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存関係ツリー全体を掘り下げ、すべての依存関係をインスタンス化する必要がなくなります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの場所で使用されているインターフェースの実装を簡単に変更できます。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトのDIコンテナーとして、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://github.com/modesttree/Zenject"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zenjectが</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zenjectにはいくつかのコンテキストがあり、そのうちの2つだけを使用します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトコンテキスト-アプリケーション全体での依存関係の登録。</font></font></li>
<li> :                .</li>
<li>      ,        .     </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスの登録は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インストーラーに</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存され</font><font style="vertical-align: inherit;">ます。コンテキストには、プロジェクト</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScriptableObjectInstaller</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用し</font><font style="vertical-align: inherit;">、シーンのコンテキストには</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MonoInstallerを使用し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AsSingleに登録するクラスのほとんどは、状態を含まないため、メソッドのコンテナーにすぎません。他のクラスに共通してはならない内部状態があるクラスには、AsTransientを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、これらの要素を表すMonoBehaviourクラスを何らかの方法で作成する必要があります。また、コアプロジェクトに応じて、Unityに関連するクラスを別のプロジェクトに割り当てました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/eg/s1/se/egs1seui5csmxylqk9we7qhedwc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MonoBehaviourクラスの場合、私は自分のインターフェースを作成することを好みます。</font><font style="vertical-align: inherit;">これにより、インターフェースの標準的な利点に加えて、非常に多くのMonoBehaviourメンバーを非表示にすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
便宜上、DIは多くの場合、すべてのロジックを実行する単純なクラスと、そのためのMonoBehaviourラッパーを作成します。</font><font style="vertical-align: inherit;">たとえば、クラスにはStartメソッドとUpdateメソッドがあります。そのようなメソッドをクラスで作成し、MonoBehaviourクラスで依存関係フィールドを追加し、対応するメソッドでStartおよびUpdateを呼び出します。</font><font style="vertical-align: inherit;">これにより、コンストラクターへの「正しい」注入、DIコンテナーからのメインクラスの分離、および簡単なテストが可能になります。</font></font><br>
<br>
<a name="Config"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
構成とは、アプリケーション全体に共通のデータを意味します。</font><font style="vertical-align: inherit;">私の場合、これらはプレハブ、広告と購入の識別子、タグ、シーン名などです。</font><font style="vertical-align: inherit;">これらの目的のために、私はScriptableObjectsを使用します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データグループごとに、ScriptableObjectの下位クラスが割り当てられます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要なシリアライズ可能なフィールドを作成します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのフィールドからの読み取りプロパティが追加されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記のフィールドを持つインターフェースが強調表示されます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスは、DIコンテナーのインターフェイスに登録します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">利益</font></font></li>
</ol><br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ITags</span><font></font>
{<font></font>
        <span class="hljs-keyword">string</span> FixedColor { <span class="hljs-keyword">get</span>; }
        <span class="hljs-keyword">string</span> BackgroundColor { <span class="hljs-keyword">get</span>; }
        <span class="hljs-keyword">string</span> ForegroundColor { <span class="hljs-keyword">get</span>; }
        <span class="hljs-keyword">string</span> AccentedColor { <span class="hljs-keyword">get</span>; }<font></font>
}<font></font>
[<span class="hljs-meta">CreateAssetMenu(fileName = nameof(Tags), menuName = <span class="hljs-meta-string">"Configuration/"</span> + nameof(Tags))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tags</span> : <span class="hljs-title">ScriptableObject</span>, <span class="hljs-title">ITags</span><font></font>
{<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">string</span> fixedColor;<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">string</span> backgroundColor;<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">string</span> foregroundColor;<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">string</span> accentedColor;<font></font>
<font></font>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> FixedColor =&gt; fixedColor;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> BackgroundColor =&gt; backgroundColor;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> ForegroundColor =&gt; foregroundColor;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> AccentedColor =&gt; accentedColor;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            fixedColor.AssertNotEmpty(<span class="hljs-keyword">nameof</span>(fixedColor));<font></font>
            backgroundColor.AssertNotEmpty(<span class="hljs-keyword">nameof</span>(backgroundColor));<font></font>
            foregroundColor.AssertNotEmpty(<span class="hljs-keyword">nameof</span>(foregroundColor));<font></font>
            accentedColor.AssertNotEmpty(<span class="hljs-keyword">nameof</span>(accentedColor));<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構成の場合、個別のインストーラー（コードは省略）：</font></font><br>
<br>
<pre><code class="cs hljs">CreateAssetMenu(fileName = <span class="hljs-keyword">nameof</span>(ConfigurationInstaller), menuName = <span class="hljs-string">"Installers/"</span> + <span class="hljs-keyword">nameof</span>(ConfigurationInstaller))]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ConfigurationInstaller</span> : <span class="hljs-title">ScriptableObjectInstaller</span>&lt;ConfigurationInstaller&gt;<font></font>
    {<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> EditorElementsPrefabs editorElementsPrefabs;       <font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> LevelCompletionSteps levelCompletionSteps;<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> CommonValues commonValues;<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> AdsConfiguration adsConfiguration;<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> CutscenesConfiguration cutscenesConfiguration;<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> Colors colors;<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> Tags tags;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InstallBindings</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            Container.Bind&lt;IEditorElementsPrefabs&gt;().FromInstance(editorElementsPrefabs).AsSingle();           <font></font>
            Container.Bind&lt;ILevelCompletionSteps&gt;().FromInstance(levelCompletionSteps).AsSingle();<font></font>
            Container.Bind&lt;ICommonValues&gt;().FromInstance(commonValues).AsSingle();<font></font>
            Container.Bind&lt;IAdsConfiguration&gt;().FromInstance(adsConfiguration).AsSingle();<font></font>
            Container.Bind&lt;ICutscenesConfiguration&gt;().FromInstance(cutscenesConfiguration).AsSingle();<font></font>
            Container.Bind&lt;IColors&gt;().FromInstance(colors).AsSingle();<font></font>
            Container.Bind&lt;ITags&gt;().FromInstance(tags).AsSingle();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            editorElementsPrefabs.AssertNotNull();<font></font>
            levelCompletionSteps.AssertNotNull();<font></font>
            commonValues.AssertNotNull();<font></font>
            adsConfiguration.AssertNotNull();<font></font>
            cutscenesConfiguration.AssertNotNull();<font></font>
            colors.AssertNOTNull();<font></font>
            tags.AssertNotNull();<font></font>
        }<font></font>
}</code></pre><br>
<a name="GameElectricalElements"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電気要素</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目次</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
どういうわけか電気要素を想像する必要があります</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IElectricalElementMb</span><font></font>
    {<font></font>
        GameObject GameObject { <span class="hljs-keyword">get</span>; }
        <span class="hljs-keyword">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
        IElectricalElement Element { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
        IOutputConnectorMb[] OutputConnectorsMb { <span class="hljs-keyword">get</span>; }<font></font>
        IInputConnectorMb[] InputConnectorsMb { <span class="hljs-keyword">get</span>; }<font></font>
        Transform Transform { <span class="hljs-keyword">get</span>; }
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetInputConnectorsMb</span>(<span class="hljs-params">InputConnectorMb[] inputConnectorsMb</span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetOutputConnectorsMb</span>(<span class="hljs-params">OutputConnectorMb[] outputConnectorsMb</span>)</span>;<font></font>
    }<font></font>
<font></font>
    [<span class="hljs-meta">DisallowMultipleComponent</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ElectricalElementMb</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IElectricalElementMb</span><font></font>
    {<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> OutputConnectorMb[] outputConnectorsMb;<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> InputConnectorMb[] inputConnectorsMb;<font></font>
<font></font>
        <span class="hljs-keyword">public</span> Transform Transform =&gt; transform;<font></font>
<font></font>
        <span class="hljs-keyword">public</span> GameObject GameObject =&gt; gameObject;<font></font>
<font></font>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Name<font></font>
        {<font></font>
            <span class="hljs-keyword">get</span> =&gt; name;
            <span class="hljs-keyword">set</span> =&gt; name = <span class="hljs-keyword">value</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> IElectricalElement Element { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> IOutputConnectorMb[] OutputConnectorsMb =&gt; outputConnectorsMb;<font></font>
<font></font>
        <span class="hljs-keyword">public</span> IInputConnectorMb[] InputConnectorsMb =&gt; inputConnectorsMb;<font></font>
    }</code></pre><br>
<pre><code class="cs hljs">    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span>     Provide additional data to be able to configure it after manual install.</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IElectricalElementMbEditor</span> : <span class="hljs-title">IElectricalElementMb</span><font></font>
    {<font></font>
        ElectricalElementType Type { <span class="hljs-keyword">get</span>; }<font></font>
    }<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ElectricalElementMbEditor</span> : <span class="hljs-title">ElectricalElementMb</span>, <span class="hljs-title">IElectricalElementMbEditor</span><font></font>
    {<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> ElectricalElementType type;<font></font>
<font></font>
        <span class="hljs-keyword">public</span> ElectricalElementType Type =&gt; type;<font></font>
    }</code></pre><br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IInputConnectorMb</span> : <span class="hljs-title">IConnectorMb</span><font></font>
    {<font></font>
        IOutputConnectorMb OutputConnectorMb { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
        IInputConnector InputConnector { <span class="hljs-keyword">get</span>; }<font></font>
    }</code></pre><br>
<pre><code class="cs hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InputConnectorMb</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IInputConnectorMb</span><font></font>
    {<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> OutputConnectorMb outputConnectorMb;<font></font>
<font></font>
        <span class="hljs-keyword">public</span> Transform Transform =&gt; transform;<font></font>
<font></font>
        <span class="hljs-keyword">public</span> IOutputConnectorMb OutputConnectorMb<font></font>
        {<font></font>
            <span class="hljs-keyword">get</span> =&gt; outputConnectorMb;
            <span class="hljs-keyword">set</span> =&gt; outputConnectorMb = (OutputConnectorMb) <span class="hljs-keyword">value</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> IInputConnector InputConnector { <span class="hljs-keyword">get</span>; } = <span class="hljs-keyword">new</span> InputConnector();<font></font>
<font></font>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> UNITY_EDITOR</span>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (outputConnectorMb != <span class="hljs-literal">null</span>)<font></font>
            {<font></font>
                Handles.DrawLine(transform.position, outputConnectorMb.Transform.position);<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
public IElectricalElement Element {get;という行があります。セットする; } </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これはこのアイテムを設定する方法ですか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
良いオプションはジェネリックにすることです：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
public class ElectricalElementMb：MonoBehaviour、IElectricalElementMb where T：IElectricalElement </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、問題はUnityがMonoBehaviorクラスのジェネリックをサポートしていないことです。さらに、Unityはプロパティとインターフェースのシリアル化をサポートしていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それにもかかわらず、実行時にIElectricalElement Element {get;セットする; } </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 必要な値。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要なすべてのタイプがある列挙型ElectricalElementTypeを作成しました。</font><font style="vertical-align: inherit;">EnumはUnityによって適切にシリアル化され、ドロップダウンリストとしてインスペクターに表示されます。</font><font style="vertical-align: inherit;">定義された2種類の要素：ランタイムで作成される要素とエディターで作成され、保存できる要素。</font><font style="vertical-align: inherit;">したがって、IElectricalElementMbとIElectricalElementMbEditorがあり、これらにはタイプElectricalElementTypeのフィールドがさらに含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のタイプも実行時に初期化する必要があります。</font><font style="vertical-align: inherit;">これを行うには、最初にすべての要素をバイパスし、列挙フィールドのタイプに応じてそれらを初期化するクラスがあります。</font><font style="vertical-align: inherit;">次のように：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> Dictionary&lt;ElectricalElementType, Func&lt;IElectricalElement&gt;&gt; ElementByType =
            <span class="hljs-keyword">new</span> Dictionary&lt;ElectricalElementType, Func&lt;IElectricalElement&gt;&gt;<font></font>
            {<font></font>
                {ElectricalElementType.And, () =&gt; <span class="hljs-keyword">new</span> And()},<font></font>
                {ElectricalElementType.Or, () =&gt; <span class="hljs-keyword">new</span> Or()},<font></font>
                {ElectricalElementType.Xor, () =&gt; <span class="hljs-keyword">new</span> Xor()},<font></font>
                {ElectricalElementType.Nand, () =&gt; <span class="hljs-keyword">new</span> Nand()},<font></font>
                {ElectricalElementType.Nor, () =&gt; <span class="hljs-keyword">new</span> Nor()},<font></font>
                {ElectricalElementType.NOT, () =&gt; <span class="hljs-keyword">new</span> NOT()},<font></font>
                {ElectricalElementType.Xnor, () =&gt; <span class="hljs-keyword">new</span> Xnor()},<font></font>
                {ElectricalElementType.Source, () =&gt; <span class="hljs-keyword">new</span> Source()},<font></font>
                {ElectricalElementType.Conductor, () =&gt; <span class="hljs-keyword">new</span> Conductor()},<font></font>
                {ElectricalElementType.Placeholder, () =&gt; <span class="hljs-keyword">new</span> AlwaysFalse()},<font></font>
                {ElectricalElementType.Encoder, () =&gt; <span class="hljs-keyword">new</span> Encoder()},<font></font>
                {ElectricalElementType.Decoder, () =&gt; <span class="hljs-keyword">new</span> Decoder()}<font></font>
            };</code></pre><br>
<a name="GameManagement"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム管理</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
次に、ゲーム自体のロジックを配置する場所（パッセージの状態の確認、パッセージの読み取り値のカウント、およびプレイヤーの支援）の質問が発生しますか？..進行状況や設定などを保存およびロードするためのロジックの場所に関する質問もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このため、特定のクラスのタスクを担当する特定のマネージャークラスを区別します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DataManager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ユーザーの通過の結果とゲーム設定からのデータを格納します。プロジェクトのコンテキストでAsSingleによって登録されます。これは、アプリケーション全体の1つであることを意味します。アプリケーションの実行中、データはDataManager内のメモリに直接保存されます。</font><font style="vertical-align: inherit;">データと</font><b><font style="vertical-align: inherit;">IFileSerializerの</font></b><font style="vertical-align: inherit;">ロードと保存を担当</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
する</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IFileStoreService</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用し</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存用に既製の形式にファイルをシリアル化する責任があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LevelGameManager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、単一シーンのゲームマネージャです。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼はまだUIを担当しているので、少しGodObjectを取得しました。つまり、メニューの開閉、ボタンへの反応です。しかし、プロジェクトの規模とそれを拡張する必要性の欠如を考えると、それは容認できます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
2つのオプションがあります。これは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、LevelGameManager1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LevelGameManager2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">モード1およびモード2でそれぞれ</font><font style="vertical-align: inherit;">呼び出される</font><font style="vertical-align: inherit;">ものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のケースでは、ロジックは、ソースの1つにおける値の変化のイベントへの反応と回路の出力での値の検証に基づいています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のケースでは、ロジックは要素変更イベントに応答し、回路出力の値もチェックします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レベル番号やプレーヤーの支援など、現在のレベル情報がいくつかあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在のレベルに関するデータは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CurrentLevelDataに</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格納され</font><font style="vertical-align: inherit;">ます。レベル番号はそこに保存されます-ヘルプのチェック、ゲームを評価するためのオファーフラグ、およびプレイヤーを助けるためのデータを含むブールプロパティ。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ICurrentLevelData</span><font></font>
{<font></font>
        <span class="hljs-keyword">int</span> LevelNumber { <span class="hljs-keyword">get</span>; }
        <span class="hljs-keyword">bool</span> HelpExist { <span class="hljs-keyword">get</span>; }
        <span class="hljs-keyword">bool</span> ProposeRate { <span class="hljs-keyword">get</span>; }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ICurrentLevelDataMode1</span> : <span class="hljs-title">ICurrentLevelData</span><font></font>
{<font></font>
        IEnumerable&lt;SourcePositionValueHelp&gt; PartialHelp { <span class="hljs-keyword">get</span>; }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ICurrentLevelDataMode2</span> : <span class="hljs-title">ICurrentLevelData</span><font></font>
{<font></font>
        IEnumerable&lt;PlaceTypeHelp&gt; PartialHelp { <span class="hljs-keyword">get</span>; }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のモードのヘルプは、それらのソース番号と値です。 2番目のモードでは、これはセルに設定する必要がある要素のタイプです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コレクションには、指定された位置に設定する必要がある位置と値を格納する構造が含まれています。辞書はよりきれいですが、Unityは辞書をシリアル化できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異なるモードのシーンの違いは、シーンのコンテキストで、別の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LevelGameManager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と別の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICurrentLevelDataが設定されていること</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、私のイベント指向の要素の接続へのアプローチ。</font><font style="vertical-align: inherit;">一方で、それは論理的で便利です。</font><font style="vertical-align: inherit;">一方、必要に応じて登録を解除しなくても問題が発生する可能性があります。</font><font style="vertical-align: inherit;">それにもかかわらず、このプロジェクトには問題はなく、規模もそれほど大きくありません。</font><font style="vertical-align: inherit;">通常、サブスクリプションは、必要なすべてのシーンの開始時に発生します。</font><font style="vertical-align: inherit;">ランタイムではほとんど何も作成されないため、混乱はありません。</font></font><br>
<br>
<a name="LevelsLoading"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベルローディング</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ゲームの各レベルは、Unityシーンで表されます。レベルプレフィックスと番号（たとえば、「Level23」）が含まれている必要があります。</font><font style="vertical-align: inherit;">プレフィックスは設定に含まれています。</font><font style="vertical-align: inherit;">レベルのロードは、接頭辞から形成される名前によって行われます。</font><font style="vertical-align: inherit;">したがって、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LevelsManager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">は数値でレベルをロードできます。</font></font><br>
<br>
<a name="Cutscenes"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カットシーン</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カットシーン</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">の内容は</font></a><font style="vertical-align: inherit;">、レベルと同様に、タイトルに番号が付いた通常の統一シーンです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アニメーション自体はタイムラインを使用して実装されます。</font><font style="vertical-align: inherit;">残念ながら、私にはアニメーションのスキルもタイムラインを操作する能力もないので、「ピアニストを撃たないでください-彼はできる限り演奏します」。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/ny/rf/h8nyrfwesvjp8v6kmy70tcfiduc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
真実は、1つの論理的なカットシーンは、さまざまなオブジェクトのさまざまなシーンで構成される必要があることが判明しました。</font><font style="vertical-align: inherit;">これは少し遅れて気づいたことが判明しましたが、カットシーンの一部をステージのさまざまな場所に配置し、即座にカメラを動かすことで簡単に決定されました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s1/jq/jc/s1jqjces_osngyiexu03i3inrlk.png"><br>
<br>
<a name="AdditionalGameplay"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加のゲームプレイ</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ゲームは、レベルごとのアクションの数と手がかりの使用によって評価されます。アクションが少ないほど良いです。ツールチップを使用すると、最大評価が2つ星に下がり、レベルが1つ星にスキップされます。通過を評価するために、通過のステップ数が保存されます。最小値（3つ星の場合）と最大値（1つ星）の2つの値で構成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
渡されたレベルの星の数を表示する必要があるため、レベルを渡すためのステップ数はシーンファイル自体ではなく、設定ファイルに保存されます。これは、レベルを作成するプロセスをわずかに複雑にしました。バージョン管理システムの変更を見るのは特に興味深いものでした。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fl/uc/4q/fluc4q2iu7946a11fywzat8afck.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それが属しているレベルを推測してみてください。</font><font style="vertical-align: inherit;">もちろん、ディクショナリを格納することは可能でしたが、そもそもそれはUnityによってシリアル化されませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレイヤーがレベルを完了するのが難しい場合、ヒントを入手できます-一部の入力の正しい値、または2番目のモードの正しい要素。</font><font style="vertical-align: inherit;">自動化することもできますが、これも手動で行いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレイヤーの助けが役に立たなかった場合は、レベルを完全にスキップできます。</font><font style="vertical-align: inherit;">レベルが欠落している場合、プレイヤーは1つ星を獲得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒント付きのレベルを通過したユーザーはしばらくの間それを再実行できません。そのため、ヒントなしであるかのように、新しいメモリでレベルを再実行することは困難です。</font></font><br>
<br>
<a name="Monetization"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">収益化</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ゲームには2種類の収益化があります。広告の表示と広告の無効化です。広告の表示には、レベル間の広告の表示と、レベルをスキップするリワード広告の表示が含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレイヤーが広告を無効にするために支払う意思がある場合、彼はそれを行うことができます。この場合、レベル間の広告、およびレベルをスキップした場合の広告は表示されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
広告のために</font><font style="vertical-align: inherit;">、インターフェースを備えた</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AdsService</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">というクラス</font><b><font style="vertical-align: inherit;">が作成されました</font></b></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IAdsService</span><font></font>
{<font></font>
   <span class="hljs-keyword">bool</span> AdsDisabled { <span class="hljs-keyword">get</span>; }
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadBetweenLevelAd</span>(<span class="hljs-params"></span>)</span>;
   <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ShowBetweenLevelAd</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> level, <span class="hljs-keyword">bool</span> force = <span class="hljs-literal">false</span></span>)</span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadHelpAd</span>(<span class="hljs-params">Action onLoaded = <span class="hljs-literal">null</span></span>)</span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowHelpAd</span>(<span class="hljs-params">Action onRewarded, Action onClosed</span>)</span>;
   <span class="hljs-keyword">bool</span> HelpAdLoaded { <span class="hljs-keyword">get</span>; }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでHelpAdは、レベルをスキップするためのリワード広告です。最初は、ヘルプを部分的ヘルプと完全ヘルプと呼びました。部分はヒントであり、完全はスキップレベルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスには、ゲームの最初の起動後に広告を表示するための時間制限が含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実装では、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Mobile Ads Unityプラグインを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用してい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リワード広告を使って、レーキを踏みました-忠実な代理人が別のスレッドで呼び出される可能性があることが判明しました。これらのデリゲートがUnityに関連付けられたコードで何も呼び出さない方がよいためです。広告を無効にするために購入が行われた場合、広告は表示されず、デリゲートはすぐに広告の正常な表示を実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ショッピング用のインターフェースがあります</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPurchaseService</span><font></font>
{<font></font>
   <span class="hljs-keyword">bool</span> IsAdsDisablePurchased { <span class="hljs-keyword">get</span>; }
   <span class="hljs-keyword">event</span> Action DisableAdsPurchased;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuyDisableAds</span>(<span class="hljs-params"></span>)</span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RemoveDisableAd</span>(<span class="hljs-params"></span>)</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity IAPは</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
実装で使用されてい</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ますが、広告の切断を購入するにはコツがあります。</font><font style="vertical-align: inherit;">Google Playは、プレーヤーが購入を購入したという情報を提供していないようです。</font><font style="vertical-align: inherit;">彼女が一度通過したことを確認するだけです。</font><font style="vertical-align: inherit;">ただし、購入後に製品のステータスを「</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完了」では</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なく「</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保留</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」にすると、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasReceipt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">製品のプロパティを確認できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それが本当であれば、購入は完了しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、このアプローチは混乱しますが、すべてがスムーズであるとは限りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RemoveDisableAdメソッドはテスト時に必要であり、購入した広告の停止を削除します。</font></font><br>
<br>
<a name="UI"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーインターフェース</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
すべてのインターフェース要素は、イベント指向のアプローチに従って機能します。</font><font style="vertical-align: inherit;">インターフェイス要素自体には通常、Unityが使用できるパブリックメソッドによって呼び出されるイベント以外のロジックは含まれていません。</font><font style="vertical-align: inherit;">たまたま、インターフェースだけに関連するいくつかの義務を果たします。</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UiElementBase</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IUiElement</span><font></font>
    {<font></font>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Action ShowClick;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Action HideCLick;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            gameObject.SetActive(<span class="hljs-literal">true</span>);<font></font>
            ShowClick?.Invoke();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Hide</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            gameObject.SetActive(<span class="hljs-literal">false</span>);<font></font>
            HideCLick?.Invoke();<font></font>
        }<font></font>
    }<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PauseMenu</span> : <span class="hljs-title">UiElementEscapeClose</span>, <span class="hljs-title">IPauseMenu</span><font></font>
    {<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> Text levelNumberText;<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> LocalizedText finishedText;<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]
        <span class="hljs-keyword">private</span> GameObject restartButton;<font></font>
<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> levelNumber;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Action GoToMainMenuClick;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Action RestartClick;<font></font>
<font></font>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> LevelNumber<font></font>
        {<font></font>
            <span class="hljs-keyword">set</span> =&gt; levelNumberText.text = <span class="hljs-string">$"<span class="hljs-subst">{finishedText.Value}</span> <span class="hljs-subst">{<span class="hljs-keyword">value</span>}</span>"</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisableRestartButton</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            restartButton.SetActive(<span class="hljs-literal">false</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GoToMainMenu</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            GoToMainMenuClick?.Invoke();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Restart</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            RestartClick?.Invoke();<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、これは常に当てはまるとは限りません。</font><font style="vertical-align: inherit;">これらの要素をアクティブビューのままにして、そこからイベントリスナーを作成することをお勧めします。これは、マネージャーの必要なアクションをトリガーするコントローラーのようなものです。</font></font><br>
<br>
<a name="Analytics"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
抵抗が最も少ない経路で、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unityアナリティクス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が選択されました</font><font style="vertical-align: inherit;">。簡単に実装できますが、無料サブスクリプションに制限されています-ソースデータをエクスポートすることはできません。イベント数にも制限があります-プレイヤーあたり100 /時間。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分析用に、ラッパークラス</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AnalyticsServiceを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成しました</font><font style="vertical-align: inherit;">。イベントのタイプごとにメソッドがあり、必要なパラメーターを受け取り、Unityに組み込まれたツールを使用してイベントを送信します。各イベントのメソッドを作成することは確かに一般的にベストプラクティスではありませんが、故意に小規模なプロジェクトでは、大きく複雑な何かを行うよりも優れています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用されるすべてのイベントは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomEventです。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらは、イベント名とディクショナリパラメータの名前と値から作成されます。</font><font style="vertical-align: inherit;">AnalyticsServiceはパラメーターから必要な値を取得し、内部に辞書を作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのイベント名とパラメーターは定数で取り出されます。</font><font style="vertical-align: inherit;">これらの値は決して変更されるべきではないため、ScriptableObjectを使用した従来のアプローチの形式ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドの例：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LevelComplete</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> number, <span class="hljs-keyword">int</span> stars, <span class="hljs-keyword">int</span> actionCount, TimeSpan timeSpent, <span class="hljs-keyword">int</span> levelMode</span>)</span><font></font>
{<font></font>
            CustomEvent(LevelCompleteEventName,<font></font>
                        <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">object</span>&gt;<font></font>
                        {<font></font>
                            {LevelNumber, number},<font></font>
                            {LevelStars, stars},<font></font>
                            {LevelActionCount, actionCount},<font></font>
                            {LevelTimeSpent, timeSpent},<font></font>
                            {LevelMode, levelMode}<font></font>
                        });<font></font>
}</code></pre><br>
<a name="CameraAlign"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カメラの配置と図</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目次</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
タスクは、FinalDeviceを画面の上部に配置し、上部ボーダーから同じ距離に、ソースから下部ボーダーまで常に等距離に配置します。</font><font style="vertical-align: inherit;">さらに、画面にはさまざまなアスペクト比があり、回路に正しく合うようにレベルを開始する前にカメラのサイズを調整する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CameraAlign</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスを</font><b><font style="vertical-align: inherit;">作成し</font></b><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">サイズアルゴリズム：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージで必要な要素をすべて見つけます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アスペクト比に基づいて最小の幅と高さを見つける</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カメラサイズを決定する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カメラを中央にセット</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FinalDeviceを画面の上部に移動します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースを画面の下部に移動します</font></font></li>
</ol><br>
<pre><code class="cs hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CameraAlign</span> : <span class="hljs-title">ICameraAlign</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ISceneObjectsHelper sceneObjectsHelper;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ICommonValues commonValues;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CameraAlign</span>(<span class="hljs-params">ISceneObjectsHelper sceneObjectsHelper, ICommonValues commonValues</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">this</span>.sceneObjectsHelper = sceneObjectsHelper;
            <span class="hljs-keyword">this</span>.commonValues = commonValues;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Align</span>(<span class="hljs-params">Camera camera</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> elements = sceneObjectsHelper.FindObjectsOfType&lt;IElectricalElementMb&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">var</span> finalDevice = sceneObjectsHelper.FindObjectOfType&lt;IFinalDevice&gt;();
            <span class="hljs-keyword">var</span> sources = elements.OfType&lt;ISourceMb&gt;().ToArray();<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (finalDevice != <span class="hljs-literal">null</span> &amp;&amp; sources.Length &gt; <span class="hljs-number">0</span>)<font></font>
            {<font></font>
                <span class="hljs-keyword">float</span> leftPos = elements.Min(s =&gt; s.Transform.position.x);
                <span class="hljs-keyword">float</span> rightPos = elements.Max(s =&gt; s.Transform.position.x);<font></font>
<font></font>
                <span class="hljs-keyword">float</span> width = Mathf.Abs(leftPos - rightPos);
                <span class="hljs-keyword">var</span> fPos = finalDevice.Transform.position;<font></font>
<font></font>
                <span class="hljs-keyword">float</span> height = Mathf.Abs(sources.First().Transform.position.y - fPos.y) * camera.aspect;<font></font>
<font></font>
                <span class="hljs-keyword">float</span> size = Mathf.Max(width * commonValues.CameraOffset, height * commonValues.CameraOffset);<font></font>
<font></font>
                camera.orthographicSize = Mathf.Clamp(size, commonValues.MinCameraSize, <span class="hljs-keyword">float</span>.MaxValue);<font></font>
                camera.transform.position = GetCenterPoint(elements, <span class="hljs-number">-1</span>);<font></font>
<font></font>
                fPos = <span class="hljs-keyword">new</span> Vector2(fPos.x,<font></font>
                                   camera.ScreenToWorldPoint(<span class="hljs-keyword">new</span> Vector2(Screen.width, Screen.height)).y - commonValues.FinalDeviceTopOffset * camera.orthographicSize);<font></font>
                finalDevice.Transform.position = fPos;<font></font>
                <span class="hljs-keyword">float</span> sourceY = camera.ScreenToWorldPoint(Vector2.zero).y + commonValues.SourcesBottomOffset;<font></font>
<font></font>
                <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> sources)<font></font>
                {<font></font>
                    item.Transform.position = <span class="hljs-keyword">new</span> Vector2(item.Transform.position.x, sourceY);<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                Debug.Log(<span class="hljs-string">$"<span class="hljs-subst">{<span class="hljs-keyword">nameof</span>(CameraAlign)}</span>: No final device or no sources in scene"</span>);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Vector3 <span class="hljs-title">GetCenterPoint</span>(<span class="hljs-params">ICollection&lt;IElectricalElementMb&gt; elements, <span class="hljs-keyword">float</span> z</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">float</span> top = elements.Max(e =&gt; e.Transform.position.y);
            <span class="hljs-keyword">float</span> bottom = elements.Min(e =&gt; e.Transform.position.y);
            <span class="hljs-keyword">float</span> left = elements.Min(e =&gt; e.Transform.position.x);
            <span class="hljs-keyword">float</span> right = elements.Max(e =&gt; e.Transform.position.x);<font></font>
<font></font>
            <span class="hljs-keyword">float</span> x = left + ((right - left) / <span class="hljs-number">2</span>);
            <span class="hljs-keyword">float</span> y = bottom + ((top - bottom) / <span class="hljs-number">2</span>);<font></font>
<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(x, y, z);<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドは、ラッパークラスでシーンが開始するときに呼び出されます。</font></font><br>
<br>
<a name="Colors"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配色</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ゲームは非常に原始的なインターフェースを備えているので、黒と白の2つの配色で作成することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、インターフェイスを作成しました</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IColors</span><font></font>
    {<font></font>
        Color ColorAccent { <span class="hljs-keyword">get</span>; }<font></font>
        Color Background { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
        Color Foreground { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
        <span class="hljs-keyword">event</span> Action ColorsChanged;<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityエディターで直接色を設定でき、テストに使用できます。次に、それらを切り替えて、2セットの色を設定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
背景色と前景色は変更できます。どのモードでも1つの色がアクセントになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレーヤーは非標準のテーマを設定できるため、色データは設定ファイルに保存する必要があります。設定ファイルに色データが含まれていない場合、標準値が設定されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、いくつかのクラスがあります</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。CameraColorAdjustment-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カメラの背景色の設定を担当します</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。UiColorAdjustment-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェース要素と</font><b><font style="vertical-align: inherit;">TextMeshColorAdjustmentの</font></b><font style="vertical-align: inherit;">色を設定します</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-ソースの数字の色を設定します。</font><font style="vertical-align: inherit;">UiColorAdjustmentもタグを使用します。</font><font style="vertical-align: inherit;">エディターでは、各要素に設定する必要がある色のタイプ（背景、前景、アクセントカラー、固定色）を示すタグで各要素をマークできます。</font><font style="vertical-align: inherit;">これはすべて、シーンの開始時またはカラースキームの変更のイベントによって設定されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jk/6o/zz/jk6ozzdaz6h8ixxrykmnocrtgze.png"><br>
<br>
<img src="https://habrastorage.org/webt/kl/4d/u6/kl4du6hxim70hyncofiakaiqsi4.png"><br>
<br>
<a name="Editor"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エディタ拡張</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目次</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
開発プロセスを簡素化および高速化するために、多くの場合、標準のエディターツールでは提供されない適切なツールを作成する必要があります。</font><font style="vertical-align: inherit;">Unityの従来のアプローチは、EditorWindowの下位クラスを作成することです。</font><font style="vertical-align: inherit;">UiElementsを使用したアプローチもありますが、まだ開発中のため、従来のアプローチを使用することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UnityEditor名前空間の何かを使用するクラスをゲームの他のクラスの隣に作成するだけの場合、この名前空間はビルドで使用できないため、プロジェクトは単にアセンブルされません。</font><font style="vertical-align: inherit;">いくつかの解決策があります：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エディタースクリプト用に別のプロジェクトを選択</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assets / Editorフォルダにファイルを配置します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのファイルを#if UNITY_EDITORでラップします</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトは最初のアプローチを使用し、場合によっては#if UNITY_EDITOR、必要に応じて、ビルドに必要なクラスにエディターの小さな部分を追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アセンブリで定義したエディタでのみ必要なすべてのクラス。アセンブリでのみ使用できます。</font><font style="vertical-align: inherit;">彼女はゲームのビルドには行きません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-u/yv/ie/-uyviepp1z3u4aal0mgbzlothxg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エディター拡張機能にDIを含めるとよいでしょう。</font><font style="vertical-align: inherit;">これにはZenject.StaticContextを使用します。</font><font style="vertical-align: inherit;">エディターでそれを設定するために、静的コンストラクターが存在するInitializeOnLoad属性を持つクラスが使用されます。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">InitializeOnLoad</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EditorInstaller</span><font></font>
{<font></font>
        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">EditorInstaller</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> container = StaticContext.Container;<font></font>
            container.Bind&lt;IElementsProvider&gt;().To&lt;ElementsProvider&gt;().AsSingle();<font></font>
            container.Bind&lt;ISolver&gt;().To&lt;Solver&gt;().AsSingle();<font></font>
            ....<font></font>
         }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的コンテキストでScriptableObjectクラスを登録するには、次のコードを使用します。</font></font><br>
<br>
<pre><code class="cs hljs">BindFirstScriptableObject&lt;ISceneNameConfiguration, SceneNameConfiguration&gt;(container);<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> BindFirstScriptableObject&lt;TInterface, TImplementation&gt;(DiContainer container)
<span class="hljs-keyword">where</span> TImplementation : ScriptableObject, TInterface<font></font>
{<font></font>
            <span class="hljs-keyword">var</span> obj = GetFirstScriptableObject&lt;TImplementation&gt;();<font></font>
            container.Bind&lt;TInterface&gt;().FromInstance(obj).AsSingle();<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> T GetFirstScriptableObject&lt;T&gt;() <span class="hljs-keyword">where</span> T : ScriptableObject<font></font>
{<font></font>
            <span class="hljs-keyword">var</span> guids = AssetDatabase.FindAssets(<span class="hljs-string">"t:"</span> + <span class="hljs-keyword">typeof</span>(T).Name);<font></font>
<font></font>
            <span class="hljs-keyword">string</span> path = AssetDatabase.GUIDToAssetPath(guids.First());
            <span class="hljs-keyword">var</span> obj = AssetDatabase.LoadAssetAtPath&lt;T&gt;(path);<font></font>
<font></font>
            <span class="hljs-keyword">return</span> obj;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TImplementationはこの行にのみ必要ですAssetDatabase.LoadAssetAtPath（path）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンストラクターに依存関係を配置することはできません。</font><font style="vertical-align: inherit;">代わりに、ウィンドウクラスの依存関係フィールドに[Inject]属性を追加し、ウィンドウの</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
起動時にStaticContext.Container.Inject（this）</font><font style="vertical-align: inherit;">を呼び出します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ウィンドウの更新サイクルに依存フィールドの1つのnullチェックを追加することをお勧めします。フィールドが空の場合は、上記の行を実行します。</font><font style="vertical-align: inherit;">プロジェクトのコードを変更した後、Unityはウィンドウを再作成し、Awakeを呼び出さないためです。</font></font><br>
<br>
<a name="GeneratorWindow"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発生器</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目次</font></font></a><br>
<br>
<img src="https://habrastorage.org/webt/4i/cp/ud/4icpudizv2-8r-bwrbkk3bva8kq.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ジェネレーター</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">の</font></a><font style="vertical-align: inherit;">最初のビュー</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィンドウは、パラメーター付きのスキームのリストの生成へのインターフェースを提供し、スキームのリストを表示し、選択したスキームを現在のシーンに配置します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィンドウは、左から右に3つのセクションで構成されています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成設定</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボタン形式のオプションのリスト</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選択したオプションをテキストとして</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列は、EditorGUILayout.BeginVertical（）およびEditorGUILayout.EndVertical（）を使用して作成されます。残念ながら、サイズを修正して制限することはできませんでしたが、これはそれほど重要ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、多数の回路で生成するプロセスはそれほど速くないことがわかりました。 Iの要素で多くの組み合わせが得られます。プロファイラーが示したように、最も遅い部分は回路自体です。並列化はオプションではありません。すべてのオプションが1つのスキームを使用しますが、この構造を複製することは困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、おそらくエディター拡張機能のすべてのコードがデバッグモードで動作すると思いました。リリースでは、デバッグがうまく機能しない、ブレークポイントが停止しない、行がスキップされる、など。実際、パフォーマンスを測定したところ、Unityのジェネレーターの速度は、コンソールアプリケーションから起動されたデバッグアセンブリに対応していることがわかりました。これは、リリースよりも約6倍遅い速度です。これを覚えておいてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、外部アセンブリを実行して、アセンブリを含むUnity DLLに追加することもできますが、これにより、プロジェクトのアセンブリと編集が大幅に複雑になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のコードを含むコードを使用して、生成プロセスをすぐに別のタスクに組み込みました：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
circuitGenerator.Generate（lines、maxElementsInLine、availableLogicalElements、useNOT、modifier）.ToList（）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでにより良いのは、エディターが生成時にハングすることすらありません。</font><font style="vertical-align: inherit;">しかし、それでも数分（大規模な回路では20分以上）長い時間待つ必要があります。</font><font style="vertical-align: inherit;">さらに、タスクを簡単に完了することができず、生成が完了するまで機能し続けるという問題がありました。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たくさんのコード</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Ext</span><font></font>
{<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IEnumerable&lt;CircuitVariant&gt; <span class="hljs-title">OrderVariants</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IEnumerable&lt;CircuitVariant&gt; circuitVariants</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> circuitVariants.OrderBy(a =&gt; a.Solutions.Count())<font></font>
                                  .ThenByDescending(a =&gt; a.Solutions<font></font>
                                                          .Select(b =&gt; b.Sum(i =&gt; i ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>))<font></font>
                                                          .OrderByDescending(b=&gt;b)<font></font>
                                                          .First());<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEditorGenerator</span> : <span class="hljs-title">IDisposable</span><font></font>
    {<font></font>
        CircuitVariant[] FilteredVariants { <span class="hljs-keyword">get</span>; }
        <span class="hljs-keyword">int</span> LastPage { <span class="hljs-keyword">get</span>; }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FilterVariants</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> page</span>)</span>;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> lines,
                   <span class="hljs-keyword">int</span> maxElementsInLine,
                   ICollection&lt;<span class="hljs-keyword">int</span>&gt; availableGates,
                   <span class="hljs-keyword">bool</span> useNOT,
                   StructureModification? modification,
                   <span class="hljs-keyword">int</span> maxSolutions</span>)</span>;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Stop</span>(<span class="hljs-params"></span>)</span>;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fetch</span>(<span class="hljs-params"></span>)</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EditorGenerator</span> : <span class="hljs-title">IEditorGenerator</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> PageSize = <span class="hljs-number">100</span>;<font></font>
<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ICircuitGenerator circuitGenerator;<font></font>
<font></font>
        <span class="hljs-keyword">private</span> ConcurrentBag&lt;CircuitVariant&gt; variants;<font></font>
<font></font>
        <span class="hljs-keyword">private</span> List&lt;CircuitVariant&gt; sortedVariants;<font></font>
<font></font>
        <span class="hljs-keyword">private</span> Thread generatingThread;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EditorGenerator</span>(<span class="hljs-params">ICircuitGenerator circuitGenerator</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">this</span>.circuitGenerator = circuitGenerator;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            generatingThread?.Abort();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> CircuitVariant[] FilteredVariants { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> LastPage { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FilterVariants</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> page</span>)</span><font></font>
        {<font></font>
            CheckVariants();<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (sortedVariants == <span class="hljs-literal">null</span>)<font></font>
            {<font></font>
                Fetch();<font></font>
            }<font></font>
<font></font>
            FilteredVariants = sortedVariants.Skip(page * PageSize)<font></font>
                                             .Take(PageSize)<font></font>
                                             .ToArray();<font></font>
            <span class="hljs-keyword">int</span> count = sortedVariants.Count;<font></font>
<font></font>
            LastPage = count % PageSize == <span class="hljs-number">0</span>
                ? (count / PageSize) - <span class="hljs-number">1</span><font></font>
                : count / PageSize;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fetch</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            CheckVariants();<font></font>
<font></font>
            sortedVariants = variants.OrderVariants()<font></font>
                                     .ToList();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> lines,
                          <span class="hljs-keyword">int</span> maxElementsInLine,
                          ICollection&lt;<span class="hljs-keyword">int</span>&gt; availableGates,
                          <span class="hljs-keyword">bool</span> useNOT,
                          StructureModification? modification,
                          <span class="hljs-keyword">int</span> maxSolutions</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (generatingThread != <span class="hljs-literal">null</span>)<font></font>
            {<font></font>
                Stop();<font></font>
            }<font></font>
<font></font>
            variants = <span class="hljs-keyword">new</span> ConcurrentBag&lt;CircuitVariant&gt;();<font></font>
            generatingThread = <span class="hljs-keyword">new</span> Thread(() =&gt;<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> v = circuitGenerator.Generate(lines,<font></font>
                                                  maxElementsInLine,<font></font>
                                                  availableGates,<font></font>
                                                  useNOT,<font></font>
                                                  modification,<font></font>
                                                  maxSolutions);<font></font>
                <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> v)<font></font>
                {<font></font>
                    variants.Add(item);<font></font>
                }<font></font>
            });<font></font>
            generatingThread.Start();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Stop</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            generatingThread?.Abort();<font></font>
            sortedVariants = <span class="hljs-literal">null</span>;<font></font>
            variants = <span class="hljs-literal">null</span>;<font></font>
            generatingThread = <span class="hljs-literal">null</span>;<font></font>
            FilteredVariants = <span class="hljs-literal">null</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CheckVariants</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (variants == <span class="hljs-literal">null</span>)<font></font>
            {<font></font>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">"VariantsGeneration is not started. Use Start before."</span>);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        ~EditorGenerator()<font></font>
        {<font></font>
            generatingThread.Abort();<font></font>
        }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
背景は生成されるべきであり、リクエストに応じて、ソートされたオプションの内部リストが更新されるという考え方です。次に、ページごとにオプションを選択できます。したがって、毎回ソートする必要がないため、大きなリストでの作業が大幅に高速化されます。スキームは、「興味深いもの」、つまりソリューションの数、増加、およびソリューションに必要なさまざまな値によってソートされます。つまり、1 1 1 1の解を持つ回路は1 0 1 1よりも興味深いものではありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mr/ud/aa/mrudaajqtmoetizlrvzd1muja4q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、生成の終了を待たずに、レベルの回路をすでに選択していることがわかりました。もう1つの利点は、ページ分割により、編集者が牛のように速度を落とさないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unity機能は、生成されたすべてのデータと同様に、[再生]をクリックするとウィンドウの内容がリセットされるという点で非常に気がかりです。</font><font style="vertical-align: inherit;">簡単にシリアライズできる場合は、ファイルとして保存できます。</font><font style="vertical-align: inherit;">このようにして、生成の結果をキャッシュすることもできます。</font><font style="vertical-align: inherit;">しかし、悲しいかな、オブジェクトが相互に参照する複雑な構造をシリアル化することは困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、次のように各ゲートにラインを追加しました</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">if</span> (Input.Length == <span class="hljs-number">2</span>)<font></font>
{<font></font>
            <span class="hljs-keyword">return</span> Input[<span class="hljs-number">0</span>].Value &amp;&amp; Input[<span class="hljs-number">1</span>].Value;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パフォーマンスが大幅に向上しました。</font></font><br>
<br>
<a name="SolverWindow"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソルバー</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目次</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
エディタで回路を組み立てるとき、それが解決されているかどうか、およびそれがいくつのソリューションを持っているかをすばやく理解できる必要があります。</font><font style="vertical-align: inherit;">これを行うために、「ソルバー」ウィンドウを作成しました。</font><font style="vertical-align: inherit;">テキストの形で現在のスキームのソリューションを提供します</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k4/4e/pk/k44epkd08ngv_gh2rpejtr6jzkg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その「バックエンド」操作のロジック：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> <span class="hljs-title">GetSourcesLabel</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
            <span class="hljs-keyword">var</span> sourcesMb = sceneObjectsHelper.FindObjectsOfType&lt;SourceMb&gt;().OrderBy(s =&gt; s.name);<font></font>
<font></font>
            <span class="hljs-keyword">var</span> sourcesLabelSb = <span class="hljs-keyword">new</span> StringBuilder();
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> sourcesMb)<font></font>
            {<font></font>
                sourcesLabelSb.Append(<span class="hljs-string">$"<span class="hljs-subst">{item.name.Replace(<span class="hljs-string">"Source"</span>, <span class="hljs-string">"Src"</span>)}</span>\t"</span>);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> sourcesLabelSb.ToString();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-keyword">bool</span>[]&gt; FindSolutions()<font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> elementsMb = sceneObjectsHelper.FindObjectsOfType&lt;IElectricalElementMbEditor&gt;();<font></font>
            elementsConfigurator.Configure(elementsMb);<font></font>
<font></font>
            <span class="hljs-keyword">var</span> root = sceneObjectsHelper.FindObjectOfType&lt;FinalDevice&gt;();
            <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<font></font>
            {<font></font>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">"No final device in scene"</span>);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">var</span> sourcesMb = sceneObjectsHelper.FindObjectsOfType&lt;SourceMb&gt;().OrderBy(s =&gt; s.name);<font></font>
<font></font>
            <span class="hljs-keyword">var</span> sources = sourcesMb.Select(mb =&gt; (Source) mb.Element).ToArray();<font></font>
<font></font>
            <span class="hljs-keyword">return</span> solver.GetSolutions(root.Element, sources);<font></font>
}</code></pre><br>
<a name="Useful"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有用</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></a><br>
<br>
<a name="AssertHelper"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asserthelp</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アセットに値が設定されていることを確認するために、OnEnableで呼び出す拡張メソッドを使用します</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AssertHelper</span><font></font>
{<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AssertType</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IElectricalElementMbEditor elementMbEditor, ElectricalElementType expectedType</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (elementMbEditor.Type != expectedType)<font></font>
            {<font></font>
                Debug.LogError(<span class="hljs-string">$"Field for <span class="hljs-subst">{expectedType}</span> require element with such type, but given element is <span class="hljs-subst">{elementMbEditor.Type}</span>"</span>);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AssertNOTNull&lt;T&gt;(<span class="hljs-keyword">this</span> T obj, <span class="hljs-keyword">string</span> fieldName = <span class="hljs-string">""</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>)<font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">string</span>.IsNullOrEmpty(fieldName))<font></font>
                {<font></font>
                    fieldName = <span class="hljs-string">$"of type <span class="hljs-subst">{<span class="hljs-keyword">typeof</span>(T).Name}</span>"</span>;<font></font>
                }<font></font>
<font></font>
                Debug.LogError(<span class="hljs-string">$"Field <span class="hljs-subst">{fieldName}</span> is not installed"</span>);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">string</span> <span class="hljs-title">AssertNOTEmpty</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-keyword">string</span> str, <span class="hljs-keyword">string</span> fieldName = <span class="hljs-string">""</span></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">string</span>.IsNullOrWhiteSpace(str))<font></font>
            {<font></font>
                Debug.LogError(<span class="hljs-string">$"Field <span class="hljs-subst">{fieldName}</span> is not installed"</span>);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> str;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">string</span> <span class="hljs-title">AssertSceneCanBeLoaded</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-keyword">string</span> name</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (!Application.CanStreamedLevelBeLoaded(name))<font></font>
            {<font></font>
                Debug.LogError(<span class="hljs-string">$"Scene <span class="hljs-subst">{name}</span> can't be loaded."</span>);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> name;<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーンがロードされている場合でも、シーンにロード機能があることを確認すると失敗することがあります。</font><font style="vertical-align: inherit;">おそらくこれはUnityのバグです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用例：</font></font><br>
<br>
<pre><code class="cs hljs">mainMenuSceneName.AssertNOTEmpty(<span class="hljs-keyword">nameof</span>(mainMenuSceneName)).AssertSceneCanBeLoaded();<font></font>
levelNamePrefix.AssertNOTEmpty(<span class="hljs-keyword">nameof</span>(levelNamePrefix));<font></font>
editorElementsPrefabs.AssertNOTNull();<font></font>
not.AssertType(ElectricalElementType.NOT); <span class="hljs-comment">//     enum    </span></code></pre><br>
<a name="SceneObjectsHelper"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SceneObjectsHelper</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
シーン要素を操作するために、SceneObjectsHelperクラスも役に立ちました。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たくさんのコード</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Circuit.Game.Utility</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISceneObjectsHelper</span><font></font>
    {<font></font>
        T[] FindObjectsOfType&lt;T&gt;(<span class="hljs-keyword">bool</span> includeDisabled = <span class="hljs-literal">false</span>) <span class="hljs-keyword">where</span> T : <span class="hljs-keyword">class</span>;<font></font>
        T FindObjectOfType&lt;T&gt;(<span class="hljs-keyword">bool</span> includeDisabled = <span class="hljs-literal">false</span>) <span class="hljs-keyword">where</span> T : <span class="hljs-keyword">class</span>;<font></font>
        T Instantiate&lt;T&gt;(T prefab) <span class="hljs-keyword">where</span> T : Object;
        <span class="hljs-keyword">void</span> DestroyObjectsOfType&lt;T&gt;(<span class="hljs-keyword">bool</span> includeDisabled = <span class="hljs-literal">false</span>, <span class="hljs-keyword">bool</span> immediate = <span class="hljs-literal">false</span>) <span class="hljs-keyword">where</span> T : <span class="hljs-keyword">class</span>;
        <span class="hljs-keyword">void</span> Destroy&lt;T&gt;(T obj, <span class="hljs-keyword">bool</span> immediate = <span class="hljs-literal">false</span>) <span class="hljs-keyword">where</span> T : Object;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestroyAllChildren</span>(<span class="hljs-params">Transform transform</span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Inject</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> obj</span>)</span>;<font></font>
        T GetComponent&lt;T&gt;(GameObject obj) <span class="hljs-keyword">where</span> T : <span class="hljs-keyword">class</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SceneObjectsHelper</span> : <span class="hljs-title">ISceneObjectsHelper</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> DiContainer diContainer;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SceneObjectsHelper</span>(<span class="hljs-params">DiContainer diContainer</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">this</span>.diContainer = diContainer;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> T GetComponent&lt;T&gt;(GameObject obj) <span class="hljs-keyword">where</span> T : <span class="hljs-keyword">class</span><font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> obj.GetComponents&lt;Component&gt;().OfType&lt;T&gt;().FirstOrDefault();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> T[] FindObjectsOfType&lt;T&gt;(<span class="hljs-keyword">bool</span> includeDisabled = <span class="hljs-literal">false</span>) <span class="hljs-keyword">where</span> T : <span class="hljs-keyword">class</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (includeDisabled)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> Resources.FindObjectsOfTypeAll(<span class="hljs-keyword">typeof</span>(Object)).OfType&lt;T&gt;().ToArray();<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> Object.FindObjectsOfType&lt;Component&gt;().OfType&lt;T&gt;().ToArray();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> DestroyObjectsOfType&lt;T&gt;(<span class="hljs-keyword">bool</span> includeDisabled = <span class="hljs-literal">false</span>, <span class="hljs-keyword">bool</span> immediate = <span class="hljs-literal">false</span>) <span class="hljs-keyword">where</span> T : <span class="hljs-keyword">class</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> objects = includeDisabled ? Resources.FindObjectsOfTypeAll(<span class="hljs-keyword">typeof</span>(Object)).OfType&lt;T&gt;().ToArray() : Object.FindObjectsOfType&lt;Component&gt;().OfType&lt;T&gt;().ToArray();<font></font>
<font></font>
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> objects)<font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (immediate)<font></font>
                {<font></font>
                    Object.DestroyImmediate((item <span class="hljs-keyword">as</span> Component)?.gameObject);<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span><font></font>
                {<font></font>
                    Object.Destroy((item <span class="hljs-keyword">as</span> Component)?.gameObject);<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> Destroy&lt;T&gt;(T obj, <span class="hljs-keyword">bool</span> immediate = <span class="hljs-literal">false</span>) <span class="hljs-keyword">where</span> T : Object<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (immediate)<font></font>
            {<font></font>
                Object.DestroyImmediate(obj);<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                Object.Destroy(obj);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DestroyAllChildren</span>(<span class="hljs-params">Transform transform</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">int</span> childCount = transform.childCount;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++)<font></font>
            {<font></font>
                Destroy(transform.GetChild(i).gameObject);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> T FindObjectOfType&lt;T&gt;(<span class="hljs-keyword">bool</span> includeDisabled = <span class="hljs-literal">false</span>) <span class="hljs-keyword">where</span> T : <span class="hljs-keyword">class</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (includeDisabled)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> Resources.FindObjectsOfTypeAll(<span class="hljs-keyword">typeof</span>(Object)).OfType&lt;T&gt;().FirstOrDefault();<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> Object.FindObjectsOfType&lt;Component&gt;().OfType&lt;T&gt;().FirstOrDefault();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Inject</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> obj</span>)</span><font></font>
        {<font></font>
            diContainer.Inject(obj);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">public</span> T Instantiate&lt;T&gt;(T prefab) <span class="hljs-keyword">where</span> T : Object<font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> obj = Object.Instantiate(prefab);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> Component)<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> components = ((Component) (<span class="hljs-keyword">object</span>) obj).gameObject.GetComponents&lt;Component&gt;();
                <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> component <span class="hljs-keyword">in</span> components)<font></font>
                {<font></font>
                    Inject(component);<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                Inject(obj);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> obj;<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、高いパフォーマンスが必要な場合には効果があまりないものもありますが、それらが私に要求されることはほとんどなく、影響を与えません。</font><font style="vertical-align: inherit;">しかし、それらを使用すると、たとえばかなりきれいに見えるインターフェースによってオブジェクトを見つけることができます。</font></font><br>
<br>
<a name="CoroutineStarter"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチンスターター</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目次</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Launch CoroutineはMonoBehaviourのみを実行できます。</font><font style="vertical-align: inherit;">そこで、CoroutineStarterクラスを作成し、シーンのコンテキストに登録しました。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ICoroutineStarter</span><font></font>
{<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BeginCoroutine</span>(<span class="hljs-params">IEnumerator routine</span>)</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineStarter</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">ICoroutineStarter</span><font></font>
{<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginCoroutine</span>(<span class="hljs-params">IEnumerator routine</span>)</span><font></font>
        {<font></font>
            StartCoroutine(routine);<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
便利なことに加えて、そのようなツールの導入により、自動テストが容易になりました。</font><font style="vertical-align: inherit;">たとえば、テストでのコルーチンの実行：</font></font><br>
<br>
<pre><code class="cs hljs">coroutineStarter.When(x =&gt; x.BeginCoroutine(Arg.Any&lt;IEnumerator&gt;())).Do(info =&gt;<font></font>
{<font></font>
                <span class="hljs-keyword">var</span> a = (IEnumerator) info[<span class="hljs-number">0</span>];
                <span class="hljs-keyword">while</span> (a.MoveNext()) { }<font></font>
});</code></pre><br>
<a name="Gizmo"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ギズモ</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容非</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
表示の要素を表示するために、シーンでのみ表示されるギズモ画像を使用することをお勧めします。</font><font style="vertical-align: inherit;">クリックで非表示の要素を簡単に選択できます。</font><font style="vertical-align: inherit;">また、線の形で要素を接続しました：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
   <span class="hljs-keyword">if</span> (outputConnectorMb != <span class="hljs-literal">null</span>)<font></font>
   {<font></font>
       Handles.DrawLine(transform.position, outputConnectorMb.Transform.position);<font></font>
   }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/ta/ce/d5/taced5wyeyhwkpj5vtiuvauu68s.png"><br>
<br>
<a name="Testing"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト中</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツは、</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
テストが可能な限り、容易な用途に使用されたので、私は、自動テストのほとんどのアウトを取得したいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユニットテストでは、テストクラスが依存するインターフェースを実装するクラスの代わりに、モックオブジェクトを使用するのが慣例です。このために、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NSubstitute</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリーを使用し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ました</font></a><font style="vertical-align: inherit;">。とても嬉しいこと。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UnityはNuGetをサポートしていないため、依存関係がAssemblyDefinitionファイルに追加され、問題なく使用されるため、DLLを個別に取得してからアセンブリを取得する必要がありました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y-/bh/sp/y-bhsprsfvxo-j9javgdhdzzhig.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動テストのために、Unityは非常に人気のある</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUnit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストフレームワークで動作するTestRunnerを提供しています</font><font style="vertical-align: inherit;">。 TestRunnerの観点から見ると、2種類のテストがあります。</font></font><br>
<br>
<ul>
<li>EditMode —     ,   .    Nunit .    ,    .        GameObject  Monobehaviour .   ,     EditMode .</li>
<li>PlayMode —     .    </li>
</ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">編集モード </font><font style="vertical-align: inherit;">私の経験では、このモードでは多くの不便さと奇妙な動作がありました。</font><font style="vertical-align: inherit;">それでも、アプリケーション全体の状態を自動的にチェックするのに便利です。</font><font style="vertical-align: inherit;">また、Start、Updateなどのメソッドでコードを正直に検証します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PlayModeテストは通常​​のNUnitテストとして説明できますが、代替手段があります。</font><font style="vertical-align: inherit;">PlayModeでは、しばらく待つか、特定の数のフレームを待つ必要がある場合があります。</font><font style="vertical-align: inherit;">これを行うには、コルーチンと同様の方法でテストを記述する必要があります。</font><font style="vertical-align: inherit;">戻り値はIEnumerator / IEnumerableで、内部にある必要があります。時間をスキップするには、次のように使用する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または </font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">yield</span> return new <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">1</span></span>)</span>;</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他の戻り値があります。</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなテストでは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnityTest</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性を設定する必要があります</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様のアプローチを使用する必要があるUnitySetUpおよびUnityTearDown属性</font><font style="vertical-align: inherit;">も</font><font style="vertical-align: inherit;">あります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ModularとIntegrationのEditModeテストを共有します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単体テストは、他のクラスから完全に分離された1つのクラスのみをテストします。</font><font style="vertical-align: inherit;">多くの場合、このようなテストにより、テストしたクラスの環境の準備が容易になり、エラーに合格すると、問題をより正確に特定できるようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単体テストでは、多くのコアクラスと、ゲームで直接必要なクラスをテストします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回路要素のテストはよく似ているので、基本クラスを作成しました</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ElectricalElementTestsBase</span>&lt;TElement&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">TElement</span> : <span class="hljs-title">ElectricalElementBase</span>, <span class="hljs-title">IElectricalElement</span>, <span class="hljs-title">new</span>()<font></font>
{<font></font>
        <span class="hljs-keyword">protected</span> TElement element;<font></font>
<font></font>
        <span class="hljs-keyword">protected</span> IInputConnector mInput1;
        <span class="hljs-keyword">protected</span> IInputConnector mInput2;
        <span class="hljs-keyword">protected</span> IInputConnector mInput3;
        <span class="hljs-keyword">protected</span> IInputConnector mInput4;<font></font>
<font></font>
        [<span class="hljs-meta">OneTimeSetUp</span>]
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Setup</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            element = <span class="hljs-keyword">new</span> TElement();<font></font>
            mInput1 = Substitute.For&lt;IInputConnector&gt;();<font></font>
            mInput2 = Substitute.For&lt;IInputConnector&gt;();<font></font>
            mInput3 = Substitute.For&lt;IInputConnector&gt;();<font></font>
            mInput4 = Substitute.For&lt;IInputConnector&gt;();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetValue_3Input</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> input1, <span class="hljs-keyword">bool</span> input2, <span class="hljs-keyword">bool</span> input3, <span class="hljs-keyword">bool</span> expectedOutput</span>)</span><font></font>
        {<font></font>
            <span class="hljs-comment">// arrange</span><font></font>
            mInput1.Value.Returns(input1);<font></font>
            mInput2.Value.Returns(input2);<font></font>
            mInput3.Value.Returns(input3);<font></font>
<font></font>
            element.Input = <span class="hljs-keyword">new</span>[] {mInput1, mInput2, mInput3};<font></font>
<font></font>
            <span class="hljs-comment">// act</span>
            <span class="hljs-keyword">bool</span> result = element.GetValue();<font></font>
<font></font>
            <span class="hljs-comment">// assert</span><font></font>
            Assert.AreEqual(expectedOutput, result);<font></font>
        }<font></font>
    <font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetValue_2Input</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> input1, <span class="hljs-keyword">bool</span> input2, <span class="hljs-keyword">bool</span> expectedOutput</span>)</span><font></font>
        {<font></font>
            <span class="hljs-comment">// arrange</span><font></font>
            mInput1.Value.Returns(input1);<font></font>
            mInput2.Value.Returns(input2);<font></font>
<font></font>
            element.Input = <span class="hljs-keyword">new</span>[] {mInput1, mInput2};<font></font>
<font></font>
            <span class="hljs-comment">// act</span>
            <span class="hljs-keyword">bool</span> result = element.GetValue();<font></font>
<font></font>
            <span class="hljs-comment">// assert</span><font></font>
            Assert.AreEqual(expectedOutput, result);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetValue_1Input</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> input, <span class="hljs-keyword">bool</span> expectedOutput</span>)</span><font></font>
        {<font></font>
            <span class="hljs-comment">// arrange</span><font></font>
            mInput1.Value.Returns(input);<font></font>
            element.Input = <span class="hljs-keyword">new</span>[] {mInput1};<font></font>
<font></font>
            <span class="hljs-comment">// act</span>
            <span class="hljs-keyword">bool</span> result = element.GetValue();<font></font>
<font></font>
            <span class="hljs-comment">// assert</span><font></font>
            Assert.AreEqual(expectedOutput, result);<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その他の要素テストは次のようになります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AndTests</span> : <span class="hljs-title">ElectricalElementTestsBase</span>&lt;And&gt;<font></font>
{<font></font>
        [<span class="hljs-meta">TestCase(false, false, false)</span>]<font></font>
        [<span class="hljs-meta">TestCase(false, true, false)</span>]<font></font>
        [<span class="hljs-meta">TestCase(true, false, false)</span>]<font></font>
        [<span class="hljs-meta">TestCase(true, true, true)</span>]
        <span class="hljs-function"><span class="hljs-keyword">public</span> new <span class="hljs-keyword">void</span> <span class="hljs-title">GetValue_2Input</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> input1, <span class="hljs-keyword">bool</span> input2, <span class="hljs-keyword">bool</span> output</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">base</span>.GetValue_2Input(input1, input2, output);<font></font>
        }<font></font>
<font></font>
        [<span class="hljs-meta">TestCase(false, false)</span>]<font></font>
        [<span class="hljs-meta">TestCase(true, true)</span>]
        <span class="hljs-function"><span class="hljs-keyword">public</span> new <span class="hljs-keyword">void</span> <span class="hljs-title">GetValue_1Input</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> input, <span class="hljs-keyword">bool</span> expectedOutput</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">base</span>.GetValue_1Input(input, expectedOutput);<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらくこれは理解しやすさの観点からは複雑であり、通常テストでは必要ありませんが、同じものを11回コピーアンドペーストしたくありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GameManagersのテストもあります。</font><font style="vertical-align: inherit;">彼らには多くの共通点があるため、基本クラスのテストも受けました。</font><font style="vertical-align: inherit;">両方のモードのゲームマネージャには、同じ機能と異なる機能が必要です。</font><font style="vertical-align: inherit;">一般的な事柄は、各後継者に対して同じテストでテストされ、さらに特定の動作がテストされます。</font><font style="vertical-align: inherit;">イベントアプローチにもかかわらず、イベントによって実行される動作をテストすることは難しくありませんでした：</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">Test</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FullHelpAgree_FinishLevel</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
            <span class="hljs-comment">// arrange</span><font></font>
            levelGameManager.Start();<font></font>
<font></font>
            helpMenu.ClearReceivedCalls();<font></font>
            dataManager.ClearReceivedCalls();<font></font>
<font></font>
            <span class="hljs-comment">// act</span><font></font>
            helpMenu.FullHelpClick += Raise.Event&lt;Action&gt;();<font></font>
            fullHelpWindow.Agreed += Raise.Event&lt;Action&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(<span class="hljs-literal">true</span>);<font></font>
<font></font>
            <span class="hljs-comment">// assert</span><font></font>
            dataManager.Received().SaveGame();<font></font>
            helpMenu.Received().Hide();<font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Test</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ChangeSource_RootOutBecomeTrue_SavesGameOpensMenu</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
            <span class="hljs-comment">// arrange</span>
            currentLevelData.IsTestLevel.Returns(<span class="hljs-literal">false</span>);<font></font>
            rootOutputMb.OutputConnector.Value.Returns(<span class="hljs-literal">true</span>);<font></font>
<font></font>
            <span class="hljs-comment">// act</span><font></font>
            levelGameManager.Start();<font></font>
            levelFinishedMenu.ClearReceivedCalls();<font></font>
            dataManager.ClearReceivedCalls();<font></font>
            source.ValueChanged += Raise.Event&lt;Action&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(<span class="hljs-literal">true</span>);<font></font>
<font></font>
            <span class="hljs-comment">// assert</span><font></font>
            dataManager.Received().SaveGame();<font></font>
            levelFinishedMenu.Received().Show();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
統合テストでは、エディターのクラスもテストし、DIコンテナーの静的コンテキストからそれらを取得しました。</font><font style="vertical-align: inherit;">したがって、ユニットテストよりも重要な、正しい注入を含むチェック。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlacerTests</span><font></font>
{<font></font>
        [<span class="hljs-meta">Inject</span>]
        <span class="hljs-keyword">private</span> ICircuitEditorPlacer circuitEditorPlacer;<font></font>
<font></font>
        [<span class="hljs-meta">Inject</span>]
        <span class="hljs-keyword">private</span> ICircuitGenerator circuitGenerator;<font></font>
<font></font>
        [<span class="hljs-meta">Inject</span>]
        <span class="hljs-keyword">private</span> IEditorSolver solver;<font></font>
<font></font>
        [<span class="hljs-meta">Inject</span>]
        <span class="hljs-keyword">private</span> ISceneObjectsHelper sceneObjectsHelper;<font></font>
<font></font>
        [<span class="hljs-meta">TearDown</span>]
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TearDown</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            sceneObjectsHelper.DestroyObjectsOfType&lt;IElectricalElementMb&gt;(immediate: <span class="hljs-literal">true</span>);<font></font>
        }<font></font>
<font></font>
        [<span class="hljs-meta">OneTimeSetUp</span>]
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Setup</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> container = StaticContext.Container;<font></font>
            container.Inject(<span class="hljs-keyword">this</span>);<font></font>
        }<font></font>
<font></font>
        [<span class="hljs-meta">TestCase(1, 2)</span>]<font></font>
        [<span class="hljs-meta">TestCase(2, 2)</span>]<font></font>
        [<span class="hljs-meta">TestCase(3, 4)</span>]
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaceSolve_And_NoModifications_AllVariantsSolved</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> lines, <span class="hljs-keyword">int</span> elementsInLine</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> variants = circuitGenerator.Generate(lines, elementsInLine, <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt; {<span class="hljs-number">0</span>}, <span class="hljs-literal">false</span>);
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> variant <span class="hljs-keyword">in</span> variants)<font></font>
            {<font></font>
                circuitEditorPlacer.PlaceCircuit(variant);<font></font>
                <span class="hljs-keyword">var</span> solutions = solver.FindSolutions();<font></font>
                CollectionAssert.IsNOTEmpty(solutions);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        [<span class="hljs-meta">TestCase(1, 2, StructureModification.Branching)</span>]<font></font>
        [<span class="hljs-meta">TestCase(1, 2, StructureModification.ThroughLayer)</span>]<font></font>
        [<span class="hljs-meta">TestCase(1, 2, StructureModification.All)</span>]<font></font>
        [<span class="hljs-meta">TestCase(2, 2, StructureModification.Branching)</span>]<font></font>
        [<span class="hljs-meta">TestCase(2, 2, StructureModification.ThroughLayer)</span>]<font></font>
        [<span class="hljs-meta">TestCase(2, 2, StructureModification.All)</span>]
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaceSolve_And_Modifications_AllVariantsSolved</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> lines, <span class="hljs-keyword">int</span> elementsInLine, StructureModification modification</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> variants = circuitGenerator.Generate(lines, elementsInLine, <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt; {<span class="hljs-number">0</span>}, <span class="hljs-literal">false</span>, modification);
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> variant <span class="hljs-keyword">in</span> variants)<font></font>
            {<font></font>
                circuitEditorPlacer.PlaceCircuit(variant);<font></font>
                <span class="hljs-keyword">var</span> solutions = solver.FindSolutions();<font></font>
                CollectionAssert.IsNOTEmpty(solutions);<font></font>
            }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテストは、すべての依存関係の実際の実装を使用し、ステージ上にオブジェクトを設定します。これは、EditModeテストではかなり可能です。それがそれらを正気にしたことをテストすることは本当です-私は方法についてほとんど考えていません、それで私はホストされた回路が解決策を持っていることを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
統合には、CircuitGenerator（StructureGenerator + VariantsGenerator）とソルバーのテストもあります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CircuitGeneratorTests</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> ICircuitGenerator circuitGenerator;
        <span class="hljs-keyword">private</span> ISolver solver;<font></font>
<font></font>
        [<span class="hljs-meta">SetUp</span>]
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Setup</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            solver = <span class="hljs-keyword">new</span> Solver();<font></font>
<font></font>
            <span class="hljs-keyword">var</span> gates = <span class="hljs-keyword">new</span> List&lt;Func&lt;IElectricalElement&gt;&gt;<font></font>
            {<font></font>
                () =&gt; <span class="hljs-keyword">new</span> And(),<font></font>
                () =&gt; <span class="hljs-keyword">new</span> Or(),<font></font>
                () =&gt; <span class="hljs-keyword">new</span> Xor()<font></font>
            };<font></font>
<font></font>
            <span class="hljs-keyword">var</span> conductors = <span class="hljs-keyword">new</span> List&lt;Func&lt;IElectricalElement&gt;&gt;<font></font>
            {<font></font>
                () =&gt; <span class="hljs-keyword">new</span> Conductor(),<font></font>
                () =&gt; <span class="hljs-keyword">new</span> Not()<font></font>
            };<font></font>
<font></font>
            <span class="hljs-keyword">var</span> elements = Substitute.For&lt;IElementsProvider&gt;();<font></font>
            elements.Conductors.Returns(conductors);<font></font>
            elements.Gates.Returns(gates);<font></font>
<font></font>
            <span class="hljs-keyword">var</span> structGenerator = <span class="hljs-keyword">new</span> StructureGenerator();
            <span class="hljs-keyword">var</span> variantsGenerator = <span class="hljs-keyword">new</span> VariantsGenerator(solver, elements);<font></font>
<font></font>
            circuitGenerator = <span class="hljs-keyword">new</span> CircuitGenerator(structGenerator, variantsGenerator);<font></font>
        }<font></font>
<font></font>
        [<span class="hljs-meta">Test</span>]
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Generate_2l_2max_ReturnsVariants</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-comment">// act</span>
            <span class="hljs-keyword">var</span> variants = circuitGenerator.Generate(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-keyword">new</span>[] {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>}, <span class="hljs-literal">false</span>).ToArray();<font></font>
<font></font>
            <span class="hljs-comment">// assert</span><font></font>
            Assert.True(variants.Any());<font></font>
            AssertLayersNotContains(variants.First().Structure.Gates, <span class="hljs-keyword">typeof</span>(Nand));<font></font>
            AssertLayersNotContains(variants.First().Structure.Gates, <span class="hljs-keyword">typeof</span>(Nor));<font></font>
            AssertLayersNotContains(variants.First().Structure.Gates, <span class="hljs-keyword">typeof</span>(Xnor));<font></font>
            AssertLayersNotContains(variants.First().Structure.Conductors, <span class="hljs-keyword">typeof</span>(Not));<font></font>
<font></font>
            AssertLayersContains(variants.First().Structure.Gates, <span class="hljs-keyword">typeof</span>(Or));<font></font>
            AssertLayersContains(variants.First().Structure.Gates, <span class="hljs-keyword">typeof</span>(Xor));<font></font>
            AssertLayersContains(variants.First().Structure.Conductors, <span class="hljs-keyword">typeof</span>(Conductor));<font></font>
        }<font></font>
<font></font>
        [<span class="hljs-meta">Test</span>]
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Generate_2l_2max_RestrictedElementsWithConductors</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-comment">// arrange</span>
            <span class="hljs-keyword">var</span> available = <span class="hljs-keyword">new</span>[] {<span class="hljs-number">0</span>};<font></font>
<font></font>
            <span class="hljs-comment">// act</span>
            <span class="hljs-keyword">var</span> variants = circuitGenerator.Generate(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, available, <span class="hljs-literal">true</span>).ToArray();<font></font>
<font></font>
            <span class="hljs-comment">// assert</span><font></font>
            Assert.True(variants.Any());<font></font>
<font></font>
            <span class="hljs-keyword">var</span> lElements = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">var</span> layers = variants.Select(v =&gt; v.Gates);<font></font>
<font></font>
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> layer <span class="hljs-keyword">in</span> layers)<font></font>
            {<font></font>
                <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> layer.Values)<font></font>
                {<font></font>
                    lElements.AddRange(item);<font></font>
                }<font></font>
            }<font></font>
<font></font>
            Assert.True(lElements.Contains(<span class="hljs-number">0</span>));<font></font>
            Assert.False(lElements.Contains(<span class="hljs-number">1</span>));<font></font>
            Assert.False(lElements.Contains(<span class="hljs-number">2</span>));<font></font>
            AssertLayersContains(variants.First().Structure.Gates, <span class="hljs-keyword">typeof</span>(And));<font></font>
            AssertLayersContains(variants.First().Structure.Conductors, <span class="hljs-keyword">typeof</span>(Conductor));<font></font>
            AssertLayersContains(variants.First().Structure.Conductors, <span class="hljs-keyword">typeof</span>(Not));<font></font>
<font></font>
            AssertLayersNotContains(variants.First().Structure.Gates, <span class="hljs-keyword">typeof</span>(Nand));<font></font>
            AssertLayersNotContains(variants.First().Structure.Gates, <span class="hljs-keyword">typeof</span>(Or));<font></font>
            AssertLayersNotContains(variants.First().Structure.Gates, <span class="hljs-keyword">typeof</span>(Nor));<font></font>
            AssertLayersNotContains(variants.First().Structure.Gates, <span class="hljs-keyword">typeof</span>(Xnor));<font></font>
            AssertLayersNotContains(variants.First().Structure.Gates, <span class="hljs-keyword">typeof</span>(Xor));<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AssertLayersContains</span>(<span class="hljs-params">IDictionary&lt;<span class="hljs-keyword">int</span>, ElectricalElementContainer[]&gt; layers, Type elementType</span>)</span><font></font>
        {<font></font>
            AssertLayersContains(layers, elementType, <span class="hljs-literal">true</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AssertLayersNotContains</span>(<span class="hljs-params">IDictionary&lt;<span class="hljs-keyword">int</span>, ElectricalElementContainer[]&gt; layers, Type elementType</span>)</span><font></font>
        {<font></font>
            AssertLayersContains(layers, elementType, <span class="hljs-literal">false</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AssertLayersContains</span>(<span class="hljs-params">IDictionary&lt;<span class="hljs-keyword">int</span>, ElectricalElementContainer[]&gt; layers, Type elementType, <span class="hljs-keyword">bool</span> shouldContain</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">bool</span> contains = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> layer <span class="hljs-keyword">in</span> layers)<font></font>
            {<font></font>
                <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> layer.Value)<font></font>
                {<font></font>
                    contains |= item.Elements.Select(e =&gt; e.GetType()).Contains(elementType);<font></font>
                }<font></font>
            }<font></font>
<font></font>
            Assert.AreEqual(shouldContain, contains);<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PlayModeテストはシステムテストとして使用されます。彼らはプレハブ、注入などをチェックします。良いオプションは、テストがいくつかの相互作用をロードして生成するだけの既製のシーンを使用することです。しかし、テストでは、環境がゲーム内のものとは異なる準備済みの空のシーンを使用します。メニューの入力、レベルの入力など、ゲームプロセス全体をテストするためにPlayModeを使用する試みがありましたが、これらのテストの作業は不安定であることが判明したため、後で（絶対に）延期することが決定されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カバレッジ評価ツールを使用してテストを書くのは便利ですが、残念ながらUnityで動作するソリューションは見つかりませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityを2018.3にアップグレードすると、テストの動作がはるかに遅くなり、最大で10倍遅くなる（合成の例の場合）という問題が見つかりました。</font><font style="vertical-align: inherit;">プロジェクトには、11秒間実行される288のEditModeテストが含まれていますが、そこでは何も行われていません。</font></font><br>
<br>
<a name="Resume"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発のまとめ</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></a><br>
<br>
<img src="https://habrastorage.org/webt/kl/4d/u6/kl4du6hxim70hyncofiakaiqsi4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームレベルのスクリーンショット</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
一部のゲーム</font><i><font style="vertical-align: inherit;">の</font></i><font style="vertical-align: inherit;">ロジックは、プラットフォームに関係なく定式化できます。初期段階では、これにより自動テストによる開発とテスト容易性が実現します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DIは便利です。 Unityにはそれが本来備わっていないという事実を考慮に入れても、側面のねじ込みはかなり許容範囲内で機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityでは、プロジェクトを自動的にテストできます。確かに、すべての組み込みのGameObjectコンポーネントにはインターフェースがなく、Collider、SpriteRenderer、MeshRendererなどのモックに直接使用できるだけです。動作しないでしょう。 GetComponentを使用すると、インターフェース上のコンポーネントを取得できます。オプションとして、すべてに対して独自のラッパーを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動テストを使用すると、初期のロジックを生成するプロセスが簡略化されましたが、コードへのユーザーインターフェイスはありませんでした。開発中にすぐに数回のテストでエラーが見つかりましたが、当然、さらにエラーが表示されましたが、多くの場合、追加のテストを記述したり、既存のテストを変更したりして、後で自動的に検出することができました。 DI、プレハブ、スクリプト可能なオブジェクトなどのエラー、テストを把握することは困難ですが、Zenjectの実際のインストーラーを使用できるため、ビルドで発生する依存関係を厳しくする可能性があるため、テストは可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityは膨大な数のエラーを生成し、クラッシュします。</font><font style="vertical-align: inherit;">多くの場合、エラーはエディターを再起動することで解決します。</font><font style="vertical-align: inherit;">プレハブのオブジェクトへの参照の奇妙な喪失に直面しました。</font><font style="vertical-align: inherit;">参照によるプレハブが破壊される場合があります（ToString（）は「null」を返します）。</font><font style="vertical-align: inherit;">すべてのシーンで一部の接続が失われることがあります。</font><font style="vertical-align: inherit;">すべてがインストールされているように見えますが、機能しましたが、別のブランチに切り替えると、すべてのシーンが壊れます-要素間にリンクがありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸いにも、これらのエラーは、エディターを再起動するか、時にはLibraryフォルダーを削除することで修正されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアからGoogle Playでの公開まで、合計で約半年が経過しました。</font><font style="vertical-align: inherit;">開発自体は、本業からの自由時間で約3ヶ月かかりました。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja453546/index.html">小さなキーボードが必要-自分でやる</a></li>
<li><a href="../ja453548/index.html">ブレーキングサムスンギャラクシーTAB 2 WiFiを復活させます</a></li>
<li><a href="../ja453554/index.html">SpaceXのStarlinkの変更点</a></li>
<li><a href="../ja453558/index.html">機械学習の概要</a></li>
<li><a href="../ja453562/index.html">5月27日から6月2日までのモスクワでのデジタルイベント</a></li>
<li><a href="../ja453566/index.html">伝説を復元する：ノートルダムの復元に役立つオープンデータの交換の呼びかけ</a></li>
<li><a href="../ja453570/index.html">macOS用Microsoft Edge</a></li>
<li><a href="../ja453574/index.html">B2B製品管理</a></li>
<li><a href="../ja453578/index.html">批評家からアルゴリズムまで：レーベル、企業、20世紀の音楽文化</a></li>
<li><a href="../ja453580/index.html">先週のフロントエンドの世界からの新鮮な食材のダイジェストNo.366（2019年5月20日〜26日）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>