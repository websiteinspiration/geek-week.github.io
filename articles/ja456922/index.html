<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚥 🈷️ 🎻 プロセッサの設計と製造方法：コンピュータアーキテクチャの基本 🧛🏼 🗿 🤳🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私たちは中央プロセッサをコンピュータの「頭脳」として認識していますが、それは実際にはどういう意味ですか？コンピューターを機能させる何十億ものトランジスターの内部で正確に何が起こるのでしょうか？ 4つの記事からなる新しいミニシリーズでは、コンピュータ機器のアーキテクチャを作成するプロセスを検討し、その...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>プロセッサの設計と製造方法：コンピュータアーキテクチャの基本</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456922/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/772/582/2e1/7725822e1e2ef8975b16770b48a0e199.jpg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは中央プロセッサをコンピュータの「頭脳」として認識していますが、それは実際にはどういう意味ですか？コンピューターを機能させる何十億ものトランジスターの内部で正確に何が起こるのでしょうか？ 4つの記事からなる新しいミニシリーズでは、コンピュータ機器のアーキテクチャを作成するプロセスを検討し、その動作原理について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシリーズでは、コンピュータアーキテクチャ、プロセッサボードの設計、VLSI（超大規模統合）、チップ製造、およびコンピュータ技術分野の将来の動向について説明します。プロセッサーの詳細を理解することに興味がある場合は、この一連の記事から調査を開始することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、プロセッサの機能と、ビルディングブロックが機能する構造にどのように接続されるかについて、非常に高レベルの説明から始めます。特に、プロセッサコア、メモリ階層、分岐予測などについて検討します。最初に、CPUの動作を簡単に定義する必要があります。最も簡単な説明：プロセッサは一連の命令に従って、大量の受信データに対して特定の操作を実行します。たとえば、メモリから値を読み取り、それを別の値に追加し、最終的に結果を別のアドレスのメモリに保存することができます。前の計算の結果がゼロより大きい場合は、2つの数値の除算など、さらに複雑になる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オペレーティングシステムやゲームなどのプログラム自体は、CPUが実行する必要のある一連の命令です。これらの命令はメモリからロードされ、プログラムが終了するまで単純なプロセッサで次々と実行されます。ソフトウェア開発者は、C ++やPythonなどの高級言語でプログラムを作成しますが、プロセッサはそれらを理解できません。彼は1と0しか理解しないので、この形式でコードを何らかの形で表現する必要があります。</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/9ea/109/0959ea1090226766b43f20c46c8ed6d1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アセンブリ言語</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれる一連の低レベルの命令にコンパイルされ</font><em><font style="vertical-align: inherit;">ます</font></em><font style="vertical-align: inherit;">。これは、命令セットアーキテクチャ（ISA）の一部です。これは、CPUが理解して実行する必要がある一連の命令です。最も一般的なISAには、x86、MIPS、ARM、RISC-V、PowerPCなどがあります。 C ++で関数を作成するための構文がPythonで同じアクションを実行する関数と異なるのと同じように、各ISAには独自の異なる構文があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのISAは、固定長と可変長の2つの主なカテゴリに分類できます。 ISA RISC-Vは固定長の命令を使用します。つまり、各命令の所定のビット数によって、命令のタイプが決まります。 x86ではすべてが異なり、可変長命令を使用します。 x86では、命令はさまざまな部分に対してさまざまなビット数でさまざまな方法でエンコードできます。この複雑さのため、x86プロセッサの命令デコーダは通常、デバイス全体の中で最も複雑な部分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
固定長命令は、構造が一貫しているため簡単にデコードできますが、ISAでサポートできる命令の総数は制限されます。 RISC-Vアーキテクチャの一般的なバージョンには約100の命令があり、それらはすべてオープンソースですが、x86アーキテクチャは独自仕様であり、その中に命令がいくつあるか誰も知りません。一般的に数千のx86命令があると考えられていますが、正確な数を公開する人は誰もいません。 ISAの違いにも関わらず、実際にはISAはすべて同じ基本機能を備えています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acc/0a8/074/acc0a807407b41b94459d8202b0c6b4e.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部のRISC-V命令の例。右側のオペコードは7ビット長で、命令のタイプを決定します。さらに、各命令には、使用されるレジスタと実行される機能を定義するビットが含まれています。そのため、アセンブラー命令は、プロセッサーが理解できるようにバイナリー・コードに分解されます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これでコンピュータの電源を入れ、プログラムの実行を開始する準備ができました。命令の実行にはいくつかの基本的な部分があり、それらはプロセッサの多くの段階に分かれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の段階は、実行を開始するためのメモリからプロセッサへの命令の転送です。 2番目のステップでは、CPUが命令のタイプを理解できるように、命令がデコードされます。算術命令、分岐命令、メモリ命令など、多くの種類があります。 CPUが実行している命令のタイプを検出した後、命令のオペランドはメモリまたは内部CPUレジスタから取得されます。数Aと数Bを加算する場合、AとBの値がわかるまで加算できません。最新のプロセッサーのほとんどは64ビットです。つまり、各データ値のサイズは64ビットです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/105/5cd/f55/1055cdf5560f78a1bbe61b6acbfb4d4d.png"></div><br>
<i>64  —    ,    /  .     ,         ,             — 32- . 64-            (64   32).</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命令のオペランドを受け取ると、プロセッサはそれらを実行ステージに転送し、そこで着信データの操作が実行されます。これは、数値の追加、数値による論理操作の実行、または数値を変更せずに単純に渡すことです。結果を計算した後、それを格納するためにメモリアクセスが必要になる場合があります。または、プロセッサが値を内部レジスタの1つに格納するだけの場合もあります。結果を保存した後、CPUはさまざまな要素のステータスを更新し、次の命令に進みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、この説明は大幅に簡略化されており、最新のプロセッサーのほとんどは、これらのいくつかのステージを20以上の小さなステージに分割して効率を上げています。つまり、プロセッサは各サイクルでいくつかの命令を開始して完了しますが、1つの命令を最初から最後まで実行するには20サイクル以上かかる場合があります。このようなモデルは通常、パイプライン（「パイプライン」、通常は「コンベヤー」としてロシア語に翻訳されます）と呼ばれます。これは、パイプラインを液体で満たしてその通過を完了するのに時間がかかりますが、流量（データ出力）が満たされた後は一定になるためです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f4/94c/b7f/5f494cb7fea80ae36c741da698beb07c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4段コンベヤの例。マルチカラーの長方形は、互いに独立した命令を示します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令が通過するサイクル全体は、非常に注意深く調整されたプロセスですが、すべての命令を同時に完了できるわけではありません。たとえば、加算は非常に高速で、メモリからの分割またはロードには数千サイクルかかる場合があります。最新のほとんどのプロセッサは、1つの遅い命令が完了するまでプロセッサ全体を停止する代わりに、順序を変更してそれらを実行します。つまり、現時点で実行するのに最も有利な命令を決定し、まだ準備ができていない他の命令をバッファリングします。現在の命令がまだ準備ができていない場合、プロセッサはコードの前にジャンプして、他に何か準備ができているかどうかを確認できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーケンスの変更を実行することに加えて、最新のプロセッサは</font><em><font style="vertical-align: inherit;">スーパースカラーアーキテクチャ</font></em><font style="vertical-align: inherit;">と呼ばれるテクノロジーを使用しています</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、常に、プロセッサがパイプラインの各ステージで多数の命令を同時に実行することを意味します。彼はまた、数百の実行が開始されることを期待でき、プロセッサ内で複数の命令を同時に実行できるようにするために、パイプラインの各ステージのいくつかのコピーがあります。 2つの命令の実行準備が整っていることをプロセッサが認識し、それらの命令間に依存関係がない場合、プロセッサは、それらが別々に完了するまで待機せず、同時に実行します。このアーキテクチャの一般的な実装の1つは同時マルチスレッディング（SMT）と呼ばれ、ハイパースレッディングとも呼ばれます。 IntelおよびAMDプロセッサーは現在、両面SMTをサポートしていますが、IBMは最大8つのSMTをサポートするチップを開発しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/279/f3d/7ff/279f3d7fffe891e166b1a4547223363c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この入念に調整された実行を完了するために、プロセッサには、ベースコア以外にも多くの追加要素があります。プロセッサには数百の個別のモジュールがあり、それぞれに特定の機能がありますが、ここでは基本的な部分のみを取り上げます。最も重要で有益なのは、キャッシュと分岐予測子です。考慮しないその他の構造として、バッファの並べ替え、名前変更テーブルの登録、バックアップステーションがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャッシュの必要性は、RAMやSSDなどのデータを保存するため、混乱を招く場合があります。ただし、キャッシュはレイテンシとアクセス速度が異なります。 RAMメモリは非常に高速ですが、CPUが必要とするものよりも桁違いに遅いです。 RAMデータの転送で応答するには数百サイクルが必要になる場合があり、プロセッサは現時点では何もしません。 RAMにデータがない場合、SSDからデータにアクセスするには数万サイクルかかる場合があります。キャッシュがないと、プロセッサーは常に停止します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセッサには通常、いわゆる</font><em><font style="vertical-align: inherit;">メモリ階層</font></em><font style="vertical-align: inherit;">を形成する3つのキャッシュレベルがあり</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 L1キャッシュは最小かつ最速、L2は中間にあり、L3はすべてのキャッシュの中で最大かつ最遅です。階層内のキャッシュの上には、計算中に唯一のデータ値を格納する小さなレジスタがあります。大きい順に、これらのレジスタはシステムで最速のストレージデバイスです。コンパイラーが高水準プログラムをアセンブリー言語に変換するとき、これらのレジスターを使用する最良の方法を決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CPUがメモリからデータを要求すると、最初にこのデータがすでにL1キャッシュに格納されているかどうかをチェックします。その場合は、ほんの数サイクルでそれらにアクセスできます。それらが存在しない場合、プロセッサはL2をチェックし、次にL3キャッシュをチェックします。キャッシュは、一般にカーネルに対して透過的な方法で実装されます。カーネルは指定されたメモリアドレスでデータを要求し、それが存在する階層内のレベルがそれに応答します。メモリ階層の次のレベルに移動すると、サイズと遅延は通常桁違いに増加します。最後に、CPUがどのキャッシュにもデータを見つけられない場合、メインメモリ（RAM）にアクセスします。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/bfa/d08/36abfad0814a507d82b857f0de29b96e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のプロセッサでは、各コアに2つのL1キャッシュがあります。1つはデータ用、もう1つは命令用です。 L1キャッシュの容量は通常約100キロバイトで、サイズはチップとプロセッサの世代によって大きく異なります。さらに、一部のアーキテクチャでは2つのコアに共通する場合もありますが、通常、各コアには独自のL2キャッシュがあります。 L2キャッシュのサイズは通常数百キロバイトです。最後に、すべてのコアに共通の単一のL3キャッシュがあり、サイズは数十メガバイトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセッサーがコードを実行すると、最も一般的に使用される命令とデータ値がキャッシュされます。これにより、プロセッサは必要なデータを取得するために常にメインメモリにアクセスする必要がないため、実行速度が大幅に向上します。シリーズの第2部と第3部では、これらのメモリシステムの実装方法について詳しく説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャッシュに加えて、最新のプロセッサの最も重要なビルディングブロックの1つは、正確な</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遷移予測子</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。遷移（分岐）命令は、プロセッサのif構文に似ています。条件がtrueの場合は1つの命令セットが実行され、falseの場合はもう1つの命令セットが実行されます。たとえば、2つの数値を比較し、それらが等しい場合は1つの関数を実行し、等しくない場合は別の関数を実行する必要があります。これらの分岐命令は非常に一般的で、プログラムのすべての命令の約20％を占める可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見すると、これらの分岐命令は問題を引き起こすべきではないようですが、適切な実行はプロセッサにとって非常に難しい場合があります。プロセッサは常に10または20の命令を同時に実行している可能性があるため、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令を実行する</font><font style="vertical-align: inherit;">かを知ることは非常に重要</font><font style="vertical-align: inherit;">です。現在の命令が遷移であると判断するのに5サイクル、条件が真かどうかを判断するのにさらに10サイクルかかる場合があります。この時点で、プロセッサはすでに数十の追加の命令の実行を開始できますが、これらの命令が実行に本当に適しているかどうかもわかりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を回避するために、最新の高性能プロセッサはすべて、投機と呼ばれる手法を使用しています。これは、プロセッサが分岐命令に従い、条件付き分岐が実行されるかどうか疑問に思うことを意味します。予測が正しい場合、プロセッサはすでに次の命令の実行を開始しており、これによりパフォーマンスが向上します。予測が正しくない場合、プロセッサは実行を停止し、実行を開始したすべての誤った命令を削除して、正しいポイントから再開します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような分岐予測子は、実行中の分岐の動作を予測するため、機械学習の最も単純なタイプの一部です。彼があまりに頻繁に誤って予測するならば、彼は正しいふるまいを学び始めます。遷移予測手法に関する数十年にわたる研究の結果、最新のプロセッサでは90％以上の予測精度が得られました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予測によってパフォーマンスが大幅に向上しますが、プロセッサは、実行の完了をキューで待機する代わりに、すでに準備ができている命令を実行できるため、セキュリティの脆弱性も生み出します。有名なSpectre攻撃は、遷移の予測と予測におけるバグを悪用します。攻撃者は特別に選択されたコードを使用して、プロセッサにコードを積極的に実行させるため、メモリから値が漏洩します。データ漏洩を防ぐために、予測の特定の側面の設計をやり直す必要があり、パフォーマンスがわずかに低下しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
過去数十年にわたって、現代のプロセッサで使用されているアーキテクチャは長い道のりを歩んできました。イノベーションと十分に検討された構造の開発により、生産性が向上し、ハードウェアをより最適に使用できるようになりました。ただし、中央処理装置の開発者は技術の秘密を注意深く保持しているため、中央処理装置の内部で何が起こっているかを正確に知ることはできません。ただし、プロセッサの基本原則はすべてのアーキテクチャとモデルで標準化されています。 Intelはその秘密の要素を追加してキャッシュヒットのシェアを増やすことができ、AMDは改善された遷移予測子を追加できますが、両社のプロセッサは同じタスクを実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この最初のルックアンドレビューでは、プロセッサの動作の基本について説明しました。</font><font style="vertical-align: inherit;">次のパートでは、プロセッサーを構成するコンポーネントの開発方法、ロジック要素、クロック速度、電源管理、回路などについて説明します。</font></font><br>
<br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推奨読書</font></font></h5><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロプロセッサとパソコンの歴史</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスプレイ技術の比較：TN vs. </font><font style="vertical-align: inherit;">VA対 </font><font style="vertical-align: inherit;">IPS</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4GHz CPUバトル：AMD第2世代Ryzen対 </font><font style="vertical-align: inherit;">Intel 8th-Gen Core</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーマルスロットリングとは何ですか？</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja456908/index.html">TelegramがどのようにRostelecomにマージするか</a></li>
<li><a href="../ja456910/index.html">インターネットプロジェクトsecurity.txt-別の.well-knownファイルを知る</a></li>
<li><a href="../ja456912/index.html">2019年にサイトを作る方法</a></li>
<li><a href="../ja456916/index.html">Dockerでのクロスコンパイル。何故なの？</a></li>
<li><a href="../ja456920/index.html">Sony Xperia 1 in Russia-価格と予約注文のボーナス</a></li>
<li><a href="../ja456926/index.html">スポーツマスターのやり方</a></li>
<li><a href="../ja456928/index.html">JMeter-スイステスターナイフ（パート1）</a></li>
<li><a href="../ja456930/index.html">IoTを大衆にもたらす：GeekBrainsとRostelecomによる最初のIoTハッカソンの結果</a></li>
<li><a href="../ja456932/index.html">超近代的なOpenGL。パート1</a></li>
<li><a href="../ja456936/index.html">SwiftUIのアニメーションカード</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>