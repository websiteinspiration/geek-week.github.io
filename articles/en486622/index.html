<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôäÔ∏è üïô üÜé Parallel computing model ü§¥üèΩ üèº üôçüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introduction. Competitive corutinism
 Previous articles on the topic of automatic programming were just ‚Äúflowers‚Äù. The "berry" of automatic program...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Parallel computing model</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486622/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Introduction. </font><font style="vertical-align: inherit;">Competitive corutinism</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Previous articles on the topic of automatic programming were just ‚Äúflowers‚Äù. The "berry" of automatic programming, i.e. for what you need to do it, is a model of parallel computing based on the state machine model. So, let's go ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The C ++ standard included the long-awaited support for multithreading [1]. But we will neither admire it nor criticize this fact, because work with threads is weighed down by so many conditions, caveats, and features that without real examples that reveal multithreading problems, a discussion of multithreaded programming will be not only hasty, but also fairly biased. Therefore, hereinafter mainly not about flows, but about automata, bearing in mind, of course, the first ones.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The C ++ language is far from the first, supplemented by parallelism constructs. Back in the 60s of the last century, N. Wirth proposed a parallel extension of the ALGOL language [2]. However, the next 60 years have not clarified what should be considered a parallel algorithm and what should be the model of parallel computing. Apparently, such a belated extension of the C ++ language is also connected with this. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Both the long-standing constructs of the ALGOL language, and their more modern analogues in the C ++ language, are just structural parallelization methods that do not introduce a parallel algorithmic model. To justify this, it can be said that the attempts made over the past time to create such a formal model of calculations have failed. Suffice it to say that the same Petri nets did not justify the high hopes placed on them.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, the ‚Äúspiral‚Äù of parallelism development seems to have returned to its source, having undergone only ‚Äúterminological development‚Äù. </font><font style="vertical-align: inherit;">Former trivial coroutines became suddenly advanced ‚Äúcoroutines‚Äù (tracing paper from the English coroutine), and confusion with the concepts of parallel and concurrent in the English-language segment of parallel programming sometimes leads to paradoxical things. </font><font style="vertical-align: inherit;">For example, the first edition of the book [1] differs from the second edition by replacing the terms ‚Äúparallel‚Äù with ‚Äúcompetitive‚Äù and ‚Äúmultithreaded‚Äù with ‚Äúparallel‚Äù. </font><font style="vertical-align: inherit;">So figure this out in the ‚Äúwho is who‚Äù situation.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Parallel automaton model of calculations</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probably no one will dispute that the next qualitative step in the development of programming is connected with the transition to a parallel computing model. But whether this will happen as a result of the evolutionary development of the existing computational model or whether it will be a fundamentally different model is the issue still under discussion. And if theorists are still arguing, then the practically motivated part of programmers is already using structural methods for parallelizing programs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Separation of duties and increased productivity are considered to be the only reasons for using concurrency. At least, to them or their combinations ultimately reduce or try to reduce all the others [1]. But there is a reason that is rarely talked about, but because of which it is generally worthwhile to engage in parallel programming. Indeed, the speed can be increased by purely hardware methods, and the separation of duties with parallelism is connected in the same way as the daily work of bank employees with a list of their official duties. And only parallel algorithms are a strategy that allows us to defeat the complexity of tasks and increase the reliability of programs. And all this is contrary to the prevailing opinion regarding multi-threaded programming, which turns any parallel program into a complex and unreliable software product.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A parallel system, consisting of many parallel-functioning and actively interacting components, objects, agents, etc., implements an algorithm that is determined in many ways not by the algorithms of the individual components (although they, of course), but by the number of components, the number and kind of connections between them. In order to control this complexity and understand the algorithm of the parallel system, you need not just a parallel computing model, but a model that has, among other things, and even above all, an appropriate theory.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The thesis that ‚Äúoften a parallel program is more difficult to understand ..., and, consequently, the number of errors is increasing‚Äù, is to say the least. </font><font style="vertical-align: inherit;">Yes, the parallel program algorithm can be quite difficult to understand, but if there is a theory it can be "calculated" formally using component algorithms. </font><font style="vertical-align: inherit;">And from the point of view of designing, implementing and maintaining the component algorithms are much simpler than the algorithm of the system as a whole. </font><font style="vertical-align: inherit;">When designing simpler components, we will obviously make fewer mistakes than designing a system in one piece. </font><font style="vertical-align: inherit;">Moreover, debugged components can be part of other systems, reducing complexity, increasing reliability and minimizing their design costs.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Serial concurrency</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The article [3] described the parallelism of a separate model of a finite state machine. Its channels at the level of execution of transitions specify the parallel execution of the functions / methods associated with it - predicates and actions. At the same time, there are no restrictions on the predicate parallelism. When working, they do not conflict with each other, because do not affect the contents of the memory. Actions, working in parallel, can have common input and output data, as well as change them independently of each other. And all this can be a source of uncertainty in the value of the output data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Correct operation of actions in the situations described above provides shadow memory. </font><font style="vertical-align: inherit;">By storing new values ‚Äã‚Äãin it, one can use the same data within even one action, both as input and output. </font><font style="vertical-align: inherit;">An example is the model of a rectangular pulse generator, described as y =! Y, where y is the output of the generator. </font><font style="vertical-align: inherit;">Its C ++ code in the VKPa environment is shown in Listing 1, and the results of the program are shown in Fig. </font><font style="vertical-align: inherit;">1.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 1. Rectangular pulse generator</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSWGenerator</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FSWGenerator(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FSWGenerator(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FSWGenerator(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSWGenerator.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_SWGenerator[] = {<font></font>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FSWGenerator::FSWGenerator(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_SWGenerator, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{<font></font>
    pTAppCore = pInfo;<font></font>
}<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSWGenerator::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-comment">// setting output signals</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSWGenerator::y1</span><span class="hljs-params">()</span> </span>{<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, !<span class="hljs-keyword">bool</span>(pVarY-&gt;GetDataSrc()));<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
 <img src="https://habrastorage.org/webt/3f/ue/ni/3fueni68ys5fwldckqdbodllckm.jpeg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 1. Simulation of the operation of the rectangular pulse generator in the VKPA</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In this case, the machine has one state with an unconditional transition (a transition with a dash in the place of the input condition) in the form of a loop marked by the action y1, which implements the inversion of the output variable, which forms a rectangular pulse in the dynamics. Within the framework of the automaton model, the frequency of the pulse signal can be controlled by setting the tact value of the discrete time of the automaton space into which the automaton is loaded.</font></font><br>
<br>
<i> 1.          ,   .              .        .         .<br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The ability to control the discrete time of the automaton and the presence of many automaton spaces are not the only, but important, distinctive properties of the VKPa environment. </font><font style="vertical-align: inherit;">Using them, you can optimize the performance of a parallel program. </font><font style="vertical-align: inherit;">For example, machines that implement data visualization and user dialogs should be placed in slow automaton spaces, and application processes should be distributed among automaton spaces in accordance with priorities and their desired speed, etc. </font><font style="vertical-align: inherit;">etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Within the framework of an automaton model, the value of the generator output is easily related to the current state of the model. </font><font style="vertical-align: inherit;">The code for the generator model, which already has two states, each of which reflects the state of the generator output, is shown in Listing 2.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 2. Square wave generator on states</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_SWGenState[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSWGenState</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    FSWGenState(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_SWGenState, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) {};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSWGenState.h"</span></span>
<span class="hljs-comment">// state machine transition table</span><font></font>
LArc TBL_SWGenState[] = {<font></font>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the new model, states replace the output variable, and this, as can be seen, dramatically simplified the generator model. </font><font style="vertical-align: inherit;">As a result, we got a ‚Äúbare‚Äù machine, represented only by a conversion table. </font><font style="vertical-align: inherit;">To monitor its current state ‚Äús1‚Äù in VKPa, a variable of the fsa (state) type with the name SWGenState. (S1) was created for the machine with the name SWGenState. </font><font style="vertical-align: inherit;">It takes true value in state s1, and false when the machine is in a different state. </font><font style="vertical-align: inherit;">Further, this variable is already used by means of displaying the data of the VKPA environment (see the signal trend in Fig. 2). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xv/it/jp/xvitjpkfffsmaodeyax2cmeotkq.jpeg" alt="image"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">2. Modeling the state generator</font></font><br>
</i><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Parallel computing control model</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further, moving towards the creation of a model of parallel processes, it is logical to use many simultaneously functioning and interacting finite state machines, i.e. network of automata. In this case, the problem of choosing a network time model appears, which can be the same for all machines or, in the limit, individual for each. In VKPa, the choice was made in favor of a single time (for more details on synchronous networks of automata, see [5]).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The choice of a single time allows you to create an algebra of automata having operations of composition and decomposition of automata. Using the first one, you can find the resulting automaton, which gives an accurate idea of ‚Äã‚Äãthe operation of a parallel system. And here it is worth recalling the above thesis about the "complexity of understanding" of parallel programs. The presence of the composition operation allows us to solve the "problem of understanding" of the parallel program. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, the resulting automaton for a network of a large number of components can be very voluminous. But, fortunately, an understanding of the operation of subsystems or networks of a small number of components is more often required, for which finding the resulting automaton does not cause big problems. The following RS-flip-flop model example demonstrates this.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The RS trigger model is an example of a simple parallel system. It is especially interesting in the presence of cross feedbacks. Feedbacks, or, in another way, cyclic chains, loops, algebraic loops, etc. are currently a serious problem for structural models of parallel systems. In the general case, it is allowed by introducing into the gap loops of memory elements. This is the standard solution proposed by the theory of automata [4]. The same output is recommended in the person of MATLAB. The VKPa environment is different in that it does not require the introduction of such additional elements for the implementation of loops. Note, and this is very important, real circuits also do not need them (see the RS-flip-flop circuit).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fig. </font><font style="vertical-align: inherit;">Figure 3 presents the simplest model of the AND-NOT element, which the RS-trigger circuit consists of. </font><font style="vertical-align: inherit;">It does not take into account element delays, as well as their type (transport or inertial delays). </font><font style="vertical-align: inherit;">However, it still contains at least one delay beat. </font><font style="vertical-align: inherit;">This is the time of transition from one state to another. </font><font style="vertical-align: inherit;">Listing 3 shows the model code </font></font><br>
<br>
<img src="https://habrastorage.org/webt/os/8b/am/os8bam0skdc-jwtctewqmbwupci.jpeg" alt="image"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">3. The model of the element AND NOT</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3. Element model AND NOT</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FIne</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FIne(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FIne(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FIne(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarX1;				<span class="hljs-comment">//  </span>
    CVar *pVarX2;				<span class="hljs-comment">//  </span>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameY;         <span class="hljs-comment">//   </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">bool</span> bX1, bX2, bY;<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FIne.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_Ine[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12^x1"</span>,	<span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12^x2"</span>,	<span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12x1x2"</span>,	<span class="hljs-string">"y2"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x1x2"</span>,   <span class="hljs-string">"y2"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"^x1"</span>,    <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"^x2"</span>,    <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FIne::FIne(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_Ine, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{ }<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FIne::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"x1"</span>, CLocVar::vtBool, <span class="hljs-string">" 1- "</span>);<font></font>
    pVarX2 = CreateLocVar(<span class="hljs-string">"x2"</span>, CLocVar::vtBool, <span class="hljs-string">" 2- "</span>);<font></font>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameY = CreateLocVar(<span class="hljs-string">"strNameY"</span>, CLocVar::vtString, <span class="hljs-string">"name of external output variable(y)"</span>);		<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX1) {<font></font>
        str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameX2) {<font></font>
        str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>); }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameY) {<font></font>
        str = pVarStrNameY-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>){pVarY = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);}<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">bool</span>(pVarX1-&gt;GetDataSrc()); }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">bool</span>(pVarX2-&gt;GetDataSrc()); }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarY; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y1</span><span class="hljs-params">()</span> </span>{ pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">1</span>); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y2</span><span class="hljs-params">()</span> </span>{ pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0.0</span>); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y12</span><span class="hljs-params">()</span> </span>{ FInit(); }
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fig. 4 shows a diagram of an RS flip-flop and its model in the form of a finite state machine. The arrows on the model indicate the connections between the automata of the network. Here, on the one hand, the states of the models reflect the states of the outputs of the element, and, on the other hand, they are also used as signals for organizing information links between parallel processes. It is this form of the model (with synchronization through states) that makes it quite easy to find the resulting automaton of the network. It is shown in fig. 5 (for the procedure for finding the resulting automaton, see [6] for more details).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compare the [resulting] algorithm of the parallel RS-flip-flop program and the operation algorithm of a separate AND-NOT element. The difference is striking. In this case, the component algorithms are created by ‚Äúhandles‚Äù, and the parallel system algorithm is created implicitly - by the ‚Äúartificial intelligence‚Äù of the network. This is the qualitative difference between parallel programs and sequential ones: changing only communications (at least one), we will get a completely different algorithm of work. And it will definitely not be an RS trigger anymore. And, by the way, another resulting automaton. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/kb/zi/fc/kbzifcjk_ycehmabwwtsuh_gyfc.jpeg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 4. Scheme of the RS-FF and network model </font></font><br>
</i><br>
<img src="https://habrastorage.org/webt/_v/ht/2n/_vht2nka0gtsreim8qhjplh_njq.jpeg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 5. The resulting machine network model RS-trigger</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The analysis of the resulting automaton in Fig. 5 gives the following "understanding" of the parallel program (and the real trigger, of course). Firstly, when switching from one state to another, the trigger will necessarily go through the ‚Äúforbidden‚Äù state of the outputs (and what do the textbooks say about this?). Secondly, if the trigger is driven into a single state of outputs (in the state ‚Äús1w1‚Äù), and then two units are fed to the inputs, then it will enter the generation mode, i.e. cyclic switching between the states ‚Äús1w1‚Äù and ‚Äús0w0‚Äù and (and have you heard about trigger generation?).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A transition through a forbidden state also occurs in a real trigger, but the generation mode is impossible due to the difference in delays of real elements. Fig. Figure 6 shows the mode of generation of the trigger trigger model, which exists as long as the units at the inputs are stored. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remark 2. A typical description of the operation of the RS-trigger is given in the overwhelming majority of cases in the form of a truth table. But to do so, realizing that a trigger is a sequential circuit, it is, in fact, deliberately mislead those who study this topic. Well, no trigger cannot have ‚Äúforbidden states‚Äù! But for some reason only a few decide to discover this truth and, especially, discuss the problem of its generation (see, for example, [7]).</font></font><br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fig. 7 shows the switching of a trigger model between its stable states. Here, a single state of the trigger inputs saves the current state of the trigger outputs, and when this or that input is set to zero, it switches to the opposite state. At the same time, when the trigger is switched, its outputs at the moment equal to one discrete measure take at the same time a single (forbidden by whom?) State. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/fl/a0/csfla0xnbcpz0ngewn6izuj_cps.jpeg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 6. RS-trigger generation mode </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/nc/w5/74/ncw574s_lxpj2qq4oh1krswiclk.jpeg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 7. Switching RS-trigger between states</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider another RS-trigger model, consisting of one state and one action, i.e. </font><font style="vertical-align: inherit;">similar to the model in Listing 1. Its code is shown in Listing 4. This model, like the generator model, has no predicates and the signal values ‚Äã‚Äãwithout any intermediate transformations are input to the action y1. </font><font style="vertical-align: inherit;">Is this good or bad? </font><font style="vertical-align: inherit;">On the one hand, it seems that it‚Äôs good, because </font><font style="vertical-align: inherit;">the code has become simpler, but on the other hand ... not really. </font><font style="vertical-align: inherit;">And we will understand the reasons for this now.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 4. NAND element model from one action</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FTwoOperators</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FTwoOperators(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FTwoOperators(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FTwoOperators(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarX1;				<span class="hljs-comment">//  </span>
    CVar *pVarX2;				<span class="hljs-comment">//  </span>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameY;         <span class="hljs-comment">//   </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">bool</span> bX1, bX2, bY;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FTwoOperators.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_TwoOperators[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12"</span>, <span class="hljs-string">"--"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,  <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FTwoOperators::FTwoOperators(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_TwoOperators, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{ }<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FTwoOperators::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"x1"</span>, CLocVar::vtBool, <span class="hljs-string">" 1- "</span>);<font></font>
    pVarX2 = CreateLocVar(<span class="hljs-string">"x2"</span>, CLocVar::vtBool, <span class="hljs-string">" 2- "</span>);<font></font>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameY = CreateLocVar(<span class="hljs-string">"strNameY"</span>, CLocVar::vtString, <span class="hljs-string">"name of external output variable(y)"</span>);		<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX1) {<font></font>
        str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameX2) {<font></font>
        str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>); }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameY) {<font></font>
        str = pVarStrNameY-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarY = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FTwoOperators::x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarY; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTwoOperators::y1</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// reading input signals</span>
    bX1 = <span class="hljs-keyword">bool</span>(pVarX1-&gt;GetDataSrc());<font></font>
    bX2 = <span class="hljs-keyword">bool</span>(pVarX2-&gt;GetDataSrc());
<span class="hljs-comment">// setting output signals</span><font></font>
    bY = !(bX1&amp;&amp;bX2);<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, bY);<font></font>
}<font></font>
<span class="hljs-comment">// initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTwoOperators::y12</span><span class="hljs-params">()</span> </span>{ FInit(); }
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we test the new model in the ‚Äúshadow memory‚Äù mode, then we will not see any differences in its operation from the previous one, that is, and, switching, it will go through the forbidden states and regularly enter the generation mode. If we set up work with data in the usual mode, we will get the results shown in Fig. 8 and fig. 9. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/mc/ib/tomcibxvaq2mae2kxxqc5clwits.jpeg" alt="image"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 8. Failure of the generation mode of the RS-trigger model </font></font></i><br>
 <br>
<img src="https://habrastorage.org/webt/pu/qt/5y/puqt5yws1udobr_volkpcm7r4dm.jpeg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. 9. Skipping forbidden states by the RS-trigger</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
model Why does the first model, regardless of the mode of working with memory, show stable results, and the second - changes behavior? The reason is predicates. The second model has no predicates, and this is critical for its behavior. But how and why does the presence / absence of predicates affect the parallel program operation algorithm?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The program model of an AND-NOT element, like an automaton program, has two input channels and one output channel. They must match two predicates and one action. The first program is fully consistent with this. The VKPa kernel, which interprets the automaton description, first executes all the predicates of not only a particular automaton, but also the entire automaton space, and only then starts all actions. In this case, in whatever sequence the actions were executed, simulating parallelism, and in whatever mode they worked with memory, the results of predicates on the current clock cycle of the automaton do not depend on them (actions). Therefore, the first program produces the same result.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second program, although it works directly with the input channels of the machine, reads the input signals as part of the action. </font><font style="vertical-align: inherit;">Actions, working with input data in the shadow memory mode, write new values ‚Äã‚Äãto the shadow memory and thereby work with data valid at the beginning of a discrete clock cycle. </font><font style="vertical-align: inherit;">In the usual mode, they ‚Äúgrab‚Äù the instantaneous values ‚Äã‚Äãestablished at the time of their change, and thus the algorithm becomes dependent on the moments of memory change. </font><font style="vertical-align: inherit;">A similar dependence is demonstrated by the second program. </font><font style="vertical-align: inherit;">And even if predicate methods were introduced into the second model, this would not have any effect on the results of its work. </font><font style="vertical-align: inherit;">What matters here is not the fact of the existence of predicate methods, but the features of their work in the framework of the automaton programming model.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Conclusions</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using the parallel RS-trigger program as an example, we examined some of the properties inherent in any parallel program. </font><font style="vertical-align: inherit;">We will continue to consider certain general aspects of the functioning of parallel programs as an example of logical (digital) circuits. </font><font style="vertical-align: inherit;">The choice of the topic of modeling digital circuits here is not accidental. </font><font style="vertical-align: inherit;">In fact, in ‚Äúrefined form‚Äù they represent the work of parallel processes. </font><font style="vertical-align: inherit;">This makes the analysis of the nuances of concurrency, race, synchronization, dead ends, etc. </font><font style="vertical-align: inherit;">etc. transparent, clear and simple.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the same time, no matter how you call programming - ‚Äúcompetitive‚Äù or parallel, whether you use ‚Äúcoroutines‚Äù, coroutines, threads or machines for programming, the result of the [parallel] program must be the same in all implementations. </font><font style="vertical-align: inherit;">The automatic model of parallel programs within the framework of the CPSU pursues this and only this goal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Whatever assumptions would be made regarding the implementation of the core of the interpretation of the automata of the VKPa‚Äôs environment, all these would be ‚Äúspeculations‚Äù, because the result of the work of automatic programs should not be associated with the implementation of a computational model. It can be software (as it is now) or hardware (as I hope in the future), implemented on one core or on their set, in single-threaded or multi-threaded version, etc. etc. all this in no way should affect the results of parallel automatic programs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And, it seems, the goal was achieved. </font><font style="vertical-align: inherit;">The RS-trigger model, as one of the possible tests of parallelism systems [8], convinces us of this ... As life has shown, all other parallel programs, provided that the environment has successfully passed the RS-trigger test parallelism implementation, work just as correctly, reliably and stably . </font><font style="vertical-align: inherit;">By the way, the same MATLAB ‚ÄúRS-trigger test‚Äù did not pass, and this already says a lot ...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literature</font></font></b><div class="spoiler_text">1.  .    ++  .    . .  .  .. ‚Äì .:  , 2012. ‚Äì 672 . <br>
2.  .    : .  . ‚Äì .: , 1981. ‚Äì 360 .<br>
3.    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">habr.com/ru/post/484588</a> . . . (  07.01.2020).<br>
4.  ..   . .: , 1962.<br>
5.  .., - ..    . ‚Äì 2- ., .  . ‚Äì .:  , 1988. ‚Äì 480 .<br>
6.  ..    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">cloud.mail.ru/public/HwsK/T95PMM8Ed</a> . . . (  01.02.2020).<br>
7.  .    . 2-  . ‚Äì .: , 2004. ‚Äì 432.<br>
8.  ..   ? ‚Äú ‚Äù, ‚Ññ10/97, .116-119. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">www.osp.ru/pcworld/1997/10/158015</a> . . . (  01.02.2020).<br>
</div></div></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/en486622/">https://habr.com/ru/post/en486622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en486598/index.html">Microcontroller Experiments in Jupyter Notebook</a></li>
<li><a href="../en486602/index.html">Svelte Community Materials Digest (January 16 - February 1)</a></li>
<li><a href="../en486604/index.html">No, dynamic type systems are essentially no more open</a></li>
<li><a href="../en486608/index.html">Essential Assistants in the Intelligence of the Most Effective Intelligence Service in the World (Part 2)</a></li>
<li><a href="../en486614/index.html">Why eSIM is needed. How it works and why they talk so much about it</a></li>
<li><a href="../en486626/index.html">Svelte: getting to know Actions</a></li>
<li><a href="../en486628/index.html">Fixed distance between ticks on an axis in gnuplot</a></li>
<li><a href="../en486630/index.html">‚ÄúDo not flicker in the eye‚Äù: how the technology of screen illumination of electronic readers is arranged</a></li>
<li><a href="../en486632/index.html">Mental Reactive Programming Models for Supervisors</a></li>
<li><a href="../en486634/index.html">MSVC Backend updates in Visual Studio 2019 version 16.3 and 16.4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>