<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏾 📡 ⛏️ 决策平衡。叉子“随机体验” 🍋 👨🏽‍✈️ 👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="要写出现实生活，除了完全击败自己之外，您不需要任何其他东西。我继续创建它，然后我将在这个主题上写大量文章，但是，我的意思是，这件事本身是什么，要测量7次，切掉一次，然后再测量77次，最后不切掉，这是多么困难。测量，再次测量！-这是想要创造出真正不寻常的东西的座右铭。编码比思考容易得多。但总的来说，思...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>决策平衡。叉子“随机体验”</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499910/"><img src="https://avatars.mds.yandex.net/get-zen_doc/138668/pub_59b1408757906accd78afbea_59b16f7a58166998b74496ae/scale_1200" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要写出现实生活，除了完全击败自己之外，您不需要任何其他东西。</font><font style="vertical-align: inherit;">我继续创建它，然后我将在这个主题上写大量文章，但是，我的意思是，这件事本身是什么，要测量7次，切掉一次，然后再测量77次，最后不切掉，这是多么困难。</font><font style="vertical-align: inherit;">测量，再次测量！</font><font style="vertical-align: inherit;">-这是想要创造出真正不寻常的东西的座右铭。</font><font style="vertical-align: inherit;">编码比思考容易得多。</font><font style="vertical-align: inherit;">但总的来说，思考是痛苦且不寻常的。</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是今天，我想谈一谈竞选活动中出现的一个“问题”。想象一下粒子或化学元素的混沌运动-它们以有条件的有限体积运动，仅彼此碰撞或排斥-最纯净的形式的混沌。如果启动了这样的系统，那么即使在这种看似毫无用处的蚁丘中，也会不时观察到结构化的运动：在某一时刻可能会发生随机碰撞，以至于冲击（冲量）的方向会在一个方向上或多或少地发生然后碰撞粒子将沿一个方向移动，从而形成波浪。将来，来自第三方碰撞的浪潮将开始衰减，我们将再次看到混乱的景象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那些。随机在本质上不由自主地形成结构，但是结构仅仅是这种随机的临时形式。以这种方式流动，混乱呈现出各种形式，我们认为这是合理的，即订购。总的来说，合理是重复的，以便可以注意到对人的这种重复。但是，我们现在不会深入研究这个问题，而是要多一点思考。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回想一下最有可能所谓的由于化学元素的混乱相互作用，地球上出现了“生命”。如果一个分子无法从另一个分子中吸取电子，或者反之亦然，则无法实现这样的生活。这种</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机会本身</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这仅是由于化合物从元素中出现，并且化合物也从最初的复制体和生物中出现。因此，如果我们想创造数字生活，就必须</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给人以</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">互动的</font><b><font style="vertical-align: inherit;">机会</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们是宇宙的伟大建筑师，并且从一开始就完全了解所有定律，那么将它们数字化的问题就不会构成严重的问题。但是因为由于并非如此（不幸的是），我们只能依靠这样的事实，即我们可以猜测并创造出与生物生活来临相同的条件，从而使数字生活得以出现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，我试图描述自由代码的原理。最大可能的免费代码。没有我们自己对生活安排的理解，因为这种理解很可能是错误的或不完整的，以至于太没有意义了。我们这些小动物正在努力研究和描述我们周围的一切，以至于我们做不到。但是没有人禁止尝试。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当您编写混乱的代码时，您不可避免地会碰到叉子。随机的经验。那些。要么混乱地前进，要么使经验形成。那些。不仅可以使粒子碰撞，还可以相互作用。我们正在寻找生物生活的类似物，如果没有经验的转移和再生，这是无法想象的。 RNA / DNA是一种经记录的传播经验。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一方面，它不能以任何方式确定，因为我们并不真正知道它是如何发展和发展的。如果不消除这种诱惑，错误是不可避免的。换句话说，我们无法告诉程序体验应该如何看待以及应该如何形成。但是我们可以为她提供原则上可以用来构成他的工具。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我与自己奋斗了很长时间，因为在我看来，可以很简单地描述经验存储的结构。认为简单性（根据我们自己对简单性的想法对我们而言似乎很简单）是一种欺骗自己的可靠方法。我怀疑真正的简单性真的很复杂。但是我建议不要在这里进行讨论。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设我们响应于随机输入的数值集而随机生成了一行可执行代码。可以假设响应的产生或反应是经验。如果某事物对相同的传入信号稳定地做出相同的反应，则可以说它利用了经验。因此，我想记住生成的字符串。但这不能直接完成！您不仅可以将这行代码插入到类实例的数组变量中，然后以这种方式开始创建一种反应库，写出类似IF [memory_name中的input.set] THEN [memory .-&gt; reaction]。是不可能的！因为这不是“生物存储系统”的工作原理。他们的构造本来就和我们现在看到的一样，这并不是事实。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同时，您不能只是获取并随机生成至少256个字节的字符串并尝试执行它，因为在现代计算机上，这会花费大量时间，因此不适合我们。</font><font style="vertical-align: inherit;">这样的方法可能是理想的，但是，遗憾的是，无法用当前未开发的技术来验证这一方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，我们仍然拥有一种编程语言，无论怎么说，我们至少都有自己的想法。</font><font style="vertical-align: inherit;">您根本不可能一无所有。</font><font style="vertical-align: inherit;">因此，我们需要一个主观的外观。</font><font style="vertical-align: inherit;">例如，我不禁要看一种形式如何转变为另一种形式，反之亦然，混乱如何轻易地呈现出一种形式，并且又如何与之分离，就像一个球从地板上举起并释放落在该地板上并留下一个标记一样。</font><font style="vertical-align: inherit;">结果，我不想确切地确定任何事情，但是我也不能将所有事情随机化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了理解该问题，假设我们在代码中有2种可能的动作。您不能直接指出要选择哪个，这是确定的。而且，如果您将所有内容随机化，则需要使用概率。只有什么？ 50/50？ 30/70？ 80/20？假设在其他条件相同的情况下，50/50确实是最不确定的关系。然后，代码将如下所示：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> random.random() &gt;= <span class="hljs-number">0.5</span>:<font></font>
      <span class="hljs-number">1</span>
<span class="hljs-keyword">else</span>:<font></font>
     <span class="hljs-number">2</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 此代码有什么问题？而且事实是，在循环的每次迭代中，此代码</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总是会</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随机选择第一个动作或第二个动作。换句话说，这种混乱从来都不是有组织的，因为它甚至没有这种理论上的可能性。总的来说，在这里我们正在处理同样的决心。摆脱这种情况是有办法的。其原因在于，action1和action2本身必须更改其应用条件。我认为有不同的选择，但我想提供以下内容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所知，操作系统使用优先级平衡执行队列中的线程。运行时正在执行的线程会逐渐失去优先级，而队列中空闲的线程会增加此优先级。在一定的节拍下，后者的优先级变得高于第一个，流量改变了位置，然后情况再次发生。因此，这些流很快就彼此交替，我们看到了它们几乎同时执行的错觉。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的案例中，优先级原则将使我们不仅可以更改要在内核上执行的线程，还可以更改将控制权转移到代码的某些部分。而且，如果我们将代码的一部分作为“随机”，而将第二部分作为“实验性”，则它们的替代更改将是我们所需要的解决方案。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
换句话说，应用经验的代码每次都会增加下一次该动作将是随机的并且随机行动的可能性，这将增加在该循环的后续迭代中应用经验的可能性。因此，我们可以将所需的混乱变成经验，反之亦然-正是我们所需要的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种设计的一个不可思议的优点是，系统的骨化化完全没有问题，例如在相同的神经网络中就可以知道。另一方面，我们牺牲了稳定性，但是在这里我们不需要它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我希望在这里特别</font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强调</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">普通的古典程序员需要像天上一样的代码稳定性：识别必须稳定地识别，而不是每次服务器都必须不时对相应的客户请求提供规定的答案，而不是一次对相同的答案做出回应，然后再另一个，等等。等等在常规编程中，代码不稳定性是测试中很明显的错误。就我们而言，根本不需要这种稳定性，因为我们没有明确的代码任务。更确切地说，根本不是。但是我们可以用另一种方式来表达：我们需要更改控制传输代码的稳定性，然后得到它。也可以说，摆是稳定的，尽管它可以在一个周期内从一个点到达另一个点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了避免毫无根据，我建议在以下所有注意事项的指导下，查看我今天概述的以下Python基本代码。 </font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> random<font></font>
<font></font>
deter_numb = <span class="hljs-number">69</span>
p_deter = <span class="hljs-number">0.01</span>
p_random = <span class="hljs-number">0.99</span>
iteration = <span class="hljs-number">1</span><font></font>
<font></font>
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
        print(<span class="hljs-string">'iter = '</span>,iteration)<font></font>
        print(<span class="hljs-string">'p_rand =  '</span>, p_random)         <font></font>
        print(<span class="hljs-string">'p_deter = '</span>, p_deter)<font></font>
        input()<font></font>
        <span class="hljs-keyword">if</span> p_random &gt; random.random():<font></font>
            p_random-=<span class="hljs-number">0.01</span>                     <span class="hljs-comment">#  </span>
            p_deter+=<span class="hljs-number">0.01</span>
            print(random.random())    <span class="hljs-comment">#  </span>
        <span class="hljs-keyword">if</span> p_deter &gt; random.random():       <font></font>
            p_deter-=<span class="hljs-number">0.01</span>                      <span class="hljs-comment">#  </span>
            p_random+=<span class="hljs-number">0.01</span>
            print(deter_numb)            <span class="hljs-comment">#  </span>
        iteration+=<span class="hljs-number">1</span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我敦促您尝试自己运行此脚本，并查看其工作方式。</font><font style="vertical-align: inherit;">这是一个自平衡代码。</font><font style="vertical-align: inherit;">如动作1所示</font></font><pre><code class="python hljs">print(random.random())</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-即 </font><font style="vertical-align: inherit;">只是一个随机数输出，而动作2-</font></font><pre><code class="python hljs">print(deter_numb)</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-输出确定的数字。在代码中，将有动作代替它们，我在这里制作打印件只是为了演示其原理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当控件传递到第一个条件（代码的随机部分）时，代码本身降低了重复的可能性（p_random- = 0.01-自身递减），同时增加了应用经验的代码部分的执行概率（p_deter + = 0.01-他人的概率增加）。将控制权转移到第二个条件时，也会发生同样的事情。因此，这两段代码在执行时都会自己“放慢速度”并同时“分散”该代码的另一个“竞争”部分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，控制权转移到代码的随机部分的初始概率为99％，而实验性转移为1％-1％。这表明即使在这种根本不同的概率下，系统也是平衡的。在执行代码时，将看到在短短一百次迭代中该比率将如何达到50/50，形成了一个正态分布，其显式峰值为0.5，工作邻域约为6％（在接下来的3-5百次迭代中）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
执行代码时，很明显，概率达到平衡并稳定在0.5左右，平衡超过该点，就像在其较低点附近的钟摆平衡一样。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里可以看到另外一个功能：显示一个随机数或一个确定的数字（69），或者同时显示这两个数字，这意味着系统既可以应用经验，然后随机采取行动，反之亦然，或者可以应用经验，或者只是采取行动随机地。</font><font style="vertical-align: inherit;">换句话说，代码本身的执行仍然是随机的，但是我们已经使系统能够应用经验，即 </font><font style="vertical-align: inherit;">我们在决定采取行动时就摆脱了决心，这正是我们所需要的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在下一篇文章中，我们将考虑随机动作和经验的形成。</font><font style="vertical-align: inherit;">好吧，或者分别说一下，让我们看看它如何进行。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN499900/index.html">产品分析工具：免费，非接触式，在线</a></li>
<li><a href="../zh-CN499902/index.html">TCP重置攻击如何工作</a></li>
<li><a href="../zh-CN499904/index.html">“我很害怕”。该怎么办？</a></li>
<li><a href="../zh-CN499906/index.html">在玩具行业中使用AR的示例</a></li>
<li><a href="../zh-CN499908/index.html">深入探讨：如何在数字世界中实现选择自由</a></li>
<li><a href="../zh-CN499920/index.html">SSH小技巧</a></li>
<li><a href="../zh-CN499922/index.html">最后，我们处理Modbus波特率</a></li>
<li><a href="../zh-CN499926/index.html">4月30日Java摘要</a></li>
<li><a href="../zh-CN499928/index.html">Udalenka：COVID-19发生了什么变化，谁现在比以前更好</a></li>
<li><a href="../zh-CN499930/index.html">我如何在Go区块链上设计区块和交易</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>