<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥃 ⛩️ 👴🏾 Unreal Engine 4でUObjectを拡張する 👩🏿‍🚀 👨🏻‍🎓 👸🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="みなさん、こんにちは！私の名前はアレクサンダーです。私はアンリアルエンジンで5年以上、ほとんどすべての時間、ネットワークプロジェクトで働いています。
 
 ネットワークプロジェクトは開発要件とパフォーマンス要件が異なるため、UObjectクラスなどのより単純なオブジェクトを操作する必要があることがよ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unreal Engine 4でUObjectを拡張する</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/475622/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">みなさん、こんにちは！私の名前はアレクサンダーです。私はアンリアルエンジンで5年以上、ほとんどすべての時間、ネットワークプロジェクトで働いています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークプロジェクトは開発要件とパフォーマンス要件が異なるため、UObjectクラスなどのより単純なオブジェクトを操作する必要があることがよくありますが、その機能は最初は切り捨てられ、強力なフレームワークを作成できます。この記事では、Unreal Engine 4のUObject基本クラスでさまざまな機能をアクティブにする方法について説明します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fe/7o/ui/fe7ouisyxz09hjfen72lsdvx5ae.png"><br>
<br>
</p><p>  ,      .          ,          .      !    ,      UE4.   ++ ,     .    ,    ,    .  ,    ,             . <a name="habracut"></a></p><br>
<br>
<h2>  UObject</h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UObject</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、Unreal Engine 4にあるほぼすべての基本クラスです。ワールド内またはメモリ内に作成されるオブジェクトの大部分は、オブジェクトから継承されます。ステージ上のオブジェクト（AActor）、コンポーネント（UActorComponent）、操作するためのさまざまなタイプデータおよびその他。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラス自体は、派生クラスよりも簡単ですが、同時に非常に機能的です。たとえば、エディターでの変数の値の変更やネットワークの基本機能など、多くの便利なイベントが含まれていますが、これらはデフォルトではアクティブではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスによって作成されたオブジェクトをステージ上に置くことはできず、メモリ内にのみ存在します。アクターにコンポーネントとして追加することはできませんが、必要な機能を自分で実装する場合は一種のコンポーネントになる可能性があります。</font></font><br>
<br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AActorがすでに必要なすべてをサポートしているのに、なぜUObjectが必要なのですか？</font><font style="vertical-align: inherit;">一般的に、多くの使用例があります。</font><font style="vertical-align: inherit;">最も簡単なのは在庫アイテムです。</font><font style="vertical-align: inherit;">ステージでは、空のどこかにそれらを格納するのは実用的ではないため、レンダリングをロードしたり、不要なプロパティを作成したりせずに、それらをメモリに格納できます。</font><font style="vertical-align: inherit;">技術的な比較が好きな人のために、AActorは1キロバイト（1016バイト）を要し、空のUObjectはわずか56バイトです。</font></font></p><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UObjectの問題は何ですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、一般的に問題はない、または私はそれらに遭遇しなかった。</font><font style="vertical-align: inherit;">UObjectを悩ませているのは、AActorまたはコンポーネントでデフォルトで使用できるさまざまな機能がないことです。</font><font style="vertical-align: inherit;">私の練習で特定した問題は次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UObjectはネットワーク経由で複製されません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のポイントのため、RPCイベントをトリガーできません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブループリントで世界へのリンクを必要とする広範な機能セットを使用することはできません。</font></font></li>
<li>      BeginPlay  Tick;</li>
<li>    UObject’  AActor  .</li>
</ul><br>
<p>     .      .</p><br>
<br>
<h2> UObject</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスを機能で拡張する前に、クラスを作成する必要があります。エディターを使用して、ジェネレーターがヘッダー（.h）に動作するために必要なすべてを自動的に書き込むようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新規</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]ボタン</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">クリックして[ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいC ++クラス</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">を選択すること</font><font style="vertical-align: inherit;">により、コンテンツブラウザエディタで新しいクラスを作成できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x3/7r/8d/x37r8d1ahvstuxtpdnafshrnp9m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、クラス自体を選択する必要があります。これは一般的なリストにない場合があるため、開いてUObjectを選択します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p2/7d/dh/p27ddhbtq9bxgmjzobmozoa1tlk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスに名前を付け、それを保存するフォルダーを選択します。クラスを作成したら、スタジオに行ってそこで見つけ、必要なすべての関数の埋め込みを開始できます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初心者の方は、.hと.ccpの2つのファイルが作成されることに注意してください。</font><font style="vertical-align: inherit;">.hでは変数と関数を宣言し、.cppではそれらのロジックを定義します。</font><font style="vertical-align: inherit;">プロジェクトで両方のファイルを見つけます。</font><font style="vertical-align: inherit;">パスを変更しなかった場合、それらはProject / Source / Project /にあるはずです。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続行するまで、クラス宣言の上のUCLASS（）マクロに</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blueprintable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータを記述しましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次のようなものが得られるはずです：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.h</font></font></b><br>
<br>
<pre><code class="cpp hljs">UCLASS(Blueprintable)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROPJECT_API</span> <span class="hljs-title">UMyObject</span> :</span> <span class="hljs-keyword">public</span> UObject<font></font>
{<font></font>
 GENERATED_BODY()<font></font>
}<font></font>
</code></pre><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このおかげで、このオブジェクトで行うすべてを継承するブループリントを作成できます。</font></font></p><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UObjectレプリケーション</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトでは、UObjectはネットワーク経由で複製されません。上で説明したように、パーティ間でデータまたはロジックを同期する必要があるが、世界にゴミを保存しない場合、いくつかの制限が作成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アンリアルエンジン4では、ワールドオブジェクトによって正確に複製が行われます。それは単にメモリ内にオブジェクトを作成し、それを複製することが機能しないことを意味します。いずれの場合も、サーバーとクライアント間のオブジェクトデータの転送を管理する所有者が必要です。たとえば、オブジェクトがキャラクターのスキルである場合、キャラクターは所有者になる必要があります。また、ネットワークを介して情報を送信するための指揮者にもなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レプリケーション用にオブジェクトを準備します。これまでのところ、ヘッダーに設定する必要がある関数は1つだけです：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.h</font></font></b><br>
<br>
<pre><code class="cpp hljs">UCLASS(Blueprintable)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROPJECT_API</span> <span class="hljs-title">UMyObject</span> :</span> <span class="hljs-keyword">public</span> UObject<font></font>
{<font></font>
 GENERATED_BODY()<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
 <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IsSupportedForNetworking</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; };<font></font>
<font></font>
}<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsSupportedForNetworking（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、オブジェクトがネットワークをサポートし、複製可能であると判断します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、すべてがそれほど単純なわけではありません。上で書いたように、オブジェクトの転送を制御する所有者が必要です。実験の純粋さのために、それを複製するAActorを作成します。これは、UObjectとまったく同じ方法で実行できます。当然、親クラス、つまりAActorのみです。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初心者は、キャラクター、コントローラー、またはその他の場所でオブジェクトを複製する必要がある場合は、エディターを使用して適切な基本クラスを作成し、それに必要なロジックを追加して、ブループリントのこのクラスから継承します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部には、3つの関数が必要です。コンストラクタ、サブオブジェクトを複製する関数、このAActor内で複製されるもの（変数、オブジェクト参照など）を決定する関数と、オブジェクトを作成する場所です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトを保存する変数を作成することを忘れないでください：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.h</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROPJECT_API</span> <span class="hljs-title">AMyActor</span> :</span> <span class="hljs-keyword">public</span> AActor<font></font>
{<font></font>
 GENERATED_BODY()<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
 AMyActor();<font></font>
<font></font>
 <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ReplicateSubobjects</span> <span class="hljs-params">(class UActorChannel *Channel, class FOutBunch *Bunch, FReplicationFlags *RepFlags)</span> <span class="hljs-keyword">override</span></span>;<font></font>
<font></font>
 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetLifetimeReplicatedProps</span> <span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<font></font>
<font></font>
 <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span> <span class="hljs-params">()</span></span>;<font></font>
<font></font>
 UPROPERTY(Replicated, BlueprintReadOnly, Category=<span class="hljs-string">"Object"</span>)
 <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UMyObject</span>* <span class="hljs-title">MyObject</span>;</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースファイル内にすべてを書き込む必要があります：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.cpp</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// </span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"MyActor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Net/UnrealNetwork.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Engine/World.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Engine/ActorChannel.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"   UObject/MyObject.h"</span></span><font></font>
<font></font>
AMyActor::AMyActor()<font></font>
{<font></font>
 <span class="hljs-comment">//  Actor  .</span>
 bReplicates = <span class="hljs-literal">true</span> 
 <span class="hljs-comment">// .</span>
 NetCullDistanceSquared = <span class="hljs-number">99999</span>;
 <span class="hljs-comment">//  (  ). </span>
 NetUpdateFrequency = <span class="hljs-number">1.f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AMyActor::GetLifetimeReplicatedProps</span> <span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span>
</span>{<font></font>
 Super::GetLifetimeReplicatedProps(OutLifetimeProps);<font></font>
<font></font>
 <span class="hljs-comment">//       .           .</span><font></font>
 DOREPLIFETIME(AMyActor, MyObject);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">AMyActor::ReplicateSubobjects</span><span class="hljs-params">(UActorChannel * Channel, FOutBunch * Bunch, FReplicationFlags * RepFlags)</span>
</span>{
 <span class="hljs-keyword">bool</span> WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);<font></font>
<font></font>
 <span class="hljs-comment">//   .</span>
 <span class="hljs-keyword">if</span> (MyObject ) WroteSomething |= Channel-&gt;ReplicateSubobject(MyObject , *Bunch, *RepFlags);<font></font>
<font></font>
 <span class="hljs-keyword">return</span> WroteSomething;<font></font>
}<font></font>
<font></font>
AMyActor::BeginPlay()<font></font>
{<font></font>
 <span class="hljs-comment">/*
       (  )  . 
    this.        . ,       ,     .
 */</span>
 <span class="hljs-keyword">if</span>(HasAuthority()) <font></font>
 {<font></font>
  MyObject = NewObject&lt;UMyObject&gt;(<span class="hljs-keyword">this</span>);<font></font>
<font></font>
  <span class="hljs-comment">//      </span>
  <span class="hljs-keyword">if</span>(MyObject) UE_LOG(LogTemp, Log, TEXT(<span class="hljs-string">"%s created"</span>), *MyObject-&gt;GetName());<font></font>
 }<font></font>
}<font></font>
</code></pre><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これで、オブジェクトがこのアクターで複製されます。</font><font style="vertical-align: inherit;">ダニには名前を表示できますが、すでにクライアント上にあります。</font><font style="vertical-align: inherit;">Begin Playでは、オブジェクトがクライアントの前に到着する可能性は低いため、オブジェクトにログを書き込んでも意味がないことに注意してください。</font></font></p><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UObjectでの変数の複製</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、サーバーとクライアント間で同期される情報も含まれていないオブジェクトを複製しても意味がありません。</font><font style="vertical-align: inherit;">オブジェクトはすでに複製されているため、変数を渡すことは難しくありません。</font><font style="vertical-align: inherit;">これは、アクター内と同じ方法で行われます：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.h</font></font></b><br>
<br>
<pre><code class="cpp hljs">UCLASS(Blueprintable)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROPJECT_API</span> <span class="hljs-title">UMyObject</span> :</span> <span class="hljs-keyword">public</span> UObject<font></font>
{<font></font>
 GENERATED_BODY()<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
 <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IsSupportedForNetworking</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; };<font></font>
<font></font>
 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetLifetimeReplicatedProps</span> <span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<font></font>
<font></font>
 UPROPERTY(Replicated, BlueprintReadWrite, Category=<span class="hljs-string">"Object"</span>)
 <span class="hljs-keyword">int</span> MyInteger;<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
}<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.cpp</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// </span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"MyObject.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Net/UnrealNetwork.h"</span></span><font></font>
<font></font>
UMyObject ::UMyObject ()<font></font>
{<font></font>
 <span class="hljs-comment">//  Object  .     .</span>
 bReplicates = <span class="hljs-literal">true</span> 
 <span class="hljs-comment">//       ,     .</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">void</span> UMyObject ::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)<font></font>
{<font></font>
 Super::GetLifetimeReplicatedProps(OutLifetimeProps);<font></font>
<font></font>
 <span class="hljs-comment">//   Integer  .</span><font></font>
 DOREPLIFETIME(UMyObject, MyInteger);<font></font>
}<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数を追加し、レプリケーションのフラグを立てることで、変数をレプリケートできます。</font><font style="vertical-align: inherit;">すべてがシンプルで、AActorと同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、すぐには表示されないが、誤解を招く可能性のある小さな落とし穴があります。</font><font style="vertical-align: inherit;">これは、C ++で動作するためではなく、ブループリントでの継承と動作のためにUObjectを作成する場合に特に顕著です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要点は、ブループリントの後継で作成された変数は複製されないということです。</font><font style="vertical-align: inherit;">エンジンは自動的にそれらにマークを付けず、BPのサーバーでパラメーターを変更しても、クライアントの値は何も変更されません。</font><font style="vertical-align: inherit;">しかし、これには治療法があります。</font><font style="vertical-align: inherit;">BP変数を正しく複製するには、事前に変数にマークを付ける必要があります。</font><font style="vertical-align: inherit;">GetLifetimeReplicatedProps（）に数行を追加します：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.cpp</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">void</span> UMyObject ::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)<font></font>
{<font></font>
 Super::GetLifetimeReplicatedProps(OutLifetimeProps);<font></font>
<font></font>
 <span class="hljs-comment">//   Integer  .</span><font></font>
 DOREPLIFETIME(UMyObject, MyInteger);<font></font>
<font></font>
 <span class="hljs-comment">//      </span><font></font>
 UBlueprintGeneratedClass* BPClass = Cast&lt;UBlueprintGeneratedClass&gt;(GetClass());<font></font>
 <span class="hljs-keyword">if</span> (BPClass) BPClass-&gt;GetLifetimeBlueprintReplicationList(OutLifetimeProps);<font></font>
<font></font>
}<font></font>
</code></pre><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子ブループリントクラスの変数が期待どおりに複製されるようになりました。</font></font></p><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UObjectのRPCイベント</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RPC（リモートプロシージャコール）イベントは、プロジェクトのネットワーク対話の反対側で呼び出される特別な関数です。</font><font style="vertical-align: inherit;">それらを使用して、他のクライアントのサーバーおよびサーバーのクライアントから関数を呼び出すことができます。</font><font style="vertical-align: inherit;">非常に便利で、ネットワークプロジェクトを作成するときによく使用されます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらに慣れていない場合は、1つの記事を読むことをお勧めします。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++とBlueprintsでの使用法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について説明してい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actorまたは呼び出しのコンポーネントには問題はありませんが、UObjectイベントでは、呼び出されたのと同じ側でイベントが発生するため、必要なときにリモート呼び出しを行うことができません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントコード（UActorComponent）を見ると、ネットワーク経由で呼び出しを転送できるいくつかの関数が見つかります。</font><font style="vertical-align: inherit;">UObjectからUActorComponentの継承ので、私たちは、単にコードの必要なセクションをコピーすることができますし、それが必要として動作するように私たちのオブジェクトに貼り付けます</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.Hを</font></font></b><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-comment">//  </span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Engine/EngineTypes.h"</span></span><font></font>
<font></font>
UCLASS(Blueprintable)<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROPJECT_API</span> <span class="hljs-title">UMyObject</span> :</span> <span class="hljs-keyword">public</span> UObject<font></font>
{<font></font>
 GENERATED_BODY()<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
 <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">CallRemoteFunction</span> <span class="hljs-params">(UFunction * Function, <span class="hljs-keyword">void</span> * Parms, struct FOutParmRec * OutParms, FFrame * Stack)</span> <span class="hljs-keyword">override</span></span>;<font></font>
<font></font>
 <span class="hljs-function"><span class="hljs-keyword">virtual</span> int32 <span class="hljs-title">GetFunctionCallspace</span> <span class="hljs-params">(UFunction* Function, <span class="hljs-keyword">void</span>* Parameters, FFrame* Stack)</span> <span class="hljs-keyword">override</span></span>;<font></font>
<font></font>
 <span class="hljs-comment">//  </span><font></font>
<font></font>
}<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.cpp</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  </span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Engine/NetDriver.h"</span></span><font></font>
<font></font>
<span class="hljs-comment">//       .</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UMyObject::CallRemoteFunction</span><span class="hljs-params">(UFunction * Function, <span class="hljs-keyword">void</span> * Parms, FOutParmRec * OutParms, FFrame * Stack)</span>
</span>{
 <span class="hljs-keyword">if</span> (!GetOuter()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
 UNetDriver* NetDriver = GetOuter()-&gt;GetNetDriver();<font></font>
 <span class="hljs-keyword">if</span> (!NetDriver) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
<font></font>
 NetDriver-&gt;ProcessRemoteFunction(GetOuter(), Function, Parms, OutParms, Stack, <span class="hljs-keyword">this</span>);<font></font>
<font></font>
 <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">int32 <span class="hljs-title">UMyObject::GetFunctionCallspace</span><span class="hljs-params">(UFunction * Function, <span class="hljs-keyword">void</span> * Parameters, FFrame * Stack)</span>
</span>{
 <span class="hljs-keyword">return</span> (GetOuter() ? GetOuter()-&gt;GetFunctionCallspace(Function, Parameters, Stack) : FunctionCallspace::Local);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの関数を使用すると、コードだけでなくブループリントでもRPCイベントをトリガーできます。 </font></font><br>
<br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントまたはサーバーイベントをトリガーするには、所有者が私たちのプレーヤーである所有者が必要です。</font><font style="vertical-align: inherit;">たとえば、オブジェクトはユーザーのキャラクターによって所有されているか、Ownerがプレーヤーのプレーヤーコントローラーであるオブジェクトです。</font></font></p><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブループリントのグローバル機能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトブループリントを作成したことがある場合は、GetGamemode（）などの他のクラスで使用できるグローバル関数（静的ですが、わかりやすくするために呼び出す）を呼び出せないことに気づいたかもしれません。 Objectクラスでクラスを実行することはできないようです。そのため、作成時にすべてのリンクを渡すか、なんとなく変態にする必要があり、選択はステージ上で作成されたActorクラスに完全に当てはまる場合があります。世界のすべてをサポートしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、C ++では、そのような問題はありません。ただし、設定を操作してさまざまな小さなことを追加するゲームデザイナーは、Visual Studioを開いて適切なクラスを見つけ、そのポイントを変更してdoSomething（）関数でゲームモードを取得する必要があるとは言えません。したがって、デザイナーがBlooprintにログインし、2回のクリックで自分の仕事を実行できることが不可欠です。彼とあなたの両方の時間を節約してください。ただし、ブループリントはこのために発明されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、Bluprintのコンテキストメニューで関数を検索または呼び出すと、世界への参照を必要とする同じグローバル関数が、それを参照するオブジェクト内の関数を呼び出そうとします。また、編集者は、機能がないことを確認すると、使用できないことを理解し、リストに表示しません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bb/mj/gu/bbmjguakea7gkb-roirojnwnrsg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これには治療法があります。</font><font style="vertical-align: inherit;">2つでも。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、エディターでより便利に使用するためのオプションを検討しましょう。</font><font style="vertical-align: inherit;">世界への参照を返す関数を再定義する必要があります。そうすると、エディターはゲーム自体で機能することを理解します：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.h</font></font></b><br>
<br>
<pre><code class="cpp hljs">UCLASS(Blueprintable)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROPJECT_API</span> <span class="hljs-title">UMyObject</span> :</span> <span class="hljs-keyword">public</span> UObject<font></font>
{<font></font>
 GENERATED_BODY()<font></font>
<font></font>
 <span class="hljs-comment">//  GetWorld()    .</span>
 <span class="hljs-function"><span class="hljs-keyword">virtual</span> UWorld* <span class="hljs-title">GetWorld</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<font></font>
<font></font>
 <span class="hljs-comment">//  </span><font></font>
}<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.cpp</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">UWorld* <span class="hljs-title">UMyObject::GetWorld</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
</span>{
 <span class="hljs-comment">//       ,    .</span>
<span class="hljs-keyword">if</span> (GIsEditor &amp;&amp; !GIsPlayInEditorWorld) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; 
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (GetOuter()) <span class="hljs-keyword">return</span> GetOuter()-&gt;GetWorld(); 
<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで定義され、一般にオブジェクトは目的のポインターを取得でき（無効ではあります）、BPでグローバル関数を使用できることがエディターで理解されます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有者（GetOuter（））もワールドにアクセスできる必要があることに注意してください。シーン内の特定のGetWorld（）、コンポーネント、またはActorオブジェクトを持つ別のUObjectである可能性があります。</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/7x/wu/w3/7xwuw3u7qkekz9m6-bnhdfd0o10.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
別の方法があります。 WorldContextObjectパラメータがBPの静的関数に追加されるクラスを宣言するときに、UCLASS（）マクロにラベルを追加するだけで十分です。BPの静的関数には、エンジンの「世界」およびグローバル関数へのコンダクターとして機能するすべてのオブジェクトが供給されます。このオプションは、プロジェクト内で同時に複数のワールドを持つことができるユーザーに適しています（たとえば、ゲームのワールドと観客のワールド）</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：.h</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   WorldContext     </span><font></font>
UCLASS(Blueprintable, meta=(ShowWorldContextPin))<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROPJECT_API</span> <span class="hljs-title">UMyObject</span> :</span> <span class="hljs-keyword">public</span> UObject<font></font>
{<font></font>
 GENERATED_BODY()<font></font>
 <span class="hljs-comment">//  </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GetGamemodeをBPの検索に入力すると、他の同様の関数と同様にリストに表示され、パラメーターはWorldContextObjectになり、そこにアクターへのリンクを渡す必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nn/uo/xg/nnuoxgsfj912bnoa5fheedsz3yk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ところで、あなたは私たちの財産の所有者をそこに提出することができます。</font><font style="vertical-align: inherit;">Actorで関数を作成することをお勧めします。これは常にオブジェクトに役立ちます：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.h</font></font></b><br>
<br>
<pre><code class="cpp hljs">UCLASS(Blueprintable, meta=(ShowWorldContextPin))
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROPJECT_API</span> <span class="hljs-title">UMyObject</span> :</span> <span class="hljs-keyword">public</span> UObject<font></font>
{<font></font>
 GENERATED_BODY()<font></font>
<font></font>
<span class="hljs-comment">//      ,     .</span>
<span class="hljs-keyword">public</span>: <font></font>
 UFUNCTION(BlueprintPure)<font></font>
 <span class="hljs-function">AActor* <span class="hljs-title">GetOwner</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{<span class="hljs-keyword">return</span> Cast&lt;AActor&gt;(GetOuter());};<font></font>
<font></font>
 <span class="hljs-comment">//  </span><font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、Pure関数と組み合わせてグローバル関数を使用するだけで、所有者を取得できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ux/22/7w/ux227wpx_b6yp8l8vnlutwxywu8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のバリアントのように2番目のバリアントでGetWorld（）も宣言する場合、WorldContextObjectパラメータで自分（SelfまたはThis）への参照を送信できます。</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/op/jh/mb/opjhmbcmm5jsktm_gtxk-jkgzyy.png"></p><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BeginPlayおよびTickイベント</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブループリント開発者が遭遇する可能性のあるもう1つの問題は、ObjectクラスにBeginPlayおよびTickイベントがないことです。</font><font style="vertical-align: inherit;">もちろん、自分で作成して別のクラスから呼び出すこともできます。</font><font style="vertical-align: inherit;">ただし、すべてをそのまま使用すると、はるかに便利になることにも同意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Begin Playを作成する方法から始めましょう。</font><font style="vertical-align: inherit;">BPで書き換え可能な関数を作成し、クラスのコンストラクターで呼び出すことができますが、コンストラクターの時点ではオブジェクトがまだ完全に初期化されていないため、いくつかの問題があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのクラスにはPostInitProperties（）関数があり、これは、ガベージコレクターなど、さまざまな内部システムでほとんどのパラメーターの初期化とオブジェクトの登録の後に呼び出されます。</font><font style="vertical-align: inherit;">その中で、ブループリントで使用されるイベントを呼び出すだけです：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.h</font></font></b><br>
<br>
<pre><code class="cpp hljs">UCLASS(Blueprintable)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROPJECT_API</span> <span class="hljs-title">UMyObject</span> :</span> <span class="hljs-keyword">public</span> UObject<font></font>
{<font></font>
 GENERATED_BODY()<font></font>
<font></font>
 <span class="hljs-comment">//      .</span>
 <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PostInitProperties</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<font></font>
<font></font>
 <span class="hljs-comment">// ,      .</span><font></font>
 UFUNCTION(BlueprintImplementableEvent)<font></font>
 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
 <span class="hljs-comment">//  </span><font></font>
}<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.cpp</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyObject::PostInitProperties</span><span class="hljs-params">()</span>
</span>{<font></font>
 Super::PostInitProperties();<font></font>
<font></font>
 <span class="hljs-comment">//   ,   .   BeginPlay   </span>
 <span class="hljs-keyword">if</span>(GetOuter() &amp;&amp; GetOuter()-&gt;GetWorld()) <font></font>
 BeginPlay();<font></font>
}<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if（GetOuter（）&amp;&amp; GetOuter（）-&gt; GetWorld（））の代わりに、if（GetWorld（））を既に再定義している場合は、単純に置くことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意してください！</font><font style="vertical-align: inherit;">デフォルトでは、PostInitProperties（）もエディターで呼び出されます。</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、BPオブジェクトに移動して、BeginPlayイベントを呼び出すことができます。</font><font style="vertical-align: inherit;">オブジェクトが作成されたときに呼び出されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントティックに移りましょう。</font><font style="vertical-align: inherit;">私たちには単純な機能はありません。</font><font style="vertical-align: inherit;">エンジン内のティックオブジェクトは特別なマネージャーを呼び出し、そこに何とかしてピックアップする必要があります。</font><font style="vertical-align: inherit;">ただし、ここには非常に便利なトリックがあります。FTickableGameObjectからの追加の継承です。</font><font style="vertical-align: inherit;">これは自動的にあなたが必要なすべてを行うことができますし、それが必要な機能をピックアップするだけで十分でしょう：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.hのを</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  </span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Tickable.h"</span></span><font></font>
<font></font>
<span class="hljs-comment">//   c FTickableGameObject</span><font></font>
UCLASS(Blueprintable)<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROPJECT_API</span> <span class="hljs-title">UMyObject</span> :</span> <span class="hljs-keyword">public</span> UObject, <span class="hljs-keyword">public</span> FTickableGameObject<font></font>
{<font></font>
 GENERATED_BODY()<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
 <span class="hljs-comment">//  </span>
 <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;
 <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IsTickable</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;
 <span class="hljs-function"><span class="hljs-keyword">virtual</span> TStatId <span class="hljs-title">GetStatId</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>;<font></font>
<font></font>
<span class="hljs-keyword">protected</span>:<font></font>
<font></font>
 <span class="hljs-comment">//    </span><font></font>
 UFUNCTION(BlueprintImplementableEvent)<font></font>
 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventTick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span></span>;<font></font>
<font></font>
 <span class="hljs-comment">//  </span><font></font>
}<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.cpp</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UMyObject::Tick</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaTime)</span>
</span>{
 <span class="hljs-comment">//       .</span><font></font>
 EventTick(DeltaTime);<font></font>
<font></font>
 <span class="hljs-comment">//     .</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UMyObject::IsTickable</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
</span>{
	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">TStatId <span class="hljs-title">UMyObject::GetStatId</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
</span>{
	<span class="hljs-keyword">return</span> TStatId();<font></font>
}<font></font>
</code></pre><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトから継承してBPクラスを作成すると、各フレームにロジックを引き起こすEventTickイベントが利用可能になります。</font></font></p><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UObjectsからコンポーネントを追加する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UObjectブループリントでは、アクターのコンポーネントを生成することはできません。</font><font style="vertical-align: inherit;">同じ問題がActorComponentのブループリントに固有です。</font><font style="vertical-align: inherit;">Epic Gamesのロジックはあまり明確ではありません。C++ではこれが可能だからです。</font><font style="vertical-align: inherit;">さらに、リンクを指定するだけで、Actorから別のActorオブジェクトにコンポーネントを追加できます。</font><font style="vertical-align: inherit;">しかし、これは実行できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、このアイテムはわかりませんでした。</font><font style="vertical-align: inherit;">これを行う方法について誰かが指示があれば、私はそれをここに投稿して喜んでいます。</font></font><br>
<br>
<p> ,        —      UObject,      .      Actor’,          . ,   .</p><br>
<br>
<h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UE4には、オブジェクトを操作するための便利な「機能」がもう1つあります。これは、初期化中にインスタンスを作成し、そのパラメーターをエディターで変更できるため、設定のために子クラスを作成することなく、そのプロパティを設定できます。ゲームデザイナーに特に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャラクターのモディファイアマネージャーがあり、モディファイア自体が、スーパーインポーズされた効果を説明するクラスによって表されているとします。ゲームデザイナーは修飾子のペアを作成し、どの修飾子が使用されているかをマネージャーで示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常の状況では、次のようになります</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.H</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROPJECT_API</span> <span class="hljs-title">AMyActor</span> :</span> <span class="hljs-keyword">public</span> AActor<font></font>
{<font></font>
 GENERATED_BODY()<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
 UPROPERTY(EditAnywhere)<font></font>
 TSubclassOf&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UMyObject</span>&gt; <span class="hljs-title">MyObjectClass</span>;</span><font></font>
}<font></font>
</code></pre><br>
<img src="https://habrastorage.org/webt/hd/rx/zc/hdrxzc1qsu2d9htiydsmgfy1t-0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、修飾子を構成できず、他の値用に追加のクラスを作成する必要があるという問題があります。</font><font style="vertical-align: inherit;">同意します。コンテンツブラウザに、値のみが異なる多数のクラスを用意するのはあまり便利ではありません。</font><font style="vertical-align: inherit;">これを修正するのは簡単です。</font><font style="vertical-align: inherit;">あなたはUSTRUCT内部のフィールドのカップルを（）を追加し、また私たちのオブジェクトはインスタンスではなく、存在しないオブジェクトやクラスへの参照のみになることをコンテナオブジェクトに指示することができます</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.H</font></font></b><br>
<br>
<pre><code class="cpp hljs">UCLASS(Blueprintable, DefaultToInstanced, EditInlineNew) <span class="hljs-comment">//  -       </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROPJECT_API</span> <span class="hljs-title">UMyObject</span> :</span> <span class="hljs-keyword">public</span> UObject<font></font>
{<font></font>
 GENERATED_BODY()<font></font>
<font></font>
 UPROPERTY(EditAnywhere) <span class="hljs-comment">//      </span>
 uint8 MyValue; <span class="hljs-comment">// ,   </span><font></font>
<font></font>
 <span class="hljs-comment">//  </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これだけでは不十分です。クラスと同じ変数がインスタンスになることを示す必要があります。</font><font style="vertical-align: inherit;">これは、オブジェクトを格納する場所で既に行われています。たとえば、文字修飾子マネージャー：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.h</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MYPROPJECT_API</span> <span class="hljs-title">AMyActor</span> :</span> <span class="hljs-keyword">public</span> AActor<font></font>
{<font></font>
 GENERATED_BODY()<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
 UPROPERTY(EditAnywhere, Instanced) <span class="hljs-comment">//   Instanced   </span>
 <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UMyObject</span>* <span class="hljs-title">MyObject</span>;</span> <span class="hljs-comment">//   </span><font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期化の直後にインスタンスが作成されるため、クラスではなくオブジェクトへの参照を使用することに注意してください。</font><font style="vertical-align: inherit;">これで、エディターウィンドウに移動してクラスを選択し、インスタンス内の値を調整できます。</font><font style="vertical-align: inherit;">はるかに便利で柔軟性があります。</font></font><br>
<br>
<p><img src="https://habrastorage.org/getpro/habr/post_images/ee4/1cd/e76/ee41cde76aed943c03f0a15ff2e903f6.png" alt="画像"></p><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情報</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アンリアルエンジンには別の興味深いクラスがあります。これはAInfoです。 AActorから継承されたクラスで、世界では視覚的な表現はありません。 Infoは、ゲームモード、GameState、PlayerStateなどのクラスを使用します。つまり、レプリケーションなど、AActorとは異なるチップをサポートするが、シーンには配置されないクラスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークと結果のすべてのActorクラスをサポートする追加のグローバルマネージャーを作成する必要がある場合は、それを使用できます。上記のようにUObjectクラスを操作して、データを複製するなど、強制する必要はありません。</font></font><br>
<br>
<p> ,       ,        ,      Actor ,  ,   ,   .        .</p><br>
<br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UObjectは非常に頻繁に必要になるため、アクターが本当に必要でない場合は常に使用することをお勧めします。少し限定されているのは残念ですがプラスでもあります。カスタムテンプレートを使用する必要がある場合は、いじくり回す必要がありますが、最も重要なのは、すべての主要な制限を削除できることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブループリントのオブジェクトを頻繁に使用するが、クラスを常に作成してこれらの機能を追加したくない場合は、プロジェクトで必要なすべての機能をサポートする1​​つのUObjectクラスを作成し、そこから子プリントを作成して作業することができます。それらの中で。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事がアンリアルエンジン4の学習や作業に役立つことを願っています。突然コンパイルできない部分がある場合は、コメントまたはPMで報告できます。</font><font style="vertical-align: inherit;">また、他の誰かがUObjectに関連するさまざまな有用性を知っていれば、とても感謝します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja475608/index.html">Googleタグマネージャー：わかりにくい、便利なトリガー設定</a></li>
<li><a href="../ja475610/index.html">視覚を保持する安全なLEDテーブルランプ</a></li>
<li><a href="../ja475612/index.html">与えられたとき、主張と実装の信頼性</a></li>
<li><a href="../ja475614/index.html">最小のオートメーション。二部。ネットワーク設計</a></li>
<li><a href="../ja475618/index.html">OntologyネットワークでスマートPythonコントラクトを作成する方法。パート2：ストレージAPI</a></li>
<li><a href="../ja475624/index.html">PHP-Watcher：長寿命のアプリケーションの開発を簡素化するツール</a></li>
<li><a href="../ja475626/index.html">脆弱性を探す人を自動テストで置き換えることができますか：Alexandra Svatikovaへのインタビュー</a></li>
<li><a href="../ja475630/index.html">Knative-サーバーレスサポートを備えたサービスとしてのk8sベースのプラットフォーム</a></li>
<li><a href="../ja475636/index.html">増分ベクトル要素</a></li>
<li><a href="../ja475640/index.html">何かを作成する場合は、マネージャーのスケジュールを避けてください。</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>