<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå´Ô∏è üßóüèø üë®üèº PRESENT - Ultra-Lightweight Block Encryption (translation of the original PRESENT: An Ultra-Lightweight Block Cipher) üë≤üèΩ üß† üõ¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! Here is the translation of the original article ‚ÄúPRESENT: An Ultra-Lightweight Block Cipher‚Äù by Robert B. Weide Bogdanov, Lender, Paar, P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PRESENT - Ultra-Lightweight Block Encryption (translation of the original PRESENT: An Ultra-Lightweight Block Cipher)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487542/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr! </font><font style="vertical-align: inherit;">Here is the translation of the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">original article ‚ÄúPRESENT: An Ultra-Lightweight Block Cipher‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by </font></font><strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Robert B. Weide</font></font></strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bogdanov, Lender, Paar, Poshman, Robshav, Seurin and Wikkelsoy.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/n7/eg/txn7egneg1_32856cpillz8r9_a.jpeg" width="400"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">annotation</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With the introduction of </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><abbr title="Advanced encryption standard"><font style="vertical-align: inherit;">AES, the</font></abbr></a><font style="vertical-align: inherit;"> need for new block cipher algorithms has plummeted, since in most cases </font><acronym><font style="vertical-align: inherit;">AES</font></acronym><font style="vertical-align: inherit;"> is a great solution. </font><font style="vertical-align: inherit;">However, despite its ease of implementation, </font><acronym><font style="vertical-align: inherit;">AES is</font></acronym><font style="vertical-align: inherit;"> not suitable for extremely limited environments such as </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><abbr title="Radio Frequency IDentification"><font style="vertical-align: inherit;">RFID</font></abbr></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"> tags and readers</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This article will describe the ultra-lightweight block encryption algorithm PRESENT. </font><font style="vertical-align: inherit;">During the development of this algorithm, both the efficiency of implementation in iron and the reliability of encryption were taken into account. </font><font style="vertical-align: inherit;">As a result, the result of system requirements is comparable to today's leading compact stream ciphers.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"> <abbr title="Advanced encryption standard"><font style="vertical-align: inherit;"></font></abbr></a><font style="vertical-align: inherit;"></font><acronym><font style="vertical-align: inherit;"></font></acronym><font style="vertical-align: inherit;"></font><acronym><font style="vertical-align: inherit;"></font></acronym><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><abbr title="Radio Frequency IDentification"><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Introduction</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main course in IT of the current century is the development of small computing devices, which are used not only in consumer products, but also form an integral - and invisible - part of the environment - communication infrastructure. It has already been revealed that such implementations create a whole range of very specific security threats. At the same time, available cryptographic solutions, even rather primitive ones, are often not suitable for use in highly resource-limited environments. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article, we offer a new, hardware-optimized block cipher algorithm, developed with the maximum possible size and power limitations. At the same time, we tried to avoid compromising data. To achieve this, we took advantage of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><abbr title="Data Encryption Standard - Algorithm for Symmetric Encryption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DES</font></font></abbr></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> experience </font><font style="vertical-align: inherit;">and supplemented the properties</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><abbr title="AES contest finalist algorithm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serpent</font></font></abbr></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as having shown amazing performance in hardware.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhaps it‚Äôs worth explaining why we decided to develop a new block cipher, because the generally accepted fact is that stream ciphers are potentially more compact. Indeed, in the beginning we made efforts to understand the design of compact stream ciphers in the process of working on the</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eSTREAM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project</font><font style="vertical-align: inherit;">, as well as several other promising assumptions that seem to be quick-acting. But we noticed several reasons why we nevertheless chose a block cipher. Firstly, block encryption is universal and primitive, and when used in</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> encryption mode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, i.e. using the already encrypted blocks to encrypt the following, we get streaming encryption. Secondly, and, perhaps, mainly, the intricacies of the principles of operation of block ciphers seem to be better studied than the principles of operation of stream encryption algorithms. For example, while there is an extensive theory based on the use of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shift registers with linear feedback</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it is not so easy to combine these blocks in such a way as to get a safe offer. We assume that a neatly designed block cipher may be more secure than a freshly created stream cipher. Thus, we find that a block cipher that requires as much iron resources as a compact stream cipher can be very interesting.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is important to note that when creating a new block cipher algorithm, especially with eye-catching performance, we do not just pursue innovation. On the contrary, the development and implementation of the cipher goes hand in hand, revealing some fundamental limits and inherent limitations. For example, a given level of security imposes restrictions on the minimum key and block lengths. Even processing a 64-bit state with an 80-bit key limits the minimum device size. You can also notice that the embodiment in hardware - especially the compactness of the hardware implementation - contributes to repeatability. Even small changes can adversely affect the volume of the device. However, cryptanalysts also value repeatability and look for mathematical structures that easily multiply in many rounds.So how many simple repeating structures can be used without compromising system security?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, this article will describe the compact block cipher PRESENT. </font><font style="vertical-align: inherit;">After a short review of the existing literature, we designed the rest of the article in a standard form. </font><font style="vertical-align: inherit;">The code is described in section 3, in section 4 design decisions are described. </font><font style="vertical-align: inherit;">In section 5 we will consider security, while section 6 will contain a detailed analysis of performance. </font><font style="vertical-align: inherit;">This work ends with our conclusions.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Existing works</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
While the volume of work devoted to cheap cryptography is constantly growing, the number of articles devoted to super-light ciphers is surprisingly small. Moving focus to the protocol device, we will no longer refer to works on cheap communication and identification protocols. One of the most extensive work on compact implementation is currently associated with the eSTREAM project. As part of one part of this project, new stream ciphers adapted for effective implementation in hardware were proposed. In the course of this work, promising candidates are outlined. So far, the ratios are approximate, but it follows from the implementation brochures that compact ciphers of the eSTREAM project will require about 1300-2600 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GE (Gate equivalents)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Among the block ciphers, one of the widely known, namely DES, was created taking into account the efficiency of the equipment. Bearing in mind the very limited state of semiconductors in the early 1970s, it is not surprising that DES has very competitive implementation properties. During development, 3000GE was spent on DES, and after </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serialization,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this number dropped to 2300GE. However, the DES key length limits its usefulness in many applications and leads to the fact that specialized modifications are developed on its basis, for example, with increased cryptographic strength or an extended key. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regarding modern block ciphers, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> provides a thorough analysis of low-cost </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AES</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">However, its implementation requires about 3,600 GE, which is an indirect consequence of the design of fines for 8- and 32-bit processors. </font><font style="vertical-align: inherit;">The system requirements &lt;a href = " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TEA are</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> not known, but according to estimates they require about 2100 GE. There are 4 more solutions that are designed for low-cost equipment: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mCRYPTON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (has an exact execution of 2949 GE), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HIGHT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (about 3000 GE), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (about 2280 GE) and CGEN (also about 2280 GE), despite the fact that the latter was not conceived as a block cipher.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Block cipher PRESENT</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PRESENT is a special case of the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SP network</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and consists of 31 rounds. The block length is 64 bits, and the keys are supported in 2 versions, 80- and 128-bit. This level of protection should be enough for low-security applications that are usually used for deployment based on tags, and in addition, more importantly, PRESENT largely coincides in its design features with stream ciphers of the eSTREAM project, sharpened for effective implementation in hardware, which allows us to adequately compare their. </font></font><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Security requirements and operational properties of 128-bit versions are provided in the appendix to the original article.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Each of the 31 rounds consists of an XOR operation to enter the key K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for 1 ‚â§ i ‚â§ 32, where K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32 is</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used for</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúBleaching‚Äù the key</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , linear bitwise permutation and non-linear substitution layer (or, more simply, increasing the strength of encryption). The non-linear layer uses separate 4-bit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S-blocks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which are applied in parallel 16 times in each round. The cipher described by the pseudo-code is shown in the figure: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/39/jf/bc/39jfbcgtriqxlsbdkyojjycyc_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now each stage is determined in turn. The design justifications are given in Section 4, and bits are numbered everywhere from scratch, starting with the right one in a block or word. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adding a round key (addRoundKey).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The round key K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where 1 ‚â§ i ‚â§ 32, as well as the current state b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Adding a round key to the current state occurs modulo 2 (b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚äï k </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where 0 ‚â§ j ‚â§ 63). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S-Box Layer (sBoxlayer).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The S-blocks used in PRESENT map 4-bit blocks to 4-bit blocks. The action of this block in the hexadecimal number system is shown in the following table: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5d/dv/2a/5ddv2ahldslwpoziqdpth4a5dwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the S-block layer, the current state b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is 16 4-bit words w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i + 3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> || b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i + 2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> || b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> || b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for 0 ‚â§ i ‚â§ 15. Frame output S [w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">] returns updated state values ‚Äã‚Äãin an obvious way. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permutation layer (pLayer).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bitwise permutation used PRESENT defined in the following table (the state of bit i is shifted to the position P (i)): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/et/bh/ng/etbhngoueocjgcnf0hhswl-lobs.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Key Conversion ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The key schedule</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRESENT can use 80- and 128-bit keys, however, we will focus on the 80-bit version. The key provided by the user is stored in the key register K, represented as k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . On the i-th round, a 64-bit round key K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">62</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, consisting of 64 left bits of the current contents of register K. Thus, in the i-th round we have: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">62</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After unpacking the round key K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i, the</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> key register K = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 is</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> updated as follows: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] = [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">77</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">76</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] = S [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">77</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">76</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] = [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] ‚äï round_counter </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, register the key is shifted 61 positions to the left, the 4 leftmost bits passed through the S-block and round_counter the value of i is added modulo 2 with bits k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from K with the least significant bit from round_counter to the right. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/jl/5d/o1/jl5do1gwvqcgmezpu_id0cdsxhi.png"><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A key conversion for a 128-bit algorithm can be found in the appendix to the original article.</font></font></em><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Design features of PRESENT</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to security and efficient implementation, the main achievement of PRESENT is its simplicity. </font><font style="vertical-align: inherit;">therefore, it is not surprising that similar projects were adopted in other circumstances, and were even used as a textbook for students. </font><font style="vertical-align: inherit;">In this section, we will justify the decisions we made when designing PRESENT. </font><font style="vertical-align: inherit;">However, first of all, we describe the expected application requirements.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1. </font><font style="vertical-align: inherit;">Purpose and application environment</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When designing a block cipher that is applicable in tightly constrained environments, it is important to understand that we are not creating a block cipher that will certainly be applicable in many situations - there is AES for this. </font><font style="vertical-align: inherit;">On the contrary, we are aimed at a very specific application for which AES is not suitable. </font><font style="vertical-align: inherit;">The foregoing determines the following characteristics.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The cipher will be implemented "in hardware"</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Applications will only be required to adjust the security level. </font><font style="vertical-align: inherit;">Therefore, an 80-bit key would be a robust solution. </font><font style="vertical-align: inherit;">Note that the developers of stream ciphers of the eSTREAM project adhere to the same position.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Applications do not require encryption of large amounts of data. </font><font style="vertical-align: inherit;">Thus, an implementation can be optimized for performance or space without making too much change.</font></font></li>
<li>     ,      .   ,       (       ).</li>
<li>      ,  ,         , , ,      .</li>
<li>  ,      ,        (encryption-only mode).  ,      - (challenge-response)  , ,    ,          ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"> </a>.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Based on such considerations, we decided to create PRESENT as a 64-bit block cipher with an 80-bit key. Encryption and decryption, in this case, have approximately the same physical requirements. With the ability to support both encryption and decryption, PRESENT will be more compact than supporting only AES encryption. And in the case of encryption-only execution, our cipher will be completely super-easy. Encryption </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sub-keys</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will be computed on the go. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are many examples in the literature of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attacks of compromise between time, date and memory</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , or attacks using the </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">birthday</font></a><font style="vertical-align: inherit;"> paradox</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when encrypting large amounts of data. </font><font style="vertical-align: inherit;">However, these attacks depend only on the parameters of the cipher and do not use the internal structure. </font><font style="vertical-align: inherit;">Our goal is to make these attacks the best they can use against us. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Third-party channel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> attacks and direct chip-breaking attacks threaten PRESENT as much as other </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cryptographic primitives</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">However, for probable applications, moderate security requirements make the benefits to an attacker in practice very limited. </font><font style="vertical-align: inherit;">In risk assessment, such threats are not perceived as a significant factor.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2. </font><font style="vertical-align: inherit;">Permutation layer</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When choosing a key mixing layer, our attention to hardware efficiency requires a linear layer, which can be implemented with a minimum number of control elements (for example, transistors). </font><font style="vertical-align: inherit;">this leads to a bitwise permutation. </font><font style="vertical-align: inherit;">Paying attention to simplicity, we chose regular bitwise permutation, which helps to conduct a transparent security analysis (see section 5).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3. </font><font style="vertical-align: inherit;">S-blocks.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At PRESENT, we use separate S-blocks that translate 4 bits to 4 bits (F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Üí F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). This is a direct consequence of our desire for hardware efficiency, and the implementation of such an S-block is usually much more compact than that of an 8-bit S-block. Since we use bitmap permutation for a linear diffusion layer, AES-like diffusion technologies are not an option for our cipher. Therefore, we place some additional conditions on S-blocks in order to reduce the so-called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúavalanche effect‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . More precisely, the S-blocks for PRESENT satisfy the following conditions, where we denote the Fourier coefficient S by </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (a) = ‚àë (-1) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;b, S (x)&gt; + &lt;a, x&gt;</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , x‚ààF </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1. For any fixed nonzero input bias ‚àÜ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚àà F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and any fixed nonzero input bias ‚àÜ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚àà F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inside the S-block, we require </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
# {x ‚àà F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | S (x) + S (x + ‚àÜ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = ‚àÜ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> } ‚â§ 4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. For any fixed nonzero input difference ‚àÜ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚àà F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and any fixed nonzero output difference ‚àÜ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚àà F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> such that wt (‚àÜ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = wt (‚àÜ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = 1 , we have </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{x ‚àà F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">| S (x) + S (x + ‚àÜ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = ‚àÜ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> } = ‚àÖ </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. For all nonzero a ‚àà F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and all nonzero b ‚àà F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 it</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> holds that | S </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (a) | </font><font style="vertical-align: inherit;">‚â§ 8 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. For all nonzero a ‚àà F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and all nonzero b ‚àà F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> such that wt (a) = wt (b) = 1, S </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (a) = ¬± 4 </font><font style="vertical-align: inherit;">holds. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As will be clear from section 5, these conditions ensure that PRESENT is resistant to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">differential</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linear attacks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Using the classification of all 4-bit S-blocks satisfying the above conditions, we have chosen the S-block, which is especially suitable for efficient hardware implementation.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Security Analysis</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we will present the results of the PRESENT security analysis.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Differential and linear cryptanalysis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Differential and linear cryptanalysis are some of the most powerful methods available to cryptanalysts. </font><font style="vertical-align: inherit;">To measure the PRESENT resistance to differential and linear cryptanalysis, we set the lower bound on the number of so-called active S-blocks participating in the differential (or linear) characteristic.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Differential cryptanalysis</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The case of differential cryptanalysis is covered by the following theorem. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theorem 1. </font></font></b> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Any five-circuit differential characteristic of PRESENT has at least 10 active S-blocks. </font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Theorem 1 is proved in Appendix 3 of the original article, and we continue the observations. </font><font style="vertical-align: inherit;">We divide 16 S-blocks into 4 groups: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cu/vb/xb/cuvbxb5bl5psjid8dpwqxjwpkiq.png"><br>
<br>
<sub><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The numbers at the input (above) indicate the number of the S-block at the previous step, and at the output (at the bottom) - at the next</font></font></em></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Note that:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The input bits to the S-block come from 4 different S-blocks of the same group.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input bits for groups of four s-blocks come from 16 different s-blocks.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Four output bits from a particular S-block are included in four different S-blocks, each of which belongs to a separate group of S-blocks in the next round.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The output bits of s-blocks in different groups go to different s-blocks.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
According to Theorem 1, any differential characteristic for more than 25 rounds of PRESENT must have at least 5 √ó 10 = 50 active S-blocks. The maximum differential probability of the PRESENT S-block is 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and therefore the probability of a single 25-round differential characteristic is limited to 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-100</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Advanced methods allow the cryptanalyst to remove external rounds from the cipher in order to use a shorter characteristic; however, even if we allow an attacker to remove six rounds from the cipher, which is an unprecedented situation, the data required to use the remaining 25-round differential characteristic will exceed the available amount. </font><font style="vertical-align: inherit;">Thus, security boundaries are more than reliable. </font><font style="vertical-align: inherit;">However, we have practically confirmed that the boundary of the number of active S-blocks in Theorem 1 is tight.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Practical confirmation</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can define characteristics that include ten S-blocks over five rounds. The next two-round iterative characteristic includes two S-blocks per round and holds with a probability of </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2‚Äì25</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for five rounds. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
More complex characteristics are held with a probability of 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-21</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for 5 rounds. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although the probability of this second characteristic is very close to the boundary of 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-20</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is not iterative and has little practical value. </font><font style="vertical-align: inherit;">Instead, we experimentally confirmed the likelihood of a two-round iterative differential. </font><font style="vertical-align: inherit;">In experiments with more than 100 independent sub-keys using 223 selected plaintext pairs, the observed probability was predicted. </font><font style="vertical-align: inherit;">This seems to suggest that for this particular characteristic there is no concomitant significant differential. </font><font style="vertical-align: inherit;">However, determining the extent of any differential effect is a complex and time-consuming task, even though our preliminary analysis was encouraging.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linear cryptanalysis</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The case of linear PRESENT cryptanalysis is considered in the following theorem, in which we analyze the best linear approximation to the four rounds of PRESENT. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theorem 2.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let E </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4R</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> be the maximum linear displacement of the four-round approximation using PRESENT. Then E </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4R</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚â§ 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The proof of the theorem is contained in Appendix 4 of the original article.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then for 28 rounds the maximum displacement will be </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ó E </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4R </font></font></sub><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ó (2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-43</font></font></sup><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, assuming that a cryptanalyst only needs about 28 of the 31 rounds in PRESENT to initiate a key recovery attack, a linear cryptanalysis of a cipher will require about 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">84</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> known plaintexts / ciphertexts. </font><font style="vertical-align: inherit;">Such data requirements exceed the available text.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some advanced differential / linear attacks</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The PRESENT structure allows us to consider some of the distinguished forms of attacks. However, none of them led to an attack requiring less text than the lower bound of the text requirements for linear cryptanalysis. Among the distinguished attacks, we considered one that uses palindromic differences, since symmetric differences persist with a probability of one (i.e. always) over the diffusion layer, and some advanced versions of differential-linear attacks. Although the attacks seemed promising for several rounds, they quickly lost their practical value and are unlikely to be useful in PRESENT cryptanalysis. We also found that </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">truncated differential cryptanalysis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is likely to be of limited value, although the next two rounds.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Truncated expansion is performed with a probability of one. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Even when used to reduce the length of the already identified differential characteristics, the data requirements remain excessive. </font><font style="vertical-align: inherit;">Ranked expansion is performed with a probability of one.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2. </font><font style="vertical-align: inherit;">Structural attacks</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Structural attacks, such as </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">integrated cryptanalysis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and bottleneck analysis, are well suited for analyzing AES-like ciphers. </font><font style="vertical-align: inherit;">Such ciphers have strong word-like structures, where the words are usually bytes. However, the representation construction is almost exclusively bitwise, and although the permutation operation is somewhat regular, the development and distribution of word structures are disrupted by the bitwise operations used in the cipher.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3. </font><font style="vertical-align: inherit;">Algebraic attacks</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algebraic attacks were used </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lshy success when applied to stream ciphers, than to block. However, the simple structure of PRESENT means that they deserve serious study. The PRESENT S-block is described by 21 quadratic equations for eight input / output bit variables over field G (2). This is not surprising, since it is well known that any four-bit S-block can be described by at least 21 such equations. Then the entire cipher can be described by quadratic equations e = n √ó 21 in the variables v = n √ó 8, where n is the number of S-blocks in the encryption and key transformation algorithm.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For PRESENT, we have n = (31 √ó 16) + 31 so the whole system consists of 11,067 quadratic equations in 4,216 variables. The general problem of solving a system of multidimensional quadratic equations is NP-hard. However, the systems obtained for block ciphers are very rare, since they consist of n small systems connected by simple linear layers. However, it is not clear whether this fact can be used in the so-called algebraic attack. Some specialized methods have been proposed, such as XL and XSL, although shortcomings have been discovered in both methods. Instead, the only practical results on algebraic cryptanalysis of block ciphers were obtained by applying the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buchberger</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">F4</font></a><font style="vertical-align: inherit;"> algorithms.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as part of Magma. Modeling on small-scale versions of AES showed that for all but the smallest </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SP-networks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , difficulties quickly arise in both time and memory complexity. The same goes for PRESENT. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Practical confirmation.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We conducted simulations on small-scale versions using the F4 algorithm in Magma. </font><font style="vertical-align: inherit;">When there is one S-block, that is, a very small block with a size of four bits, Magma can solve the resulting system of equations in many rounds. </font><font style="vertical-align: inherit;">However, as the block size increases and S-blocks are added, along with the corresponding variant of the linear diffusion layer, the system of equations soon becomes too large. </font><font style="vertical-align: inherit;">Even when considering a system consisting of seven S-blocks, that is, having a block size of 28 bits, we were not able within a reasonable time to get a solution for the abbreviated cipher variant that passed two rounds. </font><font style="vertical-align: inherit;">Our analysis shows that algebraic attacks are unlikely to pose a threat to PRESENT.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.4. </font><font style="vertical-align: inherit;">Key conversion attacks</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since there are no established guidelines for the development of key transformations, there is both a wide variety of projects and a wide variety of attacks based on the characteristics of the project. </font><font style="vertical-align: inherit;">The most effective attacks fall under the general heading of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attack on related keys</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shear attack</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and both are based on the construction of identifiable relationships between different sets of sub-keys. </font><font style="vertical-align: inherit;">To counter this threat, we use a round-dependent counter, so that sub-key sets cannot be easily ‚Äúshifted‚Äù, and we use a non-linear operation to mix the contents of key register K. In particular:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all bits in the key register are a non-linear function of the 80-bit key supplied by the user to round 21,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that each bit in the key register after round 21 depends on at least four of the user-provided key bits, and</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by the time we get K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , six bits are expressions of degree two out of 80 user-provided key bits, 24 bits are degree three, while the remaining bits are a function of degree six or degree nine user-provided key bits.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We believe that these properties are enough to withstand key attacks based on key conversion.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Productivity of "iron"</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We implemented PRESENT-80 in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VHDL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and adapted it for the standard Virtual Silicon Cell Library (VST) based on the UMC L180 0.18 Œº 1P6M Logic. We used the Mentor Graphics Modelsim SE PLUS 5.8 c for simulation and Synopsys Design Compilerversion Y-2006.06 for the synthesis and modeling of power consumption. Typical values ‚Äã‚Äãfor foundry were used (1.8 Volts for core voltage and 25 ¬∞ C for temperature), and the proposed model of wire loading was used to model power. Please note that such a simulation is intended for structures around 10,000 GE, so power results will be pessimistic for much smaller structures. On the image</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tt/8i/bg/tt8ibga5aprmwzqrrckekekzv2a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The data path shown is space-optimized PRESENT-80 without the possibility of decryption (encryption-only), which performs one round per cycle, that is, a data path of 64-bit width. Please note that at the PRESENT design stage, we use the same S-block 16 times instead of having 16 different S-blocks, and this facilitates the further serialization of the project, i.e. with a 4-bit data channel. Our implementation requires 32 clock cycles for encrypting 64-bit plaintext with an 80-bit key, takes 1570 GE and has a 5 micW power consumption in modulation. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ek/7o/xq/ek7oxqtiawboi4wjqqrivgxvzmy.png"><br>
<br>
<em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spatial requirements PRESENT</font></font></sup></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most of the area is occupied by triggers for storing the key and data state, followed by the S-layer and the XOR keying department. </font><font style="vertical-align: inherit;">Simple permutation bit permutations will increase the area only when the implementation reaches the place &amp; route stage. </font><font style="vertical-align: inherit;">Note that the main goal of our implementation was a small amount of hardware, however, we also synthesized a process optimized for power. </font><font style="vertical-align: inherit;">For an additional 53 GE, we achieve energy consumption of only 3.3 ŒºW, and the current 128 will occupy an estimated area of ‚Äã‚Äã1886 GE. </font><font style="vertical-align: inherit;">In addition to its very small size, PRESENT has a fairly high throughput, giving good energy per bit. </font><font style="vertical-align: inherit;">Comparison with other ciphers is given in the table:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m9/yt/7j/m9yt7jonvvcpkjnluz273z1ksga.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Conclusion</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article, we described the new PRESENT block cipher. </font><font style="vertical-align: inherit;">Our goal was an ultralight cipher, which provides a level of security commensurate with the size of a 64-bit block and an 80-bit key. </font><font style="vertical-align: inherit;">As a result, PRESENT has implementation requirements similar to many compact stream ciphers. </font><font style="vertical-align: inherit;">Therefore, we believe that it is of both theoretical and practical interest. </font><font style="vertical-align: inherit;">Like all new proposals, we do not encourage the immediate deployment of PRESENT, but urge its analysis.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Confession</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The work presented in this document was partially supported by the European Commission as part of the STREP UbiSec &amp; Sens of the EU Framework Program 6for Research and Development (www.ist-ubisecsens.org). </font><font style="vertical-align: inherit;">The opinions and conclusions contained in this document are those of the authors and should not be interpreted as constituting an official policy or endorsement expressed or endorsed by the UbiSec &amp; Sens project or the European Commission.</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en487524/index.html">Why does a hardware startup hackathon need</a></li>
<li><a href="../en487528/index.html">–ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º —Å–æ–≥–ª–∞—à–µ–Ω–∏–∏ –∏ –ø–æ–ª–∏—Ç–∏–∫–µ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω–∞ —Å–µ—Ä–≤–∏—Å–∞—Ö –•–∞–±—Ä–∞</a></li>
<li><a href="../en487534/index.html">etcd 3.4.3: storage reliability and security research</a></li>
<li><a href="../en487538/index.html">.NET Interactive is here! | .NET Notebooks Preview 2</a></li>
<li><a href="../en487540/index.html">HighLoad ++, Anastasia Tsymbalyuk, Stanislav Tselovalnikov (Sberbank): how we became MDA</a></li>
<li><a href="../en487544/index.html">.NET Documentation: What's New for January</a></li>
<li><a href="../en487548/index.html">New Experiment: Calling .NET gRPC Services from a Browser with gRPC-Web</a></li>
<li><a href="../en487550/index.html">3D picture in python with (almost) normal performance</a></li>
<li><a href="../en487552/index.html">Swift 5.2 - what's new?</a></li>
<li><a href="../en487556/index.html">News from the world of OpenStreetMap No. 497 (01/21/2020-27.01.2020)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>