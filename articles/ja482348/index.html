<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉🏽 🚹 👩‍🚒 疑いを持たないゲーム開発者のためのトポロジーと包括的な分析：単一の3Dベクトルの圧縮 👨🏻‍💼 🛩️ 🤼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私の以前の記事からすでに理解できるように、ゲーム開発を言い訳として使用して、他の方法ではほとんどの人が役に立たない複雑な数学を説明したいと思います。そして、この記事も例外ではありません！私にとって興味深い点に対応する、非常にクールなテクニックを紹介したいと思います。
 
 

- プロセスは十分に明...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>疑いを持たないゲーム開発者のためのトポロジーと包括的な分析：単一の3Dベクトルの圧縮</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482348/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/910/fcb/d9f/910fcbd9f721b1ceea2de3b3a56bcb2c.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の以前の記事からすでに理解できるように、ゲーム開発を言い訳として使用して、他の方法ではほとんどの人が役に立たない複雑な数学を説明したいと思います。</font><font style="vertical-align: inherit;">そして、この記事も例外ではありません！</font><font style="vertical-align: inherit;">私にとって興味深い点に対応する、非常にクールなテクニックを紹介したいと思います。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスは十分に明確です</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じタスクを実行する通常の手法よりもはるかに高速です</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、浮動小数点形式で浮動小数点数を表すという非常に珍しいプロパティを使用します。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古典的な分析では機能しません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このアルゴリズムが理論上機能するためには、非古典的な数学の素晴らしい世界に入る必要があります！</font><font style="vertical-align: inherit;">そして、これがあなたの好奇心を呼び起こさなかったなら、私は他に何をすべきか分かりません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、説明を深く研究する必要があるため、かなり長く理論的です。時間をかけて、最初はそれほど明白ではなかったと思った部分をもう一度読んでください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキスト（GPU）について</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームの開発において、そしてより広い意味で-グラフィックスが積極的に使用されているあらゆる分野で注意すべき重要な側面の1つは、GPUの帯域幅です。中央プロセッサとGPUは別個の物理デバイスであり、データを交換するには同期が必要です。すでに並列処理に関与している場合、2つのデバイスを同期する必要がある場合、これはかなりの時間を失うことを意味します。この点でのCPU-GPUの相互作用に違いはないため、操作の数と転送されるデータの量の両方において、データ転送を最小限に抑えるよう努めています。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ転送操作の数の最小化は、通常、バッファリングを使用して実行されます。すべてのデータを可能な限り少ない数の配列に収め、すべてを一度に転送するため、それらを心配する必要がなくなります。転送操作でのデータ量の最小化は完全に異なるトピックであり、この問題の解決策はほとんど常に個別のものです。この極端な例として、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Destinyレンダリングエンジンが位置、サーフェス法線、マテリアルフラグ、96ビットの完全異方性BSDFパラメータにどのように適合するか</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を確認でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます。 3つの浮動小数点数</font></a><font style="vertical-align: inherit;">（62ページ以降）。ただし、一般的な方法で良好な結果を得ることができ、それに最適化のための個別のソリューションが追加されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日は議論します</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">個々の単一3Dベクトルの可逆圧縮</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この文にはいくつかのキーワードが含まれています：</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一の3Dベクトル</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：長さが1の3Dベクトル</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロスレス圧縮</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：精度を失うことなく、単一の3Dベクトルの記述のサイズを削減します。</font><font style="vertical-align: inherit;">これは</font><em><font style="vertical-align: inherit;">不可逆圧縮</font></em><font style="vertical-align: inherit;">の逆です</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></em></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separate</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ベクトルのエンコードとデコードは、その近傍に関する情報なしで実行されます。</font><font style="vertical-align: inherit;">状況が逆転した場合、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッチ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">圧縮の</font><font style="vertical-align: inherit;">ようになる可能性があります。</font><font style="vertical-align: inherit;">個々のベクトルは圧縮されませんが、その配列は</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先に進む前に、Cigolle、Donow、Evangelakos、Mara、McGuire、およびMeyerによる</font><font style="vertical-align: inherit;">
優れた記事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「独立した単位</font></font></em> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクトルの</font></font></em></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><em><font style="vertical-align: inherit;">効率的な表現の調査」</font></em></a><font style="vertical-align: inherit;">について言及する必要があり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">私</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が話すアルゴリズムは、記事で提示された</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oct</font></font></em></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">アルゴリズムよりも効率が悪い</font></strong><font style="vertical-align: inherit;">と</font><strong><em><font style="vertical-align: inherit;">すぐに</font></em></strong><font style="vertical-align: inherit;">言っておく必要があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最大の効率が必要な場合は、記事を読んで</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oct</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私の投稿の目的は、非常に珍しい数学を使用することの美しさを示すと同時に、後で説明するように、非常に便利なアルゴリズムを作成することです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオゲームのトポロジー</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/a95/4bc/41ca954bca54597431a9a0ebb7a9fe97.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単位球の場合、ρは常に1であり、したがって冗長であるため、θとφのみが重要です。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アルゴリズムの開始点は、単位3Dベクトルが球上の点に相当するという観察です。おそらくご存じのとおり、球は2次元の表面です。つまり、球上の点を一意に識別するために必要な座標は2つだけです。これの非常に一般的な例は、球上の座標が2つの角度θとφによって定義される球座標です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深いことに、かなり不快な特性は、球と塗りつぶされた正方形（2D座標の1つの可能なスペース）は2Dオブジェクトですが、実際にはそれらの間の対応はありません。これは、球の一意の点を正方形の一意の各点に（少なくとも連続的に）アタッチする方法がないことを意味します。彼らは</font><em><font style="vertical-align: inherit;">非同形である</font></em><font style="vertical-align: inherit;">と言われています</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（簡単に言うと、1つには境界線がありますが、もう1つにはありません）。これの不愉快な結果は、異なる座標が球上の同一の点に対応するという意味で一部の2D座標が失われることです（たとえば、球座標の場合、φが0の場合、対応する点は座標θに関係なく北極になります）。圧縮に関しては、球のポイントを表すことができる貴重なビットパターンが失われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より多くの数学が必要で、正方形と球が同形でないことを証明したい場合は、正方形とは対照的に、球は収縮可能ではなく、収縮性はトポロジープロパティであるという事実を使用できます。ボルスク・ウラムの定理は証明にも使用できます。彼らはまた、ホモトピーグループが証明に役立つことができると私に言いましたが、これはすでに私の専門分野の外です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、この問題は球面座標だけで発生するわけではありません。球体の点の連続的な2D表現は、その影響を受けます。ただし、これは将来のために覚えておいてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
球面座標には、他にも悪い特性があります。</font></font><br>
<br>
<ul>
<li>     .           3D-,           .    ,  3D-       .<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/e1d/15a/87ce1d15ad314b007f0093b83a738538.png"></div><br>
<i>   10 000    </i></li>
<li>    .   (3D → 2D)    <em>acos</em>   <em>atan2</em>,       ,    (2D → 3D)    <em>cos</em>    <em>sin</em>,     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
球面座標と他の圧縮方法の他の比較については、上記の記事をご覧ください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビットパターンを維持するタスク...と速度</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが検討する方法には大きな利点があります-その計算ははるかに速く、最適化されていない単純なベンチマークの2倍以上です（インテルCore i5第7世代のVisual Studio 19のC ++で1000万のランダムベクトルをパックおよびアンパックすることでテストされています）。さらに、この方法には特異点がありません。つまり、上記の球面座標とは対照的に、各パックされた点は単一のアンパックされた点に対応します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先に述べたように、単位球と単位正方形の間に同相関係はありません。つまり、正方形の各一意の点を球の別の一意の点に適切に関連付けることができません。ただし、次の構造を見てみましょう。これまでのところ、座標Zが正またはゼロの点がある北半球だけが関係します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/b7a/709/8a0b7a709482f110e7936fc71187e70d.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">北半球をディスクに「平坦化」し、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各点のZ座標を破棄しました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（または0に設定しました）。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
北半球の各点を1つのディスクの各点に接続する方法を見つけました。</font><font style="vertical-align: inherit;">いくつかの注目すべき点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">北極は（0、0）に分類されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">半球の境界上の各点は同じままです。</font><font style="vertical-align: inherit;">より具体的には、半球とディスクは同じ境界を持っています。</font><font style="vertical-align: inherit;">これは論理的です。半球の境界上の点はZ = 0、つまりZ座標を破棄するため、何も変更しません。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスク圧縮：単純で複雑なタスク</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の構造には、少し紹介が必要です。念のため、私はその複素数は実数の空間の延長使用し、特別な番号（0、1、129.43、パイ、117分の335、など平方根2のような普通の数字）であると言うでしょう</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれる</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">架空のユニット</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。複素数の形式有し</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+のIB</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">及び</font><em><font style="vertical-align: inherit;">bは</font></em><font style="vertical-align: inherit;">（それぞれ、実数部および虚数部）いくつかの実数であり、</font><em><font style="vertical-align: inherit;">iは</font></em><font style="vertical-align: inherit;">プロパティ有する</font><em><font style="vertical-align: inherit;">I</font></em><font style="vertical-align: inherit;"> ²= -1。これにより、2D平面上の点と複素数を一致させることができます。我々が取る場合は</font><em><font style="vertical-align: inherit;">、Z</font></em><font style="vertical-align: inherit;">形の複素数</font><em><font style="vertical-align: inherit;">Z = A + IBを</font></em><font style="vertical-align: inherit;">、我々は表すことができ、</font><em><font style="vertical-align: inherit;">Zは</font></em></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平面上の</font><font style="vertical-align: inherit;">座標（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">持つポイント</font><font style="vertical-align: inherit;">。複素数</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の「実数部」と「虚数部」の抽出関数は、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Re（z）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im（z）で</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c7/3d5/9b2/3c73d59b25bb8db10409e8c763b90154.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複素数</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とその値。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
複素数の実数部と虚数部に加えて、X軸とのそれによって形成される長さと角度も考慮することができ、これは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">極座標表現</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれます</font><font style="vertical-align: inherit;">。極長と極角は標準です</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">| z |</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arg（z）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。両方の表現の便利なプロパティがあることである</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複素数の添加は実部と虚部を追加することによって行われる</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複素数の乗算は、規範を掛けると引数を追加することによって行われます</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、2乗と複素数の平方根の2つの演算に関心があります。複素数を</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2乗する</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことは実数とまったく同じです。単純にそれを自分で乗算し、基本的</font><strong><font style="vertical-align: inherit;">にノルムを2乗して引数を2倍にします</font></strong><font style="vertical-align: inherit;">。複素数のノルムが1未満の場合、それを2乗すると、その長さは1未満のままになります。したがって、正の実数部を持つディスク上の各複素数を取り、それらすべてを正方形に配置すると、基本的にディスク全体が得られます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cf/7f3/af0/0cf7f3af09328146ee38a26f4e72eddb.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左側には、正の実数部（X座標）を持つディスクの半分のいくつかの複素数があります。右側は、これらすべてのポイントを二乗した結果です。ディスクの半分がディスク全体を満たします。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1つのトリックは、「引数を2倍にする」ことに関連しています。それは、ポイントが存在するX軸の側に依存します。ルールを以下に示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/ed7/ddd/8cced7ddd2e812dd5d4361131a500f95.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正の虚数部（Y座標）を持つ複素数は左に回転し、負の虚数部（Y座標）を持つ複素数は右に回転します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
実数の場合と同様に、平方根は2乗の逆数です。与えられた複素数</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、平方根（そのうちの2つ）は</font><em><font style="vertical-align: inherit;">c²= zの</font></em><font style="vertical-align: inherit;">ような</font><font style="vertical-align: inherit;">数値</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。実数の場合のように、</font><em><font style="vertical-align: inherit;">c</font></em><font style="vertical-align: inherit;">が</font><em><font style="vertical-align: inherit;">zの</font></em><font style="vertical-align: inherit;">平方根である</font><font style="vertical-align: inherit;">場合、</font><em><font style="vertical-align: inherit;">-c</font></em><font style="vertical-align: inherit;">もそれです。</font><font style="vertical-align: inherit;">引数が引数</font><em><font style="vertical-align: inherit;">zの</font></em><font style="vertical-align: inherit;">半分に等しい</font><em><font style="vertical-align: inherit;">c</font></em><font style="vertical-align: inherit;">と</font><em><font style="vertical-align: inherit;">-c</font></em><font style="vertical-align: inherit;">の数</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、平方根のメイン値と呼ばれます（これは、負の平方根の代わりに実数の正の平方根をとるのと同じです）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複素数が2乗されると、そのノルムが2乗され、引数が2倍になることを理解していれば、平方根の主な値はノルムから平方根を取り、引数を半分にすることが簡単に推測できます（上に示した規則に従いますが、矢印が逆になっています）。 。二乗の場合と同様に、ノルムが1未満の複素数の平方根をとると、ノルムは1未満のままです。したがって、ユニットディスクを正の実数の半分に「圧縮」します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51f/7cc/5f0/51f7cc5f0b9616d7f82f09a29e3c14c7.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左側には、1つのディスクにいくつかのドットがあります。</font><font style="vertical-align: inherit;">右側は、これらすべての点の平方根をとった結果です。</font><font style="vertical-align: inherit;">ディスク全体が半分に収まります。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがアルゴリズムの基礎です。実際、ユニットディスク全体を半分に圧縮します。半分は正の実数部です。</font><font style="vertical-align: inherit;">ご存じのように、最近、球の上半分を1つのディスクに平坦化しました。</font><font style="vertical-align: inherit;">さて、それで何をするか見てみる価値があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてを一緒に入れて</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先ほどのことを要約してみましょう。球の半分を1つの単位ディスクに平坦化し、そのすべての点のZ座標を破棄し、複素主要平方根値を使用して、正の実数部分で単位ディスクを半分にします。実際、球の半分をディスクの半分に平らにしました！さて、マイナーな変更により、同様に球の残りの半分をディスクの残りの半分に圧縮できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
球の下半分は、（負のZ球のすべての点座標）は、同様に繰り返しZ座標をドロップすることによって、単位ディスクに平坦化される。ただし、すべての複素数のための</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスクに、我々は、主平方根に値反対側を取る</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（即ち、我々が取る</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-C</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わり</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">平方根の主な値は常に正の実数部分を持つため、反対の値は常に負の実数部分になります。</font><font style="vertical-align: inherit;">実際、球の残りの半分をディスクの残りの半分に平らにし、圧縮段階が完了しました！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/910/fcb/d9f/910fcbd9f721b1ceea2de3b3a56bcb2c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全な圧縮ステップ。</font><font style="vertical-align: inherit;">北半球と南半球（青とオレンジ）は、単一のディスクの2つのコピーに平坦化され、1つの単一のディスクの2つの半分に圧縮されることに注意してください。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
圧縮アルゴリズムは次のとおりです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">function <span class="hljs-title">packUnitVector</span><span class="hljs-params">(unit)</span>
    disk </span>= <span class="hljs-keyword">new</span> Complex(unit.x, unit.y)<font></font>
    packed = principalSquareRoot(disk)<font></font>
    <span class="hljs-keyword">return</span> unit.z &lt; <span class="hljs-number">0</span> ? -packed : packed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、わずか3行の疑似コードで、検証した理論全体を適用して効果的なアルゴリズムを作成しました。</font><font style="vertical-align: inherit;">ご使用の環境に平方根の主な値の式がない場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィキペディア</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で見つけることができます</font><font style="vertical-align: inherit;">（虚数部の符号の選択には特に注意を払う必要があります）。</font><font style="vertical-align: inherit;">これが私のコードで使用するリファレンスC ++実装です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Principal complex square root of 'x + iy'</span>
<span class="hljs-function">float2 <span class="hljs-title">csqrt</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y)</span>
</span>{
    <span class="hljs-keyword">float</span> r = <span class="hljs-built_in">sqrt</span>(x * x + y * y);
    <span class="hljs-keyword">return</span> float2(<span class="hljs-built_in">sqrt</span>((r + x) / <span class="hljs-number">2</span>), (y &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>) * <span class="hljs-built_in">sqrt</span>((r - x) / <span class="hljs-number">2</span>));<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">戻って</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
圧縮に対処したので、展開を開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解凍は、すべての圧縮ステップと逆の順序で行われます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのディスクの材料部分の正と負の両方を2つの完全なディスクに拡張します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスク全体を対応する半球と一致させる</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のパックされた値から始め、</font><font style="vertical-align: inherit;">それを2乗して半球の1つから取得したディスク上の点に戻り、次に記号</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Re（p）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">して、ディスク内の点がどの半球</font><font style="vertical-align: inherit;">から取得されているか</font><font style="vertical-align: inherit;">を調べます。</font><font style="vertical-align: inherit;">単位球上の点を定義</font><font style="vertical-align: inherit;">する方程式</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x²+y²+z²= 1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して、パックされた点の欠落したZ座標を再作成できます。</font><em><font style="vertical-align: inherit;">z²= </font></em><em><font style="vertical-align: inherit;">（- </font></em><em><font style="vertical-align: inherit;">z </font></em><em><font style="vertical-align: inherit;">）²</font></em></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
であるため、パックされた値の二乗を計算すると、最初の半球（上または下）に関係なく、常にディスクの正しい点が得られることに注意してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
解凍アルゴリズムの形式は次のとおりです。</font></font><em><font style="vertical-align: inherit;"></font></em> <em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">function <span class="hljs-title">unpackUnitVector</span><span class="hljs-params">(packed)</span>:
    disk </span>= packed * packed<font></font>
    unit = <span class="hljs-keyword">new</span> Vec3()<font></font>
    unit.x = disk.real()<font></font>
    unit.y = disk.imag()<font></font>
    unit.z = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span> - unit.x * unit.x - unit.y * unit.y) * (packed.real() &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> unit</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、単一の3Dベクトルの2D表現を非常に効果的に作成するアルゴリズムを取得しました。これは、球面座標とは異なり、ビットパターンを失わず、特異点もありません。計算を高速化するためのいくつかの最適化トリックを考慮しない場合、これはアルゴリズムのほぼ既製のバージョンです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
… か否か？注意深くフォローすると、ここで何かがおかしいことに気づきました。球体と単位四角形は同形ではないと言いましたが、どういうわけか、ディスクの一意の点を球体の各一意の点にバインドできましたか？また、非古典的な数学については触れていません。何が起こっているのでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、このアルゴリズムには重大な欠点があります。Y= 0およびX &lt;= 0の北半球上のポイントを除いて、球全体のすべてのポイントで機能します。ただし、パックとアンパック時に、北半球の対応するポイントと誤って比較されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Z座標が破棄されると、対応する複素数が負の実数になり、虚数部がなくなるためです。負の実数の平方根の主値を取ると、実数部分を持たない完全に虚数の複素数になります（これは、-1の平方根の主値が</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iに</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等しいという事実に似ています</font><font style="vertical-align: inherit;">）。次に、Z座標の符号を本質的にゼロに保つようにします。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6bc/720/d08/6bc720d085469f478453dc4c961e2036.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題ストリップ。</font><font style="vertical-align: inherit;">Y = 0およびX &lt;= 0のポイントは、定義不可能な実数部を持つ純粋な虚数の行にパックされます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなポイントを2つパックするとどうなるか見てみましょう（x &lt;= 0であることを忘れないでください）。</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">       | </font><font style="vertical-align: inherit;">ノースポイント| </font><font style="vertical-align: inherit;">サウスポイント</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 ユニット| </font><font style="vertical-align: inherit;">（x、0、z）| </font><font style="vertical-align: inherit;">（x、0、-z）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 ディスク| </font><font style="vertical-align: inherit;">x + 0i | </font><font style="vertical-align: inherit;">x + 0i</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
満員| </font><font style="vertical-align: inherit;">0 +√（-x）i | </font><font style="vertical-align: inherit;">-0-√（-x）i</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
両方の点のディスクへの投影の虚数部はゼロに等しいので、Z座標の符号は、それ自体がゼロに等しいため、平方根の主値の実数部の符号に格納できません。</font><font style="vertical-align: inherit;">アルゴリズムがこれらのポイントに対して機能しないという事実を受け入れて、これについて詳しく考えることができます-または、次に進むことができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学んだことを忘れる</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が知っているすべての数学の分野と分野では、0 = -0と仮定されています。これ</font><font style="vertical-align: inherit;">は、</font><em><font style="vertical-align: inherit;">a</font></em><font style="vertical-align: inherit;">の反対で</font><em><font style="vertical-align: inherit;">ある</font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の定義に由来し、</font><em><font style="vertical-align: inherit;">「-aは、aと合計されたときに0を与える唯一の数で</font></em><font style="vertical-align: inherit;">ある</font><em><font style="vertical-align: inherit;">」</font></em><font style="vertical-align: inherit;">と述べてい</font><font style="vertical-align: inherit;">ます。 0は加算（</font><em><font style="vertical-align: inherit;">0 + a = a + 0 = a</font></em><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">に関してもゼロ要素であるため</font><font style="vertical-align: inherit;">、0を取得するために0に追加する必要があるのは0のみです。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ソフトウェア開発では、すべてが異なります。浮動小数点数のほとんどの表現では、指数と仮数とともに、文字を格納するために追加のビットが使用されます。つまり、指数と仮数が0の場合、符号ビットを使用して正のゼロと負のゼロを区別できます。ほとんどのプログラミング言語では（すべてではないにしても）、これらのゼロは両方とも1つの単一のゼロとして扱われます（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 == -0を</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">試してみてください</font><font style="vertical-align: inherit;">）。ただし、違いがあり、「-0」と「0」を端末に出力しようとすると確認できます」-それが彼らが推論される方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは私たちにとって非常に重要です。ゼロの値は、実際には標識に関する情報を格納するために使用できます。実際、とにかく正しく保存されます。私たちの場合、問題はそれが正しく読み取られないことです。解凍アルゴリズムの最後から2番目の行を見ると、次のことがわかります。</font></font><br>
<br>
<pre><code class="cpp hljs">packed.real() &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この操作は、パックされた値の実数部の符号を読み取って、ポイントが属する半球を決定します-北または南。ただし、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packed.real（）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が0または-0の場合、文字は比較演算子によって無視され、3項演算子は常に1を返します。文字を読み取る正しい方法は、</font><font style="vertical-align: inherit;">たとえば、</font><font style="vertical-align: inherit;">C ++または</font><em><font style="vertical-align: inherit;">np</font></em><font style="vertical-align: inherit;">から</font><em><font style="vertical-align: inherit;">std :: signbit</font></em><font style="vertical-align: inherit;">を使用して、符号ビットのステータスを</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際に</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求することです。</font><font style="vertical-align: inherit;">NumpyからPythonへの</font><em><font style="vertical-align: inherit;">.signbit-</font></em><font style="vertical-align: inherit;">関数は言語に依存します。符号ビットは、数値が負の場合は1、正の場合は0であることを覚えておいてください。</font><font style="vertical-align: inherit;">
したがって、修正された100％の作業関数が得られます。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">function <span class="hljs-title">unpackUnitVector</span><span class="hljs-params">(packed)</span>:
    disk </span>= packed * packed<font></font>
    unit = <span class="hljs-keyword">new</span> Vec3()<font></font>
    unit.x = disk.real()<font></font>
    unit.y = disk.imag()<font></font>
    unit.z = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span> - unit.x * unit.x - unit.y * unit.y) * (signbit(packed.real()) ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> unit</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで全部です！</font><font style="vertical-align: inherit;">これでアルゴリズムが完成しました。</font><font style="vertical-align: inherit;">非古典的な数学は、0が-0とは異なるという事実を使用しているという事実に表れています。これは、私の知っている数学のすべての領域では誤りです。</font><font style="vertical-align: inherit;">ただし、この奇妙さを理論的、数学的に厳密な意味で論理的にする方法があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルール通りに遊べないスペース：２つの原点を持つライン</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下をよりよく理解するには、等価クラスと近傍の概念を知っている必要があります。</font><font style="vertical-align: inherit;">これはオプションですが、より明確になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この奇妙さの一貫性を、「トポロジーゼロ」で確認できます。興味深いトポロジー空間、つまり2つの原点を持つ直線から始めます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7df/bdc/b66/7dfbdcb665e09552d349b0fb6d606f52.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つの原点を持つ直線は、通常の実数値軸であり、なんとかして0が増えました</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
。2つの原点を持つ直線は、2つの実数値軸を取り、各数値を反対側に接着すると得られます（0を除く）それらが等しい場合正式に、起源の二点と直線が2つの数値を識別する同値関係と商空間R²である</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しない0の結果は、2つの異なるゼロで実数の直線である任意の点から等距離に、しかし互いに異なる同時に。正式には、各ゼロの2つの近傍には常に空でない交差があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを拡張して、この記事で使用された「ディスクのような」オブジェクトを特定することができます。以前は、複素数ディスクへの投影のメイン平方根の実数部の点のZ座標の符号を強制的に保持していました。これは、この実数部が0の場合でも同様です。これは、複素数を使用しなかったが、それに類似した別の概念である複素数、虚数部は実数で、実数部は2つの原点を持つ線上の点なので、+ 0と-0に等しい実数部を区別できます。実際、</font><strong><font style="vertical-align: inherit;">2つの原点を持つ複素数</font></strong><font style="vertical-align: inherit;">を使用しています</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして実際には、球と単位円盤の間の全単射（1対1マッピング）は見つかりませんでしたが、球と2つの原点を持つ単位円盤の間の全単射が見つかりました。</font><font style="vertical-align: inherit;">この全単射が同型であるかどうかはテストしていませんが（同型は両方向に連続する全単射です）、いつか私はそれを行うでしょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後に少しのトポロジー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論として、2つの原点で使用した複雑な平面は、2つの座標を持つ直線と同じ構成ではありませんが、実際には、2つの座標原点を持つ別の複雑な平面と同等であり、二つの起源。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの原点をもつ直線の場合、0を除くすべての場所で実際の数値軸の2つのコピーを接着しました。複素数平面の2つのコピーを使用して同じことを行い、0ではない等しい複素数の各ペアを接着すると、同様に複雑になります。 2つの原点を持つ平面。この構成は、2つの原点と通常の実数値軸を持つ直線からの新しい複雑な平面の構成とは異なります。前者は因子空間であり、後者は空間の積です。ただし、結果の2つのスペースの唯一の違いは、</font><font style="vertical-align: inherit;">各スペースに異なるゼロ</font><font style="vertical-align: inherit;">を</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">書き込む</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法です。</font><font style="vertical-align: inherit;">最初のスペースでは、（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 + 0i）a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および（</font><em><font style="vertical-align: inherit;">0 + 0i）b</font></em><font style="vertical-align: inherit;">としてカウントされます</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（一緒に接着されていない2つの異なるスペースから取得された2つのゼロ）、および後者では</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（0a + 0i）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（0b + </font></font></em> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0i）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として読み取られ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">実際、どちらのスペースも同型なので、もう一方が必要な場所で安全に使用できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
奇妙で曖昧な数学の世界へのこの遠足を楽しんだことを望みます。</font><font style="vertical-align: inherit;">厳密に言えば、このアルゴリズムは</font><font style="vertical-align: inherit;">最初に述べた記事の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oct</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムよりも動作が悪いことを再度強調し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">実行時間は近いか、さらに高速ですが、球上のポイントの分布はそれほど良くありません。</font><font style="vertical-align: inherit;">次に、この記事を書いて、抽象的なナンセンスに似た一見エイリアンの数学が実際に現実の世界で非常に興味深いアプリケーションを持つことができることを示すために書きました。</font><font style="vertical-align: inherit;">さらに、私はこの抽象的なナンセンスを楽しいと思います。</font><font style="vertical-align: inherit;">記事を読んでくれてありがとうございます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja482336/index.html">トレーダーは、公開前にイングランド中央銀行の記者会見へのアクセスを得ました</a></li>
<li><a href="../ja482338/index.html">Visual Studio for Mac：IDEをキーで制御する</a></li>
<li><a href="../ja482340/index.html">ジュニアからミドル：パーサー</a></li>
<li><a href="../ja482344/index.html">ロシアでの社会的格付けの導入に備えましょう</a></li>
<li><a href="../ja482346/index.html">ASP.NET MVC-ADO.NETを介してMySQLを操作する</a></li>
<li><a href="../ja482352/index.html">私が風に150kをほとんど投げたとき、またはアパートに強制換気を設置した歴史</a></li>
<li><a href="../ja482354/index.html">ConfigureAwait：よくある質問</a></li>
<li><a href="../ja482356/index.html">通常のWindowsユーザーの観点から、エクスプローラーなしでWindows Serverを使用する</a></li>
<li><a href="../ja482358/index.html">Rustでのパニックの仕組み</a></li>
<li><a href="../ja482360/index.html">Habra探偵：彼らはUFOの友達です</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>