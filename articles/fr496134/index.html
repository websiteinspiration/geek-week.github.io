<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🌾 🍇 👨🏽‍🍳 Comment se débarrasser des photos floues en utilisant Python 🎛️ ✍🏽 🙅🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsque nous prenons une grande série de photos, certaines sont floues. Une grande entreprise automobile a été confrontée au même problème. Certaines ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Comment se débarrasser des photos floues en utilisant Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496134/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous prenons une grande série de photos, certaines sont floues. </font><font style="vertical-align: inherit;">Une grande entreprise automobile a été confrontée au même problème. </font><font style="vertical-align: inherit;">Certaines des photographies lors de l'inspection de la voiture se sont révélées floues, ce qui pourrait avoir un impact négatif sur les ventes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les images de faible qualité réduisent directement les bénéfices.</font></font></i><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment une application reconnaît-elle les photos floues au niveau de l'algorithme?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment mesurer la clarté d'une image RVB?</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/be/p7/1g/bep71gaawmaf4thhfl5j7ig-1ze.jpeg"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formulation du problème</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je travaille comme analyste dans une grande entreprise automobile. </font><font style="vertical-align: inherit;">Lors de l'inspection d'une voiture, lors de l'inspection d'une voiture, ils prennent beaucoup de photos via une application spéciale, qui sont immédiatement envoyées à la base de données. </font><font style="vertical-align: inherit;">Certaines images sont floues, ce qui est mauvais pour les ventes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De là, le problème se pose: "comment reconnaître les images floues au niveau de l'algorithme?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Développer un algorithme basé sur un échantillon de 1200 photos de différents éléments de voitures. </font><font style="vertical-align: inherit;">Une caractéristique de l'échantillon est qu'il n'est pas étiqueté, car </font><font style="vertical-align: inherit;">il est difficile de déterminer quelles images sont claires et lesquelles ne le sont pas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'avère que l'apprentissage du modèle ML «avec un enseignant» n'est pas applicable à la solution. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au cours du travail, j'ai utilisé des outils:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bibliothèques: numpy, matplotlib, cv2;</font></font></li>
<li><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cahier </font><b><font style="vertical-align: inherit;">Jupyter</font></b><font style="vertical-align: inherit;"> .</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'article, je décrirai la solution au problème auquel je suis arrivé.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Description de l'approche pour résoudre le problème</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 1. Définir les limites</font></font></h4><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle photo peut être qualifiée de claire? </font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Celui dans lequel les limites des objets sont prononcées. </font><font style="vertical-align: inherit;">Dans les photos floues, les bordures des objets sont floues. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment déterminer les limites des objets dans l'image? </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bordures où nous voyons la plus grande différence de couleur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'avère que pour déterminer la clarté de l'image, vous devez d'abord déterminer les limites des objets des photographies, puis évaluer leur taille, leur épaisseur, leur nombre, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La photo se compose d'un tableau tridimensionnel de nombres de 0 à 255: (largeur, hauteur, 3 couleurs). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai défini les limites en appliquant un filtre comme dans la création d'un réseau neuronal profond: en multipliant un tableau tridimensionnel par des matrices (pour chaque couleur):</font></font><br>
<br>
<pre><code class="plaintext hljs">    │ 1 -1 │<font></font>
    │ 1 -1 │<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec une différence de couleur, le réseau résultant produira un nombre de modules élevé. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous définissons donc les limites verticales et horizontales. </font><font style="vertical-align: inherit;">La moyenne arithmétique montre les bords communs de la photographie.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 2. Analyse des limites pour plus de clarté</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les limites sont définies. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment distinguer la bordure d'une image floue de la bordure d'un clair? </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En passant par différentes options, j'ai trouvé l'approche suivante:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définir les limites de la photo originale (décrite à l'étape 1);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flouter l'image originale;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définir les limites de l'image floue (décrite à l'étape 1);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous considérons le rapport de la moyenne arithmétique des paragraphes 1 et 2;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le coefficient résultant caractérise la clarté de l'image.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La logique est simple: dans les photographies claires, le changement de bordures se produira plus significativement que dans les photos floues, ce qui signifie que le coefficient sera plus élevé.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implémentation Python de l'algorithme</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour résoudre le problème directement, nous utilisons les bibliothèques suivantes:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> cv2
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour les paramètres de détermination des limites, nous définissons la fonction de définition de la matrice:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edges</span>(<span class="hljs-params">n, orient</span>):</span>
    edges = np.ones((<span class="hljs-number">2</span>*n, <span class="hljs-number">2</span>*n, <span class="hljs-number">3</span>))<font></font>
    <font></font>
    <span class="hljs-keyword">if</span> orient == <span class="hljs-string">'vert'</span>:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>*n):<font></font>
            edges[i][n: <span class="hljs-number">2</span>*n] *= <span class="hljs-number">-1</span>
    <span class="hljs-keyword">elif</span> orient == <span class="hljs-string">'horiz'</span>:<font></font>
        edges[n: <span class="hljs-number">2</span>*n] *= <span class="hljs-number">-1</span><font></font>
    <font></font>
    <span class="hljs-keyword">return</span> edges
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous le paramètre n, nous spécifions le nombre de pixels que nous incluons dans l'estimation des bornes. </font><font style="vertical-align: inherit;">L'orientation de la matrice peut être horizontale ou verticale. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'autres fonctions sont similaires à une couche de réseau neuronal profond:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Apply one filter defined by parameters W and single slice</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conv_single_step</span>(<span class="hljs-params">a_slice_prev, W</span>):</span><font></font>
    s = W * a_slice_prev<font></font>
    Z = np.sum(s)<font></font>
    Z = np.abs(Z)<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> Z<font></font>
   <font></font>
<span class="hljs-comment"># Full edge filter</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conv_forward</span>(<span class="hljs-params">A_prev, W, hparameters</span>):</span><font></font>
    m = len(A_prev)<font></font>
    (f, f, n_C) = W.shape<font></font>
    stride = hparameters[<span class="hljs-string">'stride'</span>]<font></font>
    pad = hparameters[<span class="hljs-string">'pad'</span>]<font></font>
    <font></font>
    Z = list()<font></font>
    flag = <span class="hljs-number">0</span>
    z_max = hparameters[<span class="hljs-string">'z_max'</span>]<font></font>
    <font></font>
    <span class="hljs-keyword">if</span> len(z_max) == <span class="hljs-number">0</span>:<font></font>
        z_max = list()<font></font>
        flag = <span class="hljs-number">1</span><font></font>
    <font></font>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):<font></font>
        <font></font>
        (x0, x1, x2) = A_prev[i].shape<font></font>
        A_prev_pad = A_prev[i][ <font></font>
                            int(x0 / <span class="hljs-number">4</span>) : int(x0 * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>), <font></font>
                            int(x1 / <span class="hljs-number">4</span>) : int(x1 * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>), <font></font>
                            :]<font></font>
        <font></font>
        (n_H_prev, n_W_prev, n_C_prev) = A_prev_pad.shape<font></font>
        n_H = int((n_H_prev - f + <span class="hljs-number">2</span>*pad) / stride) + <span class="hljs-number">1</span>
        n_W = int((n_W_prev - f + <span class="hljs-number">2</span>*pad) / stride) + <span class="hljs-number">1</span><font></font>
        z = np.zeros((n_H, n_W))<font></font>
        <font></font>
        a_prev_pad = A_prev_pad<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> range(n_H):<font></font>
            vert_start = h * stride<font></font>
            vert_end = h * stride + f<font></font>
            <font></font>
            <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> range(n_W):<font></font>
                horiz_start = w * stride<font></font>
                horiz_end = w * stride + f<font></font>
                <font></font>
               <font></font>
                a_slice_prev = a_prev_pad[vert_start: vert_end, horiz_start: horiz_end, :]<font></font>
<font></font>
                weights = W[:, :, :]<font></font>
                z[h, w] = conv_single_step(a_slice_prev, weights)<font></font>
        <font></font>
        <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span>:<font></font>
            z_max.append(np.max(z))<font></font>
        Z.append(z / z_max[i])<font></font>
        <font></font>
    cache = (A_prev, W, hparameters)<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> Z, z_max, cache<font></font>
<font></font>
<span class="hljs-comment"># pooling</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pool_forward</span>(<span class="hljs-params">A_prev, hparameters, mode = <span class="hljs-string">'max'</span></span>):</span><font></font>
    m = len(A_prev)<font></font>
    f = hparameters[<span class="hljs-string">'f'</span>]<font></font>
    stride = hparameters[<span class="hljs-string">'stride'</span>]<font></font>
    <font></font>
    A = list()<font></font>
    <font></font>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):<font></font>
        (n_H_prev, n_W_prev) = A_prev[i].shape<font></font>
        <font></font>
        n_H = int(<span class="hljs-number">1</span> + (n_H_prev - f) / stride)<font></font>
        n_W = int(<span class="hljs-number">1</span> + (n_W_prev - f) / stride)<font></font>
        <font></font>
        a = np.zeros((n_H, n_W))<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> range(n_H):<font></font>
            vert_start = h * stride<font></font>
            vert_end = h * stride + f<font></font>
            <font></font>
            <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> range(n_W):<font></font>
                horiz_start = w * stride<font></font>
                horiz_end = w * stride + f<font></font>
                <font></font>
                a_prev_slice = A_prev[i][vert_start: vert_end, horiz_start: horiz_end]<font></font>
<font></font>
                <span class="hljs-keyword">if</span> mode == <span class="hljs-string">'max'</span>:<font></font>
                    a[h, w] = np.max(a_prev_slice)<font></font>
                <span class="hljs-keyword">elif</span> mode == <span class="hljs-string">'avg'</span>:<font></font>
                    a[h, w] = np.mean(a_prev_slice)<font></font>
                        <font></font>
        A.append(a)<font></font>
<font></font>
    cache = (A_prev, hparameters)<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> A, cache
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
conv_single_step - une multiplication des couleurs de l'image par des matrices révélant la bordure. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
conv_forward - Une définition complète des bordures sur la photo entière. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pool_forward - réduit la taille du tableau résultant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Séparément, je note la valeur des lignes dans la fonction conv_forward:</font></font><br>
<br>
<pre><code class="python hljs">(x0, x1, x2) = A_prev[i].shape<font></font>
A_prev_pad = A_prev[i][ <font></font>
    int(x0 / <span class="hljs-number">4</span>) : int(x0 * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>), <font></font>
    int(x1 / <span class="hljs-number">4</span>) : int(x1 * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>), <font></font>
    :]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour l'analyse, nous utilisons non pas l'image entière, mais seulement sa partie centrale, car </font><font style="vertical-align: inherit;">la caméra se concentre plus souvent sur le centre. </font><font style="vertical-align: inherit;">Si l'image est claire, le centre sera clair. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction suivante détermine les limites des objets dans l'image à l'aide des fonctions précédentes:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># main layer</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">borders</span>(<span class="hljs-params">images, filter_size = <span class="hljs-number">1</span>, stride = <span class="hljs-number">1</span>, pool_stride = <span class="hljs-number">2</span>, pool_size = <span class="hljs-number">2</span>, z_max = []</span>):</span>
    Wv = edges(filter_size, <span class="hljs-string">'vert'</span>)<font></font>
    hparameters = {<span class="hljs-string">'pad'</span>: pad, <span class="hljs-string">'stride'</span>: stride, <span class="hljs-string">'pool_stride'</span>: pool_stride, <span class="hljs-string">'f'</span>: pool_size, <span class="hljs-string">'z_max'</span>: z_max}<font></font>
    Z, z_max_v, _ = conv_forward(images, Wv, hparameters)<font></font>
    <font></font>
    print(<span class="hljs-string">'edge filter applied'</span>)<font></font>
    <font></font>
    hparameters_pool = {<span class="hljs-string">'stride'</span>: pool_stride, <span class="hljs-string">'f'</span>: pool_size}<font></font>
    Av, _ = pool_forward(Z, hparameters_pool, mode = <span class="hljs-string">'max'</span>)<font></font>
    <font></font>
    print(<span class="hljs-string">'vertical filter applied'</span>)<font></font>
    <font></font>
    Wh = edges(filter_size, <span class="hljs-string">'horiz'</span>)<font></font>
    hparameters = {<span class="hljs-string">'pad'</span>: pad, <span class="hljs-string">'stride'</span>: stride, <span class="hljs-string">'pool_stride'</span>: pool_stride, <span class="hljs-string">'f'</span>: pool_size, <span class="hljs-string">'z_max'</span>: z_max}<font></font>
    Z, z_max_h, _ = conv_forward(images, Wh, hparameters)<font></font>
    <font></font>
    print(<span class="hljs-string">'edge filter applied'</span>)<font></font>
    <font></font>
    hparameters_pool = {<span class="hljs-string">'stride'</span>: pool_stride, <span class="hljs-string">'f'</span>: pool_size}<font></font>
    Ah, _ = pool_forward(Z, hparameters_pool, mode = <span class="hljs-string">'max'</span>)<font></font>
    <font></font>
    print(<span class="hljs-string">'horizontal filter applied'</span>)   <font></font>
    <font></font>
    <span class="hljs-keyword">return</span> [(Av[i] + Ah[i]) / <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(Av))], list(map(np.max, zip(z_max_v, z_max_h)))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction détermine les limites verticales, puis horizontales, et renvoie la moyenne arithmétique des deux tableaux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et la fonction principale pour l'émission du paramètre de définition:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># calculate borders of original and blurred images</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orig_blur</span>(<span class="hljs-params">images, filter_size = <span class="hljs-number">1</span>, stride = <span class="hljs-number">3</span>, pool_stride = <span class="hljs-number">2</span>, pool_size = <span class="hljs-number">2</span>, blur = <span class="hljs-number">57</span></span>):</span><font></font>
    z_max = []<font></font>
<font></font>
    img, z_max = borders(images, <font></font>
                         filter_size = filter_size, <font></font>
                         stride = stride, <font></font>
                         pool_stride = pool_stride, <font></font>
                         pool_size = pool_size<font></font>
                        )<font></font>
    print(<span class="hljs-string">'original image borders is calculated'</span>)<font></font>
    <font></font>
    blurred_img = [cv2.GaussianBlur(x, (blur, blur), <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> images]<font></font>
    print(<span class="hljs-string">'images blurred'</span>)<font></font>
    <font></font>
    blurred, z_max = borders(blurred_img, <font></font>
                             filter_size = filter_size, <font></font>
                             stride = stride, <font></font>
                             pool_stride = pool_stride, <font></font>
                             pool_size = pool_size, <font></font>
                             z_max = z_max<font></font>
                            )<font></font>
    print(<span class="hljs-string">'blurred image borders is calculated'</span>)<font></font>
<font></font>
    <span class="hljs-keyword">return</span> [np.mean(orig) / np.mean(blurred) <span class="hljs-keyword">for</span> (orig, blurred) <span class="hljs-keyword">in</span> zip(img, blurred)], img, blurred</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, nous déterminons les limites de l'image d'origine, puis nous rendons l'image floue, puis nous déterminons les limites de la photo floue, et, enfin, nous considérons le rapport des limites moyennes arithmétiques de l'image originale et du flou. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction renvoie une liste de facteurs de définition, un tableau de bordures de l'image d'origine et un tableau de bordures floues.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de fonctionnement d'algorithme</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour l'analyse, j'ai pris des photos du stock de photos freepik.com. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/be/p7/1g/bep71gaawmaf4thhfl5j7ig-1ze.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/bx/q_/zt/bxq_ztaqhom_1utv10_fiik2qbw.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/k_/fa/x4/k_fax4jhbwyxzqhth0a7gdquwuk.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/zw/hc/fo/zwhcfoypmkq78gcvae5nxejwhkc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous déterminons les limites de la première image avant et après le flou: </font></font><br>
<br>
<img align="left" src="https://habrastorage.org/webt/mu/tz/fw/mutzfwpy7abfonej9aowhiffg1s.jpeg"><img src="https://habrastorage.org/webt/z2/3u/xi/z23uxi_ei9xh9ql1qnhf9zaoz4i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deuxième: </font></font><br>
<br>
<img align="left" src="https://habrastorage.org/webt/xi/fj/5c/xifj5chec5sccukkrgg2rhjj73e.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/ye/8n/ei/ye8neincmrszl7nf6cexjzmy6aa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Troisième: </font></font><br>
<br>
<img align="left" src="https://habrastorage.org/webt/x5/1z/js/x51zjshztdvw40frgdzknx09tic.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/r6/l6/uu/r6l6uum_2u9oee8vqacw0s5fvgo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quatrième: </font></font><br>
<br>
<img align="left" src="https://habrastorage.org/webt/yp/4n/jy/yp4njywmsdj9p-wi7syid1srtgq.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/jc/dn/mv/jcdnmv7t8nontgodlfjd4robqaw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les images, on voit que les changements de bordure pour les images claires (3e et 4e) sont plus forts que pour les images floues (1re et 2e). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après les calculs, nous obtenons les coefficients: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[5.92918651681958, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.672756123184502, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10.695051017699232, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
11.901115749698139] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les coefficients confirment les conclusions: plus le coefficient est grand, plus la photo est nette. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, la deuxième image est moins claire que la première, ce qui se reflète dans les coefficients.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caractéristiques d'approche</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus l'image est nette, plus la bordure change fort, ce qui signifie que plus le paramètre est élevé;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour différents besoins, une clarté différente est nécessaire. </font><font style="vertical-align: inherit;">Par conséquent, il est nécessaire de déterminer vous-même les limites de la clarté: quelque part, le coefficient de suffisamment de photos claires sera supérieur à 7, quelque part au-dessus de 10;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le coefficient dépend de la luminosité de la photo. </font><font style="vertical-align: inherit;">Les bordures des photos sombres seront plus faibles, ce qui signifie que le coefficient sera inférieur. </font><font style="vertical-align: inherit;">Il s'avère que les limites de clarté doivent être déterminées en tenant compte de l'éclairage, c'est-à-dire pour les photographies standard;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un algorithme de travail peut être trouvé sur mon compte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr496118/index.html">Pourquoi y a-t-il tant de centres de données à Amsterdam</a></li>
<li><a href="../fr496122/index.html">Prendre soin de vos devoirs: sauvegardez votre ordinateur portable ou de bureau à l'aide des agents Veeam gratuits</a></li>
<li><a href="../fr496126/index.html">Crazy Logs</a></li>
<li><a href="../fr496128/index.html">Comment l'optimisation du référencement et les algorithmes de Google ont détruit le vrai Internet</a></li>
<li><a href="../fr496130/index.html">Miroir de l'âme: l'histoire de la télévision de la «box» à l'intelligence</a></li>
<li><a href="../fr496136/index.html">Utilisation de la bibliothèque ColorPicker dans Android pour implémenter une sélection de couleurs flexible</a></li>
<li><a href="../fr496138/index.html">Participez à la programmation musicale - des langages qui vous aideront à le faire</a></li>
<li><a href="../fr496144/index.html">Les fruits de l'isolement: carte interactive COVID-19 avec graphiques historiques et restrictions de migration</a></li>
<li><a href="../fr496146/index.html">Lua sur STM32</a></li>
<li><a href="../fr496148/index.html">Modèles de conception structurelle dans ES6 + sur l'exemple de Game of Thrones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>