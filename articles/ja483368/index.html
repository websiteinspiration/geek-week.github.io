<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏼 ✊🏻 🏽 Linux用のx86_64 ELFファイルパッカーの作成 🔺 💈 👲🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前書き
 この投稿では、Linux x86_64用の単純な実行可能ファイルパッカーの作成について説明します。読者は、Cプログラミング言語、x86_64アーキテクチャのアセンブリ言語、およびデバイスのELFファイルに精通していることを前提としています。明確にするために、記事のコードからエラー処理が削除...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Linux用のx86_64 ELFファイルパッカーの作成</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483368/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この投稿では、Linux x86_64用の単純な実行可能ファイルパッカーの作成について説明します。</font><font style="vertical-align: inherit;">読者は、Cプログラミング言語、x86_64アーキテクチャのアセンブリ言語、およびデバイスのELFファイルに精通していることを前提としています。</font><font style="vertical-align: inherit;">明確にするために、記事のコードからエラー処理が削除され、一部の関数の実装は表示されませんでした。github（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローダー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッカー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">へのリンクをクリックすると、完全なコードを見つけることができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアは次のとおりです。ELFファイルをパッカーに転送し、出力に次の構造を持つ新しいファイルを取得します。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td colspan="2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ELFヘッダー</font></font></td>
</tr>
<tr>
<td colspan="2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムのタイトル</font></font></td>
</tr>
<tr>
<td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードセグメント</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージ化されたELFファイルダウンローダー</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パックされたELFファイル</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">256バイトのランダムデータ</font></font></td>
</tr>
</tbody></table></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
圧縮については、暗号化のためにハフマンアルゴリズムを使用することが決定されました-256ビットキーのAES-CTR、つまりkokke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiny-AES-c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からの実装</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以下に示すように、256バイトのランダムデータは、疑似乱数ジェネレータを使用してAESキーと初期化ベクトルを初期化するために使用されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) {<font></font>
    seed = (<span class="hljs-number">1103515245</span>*seed + <span class="hljs-number">12345</span>) % <span class="hljs-number">256</span>;<font></font>
    key[i] = buf[seed];<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この決定は、リバースエンジニアリングを複雑にしたいという願望によって引き起こされました。</font><font style="vertical-align: inherit;">今日まで、合併症はささいなことであることに気づきましたが、時間とエネルギーを費やしたくなかったので、それを取り除くことを始めませんでした。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローダ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、ブートローダーの動作を検討します。</font><font style="vertical-align: inherit;">ローダーには依存関係があってはならないため、標準Cライブラリから必要なすべての関数を個別に作成する必要があります（これらの関数の実装は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">により利用可能です</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">また、位置的に独立している必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Start関数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブートローダーは_start関数から始まります。これは単にargcとargvをmainに渡します。</font></font><br>
<br>
<pre><code class="plaintext hljs">.extern main<font></font>
.globl _start<font></font>
.text<font></font>
_start:<font></font>
    movq (%rsp), %rdi<font></font>
    movq %rsp, %rsi<font></font>
    addq $8, %rsi<font></font>
    call main<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主な機能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
main.cファイルは、いくつかのextern変数を定義することから始まります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span>* loader_end;    <span class="hljs-comment">//    , .  </span>
                            <span class="hljs-comment">//  ELF .</span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">size_t</span> payload_size; <span class="hljs-comment">//   ELF </span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">size_t</span> key_seed;     <span class="hljs-comment">//    </span>
                            <span class="hljs-comment">// -   .</span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">size_t</span> iv_seed;      <span class="hljs-comment">//    </span>
                            <span class="hljs-comment">// -    </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パッカー内の変数（Elf64_Sym）に対応する文字の位置を見つけ、その値を変更するために、それらはすべてexternとして宣言されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メイン関数自体は非常に単純です。</font><font style="vertical-align: inherit;">最初のステップは、パックされたELFファイル、256バイトのバッファー、およびスタックの最上位へのポインターを初期化することです。</font><font style="vertical-align: inherit;">次に、ELFファイルが復号化されて展開され、load_elf関数を使用してメモリの適切な場所に配置されます。最後に、rspレジスタの値が元の状態に戻り、プログラムのエントリポイントにジャンプします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SET_STACK(sp) __asm__ __volatile__ (<span class="hljs-meta-string">"movq %0, %%rsp"</span>::<span class="hljs-meta-string">"r"</span>(sp))</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> JMP(addr) __asm__ __volatile__ (<span class="hljs-meta-string">"jmp *%0"</span>::<span class="hljs-meta-string">"r"</span>(addr))</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
    <span class="hljs-keyword">uint8_t</span> *payload = (<span class="hljs-keyword">uint8_t</span>*)&amp;loader_end; <span class="hljs-comment">//   </span>
                                              <span class="hljs-comment">// ELF </span>
    <span class="hljs-keyword">uint8_t</span> *entropy_buf = payload + payload_size; <span class="hljs-comment">//   256-</span>
                                                   <span class="hljs-comment">// </span>
    <span class="hljs-keyword">void</span> *rsp = argv<span class="hljs-number">-1</span>; <span class="hljs-comment">//    </span><font></font>
<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AES_ctx</span> <span class="hljs-title">ctx</span>;</span>
    AES_init_ctx_iv(&amp;ctx, entropy_buf, key_seed, iv_seed); <span class="hljs-comment">//  AES</span>
    AES_CTR_xcrypt_buffer(&amp;ctx, payload, payload_size);    <span class="hljs-comment">//  ELF</span>
    <span class="hljs-built_in">memset</span>(&amp;ctx, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ctx)); <span class="hljs-comment">//   AES</span><font></font>
<font></font>
    <span class="hljs-keyword">size_t</span> decoded_payload_size;
    <span class="hljs-comment">//  ELF</span>
    <span class="hljs-keyword">char</span> *decoded_payload = <font></font>
    huffman_decode((<span class="hljs-keyword">char</span>*)payload, payload_size, &amp;decoded_payload_size);<font></font>
<font></font>
    <span class="hljs-comment">//     ELF  ,</span>
    <span class="hljs-comment">//   ET_EXEC  NULL.</span>
    <span class="hljs-keyword">void</span> *load_addr = elf_load_addr(rsp, decoded_payload, decoded_payload_size);<font></font>
    load_addr = load_elf(load_addr, decoded_payload); <span class="hljs-comment">//  ELF  ,</span>
                                                      <span class="hljs-comment">//   </span>
                                                     <span class="hljs-comment">//  .</span>
    <span class="hljs-built_in">memset</span>(decoded_payload, <span class="hljs-number">0</span>, decoded_payload_size); <span class="hljs-comment">//   ELF</span>
    munmap(decoded_payload, decoded_payload_size); <span class="hljs-comment">//  </span>
                                                   <span class="hljs-comment">//   </span><font></font>
	<font></font>
    <span class="hljs-comment">//  ELF     AES</span><font></font>
    AES_init_ctx_iv(&amp;ctx, entropy_buf, key_seed, iv_seed);<font></font>
    AES_CTR_xcrypt_buffer(&amp;ctx, payload, payload_size);<font></font>
    <span class="hljs-built_in">memset</span>(&amp;ctx, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ctx));<font></font>
<font></font>
    SET_STACK(rsp); <span class="hljs-comment">//   </span>
    JMP(load_addr); <span class="hljs-comment">//      </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AESおよび圧縮解除されたELFファイルの状態のリセットは、セキュリティ上の目的で行われます。これにより、キーと復号化されたデータは、使用中のみメモリに保存されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、いくつかの関数の実装について検討します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">load_elf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は彼からのニックネームbedigerとgithubのユーザーからこの関数を取った</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">userlandexec</font></a><font style="vertical-align: inherit;">リポジトリ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元の関数がタイプET_DYNのファイルでクラッシュしたため、それを確定しました。</font><font style="vertical-align: inherit;">このエラーは、mmapシステムコールの最初の引数の値がNULLに設定されており、アドレスがメインプログラムの非常に近くに返されたため、その後のmmapの呼び出しと、セグメントによって返されたアドレスへのセグメントのコピー中にメインプログラムのコードが上書きされ、segfaultが発生したために失敗しました。</font><font style="vertical-align: inherit;">そのため、開始アドレスをパラメーターとしてload_elf関数に追加することにしました。</font><font style="vertical-align: inherit;">関数自体はすべてのプログラムヘッダーを通過し、ELFファイルのPT_LOADセグメントにメモリを割り当て（その数はページサイズの倍数でなければなりません）、その内容を割り当てられたメモリ領域にコピーし、対応する読み取り、書き込み、実行権限をこれらの領域に設定します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//     </span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAGEUP(x) (((unsigned long)x + 4095)&amp;(~4095))</span>
<span class="hljs-comment">//     </span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAGEDOWN(x) ((unsigned long)x&amp;(~4095))</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">load_elf</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *load_addr, <span class="hljs-keyword">void</span> *mapped)</span> </span>{<font></font>
    Elf64_Ehdr *ehdr = mapped;<font></font>
    Elf64_Phdr *phdr = mapped + ehdr-&gt;e_phoff;<font></font>
    <span class="hljs-keyword">void</span> *text_segment = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> initial_vaddr = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> brk_addr = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; ehdr-&gt;e_phnum; i++, phdr++) {
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> rounded_len, k;
        <span class="hljs-keyword">void</span> *segment;<font></font>
<font></font>
        <span class="hljs-comment">//   PT_LOAD,   </span>
        <span class="hljs-keyword">if</span>(phdr-&gt;p_type != PT_LOAD)
            <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(text_segment != <span class="hljs-number">0</span> &amp;&amp; ehdr-&gt;e_type == ET_DYN) {
            <span class="hljs-comment">//  ET_DYN phdr-&gt;p_vaddr    ,</span>
            <span class="hljs-comment">//       </span>
            <span class="hljs-comment">//    ,     </span>
            <span class="hljs-comment">//    </span><font></font>
            load_addr = text_segment + phdr-&gt;p_vaddr - initial_vaddr;<font></font>
            load_addr = (<span class="hljs-keyword">void</span>*)PAGEDOWN(load_addr);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ehdr-&gt;e_type == ET_EXEC) {
            <span class="hljs-comment">//  ET_EXEC phdr-&gt;p_vaddr    </span>
            load_addr = (<span class="hljs-keyword">void</span>*)PAGEDOWN(phdr-&gt;p_vaddr);<font></font>
        } <font></font>
<font></font>
        <span class="hljs-comment">//       </span>
        rounded_len = phdr-&gt;p_memsz + (phdr-&gt;p_vaddr % <span class="hljs-number">4096</span>);<font></font>
        rounded_len = PAGEUP(rounded_len);<font></font>
<font></font>
        <span class="hljs-comment">//       </span><font></font>
        segment = mmap(load_addr,<font></font>
                       rounded_len,<font></font>
                       PROT_WRITE,<font></font>
                       MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,<font></font>
                       <span class="hljs-number">-1</span>,
                        <span class="hljs-number">0</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(ehdr-&gt;e_type == ET_EXEC)<font></font>
            load_addr = (<span class="hljs-keyword">void</span>*)phdr-&gt;p_vaddr;
        <span class="hljs-keyword">else</span>
            load_addr = segment + (phdr-&gt;p_vaddr % <span class="hljs-number">4096</span>);
        <span class="hljs-comment">//        </span>
        <span class="hljs-built_in">memcpy</span>(load_addr, mapped + phdr-&gt;p_offset, phdr-&gt;p_filesz);<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(!text_segment) {<font></font>
            text_segment = segment;<font></font>
            initial_vaddr = phdr-&gt;p_vaddr;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> protflags = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(phdr-&gt;p_flags &amp; PF_R)<font></font>
            protflags |= PROT_READ;<font></font>
        <span class="hljs-keyword">if</span>(phdr-&gt;p_flags &amp; PF_W)<font></font>
            protflags |= PROT_WRITE;<font></font>
        <span class="hljs-keyword">if</span>(phdr-&gt;p_flags &amp; PF_X)<font></font>
            protflags |= PROT_EXEC;<font></font>
<font></font>
        mprotect(segment, rounded_len, protflags); <span class="hljs-comment">//   </span>
                                                   <span class="hljs-comment">// , , </span><font></font>
<font></font>
        k = phdr-&gt;p_vaddr + phdr-&gt;p_memsz;<font></font>
        <span class="hljs-keyword">if</span>(k &gt; brk_addr) brk_addr = k;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (ehdr-&gt;e_type == ET_EXEC) {<font></font>
        brk(PAGEUP(brk_addr));<font></font>
        <span class="hljs-comment">//  ET_EXEC ehdr-&gt;e_entry    </span>
        load_addr = (<span class="hljs-keyword">void</span>*)ehdr-&gt;e_entry;<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//  ET_DYN ehdr-&gt;e_entry    ,</span>
        <span class="hljs-comment">//          </span>
        load_addr = (<span class="hljs-keyword">void</span>*)ehdr + ehdr-&gt;e_entry;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> load_addr; <span class="hljs-comment">//      </span><font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elf_load_addr</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ET_EXEC ELFファイル用のこの関数は、このタイプのファイルはそれらで指定されたアドレスに配置する必要があるため、NULLを返します。 ET_DYNファイルの場合、アドレスは、メインプログラム（つまり、ブートローダー）のベースアドレス、ELFをメモリに配置するために必要なメモリの量、および4096、4096-ELFファイルをメインプログラムのすぐ隣に配置しないために必要なギャップの差と等しいです。このアドレスを計算した後、メモリ領域が、指定されたアドレスからメインプログラムのベースアドレスまで、アンパックされたELFファイルの先頭から最後までの領域と交差するかどうかがチェックされます。交差する場合、アドレスはアンパックされたELFの開始アドレスとそれを配置するために必要なメモリ量の差に等しく返されます。それ以外の場合は、以前に計算されたアドレスが返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムのベースアドレスは、スタック内の環境変数へのポインターの後にある補助ベクトル（ELF補助ベクトル）からプログラムヘッダーのアドレスを抽出し、そこからELFヘッダーのサイズを引くことでわかります。</font></font><br>
<br>
<pre><code class="plaintext hljs">                                          <font></font>
  ---------------------------------------------------------------------------<font></font>
     -&gt;  [ argc        ]                8<font></font>
                        [ argv[0]     ]                8<font></font>
                        [ argv[1]     ]                8<font></font>
                        [ argv[..]    ]                8 * x<font></font>
                        [ argv[n – 1] ]                8<font></font>
                        [ argv[n]     ]                8   (= NULL)<font></font>
<font></font>
                        [ envp[0]    ]                 8<font></font>
                        [ envp[1]    ]                 8<font></font>
                        [ envp[..]   ]                 8<font></font>
                        [ envp[term] ]                 8   (= NULL)<font></font>
<font></font>
                        [ auxv[0] (Elf64_auxv_t)    ]  16<font></font>
                        [ auxv[1] (Elf64_auxv_t)    ]  16<font></font>
                        [ auxv[..] (Elf64_auxv_t)   ]  16<font></font>
                        [ auxv[term] (Elf64_auxv_t) ]  16  (= AT_NULL)<font></font>
<font></font>
                        [  ]               0 - 16<font></font>
<font></font>
                        [    ] &gt;= 0<font></font>
                        [   ]           &gt;= 0<font></font>
<font></font>
                        [   ]          8   (= NULL)<font></font>
<font></font>
                        &lt;    &gt;         0<font></font>
  ---------------------------------------------------------------------------<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
補助ベクトルの各要素が記述される構造は、次の形式を持っています。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">uint64_t</span> a_type; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">union</span> {
        <span class="hljs-keyword">uint64_t</span> a_val; <span class="hljs-comment">// </span><font></font>
    } a_un;<font></font>
} Elf64_auxv_t;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有効なa_type値の1つはAT_PHDRであり、a_valはプログラムヘッダーを指します。</font><font style="vertical-align: inherit;">以下は、elf_load_addr関数のコードです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">elf_base_addr</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *rsp)</span> </span>{
    <span class="hljs-keyword">void</span> *base_addr = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> argc = *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>*)rsp;
    <span class="hljs-keyword">char</span> **envp = rsp + (argc+<span class="hljs-number">2</span>)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>); <span class="hljs-comment">//   </span>
                                                        <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">while</span>(*envp++); <span class="hljs-comment">//       </span>
    Elf64_auxv_t *aux = (Elf64_auxv_t*)envp; <span class="hljs-comment">//   </span>
                                             <span class="hljs-comment">// </span><font></font>
<font></font>
    <span class="hljs-keyword">for</span>(; aux-&gt;a_type != AT_NULL; aux++) {
        <span class="hljs-comment">//       </span>
        <span class="hljs-keyword">if</span>(aux-&gt;a_type == AT_PHDR) {
            <span class="hljs-comment">//   ELF ,    </span>
            <span class="hljs-comment">//     </span>
            base_addr = (<span class="hljs-keyword">void</span>*)(aux-&gt;a_un.a_val – <span class="hljs-keyword">sizeof</span>(Elf64_Ehdr));
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> base_addr;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">elf_memory_size</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *mapped)</span> </span>{<font></font>
    Elf64_Ehdr *ehdr = mapped;<font></font>
    Elf64_Phdr *phdr = mapped + ehdr-&gt;e_phoff;<font></font>
    <span class="hljs-keyword">size_t</span> mem_size = <span class="hljs-number">0</span>, segment_len;<font></font>
<font></font>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; ehdr-&gt;e_phnum; i++, phdr++) {
        <span class="hljs-keyword">if</span>(phdr-&gt;p_type != PT_LOAD)
            <span class="hljs-keyword">continue</span>;<font></font>
        segment_len = phdr-&gt;p_memsz + (phdr-&gt;p_vaddr % <span class="hljs-number">4096</span>);<font></font>
        mem_size += PAGEUP(segment_len);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> mem_size;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">elf_load_addr</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *rsp, <span class="hljs-keyword">void</span> *mapped, <span class="hljs-keyword">size_t</span> mapped_size)</span> </span>{<font></font>
    Elf64_Ehdr *ehdr = mapped;<font></font>
    <span class="hljs-keyword">if</span>(ehdr-&gt;e_type == ET_EXEC)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
    <span class="hljs-keyword">size_t</span> mem_size = elf_memory_size(mapped) + <span class="hljs-number">0x1000</span>;
    <span class="hljs-keyword">void</span> *load_addr = elf_base_addr(rsp);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(mapped &lt; load_addr &amp;&amp; mapped + mapped_size &gt; load_addr - mem_size)<font></font>
        load_addr = mapped;<font></font>
<font></font>
    <span class="hljs-keyword">return</span> load_addr - mem_size;<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンカースクリプトの説明</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のextern変数の文字を定義する必要があります。また、コンパイル後のコードとローダーデータが同じ.textセクションにあることを確認してください。</font><font style="vertical-align: inherit;">これは、ファイルからこのセクションの内容を単にカットするだけで、ローダーマシンのコードを簡単に抽出するために必要です。</font><font style="vertical-align: inherit;">これらの目標を達成するために、次のリンカースクリプトが作成されました。</font></font><br>
<br>
<pre><code class="plaintext hljs">ENTRY(_start)<font></font>
SECTIONS {<font></font>
    . = 0;<font></font>
    .text :{<font></font>
        *(.text) *(.text.startup) *(.data) *(.rodata)<font></font>
        payload_size = .;<font></font>
        QUAD(0)<font></font>
        key_seed = .;<font></font>
        QUAD(0)<font></font>
        iv_seed = .;<font></font>
        QUAD(0)<font></font>
        loader_end = .;<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
QUAD（0）は8バイトのゼロを配置することを説明する価値があります。代わりに、パッカーは特定の値を置き換えます。</font><font style="vertical-align: inherit;">マシンコードを切り取るために、ブートローダーの先頭からブートローダーへのエントリポイントのシフト、ブートローダーの先頭からのpayload_size、key_seed、およびiv_seed文字の値のオフセットもマシンコードの先頭に書き込む小さなユーティリティが書き込まれました。</font><font style="vertical-align: inherit;">このユーティリティのコードは、こちらから入手でき</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これでブートローダーの説明は終了です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接パッカー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パッカーの主な機能を検討してください。</font><font style="vertical-align: inherit;">2つのコマンドライン引数を使用します。入力ファイル名はargv [1]で、出力ファイル名はargv [2]です。</font><font style="vertical-align: inherit;">まず、入力ファイルがメモリに表示され、packerとの互換性がチェックされます。</font><font style="vertical-align: inherit;">パッカーは、ET_EXECとET_DYNの2種類のELFファイルのみを処理し、静的にコンパイルされたファイルのみを処理します。</font><font style="vertical-align: inherit;">この制限が導入された理由は、Linuxシステムごとに共有ライブラリのバージョンが異なるためです。</font><font style="vertical-align: inherit;">動的にコンパイルされたプログラムが親システム以外のシステムで起動しない可能性は非常に高いです。</font><font style="vertical-align: inherit;">メイン関数の対応するコード：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">size_t</span> mapped_size;
<span class="hljs-keyword">void</span> *mapped = map_file(argv[<span class="hljs-number">1</span>], &amp;mapped_size);
<span class="hljs-keyword">if</span>(check_elf(mapped) &lt; <span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、入力ファイルが互換性チェックに合格すると、圧縮されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">size_t</span> comp_size;
<span class="hljs-keyword">uint8_t</span> *comp_buf = huffman_encode(mapped, &amp;comp_size);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、AES状態が生成され、圧縮されたELFファイルが暗号化されます。</font><font style="vertical-align: inherit;">AESの状態は、次の構造によって決定されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AES_ENTROPY_BUFSIZE 256</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">uint8_t</span> entropy_buf[AES_ENTROPY_BUFSIZE]; <span class="hljs-comment">// 256- </span>
    <span class="hljs-keyword">size_t</span> key_seed; <span class="hljs-comment">//     </span>
    <span class="hljs-keyword">size_t</span> iv_seed; <span class="hljs-comment">//      </span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AES_ctx</span> <span class="hljs-title">ctx</span>;</span> <span class="hljs-comment">//  AES-CTR</span><font></font>
} AES_state_t;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインの対応するコード：</font></font><br>
<br>
<pre><code class="cpp hljs">AES_state_t aes_st;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; AES_ENTROPY_BUFSIZE; i++)<font></font>
    state.entropy_buf[i] = rand() % <span class="hljs-number">256</span>;<font></font>
state.key_seed = rand();<font></font>
state.iv_seed = rand();<font></font>
AES_init_ctx_iv(&amp;state.ctx, state.entropy_buf, state.key_seed, state.iv_seed);<font></font>
AES_CTR_xcrypt_buffer(&amp;aes_st.ctx, comp_buf, comp_size);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、ブートローダーに関する情報を格納する構造が初期化され、ブートローダーのpayload_size、key_seed、iv_seedの値が前のステップで生成された値に変更され、その後AES状態がリセットされます。</font><font style="vertical-align: inherit;">ブートローダーに関する情報は、次の構造で保存されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">char</span> *loader_begin; <span class="hljs-comment">//     </span>
    <span class="hljs-keyword">size_t</span> entry_offset; <span class="hljs-comment">//      </span>
    <span class="hljs-keyword">size_t</span> *payload_size_patch_offset; <span class="hljs-comment">//    </span>
                                       <span class="hljs-comment">// ELF   </span>
    <span class="hljs-keyword">size_t</span> *key_seed_pacth_offset; <span class="hljs-comment">//    </span>
                                   <span class="hljs-comment">//      </span>
    <span class="hljs-keyword">size_t</span> *iv_seed_patch_offset; <span class="hljs-comment">//    </span>
                                  <span class="hljs-comment">//    </span>
                                  <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">size_t</span> loader_size; <span class="hljs-comment">//    </span>
} <span class="hljs-keyword">loader_t</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインの対応するコード：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">loader_t</span> loader;<font></font>
init_loader(&amp;loader);<font></font>
*loader.payload_size_patch_offset = comp_size;<font></font>
*loader.key_seed_pacth_offset = aes_st.key_seed;<font></font>
*loader.iv_seed_patch_offset = aes_st.iv_seed;<font></font>
<span class="hljs-built_in">memset</span>(&amp;aes_st.ctx, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(aes_st.ctx));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後の部分では、出力ファイルを作成し、ELFヘッダー、1つのプログラムヘッダー、ローダーコード、圧縮および暗号化されたELFファイル、および256バイトのバッファーを書き込みます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> out_fd = open(argv[<span class="hljs-number">2</span>], O_WRONLY | O_CREAT | O_TRUNC, <span class="hljs-number">0755</span>); <span class="hljs-comment">// </span>
                                                                <span class="hljs-comment">//  </span>
write_elf_ehdr(out_fd, &amp;loader); <span class="hljs-comment">//  ELF </span>
write_elf_phdr(out_fd, &amp;loader, comp_size); <span class="hljs-comment">//   </span>
write(out_fd, loader.loader_begin, loader.loader_size); <span class="hljs-comment">//  </span>
write(out_fd, comp_buf, comp_size); <span class="hljs-comment">//     ELF</span>
write(out_fd, aes_st.entropy_buf, AES_ENTROPY_BUFSIZE); <span class="hljs-comment">// </span>
                                                        <span class="hljs-comment">// 256- </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでメインパッカーコードが終了し、ブートローダー情報初期化関数、ELFヘッダー記録関数、およびプログラムヘッダー記録関数の機能が検討されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブートローダー情報の初期化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ローダーマシンコードは、以下の簡単なコードを使用して、実行可能ファイルに埋め込まれます。</font></font><br>
<br>
<pre><code class="plaintext hljs">.data<font></font>
.globl _loader_begin<font></font>
.globl _loader_end<font></font>
_loader_begin:<font></font>
.incbin "loader"<font></font>
_loader_end:<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリ内のアドレスを決定するために、main.cファイルで次の変数が宣言されています。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span>* _loader_begin;
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span>* _loader_end;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、init_loader関数について考えます。</font><font style="vertical-align: inherit;">最初に、次の値が順番に読み取られます：ブートローダーの先頭からのエントリポイントのオフセット（entry_offset）、ブートローダーの先頭からのパックされたELFファイルのサイズのオフセット（payload_size_patch_offset）、ブートローダーの先頭からのキーの初期ジェネレーター値のシフト（key_seed_pa​​tch_offsetのベクトルのシフト値、ベクトルのシフト）ブートローダーの最初からの初期化（iv_seed_pa​​tch_offset）。</font><font style="vertical-align: inherit;">次に、ローダーアドレスが最後の3つの値に追加されるため、ポインターを逆参照して値を割り当てるときに、レイアウトステージで割り当てられたゼロ（QUAD（0））を必要な値に置き換えます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_loader</span><span class="hljs-params">(<span class="hljs-keyword">loader_t</span> *l)</span> </span>{
    <span class="hljs-keyword">void</span> *loader_begin = (<span class="hljs-keyword">void</span>*)&amp;_loader_begin;<font></font>
    l-&gt;entry_offset = *(<span class="hljs-keyword">size_t</span>*)loader_begin;<font></font>
    loader_begin += <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">size_t</span>);<font></font>
<font></font>
    l-&gt;payload_size_patch_offset = *(<span class="hljs-keyword">void</span>**)loader_begin;<font></font>
    loader_begin += <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span>*);<font></font>
<font></font>
    l-&gt;key_seed_pacth_offset = *(<span class="hljs-keyword">void</span>**)loader_begin;<font></font>
    loader_begin += <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span>*);<font></font>
<font></font>
    l-&gt;iv_seed_patch_offset = *(<span class="hljs-keyword">void</span>**)loader_begin;<font></font>
    loader_begin += <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span>*);<font></font>
<font></font>
    l-&gt;payload_size_patch_offset = (<span class="hljs-keyword">size_t</span>)l-&gt;payload_size_patch_offset +<font></font>
                                   loader_begin;<font></font>
    l-&gt;key_seed_pacth_offset = (<span class="hljs-keyword">size_t</span>)l-&gt;key_seed_pacth_offset +<font></font>
                               loader_begin;<font></font>
    l-&gt;iv_seed_patch_offset = (<span class="hljs-keyword">size_t</span>)l-&gt;iv_seed_patch_offset +<font></font>
                              loader_begin;<font></font>
<font></font>
    l-&gt;loader_begin = loader_begin;<font></font>
    l-&gt;loader_size = (<span class="hljs-keyword">void</span>*)&amp;_loader_end - loader_begin;<font></font>
}<font></font>
</code></pre><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">write_elf_ehdr</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_elf_ehdr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">loader_t</span> *loader)</span> </span>{
    <span class="hljs-comment">//  ELF </span><font></font>
    Elf64_Ehdr ehdr;<font></font>
    <span class="hljs-built_in">memset</span>(ehdr.e_ident, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ehdr.e_ident));
    <span class="hljs-built_in">memcpy</span>(ehdr.e_ident, ELFMAG, SELFMAG);<font></font>
    ehdr.e_ident[EI_CLASS] = ELFCLASS64;<font></font>
    ehdr.e_ident[EI_DATA] = ELFDATA2LSB;<font></font>
    ehdr.e_ident[EI_VERSION] = EV_CURRENT;<font></font>
    ehdr.e_ident[EI_OSABI] = ELFOSABI_NONE;<font></font>
<font></font>
    ehdr.e_type = ET_DYN;<font></font>
    ehdr.e_machine = EM_X86_64;<font></font>
    ehdr.e_version = EV_CURRENT;<font></font>
    ehdr.e_entry = <span class="hljs-keyword">sizeof</span>(Elf64_Ehdr) +
                   <span class="hljs-keyword">sizeof</span>(Elf64_Phdr) +<font></font>
                   loader-&gt;entry_offset;<font></font>
    ehdr.e_phoff = <span class="hljs-keyword">sizeof</span>(Elf64_Ehdr);<font></font>
    ehdr.e_shoff = <span class="hljs-number">0</span>;<font></font>
    ehdr.e_flags = <span class="hljs-number">0</span>;<font></font>
    ehdr.e_ehsize = <span class="hljs-keyword">sizeof</span>(Elf64_Ehdr);<font></font>
    ehdr.e_phentsize = <span class="hljs-keyword">sizeof</span>(Elf64_Phdr);<font></font>
    ehdr.e_phnum = <span class="hljs-number">1</span>;<font></font>
    ehdr.e_shentsize = <span class="hljs-keyword">sizeof</span>(Elf64_Shdr);<font></font>
    ehdr.e_shnum = <span class="hljs-number">0</span>;<font></font>
    ehdr.e_shstrndx = <span class="hljs-number">0</span>;<font></font>
<font></font>
    write(fd, &amp;ehdr, <span class="hljs-keyword">sizeof</span>(ehdr)); <span class="hljs-comment">//    </span><font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、ELFヘッダーの標準的な初期化とそれに続くファイルへの記録が行われます。注意が必要なのは、ET_DYN ELFファイルでは、最初のプログラムヘッダーによって記述されるセグメントに実行可能コードだけでなく、ELFヘッダーとすべてのヘッダーも含まれるということです。プログラム。</font><font style="vertical-align: inherit;">したがって、最初からのオフセットはゼロである必要があり、サイズはELFヘッダー、すべてのプログラムヘッダー、および実行可能コードのサイズの合計であり、エントリポイントは、ELFヘッダーのサイズ、すべてのプログラムヘッダーのサイズ、および実行可能コードの先頭からのオフセットの合計として決定されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">write_elf_phdr</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_elf_phdr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">loader_t</span> *loader, <span class="hljs-keyword">size_t</span> payload_size)</span> </span>{
    <span class="hljs-comment">//   </span><font></font>
    Elf64_Phdr phdr;<font></font>
    phdr.p_type = PT_LOAD;<font></font>
    phdr.p_offset = <span class="hljs-number">0</span>;<font></font>
    phdr.p_vaddr = <span class="hljs-number">0</span>;<font></font>
    phdr.p_paddr = <span class="hljs-number">0</span>;<font></font>
    phdr.p_filesz = <span class="hljs-keyword">sizeof</span>(Elf64_Ehdr) +
                    <span class="hljs-keyword">sizeof</span>(Elf64_Phdr) +<font></font>
                    loader-&gt;loader_size +<font></font>
                    payload_size +<font></font>
                    AES_ENTROPY_BUFSIZE;<font></font>
    phdr.p_memsz = phdr.p_filesz;<font></font>
    phdr.p_flags = PF_R | PF_W | PF_X;<font></font>
    phdr.p_align = <span class="hljs-number">0x1000</span>;<font></font>
<font></font>
    write(fd, &amp;phdr, <span class="hljs-keyword">sizeof</span>(phdr)); <span class="hljs-comment">//     </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、プログラムヘッダーが初期化され、ファイルに書き込まれます。</font><font style="vertical-align: inherit;">ファイルの先頭からのオフセットと、プログラムヘッダーで記述されたセグメントのサイズに注意する必要があります。</font><font style="vertical-align: inherit;">前の段落で説明したように、このヘッダーによって記述されるセグメントには、実行可能コードだけでなく、ELFヘッダーとプログラムヘッダーも含まれます。</font><font style="vertical-align: inherit;">また、書き込み可能な実行可能コードを含むセグメントを作成します。これは、ブートローダーで使用されるAES実装がデータを適切に暗号化および復号化するためです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッカーの仕事についてのいくつかの事実</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト中に、glibcで静的にコンパイルされたプログラムは、次の命令で、起動時にsegfaultに移動することがわかりました。</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">movq％fs：0x28、％rax</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜそうなるのかわかりませんでしたが、この件に関する情報を共有していただければ幸いです。</font><font style="vertical-align: inherit;">glibcの代わりに、musl-libcを使用できます。すべてが確実に動作します。</font><font style="vertical-align: inherit;">また、packerは、httpサーバーなどの静的にコンパイルされたgolangプログラムでテストされました。</font><font style="vertical-align: inherit;">golangプログラムの完全な静的クラッシュの場合、次のフラグを使用する必要があります。</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CGO_ENABLED = 0 go build -a -ldflags '-extldflags "-static"'。</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パッカーが最後にテストされたのは、動的リンカーのないET_DYN ELFファイルでした。</font><font style="vertical-align: inherit;">確かに、これらのファイルを操作するとき、elf_load_addr関数は失敗する可能性があります。</font><font style="vertical-align: inherit;">実際には、ブートローダーから切り取り、固定アドレス（0x10000など）を使用できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパッカーは、保護されているファイルを簡単に復号化できるため、意図した目的に使用しても意味がありません。</font><font style="vertical-align: inherit;">このプロジェクトの目的は、ELFファイルでの作業、それらを生成する方法、およびより完全なパッカーの作成の準備をよりよくマスターすることでした。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja483354/index.html">二ヶ月目の呪い</a></li>
<li><a href="../ja483356/index.html">コミュニティ数「何？」どこ？いつ？" （ChGK）または友達の前で何回握手？</a></li>
<li><a href="../ja483360/index.html">パワー電気駆動制御。アマチュア体験</a></li>
<li><a href="../ja483364/index.html">仕事でコードを書いて、時間を節約できます。</a></li>
<li><a href="../ja483366/index.html">インターネットの歴史：ネットワーキング</a></li>
<li><a href="../ja483372/index.html">GPUを使用してラップトップでDeepPavlovニューラルネットワークをトレーニングする方法</a></li>
<li><a href="../ja483374/index.html">REST APIガイドライン-JavaおよびSpringでのWebサービス設計の例</a></li>
<li><a href="../ja483376/index.html">ブラックホールの表面に</a></li>
<li><a href="../ja483378/index.html">C ++ 17でオーバーヘッドのないレジスタを使用したタイプセーフな作業：値ベースのメタプログラミング</a></li>
<li><a href="../ja483380/index.html">マイクロサービス：契約の遵守方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>