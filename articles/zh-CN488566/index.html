<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐝 🦓 🧓🏽 质量检查工程师如何通过链接Visual Studio中的自动测试和测试IT来节省一整天 👩‍❤️‍💋‍👩 👿 ✨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="开发人员的现代工作工具有十二种不同的应用程序：IDE，测试系统，各种框架，版本控制和容器化系统，办公应用程序等等。
 
 通常，我们在没有注意到的情况下，会花费宝贵的时间将数据从一个工作系统传输到另一个工作系统。但是，为什么我们不进行工作流程的优化，即使是很小的事情呢？五分钟乘以每天五次，每月总共可...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>质量检查工程师如何通过链接Visual Studio中的自动测试和测试IT来节省一整天</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/488566/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开发人员的现代工作工具有十二种不同的应用程序：IDE，测试系统，各种框架，版本控制和容器化系统，办公应用程序等等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，我们在没有注意到的情况下，会花费宝贵的时间将数据从一个工作系统传输到另一个工作系统。但是，为什么我们不进行工作流程的优化，即使是很小的事情呢？五分钟乘以每天五次，每月总共可以给我们超过一个工作日，这比平常的工作所花的时间要有用得多。因此，我们开始为Visual Studio创建扩展，它使我们能够在Test IT系统中自动化创建自动测试的过程。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
继续讲述</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Webhooks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及它们如何帮助连接工作中的许多服务，我们向您介绍了有关为我们的工作IDE-Visual Studio创建扩展的故事。</font><font style="vertical-align: inherit;">欢迎来到猫！</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文是来自Test IT团队的嘉宾帖子。</font></font></blockquote><br>
<img src="https://habrastorage.org/webt/de/p4/sn/dep4snssll0ayy6pne0d8g_kvio.png"><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上一篇文章中讨论的聊天机器人当然不错，但是到目前为止，它仅为我们提供有关自动测试当前状态的信息。而且，如果我们与Test IT系统建立了更紧密的集成，则可以自动在门户上扩展当前项目的测试列表，而无需手动添加它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前，为此，我们使用了一个匆忙部署的库和一个控制台应用程序，该应用程序在启动时会查看当前的解决方案，找到一个测试项目，从其程序集中提取一系列自动测试，然后将其发送到我们的API。看来您可以那样做，因为该解决方案有效。但是，不断拖延整个项目（即使这是异步调用该库的一种方法）非常困难，并且项目之间的永恒依赖关系也不是好习惯的标志。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们开始为Visual Studio创建扩展，现在我们将介绍如何制作扩展。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术方面</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们自然会在Visual Studio本身中开发扩展。毕竟，没有人比IDE本身更了解IDE。首先，请确保Visual Studio具有创建扩展所需的所有组件。我们找到并启动Visual Studio Installer，并检查“ Visual Studio Extensions的开发”模块：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1_/u1/kp/1_u1kppuwwmkcolqbxic8mluadq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一项检查足以让我们安装所有必要的工作库。有关用于Visual Studio扩展的开发的安装信息应大致处于以下情况：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f3/8k/ko/f38kkok4jcjusae2fqhmkguplvu.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
准备部分已结束，我们可以继续创建新项目，并使自己沉浸在扩展模板的体系结构中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将使用短语“ VSIX”找到可用的解决方案列表，然后选择VSIX Project（当然是C＃），以扩展新的扩展程序：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ms/v4/x0/msv4x0wvkmduxaekbvdxtev5spi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
部署后，扩展模板的简单体系结构使我们乍看之下：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c4/zs/u4/c4zsu4q1ojiogciyo-7s0z6qdsw.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此示例中，source.extension.vsixmanifest是描述扩展的基本属性的通用清单，例如产品名称，作者，版本，描述，扩展图标，IDE的目标版本。还有很多其他顺便说一下，在扩展存储区和Visual Studio扩展安装程序中都可以查看这些属性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VSIXProject3Package.cs（掩码：{ProjectName} Package.cs）又是一个初始化程序类，该类注册所有可用的命令和资源模式。我们现在将了解团队。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们创建一个新的团队，该团队打开带有扩展参数的WPF窗口：我们需要存储有关目标项目的数据，其程序集的位置和名称，与服务器的连接以及其他信息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们正在寻找一个新的元素，称为颇合逻辑的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Command</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7t/a8/rl/7ta8rlzogkygdh2cxngxbrt8kgi.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
许多人可能会怀疑：当异步工具窗口和工具窗口适合按名称描述任务时，为什么要使用命令？一切都非常简单：创建这两个元素时，我们会将标记文件部署到xaml，具有相同名称的cs文件以及命令。一切都会好起来，就像我们需要的一样，但是在这种情况下，“工具窗口”（无论是否异步）都部署了一个集成到Visual Studio本身的窗口模板。在输出中，我们获得其中一个窗口，默认情况下会展开该窗口，而不是“调试”窗口。当然，所有这些都是可定制的，但是我们需要一个第三方窗口。这就是为什么我们不使用“工具窗口”，而是添加常规WPF窗口的原因。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为创建带有标准元素的新窗口的细节可以省略，因为它很无聊，无趣且与文章标题联系不紧密。您可以在这里留下的唯一建议是：添加新元素时，Visual Studio不会在选项列表中显示WPF窗口，因此，最快，最简单的选择是与扩展项目分开创建一个这样的窗口，然后将其转移到当前项目中（不要忘记固定空间）名称）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z8/hf/nf/z8hfnfvt6rebokigeoxdq2hcl-q.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，在创建了一个新团队（我们称为OpenSettingsCommand）之后，传奇的Studio代码生成过程将创建一个团队类和一个vsct格式文件，该文件既存储我们扩展的标记，又存储命令的映射以及调用它们的按钮。</font><font style="vertical-align: inherit;">非常需要在您自己的实现上重写标记：自动创建的标记，它将把您的元素放在“扩展”菜单中。</font><font style="vertical-align: inherit;">在这种情况下，我们通过创建一个由两个团队组成的小组并直接将其放置在工具栏上来重写此标记。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在我们的存储库中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以找到命令和标记的示例</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在创建的类中，我们可以注意到Execute方法，当调用此命令时，该方法将从所有内容开始。</font><font style="vertical-align: inherit;">实际上，我们将在这里注册新的WPF窗口的初始化。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">环境</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们顺利地使用了Visual Studio SDK，即EnvDTE库。这个COM库使我们能够使用Visual Studio的对象和元素：获得活动解决方案和项目的列表，使用语法突出显示，活动窗口，阅读项目代码等等。实际上，如果您沉迷于该库的文档，您将为自己找到很多有用的功能。在此示例中，我们精确地使用它来获取活动解决方案中的项目列表。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管免费的代码库很小，但是我们只需要几行代码即可获得活动解决方案中的项目列表：</font></font><br>
<br>
<pre><code class="cs hljs">ThreadHelper.ThrowIfNotOnUIThread();
<span class="hljs-keyword">var</span> activeVS = (DTE)Microsoft.VisualStudio.Shell.ServiceProvider.GlobalProvider.GetService(<span class="hljs-keyword">typeof</span>(DTE))<font></font>
 ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">"DTE not found"</span>);
<span class="hljs-keyword">var</span> activeProjects = <span class="hljs-keyword">new</span> List&lt;Project&gt;();<font></font>
activeProjects.AddRange(activeVS.Solution.Projects.Cast&lt;Project&gt;());<font></font>
<span class="hljs-comment">//  , activeProjects         </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们可以轻松自然地收集有关所有活动项目的详细信息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从此列表中获取项目名称（名称属性）和csproj文件的路径（突然为FullName）：这足以让我们从可能的项目列表中向用户询问所需的项目并将其映射到目录以搜索程序集。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一步是连接库，库的任务是分析程序集，收集自动测试并将其发布在Test IT门户上。我们将省略创建库的详细信息，但将提供一个有趣的类，该类可以从已加载的程序集中获取自动测试的列表：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AutotestsService</span><font></font>
    {<font></font>
        <span class="hljs-keyword">public</span> IList&lt;AutotestModel&gt; GetAutotestsFromAssembly&lt;TTestClassAttribute, TTestMethodAttribute&gt;(Assembly assembly, Guid projectId, <span class="hljs-keyword">string</span> repositoryLink)
            <span class="hljs-keyword">where</span> TTestClassAttribute : Attribute
            <span class="hljs-keyword">where</span> TTestMethodAttribute : Attribute<font></font>
        {<font></font>
            MethodInfo[] testMethods = GetAutotestFromAssembly&lt;TTestClassAttribute, TTestMethodAttribute&gt;(assembly);<font></font>
<font></font>
            List&lt;AutotestModel&gt; allModels = <span class="hljs-keyword">new</span> List&lt;AutotestModel&gt;();
            <span class="hljs-keyword">foreach</span> (MethodInfo method <span class="hljs-keyword">in</span> testMethods)<font></font>
            {<font></font>
                AutotestModel autotest = <span class="hljs-keyword">new</span> AutotestModel()<font></font>
                {<font></font>
                    ExternalId = method.Name,<font></font>
                    LinkToRepository = repositoryLink,<font></font>
                    ProjectId = projectId,<font></font>
                    Name = GetAutotestName(method.Name),<font></font>
                    Classname = method.DeclaringType.Name,<font></font>
                    Namespace = GetAutotestNamespace(method)<font></font>
                };<font></font>
<font></font>
                allModels.Add(autotest);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> allModels;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MethodInfo[] GetAutotestFromAssembly&lt;TTestClassAttribute, TTestMethodAttribute&gt;(Assembly assembly)
            <span class="hljs-keyword">where</span> TTestClassAttribute : Attribute
            <span class="hljs-keyword">where</span> TTestMethodAttribute : Attribute<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> assembly.GetTypes()<font></font>
                .Where(c =&gt; c.IsDefined(<span class="hljs-keyword">typeof</span>(TTestClassAttribute)))<font></font>
                .SelectMany(t =&gt; t.GetMethods())<font></font>
                .Where(m =&gt; m.IsDefined(<span class="hljs-keyword">typeof</span>(TTestMethodAttribute)))<font></font>
                .ToArray();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">string</span> <span class="hljs-title">GetAutotestName</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> autotestExternalId</span>)</span><font></font>
        {<font></font>
            StringBuilder autotestName = <span class="hljs-keyword">new</span> StringBuilder();<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; autotestExternalId.Length; i++)<font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">char</span>.IsUpper(autotestExternalId[i]) &amp;&amp; i != <span class="hljs-number">0</span>)<font></font>
                    autotestName.Append(<span class="hljs-string">' '</span>);<font></font>
                autotestName.Append(autotestExternalId[i]);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> autotestName.ToString();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">string</span> <span class="hljs-title">GetAutotestNamespace</span>(<span class="hljs-params">MethodInfo testMethod</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> testMethod.DeclaringType.FullName<font></font>
                .Replace(<span class="hljs-string">$".<span class="hljs-subst">{testMethod.DeclaringType.Name}</span>"</span>, <span class="hljs-keyword">string</span>.Empty);<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
库的整个源代码始终可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在我们的存储库中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，回到扩展名。</font><font style="vertical-align: inherit;">要启动库的逻辑，您需要添加一个新命令，在Execute方法中我们编写库调用，并向其传递测试类和方法的属性以及保存的扩展参数：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> settings = Properties.Settings.Default;
<span class="hljs-keyword">var</span> executor = <span class="hljs-keyword">new</span> LinkExecutor();
<span class="hljs-keyword">await</span> executor.Execute&lt;TestClassAttribute, TestMethodAttribute&gt;(<font></font>
    settings.Domain,<font></font>
    settings.SecretKey,<font></font>
    settings.ProjectNameInTestIT,<font></font>
    settings.RepositoryLink ?? <span class="hljs-keyword">string</span>.Empty,<font></font>
    settings.AssemblyPath,<font></font>
    Logger);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要说明：我们跳过记录器进入库，以便能够将技术信息直接写入Visual Studio消息输出窗口。</font><font style="vertical-align: inherit;">该库不应仅与此IDE绑定，对于我们来说，重要的是要有机会在任何情况下使用它。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，在开发之后，我们得到了以下扩展名：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/al/b2/sa/alb2samrb9b5f6l48lmfoumpa2q.png"><br>
 <br>
<blockquote>    .  ,       Visual Studio,     ,      Visual Studio  Visual Studio    Visual Studio      Visual Studio.    ,   .</blockquote><br>
<img src="https://habrastorage.org/webt/jn/1d/zy/jn1dzyk8tj82bfbga47pabgta2g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们打开一个包含一个带有单元测试项目的示例解决方案，然后在其上测试我们的扩展。加载项目时，我们可以立即在面板上看到一个新按钮：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bc/bv/ts/bcbvtslenbgaar8yodstv3b63wu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
立即从您的个人帐户中获取API密钥，并在我们的平台上准备一个新项目：</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/to/md/t8/tomdt8mhsgaiqyxu99gmjg3faoe.png"><br>
<br>
<img src="https://habrastorage.org/webt/i8/vt/06/i8vt06nwwm9sjccpcpsnft2hjiw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，</font><font style="vertical-align: inherit;">让我们</font><font style="vertical-align: inherit;">回到扩展程序。让我们用扩展参数打开窗口并填写字段：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dk/k8/7o/dkk87oshczsgho69bwppufbckvm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将当前项目列表传递给窗口设计器，由Visual Studio SDK库提供，并在选择项目后加载“ Project dll”选项：该服务在UnitTestProject项目的程序集中查找所有dll文件”并向我们展示了可能的图书馆选择。我们保存设置并运行扩展程序的主要功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
几秒钟后，在输出窗口中，我们看到以下内容：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zm/ds/sy/zmdssyus9a7hapbht4jzi5z_cfc.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
谁在乎我们如何输出消息-记录器的源代码可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的示例中，有3个单元测试和3个集成测试。</font><font style="vertical-align: inherit;">听起来像是事实。</font><font style="vertical-align: inherit;">检查是否有门户网站：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5g/mx/fh/5gmxfhgj4hamitcruqipqm__6z4.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今天，我们以在Test IT平台上发布自动测试列表的扩展示例为例，研究了为Visual Studio创建扩展的基础。</font><font style="vertical-align: inherit;">扩展选项仅受您的想象力限制：您可以与团队进行聊天，可以在分支机构的项目崩溃时创建通知，甚至</font><font style="vertical-align: inherit;">可以在办公室添加比萨饼订购按钮</font><font style="vertical-align: inherit;">，就像</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们对Bot Framework的幻想一样</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
梦想，创造，节省时间，并始终保持创意专家的地位！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于作者</font></font></h2><br>
<img src="https://habrastorage.org/webt/-a/ih/-6/-aih-6npcjorku37ud5joj5p7no.png" align="left" width="120"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mikhail Pirogovsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是.NET开发人员。</font><font style="vertical-align: inherit;">该材料是由Test IT团队编写的。</font><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Facebook上的小组中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们讨论了质量检查，测试，工具等方面的工作。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN488550/index.html">谁想要使合作伙伴脱离IT巨头</a></li>
<li><a href="../zh-CN488552/index.html">Apple FAS和家长控制开发人员</a></li>
<li><a href="../zh-CN488558/index.html">使用Kafka Streams确保应用程序的高可用性</a></li>
<li><a href="../zh-CN488560/index.html">在Google Cloud Platform上托管的免费Telegram机器人</a></li>
<li><a href="../zh-CN488564/index.html">您在图形处理单元（GPU）上的第一个神经网络。初学者指南</a></li>
<li><a href="../zh-CN488568/index.html">神经网络是否梦想着用电钱？</a></li>
<li><a href="../zh-CN488570/index.html">美国特勤局如何将网络朋克RPG与黑客教科书混淆</a></li>
<li><a href="../zh-CN488572/index.html">Unity分析仪现已开源</a></li>
<li><a href="../zh-CN488574/index.html">学生为STM32F411写Uart驱动程序</a></li>
<li><a href="../zh-CN488576/index.html">亚美尼亚生态运动：简单的挂历如何发展成大型的反塑料运动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>