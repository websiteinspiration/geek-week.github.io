<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕶️ 🧑‍🤝‍🧑 🤟🏼 Seimbang dalam pengambilan keputusan. Fork "pengalaman acak" 🐡 ⚪️ 👨🏽‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk menulis kehidupan nyata, Anda tidak perlu apa pun selain untuk mengalahkan diri sendiri sepenuhnya dan sepenuhnya. Saya terus menciptakannya dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Seimbang dalam pengambilan keputusan. Fork "pengalaman acak"</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499910/"><img src="https://avatars.mds.yandex.net/get-zen_doc/138668/pub_59b1408757906accd78afbea_59b16f7a58166998b74496ae/scale_1200" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menulis kehidupan nyata, Anda tidak perlu apa pun selain untuk mengalahkan diri sendiri sepenuhnya dan sepenuhnya. </font><font style="vertical-align: inherit;">Saya terus menciptakannya dan kemudian saya akan menulis artikel besar tentang topik ini, tapi, saya, apa hal ini dengan sendirinya dan betapa sulitnya untuk mengukur 7 kali, memotong satu, lalu mengukurnya lagi 77 kali dan akhirnya tidak terputus. </font><font style="vertical-align: inherit;">Ukur, ukur lagi! </font><font style="vertical-align: inherit;">- Ini adalah motto seseorang yang ingin membuat sesuatu yang benar-benar tidak biasa. </font><font style="vertical-align: inherit;">Pengkodean jauh lebih mudah daripada berpikir. </font><font style="vertical-align: inherit;">Tetapi berpikir itu menyakitkan dan tidak biasa pada umumnya.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi hari ini saya ingin memikirkan satu "masalah" yang muncul di sini kampanye. Bayangkan gerakan kacau partikel atau elemen kimia - mereka bergerak dalam volume yang terbatas bersyarat, hanya saling bertabrakan, atau mengusir - kekacauan dalam bentuk yang paling murni. Jika sistem seperti itu diluncurkan, maka bahkan di sarang semut yang tampaknya tidak berguna ini, pergerakan terstruktur akan diamati dari waktu ke waktu: tabrakan acak pada saat tertentu dapat terjadi sedemikian rupa sehingga arah dampak (impuls) akan berubah kurang lebih dalam satu arah, dan kemudian bertabrakan partikel akan bergerak dalam satu arah, membentuk gelombang. Di masa depan, gelombang dari tabrakan pihak ketiga ini akan mulai membusuk dan kita akan kembali melihat gambaran kacau.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu acak dalam esensinya secara sukarela membentuk suatu struktur, tetapi struktur hanyalah bentuk sementara dari acak ini. Mengalir dengan cara ini, kekacauan terjadi dalam berbagai bentuk, yang kami anggap sebagai sesuatu yang masuk akal, mis. dipesan. Secara umum, rasionalnya adalah apa yang diulang sehingga pengulangan kepada seseorang dapat diperhatikan. Namun, kita tidak akan membahas ini sekarang, tetapi berpikir sedikit lebih luas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ingatlah bahwa kemungkinan besar yang disebut "Kehidupan" di Bumi muncul sebagai akibat dari interaksi kacau unsur-unsur kimia. Kehidupan seperti itu tidak akan pernah terjadi jika satu molekul tidak mampu menarik elektron dari yang lain, atau sebaliknya, berpisah dengan molekulnya sendiri. </font><b><font style="vertical-align: inherit;">PELUANG</font></b><font style="vertical-align: inherit;"> ini </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sendiri</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu hanya karena fakta bahwa senyawa muncul dari unsur-unsur, dan dari senyawa itu juga terdapat replika dan organisme. Karena itu, jika kita ingin menciptakan kehidupan digital, kita harus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MEMBERIKAN PELUANG</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interaksi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita adalah Arsitek Agung Alam Semesta dan tahu persis semua hukumnya, mulai dari yang utama, maka masalah digitalisasi mereka tidak akan menjadi masalah serius. Tapi karena karena kita bukan (sayangnya), kita hanya bisa mengandalkan fakta bahwa kita dapat menebak dan menciptakan kondisi yang sama dengan munculnya kehidupan biologis, sehingga memungkinkan kehidupan digital muncul.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk inilah saya mencoba menggambarkan prinsip-prinsip kode bebas. Kode bebas maksimum yang mungkin. Bebas dari pemahaman kita sendiri tentang bagaimana kehidupan harus diatur - karena pemahaman seperti itu kemungkinan besar keliru atau tidak lengkap sehingga terlalu masuk akal. Kami makhluk kecil berusaha sangat keras untuk mempelajari dan menggambarkan segala sesuatu di sekitar kami sehingga kami bahkan tidak dapat melakukannya. Tapi tidak ada yang melarang mencoba. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika Anda menulis kode kacau, Anda pasti menemukan garpu. Pengalaman acak. Itu baik bergerak lebih jauh secara kacau, atau memungkinkan pembentukan pengalaman. Itu memungkinkan tidak hanya partikel bertabrakan, tetapi juga berinteraksi. Kami mencari analog kehidupan biologis, yang tidak terpikirkan tanpa transfer dan regenerasi pengalaman. RNA / DNA adalah pengalaman yang direkam yang ditransmisikan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sisi lain, itu tidak dapat ditentukan dalam hal apa pun, karena kita tidak benar-benar tahu bagaimana itu berkembang dan berkembang. Jika godaan ini tidak dihapus, kesalahan tidak bisa dihindari. Dengan kata lain, kita tidak bisa memberi tahu program itu bagaimana pengalaman itu harus dilihat dan bagaimana itu harus dibentuk. Tapi kita bisa memberinya alat yang pada prinsipnya dia bisa dibentuk. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya bergumul dengan diri saya sendiri untuk waktu yang sangat lama, karena menurut saya struktur penyimpanan pengalaman dapat digambarkan dengan cukup sederhana. Berpikir bahwa kesederhanaan, yang tampaknya sederhana bagi kita berdasarkan pada gagasan kita sendiri tentang kesederhanaan, adalah cara pasti untuk menipu diri kita sendiri. Saya curiga kesederhanaan sejati sangat kompleks. Tetapi saya mengusulkan untuk tidak masuk ke demagogi di sini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan kita secara acak menghasilkan garis kode yang dapat dieksekusi sebagai respons terhadap set numerik input acak. Dapat diasumsikan bahwa generasi respons, atau reaksi, adalah pengalaman. Jika sesuatu bereaksi secara stabil sama dengan sinyal masuk yang sama, kita dapat mengatakan bahwa itu menggunakan pengalaman. Oleh karena itu, saya ingin mengingat string yang dihasilkan. Tetapi ini tidak bisa dilakukan secara langsung! Anda tidak bisa hanya mengambil baris ini dan mendorongnya ke suatu tempat ke dalam variabel array dari instance kelas dan mulai membuat semacam perpustakaan reaksi dengan cara ini, menulis sesuatu seperti JIKA [input.set di memory_ array] KEMUDIAN [memori .-&gt; reaksi]. Itu tidak mungkin! Karena ini bukan fakta bahwa inilah "sistem memori biologis" bekerja. Dan bukan fakta bahwa konstruksi mereka pada awalnya sama seperti yang kita lihat sekarang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada saat yang sama, Anda tidak dapat hanya mengambil dan secara acak menghasilkan string setidaknya 256 byte dan mencoba untuk mengeksekusinya, karena pada komputer modern akan membutuhkan banyak waktu dan tidak cocok untuk kami. </font><font style="vertical-align: inherit;">Mungkin saja metode seperti itu ideal, tetapi sayangnya, tidak mungkin untuk memverifikasi ini dengan teknologi yang saat ini belum dikembangkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus, kami masih memiliki bahasa pemrograman dan, apa pun yang dikatakan orang, ide kami tentang setidaknya sesuatu. </font><font style="vertical-align: inherit;">Anda tidak dapat membangun sesuatu dari ketiadaan sama sekali. </font><font style="vertical-align: inherit;">Karena itu, kita perlu tampilan yang subyektif. </font><font style="vertical-align: inherit;">Sebagai contoh, saya tidak bisa membantu tetapi melihat bagaimana satu bentuk melewati yang lain dan sebaliknya, bagaimana kekacauan dengan mudah mengambil formulir dan juga berpisah dengan itu seperti bola diangkat dari lantai dan dilepaskan jatuh ke lantai itu dan meninggalkan bekas. </font><font style="vertical-align: inherit;">Akibatnya, saya tidak ingin menentukan sesuatu dengan tepat, tetapi saya juga tidak dapat mengacak semuanya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memahami masalahnya, bayangkan kita memiliki 2 kemungkinan tindakan dalam kode. Anda tidak dapat secara langsung menunjukkan mana yang akan dipilih, karena ini akan menjadi penentuan. Dan jika Anda mengacak semuanya, maka Anda perlu menggunakan probabilitas. Hanya apa? 50/50? 30/70? 80/20? Misalkan, hal-hal lain dianggap sama, 50/50 memang hubungan yang paling tidak pasti. Maka kode akan terlihat seperti ini:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> random.random() &gt;= <span class="hljs-number">0.5</span>:<font></font>
      <span class="hljs-number">1</span>
<span class="hljs-keyword">else</span>:<font></font>
     <span class="hljs-number">2</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Apa yang salah dengan kode ini? Dan fakta bahwa pada setiap iterasi loop, kode ini </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SELALU</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan </font><font style="vertical-align: inherit;">memilih secara acak tindakan pertama atau kedua. Dengan kata lain, kekacauan seperti itu tidak pernah terstruktur, karena ia bahkan tidak memiliki kemungkinan teoretis seperti itu. Pada umumnya, di sini kita berurusan dengan tekad yang sama. Ada jalan keluar dari situasi ini. Terdiri dari fakta bahwa action1 dan action2 sendiri harus mengubah kondisi di mana mereka diterapkan. Ada, saya pikir, opsi yang berbeda, tetapi saya ingin menawarkan yang berikut.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda ketahui, sistem operasi menyeimbangkan utas dalam antrian eksekusi menggunakan penentuan prioritas. Thread yang mengeksekusi saat runtime secara bertahap kehilangan prioritas, sementara utas menganggur dalam antrian meningkatkan prioritas ini. Pada ketukan tertentu, prioritas yang terakhir menjadi lebih tinggi daripada yang pertama, arus berubah tempat, dan kemudian situasinya berulang. Jadi, alirannya agak cepat bergantian satu sama lain dan kita melihat ilusi bahwa mereka dieksekusi hampir bersamaan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus kami, prinsip prioritas akan memungkinkan kami untuk mengubah bukan utas untuk eksekusi pada kernel, tetapi bagian-bagian dari kode di mana kontrol akan ditransfer. Dan jika kita membuat satu bagian dari kode sebagai "acak", dan yang kedua sebagai "berpengalaman", maka perubahan alternatif mereka akan menjadi solusi yang kita cari.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan kata lain, kode, menerapkan pengalaman, setiap kali akan meningkatkan kemungkinan bahwa tindakan berikutnya akan acak, dan bertindak secara acak, akan meningkatkan kemungkinan menerapkan pengalaman pada iterasi siklus berikutnya. Dengan demikian, kita mendapatkan aliran kekacauan yang diinginkan ke dalam pengalaman dan sebaliknya - persis apa yang kita butuhkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keuntungan luar biasa dari desain ini adalah sama sekali tidak ada masalah dengan osifikasi sistem, yang dikenal, misalnya, dalam jaringan saraf yang sama. Di sisi lain, kami mengorbankan stabilitas, tetapi kami tidak membutuhkannya di sini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya berharap di sini terutama </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk stres</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bahwa pemrogram klasik biasa membutuhkan stabilitas kode sebagai manna dari surga: pengakuan harus secara stabil mengenali, dan tidak setiap kali, server harus merespons dengan jawaban yang ditentukan untuk permintaan klien yang sesuai dari waktu ke waktu, dan tidak hanya untuk jawaban yang sama. , lalu yang lain, dll. dll. Dalam pemrograman reguler, ketidakstabilan kode adalah bug yang jelas yang tertangkap dalam pengujian. Dalam kasus kami, stabilitas ini tidak diperlukan dari kata sama sekali, karena kami tidak memiliki tugas kode yang jelas. Lebih tepatnya, tidak sama sekali. Tapi kita bisa mengatakannya dengan cara lain: kita perlu stabilitas perubahan kode transfer kontrol, dan kita mendapatkannya. Dapat juga dikatakan bahwa pendulum stabil, meskipun ia berhasil bergerak dari satu titik ke titik yang berlawanan dalam satu siklus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar tidak berdasar, saya sarankan melihat kode dasar berikut di Python, yang saya buat sketsa hari ini, dipandu oleh semua pertimbangan di atas. </font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> random<font></font>
<font></font>
deter_numb = <span class="hljs-number">69</span>
p_deter = <span class="hljs-number">0.01</span>
p_random = <span class="hljs-number">0.99</span>
iteration = <span class="hljs-number">1</span><font></font>
<font></font>
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
        print(<span class="hljs-string">'iter = '</span>,iteration)<font></font>
        print(<span class="hljs-string">'p_rand =  '</span>, p_random)         <font></font>
        print(<span class="hljs-string">'p_deter = '</span>, p_deter)<font></font>
        input()<font></font>
        <span class="hljs-keyword">if</span> p_random &gt; random.random():<font></font>
            p_random-=<span class="hljs-number">0.01</span>                     <span class="hljs-comment">#  </span>
            p_deter+=<span class="hljs-number">0.01</span>
            print(random.random())    <span class="hljs-comment">#  </span>
        <span class="hljs-keyword">if</span> p_deter &gt; random.random():       <font></font>
            p_deter-=<span class="hljs-number">0.01</span>                      <span class="hljs-comment">#  </span>
            p_random+=<span class="hljs-number">0.01</span>
            print(deter_numb)            <span class="hljs-comment">#  </span>
        iteration+=<span class="hljs-number">1</span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mendorong Anda untuk mencoba menjalankan skrip ini sendiri dan melihat cara kerjanya. </font><font style="vertical-align: inherit;">Ini adalah kode penyeimbang sendiri. </font><font style="vertical-align: inherit;">Saat aksi 1 berdiri</font></font><pre><code class="python hljs">print(random.random())</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- yaitu </font><font style="vertical-align: inherit;">hanya output angka acak, dan tindakan 2 -</font></font><pre><code class="python hljs">print(deter_numb)</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Output dari nomor yang ditentukan. Dalam kode, akan ada tindakan di tempat mereka, saya membuat cetakan di sini hanya untuk menunjukkan prinsipnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kontrol beralih ke kondisi pertama (bagian acak dari kode), kode itu sendiri mengurangi kemungkinan pengulangan (p_random- = 0,01 - mengurangi sendiri) dan pada saat yang sama meningkatkan kemungkinan eksekusi bagian kode di mana pengalaman diterapkan (p_deter + = 0,01 - peningkatan probabilitas orang lain). Hal yang sama terjadi ketika mentransfer kontrol ke kondisi kedua. Dengan demikian, kedua potongan kode ini, ketika dieksekusi, mereka sendiri "melambat" dan pada saat yang sama "mempercepat" bagian "yang bersaing" lainnya dari kode.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harap dicatat bahwa probabilitas awal bahwa kontrol akan ditransfer ke bagian acak dari kode adalah 99%, dan ke eksperimental - 1%. Ini untuk menunjukkan bahwa sistem seimbang bahkan dengan probabilitas yang sangat berbeda. Ketika mengeksekusi kode, akan terlihat bagaimana rasio ini akan mencapai 50/50 hanya dalam seratus iterasi, membentuk distribusi normal dengan puncak eksplisit 0,5 dan lingkungan kerja sekitar 6% (dalam 3-5 ratus iterasi berikutnya). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika mengeksekusi kode, jelas bahwa probabilitas datang ke keseimbangan dan menetap di sekitar 0,5, menyeimbangkan melewati titik ini seperti pendulum yang menyeimbangkan di sekitar titik bawahnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Satu fitur lagi terlihat di sini: salah satu nomor acak atau yang ditentukan ditampilkan (69), atau keduanya sekaligus, yang berarti bahwa sistem dapat menerapkan pengalaman dan kemudian bertindak secara acak, atau sebaliknya, atau hanya menerapkan pengalaman, atau hanya bertindak secara acak. </font><font style="vertical-align: inherit;">Dengan kata lain, eksekusi kode itu sendiri tetap acak, tetapi kami telah mengaktifkan sistem untuk menerapkan pengalaman, mis. </font><font style="vertical-align: inherit;">kami menyingkirkan tekad ketika memutuskan tindakan, yang persis apa yang kami butuhkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada artikel selanjutnya, kita akan mempertimbangkan pembentukan tindakan dan pengalaman acak. </font><font style="vertical-align: inherit;">Nah, atau sesuatu yang terpisah, mari kita lihat bagaimana kelanjutannya.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id499898/index.html">Bagaimana orang-orang IT berhubungan dengan karantina, apa yang mereka lakukan sendiri dan apa yang mereka gunakan</a></li>
<li><a href="../id499900/index.html">Mitap analitik produk: gratis, tanpa kontak, online</a></li>
<li><a href="../id499902/index.html">Bagaimana TCP Reset Attack Bekerja</a></li>
<li><a href="../id499904/index.html">"Saya ketakutan". Apa yang harus dilakukan?</a></li>
<li><a href="../id499906/index.html">Contoh penggunaan AR di industri mainan</a></li>
<li><a href="../id499920/index.html">Trik Kecil SSH</a></li>
<li><a href="../id499922/index.html">Akhirnya kami berurusan dengan baud rate Modbus</a></li>
<li><a href="../id499926/index.html">30 April Java Digest</a></li>
<li><a href="../id499928/index.html">Udalenka: apa yang berubah dengan COVID-19 dan siapa yang sekarang bahkan lebih baik dari sebelumnya</a></li>
<li><a href="../id499930/index.html">Bagaimana saya merancang blok dan transaksi di blockchain Go saya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>