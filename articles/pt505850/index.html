<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥üèº ‚õπüèª ü§™ Polimorfismo baseado em conceito do C ++ no c√≥digo do produto: PassManager no LLVM üç∂ üë©üèæ‚Äçüåæ üåà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje vamos falar sobre um idioma interessante introduzido por Sean Parent (Adobe), uma figura bem conhecida na comunidade C ++. Ele costuma fazer apre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Polimorfismo baseado em conceito do C ++ no c√≥digo do produto: PassManager no LLVM</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/samsung/blog/505850/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hoje vamos falar sobre um idioma interessante introduzido por Sean Parent (Adobe), uma figura bem conhecida na comunidade C ++. </font><font style="vertical-align: inherit;">Ele costuma fazer apresenta√ß√µes e publica uma s√©rie de artigos da Better Code. </font><font style="vertical-align: inherit;">Uma de suas id√©ias que o Photoshop usa √© o polimorfismo baseado em conceito. </font><font style="vertical-align: inherit;">√â quando implementamos o polimorfismo n√£o por heran√ßa expl√≠cita, mas usando uma t√©cnica que inclui programa√ß√£o generalizada e, como resultado, obtemos algumas vantagens adicionais. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O artigo est√° organizado da seguinte forma:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que √© polimorfismo baseado em conceito e por que √© necess√°rio?</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um pouco sobre o LLVM e seu dispositivo</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo de polimorfismo baseado em conceito no LLVM PassManager</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vantagens da abordagem</font></font><br>
</li>
</ol><br>
<br>
<img src="https://habrastorage.org/webt/hg/ru/az/hgruazi6vbztkex50vkgdcfgknw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma figura ilustrando a tese "A heran√ßa √© m√°". </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonte</font></font></a></i><br>
<a name="habracut"></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que √© polimorfismo baseado em conceito e por que √© necess√°rio?</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No C ++, o polimorfismo din√¢mico √© implementado usando fun√ß√µes e heran√ßa virtuais e o polimorfismo est√°tico usando padr√µes. </font><font style="vertical-align: inherit;">Aqui, combinamos essas duas abordagens e tiramos o melhor delas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O uso expl√≠cito da heran√ßa geralmente leva √† conectividade excessiva do c√≥digo e √† viola√ß√£o do princ√≠pio da separa√ß√£o de interface ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Como implementar o polimorfismo din√¢mico sem essas desvantagens? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sean Parent prop√¥s um idioma chamado polimorfismo baseado em conceito, em que a heran√ßa √© impl√≠cita e oculta ao usu√°rio. </font><font style="vertical-align: inherit;">Voc√™ pode aprender mais sobre isso no relat√≥rio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inheritance Is The Base Class Of Evil</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - onde ele mostra toda a id√©ia usando o Photoshop e o hist√≥rico de a√ß√µes como exemplo - voc√™ aprender√° como o "pincel hist√≥rico" realmente funciona.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um pouco sobre o LLVM e seu dispositivo</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu gostaria de mostrar as vantagens desse idioma usando o exemplo do LLVM. </font><font style="vertical-align: inherit;">Quem n√£o sabe, o LLVM √© uma infraestrutura para o desenvolvimento de compiladores. </font><font style="vertical-align: inherit;">Abaixo est√° uma arquitetura LLVM de n√≠vel muito alto, que abrange apenas as entidades usadas posteriormente neste artigo. </font><font style="vertical-align: inherit;">Para mais informa√ß√µes, consulte a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documenta√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oficial </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eu/zw/wa/euzwwalazlbmv9kqy8mzbrv95hw.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa √© a arquitetura do LLVM e, em princ√≠pio, de qualquer compilador moderno.As</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
partes principais s√£o as seguintes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Front End pega o c√≥digo fonte do programa e o transforma em uma representa√ß√£o intermedi√°ria (IR). </font><font style="vertical-align: inherit;">Isso simplifica o trabalho do restante do compilador para que ele n√£o lide com c√≥digo C ++ complexo.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Middle End - um conjunto de otimiza√ß√µes, an√°lises e transforma√ß√µes. </font><font style="vertical-align: inherit;">Na sua forma mais geral, √© um conjunto de passes (passes). </font><font style="vertical-align: inherit;">Todos os passes s√£o registrados e lan√ßados por um componente especial chamado PassManager.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Back-end gera diretamente o c√≥digo de destino.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O compilador apresenta o programa na forma de v√°rias entidades b√°sicas. </font><font style="vertical-align: inherit;">Este √© um m√≥dulo (arquivo .cpp condicional), uma fun√ß√£o, uma unidade base que cont√©m um conjunto de instru√ß√µes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ig/vi/0i/igvi0icjbjtgmhbfvdwvvtbyy0c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O LLVM agora tem duas vers√µes do PassManager:&nbsp;</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LegacyPassManager, ele usa o polimorfismo cl√°ssico baseado em heran√ßa em tempo de execu√ß√£o. </font><font style="vertical-align: inherit;">A hierarquia de heran√ßa inclui passes executados em um m√≥dulo, fun√ß√£o, loop, etc.&nbsp;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PassManager - uma nova vers√£o, apenas baseada no polimorfismo baseado em conceito, prop√µe-se substituir o LegacyPassManager. </font><font style="vertical-align: inherit;">Ambas as vers√µes existem em paralelo e se desenvolvem independentemente.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A id√©ia do artigo √© demonstrar o conceito do c√≥digo real do produto, implementado de duas maneiras diferentes, e mostrar as vantagens da √∫ltima abordagem.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo de polimorfismo baseado em conceito no LLVM PassManager</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conforme implementado no Legado</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, como tudo √© organizado de maneira cl√°ssica, no LegacyPassManager. </font><font style="vertical-align: inherit;">Digamos que temos uma classe PassManager e h√° uma classe Pass - um passe. </font><font style="vertical-align: inherit;">Temos uma hierarquia: ModulePass, da qual nossa classe herda, por exemplo, Propaga√ß√£o Constante. </font><font style="vertical-align: inherit;">Existe um m√©todo runOnModule, aqui √© virtual. </font><font style="vertical-align: inherit;">Portanto, temos o polimorfismo de tempo de execu√ß√£o usual:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/// ModulePass class - This class is used to implement unstructured</span>
<span class="hljs-comment">/// interprocedural optimizations and analyses. ModulePasses may do anything</span>
<span class="hljs-comment">/// they want to the program.</span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModulePass</span> :</span> <span class="hljs-keyword">public</span> Pass {<font></font>
...<font></font>
<span class="hljs-comment">/// runOnModule - Virtual method overriden by subclasses to process the module</span>
<span class="hljs-comment">/// being operated on.</span>
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/// IPCP - The interprocedural constant propagation pass</span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IPCP</span> :</span> <span class="hljs-keyword">public</span> ModulePass {<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> <span class="hljs-keyword">override</span></span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos o c√≥digo, qual √© o problema aqui? Vemos que nessa hierarquia, os m√©todos para iniciar uma passagem s√£o diferentes, dependendo do que devem ser executados (em uma fun√ß√£o - runOnFunction, um m√≥dulo - runOnModule, um ciclo - runOnLoop, etc.). Por sua vez, isso torna imposs√≠vel processar a coleta de passes que funcionam com diferentes entidades de RI de uma √∫nica maneira (na verdade, aplique polimorfismo). Parece, obviamente, como faz√™-lo corretamente: voc√™ precisa de um m√©todo de execu√ß√£o virtual, que ser√° redefinido nos herdeiros. Mas surge um problema: os m√©todos de execu√ß√£o nas classes sucessoras ter√£o uma assinatura diferente, porque o par√¢metro sempre √© passado de seu tipo - fun√ß√£o, m√≥dulo e assim por diante. Portanto, voc√™ deve criar uma classe base fict√≠cia para Module, Function, etc., passar um ponteiro para essa classe em execu√ß√£o e fazer a convers√£o para dentro do m√©todo,dependendo do tipo de objeto localizado nesse ponteiro. E algo estranho come√ßa: quando uma nova entidade subordinada aparece, agora somos for√ßados a reescrever o c√≥digo superior a cada vez, o que contradiz todos os princ√≠pios de design.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ pode escrever manualmente uma classe de adaptador para cada caso. </font><font style="vertical-align: inherit;">Mas essa √© uma id√©ia longa e desinteressante e, de fato, estranha para escrever classes de wrapper para a opera√ß√£o conveniente de apenas servir componentes. </font><font style="vertical-align: inherit;">Seria melhor gerar esse c√≥digo automaticamente usando modelos. </font><font style="vertical-align: inherit;">√â exatamente isso que se prop√µe a ser abordado na abordagem em discuss√£o. </font><font style="vertical-align: inherit;">Al√©m disso, como voc√™ ver√° mais adiante, teremos algumas consequ√™ncias mais √∫teis.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como sugerido na nova vers√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O seguinte acontece no novo PassManager. </font><font style="vertical-align: inherit;">O conceito de um objeto polim√≥rfico √© generalizado da seguinte forma. </font><font style="vertical-align: inherit;">Dizemos que se um objeto implementa algum m√©todo, introduzimos um conjunto de m√©todos que queremos ser polim√≥rficos e dizemos que todas as classes que implementam esse m√©todo s√£o polim√≥rficas, ou seja, podemos us√°-las em contextos intercambi√°veis ‚Äã‚Äãem esse √© o PassManager. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere a classe PassManager no LLVM. </font><font style="vertical-align: inherit;">Aqui est√° uma vers√£o simplificada, e a vers√£o completa pode ser encontrada em llvm / include / llvm / IR / PassManager.h. </font><font style="vertical-align: inherit;">O par√¢metro do modelo de IR se especializa diretamente na entidade pela qual estamos passando (a fun√ß√£o de execu√ß√£o). </font><font style="vertical-align: inherit;">Pode ser um m√≥dulo, fun√ß√£o ou ciclo. </font><font style="vertical-align: inherit;">Analisamos o c√≥digo, mais explica√ß√µes ser√£o:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassManager</span> {</span>
<span class="hljs-keyword">public</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; Pass : Passes) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pass-&gt;run(graph, args...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PassT&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addPass</span><span class="hljs-params">(PassT Pass)</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passes.emplace_back(<span class="hljs-keyword">new</span> detail::PassModel&lt;IR, PassT, ArgTs...&gt;(<span class="hljs-built_in">std</span>::move(Pass)));<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;detail::PassConcept&lt;IR, ArgTs...&gt;&gt;&gt; Passes;<font></font>
<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos as seguintes entidades b√°sicas:</font></font><br>
<br>
<ul>
<li> run     ,        run<br>
</li>
<li> addPass     (      )    PassT<br>
</li>
<li> Passes ‚Äî ,      .         ,       ,        type erasure,     <br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, que tipo de tipo deveria ser esse? </font><font style="vertical-align: inherit;">O que √© armazenado no vetor Passes? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, vamos ver o que PassModel e PassConcept s√£o. </font><font style="vertical-align: inherit;">Essas s√£o classes auxiliares internas ao PassManager. </font><font style="vertical-align: inherit;">Ambos est√£o no namespace de detalhes. </font><font style="vertical-align: inherit;">Primeiro, vamos ver como √© a classe PassConcept. </font><font style="vertical-align: inherit;">Ele cont√©m o mesmo m√©todo de execu√ß√£o novamente, aqui √© um m√©todo puramente virtual.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> detail {<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassConcept</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">virtual</span> ~PassConcept() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> </span>= <span class="hljs-number">0</span>;<font></font>
<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A segunda classe, PassModel, tamb√©m √© padr√£o. </font><font style="vertical-align: inherit;">√â herdado do PassConcept.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span> PassT, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassModel</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> PassConcept&lt;IR, ArgTs...&gt; {
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">PassModel</span><span class="hljs-params">(PassT Pass)</span> : <span class="hljs-title">pass_</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::move(pass))</span> </span>{}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> <span class="hljs-keyword">final</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass_.run(ir, args...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PassT pass_;<font></font>
<font></font>
};<font></font>
<font></font>
} <span class="hljs-comment">// end namespace detail</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que cont√©m:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Campo privado pass_ do tipo PassT</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um construtor que aceita um objeto do tipo PassT como uma entrada. </font><font style="vertical-align: inherit;">N√£o faz nada intrigante, apenas inicializa o passe_ usando a sem√¢ntica do movimento</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O m√©todo run, que simplesmente chama o m√©todo run on pass. </font><font style="vertical-align: inherit;">Passando, respectivamente, todos os argumentos que possam estar l√°.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembramos agora onde come√ßamos. Por sua vez, o PassManager armazena todas essas passagens. No vetor Passes dos elementos do tipo PassConcept. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, o quadro geral. Criado por PassManager. Usando o AddPass, ele registra as passagens que queremos fazer sobre o m√≥dulo, fun√ß√£o, loop, etc. Por exemplo, em linha, propaga√ß√£o constante, desenrolamento de loop, etc. Eles pr√≥prios n√£o s√£o herdados de ningu√©m, eles devem ter apenas um m√©todo de execu√ß√£o. E apenas esse conceito inteiro fornece isso. Qu√£o?&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que tenhamos otimiza√ß√£o embutida. Adicionamos um objeto do tipo Inline ao addPass. Assim, em Passes, no vetor, colocamos esse Inline, j√° na forma de PassConcept. Como podemos fazer isso? Inline n√£o √© herdado da classe PassConcept. Como colocamos um elemento em um vetor? N√£o podemos fazer a transmiss√£o para o tipo base (upcasting) porque n√£o h√° heran√ßa.E aqui √© feito um truque. Temos essa classe auxiliar PassConcept que define a interface. Ele diz que todos os seus descendentes devem implementar o m√©todo run. Temos o PassModel, que por sua vez √© padronizado. E assim, quando colocamos Inline, esse PassModel √© instanciado com esse tipo Inline, esse objeto √© compilado dentro dessa classe. O pr√≥prio PassModel redefine a execu√ß√£o, que por si s√≥ j√° chama de execu√ß√£o para esta passagem,ou seja, executado a partir da classe Inline. Tudo isso √© resolvido em tempo de compila√ß√£o: se o Inline n√£o definir o m√©todo de execu√ß√£o, teremos um erro em tempo de compila√ß√£o.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, esse polimorfismo √© alcan√ßado sem heran√ßa. A quest√£o pode surgir: como n√£o √© heran√ßa, porque aqui est√°, o PassModel √© herdado do PassConcept? Resposta: existe heran√ßa, mas √© interna, n√£o se destaca, o usu√°rio n√£o sabe nada sobre isso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√≥s falamos em um n√≠vel conceitual. Aqui temos um usu√°rio, ele deseja substituir um determinado m√©todo. Ao mesmo tempo, ele n√£o quer ser herdado, para n√£o extrair depend√™ncias extras de si mesmo. Como fazer isso? Dentro de n√≥s mesmos, atrav√©s de PassConcept, PassModel, criamos polimorfismo de tempo de execu√ß√£o, atrav√©s de heran√ßa, mas o usu√°rio n√£o sabe sobre isso: esses s√£o todos os interiores dessas duas classes, eles s√£o definidos em seu espa√ßo de nome.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais uma vez, como isso √© alcan√ßado? </font><font style="vertical-align: inherit;">Eu tenho uma classe, vamos cham√°-lo, seja Inline, em termos do compilador. </font><font style="vertical-align: inherit;">N√≥s adicionamos Inline ao vetor, respectivamente, criamos o objeto PassModel. </font><font style="vertical-align: inherit;">Ele tem um construtor que recebe o objeto desse par√¢metro de modelo. </font><font style="vertical-align: inherit;">E assim, quando chamamos o m√©todo run no PassManager, ele percorre todas as passagens; nesse caso, temos apenas uma passagem, o tipo Inline. </font><font style="vertical-align: inherit;">Ele chama o m√©todo runC do PassConcept. </font><font style="vertical-align: inherit;">O mesmo m√©todo de execu√ß√£o que est√° dentro do PassModel, que √© instanciado pelo tipo Inline. </font><font style="vertical-align: inherit;">E esse m√©todo j√° chama o m√©todo run na passagem registrada, neste caso, Inline e, como resultado, a execu√ß√£o no Inline √© chamada.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vantagens da abordagem</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Foi assim que fizemos um comportamento diferente sem usar explicitamente a heran√ßa. Agora n√£o temos a depend√™ncia expl√≠cita que existia anteriormente no LegacyPassManager.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que coisa recursiva incomum acontece. Podemos usar polimorfismo para qualquer objeto que substitua o m√©todo run. Como o m√©todo run substitui o PassManager, ele pode se registrar, ou seja, incorporar-se ao vetor Passes pass e se chamar novamente.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acontece que podemos misturar tudo. O antigo PassManager, que √© Legacy, tem uma separa√ß√£o clara. H√° otimiza√ß√£o modular, que √© feita no m√≥dulo; h√° otimiza√ß√£o que acontece na fun√ß√£o. E aqui tudo acontece sem problemas. N√≥s criamos o PassManager, instanciamos com o tipo ‚ÄúModule‚Äù, colocamos Inline nele, algo mais, algumas outras otimiza√ß√µes modulares. Em seguida, o segundo PassManager, instanciamos com o tipo "Function", colocamos otimiza√ß√µes na fun√ß√£o. E ent√£o, no PassManager, que √© instanciado pelo m√≥dulo, voc√™ pode colocar outro PassManager, que √© instanciado pela fun√ß√£o, atrav√©s desse vetor Passes.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs">PassManager&lt;Module&gt; MPM;
<span class="hljs-comment">// ... register passes on module</span><font></font>
MPM.addPass(GlobalDCEPass())<font></font>
MPM.addPass(PGOInstrumentationGen());<font></font>
<span class="hljs-comment">//... register passes on function</span><font></font>
PassManager&lt;Function&gt; FPM;&nbsp;<font></font>
FPM.addPass(CallSiteSplittingPass());<font></font>
<span class="hljs-comment">//... register all registered passes on function in module pass manager MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tem tempo a seguir? Temos dois PassManagers. Um com o tipo IR Module, o outro com o tipo IR Function. Digamos que no m√≥dulo, j√° colocamos algumas passagens. Agora queremos mistur√°-los com passes executados em uma fun√ß√£o. O que estamos fazendo? Chamamos addPass e passamos o PassManager como Pass, que √© instanciado com o tipo de IR "Function" (no c√≥digo real, n√£o √© o PassManager que √© colocado l√°, mas uma classe especial que o envolve, mas no n√≠vel conceitual isso n√£o importa).&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, podemos misturar diferentes n√≠veis de otimiza√ß√£o - gra√ßas ao aninhamento de PassManagers, executamos alternadamente passes para o m√≥dulo, fun√ß√£o, ciclo, etc. </font><font style="vertical-align: inherit;">No Legacy PassManager, isso √© mais complicado, existe uma classe separada para m√≥dulos que possuem uma fun√ß√£o virtual runOnModule, uma classe separada para fun√ß√µes com um m√©todo virtual runOnFunction, etc. </font><font style="vertical-align: inherit;">Ambas as classes s√£o herdadas do ancestral comum do Pass, mas s√£o independentes e t√™m uma interface diferente, o que torna o uso do LegacyPassManager inconveniente para chamar passes em diferentes entidades de IR (m√≥dulo, fun√ß√£o, loop) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.</font></font><br>
&nbsp;<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM para Alunos de Gradua√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Uma Introdu√ß√£o Simples ao LLVM</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apresenta√ß√£o de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chandler Carrut sobre como s√£o organizados os passes LLVM</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apresenta√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chandler Carruth sobre detalhes da implementa√ß√£o PassManager</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um encadeamento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na lista de discuss√£o que discute a diferen√ßa entre LegacyPassManager e PassManager</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autores: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/73/et/tp/73ettpg9jylifuwfvohspok-nv4.png" align="left"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roman Rusyaev, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Engenheiro Especialista da </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Equipe de Compiladores AI do </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instituto de P&amp;D da Samsung, R√∫ssia </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em breve, Roman falar√° na confer√™ncia C ++ R√∫ssia 2020 em Moscou com Anton Polukhin: l√° eles falar√£o sobre a elis√£o atual e futura da c√≥pia: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link para o relat√≥rio</font></font></a><br>
<br clear="all">
<img src="https://habrastorage.org/webt/ay/fa/a2/ayfaa2i4aukgor-uh5ija7gstie.png" align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tatyana Volkova, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lead Specialist </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Business Equipe de desenvolvimento </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Samsung R&amp;D Institute, R√∫ssia</font></font></i><br>
<br clear="all"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt505824/index.html">Guia: sua pr√≥pria VPN L2TP</a></li>
<li><a href="../pt505826/index.html">Como obter 100% de vis√£o e ainda mais</a></li>
<li><a href="../pt505834/index.html">Amostras medianas. Intervalos de confian√ßa e compara√ß√£o</a></li>
<li><a href="../pt505838/index.html">Tecnologia FPGA para milhares de aplica√ß√µes</a></li>
<li><a href="../pt505846/index.html">Quais s√£o os verdadeiros problemas de matem√°tica no desenvolvimento de vacinas do COVID-19?</a></li>
<li><a href="../pt505856/index.html">Da Brute-Force √† tentativa de privacidade - o que os provedores de SaaS enfrentam</a></li>
<li><a href="../pt505860/index.html">Spring Boot, Hibernate e Kotlin para iniciantes passo a passo</a></li>
<li><a href="../pt505870/index.html">Como promover jogos e aplicativos para celular no Jap√£o, Cor√©ia e China</a></li>
<li><a href="../pt505872/index.html">Hist√≥ria de ve√≠culos n√£o tripulados</a></li>
<li><a href="../pt505880/index.html">Como escrever seu √≠ndice no Tarantool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>