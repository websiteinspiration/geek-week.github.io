<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛 ♑️ 🤱🏿 IoT、フォグ、クラウド：テクノロジーについて話しますか？ 🔤 🔅 👨🏽‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=", (IoT). , . , , .
 
 . (Fog) , IoT. 
 
 クラウドはほとんどのIoTリクエストを閉じることができます。たとえば、監視サービス、デバイスによって生成された任意の量のデータの高速処理、およびそれらの視覚化を提供するために。ミスティコンピューティングは、リアルタイム...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>IoT、フォグ、クラウド：テクノロジーについて話しますか？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/cloud4y/blog/467711/"><img src="https://habrastorage.org/webt/e-/-2/xi/e--2xiob3rxaedvmvmjlklvkvoo.png"><br>
<br>
<i>      ,          (IoT).      ,      .       ,  ,     .<br>
<br>
      .         (Fog)    ,     IoT. </i><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラウドはほとんどのIoTリクエストを閉じることができます。たとえば、監視サービス、デバイスによって生成された任意の量のデータの高速処理、およびそれらの視覚化を提供するために。ミスティコンピューティングは、リアルタイムの問題を解決するのにより効果的です。リクエストへの迅速な応答とデータ処理の最小遅延を提供します。つまり、フォグは「クラウド」を完全に補完し、その機能を拡張します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、主な質問は異なります：これはすべて、IoTのコンテキストでどのように相互作用する必要がありますか？ IoT-Fog-Cloud統合システムで作業する場合、どの通信プロトコルが最も効果的ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP、IoT、Fog、Cloudの優位性は明らかですが、他の多数のソリューションを使用しています。</font><font style="vertical-align: inherit;">これは、IoTがさまざまなデバイスセンサーの機能を、ユーザーのセキュリティ、相互運用性、およびその他の要件と組み合わせる必要があるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここに参照アーキテクチャの単一のアイデアがありますが、通信標準は単にそこにはありません。</font><font style="vertical-align: inherit;">したがって、特定のIoTタスク用の新しいプロトコルの作成または既存のプロトコルの改良は、ITコミュニティが直面する最も重要なタスクの1つです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在使用されているプロトコルとそれらが提供できるものは何ですか？</font><font style="vertical-align: inherit;">それを正しくしましょう。</font><font style="vertical-align: inherit;">しかし、最初に、雲、霧、物事のインターネットが相互作用するエコシステムの原理について説明しましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IoT Fog-to-Cloudアーキテクチャ（F2C）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IoT、クラウド、フォグを合理的かつ調整された方法で管理することの利点と利点を探求するためにどれほどの労力が費やされたかに気づいたはずです。そうでない場合、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenFogコンソーシアム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エッジコンピューティングコンソーシアム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mF2C H2020 EUプロジェクトの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3つの標準化イニシアチブがすでに存在します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は2つのレベル、クラウドとエンドデバイスしか考慮されていなかった場合、提案されたアーキテクチャは新しいレベル、つまりフォグコンピューティングを導入します。この場合、フォグレベルは、リソースの詳細またはこれらのサブレベルでのさまざまなデバイスの使用を決定する一連のポリシーに応じて、いくつかのサブレベルに分割できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この抽象化はどのように見えるでしょうか？これが典型的なIoT-Fog-Cloudエコシステムです。 IoTデバイスはデータをより強力なサーバーとコンピューティングデバイスに送信して、低レイテンシを必要とするタスクを解決します。同じシステムで、クラウドは、大量のコンピューティングリソースまたはストレージスペースを必要とする問題の解決を担当します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b1/cr/tf/b1crtfzorujkb5afwoq2m-uwlua.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スマートフォン、スマートウォッチ、その他のガジェットもIoTの一部にすることができます。しかし、そのようなデバイスは、原則として、大規模な開発者からの独自の通信プロトコルを使用します。生成されたIoTデータはHTTP RESTプロトコルを介してフォグレベルに送信されます。これにより、RESTfulサービスの作成時に柔軟性と相互運用性が提供されます。これは、ローカルコンピューター、サーバー、またはサーバークラスターで実行されている既存のコンピューティングインフラストラクチャとの下位互換性の必要性に照らして重要です。 「霧のノード」と呼ばれるローカルリソースは、受信したデータをフィルタリングしてローカルで処理するか、クラウドに送信してさらに計算します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラウドはさまざまな通信プロトコルをサポートしており、AMQPとREST HTTPが最もよく見られます。 HTTPはインターネットでよく知られており、投獄されているため、「IoTとフォグを使用するにはHTTPを使用する必要がありますか？」という疑問が生じる場合があります。ただし、このプロトコルにはパフォーマンスの問題があります。これについては後で詳しく説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、必要なシステムに適した通信プロトコルには2つのモデルがあります。これは、リクエスト/レスポンスおよびパブリケーションサブスクリプションです。最初のモデルは、特にサーバー/クライアントアーキテクチャーで広く知られています。クライアントはサーバーに情報を要求し、要求を受信して​​処理し、応答メッセージを返します。 REST HTTPおよびCoAPプロトコルはこのモデルで機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のモデルは、データを生成するソースとこのデータの受信者との間に非同期の分散された弱い通信を提供する必要があるために生じました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jo/uh/ze/jouhzen4ifrik_e1pqtb9gtwtxa.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルには、パブリッシャー（データソース）、ブローカー（ディスパッチャー）、サブスクライバー（受信者）の3人の参加者が含まれます。ここで、サブスクライバーとして機能するクライアントは、サーバーに情報を要求しないでください。リクエストを送信する代わりに、すべての着信メッセージをフィルタリングしてパブリッシャーとサブスクライバー間でルーティングするブローカーを介して、システムの特定のイベントにサブスクライブします。そしてパブリッシャーは、特定のトピックに関するイベントが発生すると、それをブローカーにパブリッシュし、ブローカーは要求されたトピックに関するサブスクライバーデータを送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本質的に、このアーキテクチャはイベント駆動型です。</font><font style="vertical-align: inherit;">また、この相互作用モデルは、スケーラビリティを提供し、さまざまなデバイス間の相互接続を簡素化して、動的な多対多通信と非同期通信をサポートできるため、IoT、クラウド、フォグのアプリケーションにとって興味深いものです。</font><font style="vertical-align: inherit;">パブリッシュ/サブスクライブモデルを使用する最も有名な標準化されたメッセージングプロトコルには、MQTT、AMQP、およびDDSがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、パブリケーション-サブスクリプションモデルには多くの利点があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パブリッシャーとサブスクライバーは、お互いの存在を知る必要はありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1人のサブスクライバーは多くの異なるパブリケーションから情報を受け取ることができ、1人のパブリッシャーは多くの異なるサブスクライバーにデータを送信できます（多対多の原則）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブローカー（キューシステムとして機能）は、現在ネットワークに接続されていないクライアントへのメッセージを格納できるため、パブリッシャーとサブスクライバーは、データ交換のために同時にアクティブである必要はありません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、要求/応答モデルにも独自の長所があります。</font><font style="vertical-align: inherit;">複数のクライアントのリクエストを処理するサーバー側の機能に問題がない場合は、すでに実績のある信頼できるソリューションを使用することは理にかなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
両方のモデルをサポートするプロトコルもあります。</font><font style="vertical-align: inherit;">たとえば、サーバープッシュオプションをサポートするXMPPおよびHTTP 2.0。</font><font style="vertical-align: inherit;">IETFはCoAPもリリースしました。</font><font style="vertical-align: inherit;">メッセージングの問題を解決するために、WebSocketsプロトコルや、QUIC（Quick UDP Internet Connections）を介したHTTPプロトコルの使用など、他のいくつかのソリューションが作成されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WebSocketの場合、サーバーからWebクライアントへのリアルタイムのデータ転送に使用され、双方向の同時通信による常時接続を提供しますが、コンピューティングリソースが限られているデバイスを対象としたものではありません。</font><font style="vertical-align: inherit;">新しいトランスポートプロトコルは多くの新しい機会を提供するため、QUICにも注目に値します。</font><font style="vertical-align: inherit;">しかし、QUICはまだ標準化されていないため、可能なアプリケーションとIoTソリューションへの影響を予測するのは時期尚早です。</font><font style="vertical-align: inherit;">したがって、将来を見据えてWebSocketsとQUICをメモリに残しますが、これ以上の詳細については学習しません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">世界で最も甘い人：プロトコルを比較する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、プロトコルの長所と短所について説明します。今後は、明確なリーダーがいないことを直ちに確認します。各プロトコルにはいくつかの長所/短所があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">応答時間</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
特にモノのインターネットに関して、通信プロトコルの最も重要な特性の1つは応答時間です。しかし、既存のプロトコルの中には、さまざまな条件で作業する場合の最小レベルの遅延を示す目立つものはありません。しかし、プロトコル機能の研究と比較はたくさんあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、</font><font style="vertical-align: inherit;">IoTを使用した場合のHTTPとMQTTの有効性</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比較し</font><font style="vertical-align: inherit;">た</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">結果</font></a><font style="vertical-align: inherit;">、MQTTからのリクエストの応答時間はHTTPの応答時間よりも短いことがわかりました。そして</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">勉強する</font></a><font style="vertical-align: inherit;">とき</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MQTTとCoAPの送受信（RTT）時間では、平均RTT CoAPはMQTTのそれよりも20％少ないことがわかりました。</font><font style="vertical-align: inherit;">MQTTおよびCoAPプロトコルのRTTを使用した</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実験</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、ローカルネットワークとIoTネットワークの2つのシナリオで実行されました。 IoTネットワークでは、平均RTTが2〜3倍高いことがわかりました。 QoS0を使用したMQTTはCoAPと比較して低い結果を示し、QoS1を使用したMQTTは、アプリケーションおよびトランスポートレベルでのACKにより、より高いRTTを示しました。異なるQoSレベルでは、MQTTの輻輳のないネットワーク遅延はミリ秒であり、CoAPの場合、数百マイクロ秒でした。ただし、信頼性の低いネットワークで作業している場合、TCP上で実行されているMQTTは異なる結果を表示することを覚えておく価値があります。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比較</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ペイロードを増やすことによるAMQPおよびMQTTプロトコルの応答時間は、負荷が小さい場合の遅延レベルがほぼ同じであることを示しています。ただし、大量のデータを送信する場合、MQTTは応答時間が短くなります。別の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">研究では、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガスセンサー、気象センサー、位置情報（GPS）、モバイルネットワークインターフェース（GPRS）を搭載した車両の上にデバイスを配置したマシン間通信シナリオで</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、</font></a><font style="vertical-align: inherit;"> CoAPをHTTPと比較しました。モバイルネットワーク経由でCoAPメッセージを送信するのにかかる時間は、HTTPメッセージを使用するのにかかる時間のほぼ3分の1でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つではなく3つのプロトコルを比較する研究が行われました。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比較</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワークエミュレーターを使用した医療アプリケーションシナリオでのIoTプロトコルMQTT、DDS、およびCoAPのパフォーマンス。 DDSは、さまざまな劣悪なネットワーク条件での経験豊富なテレメトリレイテンシの点でMQTTを上回りました。 UDPベースのCoAPは、高速応答を必要とするアプリケーションに適していますが、UDPベースであるため、予期しない大きなパケット損失がありました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">帯域幅の</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比較</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">帯域幅使用率に関するMQTTとCoAPは、メッセージごとに送信されるデータの総量の計算として実行されました。 CoAPは、小さなメッセージを送信するときにMQTTよりも少ない帯域幅を示しました。しかし、プロトコルの有効性を、送信された総バイト数に対する有用な情報のバイト数の比率で比較すると、CoAPの方が効果的でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MQTT、DDS帯域幅（TCPをトランスポートプロトコルとして使用）、およびCoAPを使用すると、CoTTは比較的低い帯域幅消費を示す傾向があり、MQTTとは異なり、ネットワークパケット損失の増加やネットワーク遅延の増加では増加しませんでした。 DDS。前述のシナリオでは、チャネル容量の使用が増加しました。別のシナリオでは、同時にデータを送信する多数のデバイスが関与しましたが、これはIoT環境の典型的なケースです。結果は、負荷が高い場合はCoAPを使用する方がよいことを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
負荷が軽い場合、CoAPは最小の帯域幅を使用し、次にMQTTおよびHTTP RESTを使用しました。ただし、ペイロードサイズが大きくなると、REST HTTPが最良の結果を出しました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エネルギー</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
消費</font><b><font style="vertical-align: inherit;">エネルギー</font></b><font style="vertical-align: inherit;">消費の問題は常に、特にIoTシステムでは非常に重要です。</font><font style="vertical-align: inherit;">MQTTとHTTPの消費電力</font><font style="vertical-align: inherit;">を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比較する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、HTTPの方がはるかに「消費」します。また、CoAPは</font><font style="vertical-align: inherit;">MQTTよりも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エネルギー効率が</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高く、電力を管理できます。さらに、単純なシナリオでは、特に電力に制限がない場合、MQTTはモノのインターネット上で情報を交換するのにより適しています。</font><font style="vertical-align: inherit;">モバイルまたは不安定なワイヤレスネットワークのテストベンチでAMQPとMQTTの機能を比較した</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実験では、MQTTの方がエネルギー効率が高い一方で、AMQPがより多くのセキュリティオプションを提供することが示されました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全性</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セキュリティは、モノのインターネットと霧/クラウドコンピューティングのトピックを研究するときに発生するもう1つの重要な問題です。セキュリティメカニズムは通常、HTTP、MQTT、AMQP、XMPPのTLS、CoAPのDTLSに基づいており、DDSの両方のバージョンもサポートしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TLSとDTLSは、サポートされている暗号スイートとキーを交換するために、クライアント側とサーバー側の間の接続を確立するプロセスから始まります。両者はキットを交渉して、安全なチャネルでさらに通信が行われるようにします。 2つの違いは、UDPベースのDTLSが信頼できない接続で機能できるようにする小さな変更にあります。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">テスト攻撃</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
中</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLSとDTLSのいくつかの異なる実装では、TLSの方が優れていることがわかりました。エラーに対する耐性があるため、DTLSへの攻撃はより成功しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これらのプロトコルの最大の問題は、元々はIoTで使用するように設計されておらず、霧やクラウドでの作業が含まれていないことです。調整されたハンドシェイクにより、接続ごとにトラフィックを増やし、コンピューティングリソースを使い果たします。セキュリティレベルのない通信と比較して、ワークロードでは平均でTLSが6.5％、DTLSが11％増加しています。通常は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラウド</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベースの</font><font style="vertical-align: inherit;">リソースが豊富な環境では</font><font style="vertical-align: inherit;">、これは問題になりませんが、これはIoTとフォグレベルの間の重要な制限になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何を選ぶ？</font><font style="vertical-align: inherit;">明確な答えはありません。</font><font style="vertical-align: inherit;">MQTTとHTTPは、他のプロトコルと比較してIoT向けの比較的成熟した安定したソリューションと見なされているため、最も有望なプロトコルのようです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニファイドコミュニケーションプロトコルソリューション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単一プロトコルソリューションの実践には多くの欠点があります。たとえば、制限された環境を満たすプロトコルは、セキュリティ要件が厳しいドメインでは機能しない可能性があります。これを念頭に置いて、MQTTとREST HTTPを除いて、IoTのFog-to-Cloudエコシステムの1つのプロトコルに基づくほとんどすべての可能なソリューションを破棄する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一プロトコルソリューションとしてのREST HTTP</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
IoT-to-Fog REST HTTP要求と応答の相互作用の良い例：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インテリジェントファームがあり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。動物にはウェアラブルセンサー（IoTクライアント、C）が装備され、クラウドコンピューティングを介してスマートファーミングシステム（フォグサーバー、S）によって制御されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
POSTメソッドのタイトルは、変更するリソース（/農場/動物）、およびHTTPバージョンとコンテンツタイプを示します。この場合、システムが管理する家畜農場（Dulcinea /牛）を表すJSONオブジェクトです。サーバーからの応答は、HTTPS 201（リソースが作成された）ステータスコードを送信することにより、リクエストが成功したことを示します。 GETメソッドは、リクエストされたリソースのみをURI（たとえば、/ farm / animals / 1）で示す必要があります。これにより、サーバーからこの識別子を持つ動物のJSON表現が返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PUTメソッドは、特定のリソースレコードを更新する必要がある場合に使用されます。この場合、URIは、変更するパラメーターと現在の値のリソースで示されます（たとえば、牛が現在歩いている、/農場/動物/ 1？状態=歩いていることを示します）。最後に、DELETEメソッドはGETメソッドと同様に使用されますが、操作の結果としてリソースを削除するだけです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一</font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/ur/72/0u/ur720umujcr7x5dqvpju9ri72vs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
プロトコル</font><b><font style="vertical-align: inherit;">ソリューションとしてのMQTT</font></b><font style="vertical-align: inherit;">同じスマートファームを見てみましょう。ただし、REST HTTPの代わりにMQTTプロトコルを使用します。 Mosquittoライブラリがインストールされているローカルサーバーは、ブローカーとして機能します。この例では、単純なコンピューター（ファームサーバーと呼ばれる）Raspberry PiがMQTTクライアントとして機能し、Mosquittoブローカーと完全に互換性のあるMQTT Pahoライブラリーのインストールを通じて実装されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクライアントは、検出機能とコンピューティング機能を備えたデバイスを表すIoT抽象化レイヤーに対応しています。一方、仲介者は、フォグのコンピューティングノードを表す、より高いレベルの抽象化に対応します。これは、データ処理とストレージの面で大容量を特徴としています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提案されたスマートファームシナリオでは、Raspberry Piが加速度計、GPS、および温度センサーに接続し、これらのセンサーからのデータをフォグノードに公開します。ご存じのとおり、MQTTはトピックを階層として扱います。 1人のMQTTパブリッシャーが特定のトピックセットに投稿できます。私たちの場合、3つあります。動物の納屋の温度を測定するセンサーの場合、クライアントはテーマ（動物農場/小屋/温度）を選択します。加速度計を介してGPSの位置と動物の動きを測定するセンサーの場合、クライアントは更新（動物ファーム/動物/ GPS）と（動物ファーム/動物/動き）を公開します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この情報はブローカーに送信され、ブローカーは、関心のある別のサブスクライバーが後で表示される場合に備えて、ローカルデータベースに一時的に保存できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
霧の中でMQTTブローカーとして機能し、MQTTクライアントとして機能するRaspberry Piがセンサーからデータを送信するローカルサーバーに加えて、クラウドレベルで別のMQTTブローカーが存在する場合があります。この場合、ローカルブローカーに送信された情報は、ローカルデータベースに一時的に保存したり、クラウドに送信したりできます。この状況の霧のMQTTブローカーは、すべてのデータをクラウドMQTTブローカーに関連付けるために使用されます。このアーキテクチャでは、モバイルアプリケーションユーザーを両方のブローカーにサブスクライブできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカーの1つ（クラウドなど）との接続に失敗した場合、エンドユーザーは別のブローカー（霧）から情報を受け取ります。</font><font style="vertical-align: inherit;">これは、フォグとクラウドコンピューティングシステムを組み合わせた機能です。</font><font style="vertical-align: inherit;">デフォルトでは、モバイルアプリケーションは、霧のMQTTブローカーへの最初の接続用に構成でき、障害が発生した場合は、クラウド内のMQTTブローカーに接続できます。</font><font style="vertical-align: inherit;">このソリューションは、IoT-F2Cシステムの多くの1つにすぎません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチプロトコルソリューション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルプロトコルソリューションは、実装が簡単なため人気があります。しかし、IoT-F2Cシステムでは、異なるプロトコルを組み合わせることが理にかなっていることは明らかです。ポイントは、異なるプロトコルが異なるレベルで機能できることです。たとえば、IoT、フォグ、クラウドコンピューティングの3つの抽象化を取り上げます。 IoTデバイスは一般に制限されていると見なされます。このレビューでは、IoTレベルを最も制限があり、クラウドが最も制限が少なく、霧の計算を「中間のどこか」と見なします。次に、IoTとフォグの抽象化の間で、現在のプロトコル決定にはMQTT、CoAP、およびXMPPが含まれることがわかります。一方、霧とクラウドの間では、AMQPはHTTP RESTとともに使用される主要なプロトコルの1つです。これは、その柔軟性により、IoTと霧のレイヤーの間でも使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの主な問題は、プロトコルの相互運用性と、あるプロトコルから別のプロトコルへのメッセージ変換の単純さです。理想的には、将来的には、クラウドとフォグのリソースを備えたIoTシステムのアーキテクチャは、使用される通信プロトコルに依存せず、異なるプロトコル間の優れた相互運用性を提供します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yl/p7/xr/ylp7xrpyjurp0kczobbyoia62jk.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現時点ではそうではないので、大きな違いのないプロトコルを組み合わせることは理にかなっています。このため、1つの解決策は、同じアーキテクチャスタイルであるREST HTTPとCoAPに準拠する2つのプロトコルの組み合わせに基づいています。別の提案されたソリューションは、パブリッシングとサブスクリプションの相互作用を提供する2つのプロトコル、MQTTとAMQPの組み合わせに基づいています。密接な概念（MQTTとAMQPの両方がブローカーを使用し、CoAPとHTTPがRESTを使用）を使用すると、これらの組み合わせの実装が簡素化され、統合の労力が少なくて済みます。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/8p/sf/nf/8psfnfqz8nru91-zhamwpurr8ce.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図（a）は、要求と応答に基づく2つのモデル、HTTPとCoAP、およびIoT-F2Cソリューションでの可能な配置を示しています。 HTTPは最新のネットワークで最もよく知られ、適応されているプロトコルの1つであるため、他のメッセージングプロトコルに完全に置き換わる可能性はほとんどありません。クラウドとフォグの間にある強力なデバイスを表すノードの中で、HTTP RESTはスマートソリューションです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、フォグレベルとIoTの間で通信するコンピューティングリソースが限られているデバイスの場合、CoAPを使用する方が効率的です。 CoAPの大きな利点の1つは、実際にはHTTPとの互換性です。これは、両方のプロトコルがRESTの原則に基づいているためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図（b）は、MQTTとAMQPを含む、1つのシナリオでの2つのパブリケーションとサブスクリプションの相互作用モデルを示しています。</font><font style="vertical-align: inherit;">仮説的には、抽象化の各レベルでノード間の通信に両方のプロトコルを使用できますが、それらの位置はパフォーマンスに基づいて決定する必要があります。</font><font style="vertical-align: inherit;">MQTTは、コンピューティングリソースが限られているデバイス用の簡略化されたプロトコルとして開発されたため、IoTとフォグ間の通信に使用できます。</font><font style="vertical-align: inherit;">AMQPは、霧と雲のノードの間に理想的に配置するより強力なデバイスに適しています。</font><font style="vertical-align: inherit;">IoTは軽量と見なされているため、MQTTの代わりにXMPPプロトコルを使用できます。</font><font style="vertical-align: inherit;">しかし、そのようなシナリオではそれほど広く使用されていません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検討されているプロトコルの1つで、限られたコンピューティングリソースのデバイスからクラウドサーバーまで、システム内のすべての通信をカバーするのに十分であるとは考えられません。この調査では、開発者がより頻繁に使用する2つの最も有望なオプションがMQTTとRESTful HTTPであることを示しています。これらの2つのプロトコルは、最も成熟していて安定しているだけでなく、十分に文書化され、成功した実装やオンラインリソースも多く含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MQTTは、その安定性とシンプルな構成により、限られたデバイスでIoTレベルで使用した場合に、その優れたパフォーマンスを証明してきたプロトコルです。限られた通信やバッテリーの消費が問題にならないシステムの一部、たとえば、霧やほとんどのクラウドコンピューティングの一部の領域では、RESTful HTTPが簡単に選択できます。 CoAPもIoTメッセージング標準として急速に発展しており、近い将来、MQTTやHTTPと同様の安定性と成熟度のレベルに到達する可能性があるため、CoAPも考慮する必要があります。しかし、この規格は現在開発中であり、短期的な互換性の問題に関連しています。</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Cloud4Y</font></a></b></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブログで他に読むと便利なもの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
→</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンピューターはあなたを美味しくします</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AIはアフリカの動物を研究するのに役立ちます</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">夏は</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">もう</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">終わりです。</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">データの漏洩はほとんどありません</font></a></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラウドでバックアップを保存する4つの方法</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人口情報を含む単一の連邦情報リソースについて</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別の記事を見逃さないよう</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Telegram</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャンネルに</font><font style="vertical-align: inherit;">登録して</font><font style="vertical-align: inherit;">ください！</font><font style="vertical-align: inherit;">執筆は週に2回以下で、業務上のみです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja467699/index.html">Visual Studio 2019 Communityで最速のstrlenを実行して欠陥を見つける方法</a></li>
<li><a href="../ja467701/index.html">ディレクトリではなくカテゴリ。ファイルを簡単に保存するためのツール</a></li>
<li><a href="../ja467703/index.html">ITアフリカ：大陸で最も興味深いテクノロジー企業とスタートアップ</a></li>
<li><a href="../ja467705/index.html">パラマグノンとマグノン：熱からのエネルギー</a></li>
<li><a href="../ja467707/index.html">GOSTアルゴリズムを使用してドメインに入るようにLinuxを構成する方法</a></li>
<li><a href="../ja467719/index.html">PostgreSQLでロック履歴を取得する1つの方法</a></li>
<li><a href="../ja467723/index.html">チェック・ポイント・ガイアR80.40。何が新しくなりますか？</a></li>
<li><a href="../ja467727/index.html">こんにちは、SaaS | ブリスフルによる2019 SaaSトレンド</a></li>
<li><a href="../ja467729/index.html">チップか乗るか？スマートフォンのユニークなささいなこと</a></li>
<li><a href="../ja467733/index.html">開発者として、私には自分自身の価値はありません。しかし、システム全体はあたかもあるかのように構築されています</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>