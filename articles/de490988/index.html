<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💀 🍋 👨‍🍳 Wir untersuchen Multicast-RxJS-Operatoren 👨🏽‍🎨 👩🏼‍🤝‍👨🏽 🚊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich präsentiere Ihnen die Übersetzung des Artikels "Grundlegendes zu RxJS-Multicast-Operatoren" von Netanel Basal. 
 
 Broadcast- oder Mul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wir untersuchen Multicast-RxJS-Operatoren</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490988/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font><font style="vertical-align: inherit;">Ich präsentiere Ihnen die Übersetzung des Artikels </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Grundlegendes zu RxJS-Multicast-Operatoren"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von Netanel Basal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Broadcast- oder Multicast-Betreiber scheinen oft das schwierigste Thema zu sein, um etwas über RxJS zu lernen. </font><font style="vertical-align: inherit;">In diesem Artikel werde ich versuchen, alles auf zugängliche Weise zu erklären. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden die interne Struktur von Multicast-Operatoren und die von ihnen gelösten Aufgaben berücksichtigen.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit der Beschreibung der Grundbausteine ​​von RxJS.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beobachtbar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In RxJS sind beobachtbare Objekte (im Folgenden als "Ströme" bezeichnet) anfangs kalt. Dies bedeutet, dass jedes Mal, wenn Sie einen Stream abonnieren, ein Rückruf des Abonnements durchgeführt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie zum besseren Verständnis die folgende Implementierung:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>{
  <span class="hljs-keyword">constructor</span>(subscriptionFn) {
    <span class="hljs-keyword">this</span>.subscriptionFn = subscriptionFn;<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.subscriptionFn(observer);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Konstruktor </font></font><code>Observable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akzeptiert einen einzelnen Parameter - den Rückruf des Abonnements </font></font><br>
 <code>subscriptionFn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es wird jedes Mal aufgerufen, wenn wir den Stream abonnieren ( </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal rufen sie auch einen Rückruf eines Abonnements auf </font></font><code>producer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da es auch Werte für den Abonnenten "erzeugt" (Beobachterobjekt in unserem Code). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Methode </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nimmt eine Eingabe entgegen </font></font><code>observer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es ist ein Objekt mit drei eigenen Methoden : </font></font><code>next(), error(), complete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In Live-RxJS können Sie anstelle eines Objekts drei Funktionen übergeben. </font><font style="vertical-align: inherit;">Wenn </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
die Methode </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aufgerufen wird, ruft sie die Abonnementfunktion auf und übergibt sie an die Eingabe </font></font><code>observer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben die Methode jetzt nicht erwähnt</font></font><code>unsubscribe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sollte jedoch beachtet werden, dass jedes Abonnement eine Möglichkeit bietet, es zu zerstören. </font><font style="vertical-align: inherit;">In den meisten Fällen gibt ein Abonnement eine Funktion (oder ein Objekt mit der entsprechenden Methode) zurück, bei der die Verbindung zwischen dem Stream und seinen Abonnenten zerstört wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles ziemlich einfach. </font><font style="vertical-align: inherit;">Kommen wir jetzt der Realität näher. </font><font style="vertical-align: inherit;">Wickeln Sie beispielsweise eine native XHR-API in einen Stream ein</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">http</span>(<span class="hljs-params">url</span>) </span>{
  <span class="hljs-comment">// This function will be called when we call http().subscribe()</span>
  <span class="hljs-keyword">const</span> subscriptionFn = <span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
    log(<span class="hljs-string">'Observable execution: http'</span>);
    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<font></font>
    xhr.addEventListener(<span class="hljs-string">'load'</span>, () =&gt; {
      <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>) {<font></font>
        observer.next(<span class="hljs-built_in">JSON</span>.parse(xhr.responseText));<font></font>
        observer.complete();<font></font>
      }<font></font>
    });<font></font>
    xhr.open(<span class="hljs-string">'GET'</span>, url);<font></font>
    xhr.send();<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> xhr.abort()<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(subscriptionFn);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eine Funktion geschrieben </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die eine URL empfängt, eine http-Anforderung ausführt und einen Stream zurückgibt, der die empfangene http-Antwort ausgibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was wird Ihrer Meinung nach passieren, wenn wir diesen Stream zweimal abonnieren?</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-comment">// A small observer helper</span>
<span class="hljs-keyword">const</span> observer = <span class="hljs-function"><span class="hljs-params">tag</span> =&gt;</span> ({<font></font>
  next(value) {<font></font>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${tag}</span>:`</span>, value);<font></font>
  }<font></font>
});<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber-1'</span>));<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber-2'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Richtig, zwei http-Anfragen werden ausgeführt. </font><font style="vertical-align: inherit;">Wenn wir uns die Implementierung der Observable-Klasse noch einmal ansehen, werden wir sehen, warum dies so ist. </font><font style="vertical-align: inherit;">Jeder Teilnehmer ruft einen Abonnement-Rückruf auf, der seinerseits jedes Mal eine http-Anforderung ausführt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/by/ee/aybyeesbyfdzvcjcp3etc8jhfww.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betreiber</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Operator ist eine Funktion, die einen Stream als Eingabe verwendet, eine beliebige Aktion ausführt und einen Stream zurückgibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden unseren ersten eigenen Operator schreiben.</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
      log(<span class="hljs-string">'Observable execution: map'</span>);
      <span class="hljs-keyword">return</span> source.subscribe({<font></font>
        next(value) {<font></font>
          observer.next(fn(value));<font></font>
        }<font></font>
      });<font></font>
    });<font></font>
  };<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion </font></font><code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt einen Operator zurück, der den ursprünglichen Stream akzeptiert, und gibt einen Stream zurück, in dem alle übergebenen Werte durch die Funktion geleitet werden </font></font><code>fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jene. </font><font style="vertical-align: inherit;">Darin befindet sich immer ein Abonnement für den Eingabestream. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir diesen neuen Operator verwenden können, müssen wir ihn irgendwie an den Stream anhängen. </font><font style="vertical-align: inherit;">Erweitern Sie unsere Klasse </font></font><code>Observable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um</font></font><code>pipe()</code><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>{
  <span class="hljs-keyword">constructor</span>(subscriptionFn) {
    <span class="hljs-keyword">this</span>.subscriptionFn = subscriptionFn;<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.subscriptionFn(observer);<font></font>
  }<font></font>
<font></font>
  pipe(...operators) {<font></font>
    <span class="hljs-keyword">return</span> operators.reduce(<span class="hljs-function">(<span class="hljs-params">source, next</span>) =&gt;</span> next(source), <span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine einfache Methode, nur eine Codezeile. </font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es nimmt eine Reihe von Operatoren und ruft sie nacheinander auf, wobei jede Eingabe das Ergebnis der vorherigen übergibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden wir unseren Operator:</font></font><br>
<br>
<pre><code class="javascript hljs">http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]))<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber'</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Aufruf </font></font><code>subscribe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird ein Abonnement für den Ausgabestream ausgeführt </font></font><code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und im Gegenzug </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird ein Abonnement für den ursprünglichen Stream ausgeführt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der http-Stream gibt den Wert aus, in den er fällt </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dann wird die Funktion ausgeführt </font></font><code>fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der Stream von </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt den Wert an das endgültige Abonnement aus. </font><font style="vertical-align: inherit;">Es funktioniert wie eine </font></font><code>observable chain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fadenkette. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/4a/ou/8r/4aou8rffl-aqkm6asdvs2224n84.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir eine Kette zweimal abonnieren, wird jedes Abonnement in der Kette zweimal aufgerufen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> firstUser$ = http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
    .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]));<font></font>
<font></font>
firstUser$.subscribe(observer(<span class="hljs-string">'subscriber-1'</span>));<font></font>
firstUser$.subscribe(observer(<span class="hljs-string">'subscriber-2'</span>));
</code></pre><br>
<img src="https://habrastorage.org/webt/kg/c2/iw/kgc2iwjualmgnqh_kcaxfe4c45g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wenn dieses Verhalten nicht zu uns passt? </font><font style="vertical-align: inherit;">Wenn wir die Abonnementfunktion nur einmal aufrufen möchten, wie viele Abonnements hätten wir? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist zum Beispiel, wenn wir eine http-Anfrage stellen und das Ergebnis für alle Abonnenten verwenden möchten? </font><font style="vertical-align: inherit;">In diesem Fall brauchen Sie </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Themen</font></font></h2><br>
<code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist sowohl ein Stream als auch ein Abonnent. </font><font style="vertical-align: inherit;">Der Ablauf - weil er eine Methode hat </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der Abonnent - weil er die Abonnentenschnittstelle implementiert - Methoden </font></font><code>next(), error(), complete().</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns ihn schreiben.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.observers = [];<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">this</span>.observers.push(observer);<font></font>
  }<font></font>
<font></font>
  next(value) {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.next(value));<font></font>
  }<font></font>
<font></font>
  error(error) {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.error(error));<font></font>
  }<font></font>
<font></font>
  complete() {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.complete());<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann als Zwischenstufe zwischen dem kalten Strom und vielen Teilnehmern fungieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ändern Sie unser Beispiel wie folgt:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> Subject();<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]))<font></font>
  .subscribe(subject);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Aufruf </font></font><code>subject.subscribe(someFn)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird nur eine einfache Operation ausgeführt - Hinzufügen einer </font></font><code>subject.observers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion </font><font style="vertical-align: inherit;">zum Array </font></font><code>someFn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, da es </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sich auch als Abonnent verhält, können Sie den ursprünglichen Stream abonnieren, d. H. </font><font style="vertical-align: inherit;">Wenn der ursprüngliche Thread einen Wert ausgibt, wird dieser aufgerufen </font></font><code>subject.next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wodurch dieser Wert an jeden der Abonnenten übertragen wird </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir den ursprünglichen Rückruf des Abonnements einmal ausgeführt und nur eine http-Anfrage wird ausgeführt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/8h/ld/hk8hld-xyjtum5d3srqpquhaqic.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Party-Nachzügler</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert, wenn der ursprüngliche Stream bereits funktioniert hat, bevor wir uns angemeldet haben? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies kann im vorherigen Beispiel nicht angezeigt werden, da http asynchron ist. Selbst wenn Sie es unmittelbar danach abonnieren, wird der Wert nach dem Abonnement weiterhin angezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns schnell eine generierende Funktion erstellen </font></font><code>of</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">of</span>(<span class="hljs-params">...values</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
    log(<span class="hljs-string">'Observable execution: of'</span>);<font></font>
    values.forEach(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> observer.next(value));<font></font>
  });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein mit Mitteln erzeugter Stream </font></font><code>of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt nacheinander synchron Werte aus. </font><font style="vertical-align: inherit;">Wir werden abonnieren, </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nachdem es bereits abonniert wurde.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> Subject();
<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).subscribe(subject);<font></font>
<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Abonnenten haben nichts erhalten. Warum? Unsere Implementierung unterstützt keine "späten" Abonnenten. Wenn der ursprüngliche Stream von </font></font><code>of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werte ausgibt, Abonnenten noch nicht registriert sind, werden diese Werte nirgendwo hingehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In tatsächlichen Beispielen zu Angular kann es durchaus sein, dass der Quelldatenstrom funktioniert hat, Ihre Komponente jedoch noch nicht auf der Seite vorhanden ist. Wenn die Komponente angezeigt wird, abonniert sie die Quelle, erhält jedoch nicht die bereits übergebenen Werte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Möglichkeit, das Problem zu lösen, ist diese </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir skizzieren die Version und sehen, wie es funktioniert.</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplaySubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span> </span>{
  <span class="hljs-keyword">constructor</span>(bufferSize) {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.observers = [];
    <span class="hljs-keyword">this</span>.bufferSize = bufferSize;
    <span class="hljs-keyword">this</span>.buffer = [];<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">this</span>.buffer.forEach(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> observer.next(val));
    <span class="hljs-keyword">this</span>.observers.push(observer);<font></font>
  }<font></font>
<font></font>
  next(value) {<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.buffer.length === <span class="hljs-keyword">this</span>.bufferSize) {
      <span class="hljs-keyword">this</span>.buffer.shift();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">this</span>.buffer.push(value);
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.next(value));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Konzept ist einfach. Wie der Name schon sagt, </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">handelt es sich um eine spezielle </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Version, die alte Werte für alle neuen Abonnenten reproduzieren kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder freigegebene Wert wird an alle aktuellen Abonnenten übertragen und für zukünftige gespeichert. Die Puffergröße wird </font></font><code>bufferSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Konstruktor festgelegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schreiben Sie das vorherige Beispiel mit neu </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> ReplaySubject(<span class="hljs-number">3</span>);
<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).subscribe(subject);<font></font>
<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis hat sich geändert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz des späten Abonnements haben wir sie alle gefangen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sg/xv/y1/sgxvy1flevy8totuzlejeiphvm0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammenfassend ist der Zweck </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Verteilung von Werten an alle Abonnenten und das Zwischenspeichern für zukünftige "späte" Abonnenten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor Sie fortfahren, empfehlen wir Ihnen, Ihre eigene Implementierung zu schreiben </font></font><code>BehaviorSubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Den fertigen Code finden Sie am Ende des Artikels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun kommen wir endlich zu Multicast-Operatoren. </font><font style="vertical-align: inherit;">Ich hoffe, die obigen Beispiele helfen Ihnen, sie schneller zu verstehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multicast-Operatoren</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multicast und Connect</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Betreiber </font></font><code>multicast() </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Quellstrom an mehrere Teilnehmer zu erteilen.</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-keyword">import</span> { interval, Subject, ConnectableObservable } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { multicast } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> Subject())<font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">const</span> observer1 = connectableObservable.subscribe(log);
<span class="hljs-keyword">const</span> observer2 = connectableObservable.subscribe(log);<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableSubscription = (connectableObservable <span class="hljs-keyword">as</span> ConnectableObservable&lt;any&gt;)<font></font>
  .connect();<font></font>
</code></pre><br>
<code>multicast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt ein Objekt </font></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einer Methode zurück </font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ihr Zweck ist es, den empfangenen Betreff für den Quelldatenstrom zu abonnieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Methode </font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">können wir bestimmen, wann die Ausführung des ursprünglichen Threads gestartet werden soll. </font><font style="vertical-align: inherit;">Es gibt einen Moment zu beachten - um sich von der Quelle abzumelden, die Sie tun müssen:</font></font><br>
<br>
<pre><code class="javascript hljs">connectableSubscription.unsubscribe();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sind nicht auf einfach beschränkt </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen können Sie eine beliebige abgeleitete Klasse verwenden, zum Beispiel </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { interval, ReplaySubject, ConnectableObservable } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { multicast } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> ReplaySubject(<span class="hljs-number">1</span>))<font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">const</span> observer1 = connectableObservable.subscribe(log);<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Late subscriber</span><font></font>
  connectableObservable.subscribe(log);<font></font>
}, <span class="hljs-number">3000</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectable = (connectableObservable <span class="hljs-keyword">as</span> ConnectableObservable&lt;any&gt;).connect();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anhand dieses Codes können Sie erraten, was unter der Haube passieren wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir verwenden </font></font><code>multicast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, können wir nicht nur </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Factory-Funktion übertragen, die jedes Mal eine neue zurückgibt </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wiederverwendet bereits abgeschlossen </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann nicht sein, die </font><font style="vertical-align: inherit;">Werksfunktion </font><font style="vertical-align: inherit;">löst dieses Problem.</font></font><br>
<br>
<pre><code class="javascript hljs">interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> Subject())<font></font>
)<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachzählen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Operator verwenden </font></font><code>multicast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sind wir für den Aufruf verantwortlich, um die </font></font><code>connect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausführung des ursprünglichen Observable zu starten. </font><font style="vertical-align: inherit;">Außerdem müssen wir immer noch nach möglichen Speicherlecks suchen und uns manuell abmelden </font></font><code>ConnectableSubscription</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Automatisierung des Prozesses würde Fehler vermeiden und den Code vereinfachen. </font><font style="vertical-align: inherit;">Die freundlichen RxJS-Entwickler haben für uns darüber nachgedacht und einen </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operator erstellt. </font></font><br>
<br>
<code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zählt Abonnements und wenn das erste erscheint, ruft es an </font></font><code>connect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, d.h. </font><font style="vertical-align: inherit;">abonniert. </font><font style="vertical-align: inherit;">Wenn es auf Null zurückfällt, wird eine Antwort aufgerufen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> Subject()),<font></font>
  refCount()<font></font>
)<font></font>
 <font></font>
<span class="hljs-comment">// refCount === 1 =&gt; source.subscribe();</span>
<span class="hljs-keyword">const</span> observer1 = source.subscribe(log);<font></font>
<font></font>
<span class="hljs-comment">// refCount === 2</span>
<span class="hljs-keyword">const</span> observer2 = source.subscribe(log);<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// refCount - 1</span><font></font>
  observer1.unsubscribe();<font></font>
  <span class="hljs-comment">// refCount - 1</span><font></font>
  observer2.unsubscribe();<font></font>
  <span class="hljs-comment">// refCount === 0 =&gt; source.unsubcribe();</span>
}, <span class="hljs-number">3000</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass, nachdem </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir das übliche beobachtbare erhalten haben, nicht </font></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veröffentlichen und seine Optionen</font></font></h3><br>
<code>multicast() + Subject + refCount()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein ziemlich typischer Fall in RxJS, und die Entwickler haben ihn auf einen einzigen Operator reduziert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, welche Möglichkeiten wir haben.</font></font><br>
<br>
<ul>
<li><code>publish()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Äquivalent </font></font><code>multicast(() =&gt; new Subject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publish()<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishBehavior()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Äquivalent </font></font><code>multicast(new BehaviorSubject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishBehavior(<span class="hljs-number">100</span>)<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishReplay()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Äquivalent </font></font><code>multicast(() =&gt; new ReplaySubject(x))</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishReplay(<span class="hljs-number">3</span>)<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishLast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Äquivalent </font></font><code>multicast(new AsyncSubject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  take(<span class="hljs-number">2</span>),<font></font>
  publishLast()<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>share()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Äquivalent </font></font><code>multicast(() =&gt; new Subject()) + refCount()</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  share()<font></font>
)<font></font>
</code></pre><br>
</li>
<li><code>shareReplay(bufferSize) </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein Multicast-Operator, der verwendet </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Er hat kein Inneres </font></font><code>multicast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und sein Ergebnis ist beobachtbar, nicht </font></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es kann mit </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder ohne verwendet werden. </font><font style="vertical-align: inherit;">Hier sind beide Optionen:</font></font><br>
<br>
<pre><code class="javascript hljs">interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay({ <span class="hljs-attr">refCount</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bufferSize</span>: <span class="hljs-number">1</span> })<font></font>
)<font></font>
<font></font>
interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay(<span class="hljs-number">1</span>)<font></font>
)<font></font>
</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn mit </font></font><code>shareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angerufen wird, </font></font><code>{ refCount: false }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist wie anrufen </font></font><code>shareReplay(x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall erfolgt keine Referenzzählung. </font><font style="vertical-align: inherit;">Dies bedeutet, dass der ursprüngliche Stream bis zur Fertigstellung </font></font><code>shareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abonniert wird, unabhängig davon, ob er selbst die endgültigen Abonnenten hat oder nicht. </font><font style="vertical-align: inherit;">Alle neuen Abonnenten erhalten die letzten x-Werte.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shareReplay vs PublishReplay + refCount</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf den ersten Blick </font><font style="vertical-align: inherit;">ist es </font></font><code>shareReplay({ refCount: true, bufferSize: X })</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identisch </font></font><code>publishReplay(X) + refCount() </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber das ist nicht ganz richtig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, was sind die Ähnlichkeiten und was ist der Unterschied. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie haben das gleiche Verhalten </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Abonnieren und Abbestellen des ursprünglichen Streams basierend auf der Anzahl der Abonnenten. </font><font style="vertical-align: inherit;">Sie reagieren auch gleich, wenn der ursprüngliche Stream abgeschlossen ist - alle neuen Abonnenten erhalten X letzte Werte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der ursprüngliche Stream jedoch noch nicht finalisiert ist, erhalten in diesem Fall </font></font><code>publishReplay(X) + refCount()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle neuen Abonnenten X-Werte aus dem Puffer und werden dann mit demselben neu signiert </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir jedoch die </font></font><code>shareReplay({ refCount: true, bufferSize: 1 })</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">letzten X-Werte verwenden, erhalten sie diese nicht, da darin ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neuer</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wert erstellt </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und zum erneuten Abonnieren der Quelle verwendet wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiele, die dies veranschaulichen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishReplay(<span class="hljs-number">1</span>),<font></font>
  refCount()<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">const</span> one = source.subscribe(observer(<span class="hljs-string">'subcriber-1'</span>));<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
  one.unsubscribe();<font></font>
 <font></font>
  <span class="hljs-comment">// This subscriber will get the last emitted values from the source</span>
  <span class="hljs-keyword">const</span> two = source.subscribe(observer(<span class="hljs-string">'subcriber-2'</span>));<font></font>
}, <span class="hljs-number">3000</span>);</code></pre><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay({ <span class="hljs-attr">refCount</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bufferSize</span>: <span class="hljs-number">1</span> })<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">const</span> one = source.subscribe(observer(<span class="hljs-string">'subcriber-1'</span>));<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
  one.unsubscribe();<font></font>
  <font></font>
  <span class="hljs-comment">// This subscriber will NOT get the last emitted values from the source</span>
  <span class="hljs-keyword">const</span> two = source.subscribe(observer(<span class="hljs-string">'subcriber-2'</span>));<font></font>
}, <span class="hljs-number">3000</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/6i/j1/ih/6ij1ihusgtdo_avliuz4tk4gsca.png"><br>
<br>
<img src="https://habrastorage.org/webt/ew/nk/6q/ewnk6q0ems5ysw574aa7unvy2jc.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktuelle Beispiele in Angular</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie man die untersuchten Multicast-Operatoren unter Kampfbedingungen einsetzt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden Share</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben eine Komponente, die Daten aus dem ursprünglichen Stream benötigt. </font><font style="vertical-align: inherit;">Es kann sich um eine http-Anfrage, einen Status oder was auch immer handeln. </font><font style="vertical-align: inherit;">Und wir brauchen auch Datenmanipulationen wie Filtern, Sortieren usw.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt brauchen wir eine andere Komponente, die nur den ersten Benutzer anzeigt. </font><font style="vertical-align: inherit;">Wenn wir den Quellstrom so abonnieren, wie er ist, dann:</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;user [user]="firstUser$ | async"&gt;&lt;/user&gt;
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
  firstUser$: Observable&lt;User&gt;;<font></font>
  <font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
    );<font></font>
    <font></font>
    <span class="hljs-keyword">this</span>.firstUser$ = <span class="hljs-keyword">this</span>.allUsers$.pipe(map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users[<span class="hljs-number">0</span>]));<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt haben wir zwei http-Anfragen. Sortier- oder Filtervorgänge werden zweimal ausgeführt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir bewerben uns </font></font><code>share</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;user [user]="firstUser$ | async"&gt;&lt;/user&gt;
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
  firstUser$: Observable&lt;User&gt;;<font></font>
  <font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
      share()<font></font>
    );<font></font>
    <font></font>
    <span class="hljs-keyword">this</span>.firstUser$ = <span class="hljs-keyword">this</span>.allUsers$.pipe(map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users[<span class="hljs-number">0</span>]));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wissen bereits, dass er eine neue erstellt </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Quelle abonniert. </font><font style="vertical-align: inherit;">Wenn die Quelle sendet, übergibt der Betreff diesen Wert an alle seine Abonnenten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem ist behoben, und wenn wir uns angemeldet haben, haben </font></font><code>firstUser$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir den internen </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nicht den ursprünglichen Stream direkt </font><font style="vertical-align: inherit;">abonniert </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden von ShareReplay</font></font></h3><br>
<code>ShareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gilt, wenn Sie die letzten X-Werte ausgeben, zwischenspeichern und wiederholen müssen. </font><font style="vertical-align: inherit;">Ein typisches Beispiel ist ein Singleton-Dienst, der eine http-Anforderung ausführt.</font></font><br>
<br>
<pre><code class="javascript hljs">
@Injectable({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlogService</span> </span>{<font></font>
  posts$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://jsonplaceholder.typicode.com/posts'</span>)<font></font>
              .pipe(shareReplay(<span class="hljs-number">1</span>));<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es spielt keine Rolle, wie viele Komponenten jetzt oder in Zukunft Daten anfordern, es gibt nur eine http-Anforderung und das Ergebnis wird im internen Puffer gespeichert </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es kann immer noch vorkommen, dass Sie eine unvollständige Anfrage stornieren müssen, da keine Abonnenten vorhanden sind. Dann müssen Sie sich bewerben </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Den vollständigen Code finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de490976/index.html">Frontend-Bereich zu DUMP2020: Wir werden davon ausgehen, dass es wieder ein volles Haus geben wird. Top-Berichte des letzten Jahres und Themen dazu</a></li>
<li><a href="../de490978/index.html">Senden Sie mit SecureCRT Befehle gleichzeitig an mehrere Geräte</a></li>
<li><a href="../de490982/index.html">Schlechter Rat an den Arbeitgeber. Wie man "richtig" mit dem Entwickler interagiert</a></li>
<li><a href="../de490984/index.html">Materialien aus dem Nischni Nowgorod Android Mitap. MotionLayout, Kotlin Coroutines, CI / CD-Infrastruktur und Designsysteme</a></li>
<li><a href="../de490986/index.html">Testen von AMD Ryzen-Prozessoren für die Arbeit mit KOMPAS-3D</a></li>
<li><a href="../de490992/index.html">Preisnachlassmanagement: Modelle zur Quantifizierung der Wirkung von Tankstellen als Beispiel</a></li>
<li><a href="../de490996/index.html">STOP RESCUE! Anleitung zur Selbstorganisation der "medizinischen Maske"</a></li>
<li><a href="../de490998/index.html">Hardwaretests in SIBUR</a></li>
<li><a href="../de491000/index.html">Styling Select-Option (fast) ohne JavaScript</a></li>
<li><a href="../de491006/index.html">Intel NUC als Pass in Unity3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>