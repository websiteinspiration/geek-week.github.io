<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÄ üçã üë®‚Äçüç≥ Wir untersuchen Multicast-RxJS-Operatoren üë®üèΩ‚Äçüé® üë©üèº‚Äçü§ù‚Äçüë®üèΩ üöä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich pr√§sentiere Ihnen die √úbersetzung des Artikels "Grundlegendes zu RxJS-Multicast-Operatoren" von Netanel Basal. 
 
 Broadcast- oder Mul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wir untersuchen Multicast-RxJS-Operatoren</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490988/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font><font style="vertical-align: inherit;">Ich pr√§sentiere Ihnen die √úbersetzung des Artikels </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Grundlegendes zu RxJS-Multicast-Operatoren"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von Netanel Basal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Broadcast- oder Multicast-Betreiber scheinen oft das schwierigste Thema zu sein, um etwas √ºber RxJS zu lernen. </font><font style="vertical-align: inherit;">In diesem Artikel werde ich versuchen, alles auf zug√§ngliche Weise zu erkl√§ren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden die interne Struktur von Multicast-Operatoren und die von ihnen gel√∂sten Aufgaben ber√ºcksichtigen.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit der Beschreibung der Grundbausteine ‚Äã‚Äãvon RxJS.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beobachtbar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In RxJS sind beobachtbare Objekte (im Folgenden als "Str√∂me" bezeichnet) anfangs kalt. Dies bedeutet, dass jedes Mal, wenn Sie einen Stream abonnieren, ein R√ºckruf des Abonnements durchgef√ºhrt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie zum besseren Verst√§ndnis die folgende Implementierung:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>{
  <span class="hljs-keyword">constructor</span>(subscriptionFn) {
    <span class="hljs-keyword">this</span>.subscriptionFn = subscriptionFn;<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.subscriptionFn(observer);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Konstruktor </font></font><code>Observable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akzeptiert einen einzelnen Parameter - den R√ºckruf des Abonnements </font></font><br>
 <code>subscriptionFn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es wird jedes Mal aufgerufen, wenn wir den Stream abonnieren ( </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal rufen sie auch einen R√ºckruf eines Abonnements auf </font></font><code>producer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da es auch Werte f√ºr den Abonnenten "erzeugt" (Beobachterobjekt in unserem Code). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Methode </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nimmt eine Eingabe entgegen </font></font><code>observer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es ist ein Objekt mit drei eigenen Methoden : </font></font><code>next(), error(), complete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In Live-RxJS k√∂nnen Sie anstelle eines Objekts drei Funktionen √ºbergeben. </font><font style="vertical-align: inherit;">Wenn </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
die Methode </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aufgerufen wird, ruft sie die Abonnementfunktion auf und √ºbergibt sie an die Eingabe </font></font><code>observer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben die Methode jetzt nicht erw√§hnt</font></font><code>unsubscribe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sollte jedoch beachtet werden, dass jedes Abonnement eine M√∂glichkeit bietet, es zu zerst√∂ren. </font><font style="vertical-align: inherit;">In den meisten F√§llen gibt ein Abonnement eine Funktion (oder ein Objekt mit der entsprechenden Methode) zur√ºck, bei der die Verbindung zwischen dem Stream und seinen Abonnenten zerst√∂rt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles ziemlich einfach. </font><font style="vertical-align: inherit;">Kommen wir jetzt der Realit√§t n√§her. </font><font style="vertical-align: inherit;">Wickeln Sie beispielsweise eine native XHR-API in einen Stream ein</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">http</span>(<span class="hljs-params">url</span>) </span>{
  <span class="hljs-comment">// This function will be called when we call http().subscribe()</span>
  <span class="hljs-keyword">const</span> subscriptionFn = <span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
    log(<span class="hljs-string">'Observable execution: http'</span>);
    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<font></font>
    xhr.addEventListener(<span class="hljs-string">'load'</span>, () =&gt; {
      <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>) {<font></font>
        observer.next(<span class="hljs-built_in">JSON</span>.parse(xhr.responseText));<font></font>
        observer.complete();<font></font>
      }<font></font>
    });<font></font>
    xhr.open(<span class="hljs-string">'GET'</span>, url);<font></font>
    xhr.send();<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> xhr.abort()<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(subscriptionFn);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eine Funktion geschrieben </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die eine URL empf√§ngt, eine http-Anforderung ausf√ºhrt und einen Stream zur√ºckgibt, der die empfangene http-Antwort ausgibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was wird Ihrer Meinung nach passieren, wenn wir diesen Stream zweimal abonnieren?</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-comment">// A small observer helper</span>
<span class="hljs-keyword">const</span> observer = <span class="hljs-function"><span class="hljs-params">tag</span> =&gt;</span> ({<font></font>
  next(value) {<font></font>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${tag}</span>:`</span>, value);<font></font>
  }<font></font>
});<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber-1'</span>));<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber-2'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Richtig, zwei http-Anfragen werden ausgef√ºhrt. </font><font style="vertical-align: inherit;">Wenn wir uns die Implementierung der Observable-Klasse noch einmal ansehen, werden wir sehen, warum dies so ist. </font><font style="vertical-align: inherit;">Jeder Teilnehmer ruft einen Abonnement-R√ºckruf auf, der seinerseits jedes Mal eine http-Anforderung ausf√ºhrt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/by/ee/aybyeesbyfdzvcjcp3etc8jhfww.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betreiber</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Operator ist eine Funktion, die einen Stream als Eingabe verwendet, eine beliebige Aktion ausf√ºhrt und einen Stream zur√ºckgibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden unseren ersten eigenen Operator schreiben.</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
      log(<span class="hljs-string">'Observable execution: map'</span>);
      <span class="hljs-keyword">return</span> source.subscribe({<font></font>
        next(value) {<font></font>
          observer.next(fn(value));<font></font>
        }<font></font>
      });<font></font>
    });<font></font>
  };<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion </font></font><code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt einen Operator zur√ºck, der den urspr√ºnglichen Stream akzeptiert, und gibt einen Stream zur√ºck, in dem alle √ºbergebenen Werte durch die Funktion geleitet werden </font></font><code>fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jene. </font><font style="vertical-align: inherit;">Darin befindet sich immer ein Abonnement f√ºr den Eingabestream. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir diesen neuen Operator verwenden k√∂nnen, m√ºssen wir ihn irgendwie an den Stream anh√§ngen. </font><font style="vertical-align: inherit;">Erweitern Sie unsere Klasse </font></font><code>Observable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um</font></font><code>pipe()</code><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>{
  <span class="hljs-keyword">constructor</span>(subscriptionFn) {
    <span class="hljs-keyword">this</span>.subscriptionFn = subscriptionFn;<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.subscriptionFn(observer);<font></font>
  }<font></font>
<font></font>
  pipe(...operators) {<font></font>
    <span class="hljs-keyword">return</span> operators.reduce(<span class="hljs-function">(<span class="hljs-params">source, next</span>) =&gt;</span> next(source), <span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine einfache Methode, nur eine Codezeile. </font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es nimmt eine Reihe von Operatoren und ruft sie nacheinander auf, wobei jede Eingabe das Ergebnis der vorherigen √ºbergibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden wir unseren Operator:</font></font><br>
<br>
<pre><code class="javascript hljs">http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]))<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber'</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Aufruf </font></font><code>subscribe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird ein Abonnement f√ºr den Ausgabestream ausgef√ºhrt </font></font><code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und im Gegenzug </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird ein Abonnement f√ºr den urspr√ºnglichen Stream ausgef√ºhrt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der http-Stream gibt den Wert aus, in den er f√§llt </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dann wird die Funktion ausgef√ºhrt </font></font><code>fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der Stream von </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt den Wert an das endg√ºltige Abonnement aus. </font><font style="vertical-align: inherit;">Es funktioniert wie eine </font></font><code>observable chain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fadenkette. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/4a/ou/8r/4aou8rffl-aqkm6asdvs2224n84.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir eine Kette zweimal abonnieren, wird jedes Abonnement in der Kette zweimal aufgerufen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> firstUser$ = http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
    .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]));<font></font>
<font></font>
firstUser$.subscribe(observer(<span class="hljs-string">'subscriber-1'</span>));<font></font>
firstUser$.subscribe(observer(<span class="hljs-string">'subscriber-2'</span>));
</code></pre><br>
<img src="https://habrastorage.org/webt/kg/c2/iw/kgc2iwjualmgnqh_kcaxfe4c45g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wenn dieses Verhalten nicht zu uns passt? </font><font style="vertical-align: inherit;">Wenn wir die Abonnementfunktion nur einmal aufrufen m√∂chten, wie viele Abonnements h√§tten wir? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist zum Beispiel, wenn wir eine http-Anfrage stellen und das Ergebnis f√ºr alle Abonnenten verwenden m√∂chten? </font><font style="vertical-align: inherit;">In diesem Fall brauchen Sie </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Themen</font></font></h2><br>
<code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist sowohl ein Stream als auch ein Abonnent. </font><font style="vertical-align: inherit;">Der Ablauf - weil er eine Methode hat </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der Abonnent - weil er die Abonnentenschnittstelle implementiert - Methoden </font></font><code>next(), error(), complete().</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns ihn schreiben.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.observers = [];<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">this</span>.observers.push(observer);<font></font>
  }<font></font>
<font></font>
  next(value) {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.next(value));<font></font>
  }<font></font>
<font></font>
  error(error) {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.error(error));<font></font>
  }<font></font>
<font></font>
  complete() {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.complete());<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann als Zwischenstufe zwischen dem kalten Strom und vielen Teilnehmern fungieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ñndern Sie unser Beispiel wie folgt:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> Subject();<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]))<font></font>
  .subscribe(subject);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Aufruf </font></font><code>subject.subscribe(someFn)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird nur eine einfache Operation ausgef√ºhrt - Hinzuf√ºgen einer </font></font><code>subject.observers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion </font><font style="vertical-align: inherit;">zum Array </font></font><code>someFn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, da es </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sich auch als Abonnent verh√§lt, k√∂nnen Sie den urspr√ºnglichen Stream abonnieren, d. H. </font><font style="vertical-align: inherit;">Wenn der urspr√ºngliche Thread einen Wert ausgibt, wird dieser aufgerufen </font></font><code>subject.next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wodurch dieser Wert an jeden der Abonnenten √ºbertragen wird </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir den urspr√ºnglichen R√ºckruf des Abonnements einmal ausgef√ºhrt und nur eine http-Anfrage wird ausgef√ºhrt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/8h/ld/hk8hld-xyjtum5d3srqpquhaqic.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Party-Nachz√ºgler</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert, wenn der urspr√ºngliche Stream bereits funktioniert hat, bevor wir uns angemeldet haben? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies kann im vorherigen Beispiel nicht angezeigt werden, da http asynchron ist. Selbst wenn Sie es unmittelbar danach abonnieren, wird der Wert nach dem Abonnement weiterhin angezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns schnell eine generierende Funktion erstellen </font></font><code>of</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">of</span>(<span class="hljs-params">...values</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
    log(<span class="hljs-string">'Observable execution: of'</span>);<font></font>
    values.forEach(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> observer.next(value));<font></font>
  });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein mit Mitteln erzeugter Stream </font></font><code>of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt nacheinander synchron Werte aus. </font><font style="vertical-align: inherit;">Wir werden abonnieren, </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nachdem es bereits abonniert wurde.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> Subject();
<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).subscribe(subject);<font></font>
<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Abonnenten haben nichts erhalten. Warum? Unsere Implementierung unterst√ºtzt keine "sp√§ten" Abonnenten. Wenn der urspr√ºngliche Stream von </font></font><code>of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werte ausgibt, Abonnenten noch nicht registriert sind, werden diese Werte nirgendwo hingehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In tats√§chlichen Beispielen zu Angular kann es durchaus sein, dass der Quelldatenstrom funktioniert hat, Ihre Komponente jedoch noch nicht auf der Seite vorhanden ist. Wenn die Komponente angezeigt wird, abonniert sie die Quelle, erh√§lt jedoch nicht die bereits √ºbergebenen Werte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine M√∂glichkeit, das Problem zu l√∂sen, ist diese </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir skizzieren die Version und sehen, wie es funktioniert.</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplaySubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span> </span>{
  <span class="hljs-keyword">constructor</span>(bufferSize) {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.observers = [];
    <span class="hljs-keyword">this</span>.bufferSize = bufferSize;
    <span class="hljs-keyword">this</span>.buffer = [];<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">this</span>.buffer.forEach(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> observer.next(val));
    <span class="hljs-keyword">this</span>.observers.push(observer);<font></font>
  }<font></font>
<font></font>
  next(value) {<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.buffer.length === <span class="hljs-keyword">this</span>.bufferSize) {
      <span class="hljs-keyword">this</span>.buffer.shift();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">this</span>.buffer.push(value);
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.next(value));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Konzept ist einfach. Wie der Name schon sagt, </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">handelt es sich um eine spezielle </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Version, die alte Werte f√ºr alle neuen Abonnenten reproduzieren kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder freigegebene Wert wird an alle aktuellen Abonnenten √ºbertragen und f√ºr zuk√ºnftige gespeichert. Die Puffergr√∂√üe wird </font></font><code>bufferSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Konstruktor festgelegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schreiben Sie das vorherige Beispiel mit neu </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> ReplaySubject(<span class="hljs-number">3</span>);
<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).subscribe(subject);<font></font>
<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis hat sich ge√§ndert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz des sp√§ten Abonnements haben wir sie alle gefangen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sg/xv/y1/sgxvy1flevy8totuzlejeiphvm0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammenfassend ist der Zweck </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Verteilung von Werten an alle Abonnenten und das Zwischenspeichern f√ºr zuk√ºnftige "sp√§te" Abonnenten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor Sie fortfahren, empfehlen wir Ihnen, Ihre eigene Implementierung zu schreiben </font></font><code>BehaviorSubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Den fertigen Code finden Sie am Ende des Artikels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun kommen wir endlich zu Multicast-Operatoren. </font><font style="vertical-align: inherit;">Ich hoffe, die obigen Beispiele helfen Ihnen, sie schneller zu verstehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multicast-Operatoren</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multicast und Connect</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Betreiber </font></font><code>multicast() </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Quellstrom an mehrere Teilnehmer zu erteilen.</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-keyword">import</span> { interval, Subject, ConnectableObservable } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { multicast } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> Subject())<font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">const</span> observer1 = connectableObservable.subscribe(log);
<span class="hljs-keyword">const</span> observer2 = connectableObservable.subscribe(log);<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableSubscription = (connectableObservable <span class="hljs-keyword">as</span> ConnectableObservable&lt;any&gt;)<font></font>
  .connect();<font></font>
</code></pre><br>
<code>multicast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt ein Objekt </font></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einer Methode zur√ºck </font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ihr Zweck ist es, den empfangenen Betreff f√ºr den Quelldatenstrom zu abonnieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Methode </font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen wir bestimmen, wann die Ausf√ºhrung des urspr√ºnglichen Threads gestartet werden soll. </font><font style="vertical-align: inherit;">Es gibt einen Moment zu beachten - um sich von der Quelle abzumelden, die Sie tun m√ºssen:</font></font><br>
<br>
<pre><code class="javascript hljs">connectableSubscription.unsubscribe();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sind nicht auf einfach beschr√§nkt </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen k√∂nnen Sie eine beliebige abgeleitete Klasse verwenden, zum Beispiel </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { interval, ReplaySubject, ConnectableObservable } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { multicast } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> ReplaySubject(<span class="hljs-number">1</span>))<font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">const</span> observer1 = connectableObservable.subscribe(log);<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Late subscriber</span><font></font>
  connectableObservable.subscribe(log);<font></font>
}, <span class="hljs-number">3000</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectable = (connectableObservable <span class="hljs-keyword">as</span> ConnectableObservable&lt;any&gt;).connect();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anhand dieses Codes k√∂nnen Sie erraten, was unter der Haube passieren wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir verwenden </font></font><code>multicast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, k√∂nnen wir nicht nur </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Factory-Funktion √ºbertragen, die jedes Mal eine neue zur√ºckgibt </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wiederverwendet bereits abgeschlossen </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann nicht sein, die </font><font style="vertical-align: inherit;">Werksfunktion </font><font style="vertical-align: inherit;">l√∂st dieses Problem.</font></font><br>
<br>
<pre><code class="javascript hljs">interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> Subject())<font></font>
)<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachz√§hlen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Operator verwenden </font></font><code>multicast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sind wir f√ºr den Aufruf verantwortlich, um die </font></font><code>connect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausf√ºhrung des urspr√ºnglichen Observable zu starten. </font><font style="vertical-align: inherit;">Au√üerdem m√ºssen wir immer noch nach m√∂glichen Speicherlecks suchen und uns manuell abmelden </font></font><code>ConnectableSubscription</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Automatisierung des Prozesses w√ºrde Fehler vermeiden und den Code vereinfachen. </font><font style="vertical-align: inherit;">Die freundlichen RxJS-Entwickler haben f√ºr uns dar√ºber nachgedacht und einen </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operator erstellt. </font></font><br>
<br>
<code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z√§hlt Abonnements und wenn das erste erscheint, ruft es an </font></font><code>connect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, d.h. </font><font style="vertical-align: inherit;">abonniert. </font><font style="vertical-align: inherit;">Wenn es auf Null zur√ºckf√§llt, wird eine Antwort aufgerufen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> Subject()),<font></font>
  refCount()<font></font>
)<font></font>
 <font></font>
<span class="hljs-comment">// refCount === 1 =&gt; source.subscribe();</span>
<span class="hljs-keyword">const</span> observer1 = source.subscribe(log);<font></font>
<font></font>
<span class="hljs-comment">// refCount === 2</span>
<span class="hljs-keyword">const</span> observer2 = source.subscribe(log);<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// refCount - 1</span><font></font>
  observer1.unsubscribe();<font></font>
  <span class="hljs-comment">// refCount - 1</span><font></font>
  observer2.unsubscribe();<font></font>
  <span class="hljs-comment">// refCount === 0 =&gt; source.unsubcribe();</span>
}, <span class="hljs-number">3000</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass, nachdem </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir das √ºbliche beobachtbare erhalten haben, nicht </font></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ver√∂ffentlichen und seine Optionen</font></font></h3><br>
<code>multicast() + Subject + refCount()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein ziemlich typischer Fall in RxJS, und die Entwickler haben ihn auf einen einzigen Operator reduziert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, welche M√∂glichkeiten wir haben.</font></font><br>
<br>
<ul>
<li><code>publish()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñquivalent </font></font><code>multicast(() =&gt; new Subject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publish()<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishBehavior()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñquivalent </font></font><code>multicast(new BehaviorSubject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishBehavior(<span class="hljs-number">100</span>)<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishReplay()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñquivalent </font></font><code>multicast(() =&gt; new ReplaySubject(x))</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishReplay(<span class="hljs-number">3</span>)<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishLast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñquivalent </font></font><code>multicast(new AsyncSubject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  take(<span class="hljs-number">2</span>),<font></font>
  publishLast()<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>share()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñquivalent </font></font><code>multicast(() =&gt; new Subject()) + refCount()</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  share()<font></font>
)<font></font>
</code></pre><br>
</li>
<li><code>shareReplay(bufferSize) </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein Multicast-Operator, der verwendet </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Er hat kein Inneres </font></font><code>multicast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und sein Ergebnis ist beobachtbar, nicht </font></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es kann mit </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder ohne verwendet werden. </font><font style="vertical-align: inherit;">Hier sind beide Optionen:</font></font><br>
<br>
<pre><code class="javascript hljs">interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay({ <span class="hljs-attr">refCount</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bufferSize</span>: <span class="hljs-number">1</span> })<font></font>
)<font></font>
<font></font>
interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay(<span class="hljs-number">1</span>)<font></font>
)<font></font>
</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn mit </font></font><code>shareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angerufen wird, </font></font><code>{ refCount: false }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist wie anrufen </font></font><code>shareReplay(x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall erfolgt keine Referenzz√§hlung. </font><font style="vertical-align: inherit;">Dies bedeutet, dass der urspr√ºngliche Stream bis zur Fertigstellung </font></font><code>shareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abonniert wird, unabh√§ngig davon, ob er selbst die endg√ºltigen Abonnenten hat oder nicht. </font><font style="vertical-align: inherit;">Alle neuen Abonnenten erhalten die letzten x-Werte.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shareReplay vs PublishReplay + refCount</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf den ersten Blick </font><font style="vertical-align: inherit;">ist es </font></font><code>shareReplay({ refCount: true, bufferSize: X })</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identisch </font></font><code>publishReplay(X) + refCount() </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber das ist nicht ganz richtig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, was sind die √Ñhnlichkeiten und was ist der Unterschied. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie haben das gleiche Verhalten </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Abonnieren und Abbestellen des urspr√ºnglichen Streams basierend auf der Anzahl der Abonnenten. </font><font style="vertical-align: inherit;">Sie reagieren auch gleich, wenn der urspr√ºngliche Stream abgeschlossen ist - alle neuen Abonnenten erhalten X letzte Werte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der urspr√ºngliche Stream jedoch noch nicht finalisiert ist, erhalten in diesem Fall </font></font><code>publishReplay(X) + refCount()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle neuen Abonnenten X-Werte aus dem Puffer und werden dann mit demselben neu signiert </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir jedoch die </font></font><code>shareReplay({ refCount: true, bufferSize: 1 })</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">letzten X-Werte verwenden, erhalten sie diese nicht, da darin ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neuer</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wert erstellt </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und zum erneuten Abonnieren der Quelle verwendet wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiele, die dies veranschaulichen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishReplay(<span class="hljs-number">1</span>),<font></font>
  refCount()<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">const</span> one = source.subscribe(observer(<span class="hljs-string">'subcriber-1'</span>));<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
  one.unsubscribe();<font></font>
 <font></font>
  <span class="hljs-comment">// This subscriber will get the last emitted values from the source</span>
  <span class="hljs-keyword">const</span> two = source.subscribe(observer(<span class="hljs-string">'subcriber-2'</span>));<font></font>
}, <span class="hljs-number">3000</span>);</code></pre><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay({ <span class="hljs-attr">refCount</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bufferSize</span>: <span class="hljs-number">1</span> })<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">const</span> one = source.subscribe(observer(<span class="hljs-string">'subcriber-1'</span>));<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
  one.unsubscribe();<font></font>
  <font></font>
  <span class="hljs-comment">// This subscriber will NOT get the last emitted values from the source</span>
  <span class="hljs-keyword">const</span> two = source.subscribe(observer(<span class="hljs-string">'subcriber-2'</span>));<font></font>
}, <span class="hljs-number">3000</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/6i/j1/ih/6ij1ihusgtdo_avliuz4tk4gsca.png"><br>
<br>
<img src="https://habrastorage.org/webt/ew/nk/6q/ewnk6q0ems5ysw574aa7unvy2jc.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktuelle Beispiele in Angular</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie man die untersuchten Multicast-Operatoren unter Kampfbedingungen einsetzt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden Share</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben eine Komponente, die Daten aus dem urspr√ºnglichen Stream ben√∂tigt. </font><font style="vertical-align: inherit;">Es kann sich um eine http-Anfrage, einen Status oder was auch immer handeln. </font><font style="vertical-align: inherit;">Und wir brauchen auch Datenmanipulationen wie Filtern, Sortieren usw.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt brauchen wir eine andere Komponente, die nur den ersten Benutzer anzeigt. </font><font style="vertical-align: inherit;">Wenn wir den Quellstrom so abonnieren, wie er ist, dann:</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;user [user]="firstUser$ | async"&gt;&lt;/user&gt;
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
  firstUser$: Observable&lt;User&gt;;<font></font>
  <font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
    );<font></font>
    <font></font>
    <span class="hljs-keyword">this</span>.firstUser$ = <span class="hljs-keyword">this</span>.allUsers$.pipe(map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users[<span class="hljs-number">0</span>]));<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt haben wir zwei http-Anfragen. Sortier- oder Filtervorg√§nge werden zweimal ausgef√ºhrt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir bewerben uns </font></font><code>share</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;user [user]="firstUser$ | async"&gt;&lt;/user&gt;
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
  firstUser$: Observable&lt;User&gt;;<font></font>
  <font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
      share()<font></font>
    );<font></font>
    <font></font>
    <span class="hljs-keyword">this</span>.firstUser$ = <span class="hljs-keyword">this</span>.allUsers$.pipe(map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users[<span class="hljs-number">0</span>]));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wissen bereits, dass er eine neue erstellt </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Quelle abonniert. </font><font style="vertical-align: inherit;">Wenn die Quelle sendet, √ºbergibt der Betreff diesen Wert an alle seine Abonnenten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem ist behoben, und wenn wir uns angemeldet haben, haben </font></font><code>firstUser$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir den internen </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nicht den urspr√ºnglichen Stream direkt </font><font style="vertical-align: inherit;">abonniert </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden von ShareReplay</font></font></h3><br>
<code>ShareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gilt, wenn Sie die letzten X-Werte ausgeben, zwischenspeichern und wiederholen m√ºssen. </font><font style="vertical-align: inherit;">Ein typisches Beispiel ist ein Singleton-Dienst, der eine http-Anforderung ausf√ºhrt.</font></font><br>
<br>
<pre><code class="javascript hljs">
@Injectable({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlogService</span> </span>{<font></font>
  posts$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://jsonplaceholder.typicode.com/posts'</span>)<font></font>
              .pipe(shareReplay(<span class="hljs-number">1</span>));<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es spielt keine Rolle, wie viele Komponenten jetzt oder in Zukunft Daten anfordern, es gibt nur eine http-Anforderung und das Ergebnis wird im internen Puffer gespeichert </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es kann immer noch vorkommen, dass Sie eine unvollst√§ndige Anfrage stornieren m√ºssen, da keine Abonnenten vorhanden sind. Dann m√ºssen Sie sich bewerben </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Den vollst√§ndigen Code finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de490976/index.html">Frontend-Bereich zu DUMP2020: Wir werden davon ausgehen, dass es wieder ein volles Haus geben wird. Top-Berichte des letzten Jahres und Themen dazu</a></li>
<li><a href="../de490978/index.html">Senden Sie mit SecureCRT Befehle gleichzeitig an mehrere Ger√§te</a></li>
<li><a href="../de490982/index.html">Schlechter Rat an den Arbeitgeber. Wie man "richtig" mit dem Entwickler interagiert</a></li>
<li><a href="../de490984/index.html">Materialien aus dem Nischni Nowgorod Android Mitap. MotionLayout, Kotlin Coroutines, CI / CD-Infrastruktur und Designsysteme</a></li>
<li><a href="../de490986/index.html">Testen von AMD Ryzen-Prozessoren f√ºr die Arbeit mit KOMPAS-3D</a></li>
<li><a href="../de490992/index.html">Preisnachlassmanagement: Modelle zur Quantifizierung der Wirkung von Tankstellen als Beispiel</a></li>
<li><a href="../de490996/index.html">STOP RESCUE! Anleitung zur Selbstorganisation der "medizinischen Maske"</a></li>
<li><a href="../de490998/index.html">Hardwaretests in SIBUR</a></li>
<li><a href="../de491000/index.html">Styling Select-Option (fast) ohne JavaScript</a></li>
<li><a href="../de491006/index.html">Intel NUC als Pass in Unity3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>