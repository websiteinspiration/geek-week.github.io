<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😔 🤞 🍦 Unityでタワーディフェンスを作成する：タワーと敵を撃つ ⛺️ 👭 ✋🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ チュートリアルの前半と後半 ]
 
 

- タワーフィールドに配置します。
- 私たちは物理学の助けを借りて敵を狙います。
- 可能な限り追跡します。
- レーザー光線でそれらを撃ちます。
 これは、シンプルなタワーディフェンスジャンルの作成に関する一連のチュートリアルのパート3です。塔の作成...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unityでタワーディフェンスを作成する：タワーと敵を撃つ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459070/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font><font style="vertical-align: inherit;">チュートリアル</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の前半</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">後半</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タワーフィールドに配置します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは物理学の助けを借りて敵を狙います。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能な限り追跡します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レーザー光線でそれらを撃ちます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、シンプルなタワーディフェンスジャンルの作成に関する一連のチュートリアルのパート3です。</font><font style="vertical-align: inherit;">塔の作成、敵の狙い撃ちについて説明しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チュートリアルはUnity 2018.3.0f2で作成されました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/470/ceb/183/470ceb1832b49ee7372fb79b8425b567.jpg" width="512" height="256"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵を加熱しましょう。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タワー作成</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
壁は敵を遅くするだけであり、敵が進む必要のある経路の長さが長くなります。</font><font style="vertical-align: inherit;">しかし、ゲームの目的は、敵が終点に到達する前に敵を破壊することです。</font><font style="vertical-align: inherit;">この問題は、タワーを撃つフィールドに配置することによって解決されます。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイルコンテンツ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タワーはタイルコンテンツのもう1つのタイプなので、のエントリをタワーに追加します</font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> GameTileContentType {<font></font>
	Empty, Destination, Wall, SpawnPoint, Tower€<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このチュートリアルでは、1種類のタワーのみをサポート</font></font><code>GameTileContentFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します</font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、タワープレハブへの1つのリンクを</font><font style="vertical-align: inherit;">提供することで実装でき</font><font style="vertical-align: inherit;">、そのインスタンスもを介して作成できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">	[<span class="hljs-meta">SerializeField</span>]<font></font>
	GameTileContent towerPrefab = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> GameTileContent <span class="hljs-title">Get</span> (<span class="hljs-params">GameTileContentType type</span>)</span> {
		<span class="hljs-keyword">switch</span> (type) {<font></font>
			…<font></font>
			<span class="hljs-keyword">case</span> GameTileContentType.Tower€: <span class="hljs-keyword">return</span> Get(towerPrefab);<font></font>
		}<font></font>
		…<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、塔は撃たなければならないので、塔の状態を更新する必要があり、塔には独自のコードが必要です。</font><font style="vertical-align: inherit;">この目的のために、クラス</font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を拡張するクラス</font><font style="vertical-align: inherit;">を作成します</font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tower</span> : <span class="hljs-title">GameTileContent</span> {}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
工場フィールドタイプをに変更することで、タワープレハブに独自のコンポーネントを持たせることができ</font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">クラスはまだ考慮されているため、</font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他に何も変更する必要はありません。</font></font><br>
<br>
<pre><code class="cs hljs">	Tower towerPrefab = <span class="hljs-keyword">default</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレハブ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タワーのプレハブを作成します。</font><font style="vertical-align: inherit;">まず、壁のプレハブを複製し、そのコンポーネント</font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">コンポーネントに置き換えて</font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から、タイプを</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Towerに</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">タワーを壁にフィットさせるには、壁の立方体をタワーのベースとして保存します。</font><font style="vertical-align: inherit;">次に、その上に別の立方体を配置します。</font><font style="vertical-align: inherit;">私は彼に0.5のスケールを与えました。</font><font style="vertical-align: inherit;">砲塔を示す別の立方体をその上に置き、この部分は敵を狙って撃ちます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/e5d/633/392e5d63397672627c3b5ec018df0444.png" width="190" height="260"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/dec/c33/d92decc33036a1e973a7f20a3df2c00e.png" width="320" height="120"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タワーを形成する3つの立方体。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タレットが回転し、コライダーがあるため、物理エンジンがそれを追跡します。</font><font style="vertical-align: inherit;">ただし、タワーコライダーはセルの選択にのみ使用するため、それほど正確である必要はありません。</font><font style="vertical-align: inherit;">これはおおよそ行うことができます。</font><font style="vertical-align: inherit;">タレットキューブコライダーを削除し、タワーキューブコライダーが両方のキューブを覆うように変更します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/11e/3b7/e0111e3b7221bbbe4e5b0d23373e4b3a.png" width="190" height="260"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/857/09b/a1f85709bd504d176a18930240edea5a.png" width="320" height="152"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コライダーキューブタワー。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タワーはレーザービームを発射します。</font><font style="vertical-align: inherit;">さまざまな方法で視覚化できますが、半透明の立方体を使用します。これを伸ばしてビームを形成します。</font><font style="vertical-align: inherit;">各タワーには独自の梁が必要なので、タワープレハブに追加します。</font><font style="vertical-align: inherit;">既定では非表示になるように砲塔の内側に配置し、0.2などの小さなスケールを指定します。</font><font style="vertical-align: inherit;">タレットキューブではなく、プレハブルートの子にします。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/1dc/29e/19a1dc29e70adb158e07f29653db2d66.png" width="190" height="260" alt="レーザービーム"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/273/081/45a273081365aa9e483f1aa97cbe39c8.png" width="226" height="108" alt="階層"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レーザービームの隠された立方体。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レーザービームに適した材料を作成します。</font><font style="vertical-align: inherit;">標準の半透明の黒のマテリアルを使用し、すべての反射をオフにし、赤の発光色を付けました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fb/e49/860/2fbe498604cc4cc4ed6ee60a45eea63d.png" width="320" height="284" alt="色"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/b46/483/0ebb4648376a7fe68c96b7a16ce27db9.png" width="320" height="56" alt="反射なし"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レーザービームの材質。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レーザービームにコライダーがないことを確認し、キャストとシャドウをオフにします。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/f21/0ad/ecff210ad75ef4b12cb0a74102365492.png" width="320" height="162"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レーザービームは影と相互作用しません。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タワープレハブの作成が完了したら、それを工場に追加します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/626/37c/935/62637c9353cf1e20e170e82bbefcdb11.png" width="320" height="114"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">塔のある工場。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タワー配置</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の切り替え方法を使用してタワーを追加および削除します。</font></font><code>GameBoard.ToggleWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド名とコンテンツタイプを変更</font><font style="vertical-align: inherit;">するだけで複製でき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ToggleTower</span> (<span class="hljs-params">GameTile tile</span>)</span> {
		<span class="hljs-keyword">if</span> (tile.Content.Type == GameTileContentType.Tower€) {<font></font>
			tile.Content = contentFactory.Get(GameTileContentType.Empty);<font></font>
			FindPaths();<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tile.Content.Type == GameTileContentType.Empty) {<font></font>
			tile.Content = contentFactory.Get(GameTileContentType.Tower€);<font></font>
			<span class="hljs-keyword">if</span> (!FindPaths()) {<font></font>
				tile.Content = contentFactory.Get(GameTileContentType.Empty);<font></font>
				FindPaths();<font></font>
			}<font></font>
		}<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とき</font></font><code>Game.HandleTouch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたは、Shiftキーを押しながら、塔は、ない壁を切り替えます。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleTouch</span> (<span class="hljs-params"></span>)</span> {<font></font>
		GameTile tile = board.GetTile(TouchRay);<font></font>
		<span class="hljs-keyword">if</span> (tile != <span class="hljs-literal">null</span>) {
			<span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.LeftShift)) {<font></font>
				board.ToggleTower(tile);<font></font>
			}<font></font>
			<span class="hljs-keyword">else</span> {<font></font>
				board.ToggleWall(tile);<font></font>
			}<font></font>
		}<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/926/804/2ac/9268042acc19a28d6ff1a6d74d83144f.png" width="230" height="230"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールドの塔。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パスブロッキング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、壁のみがパスの検索をブロックできるため、敵はタワーを移動します。</font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツがパスをブロックしているかどうかを示すヘルパープロパティを</font><font style="vertical-align: inherit;">追加しましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">壁や塔の場合、通路は塞がれています。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> BlocksPath =&gt;<font></font>
		Type == GameTileContentType.Wall || Type == GameTileContentType.Tower€;</code></pre><br><font style="vertical-align: inherit;"></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツのタイプをチェックする代わりに、</font><font style="vertical-align: inherit;">
このプロパティを使用します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function">GameTile <span class="hljs-title">GrowPathTo</span> (<span class="hljs-params">GameTile neighbor, Direction direction</span>)</span> {<font></font>
		…<font></font>
		<span class="hljs-keyword">return</span>
			<span class="hljs-comment">//neighbor.Content.Type != GameTileContentType.Wall ? neighbor : null;</span>
			neighbor.Content.BlocksPath ? <span class="hljs-literal">null</span> : neighbor;<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/93f/eed/6fa93feedb4925ee12decb4233612a4c.png" width="230" height="230"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在、通路は壁と塔によって塞がれています。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">壁を交換してください</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、プレーヤーはしばしば壁を塔に交換します。</font><font style="vertical-align: inherit;">彼が最初に壁を取り除くのは不便であり、さらに敵はこの一時的な隙間に侵入することができます。</font></font><code>GameBoard.ToggleTower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">壁が現在タイル上にあるかどうかを</font><font style="vertical-align: inherit;">強制的</font><font style="vertical-align: inherit;">に確認</font><font style="vertical-align: inherit;">することにより、直接置換を実装できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">その場合は、すぐにタワーと交換してください。</font><font style="vertical-align: inherit;">この場合、タイルがまだそれらをブロックしているため、他の方法を探す必要はありません。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ToggleTower</span> (<span class="hljs-params">GameTile tile</span>)</span> {
		<span class="hljs-keyword">if</span> (tile.Content.Type == GameTileContentType.Tower) {<font></font>
			tile.Content = contentFactory.Get(GameTileContentType.Empty);<font></font>
			FindPaths();<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tile.Content.Type == GameTileContentType.Empty) {<font></font>
			…<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tile.Content.Type == GameTileContentType.Wall) {<font></font>
			tile.Content = contentFactory.Get(GameTileContentType.Tower);<font></font>
		}<font></font>
	}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵を狙う</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タワーは、敵を見つけた場合にのみそのタスクを実行できます。</font><font style="vertical-align: inherit;">敵を見つけた後、彼女はそれのどの部分を狙うべきか決定しなければなりません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">照準ポイント</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ターゲットを検出するために、物理エンジンを使用します。タワーコライダーの場合のように、敵のコライダーが必ずしもその形状と一致する必要はありません。最も単純なコライダー、つまり球を選択できます。敵を検出したら、コライダーを取り付けたゲームオブジェクトの位置を照準のポイントとして使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コライダーを敵のルートオブジェクトに接続することはできません。これは、モデルの位置と常に一致するわけではなく、塔を地面に向けさせるためです。つまり、コライダーをモデルのどこかに配置する必要があります。物理エンジンは、このオブジェクトへのリンクを提供します。これは、照準に使用できますが、</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルートオブジェクトの</font><font style="vertical-align: inherit;">コンポーネントへのアクセスが必要です</font><font style="vertical-align: inherit;">。タスクを簡略化するために、コンポーネントを作成しましょう</font></font><code>TargetPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">コンポーネントのプライベート割り当てとパブリックレシートの</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティと、世界での位置を取得するための別のプロパティを</font><font style="vertical-align: inherit;">与えましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TargetPoint</span> : <span class="hljs-title">MonoBehaviour</span> {<font></font>
<font></font>
	<span class="hljs-keyword">public</span> Enemy Enemy€ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
	<span class="hljs-keyword">public</span> Vector3 Position =&gt; transform.position;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントへの参照を設定</font><font style="vertical-align: inherit;">
するメソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">与えましょう</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">でルートオブジェクトに直接移動し</font></font><code>transform.root</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">コンポーネント</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が存在しない</font><font style="vertical-align: inherit;">場合は</font><font style="vertical-align: inherit;">、敵を作成するときにミスを犯したので、そのためのステートメントを追加しましょう。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span> (<span class="hljs-params"></span>)</span> {<font></font>
		Enemy€ = transform.root.GetComponent&lt;Enemy&gt;();<font></font>
		Debug.Assert(Enemy€ != <span class="hljs-literal">null</span>, <span class="hljs-string">"Target point without Enemy root!"</span>, <span class="hljs-keyword">this</span>);<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、コライダーは、コライダーと同じゲームオブジェクトにアタッチする必要があります</font></font><code>TargetPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">		Debug.Assert(Enemy€ != <span class="hljs-literal">null</span>, <span class="hljs-string">"Target point without Enemy root!"</span>, <span class="hljs-keyword">this</span>);<font></font>
		Debug.Assert(<font></font>
			GetComponent&lt;SphereCollider&gt;() != <span class="hljs-literal">null</span>,
			<span class="hljs-string">"Target point without sphere collider!"</span>, <span class="hljs-keyword">this</span>
		);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントとコライダーを敵のプレハブキューブに追加します。</font><font style="vertical-align: inherit;">これにより、塔が立方体の中心を狙います。</font><font style="vertical-align: inherit;">半径0.25の球形コライダーを使用します。</font><font style="vertical-align: inherit;">立方体のスケールは0.5なので、コライダーの実際の半径は0.125になります。</font><font style="vertical-align: inherit;">これのおかげで、敵は塔の射程円を視覚的に横切る必要があり、しばらくしてから実際の目標が達成されます。</font><font style="vertical-align: inherit;">コライダーのサイズは敵のランダムなスケールにも影響されるため、ゲーム内のサイズも若干異なります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85e/5ca/5e4/85e5ca5e47b8d59fa4211c78126bd512.png" width="176" height="176"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/a71/aec/7aea71aecbd64d4e045df141ecd1c711.png" width="320" height="176" alt="検査官"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューブ上の照準点とコライダーを持つ敵。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵レイヤー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タワーは敵のみを対象としており、他の目的を目指していないため、すべての敵を別のレイヤーに配置します。</font><font style="vertical-align: inherit;">レイヤー9を使用し</font><font style="vertical-align: inherit;">ます。[ </font><em><font style="vertical-align: inherit;">レイヤー＆タグ]</font></em><font style="vertical-align: inherit;">ウィンドウで</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の名前を変更</font><font style="vertical-align: inherit;">します</font><font style="vertical-align: inherit;">。これは、エディターの右上隅にある</font><font style="vertical-align: inherit;">[ </font><em><font style="vertical-align: inherit;">レイヤーの編集</font></em><font style="vertical-align: inherit;"> ]ドロップダウンメニュー[ </font><em><font style="vertical-align: inherit;">レイヤー</font></em><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">オプションから開くことができます</font><font style="vertical-align: inherit;">。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e6/9a5/762/8e69a5762e8eb1856175f9d9dc1ab388.png" width="320" height="308"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイヤー9は敵に使用されます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このレイヤーは、敵を認識するためにのみ必要であり、物理的な相互作用には必要ありません。</font><font style="vertical-align: inherit;">プロジェクトパラメータの</font><font style="vertical-align: inherit;">[ </font><em><font style="vertical-align: inherit;">Physics</font></em><font style="vertical-align: inherit;"> ]パネルにある</font><font style="vertical-align: inherit;">[ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Layer Collision Matrix]</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">それらを無効にして、それを指摘してみましょう</font><font style="vertical-align: inherit;">。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/876/06e/e7d/87606ee7dfc4777760d81219517125ce.png" width="200" height="200"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイヤー衝突のマトリックス。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
照準のゲームオブジェクトが目的のレイヤー上にあることを確認してください。</font><font style="vertical-align: inherit;">敵の残りのプレハブは他のレイヤーにある場合がありますが、すべてを調整して、プレハブ全体を</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイヤーに配置する方が簡単</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">ルートオブジェクトのレイヤーを変更すると、そのすべての子オブジェクトのレイヤーを変更するように求められます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/f75/062/6d1f75062420abadb285e9efca1e1a5e.png" width="320" height="44"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">右のレイヤーの敵。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が</font></font><code>TargetPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本当に正しいレイヤーにある</font><font style="vertical-align: inherit;">かについてのステートメントを追加しましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		Debug.Assert(gameObject.layer == <span class="hljs-number">9</span>, <span class="hljs-string">"Target point on wrong layer!"</span>, <span class="hljs-keyword">this</span>);<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、敵のコライダーはプレーヤーのアクションを無視する必要があります。</font><font style="vertical-align: inherit;">これは、レイヤーマスク引数を</font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">追加することで実現できます</font></font><code>GameBoard.GetTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このメソッドには、レイとレイヤーマスクまでの距離を追加の引数として取るフォームがあります。</font><font style="vertical-align: inherit;">デフォルトで最大距離とレイヤーマスクを与えましょう、すなわち1。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> GameTile <span class="hljs-title">GetTile</span> (<span class="hljs-params">Ray ray</span>)</span> {
		<span class="hljs-keyword">if</span> (Physics.Raycast(ray, <span class="hljs-keyword">out</span> RaycastHit hit, <span class="hljs-keyword">float</span>.MaxValue, <span class="hljs-number">1</span>)) {<font></font>
			…<font></font>
		}<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
	}</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイヤーマスクは0にすべきではありませんか？</font></font></b><div class="spoiler_text">     ,     .        1,    .        ,    ,  , 2<sup>0</sup>,   1.</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイルコンテンツの更新</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タワーは、ステータスが更新されたときにのみタスクを実行できます。</font><font style="vertical-align: inherit;">同じことがタイル全体のコンテンツにも当てはまりますが、残りのコンテンツはこれまで何もしません。</font><font style="vertical-align: inherit;">したがって、</font><font style="vertical-align: inherit;">デフォルトでは何もしない</font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想メソッドに</font><font style="vertical-align: inherit;">追加し</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {}</code></pre><br><font style="vertical-align: inherit;"></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今のところ、ターゲットを探していることをコンソールに表示するだけの場合でも、</font><font style="vertical-align: inherit;">
強制的</font><font style="vertical-align: inherit;">に再定義します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {<font></font>
		Debug.Log(<span class="hljs-string">"Searching for target..."</span>);<font></font>
	}</code></pre><br>
<code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はタイルとそのコンテンツを処理するため、更新が必要なコンテンツを追跡します。</font><font style="vertical-align: inherit;">これを行うに</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、リストとリスト内のすべてを更新</font><font style="vertical-align: inherit;">するパブリックメソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">リストに追加</font><font style="vertical-align: inherit;">します。</font></font><br>
<br>
<pre><code class="cs hljs">	List&lt;GameTileContent&gt; updatingContent = <span class="hljs-keyword">new</span> List&lt;GameTileContent&gt;();<font></font>
	<font></font>
	…<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; updatingContent.Count; i++) {<font></font>
			updatingContent[i].GameUpdate();<font></font>
		}<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このチュートリアルでは、タワーを更新するだけで済みます。</font></font><code>ToggleTower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要に応じてコンテンツを追加および削除するように</font><font style="vertical-align: inherit;">変更してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他のコンテンツが必要な場合は、より一般的なアプローチが必要になりますが、現時点ではこれで十分です。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ToggleTower</span> (<span class="hljs-params">GameTile tile</span>)</span> {
		<span class="hljs-keyword">if</span> (tile.Content.Type == GameTileContentType.Tower) {<font></font>
			updatingContent.Remove(tile.Content);<font></font>
			tile.Content = contentFactory.Get(GameTileContentType.Empty);<font></font>
			FindPaths();<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tile.Content.Type == GameTileContentType.Empty) {<font></font>
			tile.Content = contentFactory.Get(GameTileContentType.Tower);<font></font>
			<span class="hljs-comment">//if (!FindPaths()) {</span>
			<span class="hljs-keyword">if</span> (FindPaths()) {<font></font>
				updatingContent.Add(tile.Content);<font></font>
			}<font></font>
			<span class="hljs-keyword">else</span> {<font></font>
				tile.Content = contentFactory.Get(GameTileContentType.Empty);<font></font>
				FindPaths();<font></font>
			}<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tile.Content.Type == GameTileContentType.Wall) {<font></font>
			tile.Content = contentFactory.Get(GameTileContentType.Tower);<font></font>
			updatingContent.Add(tile.Content);<font></font>
		}<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが機能するためには、単にのフィールドを更新するだけで十分です</font></font><code>Game.Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">敵の後にフィールドを更新します。</font><font style="vertical-align: inherit;">これのおかげで、塔は敵がいる場所を正確に狙うことができます。</font><font style="vertical-align: inherit;">もしそうでなければ、タワーは敵が最後のフレームにいた場所を狙います。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		enemies.GameUpdate();<font></font>
		board.GameUpdate();<font></font>
	}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">照準範囲</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タワーの照準範囲は限られています。</font><font style="vertical-align: inherit;">クラスにフィールドを追加して、カスタムにし</font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">距離はタワータイルの中心から測定されるため、0.5の範囲では、自身のタイルのみをカバーします。</font><font style="vertical-align: inherit;">したがって、妥当な最小および標準範囲は1.5であり、ほとんどの隣接タイルをカバーします。</font></font><br>
<br>
<pre><code class="cs hljs">	[<span class="hljs-meta">SerializeField, Range(1.5f, 10.5f)</span>]
	<span class="hljs-keyword">float</span> targetingRange = <span class="hljs-number">1.5f</span>;</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/ae4/ee8/c38ae4ee885cf5d89f24164b9c6bc5fe.png" width="320" height="74"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">照準範囲2.5。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ギズモで範囲を視覚化しましょう。</font><font style="vertical-align: inherit;">常に表示する必要はない</font></font><code>OnDrawGizmosSelected</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、選択したオブジェクトに対してのみ呼び出される</font><font style="vertical-align: inherit;">メソッドを作成し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">半径を距離に等しく、タワーを中心にして、球の黄色のフレームを描画します。</font><font style="vertical-align: inherit;">常にはっきりと見えるように、地面の少し上に置きます。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmosSelected</span> (<span class="hljs-params"></span>)</span> {<font></font>
		Gizmos.color = Color.yellow;<font></font>
		Vector3 position = transform.localPosition;<font></font>
		position.y += <span class="hljs-number">0.01f</span>;<font></font>
		Gizmos.DrawWireSphere(position, targetingRange);<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/6b7/3cd/6746b73cd2e015fd599b770bb89e1c8a.png" width="230" height="230"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ギズモの照準範囲。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、各タワーの手ごろな価格のターゲットである敵を確認できます。</font><font style="vertical-align: inherit;">ただし、シーンウィンドウでタワーを選択するのは不便です。子キューブの1つを選択してから、タワーのルートオブジェクトに切り替える必要があるためです。</font><font style="vertical-align: inherit;">他のタイプのタイルコンテンツにも同じ問題があります。</font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性に</font><font style="vertical-align: inherit;">追加することで、シーンウィンドウのタイルコンテンツのルートを強制でき</font><font style="vertical-align: inherit;">ます</font></font><code>SelectionBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">SelectionBase</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameTileContent</span> : <span class="hljs-title">MonoBehaviour</span> { … }</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ターゲットキャプチャ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャプチャされたターゲットを追跡できるように、</font><font style="vertical-align: inherit;">
クラスに</font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールド</font></font><code>TargetPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">追加し</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に</font><font style="vertical-align: inherit;">、ターゲットが見つかったかどうかに関する情報を返す</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいメソッド</font></font><code>AquireTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出すよう</font><font style="vertical-align: inherit;">に変更</font><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">検出すると、コンソールにメッセージが表示されます。</font></font><br>
<br>
<pre><code class="cs hljs">	TargetPoint target;<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {
		<span class="hljs-keyword">if</span> (AcquireTarget()) {<font></font>
			Debug.Log(<span class="hljs-string">"Acquired target!"</span>);<font></font>
		}<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タワーとレンジの位置を引数として</font></font><code>AcquireTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出し</font></font><code>Physics.OverlapSphere</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て、</font><font style="vertical-align: inherit;">使用可能なすべてのターゲット</font><font style="vertical-align: inherit;">
を</font><font style="vertical-align: inherit;">取得します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">結果は</font></font><code>Collider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、球と接触しているすべてのコライダーを含む</font><font style="vertical-align: inherit;">配列になります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">配列の長さが正の場合、少なくとも1つの照準点があり、単純に最初の照準点を選択します。</font></font><code>TargetPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常に存在するはずの</font><font style="vertical-align: inherit;">コンポーネントを</font><font style="vertical-align: inherit;">受け取り、ターゲットフィールドに割り当てて、成功を報告します。</font><font style="vertical-align: inherit;">それ以外の場合は、ターゲットをクリアして失敗を報告します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">AcquireTarget</span> (<span class="hljs-params"></span>)</span> {<font></font>
		Collider[] targets = Physics.OverlapSphere(<font></font>
			transform.localPosition, targetingRange<font></font>
		);<font></font>
		<span class="hljs-keyword">if</span> (targets.Length &gt; <span class="hljs-number">0</span>) {<font></font>
			target = targets[<span class="hljs-number">0</span>].GetComponent&lt;TargetPoint&gt;();<font></font>
			Debug.Assert(target != <span class="hljs-literal">null</span>, <span class="hljs-string">"Targeted non-enemy!"</span>, targets[<span class="hljs-number">0</span>]);
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
		}<font></font>
		target = <span class="hljs-literal">null</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵のレイヤーでのみコライダーを考慮に入れると、正しい照準ポイントを取得できることが保証されます。</font><font style="vertical-align: inherit;">これはレイヤー9なので、対応するレイヤーマスクを渡します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> enemyLayerMask = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">9</span>;<font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">AcquireTarget</span> (<span class="hljs-params"></span>)</span> {<font></font>
		Collider[] targets = Physics.OverlapSphere(<font></font>
			transform.localPosition, targetingRange, enemyLayerMask<font></font>
		);<font></font>
		…<font></font>
	}</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このビットマスクはどのように機能しますか？</font></font></b><div class="spoiler_text">      9,        1.     2<sup>9</sup>,   512.      .      ,  <code>0b10_0000_0000</code>,      .            <code>&lt;&lt;</code>,   .      .</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
塔の位置とターゲットの間にギズモ線を引くことで、キャプチャしたターゲットを視覚化できます。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmosSelected</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		<span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) {<font></font>
			Gizmos.DrawLine(position, target.Position);<font></font>
		}<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e99/4be/7a5e994be6b7d848c2d4bfe7d627c708.png" width="230" height="230"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目標の視覚化。</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnTriggerEnterなどのメソッドを使用しないのはなぜですか？</font></font></b><div class="spoiler_text">        ,        .     ,      .  ,                 ,   .</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ターゲットロック</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャプチャするために選択されるターゲットは、物理エンジンによって表される順序に依存します。つまり、実際には任意です。</font><font style="vertical-align: inherit;">したがって、キャプチャされたターゲットが理由もなく変化しているように見えます。</font><font style="vertical-align: inherit;">タワーがターゲットを受け取った後、彼女が彼女のものを追跡し、別のものに切り替えるのではなく、より論理的です。</font></font><code>TrackTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのような追跡を実装し</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">成功したかどうかに関する情報を返す</font><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">追加</font><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">まず、ターゲットが捕獲されたかどうかをお知らせします。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">TrackTarget</span> (<span class="hljs-params"></span>)</span> {
		<span class="hljs-keyword">if</span> (target == <span class="hljs-literal">null</span>) {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
		}<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドをで呼び出し、</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falseを返す場合にのみ呼び出します</font></font><code>AcquireTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。メソッドがtrueを返した場合、目標があります。これは</font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、OR演算子を</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">して</font><font style="vertical-align: inherit;">両方のメソッド呼び出しをチェック</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">ことで実行できます。</font><font style="vertical-align: inherit;">最初のオペランドがを返した</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、2番目の</font><font style="vertical-align: inherit;">オペランドは</font><font style="vertical-align: inherit;">チェックされず、呼び出しが失敗するためです。 AND演算子も同様に機能します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {
		<span class="hljs-keyword">if</span> (TrackTarget() || AcquireTarget()) {<font></font>
			Debug.Log(<span class="hljs-string">"Locked on target!"</span>);<font></font>
		}<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ec/27c/0a2/8ec27c0a2201434cba3725621b68aaa1.png" width="230" height="230"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目標の追跡。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
その結果、塔は終点に到達して破壊されるまでターゲットに固定されます。敵を繰り返し使用する場合は、代わりに、一連の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト管理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チュートリアルで処理された図へのリンクと同様に、リンクの正確性を確認する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ターゲットが範囲内にあるときにのみターゲットを追跡するに</font></font><code>TrackTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、タワーとターゲット間の距離を追跡する必要</font><font style="vertical-align: inherit;">があります</font><font style="vertical-align: inherit;">。範囲値を超える場合、ターゲットをリセットしてfalseを返す必要があります。このチェックにはメソッドを使用できます</font></font><code>Vector3.Distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">TrackTarget</span> (<span class="hljs-params"></span>)</span> {
		<span class="hljs-keyword">if</span> (target == <span class="hljs-literal">null</span>) {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
		}<font></font>
		Vector3 a = transform.localPosition;<font></font>
		Vector3 b = target.Position;<font></font>
		<span class="hljs-keyword">if</span> (Vector3.Distance(a, b) &gt; targetingRange) {<font></font>
			target = <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
		}<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、このコードはコライダーの半径を考慮していません。</font><font style="vertical-align: inherit;">したがって、結果として、タワーはターゲットを失い、それを再びキャプチャし、次のフレームでそれを追跡するのをやめるだけです。</font><font style="vertical-align: inherit;">コライダーの半径を範囲に追加することで、これを回避できます。</font></font><br>
<br>
<pre><code class="cs hljs">		<span class="hljs-keyword">if</span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number">0.125f</span>) { … }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、正しい結果が得られます。ただし、敵のスケールが変更されていない場合のみです。</font><font style="vertical-align: inherit;">各敵にはランダムなスケールを与えるので、範囲を変更するときはそれを考慮する必要があります。</font><font style="vertical-align: inherit;">これを行うには、与えられたスケールを記憶</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、getterプロパティを使用してそれを開く</font><font style="vertical-align: inherit;">必要があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Scale { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Initialize</span> (<span class="hljs-params"><span class="hljs-keyword">float</span> scale, <span class="hljs-keyword">float</span> speed, <span class="hljs-keyword">float</span> pathOffset</span>)</span> {<font></font>
		Scale = scale;<font></font>
		…<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、</font></font><code>Tower.TrackTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正しい範囲を</font><font style="vertical-align: inherit;">チェックインでき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs">		<span class="hljs-keyword">if</span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number">0.125f</span> * target.Enemy€.Scale) { … }</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物理を同期します</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてがうまく機能しているように見えますが、フィールドの中心を狙うことができるタワーは、範囲外にあるはずのターゲットをキャプチャできます。これらの目標を追跡することはできないため、1つのフレームに対してのみ固定されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e91/0a1/836/e910a1836ef729d95ebee121a67c3f2c.png" width="230" height="230"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不適切な照準。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、物理エンジンの状態がゲームの状態と不完全に同期しているために発生します。</font><font style="vertical-align: inherit;">すべての敵のインスタンスは、フィールドの中心と一致する世界の原点で作成されます。</font><font style="vertical-align: inherit;">次に、それらを作成のポイントに移動しますが、物理エンジンはすぐにそれを知りません。</font><font style="vertical-align: inherit;">値を</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
割り当てることによってオブジェクト変換を変更するときに実行されるインスタント同期を有効にすることができ</font></font><code>Physics.autoSyncTransforms</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、デフォルトでは無効になっています。これは、必要に応じてすべてを同期する方がはるかに効率的であるためです。</font><font style="vertical-align: inherit;">私たちのケースでは、同期はタワーの状態を更新するときにのみ必要です。</font><font style="vertical-align: inherit;">それを実行して、</font></font><code>Physics.SyncTransforms</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵の更新とフィールドの更新の間</font><font style="vertical-align: inherit;">に発生させることができ</font><font style="vertical-align: inherit;">ます</font></font><code>Game.Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		enemies.GameUpdate();<font></font>
		Physics.SyncTransforms();<font></font>
		board.GameUpdate();<font></font>
	}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高さを無視する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、ゲームプレイは2Dで行われます。</font><font style="vertical-align: inherit;">したがって、それを変更し</font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て、照準および追跡時にX座標とZ座標のみが考慮されるようにします。物理エンジンは3D空間で機能しますが、基本的には</font></font><code>AcquireTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2D </font><font style="vertical-align: inherit;">チェックを実行できます。</font><font style="vertical-align: inherit;">垂直位置。</font><font style="vertical-align: inherit;">これは、球の代わりにカプセルを使用して行うことができます。その2番目のポイントは、地上のいくつかのユニット（たとえば3つ）になります。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">AcquireTarget</span> (<span class="hljs-params"></span>)</span> {<font></font>
		Vector3 a = transform.localPosition;<font></font>
		Vector3 b = a;<font></font>
		b.y += <span class="hljs-number">3f</span>;<font></font>
		Collider[] targets = Physics.OverlapCapsule(<font></font>
			a, b, targetingRange, enemyLayerMask<font></font>
		);<font></font>
		…<font></font>
	}</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物理的な2Dエンジンを使用することはできませんか？</font></font></b><div class="spoiler_text">  ,       XZ,   2D-    XY.     ,     ,    2D-   .     3D-.</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、変更する必要があります</font></font><code>TrackTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">もちろん、2Dベクトルとを使用できます</font></font><code>Vector2.Distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、計算は自分で行い、代わりに距離の2乗を比較します。これで十分です。</font><font style="vertical-align: inherit;">したがって、平方根を計算する操作を取り除きます。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">TrackTarget</span> (<span class="hljs-params"></span>)</span> {
		<span class="hljs-keyword">if</span> (target == <span class="hljs-literal">null</span>) {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
		}<font></font>
		Vector3 a = transform.localPosition;<font></font>
		Vector3 b = target.Position;<font></font>
		<span class="hljs-keyword">float</span> x = a.x - b.x;
		<span class="hljs-keyword">float</span> z = a.z - b.z;
		<span class="hljs-keyword">float</span> r = targetingRange + <span class="hljs-number">0.125f</span> * target.Enemy€.Scale;
		<span class="hljs-keyword">if</span> (x * x + z * z &gt; r * r) {<font></font>
			target = <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
		}<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
	}</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの数学計算はどのように機能しますか？</font></font></b><div class="spoiler_text">    2D-   ,     .     ,       .  ,        ,    .</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリの割り当てを避ける</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを使用するデメリット</font></font><code>Physics.OverlapCapsule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、呼び出しごとに新しい配列が割り当てられることです。</font><font style="vertical-align: inherit;">これは、配列を一度割り当て</font></font><code>OverlapCapsuleNonAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、追加の引数として配列を使用して</font><font style="vertical-align: inherit;">代替メソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出すことで回避でき</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">送信される配列の長さが結果の数を決定します。</font><font style="vertical-align: inherit;">アレイ外のすべての潜在的なターゲットは破棄されます。</font><font style="vertical-align: inherit;">とにかく、最初の要素のみを使用するので、長さ1の配列で十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列の代わりに、</font></font><code>OverlapCapsuleNonAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発生した衝突の数を最大許容数</font><font style="vertical-align: inherit;">まで</font><font style="vertical-align: inherit;">返します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、配列の長さの代わりに確認する数です。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">static</span> Collider[] targetsBuffer = <span class="hljs-keyword">new</span> Collider[<span class="hljs-number">1</span>];<font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">AcquireTarget</span> (<span class="hljs-params"></span>)</span> {<font></font>
		Vector3 a = transform.localPosition;<font></font>
		Vector3 b = a;<font></font>
		b.y += <span class="hljs-number">2f</span>;
		<span class="hljs-keyword">int</span> hits = Physics.OverlapCapsuleNonAlloc(<font></font>
			a, b, targetingRange, targetsBuffer, enemyLayerMask<font></font>
		);<font></font>
		<span class="hljs-keyword">if</span> (hits &gt; <span class="hljs-number">0</span>) {<font></font>
			target = targetsBuffer[<span class="hljs-number">0</span>].GetComponent&lt;TargetPoint&gt;();<font></font>
			Debug.Assert(target != <span class="hljs-literal">null</span>, <span class="hljs-string">"Targeted non-enemy!"</span>, targetsBuffer[<span class="hljs-number">0</span>]);
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
		}<font></font>
		target = <span class="hljs-literal">null</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
	}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵を狙う</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで本当の目標ができたので、今度はそれを撮影します。</font><font style="vertical-align: inherit;">射撃には、照準、レーザーショット、ダメージの付与が含まれます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タレットを狙う</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タレットをターゲットに向けるには、クラス</font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タレット</font><font style="vertical-align: inherit;">コンポーネントへのリンクが必要です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このための構成フィールドを追加して、タワープレハブに接続します。</font></font><br>
<br>
<pre><code class="cs hljs">	[<span class="hljs-meta">SerializeField</span>]<font></font>
	Transform turret = <span class="hljs-keyword">default</span>;</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/3be/41b/e0f3be41b0936993268316b8f01e1f67.png" width="320" height="90"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付属の砲塔。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際のターゲットがある</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、それを撮影する必要があります。</font><font style="vertical-align: inherit;">シューティングコードを別のメソッドに配置します。</font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">照準を引数として</font><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出し、ターゲットに向かって砲塔を回転させ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {
		<span class="hljs-keyword">if</span> (TrackTarget() || AcquireTarget()) {
			<span class="hljs-comment">//Debug.Log("Locked on target!");</span><font></font>
			Shoot();<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Shoot</span> (<span class="hljs-params"></span>)</span> {<font></font>
		Vector3 point = target.Position;<font></font>
		turret.LookAt(point);<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/5bb/e9d/00e5bbe9d98e739800bf47435ca574af.png" width="230" height="230"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">狙ってるだけ。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レーザーを発射します</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レーザービームを配置するには、クラス</font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">へのリンクも必要です。</font></font><br>
<br>
<pre><code class="cs hljs">	[<span class="hljs-meta">SerializeField</span>]<font></font>
	Transform turret = <span class="hljs-keyword">default</span>, laserBeam = <span class="hljs-keyword">default</span>;</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/c9c/86e/802c9c86eac24112cb2b4f072fd0f410.png" width="320" height="110"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レーザービームを接続しました。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
立方体を実際のレーザービームに変えるには、3つの手順を実行する必要があります。</font><font style="vertical-align: inherit;">まず、その向きはタレットの向きに対応している必要があります。</font><font style="vertical-align: inherit;">これは、その回転をコピーすることで実行できます。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Shoot</span> (<span class="hljs-params"></span>)</span> {<font></font>
		Vector3 point = target.Position;<font></font>
		turret.LookAt(point);<font></font>
		laserBeam.localRotation = turret.localRotation;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、レーザービームをスケーリングして、その長さがタレットの座標のローカル原点と照準点の間の距離に等しくなるようにします。</font><font style="vertical-align: inherit;">Z軸、つまりターゲットに向けられたローカル軸に沿ってスケーリングします。</font><font style="vertical-align: inherit;">XYで元のスケールを維持するために、タレットを目覚めさせる（目覚めさせる）ときに元のスケールを書き留めます。</font></font><br>
<br>
<pre><code class="cs hljs">	Vector3 laserBeamScale;<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span> (<span class="hljs-params"></span>)</span> {<font></font>
		laserBeamScale = laserBeam.localScale;<font></font>
	}<font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Shoot</span> (<span class="hljs-params"></span>)</span> {<font></font>
		Vector3 point = target.Position;<font></font>
		turret.LookAt(point);<font></font>
		laserBeam.localRotation = turret.localRotation;<font></font>
<font></font>
		<span class="hljs-keyword">float</span> d = Vector3.Distance(turret.position, point);<font></font>
		laserBeamScale.z = d;<font></font>
		laserBeam.localScale = laserBeamScale;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目に、レーザー光線を砲塔と照準点の間の中央に配置します。</font></font><br>
<br>
<pre><code class="cs hljs">		laserBeam.localScale = laserBeamScale;<font></font>
		laserBeam.localPosition =<font></font>
			turret.localPosition + <span class="hljs-number">0.5f</span> * d * laserBeam.forward;</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/d96/438/288d96438354bd732fd7a3bb84ead491.png" width="230" height="230"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レーザー撮影。</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レーザービームをタレットの子にすることはできませんか？</font></font></b><div class="spoiler_text">    ,         ,       forward.       ,     .     .</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、タレットがターゲットに固定されているときに機能します。</font><font style="vertical-align: inherit;">しかし、ターゲットがない場合、レーザーはアクティブなままです。</font><font style="vertical-align: inherit;">スケールを</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0に設定</font><font style="vertical-align: inherit;">することで、レーザーディスプレイをオフにできます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {
		<span class="hljs-keyword">if</span> (TrackTarget() || AcquireTarget()) {<font></font>
			Shoot();<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span> {<font></font>
			laserBeam.localScale = Vector3.zero;<font></font>
		}<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/8c8/c23/39b8c8c239e0936137c646f91a4197de.png" width="230" height="230"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイドルタワーは発砲しません。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵の健康</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、私たちのレーザービームは敵に触れるだけで、もはやそれらに影響を与えません。</font><font style="vertical-align: inherit;">レーザーが敵にダメージを与えることを確認する必要があります。</font><font style="vertical-align: inherit;">敵を瞬時に破壊したくないので</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、健康</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">財産を</font><font style="vertical-align: inherit;">あげ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ヘルスには任意の値を選択できるので、100にしましょう。ただし、大きな敵がより多くのヘルスを持っている方がより論理的であるため、これに係数を導入します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">float</span> Health { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
	<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Initialize</span> (<span class="hljs-params"><span class="hljs-keyword">float</span> scale, <span class="hljs-keyword">float</span> speed, <span class="hljs-keyword">float</span> pathOffset</span>)</span> {<font></font>
		…<font></font>
		Health = <span class="hljs-number">100f</span> * scale;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ダメージへの対処のサポートを追加するには</font></font><code>ApplyDamage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ヘルスからパラメーターを差し引く</font><font style="vertical-align: inherit;">パブリックメソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">追加</font><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">損傷は負ではないと想定するため、これについて説明を追加します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ApplyDamage</span> (<span class="hljs-params"><span class="hljs-keyword">float</span> damage</span>)</span> {<font></font>
		Debug.Assert(damage &gt;= <span class="hljs-number">0f</span>, <span class="hljs-string">"Negative damage applied."</span>);<font></font>
		Health -= damage;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵の体力がゼロになり次第、すぐに敵を排除することはしません。</font><font style="vertical-align: inherit;">最初は体力の消耗や敵の破壊をチェックし</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {
		<span class="hljs-keyword">if</span> (Health &lt;= <span class="hljs-number">0f</span>) {<font></font>
			OriginFactory.Reclaim(<span class="hljs-keyword">this</span>);
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
		}<font></font>
<font></font>
		…<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これのおかげで、すべてのタワーは基本的に同時に発射し、順番にではなく発射します。これにより、前のタワーが狙った敵を破壊した場合、他のターゲットに切り替えることができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">毎秒のダメージ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、レーザーがどれほどのダメージを与えるかを決定する必要があります。</font><font style="vertical-align: inherit;">これを行うに</font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、構成フィールドに</font><font style="vertical-align: inherit;">追加し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">レーザービームは継続的な損傷を与えるため、1秒あたりの損傷として表します。</font><font style="vertical-align: inherit;">私たちは、</font></font><code>Shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それを適用する</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対象の</font><font style="vertical-align: inherit;">コンポーネント</font><font style="vertical-align: inherit;">デルタ時間の乗算と。</font></font><br>
<br>
<pre><code class="cs hljs">	[<span class="hljs-meta">SerializeField, Range(1f, 100f)</span>]
	<span class="hljs-keyword">float</span> damagePerSecond = <span class="hljs-number">10f</span>;<font></font>
<font></font>
	…<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Shoot</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
<font></font>
		target.Enemy.ApplyDamage(damagePerSecond * Time.deltaTime);<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/886/18f/199/88618f199c9c08e7eaeb89b16083f545.png" width="320" height="128" alt="検査官"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/vt/sf/gkvtsfa1ya4igbsjagqhtnzu0wq.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各タワーのダメージは毎秒20ユニットです。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランダム照準</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
常に最初に利用可能なターゲットを選択するため、照準動作は、物理エンジンが交差するコライダーをチェックする順序に依存します。</font><font style="vertical-align: inherit;">この依存関係はあまりよくありません。詳細がわからないため、制御できないため、奇妙で一貫性がないように見えます。</font><font style="vertical-align: inherit;">多くの場合、この動作は集中した火災につながりますが、これは常に当てはまるわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
物理エンジンに完全に依存する代わりに、ランダム性を追加しましょう。</font><font style="vertical-align: inherit;">これは、コライダーが受け取る交差の数を、たとえば100まで増やすことで実現できます。おそらく、敵が密集しているフィールドですべての可能なターゲットを取得するには十分ではありませんが、照準を改善するにはこれで十分です。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">static</span> Collider[] targetsBuffer = <span class="hljs-keyword">new</span> Collider[<span class="hljs-number">100</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、最初の潜在的なターゲットを選択する代わりに、配列からランダムな要素を選択します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">AcquireTarget</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		<span class="hljs-keyword">if</span> (hits &gt; <span class="hljs-number">0</span>) {<font></font>
			target =<font></font>
				targetsBuffer[Random.Range(<span class="hljs-number">0</span>, hits)].GetComponent&lt;TargetPoint&gt;();<font></font>
			…<font></font>
		}<font></font>
		target = <span class="hljs-literal">null</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/lt/hi/nvlthij_ixh6lsxgwujtoipjwg4.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランダム照準。</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目標を選択するための他の基準を使用できますか？</font></font></b><div class="spoiler_text">, ,        .  ,      ,     .    .             .</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タワーディフェンスゲームでは、ようやくタワーが登場しました。</font><font style="vertical-align: inherit;">次のパートでは、ゲームはさらに最終的な形をとります。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja459052/index.html">比較方法：「すばらしい車」と「醜い小屋」、マーケティング調査とビッグデータ</a></li>
<li><a href="../ja459054/index.html">クリックのヒートマップ-サイトでのユーザーの行動</a></li>
<li><a href="../ja459062/index.html">モバイル＃305開発者向けの興味深い資料のダイジェスト（7月1〜7日）</a></li>
<li><a href="../ja459066/index.html">データベースの書き込みと読み取りのバランス</a></li>
<li><a href="../ja459068/index.html">Windows Server 2008 R2-王は死んでいる、王は長生きする</a></li>
<li><a href="../ja459074/index.html">ささいな喜び＃7：1つの価格で3つ-コンソールアニメーション、アルゴリズム、デバッグ</a></li>
<li><a href="../ja459078/index.html">CERNがオープンソースソフトウェアに切り替わりました-なぜですか？</a></li>
<li><a href="../ja459080/index.html">java.netのHttpUrlConnectionの機能</a></li>
<li><a href="../ja459082/index.html">誰がアイデティクスであり、虚偽の記憶がどのように機能するか、そして記憶についての3つの一般的な神話</a></li>
<li><a href="../ja459084/index.html">Google Home Hubについて、または130ユーロでフォトフレームを購入した方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>